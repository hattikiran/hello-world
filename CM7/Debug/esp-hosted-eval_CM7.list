
esp-hosted-eval_CM7.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .isr_vector   00000298  08000000  08000000  00010000  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  1 .text         00021b14  080002a0  080002a0  000102a0  2**4
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .rodata       00007314  08021db4  08021db4  00031db4  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  3 .ARM.extab    00000000  080290c8  080290c8  00040508  2**0
                  CONTENTS
  4 .ARM          00000008  080290c8  080290c8  000390c8  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  5 .preinit_array 00000000  080290d0  080290d0  00040508  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  6 .init_array   00000004  080290d0  080290d0  000390d0  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  7 .fini_array   00000004  080290d4  080290d4  000390d4  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  8 .data         00000508  24000000  080290d8  00040000  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  9 .bss          0004cbb8  24000508  080295e0  00040508  2**2
                  ALLOC
 10 ._threadx_heap 00032000  2404d0c0  2404d0c0  0004d0c0  2**0
                  ALLOC
 11 ._user_heap_stack 00000600  2407f0c0  2407f0c0  0004d0c0  2**0
                  ALLOC
 12 .nx_section   00007800  30000000  30000000  00050000  2**2
                  ALLOC
 13 .ARM.attributes 0000002e  00000000  00000000  00040508  2**0
                  CONTENTS, READONLY
 14 .debug_info   0013dfe3  00000000  00000000  00040536  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 15 .debug_abbrev 0001a283  00000000  00000000  0017e519  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 16 .debug_aranges 00004410  00000000  00000000  001987a0  2**3
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 17 .debug_ranges 00003638  00000000  00000000  0019cbb0  2**3
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 18 .debug_macro  00064008  00000000  00000000  001a01e8  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 19 .debug_line   000902fd  00000000  00000000  002041f0  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 20 .debug_str    001d5653  00000000  00000000  002944ed  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 21 .comment      00000050  00000000  00000000  00469b40  2**0
                  CONTENTS, READONLY
 22 .debug_frame  0000edc8  00000000  00000000  00469b90  2**2
                  CONTENTS, READONLY, DEBUGGING, OCTETS

Disassembly of section .text:

080002a0 <__do_global_dtors_aux>:
 80002a0:	b510      	push	{r4, lr}
 80002a2:	4c05      	ldr	r4, [pc, #20]	; (80002b8 <__do_global_dtors_aux+0x18>)
 80002a4:	7823      	ldrb	r3, [r4, #0]
 80002a6:	b933      	cbnz	r3, 80002b6 <__do_global_dtors_aux+0x16>
 80002a8:	4b04      	ldr	r3, [pc, #16]	; (80002bc <__do_global_dtors_aux+0x1c>)
 80002aa:	b113      	cbz	r3, 80002b2 <__do_global_dtors_aux+0x12>
 80002ac:	4804      	ldr	r0, [pc, #16]	; (80002c0 <__do_global_dtors_aux+0x20>)
 80002ae:	f3af 8000 	nop.w
 80002b2:	2301      	movs	r3, #1
 80002b4:	7023      	strb	r3, [r4, #0]
 80002b6:	bd10      	pop	{r4, pc}
 80002b8:	24000508 	.word	0x24000508
 80002bc:	00000000 	.word	0x00000000
 80002c0:	08021d9c 	.word	0x08021d9c

080002c4 <frame_dummy>:
 80002c4:	b508      	push	{r3, lr}
 80002c6:	4b03      	ldr	r3, [pc, #12]	; (80002d4 <frame_dummy+0x10>)
 80002c8:	b11b      	cbz	r3, 80002d2 <frame_dummy+0xe>
 80002ca:	4903      	ldr	r1, [pc, #12]	; (80002d8 <frame_dummy+0x14>)
 80002cc:	4803      	ldr	r0, [pc, #12]	; (80002dc <frame_dummy+0x18>)
 80002ce:	f3af 8000 	nop.w
 80002d2:	bd08      	pop	{r3, pc}
 80002d4:	00000000 	.word	0x00000000
 80002d8:	2400050c 	.word	0x2400050c
 80002dc:	08021d9c 	.word	0x08021d9c

080002e0 <_tx_initialize_low_level>:
    .thumb_func
_tx_initialize_low_level:
@
@    /* Disable interrupts during ThreadX initialization.  */
@
    CPSID   i
 80002e0:	b672      	cpsid	i
    STR     r1, [r0]                                @ Setup first unused memory pointer
#endif
@
@    /* Setup Vector Table Offset Register.  */
@
    MOV     r0, #0xE000E000                         @ Build address of NVIC registers
 80002e2:	f04f 20e0 	mov.w	r0, #3758153728	; 0xe000e000
    LDR     r1, =g_pfnVectors                           @ Pickup address of vector table
 80002e6:	4919      	ldr	r1, [pc, #100]	; (800034c <__tx_DBGHandler+0x4>)
    STR     r1, [r0, #0xD08]                        @ Set vector table address
 80002e8:	f8c0 1d08 	str.w	r1, [r0, #3336]	; 0xd08
@
@    /* Set system stack pointer from vector value.  */
@
    LDR     r0, =_tx_thread_system_stack_ptr        @ Build address of system stack pointer
 80002ec:	4818      	ldr	r0, [pc, #96]	; (8000350 <__tx_DBGHandler+0x8>)
    LDR     r1, =g_pfnVectors                           @ Pickup address of vector table
 80002ee:	4917      	ldr	r1, [pc, #92]	; (800034c <__tx_DBGHandler+0x4>)
    LDR     r1, [r1]                                @ Pickup reset stack pointer
 80002f0:	6809      	ldr	r1, [r1, #0]
    STR     r1, [r0]                                @ Save system stack pointer
 80002f2:	6001      	str	r1, [r0, #0]
@
@    /* Enable the cycle count register.  */
@
    LDR     r0, =0xE0001000                         @ Build address of DWT register
 80002f4:	4817      	ldr	r0, [pc, #92]	; (8000354 <__tx_DBGHandler+0xc>)
    LDR     r1, [r0]                                @ Pickup the current value
 80002f6:	6801      	ldr	r1, [r0, #0]
    ORR     r1, r1, #1                              @ Set the CYCCNTENA bit
 80002f8:	f041 0101 	orr.w	r1, r1, #1
    STR     r1, [r0]                                @ Enable the cycle count register
 80002fc:	6001      	str	r1, [r0, #0]
@
@    /* Configure SysTick for 100Hz clock, or 16384 cycles if no reference.  */
@
    MOV     r0, #0xE000E000                         @ Build address of NVIC registers
 80002fe:	f04f 20e0 	mov.w	r0, #3758153728	; 0xe000e000
    LDR     r1, =SYSTICK_CYCLES
 8000302:	4915      	ldr	r1, [pc, #84]	; (8000358 <__tx_DBGHandler+0x10>)
    STR     r1, [r0, #0x14]                         @ Setup SysTick Reload Value
 8000304:	6141      	str	r1, [r0, #20]
    MOV     r1, #0x7                                @ Build SysTick Control Enable Value
 8000306:	f04f 0107 	mov.w	r1, #7
    STR     r1, [r0, #0x10]                         @ Setup SysTick Control
 800030a:	6101      	str	r1, [r0, #16]
@
@    /* Configure handler priorities.  */
@
    LDR     r1, =0x00000000                         @ Rsrv, UsgF, BusF, MemM
 800030c:	f04f 0100 	mov.w	r1, #0
    STR     r1, [r0, #0xD18]                        @ Setup System Handlers 4-7 Priority Registers
 8000310:	f8c0 1d18 	str.w	r1, [r0, #3352]	; 0xd18

    LDR     r1, =0xFF000000                         @ SVCl, Rsrv, Rsrv, Rsrv
 8000314:	f04f 417f 	mov.w	r1, #4278190080	; 0xff000000
    STR     r1, [r0, #0xD1C]                        @ Setup System Handlers 8-11 Priority Registers
 8000318:	f8c0 1d1c 	str.w	r1, [r0, #3356]	; 0xd1c
                                                    @ Note: SVC must be lowest priority, which is 0xFF

    LDR     r1, =0x40FF0000                         @ SysT, PnSV, Rsrv, DbgM
 800031c:	490f      	ldr	r1, [pc, #60]	; (800035c <__tx_DBGHandler+0x14>)
    STR     r1, [r0, #0xD20]                        @ Setup System Handlers 12-15 Priority Registers
 800031e:	f8c0 1d20 	str.w	r1, [r0, #3360]	; 0xd20
                                                    @ Note: PnSV must be lowest priority, which is 0xFF
@
@    /* Return to caller.  */
@
    BX      lr
 8000322:	4770      	bx	lr

08000324 <__tx_BadHandler>:
@/* Define shells for each of the unused vectors.  */
@
    .global  __tx_BadHandler
    .thumb_func
__tx_BadHandler:
    B       __tx_BadHandler
 8000324:	f7ff bffe 	b.w	8000324 <__tx_BadHandler>

08000328 <__tx_HardfaultHandler>:
@ /* added to catch the hardfault */

    .global  __tx_HardfaultHandler
    .thumb_func
__tx_HardfaultHandler:
    B       __tx_HardfaultHandler
 8000328:	f7ff bffe 	b.w	8000328 <__tx_HardfaultHandler>

0800032c <__tx_SVCallHandler>:
@ /* added to catch the SVC */

    .global  __tx_SVCallHandler
    .thumb_func
__tx_SVCallHandler:
    B       __tx_SVCallHandler
 800032c:	f7ff bffe 	b.w	800032c <__tx_SVCallHandler>

08000330 <__tx_IntHandler>:
    .global  __tx_IntHandler
    .thumb_func
__tx_IntHandler:
@ VOID InterruptHandler (VOID)
@ {
    PUSH    {r0, lr}
 8000330:	b501      	push	{r0, lr}
@    /* BL <your C Function>.... */

#ifdef TX_ENABLE_EXECUTION_CHANGE_NOTIFY
    BL      _tx_execution_isr_exit              @ Call the ISR exit function
#endif
    POP     {r0, lr}
 8000332:	e8bd 4001 	ldmia.w	sp!, {r0, lr}
    BX      LR
 8000336:	4770      	bx	lr

08000338 <SysTick_Handler>:
    .thumb_func
SysTick_Handler:
@ VOID TimerInterruptHandler (VOID)
@ {
@
    PUSH    {r0, lr}
 8000338:	b501      	push	{r0, lr}
#ifdef TX_ENABLE_EXECUTION_CHANGE_NOTIFY
    BL      _tx_execution_isr_enter             @ Call the ISR enter function
#endif
    BL      _tx_timer_interrupt
 800033a:	f000 f891 	bl	8000460 <_tx_timer_interrupt>
#ifdef TX_ENABLE_EXECUTION_CHANGE_NOTIFY
    BL      _tx_execution_isr_exit              @ Call the ISR exit function
#endif
    POP     {r0, lr}
 800033e:	e8bd 4001 	ldmia.w	sp!, {r0, lr}
    BX      LR
 8000342:	4770      	bx	lr

08000344 <__tx_NMIHandler>:

@ /* NMI, DBG handlers */
    .global  __tx_NMIHandler
    .thumb_func
__tx_NMIHandler:
    B       __tx_NMIHandler
 8000344:	f7ff bffe 	b.w	8000344 <__tx_NMIHandler>

08000348 <__tx_DBGHandler>:

    .global  __tx_DBGHandler
    .thumb_func
__tx_DBGHandler:
    B       __tx_DBGHandler
 8000348:	f7ff bffe 	b.w	8000348 <__tx_DBGHandler>
    LDR     r1, =g_pfnVectors                           @ Pickup address of vector table
 800034c:	08000000 	.word	0x08000000
    LDR     r0, =_tx_thread_system_stack_ptr        @ Build address of system stack pointer
 8000350:	24031bc0 	.word	0x24031bc0
    LDR     r0, =0xE0001000                         @ Build address of DWT register
 8000354:	e0001000 	.word	0xe0001000
    LDR     r1, =SYSTICK_CYCLES
 8000358:	00493dff 	.word	0x00493dff
    LDR     r1, =0x40FF0000                         @ SysT, PnSV, Rsrv, DbgM
 800035c:	40ff0000 	.word	0x40ff0000

08000360 <_tx_thread_schedule>:
       from the first schedule request. Subsequent scheduling occurs
       from the PendSV handling routine below. */

    /* Clear the preempt-disable flag to enable rescheduling after initialization on Cortex-M targets.  */

    MOV     r0, #0                                  // Build value for TX_FALSE
 8000360:	f04f 0000 	mov.w	r0, #0
    LDR     r2, =_tx_thread_preempt_disable         // Build address of preempt disable flag
 8000364:	4a2a      	ldr	r2, [pc, #168]	; (8000410 <tx_thread_fpu_disable+0x2>)
    STR     r0, [r2, #0]                            // Clear preempt disable flag
 8000366:	6010      	str	r0, [r2, #0]

    /* Clear CONTROL.FPCA bit so VFP registers aren't unnecessarily stacked.  */

#ifdef __ARM_PCS_VFP
    MRS     r0, CONTROL                             // Pickup current CONTROL register
 8000368:	f3ef 8014 	mrs	r0, CONTROL
    BIC     r0, r0, #4                              // Clear the FPCA bit
 800036c:	f020 0004 	bic.w	r0, r0, #4
    MSR     CONTROL, r0                             // Setup new CONTROL register
 8000370:	f380 8814 	msr	CONTROL, r0
#endif

    /* Enable interrupts */
    CPSIE   i
 8000374:	b662      	cpsie	i

    /* Enter the scheduler for the first time.  */

    MOV     r0, #0x10000000                         // Load PENDSVSET bit
 8000376:	f04f 5080 	mov.w	r0, #268435456	; 0x10000000
    MOV     r1, #0xE000E000                         // Load NVIC base
 800037a:	f04f 21e0 	mov.w	r1, #3758153728	; 0xe000e000
    STR     r0, [r1, #0xD04]                        // Set PENDSVBIT in ICSR
 800037e:	f8c1 0d04 	str.w	r0, [r1, #3332]	; 0xd04
    DSB                                             // Complete all memory accesses
 8000382:	f3bf 8f4f 	dsb	sy
    ISB                                             // Flush pipeline
 8000386:	f3bf 8f6f 	isb	sy

0800038a <__tx_wait_here>:

    /* Wait here for the PendSV to take place.  */

__tx_wait_here:
    B       __tx_wait_here                          // Wait for the PendSV to happen
 800038a:	e7fe      	b.n	800038a <__tx_wait_here>

0800038c <PendSV_Handler>:
    BL      _tx_execution_thread_exit               // Call the thread exit function
    POP     {r0, lr}                                // Recover LR
    CPSIE   i                                       // Enable interrupts
#endif

    LDR     r0, =_tx_thread_current_ptr             // Build current thread pointer address
 800038c:	4821      	ldr	r0, [pc, #132]	; (8000414 <tx_thread_fpu_disable+0x6>)
    LDR     r2, =_tx_thread_execute_ptr             // Build execute thread pointer address
 800038e:	4a22      	ldr	r2, [pc, #136]	; (8000418 <tx_thread_fpu_disable+0xa>)
    MOV     r3, #0                                  // Build NULL value
 8000390:	f04f 0300 	mov.w	r3, #0
    LDR     r1, [r0]                                // Pickup current thread pointer
 8000394:	6801      	ldr	r1, [r0, #0]

    /* Determine if there is a current thread to finish preserving.  */

    CBZ     r1, __tx_ts_new                         // If NULL, skip preservation
 8000396:	b191      	cbz	r1, 80003be <__tx_ts_new>

    /* Recover PSP and preserve current thread context.  */

    STR     r3, [r0]                                // Set _tx_thread_current_ptr to NULL
 8000398:	6003      	str	r3, [r0, #0]
    MRS     r12, PSP                                // Pickup PSP pointer (thread's stack pointer)
 800039a:	f3ef 8c09 	mrs	ip, PSP
    STMDB   r12!, {r4-r11}                          // Save its remaining registers
 800039e:	e92c 0ff0 	stmdb	ip!, {r4, r5, r6, r7, r8, r9, sl, fp}
#ifdef __ARM_PCS_VFP
    TST     LR, #0x10                               // Determine if the VFP extended frame is present
 80003a2:	f01e 0f10 	tst.w	lr, #16
    BNE     _skip_vfp_save
 80003a6:	d101      	bne.n	80003ac <_skip_vfp_save>
    VSTMDB  r12!,{s16-s31}                          // Yes, save additional VFP registers
 80003a8:	ed2c 8a10 	vstmdb	ip!, {s16-s31}

080003ac <_skip_vfp_save>:
_skip_vfp_save:
#endif
    LDR     r4, =_tx_timer_time_slice               // Build address of time-slice variable
 80003ac:	4c1b      	ldr	r4, [pc, #108]	; (800041c <tx_thread_fpu_disable+0xe>)
    STMDB   r12!, {LR}                              // Save LR on the stack
 80003ae:	f84c ed04 	str.w	lr, [ip, #-4]!

    /* Determine if time-slice is active. If it isn't, skip time handling processing.  */

    LDR     r5, [r4]                                // Pickup current time-slice
 80003b2:	6825      	ldr	r5, [r4, #0]
    STR     r12, [r1, #8]                           // Save the thread stack pointer
 80003b4:	f8c1 c008 	str.w	ip, [r1, #8]
    CBZ     r5, __tx_ts_new                         // If not active, skip processing
 80003b8:	b10d      	cbz	r5, 80003be <__tx_ts_new>

    /* Time-slice is active, save the current thread's time-slice and clear the global time-slice variable.  */

    STR     r5, [r1, #24]                           // Save current time-slice
 80003ba:	618d      	str	r5, [r1, #24]

    /* Clear the global time-slice.  */

    STR     r3, [r4]                                // Clear time-slice
 80003bc:	6023      	str	r3, [r4, #0]

080003be <__tx_ts_new>:

__tx_ts_new:

    /* Now we are looking for a new thread to execute!  */

    CPSID   i                                       // Disable interrupts
 80003be:	b672      	cpsid	i
    LDR     r1, [r2]                                // Is there another thread ready to execute?
 80003c0:	6811      	ldr	r1, [r2, #0]
    CBZ     r1, __tx_ts_wait                        // No, skip to the wait processing
 80003c2:	b1b1      	cbz	r1, 80003f2 <__tx_ts_wait>

    /* Yes, another thread is ready for else, make the current thread the new thread.  */

    STR     r1, [r0]                                // Setup the current thread pointer to the new thread
 80003c4:	6001      	str	r1, [r0, #0]
    CPSIE   i                                       // Enable interrupts
 80003c6:	b662      	cpsie	i

080003c8 <__tx_ts_restore>:

    /* Increment the thread run count.  */

__tx_ts_restore:
    LDR     r7, [r1, #4]                            // Pickup the current thread run count
 80003c8:	684f      	ldr	r7, [r1, #4]
    LDR     r4, =_tx_timer_time_slice               // Build address of time-slice variable
 80003ca:	4c14      	ldr	r4, [pc, #80]	; (800041c <tx_thread_fpu_disable+0xe>)
    LDR     r5, [r1, #24]                           // Pickup thread's current time-slice
 80003cc:	698d      	ldr	r5, [r1, #24]
    ADD     r7, r7, #1                              // Increment the thread run count
 80003ce:	f107 0701 	add.w	r7, r7, #1
    STR     r7, [r1, #4]                            // Store the new run count
 80003d2:	604f      	str	r7, [r1, #4]

    /* Setup global time-slice with thread's current time-slice.  */

    STR     r5, [r4]                                // Setup global time-slice
 80003d4:	6025      	str	r5, [r4, #0]
    POP     {r0, r1}                                // Recover r0 and r1
#endif

    /* Restore the thread context and PSP.  */

    LDR     r12, [r1, #8]                           // Pickup thread's stack pointer
 80003d6:	f8d1 c008 	ldr.w	ip, [r1, #8]
    LDMIA   r12!, {LR}                              // Pickup LR
 80003da:	f85c eb04 	ldr.w	lr, [ip], #4
#ifdef __ARM_PCS_VFP
    TST     LR, #0x10                               // Determine if the VFP extended frame is present
 80003de:	f01e 0f10 	tst.w	lr, #16
    BNE     _skip_vfp_restore                       // If not, skip VFP restore
 80003e2:	d101      	bne.n	80003e8 <_skip_vfp_restore>
    VLDMIA  r12!, {s16-s31}                         // Yes, restore additional VFP registers
 80003e4:	ecbc 8a10 	vldmia	ip!, {s16-s31}

080003e8 <_skip_vfp_restore>:
_skip_vfp_restore:
#endif
    LDMIA   r12!, {r4-r11}                          // Recover thread's registers
 80003e8:	e8bc 0ff0 	ldmia.w	ip!, {r4, r5, r6, r7, r8, r9, sl, fp}
    MSR     PSP, r12                                // Setup the thread's stack pointer
 80003ec:	f38c 8809 	msr	PSP, ip

    /* Return to thread.  */

    BX      lr                                      // Return to thread!
 80003f0:	4770      	bx	lr

080003f2 <__tx_ts_wait>:
    /* The following is the idle wait processing... in this case, no threads are ready for execution and the
       system will simply be idle until an interrupt occurs that makes a thread ready. Note that interrupts
       are disabled to allow use of WFI for waiting for a thread to arrive.  */

__tx_ts_wait:
    CPSID   i                                       // Disable interrupts
 80003f2:	b672      	cpsid	i
    LDR     r1, [r2]                                // Pickup the next thread to execute pointer
 80003f4:	6811      	ldr	r1, [r2, #0]
    STR     r1, [r0]                                // Store it in the current pointer
 80003f6:	6001      	str	r1, [r0, #0]
    CBNZ    r1, __tx_ts_ready                       // If non-NULL, a new thread is ready!
 80003f8:	b909      	cbnz	r1, 80003fe <__tx_ts_ready>
    PUSH    {r0-r3}
    BL      tx_low_power_exit                       // Exit low power mode
    POP     {r0-r3}
#endif

    CPSIE   i                                       // Enable interrupts
 80003fa:	b662      	cpsie	i
    B       __tx_ts_wait                            // Loop to continue waiting
 80003fc:	e7f9      	b.n	80003f2 <__tx_ts_wait>

080003fe <__tx_ts_ready>:

    /* At this point, we have a new thread ready to go. Clear any newly pended PendSV - since we are
       already in the handler!  */

__tx_ts_ready:
    MOV     r7, #0x08000000                         // Build clear PendSV value
 80003fe:	f04f 6700 	mov.w	r7, #134217728	; 0x8000000
    MOV     r8, #0xE000E000                         // Build base NVIC address
 8000402:	f04f 28e0 	mov.w	r8, #3758153728	; 0xe000e000
    STR     r7, [r8, #0xD04]                        // Clear any PendSV
 8000406:	f8c8 7d04 	str.w	r7, [r8, #3332]	; 0xd04

    /* Re-enable interrupts and restore new thread.  */

    CPSIE   i                                       // Enable interrupts
 800040a:	b662      	cpsie	i
    B       __tx_ts_restore                         // Restore the thread
 800040c:	e7dc      	b.n	80003c8 <__tx_ts_restore>

0800040e <tx_thread_fpu_disable>:
tx_thread_fpu_disable:

    /* Automatic VPF logic is supported, this function is present only for
       backward compatibility purposes and therefore simply returns.  */

    BX      LR                                      // Return to caller
 800040e:	4770      	bx	lr
    LDR     r2, =_tx_thread_preempt_disable         // Build address of preempt disable flag
 8000410:	24031c5c 	.word	0x24031c5c
    LDR     r0, =_tx_thread_current_ptr             // Build current thread pointer address
 8000414:	24031bc4 	.word	0x24031bc4
    LDR     r2, =_tx_thread_execute_ptr             // Build execute thread pointer address
 8000418:	24031bc8 	.word	0x24031bc8
    LDR     r4, =_tx_timer_time_slice               // Build address of time-slice variable
 800041c:	240321cc 	.word	0x240321cc

08000420 <_tx_thread_stack_build>:
                       pc          Initial value for pc
                       xPSR        Initial value for xPSR

    Stack Bottom: (higher memory address)  */

    LDR     r2, [r0, #16]                           // Pickup end of stack area
 8000420:	6902      	ldr	r2, [r0, #16]
    BIC     r2, r2, #0x7                            // Align frame for 8-byte alignment
 8000422:	f022 0207 	bic.w	r2, r2, #7
    SUB     r2, r2, #68                             // Subtract frame size
 8000426:	f1a2 0244 	sub.w	r2, r2, #68	; 0x44
    LDR     r3, =0xFFFFFFFD                         // Build initial LR value
 800042a:	f06f 0302 	mvn.w	r3, #2
    STR     r3, [r2, #0]                            // Save on the stack
 800042e:	6013      	str	r3, [r2, #0]

    /* Actually build the stack frame.  */

    MOV     r3, #0                                  // Build initial register value
 8000430:	f04f 0300 	mov.w	r3, #0
    STR     r3, [r2, #4]                            // Store initial r4
 8000434:	6053      	str	r3, [r2, #4]
    STR     r3, [r2, #8]                            // Store initial r5
 8000436:	6093      	str	r3, [r2, #8]
    STR     r3, [r2, #12]                           // Store initial r6
 8000438:	60d3      	str	r3, [r2, #12]
    STR     r3, [r2, #16]                           // Store initial r7
 800043a:	6113      	str	r3, [r2, #16]
    STR     r3, [r2, #20]                           // Store initial r8
 800043c:	6153      	str	r3, [r2, #20]
    STR     r3, [r2, #24]                           // Store initial r9
 800043e:	6193      	str	r3, [r2, #24]
    STR     r3, [r2, #28]                           // Store initial r10
 8000440:	61d3      	str	r3, [r2, #28]
    STR     r3, [r2, #32]                           // Store initial r11
 8000442:	6213      	str	r3, [r2, #32]

    /* Hardware stack follows.  */

    STR     r3, [r2, #36]                           // Store initial r0
 8000444:	6253      	str	r3, [r2, #36]	; 0x24
    STR     r3, [r2, #40]                           // Store initial r1
 8000446:	6293      	str	r3, [r2, #40]	; 0x28
    STR     r3, [r2, #44]                           // Store initial r2
 8000448:	62d3      	str	r3, [r2, #44]	; 0x2c
    STR     r3, [r2, #48]                           // Store initial r3
 800044a:	6313      	str	r3, [r2, #48]	; 0x30
    STR     r3, [r2, #52]                           // Store initial r12
 800044c:	6353      	str	r3, [r2, #52]	; 0x34
    MOV     r3, #0xFFFFFFFF                         // Poison EXC_RETURN value
 800044e:	f04f 33ff 	mov.w	r3, #4294967295
    STR     r3, [r2, #56]                           // Store initial lr
 8000452:	6393      	str	r3, [r2, #56]	; 0x38
    STR     r1, [r2, #60]                           // Store initial pc
 8000454:	63d1      	str	r1, [r2, #60]	; 0x3c
    MOV     r3, #0x01000000                         // Only T-bit need be set
 8000456:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
    STR     r3, [r2, #64]                           // Store initial xPSR
 800045a:	6413      	str	r3, [r2, #64]	; 0x40

    /* Setup stack pointer.  */
    // thread_ptr -> tx_thread_stack_ptr =  r2;

    STR     r2, [r0, #8]                            // Save stack pointer in thread's
 800045c:	6082      	str	r2, [r0, #8]
                                                    //   control block
    BX      lr                                      // Return to caller
 800045e:	4770      	bx	lr

08000460 <_tx_timer_interrupt>:
       for use.  */

    /* Increment the system clock.  */
    // _tx_timer_system_clock++;

    LDR     r1, =_tx_timer_system_clock             // Pickup address of system clock
 8000460:	4922      	ldr	r1, [pc, #136]	; (80004ec <__tx_timer_nothing_expired+0x6>)
    LDR     r0, [r1, #0]                            // Pickup system clock
 8000462:	6808      	ldr	r0, [r1, #0]
    ADD     r0, r0, #1                              // Increment system clock
 8000464:	f100 0001 	add.w	r0, r0, #1
    STR     r0, [r1, #0]                            // Store new system clock
 8000468:	6008      	str	r0, [r1, #0]

    /* Test for time-slice expiration.  */
    // if (_tx_timer_time_slice)
    // {

    LDR     r3, =_tx_timer_time_slice               // Pickup address of time-slice
 800046a:	4b21      	ldr	r3, [pc, #132]	; (80004f0 <__tx_timer_nothing_expired+0xa>)
    LDR     r2, [r3, #0]                            // Pickup time-slice
 800046c:	681a      	ldr	r2, [r3, #0]
    CBZ     r2, __tx_timer_no_time_slice            // Is it non-active?
 800046e:	b13a      	cbz	r2, 8000480 <__tx_timer_no_time_slice>
                                                    // Yes, skip time-slice processing

       /* Decrement the time_slice.  */
       // _tx_timer_time_slice--;

    SUB     r2, r2, #1                              // Decrement the time-slice
 8000470:	f1a2 0201 	sub.w	r2, r2, #1
    STR     r2, [r3, #0]                            // Store new time-slice value
 8000474:	601a      	str	r2, [r3, #0]

       /* Check for expiration.  */
       // if (__tx_timer_time_slice == 0)

    CBNZ    r2, __tx_timer_no_time_slice            // Has it expired?
 8000476:	b91a      	cbnz	r2, 8000480 <__tx_timer_no_time_slice>
                                                    // No, skip expiration processing

       /* Set the time-slice expired flag.  */
       // _tx_timer_expired_time_slice =  TX_TRUE;

    LDR     r3, =_tx_timer_expired_time_slice       // Pickup address of expired flag
 8000478:	4b1e      	ldr	r3, [pc, #120]	; (80004f4 <__tx_timer_nothing_expired+0xe>)
    MOV     r0, #1                                  // Build expired value
 800047a:	f04f 0001 	mov.w	r0, #1
    STR     r0, [r3, #0]                            // Set time-slice expiration flag
 800047e:	6018      	str	r0, [r3, #0]

08000480 <__tx_timer_no_time_slice>:

    /* Test for timer expiration.  */
    // if (*_tx_timer_current_ptr)
    // {

    LDR     r1, =_tx_timer_current_ptr              // Pickup current timer pointer address
 8000480:	491d      	ldr	r1, [pc, #116]	; (80004f8 <__tx_timer_nothing_expired+0x12>)
    LDR     r0, [r1, #0]                            // Pickup current timer
 8000482:	6808      	ldr	r0, [r1, #0]
    LDR     r2, [r0, #0]                            // Pickup timer list entry
 8000484:	6802      	ldr	r2, [r0, #0]
    CBZ     r2, __tx_timer_no_timer                 // Is there anything in the list?
 8000486:	b122      	cbz	r2, 8000492 <__tx_timer_no_timer>
                                                    // No, just increment the timer

        /* Set expiration flag.  */
        // _tx_timer_expired =  TX_TRUE;

    LDR     r3, =_tx_timer_expired                  // Pickup expiration flag address
 8000488:	4b1c      	ldr	r3, [pc, #112]	; (80004fc <__tx_timer_nothing_expired+0x16>)
    MOV     r2, #1                                  // Build expired value
 800048a:	f04f 0201 	mov.w	r2, #1
    STR     r2, [r3, #0]                            // Set expired flag
 800048e:	601a      	str	r2, [r3, #0]
    B       __tx_timer_done                         // Finished timer processing
 8000490:	e008      	b.n	80004a4 <__tx_timer_done>

08000492 <__tx_timer_no_timer>:
__tx_timer_no_timer:

        /* No timer expired, increment the timer pointer.  */
        // _tx_timer_current_ptr++;

    ADD     r0, r0, #4                              // Move to next timer
 8000492:	f100 0004 	add.w	r0, r0, #4

        /* Check for wrap-around.  */
        // if (_tx_timer_current_ptr == _tx_timer_list_end)

    LDR     r3, =_tx_timer_list_end                 // Pickup addr of timer list end
 8000496:	4b1a      	ldr	r3, [pc, #104]	; (8000500 <__tx_timer_nothing_expired+0x1a>)
    LDR     r2, [r3, #0]                            // Pickup list end
 8000498:	681a      	ldr	r2, [r3, #0]
    CMP     r0, r2                                  // Are we at list end?
 800049a:	4290      	cmp	r0, r2
    BNE     __tx_timer_skip_wrap                    // No, skip wrap-around logic
 800049c:	d101      	bne.n	80004a2 <__tx_timer_skip_wrap>

            /* Wrap to beginning of list.  */
            // _tx_timer_current_ptr =  _tx_timer_list_start;

    LDR     r3, =_tx_timer_list_start               // Pickup addr of timer list start
 800049e:	4b19      	ldr	r3, [pc, #100]	; (8000504 <__tx_timer_nothing_expired+0x1e>)
    LDR     r0, [r3, #0]                            // Set current pointer to list start
 80004a0:	6818      	ldr	r0, [r3, #0]

080004a2 <__tx_timer_skip_wrap>:

__tx_timer_skip_wrap:

    STR     r0, [r1, #0]                            // Store new current timer pointer
 80004a2:	6008      	str	r0, [r1, #0]

080004a4 <__tx_timer_done>:

    /* See if anything has expired.  */
    // if ((_tx_timer_expired_time_slice) || (_tx_timer_expired))
    // {

    LDR     r3, =_tx_timer_expired_time_slice       // Pickup addr of expired flag
 80004a4:	4b13      	ldr	r3, [pc, #76]	; (80004f4 <__tx_timer_nothing_expired+0xe>)
    LDR     r2, [r3, #0]                            // Pickup time-slice expired flag
 80004a6:	681a      	ldr	r2, [r3, #0]
    CBNZ    r2, __tx_something_expired              // Did a time-slice expire?
 80004a8:	b912      	cbnz	r2, 80004b0 <__tx_something_expired>
                                                    // If non-zero, time-slice expired
    LDR     r1, =_tx_timer_expired                  // Pickup addr of other expired flag
 80004aa:	4914      	ldr	r1, [pc, #80]	; (80004fc <__tx_timer_nothing_expired+0x16>)
    LDR     r0, [r1, #0]                            // Pickup timer expired flag
 80004ac:	6808      	ldr	r0, [r1, #0]
    CBZ     r0, __tx_timer_nothing_expired          // Did a timer expire?
 80004ae:	b1d0      	cbz	r0, 80004e6 <__tx_timer_nothing_expired>

080004b0 <__tx_something_expired>:
                                                    // No, nothing expired

__tx_something_expired:

    STMDB   sp!, {r0, lr}                           // Save the lr register on the stack
 80004b0:	e92d 4001 	stmdb	sp!, {r0, lr}

    /* Did a timer expire?  */
    // if (_tx_timer_expired)
    // {

    LDR     r1, =_tx_timer_expired                  // Pickup addr of expired flag
 80004b4:	4911      	ldr	r1, [pc, #68]	; (80004fc <__tx_timer_nothing_expired+0x16>)
    LDR     r0, [r1, #0]                            // Pickup timer expired flag
 80004b6:	6808      	ldr	r0, [r1, #0]
    CBZ     r0, __tx_timer_dont_activate            // Check for timer expiration
 80004b8:	b108      	cbz	r0, 80004be <__tx_timer_dont_activate>
                                                    // If not set, skip timer activation

        /* Process timer expiration.  */
        // _tx_timer_expiration_process();

    BL      _tx_timer_expiration_process            // Call the timer expiration handling routine
 80004ba:	f015 f933 	bl	8015724 <_tx_timer_expiration_process>

080004be <__tx_timer_dont_activate>:

    /* Did time slice expire?  */
    // if (_tx_timer_expired_time_slice)
    // {

    LDR     r3, =_tx_timer_expired_time_slice       // Pickup addr of time-slice expired
 80004be:	4b0d      	ldr	r3, [pc, #52]	; (80004f4 <__tx_timer_nothing_expired+0xe>)
    LDR     r2, [r3, #0]                            // Pickup the actual flag
 80004c0:	681a      	ldr	r2, [r3, #0]
    CBZ     r2, __tx_timer_not_ts_expiration        // See if the flag is set
 80004c2:	b172      	cbz	r2, 80004e2 <__tx_timer_not_ts_expiration>
                                                    // No, skip time-slice processing

        /* Time slice interrupted thread.  */
        // _tx_thread_time_slice();

    BL      _tx_thread_time_slice                   // Call time-slice processing
 80004c4:	f014 ffc8 	bl	8015458 <_tx_thread_time_slice>
    LDR     r0, =_tx_thread_preempt_disable         // Build address of preempt disable flag
 80004c8:	480f      	ldr	r0, [pc, #60]	; (8000508 <__tx_timer_nothing_expired+0x22>)
    LDR     r1, [r0]                                // Is the preempt disable flag set?
 80004ca:	6801      	ldr	r1, [r0, #0]
    CBNZ    r1, __tx_timer_skip_time_slice          // Yes, skip the PendSV logic
 80004cc:	b949      	cbnz	r1, 80004e2 <__tx_timer_not_ts_expiration>
    LDR     r0, =_tx_thread_current_ptr             // Build current thread pointer address
 80004ce:	480f      	ldr	r0, [pc, #60]	; (800050c <__tx_timer_nothing_expired+0x26>)
    LDR     r1, [r0]                                // Pickup the current thread pointer
 80004d0:	6801      	ldr	r1, [r0, #0]
    LDR     r2, =_tx_thread_execute_ptr             // Build execute thread pointer address
 80004d2:	4a0f      	ldr	r2, [pc, #60]	; (8000510 <__tx_timer_nothing_expired+0x2a>)
    LDR     r3, [r2]                                // Pickup the execute thread pointer
 80004d4:	6813      	ldr	r3, [r2, #0]
    LDR     r0, =0xE000ED04                         // Build address of control register
 80004d6:	480f      	ldr	r0, [pc, #60]	; (8000514 <__tx_timer_nothing_expired+0x2e>)
    LDR     r2, =0x10000000                         // Build value for PendSV bit
 80004d8:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
    CMP     r1, r3                                  // Are they the same?
 80004dc:	4299      	cmp	r1, r3
    BEQ     __tx_timer_skip_time_slice              // If the same, there was no time-slice performed
 80004de:	d000      	beq.n	80004e2 <__tx_timer_not_ts_expiration>
    STR     r2, [r0]                                // Not the same, issue the PendSV for preemption
 80004e0:	6002      	str	r2, [r0, #0]

080004e2 <__tx_timer_not_ts_expiration>:

    // }

__tx_timer_not_ts_expiration:

    LDMIA   sp!, {r0, lr}                           // Recover lr register (r0 is just there for
 80004e2:	e8bd 4001 	ldmia.w	sp!, {r0, lr}

080004e6 <__tx_timer_nothing_expired>:

    // }

__tx_timer_nothing_expired:

    DSB                                             // Complete all memory access
 80004e6:	f3bf 8f4f 	dsb	sy
    BX      lr                                      // Return to caller
 80004ea:	4770      	bx	lr
    LDR     r1, =_tx_timer_system_clock             // Pickup address of system clock
 80004ec:	24031c68 	.word	0x24031c68
    LDR     r3, =_tx_timer_time_slice               // Pickup address of time-slice
 80004f0:	240321cc 	.word	0x240321cc
    LDR     r3, =_tx_timer_expired_time_slice       // Pickup address of expired flag
 80004f4:	24031c6c 	.word	0x24031c6c
    LDR     r1, =_tx_timer_current_ptr              // Pickup current timer pointer address
 80004f8:	24031cf8 	.word	0x24031cf8
    LDR     r3, =_tx_timer_expired                  // Pickup expiration flag address
 80004fc:	24031cfc 	.word	0x24031cfc
    LDR     r3, =_tx_timer_list_end                 // Pickup addr of timer list end
 8000500:	24031cf4 	.word	0x24031cf4
    LDR     r3, =_tx_timer_list_start               // Pickup addr of timer list start
 8000504:	24031cf0 	.word	0x24031cf0
    LDR     r0, =_tx_thread_preempt_disable         // Build address of preempt disable flag
 8000508:	24031c5c 	.word	0x24031c5c
    LDR     r0, =_tx_thread_current_ptr             // Build current thread pointer address
 800050c:	24031bc4 	.word	0x24031bc4
    LDR     r2, =_tx_thread_execute_ptr             // Build execute thread pointer address
 8000510:	24031bc8 	.word	0x24031bc8
    LDR     r0, =0xE000ED04                         // Build address of control register
 8000514:	e000ed04 	.word	0xe000ed04

08000518 <strcmp>:
 8000518:	f810 2b01 	ldrb.w	r2, [r0], #1
 800051c:	f811 3b01 	ldrb.w	r3, [r1], #1
 8000520:	2a01      	cmp	r2, #1
 8000522:	bf28      	it	cs
 8000524:	429a      	cmpcs	r2, r3
 8000526:	d0f7      	beq.n	8000518 <strcmp>
 8000528:	1ad0      	subs	r0, r2, r3
 800052a:	4770      	bx	lr

0800052c <strlen>:
 800052c:	4603      	mov	r3, r0
 800052e:	f813 2b01 	ldrb.w	r2, [r3], #1
 8000532:	2a00      	cmp	r2, #0
 8000534:	d1fb      	bne.n	800052e <strlen+0x2>
 8000536:	1a18      	subs	r0, r3, r0
 8000538:	3801      	subs	r0, #1
 800053a:	4770      	bx	lr
 800053c:	0000      	movs	r0, r0
	...

08000540 <memchr>:
 8000540:	f001 01ff 	and.w	r1, r1, #255	; 0xff
 8000544:	2a10      	cmp	r2, #16
 8000546:	db2b      	blt.n	80005a0 <memchr+0x60>
 8000548:	f010 0f07 	tst.w	r0, #7
 800054c:	d008      	beq.n	8000560 <memchr+0x20>
 800054e:	f810 3b01 	ldrb.w	r3, [r0], #1
 8000552:	3a01      	subs	r2, #1
 8000554:	428b      	cmp	r3, r1
 8000556:	d02d      	beq.n	80005b4 <memchr+0x74>
 8000558:	f010 0f07 	tst.w	r0, #7
 800055c:	b342      	cbz	r2, 80005b0 <memchr+0x70>
 800055e:	d1f6      	bne.n	800054e <memchr+0xe>
 8000560:	b4f0      	push	{r4, r5, r6, r7}
 8000562:	ea41 2101 	orr.w	r1, r1, r1, lsl #8
 8000566:	ea41 4101 	orr.w	r1, r1, r1, lsl #16
 800056a:	f022 0407 	bic.w	r4, r2, #7
 800056e:	f07f 0700 	mvns.w	r7, #0
 8000572:	2300      	movs	r3, #0
 8000574:	e8f0 5602 	ldrd	r5, r6, [r0], #8
 8000578:	3c08      	subs	r4, #8
 800057a:	ea85 0501 	eor.w	r5, r5, r1
 800057e:	ea86 0601 	eor.w	r6, r6, r1
 8000582:	fa85 f547 	uadd8	r5, r5, r7
 8000586:	faa3 f587 	sel	r5, r3, r7
 800058a:	fa86 f647 	uadd8	r6, r6, r7
 800058e:	faa5 f687 	sel	r6, r5, r7
 8000592:	b98e      	cbnz	r6, 80005b8 <memchr+0x78>
 8000594:	d1ee      	bne.n	8000574 <memchr+0x34>
 8000596:	bcf0      	pop	{r4, r5, r6, r7}
 8000598:	f001 01ff 	and.w	r1, r1, #255	; 0xff
 800059c:	f002 0207 	and.w	r2, r2, #7
 80005a0:	b132      	cbz	r2, 80005b0 <memchr+0x70>
 80005a2:	f810 3b01 	ldrb.w	r3, [r0], #1
 80005a6:	3a01      	subs	r2, #1
 80005a8:	ea83 0301 	eor.w	r3, r3, r1
 80005ac:	b113      	cbz	r3, 80005b4 <memchr+0x74>
 80005ae:	d1f8      	bne.n	80005a2 <memchr+0x62>
 80005b0:	2000      	movs	r0, #0
 80005b2:	4770      	bx	lr
 80005b4:	3801      	subs	r0, #1
 80005b6:	4770      	bx	lr
 80005b8:	2d00      	cmp	r5, #0
 80005ba:	bf06      	itte	eq
 80005bc:	4635      	moveq	r5, r6
 80005be:	3803      	subeq	r0, #3
 80005c0:	3807      	subne	r0, #7
 80005c2:	f015 0f01 	tst.w	r5, #1
 80005c6:	d107      	bne.n	80005d8 <memchr+0x98>
 80005c8:	3001      	adds	r0, #1
 80005ca:	f415 7f80 	tst.w	r5, #256	; 0x100
 80005ce:	bf02      	ittt	eq
 80005d0:	3001      	addeq	r0, #1
 80005d2:	f415 3fc0 	tsteq.w	r5, #98304	; 0x18000
 80005d6:	3001      	addeq	r0, #1
 80005d8:	bcf0      	pop	{r4, r5, r6, r7}
 80005da:	3801      	subs	r0, #1
 80005dc:	4770      	bx	lr
 80005de:	bf00      	nop

080005e0 <__aeabi_uldivmod>:
 80005e0:	b953      	cbnz	r3, 80005f8 <__aeabi_uldivmod+0x18>
 80005e2:	b94a      	cbnz	r2, 80005f8 <__aeabi_uldivmod+0x18>
 80005e4:	2900      	cmp	r1, #0
 80005e6:	bf08      	it	eq
 80005e8:	2800      	cmpeq	r0, #0
 80005ea:	bf1c      	itt	ne
 80005ec:	f04f 31ff 	movne.w	r1, #4294967295
 80005f0:	f04f 30ff 	movne.w	r0, #4294967295
 80005f4:	f000 b974 	b.w	80008e0 <__aeabi_idiv0>
 80005f8:	f1ad 0c08 	sub.w	ip, sp, #8
 80005fc:	e96d ce04 	strd	ip, lr, [sp, #-16]!
 8000600:	f000 f806 	bl	8000610 <__udivmoddi4>
 8000604:	f8dd e004 	ldr.w	lr, [sp, #4]
 8000608:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
 800060c:	b004      	add	sp, #16
 800060e:	4770      	bx	lr

08000610 <__udivmoddi4>:
 8000610:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 8000614:	9d08      	ldr	r5, [sp, #32]
 8000616:	4604      	mov	r4, r0
 8000618:	468e      	mov	lr, r1
 800061a:	2b00      	cmp	r3, #0
 800061c:	d14d      	bne.n	80006ba <__udivmoddi4+0xaa>
 800061e:	428a      	cmp	r2, r1
 8000620:	4694      	mov	ip, r2
 8000622:	d969      	bls.n	80006f8 <__udivmoddi4+0xe8>
 8000624:	fab2 f282 	clz	r2, r2
 8000628:	b152      	cbz	r2, 8000640 <__udivmoddi4+0x30>
 800062a:	fa01 f302 	lsl.w	r3, r1, r2
 800062e:	f1c2 0120 	rsb	r1, r2, #32
 8000632:	fa20 f101 	lsr.w	r1, r0, r1
 8000636:	fa0c fc02 	lsl.w	ip, ip, r2
 800063a:	ea41 0e03 	orr.w	lr, r1, r3
 800063e:	4094      	lsls	r4, r2
 8000640:	ea4f 481c 	mov.w	r8, ip, lsr #16
 8000644:	0c21      	lsrs	r1, r4, #16
 8000646:	fbbe f6f8 	udiv	r6, lr, r8
 800064a:	fa1f f78c 	uxth.w	r7, ip
 800064e:	fb08 e316 	mls	r3, r8, r6, lr
 8000652:	ea41 4303 	orr.w	r3, r1, r3, lsl #16
 8000656:	fb06 f107 	mul.w	r1, r6, r7
 800065a:	4299      	cmp	r1, r3
 800065c:	d90a      	bls.n	8000674 <__udivmoddi4+0x64>
 800065e:	eb1c 0303 	adds.w	r3, ip, r3
 8000662:	f106 30ff 	add.w	r0, r6, #4294967295
 8000666:	f080 811f 	bcs.w	80008a8 <__udivmoddi4+0x298>
 800066a:	4299      	cmp	r1, r3
 800066c:	f240 811c 	bls.w	80008a8 <__udivmoddi4+0x298>
 8000670:	3e02      	subs	r6, #2
 8000672:	4463      	add	r3, ip
 8000674:	1a5b      	subs	r3, r3, r1
 8000676:	b2a4      	uxth	r4, r4
 8000678:	fbb3 f0f8 	udiv	r0, r3, r8
 800067c:	fb08 3310 	mls	r3, r8, r0, r3
 8000680:	ea44 4403 	orr.w	r4, r4, r3, lsl #16
 8000684:	fb00 f707 	mul.w	r7, r0, r7
 8000688:	42a7      	cmp	r7, r4
 800068a:	d90a      	bls.n	80006a2 <__udivmoddi4+0x92>
 800068c:	eb1c 0404 	adds.w	r4, ip, r4
 8000690:	f100 33ff 	add.w	r3, r0, #4294967295
 8000694:	f080 810a 	bcs.w	80008ac <__udivmoddi4+0x29c>
 8000698:	42a7      	cmp	r7, r4
 800069a:	f240 8107 	bls.w	80008ac <__udivmoddi4+0x29c>
 800069e:	4464      	add	r4, ip
 80006a0:	3802      	subs	r0, #2
 80006a2:	ea40 4006 	orr.w	r0, r0, r6, lsl #16
 80006a6:	1be4      	subs	r4, r4, r7
 80006a8:	2600      	movs	r6, #0
 80006aa:	b11d      	cbz	r5, 80006b4 <__udivmoddi4+0xa4>
 80006ac:	40d4      	lsrs	r4, r2
 80006ae:	2300      	movs	r3, #0
 80006b0:	e9c5 4300 	strd	r4, r3, [r5]
 80006b4:	4631      	mov	r1, r6
 80006b6:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 80006ba:	428b      	cmp	r3, r1
 80006bc:	d909      	bls.n	80006d2 <__udivmoddi4+0xc2>
 80006be:	2d00      	cmp	r5, #0
 80006c0:	f000 80ef 	beq.w	80008a2 <__udivmoddi4+0x292>
 80006c4:	2600      	movs	r6, #0
 80006c6:	e9c5 0100 	strd	r0, r1, [r5]
 80006ca:	4630      	mov	r0, r6
 80006cc:	4631      	mov	r1, r6
 80006ce:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 80006d2:	fab3 f683 	clz	r6, r3
 80006d6:	2e00      	cmp	r6, #0
 80006d8:	d14a      	bne.n	8000770 <__udivmoddi4+0x160>
 80006da:	428b      	cmp	r3, r1
 80006dc:	d302      	bcc.n	80006e4 <__udivmoddi4+0xd4>
 80006de:	4282      	cmp	r2, r0
 80006e0:	f200 80f9 	bhi.w	80008d6 <__udivmoddi4+0x2c6>
 80006e4:	1a84      	subs	r4, r0, r2
 80006e6:	eb61 0303 	sbc.w	r3, r1, r3
 80006ea:	2001      	movs	r0, #1
 80006ec:	469e      	mov	lr, r3
 80006ee:	2d00      	cmp	r5, #0
 80006f0:	d0e0      	beq.n	80006b4 <__udivmoddi4+0xa4>
 80006f2:	e9c5 4e00 	strd	r4, lr, [r5]
 80006f6:	e7dd      	b.n	80006b4 <__udivmoddi4+0xa4>
 80006f8:	b902      	cbnz	r2, 80006fc <__udivmoddi4+0xec>
 80006fa:	deff      	udf	#255	; 0xff
 80006fc:	fab2 f282 	clz	r2, r2
 8000700:	2a00      	cmp	r2, #0
 8000702:	f040 8092 	bne.w	800082a <__udivmoddi4+0x21a>
 8000706:	eba1 010c 	sub.w	r1, r1, ip
 800070a:	ea4f 471c 	mov.w	r7, ip, lsr #16
 800070e:	fa1f fe8c 	uxth.w	lr, ip
 8000712:	2601      	movs	r6, #1
 8000714:	0c20      	lsrs	r0, r4, #16
 8000716:	fbb1 f3f7 	udiv	r3, r1, r7
 800071a:	fb07 1113 	mls	r1, r7, r3, r1
 800071e:	ea40 4101 	orr.w	r1, r0, r1, lsl #16
 8000722:	fb0e f003 	mul.w	r0, lr, r3
 8000726:	4288      	cmp	r0, r1
 8000728:	d908      	bls.n	800073c <__udivmoddi4+0x12c>
 800072a:	eb1c 0101 	adds.w	r1, ip, r1
 800072e:	f103 38ff 	add.w	r8, r3, #4294967295
 8000732:	d202      	bcs.n	800073a <__udivmoddi4+0x12a>
 8000734:	4288      	cmp	r0, r1
 8000736:	f200 80cb 	bhi.w	80008d0 <__udivmoddi4+0x2c0>
 800073a:	4643      	mov	r3, r8
 800073c:	1a09      	subs	r1, r1, r0
 800073e:	b2a4      	uxth	r4, r4
 8000740:	fbb1 f0f7 	udiv	r0, r1, r7
 8000744:	fb07 1110 	mls	r1, r7, r0, r1
 8000748:	ea44 4401 	orr.w	r4, r4, r1, lsl #16
 800074c:	fb0e fe00 	mul.w	lr, lr, r0
 8000750:	45a6      	cmp	lr, r4
 8000752:	d908      	bls.n	8000766 <__udivmoddi4+0x156>
 8000754:	eb1c 0404 	adds.w	r4, ip, r4
 8000758:	f100 31ff 	add.w	r1, r0, #4294967295
 800075c:	d202      	bcs.n	8000764 <__udivmoddi4+0x154>
 800075e:	45a6      	cmp	lr, r4
 8000760:	f200 80bb 	bhi.w	80008da <__udivmoddi4+0x2ca>
 8000764:	4608      	mov	r0, r1
 8000766:	eba4 040e 	sub.w	r4, r4, lr
 800076a:	ea40 4003 	orr.w	r0, r0, r3, lsl #16
 800076e:	e79c      	b.n	80006aa <__udivmoddi4+0x9a>
 8000770:	f1c6 0720 	rsb	r7, r6, #32
 8000774:	40b3      	lsls	r3, r6
 8000776:	fa22 fc07 	lsr.w	ip, r2, r7
 800077a:	ea4c 0c03 	orr.w	ip, ip, r3
 800077e:	fa20 f407 	lsr.w	r4, r0, r7
 8000782:	fa01 f306 	lsl.w	r3, r1, r6
 8000786:	431c      	orrs	r4, r3
 8000788:	40f9      	lsrs	r1, r7
 800078a:	ea4f 491c 	mov.w	r9, ip, lsr #16
 800078e:	fa00 f306 	lsl.w	r3, r0, r6
 8000792:	fbb1 f8f9 	udiv	r8, r1, r9
 8000796:	0c20      	lsrs	r0, r4, #16
 8000798:	fa1f fe8c 	uxth.w	lr, ip
 800079c:	fb09 1118 	mls	r1, r9, r8, r1
 80007a0:	ea40 4101 	orr.w	r1, r0, r1, lsl #16
 80007a4:	fb08 f00e 	mul.w	r0, r8, lr
 80007a8:	4288      	cmp	r0, r1
 80007aa:	fa02 f206 	lsl.w	r2, r2, r6
 80007ae:	d90b      	bls.n	80007c8 <__udivmoddi4+0x1b8>
 80007b0:	eb1c 0101 	adds.w	r1, ip, r1
 80007b4:	f108 3aff 	add.w	sl, r8, #4294967295
 80007b8:	f080 8088 	bcs.w	80008cc <__udivmoddi4+0x2bc>
 80007bc:	4288      	cmp	r0, r1
 80007be:	f240 8085 	bls.w	80008cc <__udivmoddi4+0x2bc>
 80007c2:	f1a8 0802 	sub.w	r8, r8, #2
 80007c6:	4461      	add	r1, ip
 80007c8:	1a09      	subs	r1, r1, r0
 80007ca:	b2a4      	uxth	r4, r4
 80007cc:	fbb1 f0f9 	udiv	r0, r1, r9
 80007d0:	fb09 1110 	mls	r1, r9, r0, r1
 80007d4:	ea44 4101 	orr.w	r1, r4, r1, lsl #16
 80007d8:	fb00 fe0e 	mul.w	lr, r0, lr
 80007dc:	458e      	cmp	lr, r1
 80007de:	d908      	bls.n	80007f2 <__udivmoddi4+0x1e2>
 80007e0:	eb1c 0101 	adds.w	r1, ip, r1
 80007e4:	f100 34ff 	add.w	r4, r0, #4294967295
 80007e8:	d26c      	bcs.n	80008c4 <__udivmoddi4+0x2b4>
 80007ea:	458e      	cmp	lr, r1
 80007ec:	d96a      	bls.n	80008c4 <__udivmoddi4+0x2b4>
 80007ee:	3802      	subs	r0, #2
 80007f0:	4461      	add	r1, ip
 80007f2:	ea40 4008 	orr.w	r0, r0, r8, lsl #16
 80007f6:	fba0 9402 	umull	r9, r4, r0, r2
 80007fa:	eba1 010e 	sub.w	r1, r1, lr
 80007fe:	42a1      	cmp	r1, r4
 8000800:	46c8      	mov	r8, r9
 8000802:	46a6      	mov	lr, r4
 8000804:	d356      	bcc.n	80008b4 <__udivmoddi4+0x2a4>
 8000806:	d053      	beq.n	80008b0 <__udivmoddi4+0x2a0>
 8000808:	b15d      	cbz	r5, 8000822 <__udivmoddi4+0x212>
 800080a:	ebb3 0208 	subs.w	r2, r3, r8
 800080e:	eb61 010e 	sbc.w	r1, r1, lr
 8000812:	fa01 f707 	lsl.w	r7, r1, r7
 8000816:	fa22 f306 	lsr.w	r3, r2, r6
 800081a:	40f1      	lsrs	r1, r6
 800081c:	431f      	orrs	r7, r3
 800081e:	e9c5 7100 	strd	r7, r1, [r5]
 8000822:	2600      	movs	r6, #0
 8000824:	4631      	mov	r1, r6
 8000826:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 800082a:	f1c2 0320 	rsb	r3, r2, #32
 800082e:	40d8      	lsrs	r0, r3
 8000830:	fa0c fc02 	lsl.w	ip, ip, r2
 8000834:	fa21 f303 	lsr.w	r3, r1, r3
 8000838:	4091      	lsls	r1, r2
 800083a:	4301      	orrs	r1, r0
 800083c:	ea4f 471c 	mov.w	r7, ip, lsr #16
 8000840:	fa1f fe8c 	uxth.w	lr, ip
 8000844:	fbb3 f0f7 	udiv	r0, r3, r7
 8000848:	fb07 3610 	mls	r6, r7, r0, r3
 800084c:	0c0b      	lsrs	r3, r1, #16
 800084e:	ea43 4306 	orr.w	r3, r3, r6, lsl #16
 8000852:	fb00 f60e 	mul.w	r6, r0, lr
 8000856:	429e      	cmp	r6, r3
 8000858:	fa04 f402 	lsl.w	r4, r4, r2
 800085c:	d908      	bls.n	8000870 <__udivmoddi4+0x260>
 800085e:	eb1c 0303 	adds.w	r3, ip, r3
 8000862:	f100 38ff 	add.w	r8, r0, #4294967295
 8000866:	d22f      	bcs.n	80008c8 <__udivmoddi4+0x2b8>
 8000868:	429e      	cmp	r6, r3
 800086a:	d92d      	bls.n	80008c8 <__udivmoddi4+0x2b8>
 800086c:	3802      	subs	r0, #2
 800086e:	4463      	add	r3, ip
 8000870:	1b9b      	subs	r3, r3, r6
 8000872:	b289      	uxth	r1, r1
 8000874:	fbb3 f6f7 	udiv	r6, r3, r7
 8000878:	fb07 3316 	mls	r3, r7, r6, r3
 800087c:	ea41 4103 	orr.w	r1, r1, r3, lsl #16
 8000880:	fb06 f30e 	mul.w	r3, r6, lr
 8000884:	428b      	cmp	r3, r1
 8000886:	d908      	bls.n	800089a <__udivmoddi4+0x28a>
 8000888:	eb1c 0101 	adds.w	r1, ip, r1
 800088c:	f106 38ff 	add.w	r8, r6, #4294967295
 8000890:	d216      	bcs.n	80008c0 <__udivmoddi4+0x2b0>
 8000892:	428b      	cmp	r3, r1
 8000894:	d914      	bls.n	80008c0 <__udivmoddi4+0x2b0>
 8000896:	3e02      	subs	r6, #2
 8000898:	4461      	add	r1, ip
 800089a:	1ac9      	subs	r1, r1, r3
 800089c:	ea46 4600 	orr.w	r6, r6, r0, lsl #16
 80008a0:	e738      	b.n	8000714 <__udivmoddi4+0x104>
 80008a2:	462e      	mov	r6, r5
 80008a4:	4628      	mov	r0, r5
 80008a6:	e705      	b.n	80006b4 <__udivmoddi4+0xa4>
 80008a8:	4606      	mov	r6, r0
 80008aa:	e6e3      	b.n	8000674 <__udivmoddi4+0x64>
 80008ac:	4618      	mov	r0, r3
 80008ae:	e6f8      	b.n	80006a2 <__udivmoddi4+0x92>
 80008b0:	454b      	cmp	r3, r9
 80008b2:	d2a9      	bcs.n	8000808 <__udivmoddi4+0x1f8>
 80008b4:	ebb9 0802 	subs.w	r8, r9, r2
 80008b8:	eb64 0e0c 	sbc.w	lr, r4, ip
 80008bc:	3801      	subs	r0, #1
 80008be:	e7a3      	b.n	8000808 <__udivmoddi4+0x1f8>
 80008c0:	4646      	mov	r6, r8
 80008c2:	e7ea      	b.n	800089a <__udivmoddi4+0x28a>
 80008c4:	4620      	mov	r0, r4
 80008c6:	e794      	b.n	80007f2 <__udivmoddi4+0x1e2>
 80008c8:	4640      	mov	r0, r8
 80008ca:	e7d1      	b.n	8000870 <__udivmoddi4+0x260>
 80008cc:	46d0      	mov	r8, sl
 80008ce:	e77b      	b.n	80007c8 <__udivmoddi4+0x1b8>
 80008d0:	3b02      	subs	r3, #2
 80008d2:	4461      	add	r1, ip
 80008d4:	e732      	b.n	800073c <__udivmoddi4+0x12c>
 80008d6:	4630      	mov	r0, r6
 80008d8:	e709      	b.n	80006ee <__udivmoddi4+0xde>
 80008da:	4464      	add	r4, ip
 80008dc:	3802      	subs	r0, #2
 80008de:	e742      	b.n	8000766 <__udivmoddi4+0x156>

080008e0 <__aeabi_idiv0>:
 80008e0:	4770      	bx	lr
 80008e2:	bf00      	nop

080008e4 <tx_application_define>:
  * @brief  Define the initial system.
  * @param  first_unused_memory : Pointer to the first unused memory
  * @retval None
  */
VOID tx_application_define(VOID *first_unused_memory)
{
 80008e4:	b580      	push	{r7, lr}
 80008e6:	b086      	sub	sp, #24
 80008e8:	af02      	add	r7, sp, #8
 80008ea:	6078      	str	r0, [r7, #4]
  /* USER CODE BEGIN  tx_application_define */
	if(tx_freertos_init() != TX_SUCCESS)
 80008ec:	f010 ffe8 	bl	80118c0 <tx_freertos_init>
 80008f0:	4603      	mov	r3, r0
 80008f2:	2b00      	cmp	r3, #0
 80008f4:	d000      	beq.n	80008f8 <tx_application_define+0x14>
	  {
	    //Error_Handler();
		while(1) {
 80008f6:	e7fe      	b.n	80008f6 <tx_application_define+0x12>
	 //MX_FREERTOS_Init();
  /* USER CODE END  tx_application_define */

  VOID *memory_ptr;

  if (tx_byte_pool_create(&tx_app_byte_pool, "Tx App memory pool", tx_byte_pool_buffer, TX_APP_MEM_POOL_SIZE) != TX_SUCCESS)
 80008f8:	2334      	movs	r3, #52	; 0x34
 80008fa:	9300      	str	r3, [sp, #0]
 80008fc:	f44f 6380 	mov.w	r3, #1024	; 0x400
 8000900:	4a13      	ldr	r2, [pc, #76]	; (8000950 <tx_application_define+0x6c>)
 8000902:	4914      	ldr	r1, [pc, #80]	; (8000954 <tx_application_define+0x70>)
 8000904:	4814      	ldr	r0, [pc, #80]	; (8000958 <tx_application_define+0x74>)
 8000906:	f015 f9b7 	bl	8015c78 <_txe_byte_pool_create>
 800090a:	4603      	mov	r3, r0
 800090c:	2b00      	cmp	r3, #0
 800090e:	d10a      	bne.n	8000926 <tx_application_define+0x42>
  {
    /* USER CODE BEGIN TX_Byte_Pool_Success */

    /* USER CODE END TX_Byte_Pool_Success */

    memory_ptr = (VOID *)&tx_app_byte_pool;
 8000910:	4b11      	ldr	r3, [pc, #68]	; (8000958 <tx_application_define+0x74>)
 8000912:	60fb      	str	r3, [r7, #12]

    if (App_ThreadX_Init(memory_ptr) != TX_SUCCESS)
 8000914:	68f8      	ldr	r0, [r7, #12]
 8000916:	f000 f8c1 	bl	8000a9c <App_ThreadX_Init>
 800091a:	4603      	mov	r3, r0
 800091c:	2b00      	cmp	r3, #0
 800091e:	d000      	beq.n	8000922 <tx_application_define+0x3e>
    {
      /* USER CODE BEGIN  App_ThreadX_Init_Error */
    	while(1) {
 8000920:	e7fe      	b.n	8000920 <tx_application_define+0x3c>
    	}
      /* USER CODE END  App_ThreadX_Init_Error */
    }

    /* USER CODE BEGIN  App_ThreadX_Init_Success */
    nx_system_initialize();
 8000922:	f00b fec3 	bl	800c6ac <_nx_system_initialize>
    /* USER CODE END  App_ThreadX_Init_Success */

  }

  if (tx_byte_pool_create(&nx_app_byte_pool, "Nx App memory pool", nx_byte_pool_buffer, NX_APP_MEM_POOL_SIZE) != TX_SUCCESS)
 8000926:	2334      	movs	r3, #52	; 0x34
 8000928:	9300      	str	r3, [sp, #0]
 800092a:	f44f 43f0 	mov.w	r3, #30720	; 0x7800
 800092e:	4a0b      	ldr	r2, [pc, #44]	; (800095c <tx_application_define+0x78>)
 8000930:	490b      	ldr	r1, [pc, #44]	; (8000960 <tx_application_define+0x7c>)
 8000932:	480c      	ldr	r0, [pc, #48]	; (8000964 <tx_application_define+0x80>)
 8000934:	f015 f9a0 	bl	8015c78 <_txe_byte_pool_create>
 8000938:	4603      	mov	r3, r0
 800093a:	2b00      	cmp	r3, #0
 800093c:	d104      	bne.n	8000948 <tx_application_define+0x64>
  {
    /* USER CODE BEGIN TX_Byte_Pool_Success */

    /* USER CODE END TX_Byte_Pool_Success */

    memory_ptr = (VOID *)&nx_app_byte_pool;
 800093e:	4b09      	ldr	r3, [pc, #36]	; (8000964 <tx_application_define+0x80>)
 8000940:	60fb      	str	r3, [r7, #12]

    if (MX_NetXDuo_Init(memory_ptr) != NX_SUCCESS)
 8000942:	68f8      	ldr	r0, [r7, #12]
 8000944:	f016 fa5a 	bl	8016dfc <MX_NetXDuo_Init>

    /* USER CODE END MX_NetXDuo_Init_Success */

  }

}
 8000948:	bf00      	nop
 800094a:	3710      	adds	r7, #16
 800094c:	46bd      	mov	sp, r7
 800094e:	bd80      	pop	{r7, pc}
 8000950:	24000524 	.word	0x24000524
 8000954:	08021db4 	.word	0x08021db4
 8000958:	24000924 	.word	0x24000924
 800095c:	30000000 	.word	0x30000000
 8000960:	08021dc8 	.word	0x08021dc8
 8000964:	24000958 	.word	0x24000958

08000968 <SystemInit>:
  *         configuration.
  * @param  None
  * @retval None
  */
void SystemInit (void)
{
 8000968:	b480      	push	{r7}
 800096a:	af00      	add	r7, sp, #0
  /* FPU settings ------------------------------------------------------------*/
  #if (__FPU_PRESENT == 1) && (__FPU_USED == 1)
    SCB->CPACR |= ((3UL << (10*2))|(3UL << (11*2)));  /* set CP10 and CP11 Full Access */
 800096c:	4b3f      	ldr	r3, [pc, #252]	; (8000a6c <SystemInit+0x104>)
 800096e:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
 8000972:	4a3e      	ldr	r2, [pc, #248]	; (8000a6c <SystemInit+0x104>)
 8000974:	f443 0370 	orr.w	r3, r3, #15728640	; 0xf00000
 8000978:	f8c2 3088 	str.w	r3, [r2, #136]	; 0x88
  #endif

    /*SEVONPEND enabled so that an interrupt coming from the CPU(n) interrupt signal is
     detectable by the CPU after a WFI/WFE instruction.*/
 SCB->SCR |= SCB_SCR_SEVONPEND_Msk;
 800097c:	4b3b      	ldr	r3, [pc, #236]	; (8000a6c <SystemInit+0x104>)
 800097e:	691b      	ldr	r3, [r3, #16]
 8000980:	4a3a      	ldr	r2, [pc, #232]	; (8000a6c <SystemInit+0x104>)
 8000982:	f043 0310 	orr.w	r3, r3, #16
 8000986:	6113      	str	r3, [r2, #16]

#ifdef CORE_CM7
  /* Reset the RCC clock configuration to the default reset state ------------*/
   /* Increasing the CPU frequency */
  if(FLASH_LATENCY_DEFAULT  > (READ_BIT((FLASH->ACR), FLASH_ACR_LATENCY)))
 8000988:	4b39      	ldr	r3, [pc, #228]	; (8000a70 <SystemInit+0x108>)
 800098a:	681b      	ldr	r3, [r3, #0]
 800098c:	f003 030f 	and.w	r3, r3, #15
 8000990:	2b06      	cmp	r3, #6
 8000992:	d807      	bhi.n	80009a4 <SystemInit+0x3c>
  {
    /* Program the new number of wait states to the LATENCY bits in the FLASH_ACR register */
	MODIFY_REG(FLASH->ACR, FLASH_ACR_LATENCY, (uint32_t)(FLASH_LATENCY_DEFAULT));
 8000994:	4b36      	ldr	r3, [pc, #216]	; (8000a70 <SystemInit+0x108>)
 8000996:	681b      	ldr	r3, [r3, #0]
 8000998:	f023 030f 	bic.w	r3, r3, #15
 800099c:	4a34      	ldr	r2, [pc, #208]	; (8000a70 <SystemInit+0x108>)
 800099e:	f043 0307 	orr.w	r3, r3, #7
 80009a2:	6013      	str	r3, [r2, #0]
  }

  /* Set HSION bit */
  RCC->CR |= RCC_CR_HSION;
 80009a4:	4b33      	ldr	r3, [pc, #204]	; (8000a74 <SystemInit+0x10c>)
 80009a6:	681b      	ldr	r3, [r3, #0]
 80009a8:	4a32      	ldr	r2, [pc, #200]	; (8000a74 <SystemInit+0x10c>)
 80009aa:	f043 0301 	orr.w	r3, r3, #1
 80009ae:	6013      	str	r3, [r2, #0]

  /* Reset CFGR register */
  RCC->CFGR = 0x00000000;
 80009b0:	4b30      	ldr	r3, [pc, #192]	; (8000a74 <SystemInit+0x10c>)
 80009b2:	2200      	movs	r2, #0
 80009b4:	611a      	str	r2, [r3, #16]

  /* Reset HSEON, HSECSSON, CSION, RC48ON, CSIKERON, PLL1ON, PLL2ON and PLL3ON bits */
  RCC->CR &= 0xEAF6ED7FU;
 80009b6:	4b2f      	ldr	r3, [pc, #188]	; (8000a74 <SystemInit+0x10c>)
 80009b8:	681a      	ldr	r2, [r3, #0]
 80009ba:	492e      	ldr	r1, [pc, #184]	; (8000a74 <SystemInit+0x10c>)
 80009bc:	4b2e      	ldr	r3, [pc, #184]	; (8000a78 <SystemInit+0x110>)
 80009be:	4013      	ands	r3, r2
 80009c0:	600b      	str	r3, [r1, #0]

   /* Decreasing the number of wait states because of lower CPU frequency */
  if(FLASH_LATENCY_DEFAULT  < (READ_BIT((FLASH->ACR), FLASH_ACR_LATENCY)))
 80009c2:	4b2b      	ldr	r3, [pc, #172]	; (8000a70 <SystemInit+0x108>)
 80009c4:	681b      	ldr	r3, [r3, #0]
 80009c6:	f003 0308 	and.w	r3, r3, #8
 80009ca:	2b00      	cmp	r3, #0
 80009cc:	d007      	beq.n	80009de <SystemInit+0x76>
  {
    /* Program the new number of wait states to the LATENCY bits in the FLASH_ACR register */
	MODIFY_REG(FLASH->ACR, FLASH_ACR_LATENCY, (uint32_t)(FLASH_LATENCY_DEFAULT));
 80009ce:	4b28      	ldr	r3, [pc, #160]	; (8000a70 <SystemInit+0x108>)
 80009d0:	681b      	ldr	r3, [r3, #0]
 80009d2:	f023 030f 	bic.w	r3, r3, #15
 80009d6:	4a26      	ldr	r2, [pc, #152]	; (8000a70 <SystemInit+0x108>)
 80009d8:	f043 0307 	orr.w	r3, r3, #7
 80009dc:	6013      	str	r3, [r2, #0]
  }

  /* Reset D1CFGR register */
  RCC->D1CFGR = 0x00000000;
 80009de:	4b25      	ldr	r3, [pc, #148]	; (8000a74 <SystemInit+0x10c>)
 80009e0:	2200      	movs	r2, #0
 80009e2:	619a      	str	r2, [r3, #24]

  /* Reset D2CFGR register */
  RCC->D2CFGR = 0x00000000;
 80009e4:	4b23      	ldr	r3, [pc, #140]	; (8000a74 <SystemInit+0x10c>)
 80009e6:	2200      	movs	r2, #0
 80009e8:	61da      	str	r2, [r3, #28]

  /* Reset D3CFGR register */
  RCC->D3CFGR = 0x00000000;
 80009ea:	4b22      	ldr	r3, [pc, #136]	; (8000a74 <SystemInit+0x10c>)
 80009ec:	2200      	movs	r2, #0
 80009ee:	621a      	str	r2, [r3, #32]

  /* Reset PLLCKSELR register */
  RCC->PLLCKSELR = 0x02020200;
 80009f0:	4b20      	ldr	r3, [pc, #128]	; (8000a74 <SystemInit+0x10c>)
 80009f2:	4a22      	ldr	r2, [pc, #136]	; (8000a7c <SystemInit+0x114>)
 80009f4:	629a      	str	r2, [r3, #40]	; 0x28

  /* Reset PLLCFGR register */
  RCC->PLLCFGR = 0x01FF0000;
 80009f6:	4b1f      	ldr	r3, [pc, #124]	; (8000a74 <SystemInit+0x10c>)
 80009f8:	4a21      	ldr	r2, [pc, #132]	; (8000a80 <SystemInit+0x118>)
 80009fa:	62da      	str	r2, [r3, #44]	; 0x2c
  /* Reset PLL1DIVR register */
  RCC->PLL1DIVR = 0x01010280;
 80009fc:	4b1d      	ldr	r3, [pc, #116]	; (8000a74 <SystemInit+0x10c>)
 80009fe:	4a21      	ldr	r2, [pc, #132]	; (8000a84 <SystemInit+0x11c>)
 8000a00:	631a      	str	r2, [r3, #48]	; 0x30
  /* Reset PLL1FRACR register */
  RCC->PLL1FRACR = 0x00000000;
 8000a02:	4b1c      	ldr	r3, [pc, #112]	; (8000a74 <SystemInit+0x10c>)
 8000a04:	2200      	movs	r2, #0
 8000a06:	635a      	str	r2, [r3, #52]	; 0x34

  /* Reset PLL2DIVR register */
  RCC->PLL2DIVR = 0x01010280;
 8000a08:	4b1a      	ldr	r3, [pc, #104]	; (8000a74 <SystemInit+0x10c>)
 8000a0a:	4a1e      	ldr	r2, [pc, #120]	; (8000a84 <SystemInit+0x11c>)
 8000a0c:	639a      	str	r2, [r3, #56]	; 0x38

  /* Reset PLL2FRACR register */

  RCC->PLL2FRACR = 0x00000000;
 8000a0e:	4b19      	ldr	r3, [pc, #100]	; (8000a74 <SystemInit+0x10c>)
 8000a10:	2200      	movs	r2, #0
 8000a12:	63da      	str	r2, [r3, #60]	; 0x3c
  /* Reset PLL3DIVR register */
  RCC->PLL3DIVR = 0x01010280;
 8000a14:	4b17      	ldr	r3, [pc, #92]	; (8000a74 <SystemInit+0x10c>)
 8000a16:	4a1b      	ldr	r2, [pc, #108]	; (8000a84 <SystemInit+0x11c>)
 8000a18:	641a      	str	r2, [r3, #64]	; 0x40

  /* Reset PLL3FRACR register */
  RCC->PLL3FRACR = 0x00000000;
 8000a1a:	4b16      	ldr	r3, [pc, #88]	; (8000a74 <SystemInit+0x10c>)
 8000a1c:	2200      	movs	r2, #0
 8000a1e:	645a      	str	r2, [r3, #68]	; 0x44

  /* Reset HSEBYP bit */
  RCC->CR &= 0xFFFBFFFFU;
 8000a20:	4b14      	ldr	r3, [pc, #80]	; (8000a74 <SystemInit+0x10c>)
 8000a22:	681b      	ldr	r3, [r3, #0]
 8000a24:	4a13      	ldr	r2, [pc, #76]	; (8000a74 <SystemInit+0x10c>)
 8000a26:	f423 2380 	bic.w	r3, r3, #262144	; 0x40000
 8000a2a:	6013      	str	r3, [r2, #0]

  /* Disable all interrupts */
  RCC->CIER = 0x00000000;
 8000a2c:	4b11      	ldr	r3, [pc, #68]	; (8000a74 <SystemInit+0x10c>)
 8000a2e:	2200      	movs	r2, #0
 8000a30:	661a      	str	r2, [r3, #96]	; 0x60

  /* Enable CortexM7 HSEM EXTI line (line 78)*/
  EXTI_D2->EMR3 |= 0x4000UL;
 8000a32:	4b15      	ldr	r3, [pc, #84]	; (8000a88 <SystemInit+0x120>)
 8000a34:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8000a36:	4a14      	ldr	r2, [pc, #80]	; (8000a88 <SystemInit+0x120>)
 8000a38:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
 8000a3c:	6253      	str	r3, [r2, #36]	; 0x24


  if((DBGMCU->IDCODE & 0xFFFF0000U) < 0x20000000U)
 8000a3e:	4b13      	ldr	r3, [pc, #76]	; (8000a8c <SystemInit+0x124>)
 8000a40:	681a      	ldr	r2, [r3, #0]
 8000a42:	4b13      	ldr	r3, [pc, #76]	; (8000a90 <SystemInit+0x128>)
 8000a44:	4013      	ands	r3, r2
 8000a46:	f1b3 5f00 	cmp.w	r3, #536870912	; 0x20000000
 8000a4a:	d202      	bcs.n	8000a52 <SystemInit+0xea>
  {
    /* if stm32h7 revY*/
    /* Change  the switch matrix read issuing capability to 1 for the AXI SRAM target (Target 7) */
    *((__IO uint32_t*)0x51008108) = 0x000000001U;
 8000a4c:	4b11      	ldr	r3, [pc, #68]	; (8000a94 <SystemInit+0x12c>)
 8000a4e:	2201      	movs	r2, #1
 8000a50:	601a      	str	r2, [r3, #0]
  /*
   * Disable the FMC bank1 (enabled after reset).
   * This, prevents CPU speculation access on this bank which blocks the use of FMC during
   * 24us. During this time the others FMC master (such as LTDC) cannot use it!
   */
  FMC_Bank1_R->BTCR[0] = 0x000030D2;
 8000a52:	4b11      	ldr	r3, [pc, #68]	; (8000a98 <SystemInit+0x130>)
 8000a54:	f243 02d2 	movw	r2, #12498	; 0x30d2
 8000a58:	601a      	str	r2, [r3, #0]

  /* Configure the Vector Table location add offset address ------------------*/
#ifdef VECT_TAB_SRAM
  SCB->VTOR = D1_AXISRAM_BASE  | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal D1 AXI-RAM */
#else
  SCB->VTOR = FLASH_BANK1_BASE | VECT_TAB_OFFSET;       /* Vector Table Relocation in Internal FLASH */
 8000a5a:	4b04      	ldr	r3, [pc, #16]	; (8000a6c <SystemInit+0x104>)
 8000a5c:	f04f 6200 	mov.w	r2, #134217728	; 0x8000000
 8000a60:	609a      	str	r2, [r3, #8]
#else
#error Please #define CORE_CM4 or CORE_CM7
#endif
#endif

}
 8000a62:	bf00      	nop
 8000a64:	46bd      	mov	sp, r7
 8000a66:	f85d 7b04 	ldr.w	r7, [sp], #4
 8000a6a:	4770      	bx	lr
 8000a6c:	e000ed00 	.word	0xe000ed00
 8000a70:	52002000 	.word	0x52002000
 8000a74:	58024400 	.word	0x58024400
 8000a78:	eaf6ed7f 	.word	0xeaf6ed7f
 8000a7c:	02020200 	.word	0x02020200
 8000a80:	01ff0000 	.word	0x01ff0000
 8000a84:	01010280 	.word	0x01010280
 8000a88:	580000c0 	.word	0x580000c0
 8000a8c:	5c001000 	.word	0x5c001000
 8000a90:	ffff0000 	.word	0xffff0000
 8000a94:	51008108 	.word	0x51008108
 8000a98:	52004000 	.word	0x52004000

08000a9c <App_ThreadX_Init>:
  * @brief  Application ThreadX Initialization.
  * @param memory_ptr: memory pointer
  * @retval int
  */
UINT App_ThreadX_Init(VOID *memory_ptr)
{
 8000a9c:	b480      	push	{r7}
 8000a9e:	b085      	sub	sp, #20
 8000aa0:	af00      	add	r7, sp, #0
 8000aa2:	6078      	str	r0, [r7, #4]
  UINT ret = TX_SUCCESS;
 8000aa4:	2300      	movs	r3, #0
 8000aa6:	60fb      	str	r3, [r7, #12]
  TX_BYTE_POOL *byte_pool = (TX_BYTE_POOL*)memory_ptr;
 8000aa8:	687b      	ldr	r3, [r7, #4]
 8000aaa:	60bb      	str	r3, [r7, #8]
  /* USER CODE BEGIN App_ThreadX_Init */


  /* USER CODE END App_ThreadX_Init */

  return ret;
 8000aac:	68fb      	ldr	r3, [r7, #12]
}
 8000aae:	4618      	mov	r0, r3
 8000ab0:	3714      	adds	r7, #20
 8000ab2:	46bd      	mov	sp, r7
 8000ab4:	f85d 7b04 	ldr.w	r7, [sp], #4
 8000ab8:	4770      	bx	lr

08000aba <MX_ThreadX_Init>:
  * @brief  MX_ThreadX_Init
  * @param  None
  * @retval None
  */
void MX_ThreadX_Init(void)
{
 8000aba:	b580      	push	{r7, lr}
 8000abc:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN  Before_Kernel_Start */

  /* USER CODE END  Before_Kernel_Start */

  tx_kernel_enter();
 8000abe:	f011 ff6b 	bl	8012998 <_tx_initialize_kernel_enter>

  /* USER CODE BEGIN  Kernel_Start_Error */

  /* USER CODE END  Kernel_Start_Error */
}
 8000ac2:	bf00      	nop
 8000ac4:	bd80      	pop	{r7, pc}
	...

08000ac8 <MX_GPIO_Init>:
/** Configure pins
     PH1-OSC_OUT (PH1)   ------> RCC_OSC_OUT
     PH0-OSC_IN (PH0)   ------> RCC_OSC_IN
*/
void MX_GPIO_Init(void)
{
 8000ac8:	b580      	push	{r7, lr}
 8000aca:	b08a      	sub	sp, #40	; 0x28
 8000acc:	af00      	add	r7, sp, #0

  GPIO_InitTypeDef GPIO_InitStruct = {0};
 8000ace:	f107 0314 	add.w	r3, r7, #20
 8000ad2:	2200      	movs	r2, #0
 8000ad4:	601a      	str	r2, [r3, #0]
 8000ad6:	605a      	str	r2, [r3, #4]
 8000ad8:	609a      	str	r2, [r3, #8]
 8000ada:	60da      	str	r2, [r3, #12]
 8000adc:	611a      	str	r2, [r3, #16]

  /* GPIO Ports Clock Enable */
  __HAL_RCC_GPIOK_CLK_ENABLE();
 8000ade:	4b37      	ldr	r3, [pc, #220]	; (8000bbc <MX_GPIO_Init+0xf4>)
 8000ae0:	f8d3 30e0 	ldr.w	r3, [r3, #224]	; 0xe0
 8000ae4:	4a35      	ldr	r2, [pc, #212]	; (8000bbc <MX_GPIO_Init+0xf4>)
 8000ae6:	f443 6380 	orr.w	r3, r3, #1024	; 0x400
 8000aea:	f8c2 30e0 	str.w	r3, [r2, #224]	; 0xe0
 8000aee:	4b33      	ldr	r3, [pc, #204]	; (8000bbc <MX_GPIO_Init+0xf4>)
 8000af0:	f8d3 30e0 	ldr.w	r3, [r3, #224]	; 0xe0
 8000af4:	f403 6380 	and.w	r3, r3, #1024	; 0x400
 8000af8:	613b      	str	r3, [r7, #16]
 8000afa:	693b      	ldr	r3, [r7, #16]
  __HAL_RCC_GPIOJ_CLK_ENABLE();
 8000afc:	4b2f      	ldr	r3, [pc, #188]	; (8000bbc <MX_GPIO_Init+0xf4>)
 8000afe:	f8d3 30e0 	ldr.w	r3, [r3, #224]	; 0xe0
 8000b02:	4a2e      	ldr	r2, [pc, #184]	; (8000bbc <MX_GPIO_Init+0xf4>)
 8000b04:	f443 7300 	orr.w	r3, r3, #512	; 0x200
 8000b08:	f8c2 30e0 	str.w	r3, [r2, #224]	; 0xe0
 8000b0c:	4b2b      	ldr	r3, [pc, #172]	; (8000bbc <MX_GPIO_Init+0xf4>)
 8000b0e:	f8d3 30e0 	ldr.w	r3, [r3, #224]	; 0xe0
 8000b12:	f403 7300 	and.w	r3, r3, #512	; 0x200
 8000b16:	60fb      	str	r3, [r7, #12]
 8000b18:	68fb      	ldr	r3, [r7, #12]
  __HAL_RCC_GPIOH_CLK_ENABLE();
 8000b1a:	4b28      	ldr	r3, [pc, #160]	; (8000bbc <MX_GPIO_Init+0xf4>)
 8000b1c:	f8d3 30e0 	ldr.w	r3, [r3, #224]	; 0xe0
 8000b20:	4a26      	ldr	r2, [pc, #152]	; (8000bbc <MX_GPIO_Init+0xf4>)
 8000b22:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 8000b26:	f8c2 30e0 	str.w	r3, [r2, #224]	; 0xe0
 8000b2a:	4b24      	ldr	r3, [pc, #144]	; (8000bbc <MX_GPIO_Init+0xf4>)
 8000b2c:	f8d3 30e0 	ldr.w	r3, [r3, #224]	; 0xe0
 8000b30:	f003 0380 	and.w	r3, r3, #128	; 0x80
 8000b34:	60bb      	str	r3, [r7, #8]
 8000b36:	68bb      	ldr	r3, [r7, #8]
  __HAL_RCC_GPIOB_CLK_ENABLE();
 8000b38:	4b20      	ldr	r3, [pc, #128]	; (8000bbc <MX_GPIO_Init+0xf4>)
 8000b3a:	f8d3 30e0 	ldr.w	r3, [r3, #224]	; 0xe0
 8000b3e:	4a1f      	ldr	r2, [pc, #124]	; (8000bbc <MX_GPIO_Init+0xf4>)
 8000b40:	f043 0302 	orr.w	r3, r3, #2
 8000b44:	f8c2 30e0 	str.w	r3, [r2, #224]	; 0xe0
 8000b48:	4b1c      	ldr	r3, [pc, #112]	; (8000bbc <MX_GPIO_Init+0xf4>)
 8000b4a:	f8d3 30e0 	ldr.w	r3, [r3, #224]	; 0xe0
 8000b4e:	f003 0302 	and.w	r3, r3, #2
 8000b52:	607b      	str	r3, [r7, #4]
 8000b54:	687b      	ldr	r3, [r7, #4]

  /*Configure GPIO pin Output Level */
  HAL_GPIO_WritePin(GPIOK, LED2_Pin|LED1_Pin, GPIO_PIN_RESET);
 8000b56:	2200      	movs	r2, #0
 8000b58:	2118      	movs	r1, #24
 8000b5a:	4819      	ldr	r0, [pc, #100]	; (8000bc0 <MX_GPIO_Init+0xf8>)
 8000b5c:	f001 f928 	bl	8001db0 <HAL_GPIO_WritePin>

  /*Configure GPIO pin Output Level */
  HAL_GPIO_WritePin(GPIO_RESET_GPIO_Port, GPIO_RESET_Pin, GPIO_PIN_SET);
 8000b60:	2201      	movs	r2, #1
 8000b62:	2104      	movs	r1, #4
 8000b64:	4816      	ldr	r0, [pc, #88]	; (8000bc0 <MX_GPIO_Init+0xf8>)
 8000b66:	f001 f923 	bl	8001db0 <HAL_GPIO_WritePin>

  /*Configure GPIO pins : PKPin PKPin PKPin */
  GPIO_InitStruct.Pin = LED2_Pin|LED1_Pin|GPIO_RESET_Pin;
 8000b6a:	231c      	movs	r3, #28
 8000b6c:	617b      	str	r3, [r7, #20]
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
 8000b6e:	2301      	movs	r3, #1
 8000b70:	61bb      	str	r3, [r7, #24]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 8000b72:	2300      	movs	r3, #0
 8000b74:	61fb      	str	r3, [r7, #28]
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
 8000b76:	2300      	movs	r3, #0
 8000b78:	623b      	str	r3, [r7, #32]
  HAL_GPIO_Init(GPIOK, &GPIO_InitStruct);
 8000b7a:	f107 0314 	add.w	r3, r7, #20
 8000b7e:	4619      	mov	r1, r3
 8000b80:	480f      	ldr	r0, [pc, #60]	; (8000bc0 <MX_GPIO_Init+0xf8>)
 8000b82:	f000 ff4d 	bl	8001a20 <HAL_GPIO_Init>

  /*Configure GPIO pins : PJPin PJPin */
  GPIO_InitStruct.Pin = GPIO_DATA_READY_Pin|GPIO_HANDSHAKE_Pin;
 8000b86:	f44f 43c0 	mov.w	r3, #24576	; 0x6000
 8000b8a:	617b      	str	r3, [r7, #20]
  GPIO_InitStruct.Mode = GPIO_MODE_IT_RISING;
 8000b8c:	f44f 1388 	mov.w	r3, #1114112	; 0x110000
 8000b90:	61bb      	str	r3, [r7, #24]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 8000b92:	2300      	movs	r3, #0
 8000b94:	61fb      	str	r3, [r7, #28]
  HAL_GPIO_Init(GPIOJ, &GPIO_InitStruct);
 8000b96:	f107 0314 	add.w	r3, r7, #20
 8000b9a:	4619      	mov	r1, r3
 8000b9c:	4809      	ldr	r0, [pc, #36]	; (8000bc4 <MX_GPIO_Init+0xfc>)
 8000b9e:	f000 ff3f 	bl	8001a20 <HAL_GPIO_Init>

  /* EXTI interrupt init*/
  HAL_NVIC_SetPriority(EXTI15_10_IRQn, 8, 0);
 8000ba2:	2200      	movs	r2, #0
 8000ba4:	2108      	movs	r1, #8
 8000ba6:	2028      	movs	r0, #40	; 0x28
 8000ba8:	f000 fe96 	bl	80018d8 <HAL_NVIC_SetPriority>
  HAL_NVIC_EnableIRQ(EXTI15_10_IRQn);
 8000bac:	2028      	movs	r0, #40	; 0x28
 8000bae:	f000 fead 	bl	800190c <HAL_NVIC_EnableIRQ>

}
 8000bb2:	bf00      	nop
 8000bb4:	3728      	adds	r7, #40	; 0x28
 8000bb6:	46bd      	mov	sp, r7
 8000bb8:	bd80      	pop	{r7, pc}
 8000bba:	bf00      	nop
 8000bbc:	58024400 	.word	0x58024400
 8000bc0:	58022800 	.word	0x58022800
 8000bc4:	58022400 	.word	0x58022400

08000bc8 <main>:
/**
  * @brief  The application entry point.
  * @retval int
  */
int main(void)
{
 8000bc8:	b580      	push	{r7, lr}
 8000bca:	b086      	sub	sp, #24
 8000bcc:	af00      	add	r7, sp, #0
/* USER CODE BEGIN Boot_Mode_Sequence_0 */
  int32_t timeout;
/* USER CODE END Boot_Mode_Sequence_0 */

  /* MPU Configuration--------------------------------------------------------*/
  MPU_Config();
 8000bce:	f000 f92d 	bl	8000e2c <MPU_Config>
  \details Turns on I-Cache
  */
__STATIC_FORCEINLINE void SCB_EnableICache (void)
{
  #if defined (__ICACHE_PRESENT) && (__ICACHE_PRESENT == 1U)
    if (SCB->CCR & SCB_CCR_IC_Msk) return;  /* return if ICache is already enabled */
 8000bd2:	4b57      	ldr	r3, [pc, #348]	; (8000d30 <main+0x168>)
 8000bd4:	695b      	ldr	r3, [r3, #20]
 8000bd6:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
 8000bda:	2b00      	cmp	r3, #0
 8000bdc:	d11b      	bne.n	8000c16 <main+0x4e>
  \details Acts as a special kind of Data Memory Barrier.
           It completes when all explicit memory accesses before this instruction complete.
 */
__STATIC_FORCEINLINE void __DSB(void)
{
  __ASM volatile ("dsb 0xF":::"memory");
 8000bde:	f3bf 8f4f 	dsb	sy
}
 8000be2:	bf00      	nop
  __ASM volatile ("isb 0xF":::"memory");
 8000be4:	f3bf 8f6f 	isb	sy
}
 8000be8:	bf00      	nop

    __DSB();
    __ISB();
    SCB->ICIALLU = 0UL;                     /* invalidate I-Cache */
 8000bea:	4b51      	ldr	r3, [pc, #324]	; (8000d30 <main+0x168>)
 8000bec:	2200      	movs	r2, #0
 8000bee:	f8c3 2250 	str.w	r2, [r3, #592]	; 0x250
  __ASM volatile ("dsb 0xF":::"memory");
 8000bf2:	f3bf 8f4f 	dsb	sy
}
 8000bf6:	bf00      	nop
  __ASM volatile ("isb 0xF":::"memory");
 8000bf8:	f3bf 8f6f 	isb	sy
}
 8000bfc:	bf00      	nop
    __DSB();
    __ISB();
    SCB->CCR |=  (uint32_t)SCB_CCR_IC_Msk;  /* enable I-Cache */
 8000bfe:	4b4c      	ldr	r3, [pc, #304]	; (8000d30 <main+0x168>)
 8000c00:	695b      	ldr	r3, [r3, #20]
 8000c02:	4a4b      	ldr	r2, [pc, #300]	; (8000d30 <main+0x168>)
 8000c04:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
 8000c08:	6153      	str	r3, [r2, #20]
  __ASM volatile ("dsb 0xF":::"memory");
 8000c0a:	f3bf 8f4f 	dsb	sy
}
 8000c0e:	bf00      	nop
  __ASM volatile ("isb 0xF":::"memory");
 8000c10:	f3bf 8f6f 	isb	sy
}
 8000c14:	e000      	b.n	8000c18 <main+0x50>
    if (SCB->CCR & SCB_CCR_IC_Msk) return;  /* return if ICache is already enabled */
 8000c16:	bf00      	nop
  #if defined (__DCACHE_PRESENT) && (__DCACHE_PRESENT == 1U)
    uint32_t ccsidr;
    uint32_t sets;
    uint32_t ways;

    if (SCB->CCR & SCB_CCR_DC_Msk) return;  /* return if DCache is already enabled */
 8000c18:	4b45      	ldr	r3, [pc, #276]	; (8000d30 <main+0x168>)
 8000c1a:	695b      	ldr	r3, [r3, #20]
 8000c1c:	f403 3380 	and.w	r3, r3, #65536	; 0x10000
 8000c20:	2b00      	cmp	r3, #0
 8000c22:	d138      	bne.n	8000c96 <main+0xce>

    SCB->CSSELR = 0U;                       /* select Level 1 data cache */
 8000c24:	4b42      	ldr	r3, [pc, #264]	; (8000d30 <main+0x168>)
 8000c26:	2200      	movs	r2, #0
 8000c28:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84
  __ASM volatile ("dsb 0xF":::"memory");
 8000c2c:	f3bf 8f4f 	dsb	sy
}
 8000c30:	bf00      	nop
    __DSB();

    ccsidr = SCB->CCSIDR;
 8000c32:	4b3f      	ldr	r3, [pc, #252]	; (8000d30 <main+0x168>)
 8000c34:	f8d3 3080 	ldr.w	r3, [r3, #128]	; 0x80
 8000c38:	613b      	str	r3, [r7, #16]

                                            /* invalidate D-Cache */
    sets = (uint32_t)(CCSIDR_SETS(ccsidr));
 8000c3a:	693b      	ldr	r3, [r7, #16]
 8000c3c:	0b5b      	lsrs	r3, r3, #13
 8000c3e:	f3c3 030e 	ubfx	r3, r3, #0, #15
 8000c42:	60fb      	str	r3, [r7, #12]
    do {
      ways = (uint32_t)(CCSIDR_WAYS(ccsidr));
 8000c44:	693b      	ldr	r3, [r7, #16]
 8000c46:	08db      	lsrs	r3, r3, #3
 8000c48:	f3c3 0309 	ubfx	r3, r3, #0, #10
 8000c4c:	60bb      	str	r3, [r7, #8]
      do {
        SCB->DCISW = (((sets << SCB_DCISW_SET_Pos) & SCB_DCISW_SET_Msk) |
 8000c4e:	68fb      	ldr	r3, [r7, #12]
 8000c50:	015a      	lsls	r2, r3, #5
 8000c52:	f643 73e0 	movw	r3, #16352	; 0x3fe0
 8000c56:	4013      	ands	r3, r2
                      ((ways << SCB_DCISW_WAY_Pos) & SCB_DCISW_WAY_Msk)  );
 8000c58:	68ba      	ldr	r2, [r7, #8]
 8000c5a:	0792      	lsls	r2, r2, #30
        SCB->DCISW = (((sets << SCB_DCISW_SET_Pos) & SCB_DCISW_SET_Msk) |
 8000c5c:	4934      	ldr	r1, [pc, #208]	; (8000d30 <main+0x168>)
 8000c5e:	4313      	orrs	r3, r2
 8000c60:	f8c1 3260 	str.w	r3, [r1, #608]	; 0x260
        #if defined ( __CC_ARM )
          __schedule_barrier();
        #endif
      } while (ways-- != 0U);
 8000c64:	68bb      	ldr	r3, [r7, #8]
 8000c66:	1e5a      	subs	r2, r3, #1
 8000c68:	60ba      	str	r2, [r7, #8]
 8000c6a:	2b00      	cmp	r3, #0
 8000c6c:	d1ef      	bne.n	8000c4e <main+0x86>
    } while(sets-- != 0U);
 8000c6e:	68fb      	ldr	r3, [r7, #12]
 8000c70:	1e5a      	subs	r2, r3, #1
 8000c72:	60fa      	str	r2, [r7, #12]
 8000c74:	2b00      	cmp	r3, #0
 8000c76:	d1e5      	bne.n	8000c44 <main+0x7c>
  __ASM volatile ("dsb 0xF":::"memory");
 8000c78:	f3bf 8f4f 	dsb	sy
}
 8000c7c:	bf00      	nop
    __DSB();

    SCB->CCR |=  (uint32_t)SCB_CCR_DC_Msk;  /* enable D-Cache */
 8000c7e:	4b2c      	ldr	r3, [pc, #176]	; (8000d30 <main+0x168>)
 8000c80:	695b      	ldr	r3, [r3, #20]
 8000c82:	4a2b      	ldr	r2, [pc, #172]	; (8000d30 <main+0x168>)
 8000c84:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 8000c88:	6153      	str	r3, [r2, #20]
  __ASM volatile ("dsb 0xF":::"memory");
 8000c8a:	f3bf 8f4f 	dsb	sy
}
 8000c8e:	bf00      	nop
  __ASM volatile ("isb 0xF":::"memory");
 8000c90:	f3bf 8f6f 	isb	sy
}
 8000c94:	e000      	b.n	8000c98 <main+0xd0>
    if (SCB->CCR & SCB_CCR_DC_Msk) return;  /* return if DCache is already enabled */
 8000c96:	bf00      	nop
  /* Enable D-Cache---------------------------------------------------------*/
  SCB_EnableDCache();

/* USER CODE BEGIN Boot_Mode_Sequence_1 */
  /* Wait until CPU2 boots and enters in stop mode or timeout*/
  timeout = 0xFFFF;
 8000c98:	f64f 73ff 	movw	r3, #65535	; 0xffff
 8000c9c:	617b      	str	r3, [r7, #20]
  while((__HAL_RCC_GET_FLAG(RCC_FLAG_D2CKRDY) != RESET) && (timeout-- > 0));
 8000c9e:	bf00      	nop
 8000ca0:	4b24      	ldr	r3, [pc, #144]	; (8000d34 <main+0x16c>)
 8000ca2:	681b      	ldr	r3, [r3, #0]
 8000ca4:	f403 4300 	and.w	r3, r3, #32768	; 0x8000
 8000ca8:	2b00      	cmp	r3, #0
 8000caa:	d004      	beq.n	8000cb6 <main+0xee>
 8000cac:	697b      	ldr	r3, [r7, #20]
 8000cae:	1e5a      	subs	r2, r3, #1
 8000cb0:	617a      	str	r2, [r7, #20]
 8000cb2:	2b00      	cmp	r3, #0
 8000cb4:	dcf4      	bgt.n	8000ca0 <main+0xd8>
  if ( timeout < 0 )
 8000cb6:	697b      	ldr	r3, [r7, #20]
 8000cb8:	2b00      	cmp	r3, #0
 8000cba:	da01      	bge.n	8000cc0 <main+0xf8>
  {
  Error_Handler();
 8000cbc:	f000 f8f6 	bl	8000eac <Error_Handler>
  }
/* USER CODE END Boot_Mode_Sequence_1 */
  /* MCU Configuration--------------------------------------------------------*/

  /* Reset of all peripherals, Initializes the Flash interface and the Systick. */
  HAL_Init();
 8000cc0:	f000 fcea 	bl	8001698 <HAL_Init>
  /* USER CODE BEGIN Init */

  /* USER CODE END Init */

  /* Configure the system clock */
  SystemClock_Config();
 8000cc4:	f000 f838 	bl	8000d38 <SystemClock_Config>
/* USER CODE BEGIN Boot_Mode_Sequence_2 */
/* When system initialization is finished, Cortex-M7 will release Cortex-M4 by means of
HSEM notification */
/*HW semaphore Clock enable*/
__HAL_RCC_HSEM_CLK_ENABLE();
 8000cc8:	4b1a      	ldr	r3, [pc, #104]	; (8000d34 <main+0x16c>)
 8000cca:	f8d3 30e0 	ldr.w	r3, [r3, #224]	; 0xe0
 8000cce:	4a19      	ldr	r2, [pc, #100]	; (8000d34 <main+0x16c>)
 8000cd0:	f043 7300 	orr.w	r3, r3, #33554432	; 0x2000000
 8000cd4:	f8c2 30e0 	str.w	r3, [r2, #224]	; 0xe0
 8000cd8:	4b16      	ldr	r3, [pc, #88]	; (8000d34 <main+0x16c>)
 8000cda:	f8d3 30e0 	ldr.w	r3, [r3, #224]	; 0xe0
 8000cde:	f003 7300 	and.w	r3, r3, #33554432	; 0x2000000
 8000ce2:	607b      	str	r3, [r7, #4]
 8000ce4:	687b      	ldr	r3, [r7, #4]
/*Take HSEM */
HAL_HSEM_FastTake(HSEM_ID_0);
 8000ce6:	2000      	movs	r0, #0
 8000ce8:	f001 f896 	bl	8001e18 <HAL_HSEM_FastTake>
/*Release HSEM in order to notify the CPU2(CM4)*/
HAL_HSEM_Release(HSEM_ID_0,0);
 8000cec:	2100      	movs	r1, #0
 8000cee:	2000      	movs	r0, #0
 8000cf0:	f001 f8ac 	bl	8001e4c <HAL_HSEM_Release>
/* wait until CPU2 wakes up from stop mode */
timeout = 0xFFFF;
 8000cf4:	f64f 73ff 	movw	r3, #65535	; 0xffff
 8000cf8:	617b      	str	r3, [r7, #20]
while((__HAL_RCC_GET_FLAG(RCC_FLAG_D2CKRDY) == RESET) && (timeout-- > 0));
 8000cfa:	bf00      	nop
 8000cfc:	4b0d      	ldr	r3, [pc, #52]	; (8000d34 <main+0x16c>)
 8000cfe:	681b      	ldr	r3, [r3, #0]
 8000d00:	f403 4300 	and.w	r3, r3, #32768	; 0x8000
 8000d04:	2b00      	cmp	r3, #0
 8000d06:	d104      	bne.n	8000d12 <main+0x14a>
 8000d08:	697b      	ldr	r3, [r7, #20]
 8000d0a:	1e5a      	subs	r2, r3, #1
 8000d0c:	617a      	str	r2, [r7, #20]
 8000d0e:	2b00      	cmp	r3, #0
 8000d10:	dcf4      	bgt.n	8000cfc <main+0x134>
if ( timeout < 0 )
 8000d12:	697b      	ldr	r3, [r7, #20]
 8000d14:	2b00      	cmp	r3, #0
 8000d16:	da01      	bge.n	8000d1c <main+0x154>
{
Error_Handler();
 8000d18:	f000 f8c8 	bl	8000eac <Error_Handler>
  /* USER CODE BEGIN SysInit */

  /* USER CODE END SysInit */

  /* Initialize all configured peripherals */
  MX_GPIO_Init();
 8000d1c:	f7ff fed4 	bl	8000ac8 <MX_GPIO_Init>
  MX_USART1_UART_Init();
 8000d20:	f000 fb1a 	bl	8001358 <MX_USART1_UART_Init>
  MX_SPI5_Init();
 8000d24:	f000 f8c8 	bl	8000eb8 <MX_SPI5_Init>
  /* USER CODE BEGIN 2 */
//  App_TX_FreeRTOS_Init();
  /* USER CODE END 2 */

  MX_ThreadX_Init();
 8000d28:	f7ff fec7 	bl	8000aba <MX_ThreadX_Init>
  //MX_FREERTOS_Init();
  /* We should never get here as control is now taken by the scheduler */
  /* Infinite loop */
  /* USER CODE BEGIN WHILE */
  while (1)
 8000d2c:	e7fe      	b.n	8000d2c <main+0x164>
 8000d2e:	bf00      	nop
 8000d30:	e000ed00 	.word	0xe000ed00
 8000d34:	58024400 	.word	0x58024400

08000d38 <SystemClock_Config>:
/**
  * @brief System Clock Configuration
  * @retval None
  */
void SystemClock_Config(void)
{
 8000d38:	b580      	push	{r7, lr}
 8000d3a:	b09c      	sub	sp, #112	; 0x70
 8000d3c:	af00      	add	r7, sp, #0
  RCC_OscInitTypeDef RCC_OscInitStruct = {0};
 8000d3e:	f107 0324 	add.w	r3, r7, #36	; 0x24
 8000d42:	224c      	movs	r2, #76	; 0x4c
 8000d44:	2100      	movs	r1, #0
 8000d46:	4618      	mov	r0, r3
 8000d48:	f01e fd98 	bl	801f87c <memset>
  RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};
 8000d4c:	1d3b      	adds	r3, r7, #4
 8000d4e:	2220      	movs	r2, #32
 8000d50:	2100      	movs	r1, #0
 8000d52:	4618      	mov	r0, r3
 8000d54:	f01e fd92 	bl	801f87c <memset>

  /** Supply configuration update enable
  */
  HAL_PWREx_ConfigSupply(PWR_DIRECT_SMPS_SUPPLY);
 8000d58:	2004      	movs	r0, #4
 8000d5a:	f001 f88b 	bl	8001e74 <HAL_PWREx_ConfigSupply>

  /** Configure the main internal regulator output voltage
  */
  __HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE0);
 8000d5e:	2300      	movs	r3, #0
 8000d60:	603b      	str	r3, [r7, #0]
 8000d62:	4b30      	ldr	r3, [pc, #192]	; (8000e24 <SystemClock_Config+0xec>)
 8000d64:	699b      	ldr	r3, [r3, #24]
 8000d66:	4a2f      	ldr	r2, [pc, #188]	; (8000e24 <SystemClock_Config+0xec>)
 8000d68:	f443 4340 	orr.w	r3, r3, #49152	; 0xc000
 8000d6c:	6193      	str	r3, [r2, #24]
 8000d6e:	4b2d      	ldr	r3, [pc, #180]	; (8000e24 <SystemClock_Config+0xec>)
 8000d70:	699b      	ldr	r3, [r3, #24]
 8000d72:	f403 4340 	and.w	r3, r3, #49152	; 0xc000
 8000d76:	603b      	str	r3, [r7, #0]
 8000d78:	4b2b      	ldr	r3, [pc, #172]	; (8000e28 <SystemClock_Config+0xf0>)
 8000d7a:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8000d7c:	4a2a      	ldr	r2, [pc, #168]	; (8000e28 <SystemClock_Config+0xf0>)
 8000d7e:	f043 0301 	orr.w	r3, r3, #1
 8000d82:	62d3      	str	r3, [r2, #44]	; 0x2c
 8000d84:	4b28      	ldr	r3, [pc, #160]	; (8000e28 <SystemClock_Config+0xf0>)
 8000d86:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8000d88:	f003 0301 	and.w	r3, r3, #1
 8000d8c:	603b      	str	r3, [r7, #0]
 8000d8e:	683b      	ldr	r3, [r7, #0]

  while(!__HAL_PWR_GET_FLAG(PWR_FLAG_VOSRDY)) {}
 8000d90:	bf00      	nop
 8000d92:	4b24      	ldr	r3, [pc, #144]	; (8000e24 <SystemClock_Config+0xec>)
 8000d94:	699b      	ldr	r3, [r3, #24]
 8000d96:	f403 5300 	and.w	r3, r3, #8192	; 0x2000
 8000d9a:	f5b3 5f00 	cmp.w	r3, #8192	; 0x2000
 8000d9e:	d1f8      	bne.n	8000d92 <SystemClock_Config+0x5a>

  /** Initializes the RCC Oscillators according to the specified parameters
  * in the RCC_OscInitTypeDef structure.
  */
  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE;
 8000da0:	2301      	movs	r3, #1
 8000da2:	627b      	str	r3, [r7, #36]	; 0x24
  RCC_OscInitStruct.HSEState = RCC_HSE_ON;
 8000da4:	f44f 3380 	mov.w	r3, #65536	; 0x10000
 8000da8:	62bb      	str	r3, [r7, #40]	; 0x28
  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
 8000daa:	2302      	movs	r3, #2
 8000dac:	64bb      	str	r3, [r7, #72]	; 0x48
  RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;
 8000dae:	2302      	movs	r3, #2
 8000db0:	64fb      	str	r3, [r7, #76]	; 0x4c
  RCC_OscInitStruct.PLL.PLLM = 5;
 8000db2:	2305      	movs	r3, #5
 8000db4:	653b      	str	r3, [r7, #80]	; 0x50
  RCC_OscInitStruct.PLL.PLLN = 192;
 8000db6:	23c0      	movs	r3, #192	; 0xc0
 8000db8:	657b      	str	r3, [r7, #84]	; 0x54
  RCC_OscInitStruct.PLL.PLLP = 2;
 8000dba:	2302      	movs	r3, #2
 8000dbc:	65bb      	str	r3, [r7, #88]	; 0x58
  RCC_OscInitStruct.PLL.PLLQ = 10;
 8000dbe:	230a      	movs	r3, #10
 8000dc0:	65fb      	str	r3, [r7, #92]	; 0x5c
  RCC_OscInitStruct.PLL.PLLR = 2;
 8000dc2:	2302      	movs	r3, #2
 8000dc4:	663b      	str	r3, [r7, #96]	; 0x60
  RCC_OscInitStruct.PLL.PLLRGE = RCC_PLL1VCIRANGE_2;
 8000dc6:	2308      	movs	r3, #8
 8000dc8:	667b      	str	r3, [r7, #100]	; 0x64
  RCC_OscInitStruct.PLL.PLLVCOSEL = RCC_PLL1VCOWIDE;
 8000dca:	2300      	movs	r3, #0
 8000dcc:	66bb      	str	r3, [r7, #104]	; 0x68
  RCC_OscInitStruct.PLL.PLLFRACN = 0;
 8000dce:	2300      	movs	r3, #0
 8000dd0:	66fb      	str	r3, [r7, #108]	; 0x6c
  if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
 8000dd2:	f107 0324 	add.w	r3, r7, #36	; 0x24
 8000dd6:	4618      	mov	r0, r3
 8000dd8:	f001 f8a6 	bl	8001f28 <HAL_RCC_OscConfig>
 8000ddc:	4603      	mov	r3, r0
 8000dde:	2b00      	cmp	r3, #0
 8000de0:	d001      	beq.n	8000de6 <SystemClock_Config+0xae>
  {
    Error_Handler();
 8000de2:	f000 f863 	bl	8000eac <Error_Handler>
  }

  /** Initializes the CPU, AHB and APB buses clocks
  */
  RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
 8000de6:	233f      	movs	r3, #63	; 0x3f
 8000de8:	607b      	str	r3, [r7, #4]
                              |RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2
                              |RCC_CLOCKTYPE_D3PCLK1|RCC_CLOCKTYPE_D1PCLK1;
  RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
 8000dea:	2303      	movs	r3, #3
 8000dec:	60bb      	str	r3, [r7, #8]
  RCC_ClkInitStruct.SYSCLKDivider = RCC_SYSCLK_DIV1;
 8000dee:	2300      	movs	r3, #0
 8000df0:	60fb      	str	r3, [r7, #12]
  RCC_ClkInitStruct.AHBCLKDivider = RCC_HCLK_DIV2;
 8000df2:	2308      	movs	r3, #8
 8000df4:	613b      	str	r3, [r7, #16]
  RCC_ClkInitStruct.APB3CLKDivider = RCC_APB3_DIV2;
 8000df6:	2340      	movs	r3, #64	; 0x40
 8000df8:	617b      	str	r3, [r7, #20]
  RCC_ClkInitStruct.APB1CLKDivider = RCC_APB1_DIV2;
 8000dfa:	2340      	movs	r3, #64	; 0x40
 8000dfc:	61bb      	str	r3, [r7, #24]
  RCC_ClkInitStruct.APB2CLKDivider = RCC_APB2_DIV2;
 8000dfe:	f44f 6380 	mov.w	r3, #1024	; 0x400
 8000e02:	61fb      	str	r3, [r7, #28]
  RCC_ClkInitStruct.APB4CLKDivider = RCC_APB4_DIV2;
 8000e04:	2340      	movs	r3, #64	; 0x40
 8000e06:	623b      	str	r3, [r7, #32]

  if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_4) != HAL_OK)
 8000e08:	1d3b      	adds	r3, r7, #4
 8000e0a:	2104      	movs	r1, #4
 8000e0c:	4618      	mov	r0, r3
 8000e0e:	f001 fcb9 	bl	8002784 <HAL_RCC_ClockConfig>
 8000e12:	4603      	mov	r3, r0
 8000e14:	2b00      	cmp	r3, #0
 8000e16:	d001      	beq.n	8000e1c <SystemClock_Config+0xe4>
  {
    Error_Handler();
 8000e18:	f000 f848 	bl	8000eac <Error_Handler>
  }
}
 8000e1c:	bf00      	nop
 8000e1e:	3770      	adds	r7, #112	; 0x70
 8000e20:	46bd      	mov	sp, r7
 8000e22:	bd80      	pop	{r7, pc}
 8000e24:	58024800 	.word	0x58024800
 8000e28:	58000400 	.word	0x58000400

08000e2c <MPU_Config>:
/* USER CODE END 4 */

/* MPU Configuration */

void MPU_Config(void)
{
 8000e2c:	b580      	push	{r7, lr}
 8000e2e:	b084      	sub	sp, #16
 8000e30:	af00      	add	r7, sp, #0
  MPU_Region_InitTypeDef MPU_InitStruct = {0};
 8000e32:	463b      	mov	r3, r7
 8000e34:	2200      	movs	r2, #0
 8000e36:	601a      	str	r2, [r3, #0]
 8000e38:	605a      	str	r2, [r3, #4]
 8000e3a:	609a      	str	r2, [r3, #8]
 8000e3c:	60da      	str	r2, [r3, #12]

  /* Disables the MPU */
  HAL_MPU_Disable();
 8000e3e:	f000 fd73 	bl	8001928 <HAL_MPU_Disable>

  /** Initializes and configures the Region and the memory to be protected
  */
  MPU_InitStruct.Enable = MPU_REGION_ENABLE;
 8000e42:	2301      	movs	r3, #1
 8000e44:	703b      	strb	r3, [r7, #0]
  MPU_InitStruct.Number = MPU_REGION_NUMBER0;
 8000e46:	2300      	movs	r3, #0
 8000e48:	707b      	strb	r3, [r7, #1]
  MPU_InitStruct.BaseAddress = 0x30000000;
 8000e4a:	f04f 5340 	mov.w	r3, #805306368	; 0x30000000
 8000e4e:	607b      	str	r3, [r7, #4]
  MPU_InitStruct.Size = MPU_REGION_SIZE_64KB;
 8000e50:	230f      	movs	r3, #15
 8000e52:	723b      	strb	r3, [r7, #8]
  MPU_InitStruct.SubRegionDisable = 0x0;
 8000e54:	2300      	movs	r3, #0
 8000e56:	727b      	strb	r3, [r7, #9]
  MPU_InitStruct.TypeExtField = MPU_TEX_LEVEL0;
 8000e58:	2300      	movs	r3, #0
 8000e5a:	72bb      	strb	r3, [r7, #10]
  MPU_InitStruct.AccessPermission = MPU_REGION_FULL_ACCESS;
 8000e5c:	2303      	movs	r3, #3
 8000e5e:	72fb      	strb	r3, [r7, #11]
  MPU_InitStruct.DisableExec = MPU_INSTRUCTION_ACCESS_DISABLE;
 8000e60:	2301      	movs	r3, #1
 8000e62:	733b      	strb	r3, [r7, #12]
  MPU_InitStruct.IsShareable = MPU_ACCESS_SHAREABLE;
 8000e64:	2301      	movs	r3, #1
 8000e66:	737b      	strb	r3, [r7, #13]
  MPU_InitStruct.IsCacheable = MPU_ACCESS_NOT_CACHEABLE;
 8000e68:	2300      	movs	r3, #0
 8000e6a:	73bb      	strb	r3, [r7, #14]
  MPU_InitStruct.IsBufferable = MPU_ACCESS_BUFFERABLE;
 8000e6c:	2301      	movs	r3, #1
 8000e6e:	73fb      	strb	r3, [r7, #15]

  HAL_MPU_ConfigRegion(&MPU_InitStruct);
 8000e70:	463b      	mov	r3, r7
 8000e72:	4618      	mov	r0, r3
 8000e74:	f000 fd90 	bl	8001998 <HAL_MPU_ConfigRegion>
  /* Enables the MPU */
  HAL_MPU_Enable(MPU_PRIVILEGED_DEFAULT);
 8000e78:	2004      	movs	r0, #4
 8000e7a:	f000 fd6d 	bl	8001958 <HAL_MPU_Enable>

}
 8000e7e:	bf00      	nop
 8000e80:	3710      	adds	r7, #16
 8000e82:	46bd      	mov	sp, r7
 8000e84:	bd80      	pop	{r7, pc}
	...

08000e88 <HAL_TIM_PeriodElapsedCallback>:
  * a global variable "uwTick" used as application time base.
  * @param  htim : TIM handle
  * @retval None
  */
void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim)
{
 8000e88:	b580      	push	{r7, lr}
 8000e8a:	b082      	sub	sp, #8
 8000e8c:	af00      	add	r7, sp, #0
 8000e8e:	6078      	str	r0, [r7, #4]
  /* USER CODE BEGIN Callback 0 */

  /* USER CODE END Callback 0 */
  if (htim->Instance == TIM1) {
 8000e90:	687b      	ldr	r3, [r7, #4]
 8000e92:	681b      	ldr	r3, [r3, #0]
 8000e94:	4a04      	ldr	r2, [pc, #16]	; (8000ea8 <HAL_TIM_PeriodElapsedCallback+0x20>)
 8000e96:	4293      	cmp	r3, r2
 8000e98:	d101      	bne.n	8000e9e <HAL_TIM_PeriodElapsedCallback+0x16>
    HAL_IncTick();
 8000e9a:	f000 fc39 	bl	8001710 <HAL_IncTick>
  }
  /* USER CODE BEGIN Callback 1 */

  /* USER CODE END Callback 1 */
}
 8000e9e:	bf00      	nop
 8000ea0:	3708      	adds	r7, #8
 8000ea2:	46bd      	mov	sp, r7
 8000ea4:	bd80      	pop	{r7, pc}
 8000ea6:	bf00      	nop
 8000ea8:	40010000 	.word	0x40010000

08000eac <Error_Handler>:
/**
  * @brief  This function is executed in case of error occurrence.
  * @retval None
  */
void Error_Handler(void)
{
 8000eac:	b480      	push	{r7}
 8000eae:	af00      	add	r7, sp, #0
  __ASM volatile ("cpsid i" : : : "memory");
 8000eb0:	b672      	cpsid	i
}
 8000eb2:	bf00      	nop
  /* USER CODE BEGIN Error_Handler_Debug */
  /* User can add his own implementation to report the HAL error return state */
  __disable_irq();
  while (1)
 8000eb4:	e7fe      	b.n	8000eb4 <Error_Handler+0x8>
	...

08000eb8 <MX_SPI5_Init>:

SPI_HandleTypeDef hspi5;

/* SPI5 init function */
void MX_SPI5_Init(void)
{
 8000eb8:	b580      	push	{r7, lr}
 8000eba:	af00      	add	r7, sp, #0
  /* USER CODE END SPI5_Init 0 */

  /* USER CODE BEGIN SPI5_Init 1 */

  /* USER CODE END SPI5_Init 1 */
  hspi5.Instance = SPI5;
 8000ebc:	4b27      	ldr	r3, [pc, #156]	; (8000f5c <MX_SPI5_Init+0xa4>)
 8000ebe:	4a28      	ldr	r2, [pc, #160]	; (8000f60 <MX_SPI5_Init+0xa8>)
 8000ec0:	601a      	str	r2, [r3, #0]
  hspi5.Init.Mode = SPI_MODE_MASTER;
 8000ec2:	4b26      	ldr	r3, [pc, #152]	; (8000f5c <MX_SPI5_Init+0xa4>)
 8000ec4:	f44f 0280 	mov.w	r2, #4194304	; 0x400000
 8000ec8:	605a      	str	r2, [r3, #4]
  hspi5.Init.Direction = SPI_DIRECTION_2LINES;
 8000eca:	4b24      	ldr	r3, [pc, #144]	; (8000f5c <MX_SPI5_Init+0xa4>)
 8000ecc:	2200      	movs	r2, #0
 8000ece:	609a      	str	r2, [r3, #8]
  hspi5.Init.DataSize = SPI_DATASIZE_8BIT;
 8000ed0:	4b22      	ldr	r3, [pc, #136]	; (8000f5c <MX_SPI5_Init+0xa4>)
 8000ed2:	2207      	movs	r2, #7
 8000ed4:	60da      	str	r2, [r3, #12]
  hspi5.Init.CLKPolarity = SPI_POLARITY_HIGH;
 8000ed6:	4b21      	ldr	r3, [pc, #132]	; (8000f5c <MX_SPI5_Init+0xa4>)
 8000ed8:	f04f 7200 	mov.w	r2, #33554432	; 0x2000000
 8000edc:	611a      	str	r2, [r3, #16]
  hspi5.Init.CLKPhase = SPI_PHASE_1EDGE;
 8000ede:	4b1f      	ldr	r3, [pc, #124]	; (8000f5c <MX_SPI5_Init+0xa4>)
 8000ee0:	2200      	movs	r2, #0
 8000ee2:	615a      	str	r2, [r3, #20]
  hspi5.Init.NSS = SPI_NSS_HARD_OUTPUT;
 8000ee4:	4b1d      	ldr	r3, [pc, #116]	; (8000f5c <MX_SPI5_Init+0xa4>)
 8000ee6:	f04f 5200 	mov.w	r2, #536870912	; 0x20000000
 8000eea:	619a      	str	r2, [r3, #24]
  hspi5.Init.BaudRatePrescaler = SPI_BAUDRATEPRESCALER_16;
 8000eec:	4b1b      	ldr	r3, [pc, #108]	; (8000f5c <MX_SPI5_Init+0xa4>)
 8000eee:	f04f 5240 	mov.w	r2, #805306368	; 0x30000000
 8000ef2:	61da      	str	r2, [r3, #28]
  hspi5.Init.FirstBit = SPI_FIRSTBIT_MSB;
 8000ef4:	4b19      	ldr	r3, [pc, #100]	; (8000f5c <MX_SPI5_Init+0xa4>)
 8000ef6:	2200      	movs	r2, #0
 8000ef8:	621a      	str	r2, [r3, #32]
  hspi5.Init.TIMode = SPI_TIMODE_DISABLE;
 8000efa:	4b18      	ldr	r3, [pc, #96]	; (8000f5c <MX_SPI5_Init+0xa4>)
 8000efc:	2200      	movs	r2, #0
 8000efe:	625a      	str	r2, [r3, #36]	; 0x24
  hspi5.Init.CRCCalculation = SPI_CRCCALCULATION_DISABLE;
 8000f00:	4b16      	ldr	r3, [pc, #88]	; (8000f5c <MX_SPI5_Init+0xa4>)
 8000f02:	2200      	movs	r2, #0
 8000f04:	629a      	str	r2, [r3, #40]	; 0x28
  hspi5.Init.CRCPolynomial = 0x0;
 8000f06:	4b15      	ldr	r3, [pc, #84]	; (8000f5c <MX_SPI5_Init+0xa4>)
 8000f08:	2200      	movs	r2, #0
 8000f0a:	62da      	str	r2, [r3, #44]	; 0x2c
  hspi5.Init.NSSPMode = SPI_NSS_PULSE_DISABLE;
 8000f0c:	4b13      	ldr	r3, [pc, #76]	; (8000f5c <MX_SPI5_Init+0xa4>)
 8000f0e:	2200      	movs	r2, #0
 8000f10:	635a      	str	r2, [r3, #52]	; 0x34
  hspi5.Init.NSSPolarity = SPI_NSS_POLARITY_LOW;
 8000f12:	4b12      	ldr	r3, [pc, #72]	; (8000f5c <MX_SPI5_Init+0xa4>)
 8000f14:	2200      	movs	r2, #0
 8000f16:	639a      	str	r2, [r3, #56]	; 0x38
  hspi5.Init.FifoThreshold = SPI_FIFO_THRESHOLD_01DATA;
 8000f18:	4b10      	ldr	r3, [pc, #64]	; (8000f5c <MX_SPI5_Init+0xa4>)
 8000f1a:	2200      	movs	r2, #0
 8000f1c:	63da      	str	r2, [r3, #60]	; 0x3c
  hspi5.Init.TxCRCInitializationPattern = SPI_CRC_INITIALIZATION_ALL_ZERO_PATTERN;
 8000f1e:	4b0f      	ldr	r3, [pc, #60]	; (8000f5c <MX_SPI5_Init+0xa4>)
 8000f20:	2200      	movs	r2, #0
 8000f22:	641a      	str	r2, [r3, #64]	; 0x40
  hspi5.Init.RxCRCInitializationPattern = SPI_CRC_INITIALIZATION_ALL_ZERO_PATTERN;
 8000f24:	4b0d      	ldr	r3, [pc, #52]	; (8000f5c <MX_SPI5_Init+0xa4>)
 8000f26:	2200      	movs	r2, #0
 8000f28:	645a      	str	r2, [r3, #68]	; 0x44
  hspi5.Init.MasterSSIdleness = SPI_MASTER_SS_IDLENESS_00CYCLE;
 8000f2a:	4b0c      	ldr	r3, [pc, #48]	; (8000f5c <MX_SPI5_Init+0xa4>)
 8000f2c:	2200      	movs	r2, #0
 8000f2e:	649a      	str	r2, [r3, #72]	; 0x48
  hspi5.Init.MasterInterDataIdleness = SPI_MASTER_INTERDATA_IDLENESS_00CYCLE;
 8000f30:	4b0a      	ldr	r3, [pc, #40]	; (8000f5c <MX_SPI5_Init+0xa4>)
 8000f32:	2200      	movs	r2, #0
 8000f34:	64da      	str	r2, [r3, #76]	; 0x4c
  hspi5.Init.MasterReceiverAutoSusp = SPI_MASTER_RX_AUTOSUSP_DISABLE;
 8000f36:	4b09      	ldr	r3, [pc, #36]	; (8000f5c <MX_SPI5_Init+0xa4>)
 8000f38:	2200      	movs	r2, #0
 8000f3a:	651a      	str	r2, [r3, #80]	; 0x50
  hspi5.Init.MasterKeepIOState = SPI_MASTER_KEEP_IO_STATE_DISABLE;
 8000f3c:	4b07      	ldr	r3, [pc, #28]	; (8000f5c <MX_SPI5_Init+0xa4>)
 8000f3e:	2200      	movs	r2, #0
 8000f40:	655a      	str	r2, [r3, #84]	; 0x54
  hspi5.Init.IOSwap = SPI_IO_SWAP_DISABLE;
 8000f42:	4b06      	ldr	r3, [pc, #24]	; (8000f5c <MX_SPI5_Init+0xa4>)
 8000f44:	2200      	movs	r2, #0
 8000f46:	659a      	str	r2, [r3, #88]	; 0x58
  if (HAL_SPI_Init(&hspi5) != HAL_OK)
 8000f48:	4804      	ldr	r0, [pc, #16]	; (8000f5c <MX_SPI5_Init+0xa4>)
 8000f4a:	f003 fb79 	bl	8004640 <HAL_SPI_Init>
 8000f4e:	4603      	mov	r3, r0
 8000f50:	2b00      	cmp	r3, #0
 8000f52:	d001      	beq.n	8000f58 <MX_SPI5_Init+0xa0>
  {
    Error_Handler();
 8000f54:	f7ff ffaa 	bl	8000eac <Error_Handler>
  }
  /* USER CODE BEGIN SPI5_Init 2 */

  /* USER CODE END SPI5_Init 2 */

}
 8000f58:	bf00      	nop
 8000f5a:	bd80      	pop	{r7, pc}
 8000f5c:	2400098c 	.word	0x2400098c
 8000f60:	40015000 	.word	0x40015000

08000f64 <HAL_SPI_MspInit>:

void HAL_SPI_MspInit(SPI_HandleTypeDef* spiHandle)
{
 8000f64:	b580      	push	{r7, lr}
 8000f66:	b0ba      	sub	sp, #232	; 0xe8
 8000f68:	af00      	add	r7, sp, #0
 8000f6a:	6078      	str	r0, [r7, #4]

  GPIO_InitTypeDef GPIO_InitStruct = {0};
 8000f6c:	f107 03d4 	add.w	r3, r7, #212	; 0xd4
 8000f70:	2200      	movs	r2, #0
 8000f72:	601a      	str	r2, [r3, #0]
 8000f74:	605a      	str	r2, [r3, #4]
 8000f76:	609a      	str	r2, [r3, #8]
 8000f78:	60da      	str	r2, [r3, #12]
 8000f7a:	611a      	str	r2, [r3, #16]
  RCC_PeriphCLKInitTypeDef PeriphClkInitStruct = {0};
 8000f7c:	f107 0314 	add.w	r3, r7, #20
 8000f80:	22c0      	movs	r2, #192	; 0xc0
 8000f82:	2100      	movs	r1, #0
 8000f84:	4618      	mov	r0, r3
 8000f86:	f01e fc79 	bl	801f87c <memset>
  if(spiHandle->Instance==SPI5)
 8000f8a:	687b      	ldr	r3, [r7, #4]
 8000f8c:	681b      	ldr	r3, [r3, #0]
 8000f8e:	4a37      	ldr	r2, [pc, #220]	; (800106c <HAL_SPI_MspInit+0x108>)
 8000f90:	4293      	cmp	r3, r2
 8000f92:	d166      	bne.n	8001062 <HAL_SPI_MspInit+0xfe>

  /* USER CODE END SPI5_MspInit 0 */

  /** Initializes the peripherals clock
  */
    PeriphClkInitStruct.PeriphClockSelection = RCC_PERIPHCLK_SPI5;
 8000f94:	f44f 5300 	mov.w	r3, #8192	; 0x2000
 8000f98:	617b      	str	r3, [r7, #20]
    PeriphClkInitStruct.Spi45ClockSelection = RCC_SPI45CLKSOURCE_D2PCLK1;
 8000f9a:	2300      	movs	r3, #0
 8000f9c:	67bb      	str	r3, [r7, #120]	; 0x78
    if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInitStruct) != HAL_OK)
 8000f9e:	f107 0314 	add.w	r3, r7, #20
 8000fa2:	4618      	mov	r0, r3
 8000fa4:	f001 ffbc 	bl	8002f20 <HAL_RCCEx_PeriphCLKConfig>
 8000fa8:	4603      	mov	r3, r0
 8000faa:	2b00      	cmp	r3, #0
 8000fac:	d001      	beq.n	8000fb2 <HAL_SPI_MspInit+0x4e>
    {
      Error_Handler();
 8000fae:	f7ff ff7d 	bl	8000eac <Error_Handler>
    }

    /* SPI5 clock enable */
    __HAL_RCC_SPI5_CLK_ENABLE();
 8000fb2:	4b2f      	ldr	r3, [pc, #188]	; (8001070 <HAL_SPI_MspInit+0x10c>)
 8000fb4:	f8d3 30f0 	ldr.w	r3, [r3, #240]	; 0xf0
 8000fb8:	4a2d      	ldr	r2, [pc, #180]	; (8001070 <HAL_SPI_MspInit+0x10c>)
 8000fba:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
 8000fbe:	f8c2 30f0 	str.w	r3, [r2, #240]	; 0xf0
 8000fc2:	4b2b      	ldr	r3, [pc, #172]	; (8001070 <HAL_SPI_MspInit+0x10c>)
 8000fc4:	f8d3 30f0 	ldr.w	r3, [r3, #240]	; 0xf0
 8000fc8:	f403 1380 	and.w	r3, r3, #1048576	; 0x100000
 8000fcc:	613b      	str	r3, [r7, #16]
 8000fce:	693b      	ldr	r3, [r7, #16]

    __HAL_RCC_GPIOK_CLK_ENABLE();
 8000fd0:	4b27      	ldr	r3, [pc, #156]	; (8001070 <HAL_SPI_MspInit+0x10c>)
 8000fd2:	f8d3 30e0 	ldr.w	r3, [r3, #224]	; 0xe0
 8000fd6:	4a26      	ldr	r2, [pc, #152]	; (8001070 <HAL_SPI_MspInit+0x10c>)
 8000fd8:	f443 6380 	orr.w	r3, r3, #1024	; 0x400
 8000fdc:	f8c2 30e0 	str.w	r3, [r2, #224]	; 0xe0
 8000fe0:	4b23      	ldr	r3, [pc, #140]	; (8001070 <HAL_SPI_MspInit+0x10c>)
 8000fe2:	f8d3 30e0 	ldr.w	r3, [r3, #224]	; 0xe0
 8000fe6:	f403 6380 	and.w	r3, r3, #1024	; 0x400
 8000fea:	60fb      	str	r3, [r7, #12]
 8000fec:	68fb      	ldr	r3, [r7, #12]
    __HAL_RCC_GPIOJ_CLK_ENABLE();
 8000fee:	4b20      	ldr	r3, [pc, #128]	; (8001070 <HAL_SPI_MspInit+0x10c>)
 8000ff0:	f8d3 30e0 	ldr.w	r3, [r3, #224]	; 0xe0
 8000ff4:	4a1e      	ldr	r2, [pc, #120]	; (8001070 <HAL_SPI_MspInit+0x10c>)
 8000ff6:	f443 7300 	orr.w	r3, r3, #512	; 0x200
 8000ffa:	f8c2 30e0 	str.w	r3, [r2, #224]	; 0xe0
 8000ffe:	4b1c      	ldr	r3, [pc, #112]	; (8001070 <HAL_SPI_MspInit+0x10c>)
 8001000:	f8d3 30e0 	ldr.w	r3, [r3, #224]	; 0xe0
 8001004:	f403 7300 	and.w	r3, r3, #512	; 0x200
 8001008:	60bb      	str	r3, [r7, #8]
 800100a:	68bb      	ldr	r3, [r7, #8]
    PK0     ------> SPI5_SCK
    PK1     ------> SPI5_NSS
    PJ11     ------> SPI5_MISO
    PJ10     ------> SPI5_MOSI
    */
    GPIO_InitStruct.Pin = GPIO_PIN_0|GPIO_PIN_1;
 800100c:	2303      	movs	r3, #3
 800100e:	f8c7 30d4 	str.w	r3, [r7, #212]	; 0xd4
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8001012:	2302      	movs	r3, #2
 8001014:	f8c7 30d8 	str.w	r3, [r7, #216]	; 0xd8
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 8001018:	2300      	movs	r3, #0
 800101a:	f8c7 30dc 	str.w	r3, [r7, #220]	; 0xdc
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
 800101e:	2300      	movs	r3, #0
 8001020:	f8c7 30e0 	str.w	r3, [r7, #224]	; 0xe0
    GPIO_InitStruct.Alternate = GPIO_AF5_SPI5;
 8001024:	2305      	movs	r3, #5
 8001026:	f8c7 30e4 	str.w	r3, [r7, #228]	; 0xe4
    HAL_GPIO_Init(GPIOK, &GPIO_InitStruct);
 800102a:	f107 03d4 	add.w	r3, r7, #212	; 0xd4
 800102e:	4619      	mov	r1, r3
 8001030:	4810      	ldr	r0, [pc, #64]	; (8001074 <HAL_SPI_MspInit+0x110>)
 8001032:	f000 fcf5 	bl	8001a20 <HAL_GPIO_Init>

    GPIO_InitStruct.Pin = GPIO_PIN_11|GPIO_PIN_10;
 8001036:	f44f 6340 	mov.w	r3, #3072	; 0xc00
 800103a:	f8c7 30d4 	str.w	r3, [r7, #212]	; 0xd4
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 800103e:	2302      	movs	r3, #2
 8001040:	f8c7 30d8 	str.w	r3, [r7, #216]	; 0xd8
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 8001044:	2300      	movs	r3, #0
 8001046:	f8c7 30dc 	str.w	r3, [r7, #220]	; 0xdc
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
 800104a:	2300      	movs	r3, #0
 800104c:	f8c7 30e0 	str.w	r3, [r7, #224]	; 0xe0
    GPIO_InitStruct.Alternate = GPIO_AF5_SPI5;
 8001050:	2305      	movs	r3, #5
 8001052:	f8c7 30e4 	str.w	r3, [r7, #228]	; 0xe4
    HAL_GPIO_Init(GPIOJ, &GPIO_InitStruct);
 8001056:	f107 03d4 	add.w	r3, r7, #212	; 0xd4
 800105a:	4619      	mov	r1, r3
 800105c:	4806      	ldr	r0, [pc, #24]	; (8001078 <HAL_SPI_MspInit+0x114>)
 800105e:	f000 fcdf 	bl	8001a20 <HAL_GPIO_Init>

  /* USER CODE BEGIN SPI5_MspInit 1 */

  /* USER CODE END SPI5_MspInit 1 */
  }
}
 8001062:	bf00      	nop
 8001064:	37e8      	adds	r7, #232	; 0xe8
 8001066:	46bd      	mov	sp, r7
 8001068:	bd80      	pop	{r7, pc}
 800106a:	bf00      	nop
 800106c:	40015000 	.word	0x40015000
 8001070:	58024400 	.word	0x58024400
 8001074:	58022800 	.word	0x58022800
 8001078:	58022400 	.word	0x58022400

0800107c <HAL_MspInit>:
/* USER CODE END 0 */
/**
  * Initializes the Global MSP.
  */
void HAL_MspInit(void)
{
 800107c:	b480      	push	{r7}
 800107e:	b083      	sub	sp, #12
 8001080:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN MspInit 0 */

  /* USER CODE END MspInit 0 */

  __HAL_RCC_SYSCFG_CLK_ENABLE();
 8001082:	4b0a      	ldr	r3, [pc, #40]	; (80010ac <HAL_MspInit+0x30>)
 8001084:	f8d3 30f4 	ldr.w	r3, [r3, #244]	; 0xf4
 8001088:	4a08      	ldr	r2, [pc, #32]	; (80010ac <HAL_MspInit+0x30>)
 800108a:	f043 0302 	orr.w	r3, r3, #2
 800108e:	f8c2 30f4 	str.w	r3, [r2, #244]	; 0xf4
 8001092:	4b06      	ldr	r3, [pc, #24]	; (80010ac <HAL_MspInit+0x30>)
 8001094:	f8d3 30f4 	ldr.w	r3, [r3, #244]	; 0xf4
 8001098:	f003 0302 	and.w	r3, r3, #2
 800109c:	607b      	str	r3, [r7, #4]
 800109e:	687b      	ldr	r3, [r7, #4]
  /* System interrupt init*/

  /* USER CODE BEGIN MspInit 1 */

  /* USER CODE END MspInit 1 */
}
 80010a0:	bf00      	nop
 80010a2:	370c      	adds	r7, #12
 80010a4:	46bd      	mov	sp, r7
 80010a6:	f85d 7b04 	ldr.w	r7, [sp], #4
 80010aa:	4770      	bx	lr
 80010ac:	58024400 	.word	0x58024400

080010b0 <HAL_InitTick>:
  *         reset by HAL_Init() or at any time when clock is configured, by HAL_RCC_ClockConfig().
  * @param  TickPriority: Tick interrupt priority.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_InitTick(uint32_t TickPriority)
{
 80010b0:	b580      	push	{r7, lr}
 80010b2:	b08e      	sub	sp, #56	; 0x38
 80010b4:	af00      	add	r7, sp, #0
 80010b6:	6078      	str	r0, [r7, #4]
  uint32_t              uwTimclock;

  uint32_t              uwPrescalerValue;
  uint32_t              pFLatency;
/*Configure the TIM1 IRQ priority */
  if (TickPriority < (1UL << __NVIC_PRIO_BITS))
 80010b8:	687b      	ldr	r3, [r7, #4]
 80010ba:	2b0f      	cmp	r3, #15
 80010bc:	d844      	bhi.n	8001148 <HAL_InitTick+0x98>
  {
  HAL_NVIC_SetPriority(TIM1_UP_IRQn, TickPriority ,0U);
 80010be:	2200      	movs	r2, #0
 80010c0:	6879      	ldr	r1, [r7, #4]
 80010c2:	2019      	movs	r0, #25
 80010c4:	f000 fc08 	bl	80018d8 <HAL_NVIC_SetPriority>

  /* Enable the TIM1 global Interrupt */
  HAL_NVIC_EnableIRQ(TIM1_UP_IRQn);
 80010c8:	2019      	movs	r0, #25
 80010ca:	f000 fc1f 	bl	800190c <HAL_NVIC_EnableIRQ>
    uwTickPrio = TickPriority;
 80010ce:	4a24      	ldr	r2, [pc, #144]	; (8001160 <HAL_InitTick+0xb0>)
 80010d0:	687b      	ldr	r3, [r7, #4]
 80010d2:	6013      	str	r3, [r2, #0]
  {
    return HAL_ERROR;
  }

  /* Enable TIM1 clock */
  __HAL_RCC_TIM1_CLK_ENABLE();
 80010d4:	4b23      	ldr	r3, [pc, #140]	; (8001164 <HAL_InitTick+0xb4>)
 80010d6:	f8d3 30f0 	ldr.w	r3, [r3, #240]	; 0xf0
 80010da:	4a22      	ldr	r2, [pc, #136]	; (8001164 <HAL_InitTick+0xb4>)
 80010dc:	f043 0301 	orr.w	r3, r3, #1
 80010e0:	f8c2 30f0 	str.w	r3, [r2, #240]	; 0xf0
 80010e4:	4b1f      	ldr	r3, [pc, #124]	; (8001164 <HAL_InitTick+0xb4>)
 80010e6:	f8d3 30f0 	ldr.w	r3, [r3, #240]	; 0xf0
 80010ea:	f003 0301 	and.w	r3, r3, #1
 80010ee:	60bb      	str	r3, [r7, #8]
 80010f0:	68bb      	ldr	r3, [r7, #8]

  /* Get clock configuration */
  HAL_RCC_GetClockConfig(&clkconfig, &pFLatency);
 80010f2:	f107 020c 	add.w	r2, r7, #12
 80010f6:	f107 0310 	add.w	r3, r7, #16
 80010fa:	4611      	mov	r1, r2
 80010fc:	4618      	mov	r0, r3
 80010fe:	f001 fecd 	bl	8002e9c <HAL_RCC_GetClockConfig>

  /* Compute TIM1 clock */

  uwTimclock = 2*HAL_RCC_GetPCLK2Freq();
 8001102:	f001 feb5 	bl	8002e70 <HAL_RCC_GetPCLK2Freq>
 8001106:	4603      	mov	r3, r0
 8001108:	005b      	lsls	r3, r3, #1
 800110a:	637b      	str	r3, [r7, #52]	; 0x34

  /* Compute the prescaler value to have TIM1 counter clock equal to 1MHz */
  uwPrescalerValue = (uint32_t) ((uwTimclock / 1000000U) - 1U);
 800110c:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800110e:	4a16      	ldr	r2, [pc, #88]	; (8001168 <HAL_InitTick+0xb8>)
 8001110:	fba2 2303 	umull	r2, r3, r2, r3
 8001114:	0c9b      	lsrs	r3, r3, #18
 8001116:	3b01      	subs	r3, #1
 8001118:	633b      	str	r3, [r7, #48]	; 0x30

  /* Initialize TIM1 */
  htim1.Instance = TIM1;
 800111a:	4b14      	ldr	r3, [pc, #80]	; (800116c <HAL_InitTick+0xbc>)
 800111c:	4a14      	ldr	r2, [pc, #80]	; (8001170 <HAL_InitTick+0xc0>)
 800111e:	601a      	str	r2, [r3, #0]
  + Period = [(TIM1CLK/1000) - 1]. to have a (1/1000) s time base.
  + Prescaler = (uwTimclock/1000000 - 1) to have a 1MHz counter clock.
  + ClockDivision = 0
  + Counter direction = Up
  */
  htim1.Init.Period = (1000000U / 1000U) - 1U;
 8001120:	4b12      	ldr	r3, [pc, #72]	; (800116c <HAL_InitTick+0xbc>)
 8001122:	f240 32e7 	movw	r2, #999	; 0x3e7
 8001126:	60da      	str	r2, [r3, #12]
  htim1.Init.Prescaler = uwPrescalerValue;
 8001128:	4a10      	ldr	r2, [pc, #64]	; (800116c <HAL_InitTick+0xbc>)
 800112a:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800112c:	6053      	str	r3, [r2, #4]
  htim1.Init.ClockDivision = 0;
 800112e:	4b0f      	ldr	r3, [pc, #60]	; (800116c <HAL_InitTick+0xbc>)
 8001130:	2200      	movs	r2, #0
 8001132:	611a      	str	r2, [r3, #16]
  htim1.Init.CounterMode = TIM_COUNTERMODE_UP;
 8001134:	4b0d      	ldr	r3, [pc, #52]	; (800116c <HAL_InitTick+0xbc>)
 8001136:	2200      	movs	r2, #0
 8001138:	609a      	str	r2, [r3, #8]

  if(HAL_TIM_Base_Init(&htim1) == HAL_OK)
 800113a:	480c      	ldr	r0, [pc, #48]	; (800116c <HAL_InitTick+0xbc>)
 800113c:	f003 ff5b 	bl	8004ff6 <HAL_TIM_Base_Init>
 8001140:	4603      	mov	r3, r0
 8001142:	2b00      	cmp	r3, #0
 8001144:	d107      	bne.n	8001156 <HAL_InitTick+0xa6>
 8001146:	e001      	b.n	800114c <HAL_InitTick+0x9c>
    return HAL_ERROR;
 8001148:	2301      	movs	r3, #1
 800114a:	e005      	b.n	8001158 <HAL_InitTick+0xa8>
  {
    /* Start the TIM time Base generation in interrupt mode */
    return HAL_TIM_Base_Start_IT(&htim1);
 800114c:	4807      	ldr	r0, [pc, #28]	; (800116c <HAL_InitTick+0xbc>)
 800114e:	f003 ffb3 	bl	80050b8 <HAL_TIM_Base_Start_IT>
 8001152:	4603      	mov	r3, r0
 8001154:	e000      	b.n	8001158 <HAL_InitTick+0xa8>
  }

  /* Return function status */
  return HAL_ERROR;
 8001156:	2301      	movs	r3, #1
}
 8001158:	4618      	mov	r0, r3
 800115a:	3738      	adds	r7, #56	; 0x38
 800115c:	46bd      	mov	sp, r7
 800115e:	bd80      	pop	{r7, pc}
 8001160:	24000008 	.word	0x24000008
 8001164:	58024400 	.word	0x58024400
 8001168:	431bde83 	.word	0x431bde83
 800116c:	24000a14 	.word	0x24000a14
 8001170:	40010000 	.word	0x40010000

08001174 <NMI_Handler>:
/******************************************************************************/
/**
  * @brief This function handles Non maskable interrupt.
  */
void NMI_Handler(void)
{
 8001174:	b480      	push	{r7}
 8001176:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN NonMaskableInt_IRQn 0 */

  /* USER CODE END NonMaskableInt_IRQn 0 */
  /* USER CODE BEGIN NonMaskableInt_IRQn 1 */
  while (1)
 8001178:	e7fe      	b.n	8001178 <NMI_Handler+0x4>

0800117a <HardFault_Handler>:

/**
  * @brief This function handles Hard fault interrupt.
  */
void HardFault_Handler(void)
{
 800117a:	b480      	push	{r7}
 800117c:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN HardFault_IRQn 0 */

  /* USER CODE END HardFault_IRQn 0 */
  while (1)
 800117e:	e7fe      	b.n	800117e <HardFault_Handler+0x4>

08001180 <MemManage_Handler>:

/**
  * @brief This function handles Memory management fault.
  */
void MemManage_Handler(void)
{
 8001180:	b480      	push	{r7}
 8001182:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN MemoryManagement_IRQn 0 */

  /* USER CODE END MemoryManagement_IRQn 0 */
  while (1)
 8001184:	e7fe      	b.n	8001184 <MemManage_Handler+0x4>

08001186 <BusFault_Handler>:

/**
  * @brief This function handles Pre-fetch fault, memory access fault.
  */
void BusFault_Handler(void)
{
 8001186:	b480      	push	{r7}
 8001188:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN BusFault_IRQn 0 */

  /* USER CODE END BusFault_IRQn 0 */
  while (1)
 800118a:	e7fe      	b.n	800118a <BusFault_Handler+0x4>

0800118c <UsageFault_Handler>:

/**
  * @brief This function handles Undefined instruction or illegal state.
  */
void UsageFault_Handler(void)
{
 800118c:	b480      	push	{r7}
 800118e:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN UsageFault_IRQn 0 */

  /* USER CODE END UsageFault_IRQn 0 */
  while (1)
 8001190:	e7fe      	b.n	8001190 <UsageFault_Handler+0x4>

08001192 <DebugMon_Handler>:

/**
  * @brief This function handles Debug monitor.
  */
void DebugMon_Handler(void)
{
 8001192:	b480      	push	{r7}
 8001194:	af00      	add	r7, sp, #0

  /* USER CODE END DebugMonitor_IRQn 0 */
  /* USER CODE BEGIN DebugMonitor_IRQn 1 */

  /* USER CODE END DebugMonitor_IRQn 1 */
}
 8001196:	bf00      	nop
 8001198:	46bd      	mov	sp, r7
 800119a:	f85d 7b04 	ldr.w	r7, [sp], #4
 800119e:	4770      	bx	lr

080011a0 <TIM1_UP_IRQHandler>:

/**
  * @brief This function handles TIM1 update interrupt.
  */
void TIM1_UP_IRQHandler(void)
{
 80011a0:	b580      	push	{r7, lr}
 80011a2:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN TIM1_UP_IRQn 0 */

  /* USER CODE END TIM1_UP_IRQn 0 */
  HAL_TIM_IRQHandler(&htim1);
 80011a4:	4802      	ldr	r0, [pc, #8]	; (80011b0 <TIM1_UP_IRQHandler+0x10>)
 80011a6:	f003 ffff 	bl	80051a8 <HAL_TIM_IRQHandler>
  /* USER CODE BEGIN TIM1_UP_IRQn 1 */

  /* USER CODE END TIM1_UP_IRQn 1 */
}
 80011aa:	bf00      	nop
 80011ac:	bd80      	pop	{r7, pc}
 80011ae:	bf00      	nop
 80011b0:	24000a14 	.word	0x24000a14

080011b4 <EXTI15_10_IRQHandler>:

/**
  * @brief This function handles EXTI line[15:10] interrupts.
  */
void EXTI15_10_IRQHandler(void)
{
 80011b4:	b580      	push	{r7, lr}
 80011b6:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN EXTI15_10_IRQn 0 */

  /* USER CODE END EXTI15_10_IRQn 0 */
  HAL_GPIO_EXTI_IRQHandler(GPIO_HANDSHAKE_Pin);
 80011b8:	f44f 5000 	mov.w	r0, #8192	; 0x2000
 80011bc:	f000 fe11 	bl	8001de2 <HAL_GPIO_EXTI_IRQHandler>
  HAL_GPIO_EXTI_IRQHandler(GPIO_DATA_READY_Pin);
 80011c0:	f44f 4080 	mov.w	r0, #16384	; 0x4000
 80011c4:	f000 fe0d 	bl	8001de2 <HAL_GPIO_EXTI_IRQHandler>
  /* USER CODE BEGIN EXTI15_10_IRQn 1 */

  /* USER CODE END EXTI15_10_IRQn 1 */
}
 80011c8:	bf00      	nop
 80011ca:	bd80      	pop	{r7, pc}

080011cc <_getpid>:
void initialise_monitor_handles()
{
}

int _getpid(void)
{
 80011cc:	b480      	push	{r7}
 80011ce:	af00      	add	r7, sp, #0
	return 1;
 80011d0:	2301      	movs	r3, #1
}
 80011d2:	4618      	mov	r0, r3
 80011d4:	46bd      	mov	sp, r7
 80011d6:	f85d 7b04 	ldr.w	r7, [sp], #4
 80011da:	4770      	bx	lr

080011dc <_kill>:

int _kill(int pid, int sig)
{
 80011dc:	b580      	push	{r7, lr}
 80011de:	b082      	sub	sp, #8
 80011e0:	af00      	add	r7, sp, #0
 80011e2:	6078      	str	r0, [r7, #4]
 80011e4:	6039      	str	r1, [r7, #0]
	errno = EINVAL;
 80011e6:	f01e fad5 	bl	801f794 <__errno>
 80011ea:	4603      	mov	r3, r0
 80011ec:	2216      	movs	r2, #22
 80011ee:	601a      	str	r2, [r3, #0]
	return -1;
 80011f0:	f04f 33ff 	mov.w	r3, #4294967295
}
 80011f4:	4618      	mov	r0, r3
 80011f6:	3708      	adds	r7, #8
 80011f8:	46bd      	mov	sp, r7
 80011fa:	bd80      	pop	{r7, pc}

080011fc <_exit>:

void _exit (int status)
{
 80011fc:	b580      	push	{r7, lr}
 80011fe:	b082      	sub	sp, #8
 8001200:	af00      	add	r7, sp, #0
 8001202:	6078      	str	r0, [r7, #4]
	_kill(status, -1);
 8001204:	f04f 31ff 	mov.w	r1, #4294967295
 8001208:	6878      	ldr	r0, [r7, #4]
 800120a:	f7ff ffe7 	bl	80011dc <_kill>
	while (1) {}		/* Make sure we hang here */
 800120e:	e7fe      	b.n	800120e <_exit+0x12>

08001210 <_read>:
}

__attribute__((weak)) int _read(int file, char *ptr, int len)
{
 8001210:	b580      	push	{r7, lr}
 8001212:	b086      	sub	sp, #24
 8001214:	af00      	add	r7, sp, #0
 8001216:	60f8      	str	r0, [r7, #12]
 8001218:	60b9      	str	r1, [r7, #8]
 800121a:	607a      	str	r2, [r7, #4]
	int DataIdx;

	for (DataIdx = 0; DataIdx < len; DataIdx++)
 800121c:	2300      	movs	r3, #0
 800121e:	617b      	str	r3, [r7, #20]
 8001220:	e00a      	b.n	8001238 <_read+0x28>
	{
		*ptr++ = __io_getchar();
 8001222:	f3af 8000 	nop.w
 8001226:	4601      	mov	r1, r0
 8001228:	68bb      	ldr	r3, [r7, #8]
 800122a:	1c5a      	adds	r2, r3, #1
 800122c:	60ba      	str	r2, [r7, #8]
 800122e:	b2ca      	uxtb	r2, r1
 8001230:	701a      	strb	r2, [r3, #0]
	for (DataIdx = 0; DataIdx < len; DataIdx++)
 8001232:	697b      	ldr	r3, [r7, #20]
 8001234:	3301      	adds	r3, #1
 8001236:	617b      	str	r3, [r7, #20]
 8001238:	697a      	ldr	r2, [r7, #20]
 800123a:	687b      	ldr	r3, [r7, #4]
 800123c:	429a      	cmp	r2, r3
 800123e:	dbf0      	blt.n	8001222 <_read+0x12>
	}

return len;
 8001240:	687b      	ldr	r3, [r7, #4]
}
 8001242:	4618      	mov	r0, r3
 8001244:	3718      	adds	r7, #24
 8001246:	46bd      	mov	sp, r7
 8001248:	bd80      	pop	{r7, pc}

0800124a <_write>:

__attribute__((weak)) int _write(int file, char *ptr, int len)
{
 800124a:	b580      	push	{r7, lr}
 800124c:	b086      	sub	sp, #24
 800124e:	af00      	add	r7, sp, #0
 8001250:	60f8      	str	r0, [r7, #12]
 8001252:	60b9      	str	r1, [r7, #8]
 8001254:	607a      	str	r2, [r7, #4]
	int DataIdx;

	for (DataIdx = 0; DataIdx < len; DataIdx++)
 8001256:	2300      	movs	r3, #0
 8001258:	617b      	str	r3, [r7, #20]
 800125a:	e009      	b.n	8001270 <_write+0x26>
	{
		__io_putchar(*ptr++);
 800125c:	68bb      	ldr	r3, [r7, #8]
 800125e:	1c5a      	adds	r2, r3, #1
 8001260:	60ba      	str	r2, [r7, #8]
 8001262:	781b      	ldrb	r3, [r3, #0]
 8001264:	4618      	mov	r0, r3
 8001266:	f01b f9e7 	bl	801c638 <__io_putchar>
	for (DataIdx = 0; DataIdx < len; DataIdx++)
 800126a:	697b      	ldr	r3, [r7, #20]
 800126c:	3301      	adds	r3, #1
 800126e:	617b      	str	r3, [r7, #20]
 8001270:	697a      	ldr	r2, [r7, #20]
 8001272:	687b      	ldr	r3, [r7, #4]
 8001274:	429a      	cmp	r2, r3
 8001276:	dbf1      	blt.n	800125c <_write+0x12>
	}
	return len;
 8001278:	687b      	ldr	r3, [r7, #4]
}
 800127a:	4618      	mov	r0, r3
 800127c:	3718      	adds	r7, #24
 800127e:	46bd      	mov	sp, r7
 8001280:	bd80      	pop	{r7, pc}

08001282 <_close>:

int _close(int file)
{
 8001282:	b480      	push	{r7}
 8001284:	b083      	sub	sp, #12
 8001286:	af00      	add	r7, sp, #0
 8001288:	6078      	str	r0, [r7, #4]
	return -1;
 800128a:	f04f 33ff 	mov.w	r3, #4294967295
}
 800128e:	4618      	mov	r0, r3
 8001290:	370c      	adds	r7, #12
 8001292:	46bd      	mov	sp, r7
 8001294:	f85d 7b04 	ldr.w	r7, [sp], #4
 8001298:	4770      	bx	lr

0800129a <_fstat>:


int _fstat(int file, struct stat *st)
{
 800129a:	b480      	push	{r7}
 800129c:	b083      	sub	sp, #12
 800129e:	af00      	add	r7, sp, #0
 80012a0:	6078      	str	r0, [r7, #4]
 80012a2:	6039      	str	r1, [r7, #0]
	st->st_mode = S_IFCHR;
 80012a4:	683b      	ldr	r3, [r7, #0]
 80012a6:	f44f 5200 	mov.w	r2, #8192	; 0x2000
 80012aa:	605a      	str	r2, [r3, #4]
	return 0;
 80012ac:	2300      	movs	r3, #0
}
 80012ae:	4618      	mov	r0, r3
 80012b0:	370c      	adds	r7, #12
 80012b2:	46bd      	mov	sp, r7
 80012b4:	f85d 7b04 	ldr.w	r7, [sp], #4
 80012b8:	4770      	bx	lr

080012ba <_isatty>:

int _isatty(int file)
{
 80012ba:	b480      	push	{r7}
 80012bc:	b083      	sub	sp, #12
 80012be:	af00      	add	r7, sp, #0
 80012c0:	6078      	str	r0, [r7, #4]
	return 1;
 80012c2:	2301      	movs	r3, #1
}
 80012c4:	4618      	mov	r0, r3
 80012c6:	370c      	adds	r7, #12
 80012c8:	46bd      	mov	sp, r7
 80012ca:	f85d 7b04 	ldr.w	r7, [sp], #4
 80012ce:	4770      	bx	lr

080012d0 <_lseek>:

int _lseek(int file, int ptr, int dir)
{
 80012d0:	b480      	push	{r7}
 80012d2:	b085      	sub	sp, #20
 80012d4:	af00      	add	r7, sp, #0
 80012d6:	60f8      	str	r0, [r7, #12]
 80012d8:	60b9      	str	r1, [r7, #8]
 80012da:	607a      	str	r2, [r7, #4]
	return 0;
 80012dc:	2300      	movs	r3, #0
}
 80012de:	4618      	mov	r0, r3
 80012e0:	3714      	adds	r7, #20
 80012e2:	46bd      	mov	sp, r7
 80012e4:	f85d 7b04 	ldr.w	r7, [sp], #4
 80012e8:	4770      	bx	lr
	...

080012ec <_sbrk>:
 *
 * @param incr Memory size
 * @return Pointer to allocated memory
 */
void *_sbrk(ptrdiff_t incr)
{
 80012ec:	b580      	push	{r7, lr}
 80012ee:	b086      	sub	sp, #24
 80012f0:	af00      	add	r7, sp, #0
 80012f2:	6078      	str	r0, [r7, #4]
  extern uint8_t _end; /* Symbol defined in the linker script */
  extern uint8_t _estack; /* Symbol defined in the linker script */
  extern uint32_t _Min_Stack_Size; /* Symbol defined in the linker script */
  const uint32_t stack_limit = (uint32_t)&_estack - (uint32_t)&_Min_Stack_Size;
 80012f4:	4a14      	ldr	r2, [pc, #80]	; (8001348 <_sbrk+0x5c>)
 80012f6:	4b15      	ldr	r3, [pc, #84]	; (800134c <_sbrk+0x60>)
 80012f8:	1ad3      	subs	r3, r2, r3
 80012fa:	617b      	str	r3, [r7, #20]
  const uint8_t *max_heap = (uint8_t *)stack_limit;
 80012fc:	697b      	ldr	r3, [r7, #20]
 80012fe:	613b      	str	r3, [r7, #16]
  uint8_t *prev_heap_end;

  /* Initialize heap end at first call */
  if (NULL == __sbrk_heap_end)
 8001300:	4b13      	ldr	r3, [pc, #76]	; (8001350 <_sbrk+0x64>)
 8001302:	681b      	ldr	r3, [r3, #0]
 8001304:	2b00      	cmp	r3, #0
 8001306:	d102      	bne.n	800130e <_sbrk+0x22>
  {
    __sbrk_heap_end = &_end;
 8001308:	4b11      	ldr	r3, [pc, #68]	; (8001350 <_sbrk+0x64>)
 800130a:	4a12      	ldr	r2, [pc, #72]	; (8001354 <_sbrk+0x68>)
 800130c:	601a      	str	r2, [r3, #0]
  }

  /* Protect heap from growing into the reserved MSP stack */
  if (__sbrk_heap_end + incr > max_heap)
 800130e:	4b10      	ldr	r3, [pc, #64]	; (8001350 <_sbrk+0x64>)
 8001310:	681a      	ldr	r2, [r3, #0]
 8001312:	687b      	ldr	r3, [r7, #4]
 8001314:	4413      	add	r3, r2
 8001316:	693a      	ldr	r2, [r7, #16]
 8001318:	429a      	cmp	r2, r3
 800131a:	d207      	bcs.n	800132c <_sbrk+0x40>
  {
    errno = ENOMEM;
 800131c:	f01e fa3a 	bl	801f794 <__errno>
 8001320:	4603      	mov	r3, r0
 8001322:	220c      	movs	r2, #12
 8001324:	601a      	str	r2, [r3, #0]
    return (void *)-1;
 8001326:	f04f 33ff 	mov.w	r3, #4294967295
 800132a:	e009      	b.n	8001340 <_sbrk+0x54>
  }

  prev_heap_end = __sbrk_heap_end;
 800132c:	4b08      	ldr	r3, [pc, #32]	; (8001350 <_sbrk+0x64>)
 800132e:	681b      	ldr	r3, [r3, #0]
 8001330:	60fb      	str	r3, [r7, #12]
  __sbrk_heap_end += incr;
 8001332:	4b07      	ldr	r3, [pc, #28]	; (8001350 <_sbrk+0x64>)
 8001334:	681a      	ldr	r2, [r3, #0]
 8001336:	687b      	ldr	r3, [r7, #4]
 8001338:	4413      	add	r3, r2
 800133a:	4a05      	ldr	r2, [pc, #20]	; (8001350 <_sbrk+0x64>)
 800133c:	6013      	str	r3, [r2, #0]

  return (void *)prev_heap_end;
 800133e:	68fb      	ldr	r3, [r7, #12]
}
 8001340:	4618      	mov	r0, r3
 8001342:	3718      	adds	r7, #24
 8001344:	46bd      	mov	sp, r7
 8001346:	bd80      	pop	{r7, pc}
 8001348:	24080000 	.word	0x24080000
 800134c:	00000400 	.word	0x00000400
 8001350:	24000a60 	.word	0x24000a60
 8001354:	2407f0c0 	.word	0x2407f0c0

08001358 <MX_USART1_UART_Init>:
UART_HandleTypeDef huart1;

/* USART1 init function */

void MX_USART1_UART_Init(void)
{
 8001358:	b580      	push	{r7, lr}
 800135a:	af00      	add	r7, sp, #0
  /* USER CODE END USART1_Init 0 */

  /* USER CODE BEGIN USART1_Init 1 */

  /* USER CODE END USART1_Init 1 */
  huart1.Instance = USART1;
 800135c:	4b22      	ldr	r3, [pc, #136]	; (80013e8 <MX_USART1_UART_Init+0x90>)
 800135e:	4a23      	ldr	r2, [pc, #140]	; (80013ec <MX_USART1_UART_Init+0x94>)
 8001360:	601a      	str	r2, [r3, #0]
  huart1.Init.BaudRate = 115200;
 8001362:	4b21      	ldr	r3, [pc, #132]	; (80013e8 <MX_USART1_UART_Init+0x90>)
 8001364:	f44f 32e1 	mov.w	r2, #115200	; 0x1c200
 8001368:	605a      	str	r2, [r3, #4]
  huart1.Init.WordLength = UART_WORDLENGTH_8B;
 800136a:	4b1f      	ldr	r3, [pc, #124]	; (80013e8 <MX_USART1_UART_Init+0x90>)
 800136c:	2200      	movs	r2, #0
 800136e:	609a      	str	r2, [r3, #8]
  huart1.Init.StopBits = UART_STOPBITS_1;
 8001370:	4b1d      	ldr	r3, [pc, #116]	; (80013e8 <MX_USART1_UART_Init+0x90>)
 8001372:	2200      	movs	r2, #0
 8001374:	60da      	str	r2, [r3, #12]
  huart1.Init.Parity = UART_PARITY_NONE;
 8001376:	4b1c      	ldr	r3, [pc, #112]	; (80013e8 <MX_USART1_UART_Init+0x90>)
 8001378:	2200      	movs	r2, #0
 800137a:	611a      	str	r2, [r3, #16]
  huart1.Init.Mode = UART_MODE_TX_RX;
 800137c:	4b1a      	ldr	r3, [pc, #104]	; (80013e8 <MX_USART1_UART_Init+0x90>)
 800137e:	220c      	movs	r2, #12
 8001380:	615a      	str	r2, [r3, #20]
  huart1.Init.HwFlowCtl = UART_HWCONTROL_NONE;
 8001382:	4b19      	ldr	r3, [pc, #100]	; (80013e8 <MX_USART1_UART_Init+0x90>)
 8001384:	2200      	movs	r2, #0
 8001386:	619a      	str	r2, [r3, #24]
  huart1.Init.OverSampling = UART_OVERSAMPLING_16;
 8001388:	4b17      	ldr	r3, [pc, #92]	; (80013e8 <MX_USART1_UART_Init+0x90>)
 800138a:	2200      	movs	r2, #0
 800138c:	61da      	str	r2, [r3, #28]
  huart1.Init.OneBitSampling = UART_ONE_BIT_SAMPLE_DISABLE;
 800138e:	4b16      	ldr	r3, [pc, #88]	; (80013e8 <MX_USART1_UART_Init+0x90>)
 8001390:	2200      	movs	r2, #0
 8001392:	621a      	str	r2, [r3, #32]
  huart1.Init.ClockPrescaler = UART_PRESCALER_DIV1;
 8001394:	4b14      	ldr	r3, [pc, #80]	; (80013e8 <MX_USART1_UART_Init+0x90>)
 8001396:	2200      	movs	r2, #0
 8001398:	625a      	str	r2, [r3, #36]	; 0x24
  huart1.AdvancedInit.AdvFeatureInit = UART_ADVFEATURE_NO_INIT;
 800139a:	4b13      	ldr	r3, [pc, #76]	; (80013e8 <MX_USART1_UART_Init+0x90>)
 800139c:	2200      	movs	r2, #0
 800139e:	629a      	str	r2, [r3, #40]	; 0x28
  if (HAL_UART_Init(&huart1) != HAL_OK)
 80013a0:	4811      	ldr	r0, [pc, #68]	; (80013e8 <MX_USART1_UART_Init+0x90>)
 80013a2:	f004 f901 	bl	80055a8 <HAL_UART_Init>
 80013a6:	4603      	mov	r3, r0
 80013a8:	2b00      	cmp	r3, #0
 80013aa:	d001      	beq.n	80013b0 <MX_USART1_UART_Init+0x58>
  {
    Error_Handler();
 80013ac:	f7ff fd7e 	bl	8000eac <Error_Handler>
  }
  if (HAL_UARTEx_SetTxFifoThreshold(&huart1, UART_TXFIFO_THRESHOLD_1_8) != HAL_OK)
 80013b0:	2100      	movs	r1, #0
 80013b2:	480d      	ldr	r0, [pc, #52]	; (80013e8 <MX_USART1_UART_Init+0x90>)
 80013b4:	f005 f934 	bl	8006620 <HAL_UARTEx_SetTxFifoThreshold>
 80013b8:	4603      	mov	r3, r0
 80013ba:	2b00      	cmp	r3, #0
 80013bc:	d001      	beq.n	80013c2 <MX_USART1_UART_Init+0x6a>
  {
    Error_Handler();
 80013be:	f7ff fd75 	bl	8000eac <Error_Handler>
  }
  if (HAL_UARTEx_SetRxFifoThreshold(&huart1, UART_RXFIFO_THRESHOLD_1_8) != HAL_OK)
 80013c2:	2100      	movs	r1, #0
 80013c4:	4808      	ldr	r0, [pc, #32]	; (80013e8 <MX_USART1_UART_Init+0x90>)
 80013c6:	f005 f969 	bl	800669c <HAL_UARTEx_SetRxFifoThreshold>
 80013ca:	4603      	mov	r3, r0
 80013cc:	2b00      	cmp	r3, #0
 80013ce:	d001      	beq.n	80013d4 <MX_USART1_UART_Init+0x7c>
  {
    Error_Handler();
 80013d0:	f7ff fd6c 	bl	8000eac <Error_Handler>
  }
  if (HAL_UARTEx_DisableFifoMode(&huart1) != HAL_OK)
 80013d4:	4804      	ldr	r0, [pc, #16]	; (80013e8 <MX_USART1_UART_Init+0x90>)
 80013d6:	f005 f8ea 	bl	80065ae <HAL_UARTEx_DisableFifoMode>
 80013da:	4603      	mov	r3, r0
 80013dc:	2b00      	cmp	r3, #0
 80013de:	d001      	beq.n	80013e4 <MX_USART1_UART_Init+0x8c>
  {
    Error_Handler();
 80013e0:	f7ff fd64 	bl	8000eac <Error_Handler>
  }
  /* USER CODE BEGIN USART1_Init 2 */

  /* USER CODE END USART1_Init 2 */

}
 80013e4:	bf00      	nop
 80013e6:	bd80      	pop	{r7, pc}
 80013e8:	24000a64 	.word	0x24000a64
 80013ec:	40011000 	.word	0x40011000

080013f0 <HAL_UART_MspInit>:

void HAL_UART_MspInit(UART_HandleTypeDef* uartHandle)
{
 80013f0:	b580      	push	{r7, lr}
 80013f2:	b0ba      	sub	sp, #232	; 0xe8
 80013f4:	af00      	add	r7, sp, #0
 80013f6:	6078      	str	r0, [r7, #4]

  GPIO_InitTypeDef GPIO_InitStruct = {0};
 80013f8:	f107 03d4 	add.w	r3, r7, #212	; 0xd4
 80013fc:	2200      	movs	r2, #0
 80013fe:	601a      	str	r2, [r3, #0]
 8001400:	605a      	str	r2, [r3, #4]
 8001402:	609a      	str	r2, [r3, #8]
 8001404:	60da      	str	r2, [r3, #12]
 8001406:	611a      	str	r2, [r3, #16]
  RCC_PeriphCLKInitTypeDef PeriphClkInitStruct = {0};
 8001408:	f107 0314 	add.w	r3, r7, #20
 800140c:	22c0      	movs	r2, #192	; 0xc0
 800140e:	2100      	movs	r1, #0
 8001410:	4618      	mov	r0, r3
 8001412:	f01e fa33 	bl	801f87c <memset>
  if(uartHandle->Instance==USART1)
 8001416:	687b      	ldr	r3, [r7, #4]
 8001418:	681b      	ldr	r3, [r3, #0]
 800141a:	4a25      	ldr	r2, [pc, #148]	; (80014b0 <HAL_UART_MspInit+0xc0>)
 800141c:	4293      	cmp	r3, r2
 800141e:	d142      	bne.n	80014a6 <HAL_UART_MspInit+0xb6>

  /* USER CODE END USART1_MspInit 0 */

  /** Initializes the peripherals clock
  */
    PeriphClkInitStruct.PeriphClockSelection = RCC_PERIPHCLK_USART1;
 8001420:	2301      	movs	r3, #1
 8001422:	617b      	str	r3, [r7, #20]
    PeriphClkInitStruct.Usart16ClockSelection = RCC_USART16CLKSOURCE_D2PCLK2;
 8001424:	2300      	movs	r3, #0
 8001426:	f8c7 3090 	str.w	r3, [r7, #144]	; 0x90
    if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInitStruct) != HAL_OK)
 800142a:	f107 0314 	add.w	r3, r7, #20
 800142e:	4618      	mov	r0, r3
 8001430:	f001 fd76 	bl	8002f20 <HAL_RCCEx_PeriphCLKConfig>
 8001434:	4603      	mov	r3, r0
 8001436:	2b00      	cmp	r3, #0
 8001438:	d001      	beq.n	800143e <HAL_UART_MspInit+0x4e>
    {
      Error_Handler();
 800143a:	f7ff fd37 	bl	8000eac <Error_Handler>
    }

    /* USART1 clock enable */
    __HAL_RCC_USART1_CLK_ENABLE();
 800143e:	4b1d      	ldr	r3, [pc, #116]	; (80014b4 <HAL_UART_MspInit+0xc4>)
 8001440:	f8d3 30f0 	ldr.w	r3, [r3, #240]	; 0xf0
 8001444:	4a1b      	ldr	r2, [pc, #108]	; (80014b4 <HAL_UART_MspInit+0xc4>)
 8001446:	f043 0310 	orr.w	r3, r3, #16
 800144a:	f8c2 30f0 	str.w	r3, [r2, #240]	; 0xf0
 800144e:	4b19      	ldr	r3, [pc, #100]	; (80014b4 <HAL_UART_MspInit+0xc4>)
 8001450:	f8d3 30f0 	ldr.w	r3, [r3, #240]	; 0xf0
 8001454:	f003 0310 	and.w	r3, r3, #16
 8001458:	613b      	str	r3, [r7, #16]
 800145a:	693b      	ldr	r3, [r7, #16]

    __HAL_RCC_GPIOB_CLK_ENABLE();
 800145c:	4b15      	ldr	r3, [pc, #84]	; (80014b4 <HAL_UART_MspInit+0xc4>)
 800145e:	f8d3 30e0 	ldr.w	r3, [r3, #224]	; 0xe0
 8001462:	4a14      	ldr	r2, [pc, #80]	; (80014b4 <HAL_UART_MspInit+0xc4>)
 8001464:	f043 0302 	orr.w	r3, r3, #2
 8001468:	f8c2 30e0 	str.w	r3, [r2, #224]	; 0xe0
 800146c:	4b11      	ldr	r3, [pc, #68]	; (80014b4 <HAL_UART_MspInit+0xc4>)
 800146e:	f8d3 30e0 	ldr.w	r3, [r3, #224]	; 0xe0
 8001472:	f003 0302 	and.w	r3, r3, #2
 8001476:	60fb      	str	r3, [r7, #12]
 8001478:	68fb      	ldr	r3, [r7, #12]
    /**USART1 GPIO Configuration
    PB15     ------> USART1_RX
    PB14     ------> USART1_TX
    */
    GPIO_InitStruct.Pin = GPIO_PIN_15|GPIO_PIN_14;
 800147a:	f44f 4340 	mov.w	r3, #49152	; 0xc000
 800147e:	f8c7 30d4 	str.w	r3, [r7, #212]	; 0xd4
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8001482:	2302      	movs	r3, #2
 8001484:	f8c7 30d8 	str.w	r3, [r7, #216]	; 0xd8
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 8001488:	2300      	movs	r3, #0
 800148a:	f8c7 30dc 	str.w	r3, [r7, #220]	; 0xdc
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
 800148e:	2300      	movs	r3, #0
 8001490:	f8c7 30e0 	str.w	r3, [r7, #224]	; 0xe0
    GPIO_InitStruct.Alternate = GPIO_AF4_USART1;
 8001494:	2304      	movs	r3, #4
 8001496:	f8c7 30e4 	str.w	r3, [r7, #228]	; 0xe4
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 800149a:	f107 03d4 	add.w	r3, r7, #212	; 0xd4
 800149e:	4619      	mov	r1, r3
 80014a0:	4805      	ldr	r0, [pc, #20]	; (80014b8 <HAL_UART_MspInit+0xc8>)
 80014a2:	f000 fabd 	bl	8001a20 <HAL_GPIO_Init>

  /* USER CODE BEGIN USART1_MspInit 1 */

  /* USER CODE END USART1_MspInit 1 */
  }
}
 80014a6:	bf00      	nop
 80014a8:	37e8      	adds	r7, #232	; 0xe8
 80014aa:	46bd      	mov	sp, r7
 80014ac:	bd80      	pop	{r7, pc}
 80014ae:	bf00      	nop
 80014b0:	40011000 	.word	0x40011000
 80014b4:	58024400 	.word	0x58024400
 80014b8:	58020400 	.word	0x58020400

080014bc <Reset_Handler>:

    .section  .text.Reset_Handler
  .weak  Reset_Handler
  .type  Reset_Handler, %function
Reset_Handler:
  ldr   sp, =_estack      /* set stack pointer */
 80014bc:	f8df d034 	ldr.w	sp, [pc, #52]	; 80014f4 <LoopFillZerobss+0xe>

/* Call the clock system initialization function.*/
  bl  SystemInit
 80014c0:	f7ff fa52 	bl	8000968 <SystemInit>

/* Copy the data segment initializers from flash to SRAM */
  ldr r0, =_sdata
 80014c4:	480c      	ldr	r0, [pc, #48]	; (80014f8 <LoopFillZerobss+0x12>)
  ldr r1, =_edata
 80014c6:	490d      	ldr	r1, [pc, #52]	; (80014fc <LoopFillZerobss+0x16>)
  ldr r2, =_sidata
 80014c8:	4a0d      	ldr	r2, [pc, #52]	; (8001500 <LoopFillZerobss+0x1a>)
  movs r3, #0
 80014ca:	2300      	movs	r3, #0
  b LoopCopyDataInit
 80014cc:	e002      	b.n	80014d4 <LoopCopyDataInit>

080014ce <CopyDataInit>:

CopyDataInit:
  ldr r4, [r2, r3]
 80014ce:	58d4      	ldr	r4, [r2, r3]
  str r4, [r0, r3]
 80014d0:	50c4      	str	r4, [r0, r3]
  adds r3, r3, #4
 80014d2:	3304      	adds	r3, #4

080014d4 <LoopCopyDataInit>:

LoopCopyDataInit:
  adds r4, r0, r3
 80014d4:	18c4      	adds	r4, r0, r3
  cmp r4, r1
 80014d6:	428c      	cmp	r4, r1
  bcc CopyDataInit
 80014d8:	d3f9      	bcc.n	80014ce <CopyDataInit>
/* Zero fill the bss segment. */
  ldr r2, =_sbss
 80014da:	4a0a      	ldr	r2, [pc, #40]	; (8001504 <LoopFillZerobss+0x1e>)
  ldr r4, =_ebss
 80014dc:	4c0a      	ldr	r4, [pc, #40]	; (8001508 <LoopFillZerobss+0x22>)
  movs r3, #0
 80014de:	2300      	movs	r3, #0
  b LoopFillZerobss
 80014e0:	e001      	b.n	80014e6 <LoopFillZerobss>

080014e2 <FillZerobss>:

FillZerobss:
  str  r3, [r2]
 80014e2:	6013      	str	r3, [r2, #0]
  adds r2, r2, #4
 80014e4:	3204      	adds	r2, #4

080014e6 <LoopFillZerobss>:

LoopFillZerobss:
  cmp r2, r4
 80014e6:	42a2      	cmp	r2, r4
  bcc FillZerobss
 80014e8:	d3fb      	bcc.n	80014e2 <FillZerobss>

/* Call static constructors */
    bl __libc_init_array
 80014ea:	f01e f96b 	bl	801f7c4 <__libc_init_array>
/* Call the application's entry point.*/
  bl  main
 80014ee:	f7ff fb6b 	bl	8000bc8 <main>
  bx  lr
 80014f2:	4770      	bx	lr
  ldr   sp, =_estack      /* set stack pointer */
 80014f4:	24080000 	.word	0x24080000
  ldr r0, =_sdata
 80014f8:	24000000 	.word	0x24000000
  ldr r1, =_edata
 80014fc:	24000508 	.word	0x24000508
  ldr r2, =_sidata
 8001500:	080290d8 	.word	0x080290d8
  ldr r2, =_sbss
 8001504:	24000508 	.word	0x24000508
  ldr r4, =_ebss
 8001508:	2404d0c0 	.word	0x2404d0c0

0800150c <ADC3_IRQHandler>:
 * @retval None
*/
    .section  .text.Default_Handler,"ax",%progbits
Default_Handler:
Infinite_Loop:
  b  Infinite_Loop
 800150c:	e7fe      	b.n	800150c <ADC3_IRQHandler>

0800150e <stm32_lock_init>:
/**
  * @brief Initialize STM32 lock
  * @param lock The lock to init
  */
static inline void stm32_lock_init(LockingData_t *lock)
{
 800150e:	b580      	push	{r7, lr}
 8001510:	b082      	sub	sp, #8
 8001512:	af00      	add	r7, sp, #0
 8001514:	6078      	str	r0, [r7, #4]
  STM32_LOCK_BLOCK_IF_NULL_ARGUMENT(lock);
 8001516:	687b      	ldr	r3, [r7, #4]
 8001518:	2b00      	cmp	r3, #0
 800151a:	d104      	bne.n	8001526 <stm32_lock_init+0x18>
  __ASM volatile ("cpsid i" : : : "memory");
 800151c:	b672      	cpsid	i
}
 800151e:	bf00      	nop
 8001520:	f7ff fcc4 	bl	8000eac <Error_Handler>
 8001524:	e7fe      	b.n	8001524 <stm32_lock_init+0x16>
  lock->flag = 0;
 8001526:	687b      	ldr	r3, [r7, #4]
 8001528:	2200      	movs	r2, #0
 800152a:	701a      	strb	r2, [r3, #0]
  lock->counter = 0;
 800152c:	687b      	ldr	r3, [r7, #4]
 800152e:	2200      	movs	r2, #0
 8001530:	705a      	strb	r2, [r3, #1]
}
 8001532:	bf00      	nop
 8001534:	3708      	adds	r7, #8
 8001536:	46bd      	mov	sp, r7
 8001538:	bd80      	pop	{r7, pc}

0800153a <stm32_lock_acquire>:
/**
  * @brief Acquire STM32 lock
  * @param lock The lock to acquire
  */
static inline void stm32_lock_acquire(LockingData_t *lock)
{
 800153a:	b580      	push	{r7, lr}
 800153c:	b084      	sub	sp, #16
 800153e:	af00      	add	r7, sp, #0
 8001540:	6078      	str	r0, [r7, #4]
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 8001542:	f3ef 8310 	mrs	r3, PRIMASK
 8001546:	60bb      	str	r3, [r7, #8]
  return(result);
 8001548:	68bb      	ldr	r3, [r7, #8]
  uint8_t flag = (uint8_t)(__get_PRIMASK() & 0x1); /* PRIMASK.PM */
 800154a:	b2db      	uxtb	r3, r3
 800154c:	f003 0301 	and.w	r3, r3, #1
 8001550:	73fb      	strb	r3, [r7, #15]
  __ASM volatile ("cpsid i" : : : "memory");
 8001552:	b672      	cpsid	i
}
 8001554:	bf00      	nop
  __ASM volatile ("dsb 0xF":::"memory");
 8001556:	f3bf 8f4f 	dsb	sy
}
 800155a:	bf00      	nop
  __ASM volatile ("isb 0xF":::"memory");
 800155c:	f3bf 8f6f 	isb	sy
}
 8001560:	bf00      	nop
  __disable_irq();
  __DSB();
  __ISB();
  STM32_LOCK_BLOCK_IF_NULL_ARGUMENT(lock);
 8001562:	687b      	ldr	r3, [r7, #4]
 8001564:	2b00      	cmp	r3, #0
 8001566:	d104      	bne.n	8001572 <stm32_lock_acquire+0x38>
  __ASM volatile ("cpsid i" : : : "memory");
 8001568:	b672      	cpsid	i
}
 800156a:	bf00      	nop
 800156c:	f7ff fc9e 	bl	8000eac <Error_Handler>
 8001570:	e7fe      	b.n	8001570 <stm32_lock_acquire+0x36>
  if (lock->counter == 0)
 8001572:	687b      	ldr	r3, [r7, #4]
 8001574:	785b      	ldrb	r3, [r3, #1]
 8001576:	2b00      	cmp	r3, #0
 8001578:	d103      	bne.n	8001582 <stm32_lock_acquire+0x48>
  {
    lock->flag = flag;
 800157a:	687b      	ldr	r3, [r7, #4]
 800157c:	7bfa      	ldrb	r2, [r7, #15]
 800157e:	701a      	strb	r2, [r3, #0]
 8001580:	e008      	b.n	8001594 <stm32_lock_acquire+0x5a>
  }
  else if (lock->counter == UINT8_MAX)
 8001582:	687b      	ldr	r3, [r7, #4]
 8001584:	785b      	ldrb	r3, [r3, #1]
 8001586:	2bff      	cmp	r3, #255	; 0xff
 8001588:	d104      	bne.n	8001594 <stm32_lock_acquire+0x5a>
  __ASM volatile ("cpsid i" : : : "memory");
 800158a:	b672      	cpsid	i
}
 800158c:	bf00      	nop
  {
    STM32_LOCK_BLOCK();
 800158e:	f7ff fc8d 	bl	8000eac <Error_Handler>
 8001592:	e7fe      	b.n	8001592 <stm32_lock_acquire+0x58>
  }
  lock->counter++;
 8001594:	687b      	ldr	r3, [r7, #4]
 8001596:	785b      	ldrb	r3, [r3, #1]
 8001598:	3301      	adds	r3, #1
 800159a:	b2da      	uxtb	r2, r3
 800159c:	687b      	ldr	r3, [r7, #4]
 800159e:	705a      	strb	r2, [r3, #1]
}
 80015a0:	bf00      	nop
 80015a2:	3710      	adds	r7, #16
 80015a4:	46bd      	mov	sp, r7
 80015a6:	bd80      	pop	{r7, pc}

080015a8 <stm32_lock_release>:
/**
  * @brief Release STM32 lock
  * @param lock The lock to release
  */
static inline void stm32_lock_release(LockingData_t *lock)
{
 80015a8:	b580      	push	{r7, lr}
 80015aa:	b082      	sub	sp, #8
 80015ac:	af00      	add	r7, sp, #0
 80015ae:	6078      	str	r0, [r7, #4]
  STM32_LOCK_BLOCK_IF_NULL_ARGUMENT(lock);
 80015b0:	687b      	ldr	r3, [r7, #4]
 80015b2:	2b00      	cmp	r3, #0
 80015b4:	d104      	bne.n	80015c0 <stm32_lock_release+0x18>
  __ASM volatile ("cpsid i" : : : "memory");
 80015b6:	b672      	cpsid	i
}
 80015b8:	bf00      	nop
 80015ba:	f7ff fc77 	bl	8000eac <Error_Handler>
 80015be:	e7fe      	b.n	80015be <stm32_lock_release+0x16>
  if (lock->counter == 0)
 80015c0:	687b      	ldr	r3, [r7, #4]
 80015c2:	785b      	ldrb	r3, [r3, #1]
 80015c4:	2b00      	cmp	r3, #0
 80015c6:	d104      	bne.n	80015d2 <stm32_lock_release+0x2a>
  __ASM volatile ("cpsid i" : : : "memory");
 80015c8:	b672      	cpsid	i
}
 80015ca:	bf00      	nop
  {
    STM32_LOCK_BLOCK();
 80015cc:	f7ff fc6e 	bl	8000eac <Error_Handler>
 80015d0:	e7fe      	b.n	80015d0 <stm32_lock_release+0x28>
  }
  lock->counter--;
 80015d2:	687b      	ldr	r3, [r7, #4]
 80015d4:	785b      	ldrb	r3, [r3, #1]
 80015d6:	3b01      	subs	r3, #1
 80015d8:	b2da      	uxtb	r2, r3
 80015da:	687b      	ldr	r3, [r7, #4]
 80015dc:	705a      	strb	r2, [r3, #1]
  if (lock->counter == 0 && lock->flag == 0)
 80015de:	687b      	ldr	r3, [r7, #4]
 80015e0:	785b      	ldrb	r3, [r3, #1]
 80015e2:	2b00      	cmp	r3, #0
 80015e4:	d105      	bne.n	80015f2 <stm32_lock_release+0x4a>
 80015e6:	687b      	ldr	r3, [r7, #4]
 80015e8:	781b      	ldrb	r3, [r3, #0]
 80015ea:	2b00      	cmp	r3, #0
 80015ec:	d101      	bne.n	80015f2 <stm32_lock_release+0x4a>
  __ASM volatile ("cpsie i" : : : "memory");
 80015ee:	b662      	cpsie	i
}
 80015f0:	bf00      	nop
  {
    __enable_irq();
  }
}
 80015f2:	bf00      	nop
 80015f4:	3708      	adds	r7, #8
 80015f6:	46bd      	mov	sp, r7
 80015f8:	bd80      	pop	{r7, pc}

080015fa <__retarget_lock_init_recursive>:
/**
  * @brief Initialize recursive lock
  * @param lock The lock
  */
void __retarget_lock_init_recursive(_LOCK_T *lock)
{
 80015fa:	b580      	push	{r7, lr}
 80015fc:	b082      	sub	sp, #8
 80015fe:	af00      	add	r7, sp, #0
 8001600:	6078      	str	r0, [r7, #4]
  if (lock == NULL)
 8001602:	687b      	ldr	r3, [r7, #4]
 8001604:	2b00      	cmp	r3, #0
 8001606:	d105      	bne.n	8001614 <__retarget_lock_init_recursive+0x1a>
  {
    errno = EINVAL;
 8001608:	f01e f8c4 	bl	801f794 <__errno>
 800160c:	4603      	mov	r3, r0
 800160e:	2216      	movs	r2, #22
 8001610:	601a      	str	r2, [r3, #0]
    return;
 8001612:	e015      	b.n	8001640 <__retarget_lock_init_recursive+0x46>
  }

  *lock = (_LOCK_T)malloc(sizeof(struct __lock));
 8001614:	2002      	movs	r0, #2
 8001616:	f01e f8f9 	bl	801f80c <malloc>
 800161a:	4603      	mov	r3, r0
 800161c:	461a      	mov	r2, r3
 800161e:	687b      	ldr	r3, [r7, #4]
 8001620:	601a      	str	r2, [r3, #0]
  if (*lock != NULL)
 8001622:	687b      	ldr	r3, [r7, #4]
 8001624:	681b      	ldr	r3, [r3, #0]
 8001626:	2b00      	cmp	r3, #0
 8001628:	d005      	beq.n	8001636 <__retarget_lock_init_recursive+0x3c>
  {
    stm32_lock_init(STM32_LOCK_PARAMETER(*lock));
 800162a:	687b      	ldr	r3, [r7, #4]
 800162c:	681b      	ldr	r3, [r3, #0]
 800162e:	4618      	mov	r0, r3
 8001630:	f7ff ff6d 	bl	800150e <stm32_lock_init>
    return;
 8001634:	e004      	b.n	8001640 <__retarget_lock_init_recursive+0x46>
  __ASM volatile ("cpsid i" : : : "memory");
 8001636:	b672      	cpsid	i
}
 8001638:	bf00      	nop
  }

  /* Unable to allocate memory */
  STM32_LOCK_BLOCK();
 800163a:	f7ff fc37 	bl	8000eac <Error_Handler>
 800163e:	e7fe      	b.n	800163e <__retarget_lock_init_recursive+0x44>
}
 8001640:	3708      	adds	r7, #8
 8001642:	46bd      	mov	sp, r7
 8001644:	bd80      	pop	{r7, pc}

08001646 <__retarget_lock_acquire_recursive>:
/**
  * @brief Acquire recursive lock
  * @param lock The lock
  */
void __retarget_lock_acquire_recursive(_LOCK_T lock)
{
 8001646:	b580      	push	{r7, lr}
 8001648:	b082      	sub	sp, #8
 800164a:	af00      	add	r7, sp, #0
 800164c:	6078      	str	r0, [r7, #4]
  STM32_LOCK_BLOCK_IF_NULL_ARGUMENT(lock);
 800164e:	687b      	ldr	r3, [r7, #4]
 8001650:	2b00      	cmp	r3, #0
 8001652:	d104      	bne.n	800165e <__retarget_lock_acquire_recursive+0x18>
  __ASM volatile ("cpsid i" : : : "memory");
 8001654:	b672      	cpsid	i
}
 8001656:	bf00      	nop
 8001658:	f7ff fc28 	bl	8000eac <Error_Handler>
 800165c:	e7fe      	b.n	800165c <__retarget_lock_acquire_recursive+0x16>
  stm32_lock_acquire(STM32_LOCK_PARAMETER(lock));
 800165e:	687b      	ldr	r3, [r7, #4]
 8001660:	4618      	mov	r0, r3
 8001662:	f7ff ff6a 	bl	800153a <stm32_lock_acquire>
}
 8001666:	bf00      	nop
 8001668:	3708      	adds	r7, #8
 800166a:	46bd      	mov	sp, r7
 800166c:	bd80      	pop	{r7, pc}

0800166e <__retarget_lock_release_recursive>:
/**
  * @brief Release recursive lock
  * @param lock The lock
  */
void __retarget_lock_release_recursive(_LOCK_T lock)
{
 800166e:	b580      	push	{r7, lr}
 8001670:	b082      	sub	sp, #8
 8001672:	af00      	add	r7, sp, #0
 8001674:	6078      	str	r0, [r7, #4]
  STM32_LOCK_BLOCK_IF_NULL_ARGUMENT(lock);
 8001676:	687b      	ldr	r3, [r7, #4]
 8001678:	2b00      	cmp	r3, #0
 800167a:	d104      	bne.n	8001686 <__retarget_lock_release_recursive+0x18>
  __ASM volatile ("cpsid i" : : : "memory");
 800167c:	b672      	cpsid	i
}
 800167e:	bf00      	nop
 8001680:	f7ff fc14 	bl	8000eac <Error_Handler>
 8001684:	e7fe      	b.n	8001684 <__retarget_lock_release_recursive+0x16>
  stm32_lock_release(STM32_LOCK_PARAMETER(lock));
 8001686:	687b      	ldr	r3, [r7, #4]
 8001688:	4618      	mov	r0, r3
 800168a:	f7ff ff8d 	bl	80015a8 <stm32_lock_release>
}
 800168e:	bf00      	nop
 8001690:	3708      	adds	r7, #8
 8001692:	46bd      	mov	sp, r7
 8001694:	bd80      	pop	{r7, pc}
	...

08001698 <HAL_Init>:
  *         need to ensure that the SysTick time base is always set to 1 millisecond
  *         to have correct HAL operation.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_Init(void)
{
 8001698:	b580      	push	{r7, lr}
 800169a:	b082      	sub	sp, #8
 800169c:	af00      	add	r7, sp, #0
   __HAL_ART_CONFIG_BASE_ADDRESS(0x08100000UL);  /* Configure the Cortex-M4 ART Base address to the Flash Bank 2 : */
   __HAL_ART_ENABLE();                           /* Enable the Cortex-M4 ART */
#endif /* DUAL_CORE &&  CORE_CM4 */

  /* Set Interrupt Group Priority */
  HAL_NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_4);
 800169e:	2003      	movs	r0, #3
 80016a0:	f000 f90f 	bl	80018c2 <HAL_NVIC_SetPriorityGrouping>

  /* Update the SystemCoreClock global variable */
#if defined(RCC_D1CFGR_D1CPRE)
  common_system_clock = HAL_RCC_GetSysClockFreq() >> ((D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_D1CPRE)>> RCC_D1CFGR_D1CPRE_Pos]) & 0x1FU);
 80016a4:	f001 fa24 	bl	8002af0 <HAL_RCC_GetSysClockFreq>
 80016a8:	4602      	mov	r2, r0
 80016aa:	4b15      	ldr	r3, [pc, #84]	; (8001700 <HAL_Init+0x68>)
 80016ac:	699b      	ldr	r3, [r3, #24]
 80016ae:	0a1b      	lsrs	r3, r3, #8
 80016b0:	f003 030f 	and.w	r3, r3, #15
 80016b4:	4913      	ldr	r1, [pc, #76]	; (8001704 <HAL_Init+0x6c>)
 80016b6:	5ccb      	ldrb	r3, [r1, r3]
 80016b8:	f003 031f 	and.w	r3, r3, #31
 80016bc:	fa22 f303 	lsr.w	r3, r2, r3
 80016c0:	607b      	str	r3, [r7, #4]
  common_system_clock = HAL_RCC_GetSysClockFreq() >> ((D1CorePrescTable[(RCC->CDCFGR1 & RCC_CDCFGR1_CDCPRE)>> RCC_CDCFGR1_CDCPRE_Pos]) & 0x1FU);
#endif

  /* Update the SystemD2Clock global variable */
#if defined(RCC_D1CFGR_HPRE)
  SystemD2Clock = (common_system_clock >> ((D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_HPRE)>> RCC_D1CFGR_HPRE_Pos]) & 0x1FU));
 80016c2:	4b0f      	ldr	r3, [pc, #60]	; (8001700 <HAL_Init+0x68>)
 80016c4:	699b      	ldr	r3, [r3, #24]
 80016c6:	f003 030f 	and.w	r3, r3, #15
 80016ca:	4a0e      	ldr	r2, [pc, #56]	; (8001704 <HAL_Init+0x6c>)
 80016cc:	5cd3      	ldrb	r3, [r2, r3]
 80016ce:	f003 031f 	and.w	r3, r3, #31
 80016d2:	687a      	ldr	r2, [r7, #4]
 80016d4:	fa22 f303 	lsr.w	r3, r2, r3
 80016d8:	4a0b      	ldr	r2, [pc, #44]	; (8001708 <HAL_Init+0x70>)
 80016da:	6013      	str	r3, [r2, #0]
#endif

#if defined(DUAL_CORE) && defined(CORE_CM4)
  SystemCoreClock = SystemD2Clock;
#else
  SystemCoreClock = common_system_clock;
 80016dc:	4a0b      	ldr	r2, [pc, #44]	; (800170c <HAL_Init+0x74>)
 80016de:	687b      	ldr	r3, [r7, #4]
 80016e0:	6013      	str	r3, [r2, #0]
#endif /* DUAL_CORE && CORE_CM4 */

  /* Use systick as time base source and configure 1ms tick (default clock after Reset is HSI) */
  if(HAL_InitTick(TICK_INT_PRIORITY) != HAL_OK)
 80016e2:	200f      	movs	r0, #15
 80016e4:	f7ff fce4 	bl	80010b0 <HAL_InitTick>
 80016e8:	4603      	mov	r3, r0
 80016ea:	2b00      	cmp	r3, #0
 80016ec:	d001      	beq.n	80016f2 <HAL_Init+0x5a>
  {
    return HAL_ERROR;
 80016ee:	2301      	movs	r3, #1
 80016f0:	e002      	b.n	80016f8 <HAL_Init+0x60>
  }

  /* Init the low level hardware */
  HAL_MspInit();
 80016f2:	f7ff fcc3 	bl	800107c <HAL_MspInit>

  /* Return function status */
  return HAL_OK;
 80016f6:	2300      	movs	r3, #0
}
 80016f8:	4618      	mov	r0, r3
 80016fa:	3708      	adds	r7, #8
 80016fc:	46bd      	mov	sp, r7
 80016fe:	bd80      	pop	{r7, pc}
 8001700:	58024400 	.word	0x58024400
 8001704:	0802621c 	.word	0x0802621c
 8001708:	24000004 	.word	0x24000004
 800170c:	24000000 	.word	0x24000000

08001710 <HAL_IncTick>:
 * @note This function is declared as __weak to be overwritten in case of other
  *      implementations in user file.
  * @retval None
  */
__weak void HAL_IncTick(void)
{
 8001710:	b480      	push	{r7}
 8001712:	af00      	add	r7, sp, #0
  uwTick += (uint32_t)uwTickFreq;
 8001714:	4b06      	ldr	r3, [pc, #24]	; (8001730 <HAL_IncTick+0x20>)
 8001716:	781b      	ldrb	r3, [r3, #0]
 8001718:	461a      	mov	r2, r3
 800171a:	4b06      	ldr	r3, [pc, #24]	; (8001734 <HAL_IncTick+0x24>)
 800171c:	681b      	ldr	r3, [r3, #0]
 800171e:	4413      	add	r3, r2
 8001720:	4a04      	ldr	r2, [pc, #16]	; (8001734 <HAL_IncTick+0x24>)
 8001722:	6013      	str	r3, [r2, #0]
}
 8001724:	bf00      	nop
 8001726:	46bd      	mov	sp, r7
 8001728:	f85d 7b04 	ldr.w	r7, [sp], #4
 800172c:	4770      	bx	lr
 800172e:	bf00      	nop
 8001730:	2400000c 	.word	0x2400000c
 8001734:	24000b00 	.word	0x24000b00

08001738 <HAL_GetTick>:
  * @note This function is declared as __weak to be overwritten in case of other
  *       implementations in user file.
  * @retval tick value
  */
__weak uint32_t HAL_GetTick(void)
{
 8001738:	b480      	push	{r7}
 800173a:	af00      	add	r7, sp, #0
  return uwTick;
 800173c:	4b03      	ldr	r3, [pc, #12]	; (800174c <HAL_GetTick+0x14>)
 800173e:	681b      	ldr	r3, [r3, #0]
}
 8001740:	4618      	mov	r0, r3
 8001742:	46bd      	mov	sp, r7
 8001744:	f85d 7b04 	ldr.w	r7, [sp], #4
 8001748:	4770      	bx	lr
 800174a:	bf00      	nop
 800174c:	24000b00 	.word	0x24000b00

08001750 <HAL_GetREVID>:
/**
  * @brief  Returns the device revision identifier.
  * @retval Device revision identifier
  */
uint32_t HAL_GetREVID(void)
{
 8001750:	b480      	push	{r7}
 8001752:	af00      	add	r7, sp, #0
   return((DBGMCU->IDCODE) >> 16);
 8001754:	4b03      	ldr	r3, [pc, #12]	; (8001764 <HAL_GetREVID+0x14>)
 8001756:	681b      	ldr	r3, [r3, #0]
 8001758:	0c1b      	lsrs	r3, r3, #16
}
 800175a:	4618      	mov	r0, r3
 800175c:	46bd      	mov	sp, r7
 800175e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8001762:	4770      	bx	lr
 8001764:	5c001000 	.word	0x5c001000

08001768 <__NVIC_SetPriorityGrouping>:
{
 8001768:	b480      	push	{r7}
 800176a:	b085      	sub	sp, #20
 800176c:	af00      	add	r7, sp, #0
 800176e:	6078      	str	r0, [r7, #4]
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);             /* only values 0..7 are used          */
 8001770:	687b      	ldr	r3, [r7, #4]
 8001772:	f003 0307 	and.w	r3, r3, #7
 8001776:	60fb      	str	r3, [r7, #12]
  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
 8001778:	4b0b      	ldr	r3, [pc, #44]	; (80017a8 <__NVIC_SetPriorityGrouping+0x40>)
 800177a:	68db      	ldr	r3, [r3, #12]
 800177c:	60bb      	str	r3, [r7, #8]
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
 800177e:	68ba      	ldr	r2, [r7, #8]
 8001780:	f64f 03ff 	movw	r3, #63743	; 0xf8ff
 8001784:	4013      	ands	r3, r2
 8001786:	60bb      	str	r3, [r7, #8]
                (PriorityGroupTmp << SCB_AIRCR_PRIGROUP_Pos)  );              /* Insert write key and priority group */
 8001788:	68fb      	ldr	r3, [r7, #12]
 800178a:	021a      	lsls	r2, r3, #8
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
 800178c:	68bb      	ldr	r3, [r7, #8]
 800178e:	431a      	orrs	r2, r3
  reg_value  =  (reg_value                                   |
 8001790:	4b06      	ldr	r3, [pc, #24]	; (80017ac <__NVIC_SetPriorityGrouping+0x44>)
 8001792:	4313      	orrs	r3, r2
 8001794:	60bb      	str	r3, [r7, #8]
  SCB->AIRCR =  reg_value;
 8001796:	4a04      	ldr	r2, [pc, #16]	; (80017a8 <__NVIC_SetPriorityGrouping+0x40>)
 8001798:	68bb      	ldr	r3, [r7, #8]
 800179a:	60d3      	str	r3, [r2, #12]
}
 800179c:	bf00      	nop
 800179e:	3714      	adds	r7, #20
 80017a0:	46bd      	mov	sp, r7
 80017a2:	f85d 7b04 	ldr.w	r7, [sp], #4
 80017a6:	4770      	bx	lr
 80017a8:	e000ed00 	.word	0xe000ed00
 80017ac:	05fa0000 	.word	0x05fa0000

080017b0 <__NVIC_GetPriorityGrouping>:
{
 80017b0:	b480      	push	{r7}
 80017b2:	af00      	add	r7, sp, #0
  return ((uint32_t)((SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) >> SCB_AIRCR_PRIGROUP_Pos));
 80017b4:	4b04      	ldr	r3, [pc, #16]	; (80017c8 <__NVIC_GetPriorityGrouping+0x18>)
 80017b6:	68db      	ldr	r3, [r3, #12]
 80017b8:	0a1b      	lsrs	r3, r3, #8
 80017ba:	f003 0307 	and.w	r3, r3, #7
}
 80017be:	4618      	mov	r0, r3
 80017c0:	46bd      	mov	sp, r7
 80017c2:	f85d 7b04 	ldr.w	r7, [sp], #4
 80017c6:	4770      	bx	lr
 80017c8:	e000ed00 	.word	0xe000ed00

080017cc <__NVIC_EnableIRQ>:
{
 80017cc:	b480      	push	{r7}
 80017ce:	b083      	sub	sp, #12
 80017d0:	af00      	add	r7, sp, #0
 80017d2:	4603      	mov	r3, r0
 80017d4:	80fb      	strh	r3, [r7, #6]
  if ((int32_t)(IRQn) >= 0)
 80017d6:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
 80017da:	2b00      	cmp	r3, #0
 80017dc:	db0b      	blt.n	80017f6 <__NVIC_EnableIRQ+0x2a>
    NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
 80017de:	88fb      	ldrh	r3, [r7, #6]
 80017e0:	f003 021f 	and.w	r2, r3, #31
 80017e4:	4907      	ldr	r1, [pc, #28]	; (8001804 <__NVIC_EnableIRQ+0x38>)
 80017e6:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
 80017ea:	095b      	lsrs	r3, r3, #5
 80017ec:	2001      	movs	r0, #1
 80017ee:	fa00 f202 	lsl.w	r2, r0, r2
 80017f2:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
 80017f6:	bf00      	nop
 80017f8:	370c      	adds	r7, #12
 80017fa:	46bd      	mov	sp, r7
 80017fc:	f85d 7b04 	ldr.w	r7, [sp], #4
 8001800:	4770      	bx	lr
 8001802:	bf00      	nop
 8001804:	e000e100 	.word	0xe000e100

08001808 <__NVIC_SetPriority>:
{
 8001808:	b480      	push	{r7}
 800180a:	b083      	sub	sp, #12
 800180c:	af00      	add	r7, sp, #0
 800180e:	4603      	mov	r3, r0
 8001810:	6039      	str	r1, [r7, #0]
 8001812:	80fb      	strh	r3, [r7, #6]
  if ((int32_t)(IRQn) >= 0)
 8001814:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
 8001818:	2b00      	cmp	r3, #0
 800181a:	db0a      	blt.n	8001832 <__NVIC_SetPriority+0x2a>
    NVIC->IP[((uint32_t)IRQn)]                = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 800181c:	683b      	ldr	r3, [r7, #0]
 800181e:	b2da      	uxtb	r2, r3
 8001820:	490c      	ldr	r1, [pc, #48]	; (8001854 <__NVIC_SetPriority+0x4c>)
 8001822:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
 8001826:	0112      	lsls	r2, r2, #4
 8001828:	b2d2      	uxtb	r2, r2
 800182a:	440b      	add	r3, r1
 800182c:	f883 2300 	strb.w	r2, [r3, #768]	; 0x300
}
 8001830:	e00a      	b.n	8001848 <__NVIC_SetPriority+0x40>
    SCB->SHPR[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8001832:	683b      	ldr	r3, [r7, #0]
 8001834:	b2da      	uxtb	r2, r3
 8001836:	4908      	ldr	r1, [pc, #32]	; (8001858 <__NVIC_SetPriority+0x50>)
 8001838:	88fb      	ldrh	r3, [r7, #6]
 800183a:	f003 030f 	and.w	r3, r3, #15
 800183e:	3b04      	subs	r3, #4
 8001840:	0112      	lsls	r2, r2, #4
 8001842:	b2d2      	uxtb	r2, r2
 8001844:	440b      	add	r3, r1
 8001846:	761a      	strb	r2, [r3, #24]
}
 8001848:	bf00      	nop
 800184a:	370c      	adds	r7, #12
 800184c:	46bd      	mov	sp, r7
 800184e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8001852:	4770      	bx	lr
 8001854:	e000e100 	.word	0xe000e100
 8001858:	e000ed00 	.word	0xe000ed00

0800185c <NVIC_EncodePriority>:
{
 800185c:	b480      	push	{r7}
 800185e:	b089      	sub	sp, #36	; 0x24
 8001860:	af00      	add	r7, sp, #0
 8001862:	60f8      	str	r0, [r7, #12]
 8001864:	60b9      	str	r1, [r7, #8]
 8001866:	607a      	str	r2, [r7, #4]
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);   /* only values 0..7 are used          */
 8001868:	68fb      	ldr	r3, [r7, #12]
 800186a:	f003 0307 	and.w	r3, r3, #7
 800186e:	61fb      	str	r3, [r7, #28]
  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
 8001870:	69fb      	ldr	r3, [r7, #28]
 8001872:	f1c3 0307 	rsb	r3, r3, #7
 8001876:	2b04      	cmp	r3, #4
 8001878:	bf28      	it	cs
 800187a:	2304      	movcs	r3, #4
 800187c:	61bb      	str	r3, [r7, #24]
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 800187e:	69fb      	ldr	r3, [r7, #28]
 8001880:	3304      	adds	r3, #4
 8001882:	2b06      	cmp	r3, #6
 8001884:	d902      	bls.n	800188c <NVIC_EncodePriority+0x30>
 8001886:	69fb      	ldr	r3, [r7, #28]
 8001888:	3b03      	subs	r3, #3
 800188a:	e000      	b.n	800188e <NVIC_EncodePriority+0x32>
 800188c:	2300      	movs	r3, #0
 800188e:	617b      	str	r3, [r7, #20]
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
 8001890:	f04f 32ff 	mov.w	r2, #4294967295
 8001894:	69bb      	ldr	r3, [r7, #24]
 8001896:	fa02 f303 	lsl.w	r3, r2, r3
 800189a:	43da      	mvns	r2, r3
 800189c:	68bb      	ldr	r3, [r7, #8]
 800189e:	401a      	ands	r2, r3
 80018a0:	697b      	ldr	r3, [r7, #20]
 80018a2:	409a      	lsls	r2, r3
           ((SubPriority     & (uint32_t)((1UL << (SubPriorityBits    )) - 1UL)))
 80018a4:	f04f 31ff 	mov.w	r1, #4294967295
 80018a8:	697b      	ldr	r3, [r7, #20]
 80018aa:	fa01 f303 	lsl.w	r3, r1, r3
 80018ae:	43d9      	mvns	r1, r3
 80018b0:	687b      	ldr	r3, [r7, #4]
 80018b2:	400b      	ands	r3, r1
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
 80018b4:	4313      	orrs	r3, r2
}
 80018b6:	4618      	mov	r0, r3
 80018b8:	3724      	adds	r7, #36	; 0x24
 80018ba:	46bd      	mov	sp, r7
 80018bc:	f85d 7b04 	ldr.w	r7, [sp], #4
 80018c0:	4770      	bx	lr

080018c2 <HAL_NVIC_SetPriorityGrouping>:
  * @note   When the NVIC_PriorityGroup_0 is selected, IRQ preemption is no more possible.
  *         The pending IRQ priority will be managed only by the subpriority.
  * @retval None
  */
void HAL_NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
{
 80018c2:	b580      	push	{r7, lr}
 80018c4:	b082      	sub	sp, #8
 80018c6:	af00      	add	r7, sp, #0
 80018c8:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param(IS_NVIC_PRIORITY_GROUP(PriorityGroup));

  /* Set the PRIGROUP[10:8] bits according to the PriorityGroup parameter value */
  NVIC_SetPriorityGrouping(PriorityGroup);
 80018ca:	6878      	ldr	r0, [r7, #4]
 80018cc:	f7ff ff4c 	bl	8001768 <__NVIC_SetPriorityGrouping>
}
 80018d0:	bf00      	nop
 80018d2:	3708      	adds	r7, #8
 80018d4:	46bd      	mov	sp, r7
 80018d6:	bd80      	pop	{r7, pc}

080018d8 <HAL_NVIC_SetPriority>:
  *         This parameter can be a value between 0 and 15
  *         A lower priority value indicates a higher priority.
  * @retval None
  */
void HAL_NVIC_SetPriority(IRQn_Type IRQn, uint32_t PreemptPriority, uint32_t SubPriority)
{
 80018d8:	b580      	push	{r7, lr}
 80018da:	b086      	sub	sp, #24
 80018dc:	af00      	add	r7, sp, #0
 80018de:	4603      	mov	r3, r0
 80018e0:	60b9      	str	r1, [r7, #8]
 80018e2:	607a      	str	r2, [r7, #4]
 80018e4:	81fb      	strh	r3, [r7, #14]

  /* Check the parameters */
  assert_param(IS_NVIC_SUB_PRIORITY(SubPriority));
  assert_param(IS_NVIC_PREEMPTION_PRIORITY(PreemptPriority));

  prioritygroup = NVIC_GetPriorityGrouping();
 80018e6:	f7ff ff63 	bl	80017b0 <__NVIC_GetPriorityGrouping>
 80018ea:	6178      	str	r0, [r7, #20]

  NVIC_SetPriority(IRQn, NVIC_EncodePriority(prioritygroup, PreemptPriority, SubPriority));
 80018ec:	687a      	ldr	r2, [r7, #4]
 80018ee:	68b9      	ldr	r1, [r7, #8]
 80018f0:	6978      	ldr	r0, [r7, #20]
 80018f2:	f7ff ffb3 	bl	800185c <NVIC_EncodePriority>
 80018f6:	4602      	mov	r2, r0
 80018f8:	f9b7 300e 	ldrsh.w	r3, [r7, #14]
 80018fc:	4611      	mov	r1, r2
 80018fe:	4618      	mov	r0, r3
 8001900:	f7ff ff82 	bl	8001808 <__NVIC_SetPriority>
}
 8001904:	bf00      	nop
 8001906:	3718      	adds	r7, #24
 8001908:	46bd      	mov	sp, r7
 800190a:	bd80      	pop	{r7, pc}

0800190c <HAL_NVIC_EnableIRQ>:
  *         This parameter can be an enumerator of IRQn_Type enumeration
  *         (For the complete STM32 Devices IRQ Channels list, please refer to the appropriate CMSIS device file (stm32h7xxxx.h))
  * @retval None
  */
void HAL_NVIC_EnableIRQ(IRQn_Type IRQn)
{
 800190c:	b580      	push	{r7, lr}
 800190e:	b082      	sub	sp, #8
 8001910:	af00      	add	r7, sp, #0
 8001912:	4603      	mov	r3, r0
 8001914:	80fb      	strh	r3, [r7, #6]
  /* Check the parameters */
  assert_param(IS_NVIC_DEVICE_IRQ(IRQn));

  /* Enable interrupt */
  NVIC_EnableIRQ(IRQn);
 8001916:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
 800191a:	4618      	mov	r0, r3
 800191c:	f7ff ff56 	bl	80017cc <__NVIC_EnableIRQ>
}
 8001920:	bf00      	nop
 8001922:	3708      	adds	r7, #8
 8001924:	46bd      	mov	sp, r7
 8001926:	bd80      	pop	{r7, pc}

08001928 <HAL_MPU_Disable>:
/**
  * @brief  Disables the MPU
  * @retval None
  */
void HAL_MPU_Disable(void)
{
 8001928:	b480      	push	{r7}
 800192a:	af00      	add	r7, sp, #0
  \details Ensures the apparent order of the explicit memory operations before
           and after the instruction, without ensuring their completion.
 */
__STATIC_FORCEINLINE void __DMB(void)
{
  __ASM volatile ("dmb 0xF":::"memory");
 800192c:	f3bf 8f5f 	dmb	sy
}
 8001930:	bf00      	nop
  /* Make sure outstanding transfers are done */
  __DMB();

  /* Disable fault exceptions */
  SCB->SHCSR &= ~SCB_SHCSR_MEMFAULTENA_Msk;
 8001932:	4b07      	ldr	r3, [pc, #28]	; (8001950 <HAL_MPU_Disable+0x28>)
 8001934:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8001936:	4a06      	ldr	r2, [pc, #24]	; (8001950 <HAL_MPU_Disable+0x28>)
 8001938:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
 800193c:	6253      	str	r3, [r2, #36]	; 0x24

  /* Disable the MPU and clear the control register*/
  MPU->CTRL = 0;
 800193e:	4b05      	ldr	r3, [pc, #20]	; (8001954 <HAL_MPU_Disable+0x2c>)
 8001940:	2200      	movs	r2, #0
 8001942:	605a      	str	r2, [r3, #4]
}
 8001944:	bf00      	nop
 8001946:	46bd      	mov	sp, r7
 8001948:	f85d 7b04 	ldr.w	r7, [sp], #4
 800194c:	4770      	bx	lr
 800194e:	bf00      	nop
 8001950:	e000ed00 	.word	0xe000ed00
 8001954:	e000ed90 	.word	0xe000ed90

08001958 <HAL_MPU_Enable>:
  *            @arg MPU_PRIVILEGED_DEFAULT
  *            @arg MPU_HFNMI_PRIVDEF
  * @retval None
  */
void HAL_MPU_Enable(uint32_t MPU_Control)
{
 8001958:	b480      	push	{r7}
 800195a:	b083      	sub	sp, #12
 800195c:	af00      	add	r7, sp, #0
 800195e:	6078      	str	r0, [r7, #4]
  /* Enable the MPU */
  MPU->CTRL = MPU_Control | MPU_CTRL_ENABLE_Msk;
 8001960:	4a0b      	ldr	r2, [pc, #44]	; (8001990 <HAL_MPU_Enable+0x38>)
 8001962:	687b      	ldr	r3, [r7, #4]
 8001964:	f043 0301 	orr.w	r3, r3, #1
 8001968:	6053      	str	r3, [r2, #4]

  /* Enable fault exceptions */
  SCB->SHCSR |= SCB_SHCSR_MEMFAULTENA_Msk;
 800196a:	4b0a      	ldr	r3, [pc, #40]	; (8001994 <HAL_MPU_Enable+0x3c>)
 800196c:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800196e:	4a09      	ldr	r2, [pc, #36]	; (8001994 <HAL_MPU_Enable+0x3c>)
 8001970:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 8001974:	6253      	str	r3, [r2, #36]	; 0x24
  __ASM volatile ("dsb 0xF":::"memory");
 8001976:	f3bf 8f4f 	dsb	sy
}
 800197a:	bf00      	nop
  __ASM volatile ("isb 0xF":::"memory");
 800197c:	f3bf 8f6f 	isb	sy
}
 8001980:	bf00      	nop

  /* Ensure MPU setting take effects */
  __DSB();
  __ISB();
}
 8001982:	bf00      	nop
 8001984:	370c      	adds	r7, #12
 8001986:	46bd      	mov	sp, r7
 8001988:	f85d 7b04 	ldr.w	r7, [sp], #4
 800198c:	4770      	bx	lr
 800198e:	bf00      	nop
 8001990:	e000ed90 	.word	0xe000ed90
 8001994:	e000ed00 	.word	0xe000ed00

08001998 <HAL_MPU_ConfigRegion>:
  * @param  MPU_Init Pointer to a MPU_Region_InitTypeDef structure that contains
  *                  the initialization and configuration information.
  * @retval None
  */
void HAL_MPU_ConfigRegion(MPU_Region_InitTypeDef *MPU_Init)
{
 8001998:	b480      	push	{r7}
 800199a:	b083      	sub	sp, #12
 800199c:	af00      	add	r7, sp, #0
 800199e:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param(IS_MPU_REGION_NUMBER(MPU_Init->Number));
  assert_param(IS_MPU_REGION_ENABLE(MPU_Init->Enable));

  /* Set the Region number */
  MPU->RNR = MPU_Init->Number;
 80019a0:	687b      	ldr	r3, [r7, #4]
 80019a2:	785a      	ldrb	r2, [r3, #1]
 80019a4:	4b1d      	ldr	r3, [pc, #116]	; (8001a1c <HAL_MPU_ConfigRegion+0x84>)
 80019a6:	609a      	str	r2, [r3, #8]

  if ((MPU_Init->Enable) != 0UL)
 80019a8:	687b      	ldr	r3, [r7, #4]
 80019aa:	781b      	ldrb	r3, [r3, #0]
 80019ac:	2b00      	cmp	r3, #0
 80019ae:	d029      	beq.n	8001a04 <HAL_MPU_ConfigRegion+0x6c>
    assert_param(IS_MPU_ACCESS_CACHEABLE(MPU_Init->IsCacheable));
    assert_param(IS_MPU_ACCESS_BUFFERABLE(MPU_Init->IsBufferable));
    assert_param(IS_MPU_SUB_REGION_DISABLE(MPU_Init->SubRegionDisable));
    assert_param(IS_MPU_REGION_SIZE(MPU_Init->Size));

    MPU->RBAR = MPU_Init->BaseAddress;
 80019b0:	4a1a      	ldr	r2, [pc, #104]	; (8001a1c <HAL_MPU_ConfigRegion+0x84>)
 80019b2:	687b      	ldr	r3, [r7, #4]
 80019b4:	685b      	ldr	r3, [r3, #4]
 80019b6:	60d3      	str	r3, [r2, #12]
    MPU->RASR = ((uint32_t)MPU_Init->DisableExec             << MPU_RASR_XN_Pos)   |
 80019b8:	687b      	ldr	r3, [r7, #4]
 80019ba:	7b1b      	ldrb	r3, [r3, #12]
 80019bc:	071a      	lsls	r2, r3, #28
                ((uint32_t)MPU_Init->AccessPermission        << MPU_RASR_AP_Pos)   |
 80019be:	687b      	ldr	r3, [r7, #4]
 80019c0:	7adb      	ldrb	r3, [r3, #11]
 80019c2:	061b      	lsls	r3, r3, #24
    MPU->RASR = ((uint32_t)MPU_Init->DisableExec             << MPU_RASR_XN_Pos)   |
 80019c4:	431a      	orrs	r2, r3
                ((uint32_t)MPU_Init->TypeExtField            << MPU_RASR_TEX_Pos)  |
 80019c6:	687b      	ldr	r3, [r7, #4]
 80019c8:	7a9b      	ldrb	r3, [r3, #10]
 80019ca:	04db      	lsls	r3, r3, #19
                ((uint32_t)MPU_Init->AccessPermission        << MPU_RASR_AP_Pos)   |
 80019cc:	431a      	orrs	r2, r3
                ((uint32_t)MPU_Init->IsShareable             << MPU_RASR_S_Pos)    |
 80019ce:	687b      	ldr	r3, [r7, #4]
 80019d0:	7b5b      	ldrb	r3, [r3, #13]
 80019d2:	049b      	lsls	r3, r3, #18
                ((uint32_t)MPU_Init->TypeExtField            << MPU_RASR_TEX_Pos)  |
 80019d4:	431a      	orrs	r2, r3
                ((uint32_t)MPU_Init->IsCacheable             << MPU_RASR_C_Pos)    |
 80019d6:	687b      	ldr	r3, [r7, #4]
 80019d8:	7b9b      	ldrb	r3, [r3, #14]
 80019da:	045b      	lsls	r3, r3, #17
                ((uint32_t)MPU_Init->IsShareable             << MPU_RASR_S_Pos)    |
 80019dc:	431a      	orrs	r2, r3
                ((uint32_t)MPU_Init->IsBufferable            << MPU_RASR_B_Pos)    |
 80019de:	687b      	ldr	r3, [r7, #4]
 80019e0:	7bdb      	ldrb	r3, [r3, #15]
 80019e2:	041b      	lsls	r3, r3, #16
                ((uint32_t)MPU_Init->IsCacheable             << MPU_RASR_C_Pos)    |
 80019e4:	431a      	orrs	r2, r3
                ((uint32_t)MPU_Init->SubRegionDisable        << MPU_RASR_SRD_Pos)  |
 80019e6:	687b      	ldr	r3, [r7, #4]
 80019e8:	7a5b      	ldrb	r3, [r3, #9]
 80019ea:	021b      	lsls	r3, r3, #8
                ((uint32_t)MPU_Init->IsBufferable            << MPU_RASR_B_Pos)    |
 80019ec:	431a      	orrs	r2, r3
                ((uint32_t)MPU_Init->Size                    << MPU_RASR_SIZE_Pos) |
 80019ee:	687b      	ldr	r3, [r7, #4]
 80019f0:	7a1b      	ldrb	r3, [r3, #8]
 80019f2:	005b      	lsls	r3, r3, #1
                ((uint32_t)MPU_Init->SubRegionDisable        << MPU_RASR_SRD_Pos)  |
 80019f4:	4313      	orrs	r3, r2
                ((uint32_t)MPU_Init->Enable                  << MPU_RASR_ENABLE_Pos);
 80019f6:	687a      	ldr	r2, [r7, #4]
 80019f8:	7812      	ldrb	r2, [r2, #0]
 80019fa:	4611      	mov	r1, r2
    MPU->RASR = ((uint32_t)MPU_Init->DisableExec             << MPU_RASR_XN_Pos)   |
 80019fc:	4a07      	ldr	r2, [pc, #28]	; (8001a1c <HAL_MPU_ConfigRegion+0x84>)
                ((uint32_t)MPU_Init->Size                    << MPU_RASR_SIZE_Pos) |
 80019fe:	430b      	orrs	r3, r1
    MPU->RASR = ((uint32_t)MPU_Init->DisableExec             << MPU_RASR_XN_Pos)   |
 8001a00:	6113      	str	r3, [r2, #16]
  else
  {
    MPU->RBAR = 0x00;
    MPU->RASR = 0x00;
  }
}
 8001a02:	e005      	b.n	8001a10 <HAL_MPU_ConfigRegion+0x78>
    MPU->RBAR = 0x00;
 8001a04:	4b05      	ldr	r3, [pc, #20]	; (8001a1c <HAL_MPU_ConfigRegion+0x84>)
 8001a06:	2200      	movs	r2, #0
 8001a08:	60da      	str	r2, [r3, #12]
    MPU->RASR = 0x00;
 8001a0a:	4b04      	ldr	r3, [pc, #16]	; (8001a1c <HAL_MPU_ConfigRegion+0x84>)
 8001a0c:	2200      	movs	r2, #0
 8001a0e:	611a      	str	r2, [r3, #16]
}
 8001a10:	bf00      	nop
 8001a12:	370c      	adds	r7, #12
 8001a14:	46bd      	mov	sp, r7
 8001a16:	f85d 7b04 	ldr.w	r7, [sp], #4
 8001a1a:	4770      	bx	lr
 8001a1c:	e000ed90 	.word	0xe000ed90

08001a20 <HAL_GPIO_Init>:
  * @param  GPIO_Init: pointer to a GPIO_InitTypeDef structure that contains
  *         the configuration information for the specified GPIO peripheral.
  * @retval None
  */
void HAL_GPIO_Init(GPIO_TypeDef  *GPIOx, GPIO_InitTypeDef *GPIO_Init)
{
 8001a20:	b480      	push	{r7}
 8001a22:	b089      	sub	sp, #36	; 0x24
 8001a24:	af00      	add	r7, sp, #0
 8001a26:	6078      	str	r0, [r7, #4]
 8001a28:	6039      	str	r1, [r7, #0]
  uint32_t position = 0x00U;
 8001a2a:	2300      	movs	r3, #0
 8001a2c:	61fb      	str	r3, [r7, #28]
  EXTI_Core_TypeDef *EXTI_CurrentCPU;

#if defined(DUAL_CORE) && defined(CORE_CM4)
  EXTI_CurrentCPU = EXTI_D2; /* EXTI for CM4 CPU */
#else
  EXTI_CurrentCPU = EXTI_D1; /* EXTI for CM7 CPU */
 8001a2e:	4b89      	ldr	r3, [pc, #548]	; (8001c54 <HAL_GPIO_Init+0x234>)
 8001a30:	617b      	str	r3, [r7, #20]
  assert_param(IS_GPIO_ALL_INSTANCE(GPIOx));
  assert_param(IS_GPIO_PIN(GPIO_Init->Pin));
  assert_param(IS_GPIO_MODE(GPIO_Init->Mode));

  /* Configure the port pins */
  while (((GPIO_Init->Pin) >> position) != 0x00U)
 8001a32:	e194      	b.n	8001d5e <HAL_GPIO_Init+0x33e>
  {
    /* Get current io position */
    iocurrent = (GPIO_Init->Pin) & (1UL << position);
 8001a34:	683b      	ldr	r3, [r7, #0]
 8001a36:	681a      	ldr	r2, [r3, #0]
 8001a38:	2101      	movs	r1, #1
 8001a3a:	69fb      	ldr	r3, [r7, #28]
 8001a3c:	fa01 f303 	lsl.w	r3, r1, r3
 8001a40:	4013      	ands	r3, r2
 8001a42:	613b      	str	r3, [r7, #16]

    if (iocurrent != 0x00U)
 8001a44:	693b      	ldr	r3, [r7, #16]
 8001a46:	2b00      	cmp	r3, #0
 8001a48:	f000 8186 	beq.w	8001d58 <HAL_GPIO_Init+0x338>
    {
      /*--------------------- GPIO Mode Configuration ------------------------*/
      /* In case of Output or Alternate function mode selection */
      if (((GPIO_Init->Mode & GPIO_MODE) == MODE_OUTPUT) || ((GPIO_Init->Mode & GPIO_MODE) == MODE_AF))
 8001a4c:	683b      	ldr	r3, [r7, #0]
 8001a4e:	685b      	ldr	r3, [r3, #4]
 8001a50:	f003 0303 	and.w	r3, r3, #3
 8001a54:	2b01      	cmp	r3, #1
 8001a56:	d005      	beq.n	8001a64 <HAL_GPIO_Init+0x44>
 8001a58:	683b      	ldr	r3, [r7, #0]
 8001a5a:	685b      	ldr	r3, [r3, #4]
 8001a5c:	f003 0303 	and.w	r3, r3, #3
 8001a60:	2b02      	cmp	r3, #2
 8001a62:	d130      	bne.n	8001ac6 <HAL_GPIO_Init+0xa6>
      {
        /* Check the Speed parameter */
        assert_param(IS_GPIO_SPEED(GPIO_Init->Speed));

        /* Configure the IO Speed */
        temp = GPIOx->OSPEEDR;
 8001a64:	687b      	ldr	r3, [r7, #4]
 8001a66:	689b      	ldr	r3, [r3, #8]
 8001a68:	61bb      	str	r3, [r7, #24]
        temp &= ~(GPIO_OSPEEDR_OSPEED0 << (position * 2U));
 8001a6a:	69fb      	ldr	r3, [r7, #28]
 8001a6c:	005b      	lsls	r3, r3, #1
 8001a6e:	2203      	movs	r2, #3
 8001a70:	fa02 f303 	lsl.w	r3, r2, r3
 8001a74:	43db      	mvns	r3, r3
 8001a76:	69ba      	ldr	r2, [r7, #24]
 8001a78:	4013      	ands	r3, r2
 8001a7a:	61bb      	str	r3, [r7, #24]
        temp |= (GPIO_Init->Speed << (position * 2U));
 8001a7c:	683b      	ldr	r3, [r7, #0]
 8001a7e:	68da      	ldr	r2, [r3, #12]
 8001a80:	69fb      	ldr	r3, [r7, #28]
 8001a82:	005b      	lsls	r3, r3, #1
 8001a84:	fa02 f303 	lsl.w	r3, r2, r3
 8001a88:	69ba      	ldr	r2, [r7, #24]
 8001a8a:	4313      	orrs	r3, r2
 8001a8c:	61bb      	str	r3, [r7, #24]
        GPIOx->OSPEEDR = temp;
 8001a8e:	687b      	ldr	r3, [r7, #4]
 8001a90:	69ba      	ldr	r2, [r7, #24]
 8001a92:	609a      	str	r2, [r3, #8]

        /* Configure the IO Output Type */
        temp = GPIOx->OTYPER;
 8001a94:	687b      	ldr	r3, [r7, #4]
 8001a96:	685b      	ldr	r3, [r3, #4]
 8001a98:	61bb      	str	r3, [r7, #24]
        temp &= ~(GPIO_OTYPER_OT0 << position) ;
 8001a9a:	2201      	movs	r2, #1
 8001a9c:	69fb      	ldr	r3, [r7, #28]
 8001a9e:	fa02 f303 	lsl.w	r3, r2, r3
 8001aa2:	43db      	mvns	r3, r3
 8001aa4:	69ba      	ldr	r2, [r7, #24]
 8001aa6:	4013      	ands	r3, r2
 8001aa8:	61bb      	str	r3, [r7, #24]
        temp |= (((GPIO_Init->Mode & OUTPUT_TYPE) >> OUTPUT_TYPE_Pos) << position);
 8001aaa:	683b      	ldr	r3, [r7, #0]
 8001aac:	685b      	ldr	r3, [r3, #4]
 8001aae:	091b      	lsrs	r3, r3, #4
 8001ab0:	f003 0201 	and.w	r2, r3, #1
 8001ab4:	69fb      	ldr	r3, [r7, #28]
 8001ab6:	fa02 f303 	lsl.w	r3, r2, r3
 8001aba:	69ba      	ldr	r2, [r7, #24]
 8001abc:	4313      	orrs	r3, r2
 8001abe:	61bb      	str	r3, [r7, #24]
        GPIOx->OTYPER = temp;
 8001ac0:	687b      	ldr	r3, [r7, #4]
 8001ac2:	69ba      	ldr	r2, [r7, #24]
 8001ac4:	605a      	str	r2, [r3, #4]
      }

      if ((GPIO_Init->Mode & GPIO_MODE) != MODE_ANALOG)
 8001ac6:	683b      	ldr	r3, [r7, #0]
 8001ac8:	685b      	ldr	r3, [r3, #4]
 8001aca:	f003 0303 	and.w	r3, r3, #3
 8001ace:	2b03      	cmp	r3, #3
 8001ad0:	d017      	beq.n	8001b02 <HAL_GPIO_Init+0xe2>
      {
       /* Check the Pull parameter */
       assert_param(IS_GPIO_PULL(GPIO_Init->Pull));

      /* Activate the Pull-up or Pull down resistor for the current IO */
      temp = GPIOx->PUPDR;
 8001ad2:	687b      	ldr	r3, [r7, #4]
 8001ad4:	68db      	ldr	r3, [r3, #12]
 8001ad6:	61bb      	str	r3, [r7, #24]
      temp &= ~(GPIO_PUPDR_PUPD0 << (position * 2U));
 8001ad8:	69fb      	ldr	r3, [r7, #28]
 8001ada:	005b      	lsls	r3, r3, #1
 8001adc:	2203      	movs	r2, #3
 8001ade:	fa02 f303 	lsl.w	r3, r2, r3
 8001ae2:	43db      	mvns	r3, r3
 8001ae4:	69ba      	ldr	r2, [r7, #24]
 8001ae6:	4013      	ands	r3, r2
 8001ae8:	61bb      	str	r3, [r7, #24]
      temp |= ((GPIO_Init->Pull) << (position * 2U));
 8001aea:	683b      	ldr	r3, [r7, #0]
 8001aec:	689a      	ldr	r2, [r3, #8]
 8001aee:	69fb      	ldr	r3, [r7, #28]
 8001af0:	005b      	lsls	r3, r3, #1
 8001af2:	fa02 f303 	lsl.w	r3, r2, r3
 8001af6:	69ba      	ldr	r2, [r7, #24]
 8001af8:	4313      	orrs	r3, r2
 8001afa:	61bb      	str	r3, [r7, #24]
      GPIOx->PUPDR = temp;
 8001afc:	687b      	ldr	r3, [r7, #4]
 8001afe:	69ba      	ldr	r2, [r7, #24]
 8001b00:	60da      	str	r2, [r3, #12]
      }

      /* In case of Alternate function mode selection */
      if ((GPIO_Init->Mode & GPIO_MODE) == MODE_AF)
 8001b02:	683b      	ldr	r3, [r7, #0]
 8001b04:	685b      	ldr	r3, [r3, #4]
 8001b06:	f003 0303 	and.w	r3, r3, #3
 8001b0a:	2b02      	cmp	r3, #2
 8001b0c:	d123      	bne.n	8001b56 <HAL_GPIO_Init+0x136>
        /* Check the Alternate function parameters */
        assert_param(IS_GPIO_AF_INSTANCE(GPIOx));
        assert_param(IS_GPIO_AF(GPIO_Init->Alternate));

        /* Configure Alternate function mapped with the current IO */
        temp = GPIOx->AFR[position >> 3U];
 8001b0e:	69fb      	ldr	r3, [r7, #28]
 8001b10:	08da      	lsrs	r2, r3, #3
 8001b12:	687b      	ldr	r3, [r7, #4]
 8001b14:	3208      	adds	r2, #8
 8001b16:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 8001b1a:	61bb      	str	r3, [r7, #24]
        temp &= ~(0xFU << ((position & 0x07U) * 4U));
 8001b1c:	69fb      	ldr	r3, [r7, #28]
 8001b1e:	f003 0307 	and.w	r3, r3, #7
 8001b22:	009b      	lsls	r3, r3, #2
 8001b24:	220f      	movs	r2, #15
 8001b26:	fa02 f303 	lsl.w	r3, r2, r3
 8001b2a:	43db      	mvns	r3, r3
 8001b2c:	69ba      	ldr	r2, [r7, #24]
 8001b2e:	4013      	ands	r3, r2
 8001b30:	61bb      	str	r3, [r7, #24]
        temp |= ((GPIO_Init->Alternate) << ((position & 0x07U) * 4U));
 8001b32:	683b      	ldr	r3, [r7, #0]
 8001b34:	691a      	ldr	r2, [r3, #16]
 8001b36:	69fb      	ldr	r3, [r7, #28]
 8001b38:	f003 0307 	and.w	r3, r3, #7
 8001b3c:	009b      	lsls	r3, r3, #2
 8001b3e:	fa02 f303 	lsl.w	r3, r2, r3
 8001b42:	69ba      	ldr	r2, [r7, #24]
 8001b44:	4313      	orrs	r3, r2
 8001b46:	61bb      	str	r3, [r7, #24]
        GPIOx->AFR[position >> 3U] = temp;
 8001b48:	69fb      	ldr	r3, [r7, #28]
 8001b4a:	08da      	lsrs	r2, r3, #3
 8001b4c:	687b      	ldr	r3, [r7, #4]
 8001b4e:	3208      	adds	r2, #8
 8001b50:	69b9      	ldr	r1, [r7, #24]
 8001b52:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
      }

      /* Configure IO Direction mode (Input, Output, Alternate or Analog) */
      temp = GPIOx->MODER;
 8001b56:	687b      	ldr	r3, [r7, #4]
 8001b58:	681b      	ldr	r3, [r3, #0]
 8001b5a:	61bb      	str	r3, [r7, #24]
      temp &= ~(GPIO_MODER_MODE0 << (position * 2U));
 8001b5c:	69fb      	ldr	r3, [r7, #28]
 8001b5e:	005b      	lsls	r3, r3, #1
 8001b60:	2203      	movs	r2, #3
 8001b62:	fa02 f303 	lsl.w	r3, r2, r3
 8001b66:	43db      	mvns	r3, r3
 8001b68:	69ba      	ldr	r2, [r7, #24]
 8001b6a:	4013      	ands	r3, r2
 8001b6c:	61bb      	str	r3, [r7, #24]
      temp |= ((GPIO_Init->Mode & GPIO_MODE) << (position * 2U));
 8001b6e:	683b      	ldr	r3, [r7, #0]
 8001b70:	685b      	ldr	r3, [r3, #4]
 8001b72:	f003 0203 	and.w	r2, r3, #3
 8001b76:	69fb      	ldr	r3, [r7, #28]
 8001b78:	005b      	lsls	r3, r3, #1
 8001b7a:	fa02 f303 	lsl.w	r3, r2, r3
 8001b7e:	69ba      	ldr	r2, [r7, #24]
 8001b80:	4313      	orrs	r3, r2
 8001b82:	61bb      	str	r3, [r7, #24]
      GPIOx->MODER = temp;
 8001b84:	687b      	ldr	r3, [r7, #4]
 8001b86:	69ba      	ldr	r2, [r7, #24]
 8001b88:	601a      	str	r2, [r3, #0]

      /*--------------------- EXTI Mode Configuration ------------------------*/
      /* Configure the External Interrupt or event for the current IO */
      if ((GPIO_Init->Mode & EXTI_MODE) != 0x00U)
 8001b8a:	683b      	ldr	r3, [r7, #0]
 8001b8c:	685b      	ldr	r3, [r3, #4]
 8001b8e:	f403 3340 	and.w	r3, r3, #196608	; 0x30000
 8001b92:	2b00      	cmp	r3, #0
 8001b94:	f000 80e0 	beq.w	8001d58 <HAL_GPIO_Init+0x338>
      {
        /* Enable SYSCFG Clock */
        __HAL_RCC_SYSCFG_CLK_ENABLE();
 8001b98:	4b2f      	ldr	r3, [pc, #188]	; (8001c58 <HAL_GPIO_Init+0x238>)
 8001b9a:	f8d3 30f4 	ldr.w	r3, [r3, #244]	; 0xf4
 8001b9e:	4a2e      	ldr	r2, [pc, #184]	; (8001c58 <HAL_GPIO_Init+0x238>)
 8001ba0:	f043 0302 	orr.w	r3, r3, #2
 8001ba4:	f8c2 30f4 	str.w	r3, [r2, #244]	; 0xf4
 8001ba8:	4b2b      	ldr	r3, [pc, #172]	; (8001c58 <HAL_GPIO_Init+0x238>)
 8001baa:	f8d3 30f4 	ldr.w	r3, [r3, #244]	; 0xf4
 8001bae:	f003 0302 	and.w	r3, r3, #2
 8001bb2:	60fb      	str	r3, [r7, #12]
 8001bb4:	68fb      	ldr	r3, [r7, #12]

        temp = SYSCFG->EXTICR[position >> 2U];
 8001bb6:	4a29      	ldr	r2, [pc, #164]	; (8001c5c <HAL_GPIO_Init+0x23c>)
 8001bb8:	69fb      	ldr	r3, [r7, #28]
 8001bba:	089b      	lsrs	r3, r3, #2
 8001bbc:	3302      	adds	r3, #2
 8001bbe:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 8001bc2:	61bb      	str	r3, [r7, #24]
        temp &= ~(0x0FUL << (4U * (position & 0x03U)));
 8001bc4:	69fb      	ldr	r3, [r7, #28]
 8001bc6:	f003 0303 	and.w	r3, r3, #3
 8001bca:	009b      	lsls	r3, r3, #2
 8001bcc:	220f      	movs	r2, #15
 8001bce:	fa02 f303 	lsl.w	r3, r2, r3
 8001bd2:	43db      	mvns	r3, r3
 8001bd4:	69ba      	ldr	r2, [r7, #24]
 8001bd6:	4013      	ands	r3, r2
 8001bd8:	61bb      	str	r3, [r7, #24]
        temp |= (GPIO_GET_INDEX(GPIOx) << (4U * (position & 0x03U)));
 8001bda:	687b      	ldr	r3, [r7, #4]
 8001bdc:	4a20      	ldr	r2, [pc, #128]	; (8001c60 <HAL_GPIO_Init+0x240>)
 8001bde:	4293      	cmp	r3, r2
 8001be0:	d052      	beq.n	8001c88 <HAL_GPIO_Init+0x268>
 8001be2:	687b      	ldr	r3, [r7, #4]
 8001be4:	4a1f      	ldr	r2, [pc, #124]	; (8001c64 <HAL_GPIO_Init+0x244>)
 8001be6:	4293      	cmp	r3, r2
 8001be8:	d031      	beq.n	8001c4e <HAL_GPIO_Init+0x22e>
 8001bea:	687b      	ldr	r3, [r7, #4]
 8001bec:	4a1e      	ldr	r2, [pc, #120]	; (8001c68 <HAL_GPIO_Init+0x248>)
 8001bee:	4293      	cmp	r3, r2
 8001bf0:	d02b      	beq.n	8001c4a <HAL_GPIO_Init+0x22a>
 8001bf2:	687b      	ldr	r3, [r7, #4]
 8001bf4:	4a1d      	ldr	r2, [pc, #116]	; (8001c6c <HAL_GPIO_Init+0x24c>)
 8001bf6:	4293      	cmp	r3, r2
 8001bf8:	d025      	beq.n	8001c46 <HAL_GPIO_Init+0x226>
 8001bfa:	687b      	ldr	r3, [r7, #4]
 8001bfc:	4a1c      	ldr	r2, [pc, #112]	; (8001c70 <HAL_GPIO_Init+0x250>)
 8001bfe:	4293      	cmp	r3, r2
 8001c00:	d01f      	beq.n	8001c42 <HAL_GPIO_Init+0x222>
 8001c02:	687b      	ldr	r3, [r7, #4]
 8001c04:	4a1b      	ldr	r2, [pc, #108]	; (8001c74 <HAL_GPIO_Init+0x254>)
 8001c06:	4293      	cmp	r3, r2
 8001c08:	d019      	beq.n	8001c3e <HAL_GPIO_Init+0x21e>
 8001c0a:	687b      	ldr	r3, [r7, #4]
 8001c0c:	4a1a      	ldr	r2, [pc, #104]	; (8001c78 <HAL_GPIO_Init+0x258>)
 8001c0e:	4293      	cmp	r3, r2
 8001c10:	d013      	beq.n	8001c3a <HAL_GPIO_Init+0x21a>
 8001c12:	687b      	ldr	r3, [r7, #4]
 8001c14:	4a19      	ldr	r2, [pc, #100]	; (8001c7c <HAL_GPIO_Init+0x25c>)
 8001c16:	4293      	cmp	r3, r2
 8001c18:	d00d      	beq.n	8001c36 <HAL_GPIO_Init+0x216>
 8001c1a:	687b      	ldr	r3, [r7, #4]
 8001c1c:	4a18      	ldr	r2, [pc, #96]	; (8001c80 <HAL_GPIO_Init+0x260>)
 8001c1e:	4293      	cmp	r3, r2
 8001c20:	d007      	beq.n	8001c32 <HAL_GPIO_Init+0x212>
 8001c22:	687b      	ldr	r3, [r7, #4]
 8001c24:	4a17      	ldr	r2, [pc, #92]	; (8001c84 <HAL_GPIO_Init+0x264>)
 8001c26:	4293      	cmp	r3, r2
 8001c28:	d101      	bne.n	8001c2e <HAL_GPIO_Init+0x20e>
 8001c2a:	2309      	movs	r3, #9
 8001c2c:	e02d      	b.n	8001c8a <HAL_GPIO_Init+0x26a>
 8001c2e:	230a      	movs	r3, #10
 8001c30:	e02b      	b.n	8001c8a <HAL_GPIO_Init+0x26a>
 8001c32:	2308      	movs	r3, #8
 8001c34:	e029      	b.n	8001c8a <HAL_GPIO_Init+0x26a>
 8001c36:	2307      	movs	r3, #7
 8001c38:	e027      	b.n	8001c8a <HAL_GPIO_Init+0x26a>
 8001c3a:	2306      	movs	r3, #6
 8001c3c:	e025      	b.n	8001c8a <HAL_GPIO_Init+0x26a>
 8001c3e:	2305      	movs	r3, #5
 8001c40:	e023      	b.n	8001c8a <HAL_GPIO_Init+0x26a>
 8001c42:	2304      	movs	r3, #4
 8001c44:	e021      	b.n	8001c8a <HAL_GPIO_Init+0x26a>
 8001c46:	2303      	movs	r3, #3
 8001c48:	e01f      	b.n	8001c8a <HAL_GPIO_Init+0x26a>
 8001c4a:	2302      	movs	r3, #2
 8001c4c:	e01d      	b.n	8001c8a <HAL_GPIO_Init+0x26a>
 8001c4e:	2301      	movs	r3, #1
 8001c50:	e01b      	b.n	8001c8a <HAL_GPIO_Init+0x26a>
 8001c52:	bf00      	nop
 8001c54:	58000080 	.word	0x58000080
 8001c58:	58024400 	.word	0x58024400
 8001c5c:	58000400 	.word	0x58000400
 8001c60:	58020000 	.word	0x58020000
 8001c64:	58020400 	.word	0x58020400
 8001c68:	58020800 	.word	0x58020800
 8001c6c:	58020c00 	.word	0x58020c00
 8001c70:	58021000 	.word	0x58021000
 8001c74:	58021400 	.word	0x58021400
 8001c78:	58021800 	.word	0x58021800
 8001c7c:	58021c00 	.word	0x58021c00
 8001c80:	58022000 	.word	0x58022000
 8001c84:	58022400 	.word	0x58022400
 8001c88:	2300      	movs	r3, #0
 8001c8a:	69fa      	ldr	r2, [r7, #28]
 8001c8c:	f002 0203 	and.w	r2, r2, #3
 8001c90:	0092      	lsls	r2, r2, #2
 8001c92:	4093      	lsls	r3, r2
 8001c94:	69ba      	ldr	r2, [r7, #24]
 8001c96:	4313      	orrs	r3, r2
 8001c98:	61bb      	str	r3, [r7, #24]
        SYSCFG->EXTICR[position >> 2U] = temp;
 8001c9a:	4938      	ldr	r1, [pc, #224]	; (8001d7c <HAL_GPIO_Init+0x35c>)
 8001c9c:	69fb      	ldr	r3, [r7, #28]
 8001c9e:	089b      	lsrs	r3, r3, #2
 8001ca0:	3302      	adds	r3, #2
 8001ca2:	69ba      	ldr	r2, [r7, #24]
 8001ca4:	f841 2023 	str.w	r2, [r1, r3, lsl #2]

        /* Clear Rising Falling edge configuration */
        temp = EXTI->RTSR1;
 8001ca8:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 8001cac:	681b      	ldr	r3, [r3, #0]
 8001cae:	61bb      	str	r3, [r7, #24]
        temp &= ~(iocurrent);
 8001cb0:	693b      	ldr	r3, [r7, #16]
 8001cb2:	43db      	mvns	r3, r3
 8001cb4:	69ba      	ldr	r2, [r7, #24]
 8001cb6:	4013      	ands	r3, r2
 8001cb8:	61bb      	str	r3, [r7, #24]
        if ((GPIO_Init->Mode & TRIGGER_RISING) != 0x00U)
 8001cba:	683b      	ldr	r3, [r7, #0]
 8001cbc:	685b      	ldr	r3, [r3, #4]
 8001cbe:	f403 1380 	and.w	r3, r3, #1048576	; 0x100000
 8001cc2:	2b00      	cmp	r3, #0
 8001cc4:	d003      	beq.n	8001cce <HAL_GPIO_Init+0x2ae>
        {
          temp |= iocurrent;
 8001cc6:	69ba      	ldr	r2, [r7, #24]
 8001cc8:	693b      	ldr	r3, [r7, #16]
 8001cca:	4313      	orrs	r3, r2
 8001ccc:	61bb      	str	r3, [r7, #24]
        }
        EXTI->RTSR1 = temp;
 8001cce:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
 8001cd2:	69bb      	ldr	r3, [r7, #24]
 8001cd4:	6013      	str	r3, [r2, #0]

        temp = EXTI->FTSR1;
 8001cd6:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 8001cda:	685b      	ldr	r3, [r3, #4]
 8001cdc:	61bb      	str	r3, [r7, #24]
        temp &= ~(iocurrent);
 8001cde:	693b      	ldr	r3, [r7, #16]
 8001ce0:	43db      	mvns	r3, r3
 8001ce2:	69ba      	ldr	r2, [r7, #24]
 8001ce4:	4013      	ands	r3, r2
 8001ce6:	61bb      	str	r3, [r7, #24]
        if ((GPIO_Init->Mode & TRIGGER_FALLING) != 0x00U)
 8001ce8:	683b      	ldr	r3, [r7, #0]
 8001cea:	685b      	ldr	r3, [r3, #4]
 8001cec:	f403 1300 	and.w	r3, r3, #2097152	; 0x200000
 8001cf0:	2b00      	cmp	r3, #0
 8001cf2:	d003      	beq.n	8001cfc <HAL_GPIO_Init+0x2dc>
        {
          temp |= iocurrent;
 8001cf4:	69ba      	ldr	r2, [r7, #24]
 8001cf6:	693b      	ldr	r3, [r7, #16]
 8001cf8:	4313      	orrs	r3, r2
 8001cfa:	61bb      	str	r3, [r7, #24]
        }
        EXTI->FTSR1 = temp;
 8001cfc:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
 8001d00:	69bb      	ldr	r3, [r7, #24]
 8001d02:	6053      	str	r3, [r2, #4]

        temp = EXTI_CurrentCPU->EMR1;
 8001d04:	697b      	ldr	r3, [r7, #20]
 8001d06:	685b      	ldr	r3, [r3, #4]
 8001d08:	61bb      	str	r3, [r7, #24]
        temp &= ~(iocurrent);
 8001d0a:	693b      	ldr	r3, [r7, #16]
 8001d0c:	43db      	mvns	r3, r3
 8001d0e:	69ba      	ldr	r2, [r7, #24]
 8001d10:	4013      	ands	r3, r2
 8001d12:	61bb      	str	r3, [r7, #24]
        if ((GPIO_Init->Mode & EXTI_EVT) != 0x00U)
 8001d14:	683b      	ldr	r3, [r7, #0]
 8001d16:	685b      	ldr	r3, [r3, #4]
 8001d18:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
 8001d1c:	2b00      	cmp	r3, #0
 8001d1e:	d003      	beq.n	8001d28 <HAL_GPIO_Init+0x308>
        {
          temp |= iocurrent;
 8001d20:	69ba      	ldr	r2, [r7, #24]
 8001d22:	693b      	ldr	r3, [r7, #16]
 8001d24:	4313      	orrs	r3, r2
 8001d26:	61bb      	str	r3, [r7, #24]
        }
        EXTI_CurrentCPU->EMR1 = temp;
 8001d28:	697b      	ldr	r3, [r7, #20]
 8001d2a:	69ba      	ldr	r2, [r7, #24]
 8001d2c:	605a      	str	r2, [r3, #4]

        /* Clear EXTI line configuration */
        temp = EXTI_CurrentCPU->IMR1;
 8001d2e:	697b      	ldr	r3, [r7, #20]
 8001d30:	681b      	ldr	r3, [r3, #0]
 8001d32:	61bb      	str	r3, [r7, #24]
        temp &= ~(iocurrent);
 8001d34:	693b      	ldr	r3, [r7, #16]
 8001d36:	43db      	mvns	r3, r3
 8001d38:	69ba      	ldr	r2, [r7, #24]
 8001d3a:	4013      	ands	r3, r2
 8001d3c:	61bb      	str	r3, [r7, #24]
        if ((GPIO_Init->Mode & EXTI_IT) != 0x00U)
 8001d3e:	683b      	ldr	r3, [r7, #0]
 8001d40:	685b      	ldr	r3, [r3, #4]
 8001d42:	f403 3380 	and.w	r3, r3, #65536	; 0x10000
 8001d46:	2b00      	cmp	r3, #0
 8001d48:	d003      	beq.n	8001d52 <HAL_GPIO_Init+0x332>
        {
          temp |= iocurrent;
 8001d4a:	69ba      	ldr	r2, [r7, #24]
 8001d4c:	693b      	ldr	r3, [r7, #16]
 8001d4e:	4313      	orrs	r3, r2
 8001d50:	61bb      	str	r3, [r7, #24]
        }
        EXTI_CurrentCPU->IMR1 = temp;
 8001d52:	697b      	ldr	r3, [r7, #20]
 8001d54:	69ba      	ldr	r2, [r7, #24]
 8001d56:	601a      	str	r2, [r3, #0]
      }
    }

    position++;
 8001d58:	69fb      	ldr	r3, [r7, #28]
 8001d5a:	3301      	adds	r3, #1
 8001d5c:	61fb      	str	r3, [r7, #28]
  while (((GPIO_Init->Pin) >> position) != 0x00U)
 8001d5e:	683b      	ldr	r3, [r7, #0]
 8001d60:	681a      	ldr	r2, [r3, #0]
 8001d62:	69fb      	ldr	r3, [r7, #28]
 8001d64:	fa22 f303 	lsr.w	r3, r2, r3
 8001d68:	2b00      	cmp	r3, #0
 8001d6a:	f47f ae63 	bne.w	8001a34 <HAL_GPIO_Init+0x14>
  }
}
 8001d6e:	bf00      	nop
 8001d70:	bf00      	nop
 8001d72:	3724      	adds	r7, #36	; 0x24
 8001d74:	46bd      	mov	sp, r7
 8001d76:	f85d 7b04 	ldr.w	r7, [sp], #4
 8001d7a:	4770      	bx	lr
 8001d7c:	58000400 	.word	0x58000400

08001d80 <HAL_GPIO_ReadPin>:
  * @param  GPIO_Pin: specifies the port bit to read.
  *         This parameter can be GPIO_PIN_x where x can be (0..15).
  * @retval The input port pin value.
  */
GPIO_PinState HAL_GPIO_ReadPin(GPIO_TypeDef *GPIOx, uint16_t GPIO_Pin)
{
 8001d80:	b480      	push	{r7}
 8001d82:	b085      	sub	sp, #20
 8001d84:	af00      	add	r7, sp, #0
 8001d86:	6078      	str	r0, [r7, #4]
 8001d88:	460b      	mov	r3, r1
 8001d8a:	807b      	strh	r3, [r7, #2]
  GPIO_PinState bitstatus;

  /* Check the parameters */
  assert_param(IS_GPIO_PIN(GPIO_Pin));

  if ((GPIOx->IDR & GPIO_Pin) != 0x00U)
 8001d8c:	687b      	ldr	r3, [r7, #4]
 8001d8e:	691a      	ldr	r2, [r3, #16]
 8001d90:	887b      	ldrh	r3, [r7, #2]
 8001d92:	4013      	ands	r3, r2
 8001d94:	2b00      	cmp	r3, #0
 8001d96:	d002      	beq.n	8001d9e <HAL_GPIO_ReadPin+0x1e>
  {
    bitstatus = GPIO_PIN_SET;
 8001d98:	2301      	movs	r3, #1
 8001d9a:	73fb      	strb	r3, [r7, #15]
 8001d9c:	e001      	b.n	8001da2 <HAL_GPIO_ReadPin+0x22>
  }
  else
  {
    bitstatus = GPIO_PIN_RESET;
 8001d9e:	2300      	movs	r3, #0
 8001da0:	73fb      	strb	r3, [r7, #15]
  }
  return bitstatus;
 8001da2:	7bfb      	ldrb	r3, [r7, #15]
}
 8001da4:	4618      	mov	r0, r3
 8001da6:	3714      	adds	r7, #20
 8001da8:	46bd      	mov	sp, r7
 8001daa:	f85d 7b04 	ldr.w	r7, [sp], #4
 8001dae:	4770      	bx	lr

08001db0 <HAL_GPIO_WritePin>:
  *            @arg GPIO_PIN_RESET: to clear the port pin
  *            @arg GPIO_PIN_SET: to set the port pin
  * @retval None
  */
void HAL_GPIO_WritePin(GPIO_TypeDef *GPIOx, uint16_t GPIO_Pin, GPIO_PinState PinState)
{
 8001db0:	b480      	push	{r7}
 8001db2:	b083      	sub	sp, #12
 8001db4:	af00      	add	r7, sp, #0
 8001db6:	6078      	str	r0, [r7, #4]
 8001db8:	460b      	mov	r3, r1
 8001dba:	807b      	strh	r3, [r7, #2]
 8001dbc:	4613      	mov	r3, r2
 8001dbe:	707b      	strb	r3, [r7, #1]
  /* Check the parameters */
  assert_param(IS_GPIO_PIN(GPIO_Pin));
  assert_param(IS_GPIO_PIN_ACTION(PinState));

  if (PinState != GPIO_PIN_RESET)
 8001dc0:	787b      	ldrb	r3, [r7, #1]
 8001dc2:	2b00      	cmp	r3, #0
 8001dc4:	d003      	beq.n	8001dce <HAL_GPIO_WritePin+0x1e>
  {
    GPIOx->BSRR = GPIO_Pin;
 8001dc6:	887a      	ldrh	r2, [r7, #2]
 8001dc8:	687b      	ldr	r3, [r7, #4]
 8001dca:	619a      	str	r2, [r3, #24]
  }
  else
  {
    GPIOx->BSRR = (uint32_t)GPIO_Pin << GPIO_NUMBER;
  }
}
 8001dcc:	e003      	b.n	8001dd6 <HAL_GPIO_WritePin+0x26>
    GPIOx->BSRR = (uint32_t)GPIO_Pin << GPIO_NUMBER;
 8001dce:	887b      	ldrh	r3, [r7, #2]
 8001dd0:	041a      	lsls	r2, r3, #16
 8001dd2:	687b      	ldr	r3, [r7, #4]
 8001dd4:	619a      	str	r2, [r3, #24]
}
 8001dd6:	bf00      	nop
 8001dd8:	370c      	adds	r7, #12
 8001dda:	46bd      	mov	sp, r7
 8001ddc:	f85d 7b04 	ldr.w	r7, [sp], #4
 8001de0:	4770      	bx	lr

08001de2 <HAL_GPIO_EXTI_IRQHandler>:
  * @brief  Handle EXTI interrupt request.
  * @param  GPIO_Pin: Specifies the port pin connected to corresponding EXTI line.
  * @retval None
  */
void HAL_GPIO_EXTI_IRQHandler(uint16_t GPIO_Pin)
{
 8001de2:	b580      	push	{r7, lr}
 8001de4:	b082      	sub	sp, #8
 8001de6:	af00      	add	r7, sp, #0
 8001de8:	4603      	mov	r3, r0
 8001dea:	80fb      	strh	r3, [r7, #6]
    __HAL_GPIO_EXTID2_CLEAR_IT(GPIO_Pin);
    HAL_GPIO_EXTI_Callback(GPIO_Pin);
  }
#else
  /* EXTI line interrupt detected */
  if (__HAL_GPIO_EXTI_GET_IT(GPIO_Pin) != 0x00U)
 8001dec:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 8001df0:	f8d3 2088 	ldr.w	r2, [r3, #136]	; 0x88
 8001df4:	88fb      	ldrh	r3, [r7, #6]
 8001df6:	4013      	ands	r3, r2
 8001df8:	2b00      	cmp	r3, #0
 8001dfa:	d008      	beq.n	8001e0e <HAL_GPIO_EXTI_IRQHandler+0x2c>
  {
    __HAL_GPIO_EXTI_CLEAR_IT(GPIO_Pin);
 8001dfc:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
 8001e00:	88fb      	ldrh	r3, [r7, #6]
 8001e02:	f8c2 3088 	str.w	r3, [r2, #136]	; 0x88
    HAL_GPIO_EXTI_Callback(GPIO_Pin);
 8001e06:	88fb      	ldrh	r3, [r7, #6]
 8001e08:	4618      	mov	r0, r3
 8001e0a:	f01d f899 	bl	801ef40 <HAL_GPIO_EXTI_Callback>
  }
#endif
}
 8001e0e:	bf00      	nop
 8001e10:	3708      	adds	r7, #8
 8001e12:	46bd      	mov	sp, r7
 8001e14:	bd80      	pop	{r7, pc}
	...

08001e18 <HAL_HSEM_FastTake>:
  * @brief  Fast Take a semaphore with 1 Step mode.
  * @param  SemID: semaphore ID from 0 to 31
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_HSEM_FastTake(uint32_t SemID)
{
 8001e18:	b480      	push	{r7}
 8001e1a:	b083      	sub	sp, #12
 8001e1c:	af00      	add	r7, sp, #0
 8001e1e:	6078      	str	r0, [r7, #4]
    /*take success when MasterID match and take bit set*/
    return HAL_OK;
  }
#else  
  /* Read the RLR register to take the semaphore */
  if (HSEM->RLR[SemID] == (HSEM_CR_COREID_CURRENT | HSEM_RLR_LOCK))
 8001e20:	4a08      	ldr	r2, [pc, #32]	; (8001e44 <HAL_HSEM_FastTake+0x2c>)
 8001e22:	687b      	ldr	r3, [r7, #4]
 8001e24:	3320      	adds	r3, #32
 8001e26:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 8001e2a:	4a07      	ldr	r2, [pc, #28]	; (8001e48 <HAL_HSEM_FastTake+0x30>)
 8001e2c:	4293      	cmp	r3, r2
 8001e2e:	d101      	bne.n	8001e34 <HAL_HSEM_FastTake+0x1c>
  {
    /*take success when MasterID match and take bit set*/
    return HAL_OK;
 8001e30:	2300      	movs	r3, #0
 8001e32:	e000      	b.n	8001e36 <HAL_HSEM_FastTake+0x1e>
  }
#endif

  /* Semaphore take fails */
  return HAL_ERROR;
 8001e34:	2301      	movs	r3, #1
}
 8001e36:	4618      	mov	r0, r3
 8001e38:	370c      	adds	r7, #12
 8001e3a:	46bd      	mov	sp, r7
 8001e3c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8001e40:	4770      	bx	lr
 8001e42:	bf00      	nop
 8001e44:	58026400 	.word	0x58026400
 8001e48:	80000300 	.word	0x80000300

08001e4c <HAL_HSEM_Release>:
  * @param  SemID: semaphore ID from 0 to 31
  * @param  ProcessID: Process ID from 0 to 255
  * @retval None
  */
void  HAL_HSEM_Release(uint32_t SemID, uint32_t ProcessID)
{
 8001e4c:	b480      	push	{r7}
 8001e4e:	b083      	sub	sp, #12
 8001e50:	af00      	add	r7, sp, #0
 8001e52:	6078      	str	r0, [r7, #4]
 8001e54:	6039      	str	r1, [r7, #0]

  /* Clear the semaphore by writing to the R register : the MasterID , the processID and take bit = 0  */
#if  USE_MULTI_CORE_SHARED_CODE != 0U
  HSEM->R[SemID] = (ProcessID | ((HAL_GetCurrentCPUID() << POSITION_VAL(HSEM_R_MASTERID)) & HSEM_R_MASTERID));
#else
  HSEM->R[SemID] = (ProcessID | HSEM_CR_COREID_CURRENT);
 8001e56:	4906      	ldr	r1, [pc, #24]	; (8001e70 <HAL_HSEM_Release+0x24>)
 8001e58:	683b      	ldr	r3, [r7, #0]
 8001e5a:	f443 7240 	orr.w	r2, r3, #768	; 0x300
 8001e5e:	687b      	ldr	r3, [r7, #4]
 8001e60:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
#endif

}
 8001e64:	bf00      	nop
 8001e66:	370c      	adds	r7, #12
 8001e68:	46bd      	mov	sp, r7
 8001e6a:	f85d 7b04 	ldr.w	r7, [sp], #4
 8001e6e:	4770      	bx	lr
 8001e70:	58026400 	.word	0x58026400

08001e74 <HAL_PWREx_ConfigSupply>:
  *         PWR_SMPS_2V5_SUPPLIES_EXT are used only for lines that supports SMPS
  *         regulator.
  * @retval HAL status.
  */
HAL_StatusTypeDef HAL_PWREx_ConfigSupply (uint32_t SupplySource)
{
 8001e74:	b580      	push	{r7, lr}
 8001e76:	b084      	sub	sp, #16
 8001e78:	af00      	add	r7, sp, #0
 8001e7a:	6078      	str	r0, [r7, #4]

  /* Check if supply source was configured */
#if defined (PWR_FLAG_SCUEN)
  if (__HAL_PWR_GET_FLAG (PWR_FLAG_SCUEN) == 0U)
#else
  if ((PWR->CR3 & (PWR_CR3_SMPSEN | PWR_CR3_LDOEN | PWR_CR3_BYPASS)) != (PWR_CR3_SMPSEN | PWR_CR3_LDOEN))
 8001e7c:	4b29      	ldr	r3, [pc, #164]	; (8001f24 <HAL_PWREx_ConfigSupply+0xb0>)
 8001e7e:	68db      	ldr	r3, [r3, #12]
 8001e80:	f003 0307 	and.w	r3, r3, #7
 8001e84:	2b06      	cmp	r3, #6
 8001e86:	d00a      	beq.n	8001e9e <HAL_PWREx_ConfigSupply+0x2a>
#endif /* defined (PWR_FLAG_SCUEN) */
  {
    /* Check supply configuration */
    if ((PWR->CR3 & PWR_SUPPLY_CONFIG_MASK) != SupplySource)
 8001e88:	4b26      	ldr	r3, [pc, #152]	; (8001f24 <HAL_PWREx_ConfigSupply+0xb0>)
 8001e8a:	68db      	ldr	r3, [r3, #12]
 8001e8c:	f003 033f 	and.w	r3, r3, #63	; 0x3f
 8001e90:	687a      	ldr	r2, [r7, #4]
 8001e92:	429a      	cmp	r2, r3
 8001e94:	d001      	beq.n	8001e9a <HAL_PWREx_ConfigSupply+0x26>
    {
      /* Supply configuration update locked, can't apply a new supply config */
      return HAL_ERROR;
 8001e96:	2301      	movs	r3, #1
 8001e98:	e040      	b.n	8001f1c <HAL_PWREx_ConfigSupply+0xa8>
    else
    {
      /* Supply configuration update locked, but new supply configuration
         matches with old supply configuration : nothing to do
      */
      return HAL_OK;
 8001e9a:	2300      	movs	r3, #0
 8001e9c:	e03e      	b.n	8001f1c <HAL_PWREx_ConfigSupply+0xa8>
    }
  }

  /* Set the power supply configuration */
  MODIFY_REG (PWR->CR3, PWR_SUPPLY_CONFIG_MASK, SupplySource);
 8001e9e:	4b21      	ldr	r3, [pc, #132]	; (8001f24 <HAL_PWREx_ConfigSupply+0xb0>)
 8001ea0:	68db      	ldr	r3, [r3, #12]
 8001ea2:	f023 023f 	bic.w	r2, r3, #63	; 0x3f
 8001ea6:	491f      	ldr	r1, [pc, #124]	; (8001f24 <HAL_PWREx_ConfigSupply+0xb0>)
 8001ea8:	687b      	ldr	r3, [r7, #4]
 8001eaa:	4313      	orrs	r3, r2
 8001eac:	60cb      	str	r3, [r1, #12]

  /* Get tick */
  tickstart = HAL_GetTick ();
 8001eae:	f7ff fc43 	bl	8001738 <HAL_GetTick>
 8001eb2:	60f8      	str	r0, [r7, #12]

  /* Wait till voltage level flag is set */
  while (__HAL_PWR_GET_FLAG (PWR_FLAG_ACTVOSRDY) == 0U)
 8001eb4:	e009      	b.n	8001eca <HAL_PWREx_ConfigSupply+0x56>
  {
    if ((HAL_GetTick () - tickstart) > PWR_FLAG_SETTING_DELAY)
 8001eb6:	f7ff fc3f 	bl	8001738 <HAL_GetTick>
 8001eba:	4602      	mov	r2, r0
 8001ebc:	68fb      	ldr	r3, [r7, #12]
 8001ebe:	1ad3      	subs	r3, r2, r3
 8001ec0:	f5b3 7f7a 	cmp.w	r3, #1000	; 0x3e8
 8001ec4:	d901      	bls.n	8001eca <HAL_PWREx_ConfigSupply+0x56>
    {
      return HAL_ERROR;
 8001ec6:	2301      	movs	r3, #1
 8001ec8:	e028      	b.n	8001f1c <HAL_PWREx_ConfigSupply+0xa8>
  while (__HAL_PWR_GET_FLAG (PWR_FLAG_ACTVOSRDY) == 0U)
 8001eca:	4b16      	ldr	r3, [pc, #88]	; (8001f24 <HAL_PWREx_ConfigSupply+0xb0>)
 8001ecc:	685b      	ldr	r3, [r3, #4]
 8001ece:	f403 5300 	and.w	r3, r3, #8192	; 0x2000
 8001ed2:	f5b3 5f00 	cmp.w	r3, #8192	; 0x2000
 8001ed6:	d1ee      	bne.n	8001eb6 <HAL_PWREx_ConfigSupply+0x42>
    }
  }

#if defined (SMPS)
  /* When the SMPS supplies external circuits verify that SDEXTRDY flag is set */
  if ((SupplySource == PWR_SMPS_1V8_SUPPLIES_EXT_AND_LDO) ||
 8001ed8:	687b      	ldr	r3, [r7, #4]
 8001eda:	2b1e      	cmp	r3, #30
 8001edc:	d008      	beq.n	8001ef0 <HAL_PWREx_ConfigSupply+0x7c>
 8001ede:	687b      	ldr	r3, [r7, #4]
 8001ee0:	2b2e      	cmp	r3, #46	; 0x2e
 8001ee2:	d005      	beq.n	8001ef0 <HAL_PWREx_ConfigSupply+0x7c>
      (SupplySource == PWR_SMPS_2V5_SUPPLIES_EXT_AND_LDO) ||
 8001ee4:	687b      	ldr	r3, [r7, #4]
 8001ee6:	2b1d      	cmp	r3, #29
 8001ee8:	d002      	beq.n	8001ef0 <HAL_PWREx_ConfigSupply+0x7c>
      (SupplySource == PWR_SMPS_1V8_SUPPLIES_EXT)         ||
 8001eea:	687b      	ldr	r3, [r7, #4]
 8001eec:	2b2d      	cmp	r3, #45	; 0x2d
 8001eee:	d114      	bne.n	8001f1a <HAL_PWREx_ConfigSupply+0xa6>
      (SupplySource == PWR_SMPS_2V5_SUPPLIES_EXT))
  {
    /* Get the current tick number */
    tickstart = HAL_GetTick ();
 8001ef0:	f7ff fc22 	bl	8001738 <HAL_GetTick>
 8001ef4:	60f8      	str	r0, [r7, #12]

    /* Wait till SMPS external supply ready flag is set */
    while (__HAL_PWR_GET_FLAG (PWR_FLAG_SMPSEXTRDY) == 0U)
 8001ef6:	e009      	b.n	8001f0c <HAL_PWREx_ConfigSupply+0x98>
    {
      if ((HAL_GetTick () - tickstart) > PWR_FLAG_SETTING_DELAY)
 8001ef8:	f7ff fc1e 	bl	8001738 <HAL_GetTick>
 8001efc:	4602      	mov	r2, r0
 8001efe:	68fb      	ldr	r3, [r7, #12]
 8001f00:	1ad3      	subs	r3, r2, r3
 8001f02:	f5b3 7f7a 	cmp.w	r3, #1000	; 0x3e8
 8001f06:	d901      	bls.n	8001f0c <HAL_PWREx_ConfigSupply+0x98>
      {
        return HAL_ERROR;
 8001f08:	2301      	movs	r3, #1
 8001f0a:	e007      	b.n	8001f1c <HAL_PWREx_ConfigSupply+0xa8>
    while (__HAL_PWR_GET_FLAG (PWR_FLAG_SMPSEXTRDY) == 0U)
 8001f0c:	4b05      	ldr	r3, [pc, #20]	; (8001f24 <HAL_PWREx_ConfigSupply+0xb0>)
 8001f0e:	68db      	ldr	r3, [r3, #12]
 8001f10:	f403 3380 	and.w	r3, r3, #65536	; 0x10000
 8001f14:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
 8001f18:	d1ee      	bne.n	8001ef8 <HAL_PWREx_ConfigSupply+0x84>
      }
    }
  }
#endif /* defined (SMPS) */

  return HAL_OK;
 8001f1a:	2300      	movs	r3, #0
}
 8001f1c:	4618      	mov	r0, r3
 8001f1e:	3710      	adds	r7, #16
 8001f20:	46bd      	mov	sp, r7
 8001f22:	bd80      	pop	{r7, pc}
 8001f24:	58024800 	.word	0x58024800

08001f28 <HAL_RCC_OscConfig>:
  *         supported by this function. User should request a transition to HSE Off
  *         first and then HSE On or HSE Bypass.
  * @retval HAL status
  */
__weak HAL_StatusTypeDef HAL_RCC_OscConfig(RCC_OscInitTypeDef  *RCC_OscInitStruct)
{
 8001f28:	b580      	push	{r7, lr}
 8001f2a:	b08c      	sub	sp, #48	; 0x30
 8001f2c:	af00      	add	r7, sp, #0
 8001f2e:	6078      	str	r0, [r7, #4]
  uint32_t tickstart;
  uint32_t temp1_pllckcfg, temp2_pllckcfg;

    /* Check Null pointer */
  if(RCC_OscInitStruct == NULL)
 8001f30:	687b      	ldr	r3, [r7, #4]
 8001f32:	2b00      	cmp	r3, #0
 8001f34:	d102      	bne.n	8001f3c <HAL_RCC_OscConfig+0x14>
  {
    return HAL_ERROR;
 8001f36:	2301      	movs	r3, #1
 8001f38:	f000 bc1d 	b.w	8002776 <HAL_RCC_OscConfig+0x84e>
  }

  /* Check the parameters */
  assert_param(IS_RCC_OSCILLATORTYPE(RCC_OscInitStruct->OscillatorType));
  /*------------------------------- HSE Configuration ------------------------*/
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSE) == RCC_OSCILLATORTYPE_HSE)
 8001f3c:	687b      	ldr	r3, [r7, #4]
 8001f3e:	681b      	ldr	r3, [r3, #0]
 8001f40:	f003 0301 	and.w	r3, r3, #1
 8001f44:	2b00      	cmp	r3, #0
 8001f46:	f000 8087 	beq.w	8002058 <HAL_RCC_OscConfig+0x130>
  {
    /* Check the parameters */
    assert_param(IS_RCC_HSE(RCC_OscInitStruct->HSEState));

    const uint32_t temp_sysclksrc = __HAL_RCC_GET_SYSCLK_SOURCE();
 8001f4a:	4b99      	ldr	r3, [pc, #612]	; (80021b0 <HAL_RCC_OscConfig+0x288>)
 8001f4c:	691b      	ldr	r3, [r3, #16]
 8001f4e:	f003 0338 	and.w	r3, r3, #56	; 0x38
 8001f52:	62fb      	str	r3, [r7, #44]	; 0x2c
    const uint32_t temp_pllckselr = RCC->PLLCKSELR;
 8001f54:	4b96      	ldr	r3, [pc, #600]	; (80021b0 <HAL_RCC_OscConfig+0x288>)
 8001f56:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8001f58:	62bb      	str	r3, [r7, #40]	; 0x28
    /* When the HSE is used as system clock or clock source for PLL in these cases HSE will not disabled */
    if((temp_sysclksrc == RCC_CFGR_SWS_HSE) || ((temp_sysclksrc == RCC_CFGR_SWS_PLL1) && ((temp_pllckselr & RCC_PLLCKSELR_PLLSRC) == RCC_PLLCKSELR_PLLSRC_HSE)))
 8001f5a:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8001f5c:	2b10      	cmp	r3, #16
 8001f5e:	d007      	beq.n	8001f70 <HAL_RCC_OscConfig+0x48>
 8001f60:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8001f62:	2b18      	cmp	r3, #24
 8001f64:	d110      	bne.n	8001f88 <HAL_RCC_OscConfig+0x60>
 8001f66:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8001f68:	f003 0303 	and.w	r3, r3, #3
 8001f6c:	2b02      	cmp	r3, #2
 8001f6e:	d10b      	bne.n	8001f88 <HAL_RCC_OscConfig+0x60>
    {
      if((__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != 0U) && (RCC_OscInitStruct->HSEState == RCC_HSE_OFF))
 8001f70:	4b8f      	ldr	r3, [pc, #572]	; (80021b0 <HAL_RCC_OscConfig+0x288>)
 8001f72:	681b      	ldr	r3, [r3, #0]
 8001f74:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
 8001f78:	2b00      	cmp	r3, #0
 8001f7a:	d06c      	beq.n	8002056 <HAL_RCC_OscConfig+0x12e>
 8001f7c:	687b      	ldr	r3, [r7, #4]
 8001f7e:	685b      	ldr	r3, [r3, #4]
 8001f80:	2b00      	cmp	r3, #0
 8001f82:	d168      	bne.n	8002056 <HAL_RCC_OscConfig+0x12e>
      {
        return HAL_ERROR;
 8001f84:	2301      	movs	r3, #1
 8001f86:	e3f6      	b.n	8002776 <HAL_RCC_OscConfig+0x84e>
      }
    }
    else
    {
      /* Set the new HSE configuration ---------------------------------------*/
      __HAL_RCC_HSE_CONFIG(RCC_OscInitStruct->HSEState);
 8001f88:	687b      	ldr	r3, [r7, #4]
 8001f8a:	685b      	ldr	r3, [r3, #4]
 8001f8c:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
 8001f90:	d106      	bne.n	8001fa0 <HAL_RCC_OscConfig+0x78>
 8001f92:	4b87      	ldr	r3, [pc, #540]	; (80021b0 <HAL_RCC_OscConfig+0x288>)
 8001f94:	681b      	ldr	r3, [r3, #0]
 8001f96:	4a86      	ldr	r2, [pc, #536]	; (80021b0 <HAL_RCC_OscConfig+0x288>)
 8001f98:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 8001f9c:	6013      	str	r3, [r2, #0]
 8001f9e:	e02e      	b.n	8001ffe <HAL_RCC_OscConfig+0xd6>
 8001fa0:	687b      	ldr	r3, [r7, #4]
 8001fa2:	685b      	ldr	r3, [r3, #4]
 8001fa4:	2b00      	cmp	r3, #0
 8001fa6:	d10c      	bne.n	8001fc2 <HAL_RCC_OscConfig+0x9a>
 8001fa8:	4b81      	ldr	r3, [pc, #516]	; (80021b0 <HAL_RCC_OscConfig+0x288>)
 8001faa:	681b      	ldr	r3, [r3, #0]
 8001fac:	4a80      	ldr	r2, [pc, #512]	; (80021b0 <HAL_RCC_OscConfig+0x288>)
 8001fae:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
 8001fb2:	6013      	str	r3, [r2, #0]
 8001fb4:	4b7e      	ldr	r3, [pc, #504]	; (80021b0 <HAL_RCC_OscConfig+0x288>)
 8001fb6:	681b      	ldr	r3, [r3, #0]
 8001fb8:	4a7d      	ldr	r2, [pc, #500]	; (80021b0 <HAL_RCC_OscConfig+0x288>)
 8001fba:	f423 2380 	bic.w	r3, r3, #262144	; 0x40000
 8001fbe:	6013      	str	r3, [r2, #0]
 8001fc0:	e01d      	b.n	8001ffe <HAL_RCC_OscConfig+0xd6>
 8001fc2:	687b      	ldr	r3, [r7, #4]
 8001fc4:	685b      	ldr	r3, [r3, #4]
 8001fc6:	f5b3 2fa0 	cmp.w	r3, #327680	; 0x50000
 8001fca:	d10c      	bne.n	8001fe6 <HAL_RCC_OscConfig+0xbe>
 8001fcc:	4b78      	ldr	r3, [pc, #480]	; (80021b0 <HAL_RCC_OscConfig+0x288>)
 8001fce:	681b      	ldr	r3, [r3, #0]
 8001fd0:	4a77      	ldr	r2, [pc, #476]	; (80021b0 <HAL_RCC_OscConfig+0x288>)
 8001fd2:	f443 2380 	orr.w	r3, r3, #262144	; 0x40000
 8001fd6:	6013      	str	r3, [r2, #0]
 8001fd8:	4b75      	ldr	r3, [pc, #468]	; (80021b0 <HAL_RCC_OscConfig+0x288>)
 8001fda:	681b      	ldr	r3, [r3, #0]
 8001fdc:	4a74      	ldr	r2, [pc, #464]	; (80021b0 <HAL_RCC_OscConfig+0x288>)
 8001fde:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 8001fe2:	6013      	str	r3, [r2, #0]
 8001fe4:	e00b      	b.n	8001ffe <HAL_RCC_OscConfig+0xd6>
 8001fe6:	4b72      	ldr	r3, [pc, #456]	; (80021b0 <HAL_RCC_OscConfig+0x288>)
 8001fe8:	681b      	ldr	r3, [r3, #0]
 8001fea:	4a71      	ldr	r2, [pc, #452]	; (80021b0 <HAL_RCC_OscConfig+0x288>)
 8001fec:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
 8001ff0:	6013      	str	r3, [r2, #0]
 8001ff2:	4b6f      	ldr	r3, [pc, #444]	; (80021b0 <HAL_RCC_OscConfig+0x288>)
 8001ff4:	681b      	ldr	r3, [r3, #0]
 8001ff6:	4a6e      	ldr	r2, [pc, #440]	; (80021b0 <HAL_RCC_OscConfig+0x288>)
 8001ff8:	f423 2380 	bic.w	r3, r3, #262144	; 0x40000
 8001ffc:	6013      	str	r3, [r2, #0]

      /* Check the HSE State */
      if(RCC_OscInitStruct->HSEState != RCC_HSE_OFF)
 8001ffe:	687b      	ldr	r3, [r7, #4]
 8002000:	685b      	ldr	r3, [r3, #4]
 8002002:	2b00      	cmp	r3, #0
 8002004:	d013      	beq.n	800202e <HAL_RCC_OscConfig+0x106>
      {
        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 8002006:	f7ff fb97 	bl	8001738 <HAL_GetTick>
 800200a:	6278      	str	r0, [r7, #36]	; 0x24

        /* Wait till HSE is ready */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == 0U)
 800200c:	e008      	b.n	8002020 <HAL_RCC_OscConfig+0xf8>
        {
          if((uint32_t) (HAL_GetTick() - tickstart ) > HSE_TIMEOUT_VALUE)
 800200e:	f7ff fb93 	bl	8001738 <HAL_GetTick>
 8002012:	4602      	mov	r2, r0
 8002014:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8002016:	1ad3      	subs	r3, r2, r3
 8002018:	2b64      	cmp	r3, #100	; 0x64
 800201a:	d901      	bls.n	8002020 <HAL_RCC_OscConfig+0xf8>
          {
            return HAL_TIMEOUT;
 800201c:	2303      	movs	r3, #3
 800201e:	e3aa      	b.n	8002776 <HAL_RCC_OscConfig+0x84e>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == 0U)
 8002020:	4b63      	ldr	r3, [pc, #396]	; (80021b0 <HAL_RCC_OscConfig+0x288>)
 8002022:	681b      	ldr	r3, [r3, #0]
 8002024:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
 8002028:	2b00      	cmp	r3, #0
 800202a:	d0f0      	beq.n	800200e <HAL_RCC_OscConfig+0xe6>
 800202c:	e014      	b.n	8002058 <HAL_RCC_OscConfig+0x130>
        }
      }
      else
      {
        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 800202e:	f7ff fb83 	bl	8001738 <HAL_GetTick>
 8002032:	6278      	str	r0, [r7, #36]	; 0x24

        /* Wait till HSE is disabled */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != 0U)
 8002034:	e008      	b.n	8002048 <HAL_RCC_OscConfig+0x120>
        {
          if((uint32_t) (HAL_GetTick() - tickstart ) > HSE_TIMEOUT_VALUE)
 8002036:	f7ff fb7f 	bl	8001738 <HAL_GetTick>
 800203a:	4602      	mov	r2, r0
 800203c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800203e:	1ad3      	subs	r3, r2, r3
 8002040:	2b64      	cmp	r3, #100	; 0x64
 8002042:	d901      	bls.n	8002048 <HAL_RCC_OscConfig+0x120>
          {
            return HAL_TIMEOUT;
 8002044:	2303      	movs	r3, #3
 8002046:	e396      	b.n	8002776 <HAL_RCC_OscConfig+0x84e>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != 0U)
 8002048:	4b59      	ldr	r3, [pc, #356]	; (80021b0 <HAL_RCC_OscConfig+0x288>)
 800204a:	681b      	ldr	r3, [r3, #0]
 800204c:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
 8002050:	2b00      	cmp	r3, #0
 8002052:	d1f0      	bne.n	8002036 <HAL_RCC_OscConfig+0x10e>
 8002054:	e000      	b.n	8002058 <HAL_RCC_OscConfig+0x130>
      if((__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != 0U) && (RCC_OscInitStruct->HSEState == RCC_HSE_OFF))
 8002056:	bf00      	nop
        }
      }
    }
  }
  /*----------------------------- HSI Configuration --------------------------*/
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSI) == RCC_OSCILLATORTYPE_HSI)
 8002058:	687b      	ldr	r3, [r7, #4]
 800205a:	681b      	ldr	r3, [r3, #0]
 800205c:	f003 0302 	and.w	r3, r3, #2
 8002060:	2b00      	cmp	r3, #0
 8002062:	f000 80cb 	beq.w	80021fc <HAL_RCC_OscConfig+0x2d4>
    /* Check the parameters */
    assert_param(IS_RCC_HSI(RCC_OscInitStruct->HSIState));
    assert_param(IS_RCC_HSICALIBRATION_VALUE(RCC_OscInitStruct->HSICalibrationValue));

    /* When the HSI is used as system clock it will not be disabled */
    const uint32_t temp_sysclksrc = __HAL_RCC_GET_SYSCLK_SOURCE();
 8002066:	4b52      	ldr	r3, [pc, #328]	; (80021b0 <HAL_RCC_OscConfig+0x288>)
 8002068:	691b      	ldr	r3, [r3, #16]
 800206a:	f003 0338 	and.w	r3, r3, #56	; 0x38
 800206e:	623b      	str	r3, [r7, #32]
    const uint32_t temp_pllckselr = RCC->PLLCKSELR;
 8002070:	4b4f      	ldr	r3, [pc, #316]	; (80021b0 <HAL_RCC_OscConfig+0x288>)
 8002072:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8002074:	61fb      	str	r3, [r7, #28]
    if((temp_sysclksrc == RCC_CFGR_SWS_HSI) || ((temp_sysclksrc == RCC_CFGR_SWS_PLL1) && ((temp_pllckselr & RCC_PLLCKSELR_PLLSRC) == RCC_PLLCKSELR_PLLSRC_HSI)))
 8002076:	6a3b      	ldr	r3, [r7, #32]
 8002078:	2b00      	cmp	r3, #0
 800207a:	d007      	beq.n	800208c <HAL_RCC_OscConfig+0x164>
 800207c:	6a3b      	ldr	r3, [r7, #32]
 800207e:	2b18      	cmp	r3, #24
 8002080:	d156      	bne.n	8002130 <HAL_RCC_OscConfig+0x208>
 8002082:	69fb      	ldr	r3, [r7, #28]
 8002084:	f003 0303 	and.w	r3, r3, #3
 8002088:	2b00      	cmp	r3, #0
 800208a:	d151      	bne.n	8002130 <HAL_RCC_OscConfig+0x208>
    {
      /* When HSI is used as system clock it will not be disabled */
      if((__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != 0U) && (RCC_OscInitStruct->HSIState == RCC_HSI_OFF))
 800208c:	4b48      	ldr	r3, [pc, #288]	; (80021b0 <HAL_RCC_OscConfig+0x288>)
 800208e:	681b      	ldr	r3, [r3, #0]
 8002090:	f003 0304 	and.w	r3, r3, #4
 8002094:	2b00      	cmp	r3, #0
 8002096:	d005      	beq.n	80020a4 <HAL_RCC_OscConfig+0x17c>
 8002098:	687b      	ldr	r3, [r7, #4]
 800209a:	68db      	ldr	r3, [r3, #12]
 800209c:	2b00      	cmp	r3, #0
 800209e:	d101      	bne.n	80020a4 <HAL_RCC_OscConfig+0x17c>
      {
        return HAL_ERROR;
 80020a0:	2301      	movs	r3, #1
 80020a2:	e368      	b.n	8002776 <HAL_RCC_OscConfig+0x84e>
      }
      /* Otherwise, only HSI division and calibration are allowed */
      else
      {
          /* Enable the Internal High Speed oscillator (HSI, HSIDIV2, HSIDIV4, or HSIDIV8) */
          __HAL_RCC_HSI_CONFIG(RCC_OscInitStruct->HSIState);
 80020a4:	4b42      	ldr	r3, [pc, #264]	; (80021b0 <HAL_RCC_OscConfig+0x288>)
 80020a6:	681b      	ldr	r3, [r3, #0]
 80020a8:	f023 0219 	bic.w	r2, r3, #25
 80020ac:	687b      	ldr	r3, [r7, #4]
 80020ae:	68db      	ldr	r3, [r3, #12]
 80020b0:	493f      	ldr	r1, [pc, #252]	; (80021b0 <HAL_RCC_OscConfig+0x288>)
 80020b2:	4313      	orrs	r3, r2
 80020b4:	600b      	str	r3, [r1, #0]

          /* Get Start Tick*/
          tickstart = HAL_GetTick();
 80020b6:	f7ff fb3f 	bl	8001738 <HAL_GetTick>
 80020ba:	6278      	str	r0, [r7, #36]	; 0x24

          /* Wait till HSI is ready */
          while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == 0U)
 80020bc:	e008      	b.n	80020d0 <HAL_RCC_OscConfig+0x1a8>
          {
            if((uint32_t) (HAL_GetTick() - tickstart ) > HSI_TIMEOUT_VALUE)
 80020be:	f7ff fb3b 	bl	8001738 <HAL_GetTick>
 80020c2:	4602      	mov	r2, r0
 80020c4:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80020c6:	1ad3      	subs	r3, r2, r3
 80020c8:	2b02      	cmp	r3, #2
 80020ca:	d901      	bls.n	80020d0 <HAL_RCC_OscConfig+0x1a8>
            {
              return HAL_TIMEOUT;
 80020cc:	2303      	movs	r3, #3
 80020ce:	e352      	b.n	8002776 <HAL_RCC_OscConfig+0x84e>
          while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == 0U)
 80020d0:	4b37      	ldr	r3, [pc, #220]	; (80021b0 <HAL_RCC_OscConfig+0x288>)
 80020d2:	681b      	ldr	r3, [r3, #0]
 80020d4:	f003 0304 	and.w	r3, r3, #4
 80020d8:	2b00      	cmp	r3, #0
 80020da:	d0f0      	beq.n	80020be <HAL_RCC_OscConfig+0x196>
            }
          }
        /* Adjusts the Internal High Speed oscillator (HSI) calibration value.*/
        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
 80020dc:	f7ff fb38 	bl	8001750 <HAL_GetREVID>
 80020e0:	4603      	mov	r3, r0
 80020e2:	f241 0203 	movw	r2, #4099	; 0x1003
 80020e6:	4293      	cmp	r3, r2
 80020e8:	d817      	bhi.n	800211a <HAL_RCC_OscConfig+0x1f2>
 80020ea:	687b      	ldr	r3, [r7, #4]
 80020ec:	691b      	ldr	r3, [r3, #16]
 80020ee:	2b40      	cmp	r3, #64	; 0x40
 80020f0:	d108      	bne.n	8002104 <HAL_RCC_OscConfig+0x1dc>
 80020f2:	4b2f      	ldr	r3, [pc, #188]	; (80021b0 <HAL_RCC_OscConfig+0x288>)
 80020f4:	685b      	ldr	r3, [r3, #4]
 80020f6:	f423 337c 	bic.w	r3, r3, #258048	; 0x3f000
 80020fa:	4a2d      	ldr	r2, [pc, #180]	; (80021b0 <HAL_RCC_OscConfig+0x288>)
 80020fc:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
 8002100:	6053      	str	r3, [r2, #4]
      if((__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != 0U) && (RCC_OscInitStruct->HSIState == RCC_HSI_OFF))
 8002102:	e07b      	b.n	80021fc <HAL_RCC_OscConfig+0x2d4>
        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
 8002104:	4b2a      	ldr	r3, [pc, #168]	; (80021b0 <HAL_RCC_OscConfig+0x288>)
 8002106:	685b      	ldr	r3, [r3, #4]
 8002108:	f423 327c 	bic.w	r2, r3, #258048	; 0x3f000
 800210c:	687b      	ldr	r3, [r7, #4]
 800210e:	691b      	ldr	r3, [r3, #16]
 8002110:	031b      	lsls	r3, r3, #12
 8002112:	4927      	ldr	r1, [pc, #156]	; (80021b0 <HAL_RCC_OscConfig+0x288>)
 8002114:	4313      	orrs	r3, r2
 8002116:	604b      	str	r3, [r1, #4]
      if((__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != 0U) && (RCC_OscInitStruct->HSIState == RCC_HSI_OFF))
 8002118:	e070      	b.n	80021fc <HAL_RCC_OscConfig+0x2d4>
        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
 800211a:	4b25      	ldr	r3, [pc, #148]	; (80021b0 <HAL_RCC_OscConfig+0x288>)
 800211c:	685b      	ldr	r3, [r3, #4]
 800211e:	f023 42fe 	bic.w	r2, r3, #2130706432	; 0x7f000000
 8002122:	687b      	ldr	r3, [r7, #4]
 8002124:	691b      	ldr	r3, [r3, #16]
 8002126:	061b      	lsls	r3, r3, #24
 8002128:	4921      	ldr	r1, [pc, #132]	; (80021b0 <HAL_RCC_OscConfig+0x288>)
 800212a:	4313      	orrs	r3, r2
 800212c:	604b      	str	r3, [r1, #4]
      if((__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != 0U) && (RCC_OscInitStruct->HSIState == RCC_HSI_OFF))
 800212e:	e065      	b.n	80021fc <HAL_RCC_OscConfig+0x2d4>
    }

    else
    {
      /* Check the HSI State */
      if((RCC_OscInitStruct->HSIState)!= RCC_HSI_OFF)
 8002130:	687b      	ldr	r3, [r7, #4]
 8002132:	68db      	ldr	r3, [r3, #12]
 8002134:	2b00      	cmp	r3, #0
 8002136:	d048      	beq.n	80021ca <HAL_RCC_OscConfig+0x2a2>
      {
     /* Enable the Internal High Speed oscillator (HSI, HSIDIV2,HSIDIV4, or HSIDIV8) */
        __HAL_RCC_HSI_CONFIG(RCC_OscInitStruct->HSIState);
 8002138:	4b1d      	ldr	r3, [pc, #116]	; (80021b0 <HAL_RCC_OscConfig+0x288>)
 800213a:	681b      	ldr	r3, [r3, #0]
 800213c:	f023 0219 	bic.w	r2, r3, #25
 8002140:	687b      	ldr	r3, [r7, #4]
 8002142:	68db      	ldr	r3, [r3, #12]
 8002144:	491a      	ldr	r1, [pc, #104]	; (80021b0 <HAL_RCC_OscConfig+0x288>)
 8002146:	4313      	orrs	r3, r2
 8002148:	600b      	str	r3, [r1, #0]

        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 800214a:	f7ff faf5 	bl	8001738 <HAL_GetTick>
 800214e:	6278      	str	r0, [r7, #36]	; 0x24

        /* Wait till HSI is ready */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == 0U)
 8002150:	e008      	b.n	8002164 <HAL_RCC_OscConfig+0x23c>
        {
          if((HAL_GetTick() - tickstart ) > HSI_TIMEOUT_VALUE)
 8002152:	f7ff faf1 	bl	8001738 <HAL_GetTick>
 8002156:	4602      	mov	r2, r0
 8002158:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800215a:	1ad3      	subs	r3, r2, r3
 800215c:	2b02      	cmp	r3, #2
 800215e:	d901      	bls.n	8002164 <HAL_RCC_OscConfig+0x23c>
          {
            return HAL_TIMEOUT;
 8002160:	2303      	movs	r3, #3
 8002162:	e308      	b.n	8002776 <HAL_RCC_OscConfig+0x84e>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == 0U)
 8002164:	4b12      	ldr	r3, [pc, #72]	; (80021b0 <HAL_RCC_OscConfig+0x288>)
 8002166:	681b      	ldr	r3, [r3, #0]
 8002168:	f003 0304 	and.w	r3, r3, #4
 800216c:	2b00      	cmp	r3, #0
 800216e:	d0f0      	beq.n	8002152 <HAL_RCC_OscConfig+0x22a>
          }
        }

        /* Adjusts the Internal High Speed oscillator (HSI) calibration value.*/
        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
 8002170:	f7ff faee 	bl	8001750 <HAL_GetREVID>
 8002174:	4603      	mov	r3, r0
 8002176:	f241 0203 	movw	r2, #4099	; 0x1003
 800217a:	4293      	cmp	r3, r2
 800217c:	d81a      	bhi.n	80021b4 <HAL_RCC_OscConfig+0x28c>
 800217e:	687b      	ldr	r3, [r7, #4]
 8002180:	691b      	ldr	r3, [r3, #16]
 8002182:	2b40      	cmp	r3, #64	; 0x40
 8002184:	d108      	bne.n	8002198 <HAL_RCC_OscConfig+0x270>
 8002186:	4b0a      	ldr	r3, [pc, #40]	; (80021b0 <HAL_RCC_OscConfig+0x288>)
 8002188:	685b      	ldr	r3, [r3, #4]
 800218a:	f423 337c 	bic.w	r3, r3, #258048	; 0x3f000
 800218e:	4a08      	ldr	r2, [pc, #32]	; (80021b0 <HAL_RCC_OscConfig+0x288>)
 8002190:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
 8002194:	6053      	str	r3, [r2, #4]
 8002196:	e031      	b.n	80021fc <HAL_RCC_OscConfig+0x2d4>
 8002198:	4b05      	ldr	r3, [pc, #20]	; (80021b0 <HAL_RCC_OscConfig+0x288>)
 800219a:	685b      	ldr	r3, [r3, #4]
 800219c:	f423 327c 	bic.w	r2, r3, #258048	; 0x3f000
 80021a0:	687b      	ldr	r3, [r7, #4]
 80021a2:	691b      	ldr	r3, [r3, #16]
 80021a4:	031b      	lsls	r3, r3, #12
 80021a6:	4902      	ldr	r1, [pc, #8]	; (80021b0 <HAL_RCC_OscConfig+0x288>)
 80021a8:	4313      	orrs	r3, r2
 80021aa:	604b      	str	r3, [r1, #4]
 80021ac:	e026      	b.n	80021fc <HAL_RCC_OscConfig+0x2d4>
 80021ae:	bf00      	nop
 80021b0:	58024400 	.word	0x58024400
 80021b4:	4b9a      	ldr	r3, [pc, #616]	; (8002420 <HAL_RCC_OscConfig+0x4f8>)
 80021b6:	685b      	ldr	r3, [r3, #4]
 80021b8:	f023 42fe 	bic.w	r2, r3, #2130706432	; 0x7f000000
 80021bc:	687b      	ldr	r3, [r7, #4]
 80021be:	691b      	ldr	r3, [r3, #16]
 80021c0:	061b      	lsls	r3, r3, #24
 80021c2:	4997      	ldr	r1, [pc, #604]	; (8002420 <HAL_RCC_OscConfig+0x4f8>)
 80021c4:	4313      	orrs	r3, r2
 80021c6:	604b      	str	r3, [r1, #4]
 80021c8:	e018      	b.n	80021fc <HAL_RCC_OscConfig+0x2d4>
      }
      else
      {
        /* Disable the Internal High Speed oscillator (HSI). */
        __HAL_RCC_HSI_DISABLE();
 80021ca:	4b95      	ldr	r3, [pc, #596]	; (8002420 <HAL_RCC_OscConfig+0x4f8>)
 80021cc:	681b      	ldr	r3, [r3, #0]
 80021ce:	4a94      	ldr	r2, [pc, #592]	; (8002420 <HAL_RCC_OscConfig+0x4f8>)
 80021d0:	f023 0301 	bic.w	r3, r3, #1
 80021d4:	6013      	str	r3, [r2, #0]

        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 80021d6:	f7ff faaf 	bl	8001738 <HAL_GetTick>
 80021da:	6278      	str	r0, [r7, #36]	; 0x24

        /* Wait till HSI is disabled */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != 0U)
 80021dc:	e008      	b.n	80021f0 <HAL_RCC_OscConfig+0x2c8>
        {
          if((HAL_GetTick() - tickstart ) > HSI_TIMEOUT_VALUE)
 80021de:	f7ff faab 	bl	8001738 <HAL_GetTick>
 80021e2:	4602      	mov	r2, r0
 80021e4:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80021e6:	1ad3      	subs	r3, r2, r3
 80021e8:	2b02      	cmp	r3, #2
 80021ea:	d901      	bls.n	80021f0 <HAL_RCC_OscConfig+0x2c8>
          {
            return HAL_TIMEOUT;
 80021ec:	2303      	movs	r3, #3
 80021ee:	e2c2      	b.n	8002776 <HAL_RCC_OscConfig+0x84e>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != 0U)
 80021f0:	4b8b      	ldr	r3, [pc, #556]	; (8002420 <HAL_RCC_OscConfig+0x4f8>)
 80021f2:	681b      	ldr	r3, [r3, #0]
 80021f4:	f003 0304 	and.w	r3, r3, #4
 80021f8:	2b00      	cmp	r3, #0
 80021fa:	d1f0      	bne.n	80021de <HAL_RCC_OscConfig+0x2b6>
        }
      }
    }
  }
  /*----------------------------- CSI Configuration --------------------------*/
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_CSI) == RCC_OSCILLATORTYPE_CSI)
 80021fc:	687b      	ldr	r3, [r7, #4]
 80021fe:	681b      	ldr	r3, [r3, #0]
 8002200:	f003 0310 	and.w	r3, r3, #16
 8002204:	2b00      	cmp	r3, #0
 8002206:	f000 80a9 	beq.w	800235c <HAL_RCC_OscConfig+0x434>
    /* Check the parameters */
    assert_param(IS_RCC_CSI(RCC_OscInitStruct->CSIState));
    assert_param(IS_RCC_CSICALIBRATION_VALUE(RCC_OscInitStruct->CSICalibrationValue));

    /* When the CSI is used as system clock it will not disabled */
    const uint32_t temp_sysclksrc = __HAL_RCC_GET_SYSCLK_SOURCE();
 800220a:	4b85      	ldr	r3, [pc, #532]	; (8002420 <HAL_RCC_OscConfig+0x4f8>)
 800220c:	691b      	ldr	r3, [r3, #16]
 800220e:	f003 0338 	and.w	r3, r3, #56	; 0x38
 8002212:	61bb      	str	r3, [r7, #24]
    const uint32_t temp_pllckselr = RCC->PLLCKSELR;
 8002214:	4b82      	ldr	r3, [pc, #520]	; (8002420 <HAL_RCC_OscConfig+0x4f8>)
 8002216:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8002218:	617b      	str	r3, [r7, #20]
    if((temp_sysclksrc == RCC_CFGR_SWS_CSI) || ((temp_sysclksrc == RCC_CFGR_SWS_PLL1) && ((temp_pllckselr & RCC_PLLCKSELR_PLLSRC) == RCC_PLLCKSELR_PLLSRC_CSI)))
 800221a:	69bb      	ldr	r3, [r7, #24]
 800221c:	2b08      	cmp	r3, #8
 800221e:	d007      	beq.n	8002230 <HAL_RCC_OscConfig+0x308>
 8002220:	69bb      	ldr	r3, [r7, #24]
 8002222:	2b18      	cmp	r3, #24
 8002224:	d13a      	bne.n	800229c <HAL_RCC_OscConfig+0x374>
 8002226:	697b      	ldr	r3, [r7, #20]
 8002228:	f003 0303 	and.w	r3, r3, #3
 800222c:	2b01      	cmp	r3, #1
 800222e:	d135      	bne.n	800229c <HAL_RCC_OscConfig+0x374>
    {
      /* When CSI is used as system clock it will not disabled */
      if((__HAL_RCC_GET_FLAG(RCC_FLAG_CSIRDY) != 0U) && (RCC_OscInitStruct->CSIState != RCC_CSI_ON))
 8002230:	4b7b      	ldr	r3, [pc, #492]	; (8002420 <HAL_RCC_OscConfig+0x4f8>)
 8002232:	681b      	ldr	r3, [r3, #0]
 8002234:	f403 7380 	and.w	r3, r3, #256	; 0x100
 8002238:	2b00      	cmp	r3, #0
 800223a:	d005      	beq.n	8002248 <HAL_RCC_OscConfig+0x320>
 800223c:	687b      	ldr	r3, [r7, #4]
 800223e:	69db      	ldr	r3, [r3, #28]
 8002240:	2b80      	cmp	r3, #128	; 0x80
 8002242:	d001      	beq.n	8002248 <HAL_RCC_OscConfig+0x320>
      {
        return HAL_ERROR;
 8002244:	2301      	movs	r3, #1
 8002246:	e296      	b.n	8002776 <HAL_RCC_OscConfig+0x84e>
      }
      /* Otherwise, just the calibration is allowed */
      else
      {
        /* Adjusts the Internal High Speed oscillator (CSI) calibration value.*/
        __HAL_RCC_CSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->CSICalibrationValue);
 8002248:	f7ff fa82 	bl	8001750 <HAL_GetREVID>
 800224c:	4603      	mov	r3, r0
 800224e:	f241 0203 	movw	r2, #4099	; 0x1003
 8002252:	4293      	cmp	r3, r2
 8002254:	d817      	bhi.n	8002286 <HAL_RCC_OscConfig+0x35e>
 8002256:	687b      	ldr	r3, [r7, #4]
 8002258:	6a1b      	ldr	r3, [r3, #32]
 800225a:	2b20      	cmp	r3, #32
 800225c:	d108      	bne.n	8002270 <HAL_RCC_OscConfig+0x348>
 800225e:	4b70      	ldr	r3, [pc, #448]	; (8002420 <HAL_RCC_OscConfig+0x4f8>)
 8002260:	685b      	ldr	r3, [r3, #4]
 8002262:	f023 43f8 	bic.w	r3, r3, #2080374784	; 0x7c000000
 8002266:	4a6e      	ldr	r2, [pc, #440]	; (8002420 <HAL_RCC_OscConfig+0x4f8>)
 8002268:	f043 4380 	orr.w	r3, r3, #1073741824	; 0x40000000
 800226c:	6053      	str	r3, [r2, #4]
      if((__HAL_RCC_GET_FLAG(RCC_FLAG_CSIRDY) != 0U) && (RCC_OscInitStruct->CSIState != RCC_CSI_ON))
 800226e:	e075      	b.n	800235c <HAL_RCC_OscConfig+0x434>
        __HAL_RCC_CSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->CSICalibrationValue);
 8002270:	4b6b      	ldr	r3, [pc, #428]	; (8002420 <HAL_RCC_OscConfig+0x4f8>)
 8002272:	685b      	ldr	r3, [r3, #4]
 8002274:	f023 42f8 	bic.w	r2, r3, #2080374784	; 0x7c000000
 8002278:	687b      	ldr	r3, [r7, #4]
 800227a:	6a1b      	ldr	r3, [r3, #32]
 800227c:	069b      	lsls	r3, r3, #26
 800227e:	4968      	ldr	r1, [pc, #416]	; (8002420 <HAL_RCC_OscConfig+0x4f8>)
 8002280:	4313      	orrs	r3, r2
 8002282:	604b      	str	r3, [r1, #4]
      if((__HAL_RCC_GET_FLAG(RCC_FLAG_CSIRDY) != 0U) && (RCC_OscInitStruct->CSIState != RCC_CSI_ON))
 8002284:	e06a      	b.n	800235c <HAL_RCC_OscConfig+0x434>
        __HAL_RCC_CSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->CSICalibrationValue);
 8002286:	4b66      	ldr	r3, [pc, #408]	; (8002420 <HAL_RCC_OscConfig+0x4f8>)
 8002288:	68db      	ldr	r3, [r3, #12]
 800228a:	f023 527c 	bic.w	r2, r3, #1056964608	; 0x3f000000
 800228e:	687b      	ldr	r3, [r7, #4]
 8002290:	6a1b      	ldr	r3, [r3, #32]
 8002292:	061b      	lsls	r3, r3, #24
 8002294:	4962      	ldr	r1, [pc, #392]	; (8002420 <HAL_RCC_OscConfig+0x4f8>)
 8002296:	4313      	orrs	r3, r2
 8002298:	60cb      	str	r3, [r1, #12]
      if((__HAL_RCC_GET_FLAG(RCC_FLAG_CSIRDY) != 0U) && (RCC_OscInitStruct->CSIState != RCC_CSI_ON))
 800229a:	e05f      	b.n	800235c <HAL_RCC_OscConfig+0x434>
      }
    }
    else
    {
      /* Check the CSI State */
      if((RCC_OscInitStruct->CSIState)!= RCC_CSI_OFF)
 800229c:	687b      	ldr	r3, [r7, #4]
 800229e:	69db      	ldr	r3, [r3, #28]
 80022a0:	2b00      	cmp	r3, #0
 80022a2:	d042      	beq.n	800232a <HAL_RCC_OscConfig+0x402>
      {
        /* Enable the Internal High Speed oscillator (CSI). */
        __HAL_RCC_CSI_ENABLE();
 80022a4:	4b5e      	ldr	r3, [pc, #376]	; (8002420 <HAL_RCC_OscConfig+0x4f8>)
 80022a6:	681b      	ldr	r3, [r3, #0]
 80022a8:	4a5d      	ldr	r2, [pc, #372]	; (8002420 <HAL_RCC_OscConfig+0x4f8>)
 80022aa:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 80022ae:	6013      	str	r3, [r2, #0]

        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 80022b0:	f7ff fa42 	bl	8001738 <HAL_GetTick>
 80022b4:	6278      	str	r0, [r7, #36]	; 0x24

        /* Wait till CSI is ready */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_CSIRDY) == 0U)
 80022b6:	e008      	b.n	80022ca <HAL_RCC_OscConfig+0x3a2>
        {
          if((HAL_GetTick() - tickstart ) > CSI_TIMEOUT_VALUE)
 80022b8:	f7ff fa3e 	bl	8001738 <HAL_GetTick>
 80022bc:	4602      	mov	r2, r0
 80022be:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80022c0:	1ad3      	subs	r3, r2, r3
 80022c2:	2b02      	cmp	r3, #2
 80022c4:	d901      	bls.n	80022ca <HAL_RCC_OscConfig+0x3a2>
          {
            return HAL_TIMEOUT;
 80022c6:	2303      	movs	r3, #3
 80022c8:	e255      	b.n	8002776 <HAL_RCC_OscConfig+0x84e>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_CSIRDY) == 0U)
 80022ca:	4b55      	ldr	r3, [pc, #340]	; (8002420 <HAL_RCC_OscConfig+0x4f8>)
 80022cc:	681b      	ldr	r3, [r3, #0]
 80022ce:	f403 7380 	and.w	r3, r3, #256	; 0x100
 80022d2:	2b00      	cmp	r3, #0
 80022d4:	d0f0      	beq.n	80022b8 <HAL_RCC_OscConfig+0x390>
          }
        }

        /* Adjusts the Internal High Speed oscillator (CSI) calibration value.*/
        __HAL_RCC_CSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->CSICalibrationValue);
 80022d6:	f7ff fa3b 	bl	8001750 <HAL_GetREVID>
 80022da:	4603      	mov	r3, r0
 80022dc:	f241 0203 	movw	r2, #4099	; 0x1003
 80022e0:	4293      	cmp	r3, r2
 80022e2:	d817      	bhi.n	8002314 <HAL_RCC_OscConfig+0x3ec>
 80022e4:	687b      	ldr	r3, [r7, #4]
 80022e6:	6a1b      	ldr	r3, [r3, #32]
 80022e8:	2b20      	cmp	r3, #32
 80022ea:	d108      	bne.n	80022fe <HAL_RCC_OscConfig+0x3d6>
 80022ec:	4b4c      	ldr	r3, [pc, #304]	; (8002420 <HAL_RCC_OscConfig+0x4f8>)
 80022ee:	685b      	ldr	r3, [r3, #4]
 80022f0:	f023 43f8 	bic.w	r3, r3, #2080374784	; 0x7c000000
 80022f4:	4a4a      	ldr	r2, [pc, #296]	; (8002420 <HAL_RCC_OscConfig+0x4f8>)
 80022f6:	f043 4380 	orr.w	r3, r3, #1073741824	; 0x40000000
 80022fa:	6053      	str	r3, [r2, #4]
 80022fc:	e02e      	b.n	800235c <HAL_RCC_OscConfig+0x434>
 80022fe:	4b48      	ldr	r3, [pc, #288]	; (8002420 <HAL_RCC_OscConfig+0x4f8>)
 8002300:	685b      	ldr	r3, [r3, #4]
 8002302:	f023 42f8 	bic.w	r2, r3, #2080374784	; 0x7c000000
 8002306:	687b      	ldr	r3, [r7, #4]
 8002308:	6a1b      	ldr	r3, [r3, #32]
 800230a:	069b      	lsls	r3, r3, #26
 800230c:	4944      	ldr	r1, [pc, #272]	; (8002420 <HAL_RCC_OscConfig+0x4f8>)
 800230e:	4313      	orrs	r3, r2
 8002310:	604b      	str	r3, [r1, #4]
 8002312:	e023      	b.n	800235c <HAL_RCC_OscConfig+0x434>
 8002314:	4b42      	ldr	r3, [pc, #264]	; (8002420 <HAL_RCC_OscConfig+0x4f8>)
 8002316:	68db      	ldr	r3, [r3, #12]
 8002318:	f023 527c 	bic.w	r2, r3, #1056964608	; 0x3f000000
 800231c:	687b      	ldr	r3, [r7, #4]
 800231e:	6a1b      	ldr	r3, [r3, #32]
 8002320:	061b      	lsls	r3, r3, #24
 8002322:	493f      	ldr	r1, [pc, #252]	; (8002420 <HAL_RCC_OscConfig+0x4f8>)
 8002324:	4313      	orrs	r3, r2
 8002326:	60cb      	str	r3, [r1, #12]
 8002328:	e018      	b.n	800235c <HAL_RCC_OscConfig+0x434>
      }
      else
      {
        /* Disable the Internal High Speed oscillator (CSI). */
        __HAL_RCC_CSI_DISABLE();
 800232a:	4b3d      	ldr	r3, [pc, #244]	; (8002420 <HAL_RCC_OscConfig+0x4f8>)
 800232c:	681b      	ldr	r3, [r3, #0]
 800232e:	4a3c      	ldr	r2, [pc, #240]	; (8002420 <HAL_RCC_OscConfig+0x4f8>)
 8002330:	f023 0380 	bic.w	r3, r3, #128	; 0x80
 8002334:	6013      	str	r3, [r2, #0]

        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 8002336:	f7ff f9ff 	bl	8001738 <HAL_GetTick>
 800233a:	6278      	str	r0, [r7, #36]	; 0x24

        /* Wait till CSI is disabled */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_CSIRDY) != 0U)
 800233c:	e008      	b.n	8002350 <HAL_RCC_OscConfig+0x428>
        {
          if((HAL_GetTick() - tickstart ) > CSI_TIMEOUT_VALUE)
 800233e:	f7ff f9fb 	bl	8001738 <HAL_GetTick>
 8002342:	4602      	mov	r2, r0
 8002344:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8002346:	1ad3      	subs	r3, r2, r3
 8002348:	2b02      	cmp	r3, #2
 800234a:	d901      	bls.n	8002350 <HAL_RCC_OscConfig+0x428>
          {
            return HAL_TIMEOUT;
 800234c:	2303      	movs	r3, #3
 800234e:	e212      	b.n	8002776 <HAL_RCC_OscConfig+0x84e>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_CSIRDY) != 0U)
 8002350:	4b33      	ldr	r3, [pc, #204]	; (8002420 <HAL_RCC_OscConfig+0x4f8>)
 8002352:	681b      	ldr	r3, [r3, #0]
 8002354:	f403 7380 	and.w	r3, r3, #256	; 0x100
 8002358:	2b00      	cmp	r3, #0
 800235a:	d1f0      	bne.n	800233e <HAL_RCC_OscConfig+0x416>
        }
      }
    }
  }
  /*------------------------------ LSI Configuration -------------------------*/
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSI) == RCC_OSCILLATORTYPE_LSI)
 800235c:	687b      	ldr	r3, [r7, #4]
 800235e:	681b      	ldr	r3, [r3, #0]
 8002360:	f003 0308 	and.w	r3, r3, #8
 8002364:	2b00      	cmp	r3, #0
 8002366:	d036      	beq.n	80023d6 <HAL_RCC_OscConfig+0x4ae>
  {
    /* Check the parameters */
    assert_param(IS_RCC_LSI(RCC_OscInitStruct->LSIState));

    /* Check the LSI State */
    if((RCC_OscInitStruct->LSIState)!= RCC_LSI_OFF)
 8002368:	687b      	ldr	r3, [r7, #4]
 800236a:	695b      	ldr	r3, [r3, #20]
 800236c:	2b00      	cmp	r3, #0
 800236e:	d019      	beq.n	80023a4 <HAL_RCC_OscConfig+0x47c>
    {
      /* Enable the Internal Low Speed oscillator (LSI). */
      __HAL_RCC_LSI_ENABLE();
 8002370:	4b2b      	ldr	r3, [pc, #172]	; (8002420 <HAL_RCC_OscConfig+0x4f8>)
 8002372:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 8002374:	4a2a      	ldr	r2, [pc, #168]	; (8002420 <HAL_RCC_OscConfig+0x4f8>)
 8002376:	f043 0301 	orr.w	r3, r3, #1
 800237a:	6753      	str	r3, [r2, #116]	; 0x74

      /* Get Start Tick*/
      tickstart = HAL_GetTick();
 800237c:	f7ff f9dc 	bl	8001738 <HAL_GetTick>
 8002380:	6278      	str	r0, [r7, #36]	; 0x24

      /* Wait till LSI is ready */
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) == 0U)
 8002382:	e008      	b.n	8002396 <HAL_RCC_OscConfig+0x46e>
      {
        if((HAL_GetTick() - tickstart ) > LSI_TIMEOUT_VALUE)
 8002384:	f7ff f9d8 	bl	8001738 <HAL_GetTick>
 8002388:	4602      	mov	r2, r0
 800238a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800238c:	1ad3      	subs	r3, r2, r3
 800238e:	2b02      	cmp	r3, #2
 8002390:	d901      	bls.n	8002396 <HAL_RCC_OscConfig+0x46e>
        {
          return HAL_TIMEOUT;
 8002392:	2303      	movs	r3, #3
 8002394:	e1ef      	b.n	8002776 <HAL_RCC_OscConfig+0x84e>
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) == 0U)
 8002396:	4b22      	ldr	r3, [pc, #136]	; (8002420 <HAL_RCC_OscConfig+0x4f8>)
 8002398:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 800239a:	f003 0302 	and.w	r3, r3, #2
 800239e:	2b00      	cmp	r3, #0
 80023a0:	d0f0      	beq.n	8002384 <HAL_RCC_OscConfig+0x45c>
 80023a2:	e018      	b.n	80023d6 <HAL_RCC_OscConfig+0x4ae>
      }
    }
    else
    {
      /* Disable the Internal Low Speed oscillator (LSI). */
      __HAL_RCC_LSI_DISABLE();
 80023a4:	4b1e      	ldr	r3, [pc, #120]	; (8002420 <HAL_RCC_OscConfig+0x4f8>)
 80023a6:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 80023a8:	4a1d      	ldr	r2, [pc, #116]	; (8002420 <HAL_RCC_OscConfig+0x4f8>)
 80023aa:	f023 0301 	bic.w	r3, r3, #1
 80023ae:	6753      	str	r3, [r2, #116]	; 0x74

      /* Get Start Tick*/
      tickstart = HAL_GetTick();
 80023b0:	f7ff f9c2 	bl	8001738 <HAL_GetTick>
 80023b4:	6278      	str	r0, [r7, #36]	; 0x24

      /* Wait till LSI is ready */
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) != 0U)
 80023b6:	e008      	b.n	80023ca <HAL_RCC_OscConfig+0x4a2>
      {
        if((HAL_GetTick() - tickstart ) > LSI_TIMEOUT_VALUE)
 80023b8:	f7ff f9be 	bl	8001738 <HAL_GetTick>
 80023bc:	4602      	mov	r2, r0
 80023be:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80023c0:	1ad3      	subs	r3, r2, r3
 80023c2:	2b02      	cmp	r3, #2
 80023c4:	d901      	bls.n	80023ca <HAL_RCC_OscConfig+0x4a2>
        {
          return HAL_TIMEOUT;
 80023c6:	2303      	movs	r3, #3
 80023c8:	e1d5      	b.n	8002776 <HAL_RCC_OscConfig+0x84e>
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) != 0U)
 80023ca:	4b15      	ldr	r3, [pc, #84]	; (8002420 <HAL_RCC_OscConfig+0x4f8>)
 80023cc:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 80023ce:	f003 0302 	and.w	r3, r3, #2
 80023d2:	2b00      	cmp	r3, #0
 80023d4:	d1f0      	bne.n	80023b8 <HAL_RCC_OscConfig+0x490>
      }
    }
  }

  /*------------------------------ HSI48 Configuration -------------------------*/
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSI48) == RCC_OSCILLATORTYPE_HSI48)
 80023d6:	687b      	ldr	r3, [r7, #4]
 80023d8:	681b      	ldr	r3, [r3, #0]
 80023da:	f003 0320 	and.w	r3, r3, #32
 80023de:	2b00      	cmp	r3, #0
 80023e0:	d039      	beq.n	8002456 <HAL_RCC_OscConfig+0x52e>
  {
    /* Check the parameters */
    assert_param(IS_RCC_HSI48(RCC_OscInitStruct->HSI48State));

    /* Check the HSI48 State */
    if((RCC_OscInitStruct->HSI48State)!= RCC_HSI48_OFF)
 80023e2:	687b      	ldr	r3, [r7, #4]
 80023e4:	699b      	ldr	r3, [r3, #24]
 80023e6:	2b00      	cmp	r3, #0
 80023e8:	d01c      	beq.n	8002424 <HAL_RCC_OscConfig+0x4fc>
    {
      /* Enable the Internal Low Speed oscillator (HSI48). */
      __HAL_RCC_HSI48_ENABLE();
 80023ea:	4b0d      	ldr	r3, [pc, #52]	; (8002420 <HAL_RCC_OscConfig+0x4f8>)
 80023ec:	681b      	ldr	r3, [r3, #0]
 80023ee:	4a0c      	ldr	r2, [pc, #48]	; (8002420 <HAL_RCC_OscConfig+0x4f8>)
 80023f0:	f443 5380 	orr.w	r3, r3, #4096	; 0x1000
 80023f4:	6013      	str	r3, [r2, #0]

      /* Get time-out */
      tickstart = HAL_GetTick();
 80023f6:	f7ff f99f 	bl	8001738 <HAL_GetTick>
 80023fa:	6278      	str	r0, [r7, #36]	; 0x24

      /* Wait till HSI48 is ready */
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSI48RDY) == 0U)
 80023fc:	e008      	b.n	8002410 <HAL_RCC_OscConfig+0x4e8>
      {
        if((HAL_GetTick() - tickstart ) > HSI48_TIMEOUT_VALUE)
 80023fe:	f7ff f99b 	bl	8001738 <HAL_GetTick>
 8002402:	4602      	mov	r2, r0
 8002404:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8002406:	1ad3      	subs	r3, r2, r3
 8002408:	2b02      	cmp	r3, #2
 800240a:	d901      	bls.n	8002410 <HAL_RCC_OscConfig+0x4e8>
        {
          return HAL_TIMEOUT;
 800240c:	2303      	movs	r3, #3
 800240e:	e1b2      	b.n	8002776 <HAL_RCC_OscConfig+0x84e>
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSI48RDY) == 0U)
 8002410:	4b03      	ldr	r3, [pc, #12]	; (8002420 <HAL_RCC_OscConfig+0x4f8>)
 8002412:	681b      	ldr	r3, [r3, #0]
 8002414:	f403 5300 	and.w	r3, r3, #8192	; 0x2000
 8002418:	2b00      	cmp	r3, #0
 800241a:	d0f0      	beq.n	80023fe <HAL_RCC_OscConfig+0x4d6>
 800241c:	e01b      	b.n	8002456 <HAL_RCC_OscConfig+0x52e>
 800241e:	bf00      	nop
 8002420:	58024400 	.word	0x58024400
      }
    }
    else
    {
      /* Disable the Internal Low Speed oscillator (HSI48). */
      __HAL_RCC_HSI48_DISABLE();
 8002424:	4b9b      	ldr	r3, [pc, #620]	; (8002694 <HAL_RCC_OscConfig+0x76c>)
 8002426:	681b      	ldr	r3, [r3, #0]
 8002428:	4a9a      	ldr	r2, [pc, #616]	; (8002694 <HAL_RCC_OscConfig+0x76c>)
 800242a:	f423 5380 	bic.w	r3, r3, #4096	; 0x1000
 800242e:	6013      	str	r3, [r2, #0]

      /* Get time-out */
      tickstart = HAL_GetTick();
 8002430:	f7ff f982 	bl	8001738 <HAL_GetTick>
 8002434:	6278      	str	r0, [r7, #36]	; 0x24

      /* Wait till HSI48 is ready */
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSI48RDY) != 0U)
 8002436:	e008      	b.n	800244a <HAL_RCC_OscConfig+0x522>
      {
        if((HAL_GetTick() - tickstart ) > HSI48_TIMEOUT_VALUE)
 8002438:	f7ff f97e 	bl	8001738 <HAL_GetTick>
 800243c:	4602      	mov	r2, r0
 800243e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8002440:	1ad3      	subs	r3, r2, r3
 8002442:	2b02      	cmp	r3, #2
 8002444:	d901      	bls.n	800244a <HAL_RCC_OscConfig+0x522>
        {
          return HAL_TIMEOUT;
 8002446:	2303      	movs	r3, #3
 8002448:	e195      	b.n	8002776 <HAL_RCC_OscConfig+0x84e>
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSI48RDY) != 0U)
 800244a:	4b92      	ldr	r3, [pc, #584]	; (8002694 <HAL_RCC_OscConfig+0x76c>)
 800244c:	681b      	ldr	r3, [r3, #0]
 800244e:	f403 5300 	and.w	r3, r3, #8192	; 0x2000
 8002452:	2b00      	cmp	r3, #0
 8002454:	d1f0      	bne.n	8002438 <HAL_RCC_OscConfig+0x510>
        }
      }
    }
  }
  /*------------------------------ LSE Configuration -------------------------*/
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSE) == RCC_OSCILLATORTYPE_LSE)
 8002456:	687b      	ldr	r3, [r7, #4]
 8002458:	681b      	ldr	r3, [r3, #0]
 800245a:	f003 0304 	and.w	r3, r3, #4
 800245e:	2b00      	cmp	r3, #0
 8002460:	f000 8081 	beq.w	8002566 <HAL_RCC_OscConfig+0x63e>
  {
    /* Check the parameters */
    assert_param(IS_RCC_LSE(RCC_OscInitStruct->LSEState));

    /* Enable write access to Backup domain */
    PWR->CR1 |= PWR_CR1_DBP;
 8002464:	4b8c      	ldr	r3, [pc, #560]	; (8002698 <HAL_RCC_OscConfig+0x770>)
 8002466:	681b      	ldr	r3, [r3, #0]
 8002468:	4a8b      	ldr	r2, [pc, #556]	; (8002698 <HAL_RCC_OscConfig+0x770>)
 800246a:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 800246e:	6013      	str	r3, [r2, #0]

    /* Wait for Backup domain Write protection disable */
    tickstart = HAL_GetTick();
 8002470:	f7ff f962 	bl	8001738 <HAL_GetTick>
 8002474:	6278      	str	r0, [r7, #36]	; 0x24

    while((PWR->CR1 & PWR_CR1_DBP) == 0U)
 8002476:	e008      	b.n	800248a <HAL_RCC_OscConfig+0x562>
    {
      if((HAL_GetTick() - tickstart ) > RCC_DBP_TIMEOUT_VALUE)
 8002478:	f7ff f95e 	bl	8001738 <HAL_GetTick>
 800247c:	4602      	mov	r2, r0
 800247e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8002480:	1ad3      	subs	r3, r2, r3
 8002482:	2b64      	cmp	r3, #100	; 0x64
 8002484:	d901      	bls.n	800248a <HAL_RCC_OscConfig+0x562>
      {
        return HAL_TIMEOUT;
 8002486:	2303      	movs	r3, #3
 8002488:	e175      	b.n	8002776 <HAL_RCC_OscConfig+0x84e>
    while((PWR->CR1 & PWR_CR1_DBP) == 0U)
 800248a:	4b83      	ldr	r3, [pc, #524]	; (8002698 <HAL_RCC_OscConfig+0x770>)
 800248c:	681b      	ldr	r3, [r3, #0]
 800248e:	f403 7380 	and.w	r3, r3, #256	; 0x100
 8002492:	2b00      	cmp	r3, #0
 8002494:	d0f0      	beq.n	8002478 <HAL_RCC_OscConfig+0x550>
      }
    }

    /* Set the new LSE configuration -----------------------------------------*/
    __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
 8002496:	687b      	ldr	r3, [r7, #4]
 8002498:	689b      	ldr	r3, [r3, #8]
 800249a:	2b01      	cmp	r3, #1
 800249c:	d106      	bne.n	80024ac <HAL_RCC_OscConfig+0x584>
 800249e:	4b7d      	ldr	r3, [pc, #500]	; (8002694 <HAL_RCC_OscConfig+0x76c>)
 80024a0:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 80024a2:	4a7c      	ldr	r2, [pc, #496]	; (8002694 <HAL_RCC_OscConfig+0x76c>)
 80024a4:	f043 0301 	orr.w	r3, r3, #1
 80024a8:	6713      	str	r3, [r2, #112]	; 0x70
 80024aa:	e02d      	b.n	8002508 <HAL_RCC_OscConfig+0x5e0>
 80024ac:	687b      	ldr	r3, [r7, #4]
 80024ae:	689b      	ldr	r3, [r3, #8]
 80024b0:	2b00      	cmp	r3, #0
 80024b2:	d10c      	bne.n	80024ce <HAL_RCC_OscConfig+0x5a6>
 80024b4:	4b77      	ldr	r3, [pc, #476]	; (8002694 <HAL_RCC_OscConfig+0x76c>)
 80024b6:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 80024b8:	4a76      	ldr	r2, [pc, #472]	; (8002694 <HAL_RCC_OscConfig+0x76c>)
 80024ba:	f023 0301 	bic.w	r3, r3, #1
 80024be:	6713      	str	r3, [r2, #112]	; 0x70
 80024c0:	4b74      	ldr	r3, [pc, #464]	; (8002694 <HAL_RCC_OscConfig+0x76c>)
 80024c2:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 80024c4:	4a73      	ldr	r2, [pc, #460]	; (8002694 <HAL_RCC_OscConfig+0x76c>)
 80024c6:	f023 0304 	bic.w	r3, r3, #4
 80024ca:	6713      	str	r3, [r2, #112]	; 0x70
 80024cc:	e01c      	b.n	8002508 <HAL_RCC_OscConfig+0x5e0>
 80024ce:	687b      	ldr	r3, [r7, #4]
 80024d0:	689b      	ldr	r3, [r3, #8]
 80024d2:	2b05      	cmp	r3, #5
 80024d4:	d10c      	bne.n	80024f0 <HAL_RCC_OscConfig+0x5c8>
 80024d6:	4b6f      	ldr	r3, [pc, #444]	; (8002694 <HAL_RCC_OscConfig+0x76c>)
 80024d8:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 80024da:	4a6e      	ldr	r2, [pc, #440]	; (8002694 <HAL_RCC_OscConfig+0x76c>)
 80024dc:	f043 0304 	orr.w	r3, r3, #4
 80024e0:	6713      	str	r3, [r2, #112]	; 0x70
 80024e2:	4b6c      	ldr	r3, [pc, #432]	; (8002694 <HAL_RCC_OscConfig+0x76c>)
 80024e4:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 80024e6:	4a6b      	ldr	r2, [pc, #428]	; (8002694 <HAL_RCC_OscConfig+0x76c>)
 80024e8:	f043 0301 	orr.w	r3, r3, #1
 80024ec:	6713      	str	r3, [r2, #112]	; 0x70
 80024ee:	e00b      	b.n	8002508 <HAL_RCC_OscConfig+0x5e0>
 80024f0:	4b68      	ldr	r3, [pc, #416]	; (8002694 <HAL_RCC_OscConfig+0x76c>)
 80024f2:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 80024f4:	4a67      	ldr	r2, [pc, #412]	; (8002694 <HAL_RCC_OscConfig+0x76c>)
 80024f6:	f023 0301 	bic.w	r3, r3, #1
 80024fa:	6713      	str	r3, [r2, #112]	; 0x70
 80024fc:	4b65      	ldr	r3, [pc, #404]	; (8002694 <HAL_RCC_OscConfig+0x76c>)
 80024fe:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 8002500:	4a64      	ldr	r2, [pc, #400]	; (8002694 <HAL_RCC_OscConfig+0x76c>)
 8002502:	f023 0304 	bic.w	r3, r3, #4
 8002506:	6713      	str	r3, [r2, #112]	; 0x70
    /* Check the LSE State */
    if((RCC_OscInitStruct->LSEState) != RCC_LSE_OFF)
 8002508:	687b      	ldr	r3, [r7, #4]
 800250a:	689b      	ldr	r3, [r3, #8]
 800250c:	2b00      	cmp	r3, #0
 800250e:	d015      	beq.n	800253c <HAL_RCC_OscConfig+0x614>
    {
      /* Get Start Tick*/
      tickstart = HAL_GetTick();
 8002510:	f7ff f912 	bl	8001738 <HAL_GetTick>
 8002514:	6278      	str	r0, [r7, #36]	; 0x24

      /* Wait till LSE is ready */
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == 0U)
 8002516:	e00a      	b.n	800252e <HAL_RCC_OscConfig+0x606>
      {
        if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
 8002518:	f7ff f90e 	bl	8001738 <HAL_GetTick>
 800251c:	4602      	mov	r2, r0
 800251e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8002520:	1ad3      	subs	r3, r2, r3
 8002522:	f241 3288 	movw	r2, #5000	; 0x1388
 8002526:	4293      	cmp	r3, r2
 8002528:	d901      	bls.n	800252e <HAL_RCC_OscConfig+0x606>
        {
          return HAL_TIMEOUT;
 800252a:	2303      	movs	r3, #3
 800252c:	e123      	b.n	8002776 <HAL_RCC_OscConfig+0x84e>
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == 0U)
 800252e:	4b59      	ldr	r3, [pc, #356]	; (8002694 <HAL_RCC_OscConfig+0x76c>)
 8002530:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 8002532:	f003 0302 	and.w	r3, r3, #2
 8002536:	2b00      	cmp	r3, #0
 8002538:	d0ee      	beq.n	8002518 <HAL_RCC_OscConfig+0x5f0>
 800253a:	e014      	b.n	8002566 <HAL_RCC_OscConfig+0x63e>
      }
    }
    else
    {
      /* Get Start Tick*/
      tickstart = HAL_GetTick();
 800253c:	f7ff f8fc 	bl	8001738 <HAL_GetTick>
 8002540:	6278      	str	r0, [r7, #36]	; 0x24

      /* Wait till LSE is disabled */
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) != 0U)
 8002542:	e00a      	b.n	800255a <HAL_RCC_OscConfig+0x632>
      {
        if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
 8002544:	f7ff f8f8 	bl	8001738 <HAL_GetTick>
 8002548:	4602      	mov	r2, r0
 800254a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800254c:	1ad3      	subs	r3, r2, r3
 800254e:	f241 3288 	movw	r2, #5000	; 0x1388
 8002552:	4293      	cmp	r3, r2
 8002554:	d901      	bls.n	800255a <HAL_RCC_OscConfig+0x632>
        {
          return HAL_TIMEOUT;
 8002556:	2303      	movs	r3, #3
 8002558:	e10d      	b.n	8002776 <HAL_RCC_OscConfig+0x84e>
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) != 0U)
 800255a:	4b4e      	ldr	r3, [pc, #312]	; (8002694 <HAL_RCC_OscConfig+0x76c>)
 800255c:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 800255e:	f003 0302 	and.w	r3, r3, #2
 8002562:	2b00      	cmp	r3, #0
 8002564:	d1ee      	bne.n	8002544 <HAL_RCC_OscConfig+0x61c>
    }
  }
  /*-------------------------------- PLL Configuration -----------------------*/
  /* Check the parameters */
  assert_param(IS_RCC_PLL(RCC_OscInitStruct->PLL.PLLState));
  if ((RCC_OscInitStruct->PLL.PLLState) != RCC_PLL_NONE)
 8002566:	687b      	ldr	r3, [r7, #4]
 8002568:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800256a:	2b00      	cmp	r3, #0
 800256c:	f000 8102 	beq.w	8002774 <HAL_RCC_OscConfig+0x84c>
  {
    /* Check if the PLL is used as system clock or not */
    if(__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_CFGR_SWS_PLL1)
 8002570:	4b48      	ldr	r3, [pc, #288]	; (8002694 <HAL_RCC_OscConfig+0x76c>)
 8002572:	691b      	ldr	r3, [r3, #16]
 8002574:	f003 0338 	and.w	r3, r3, #56	; 0x38
 8002578:	2b18      	cmp	r3, #24
 800257a:	f000 80bd 	beq.w	80026f8 <HAL_RCC_OscConfig+0x7d0>
    {
      if((RCC_OscInitStruct->PLL.PLLState) == RCC_PLL_ON)
 800257e:	687b      	ldr	r3, [r7, #4]
 8002580:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8002582:	2b02      	cmp	r3, #2
 8002584:	f040 809e 	bne.w	80026c4 <HAL_RCC_OscConfig+0x79c>
        assert_param(IS_RCC_PLLQ_VALUE(RCC_OscInitStruct->PLL.PLLQ));
        assert_param(IS_RCC_PLLR_VALUE(RCC_OscInitStruct->PLL.PLLR));
        assert_param(IS_RCC_PLLFRACN_VALUE(RCC_OscInitStruct->PLL.PLLFRACN));

        /* Disable the main PLL. */
        __HAL_RCC_PLL_DISABLE();
 8002588:	4b42      	ldr	r3, [pc, #264]	; (8002694 <HAL_RCC_OscConfig+0x76c>)
 800258a:	681b      	ldr	r3, [r3, #0]
 800258c:	4a41      	ldr	r2, [pc, #260]	; (8002694 <HAL_RCC_OscConfig+0x76c>)
 800258e:	f023 7380 	bic.w	r3, r3, #16777216	; 0x1000000
 8002592:	6013      	str	r3, [r2, #0]

        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 8002594:	f7ff f8d0 	bl	8001738 <HAL_GetTick>
 8002598:	6278      	str	r0, [r7, #36]	; 0x24

        /* Wait till PLL is disabled */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) != 0U)
 800259a:	e008      	b.n	80025ae <HAL_RCC_OscConfig+0x686>
        {
          if((HAL_GetTick() - tickstart ) > PLL_TIMEOUT_VALUE)
 800259c:	f7ff f8cc 	bl	8001738 <HAL_GetTick>
 80025a0:	4602      	mov	r2, r0
 80025a2:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80025a4:	1ad3      	subs	r3, r2, r3
 80025a6:	2b02      	cmp	r3, #2
 80025a8:	d901      	bls.n	80025ae <HAL_RCC_OscConfig+0x686>
          {
            return HAL_TIMEOUT;
 80025aa:	2303      	movs	r3, #3
 80025ac:	e0e3      	b.n	8002776 <HAL_RCC_OscConfig+0x84e>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) != 0U)
 80025ae:	4b39      	ldr	r3, [pc, #228]	; (8002694 <HAL_RCC_OscConfig+0x76c>)
 80025b0:	681b      	ldr	r3, [r3, #0]
 80025b2:	f003 7300 	and.w	r3, r3, #33554432	; 0x2000000
 80025b6:	2b00      	cmp	r3, #0
 80025b8:	d1f0      	bne.n	800259c <HAL_RCC_OscConfig+0x674>
          }
        }

        /* Configure the main PLL clock source, multiplication and division factors. */
        __HAL_RCC_PLL_CONFIG(RCC_OscInitStruct->PLL.PLLSource,
 80025ba:	4b36      	ldr	r3, [pc, #216]	; (8002694 <HAL_RCC_OscConfig+0x76c>)
 80025bc:	6a9a      	ldr	r2, [r3, #40]	; 0x28
 80025be:	4b37      	ldr	r3, [pc, #220]	; (800269c <HAL_RCC_OscConfig+0x774>)
 80025c0:	4013      	ands	r3, r2
 80025c2:	687a      	ldr	r2, [r7, #4]
 80025c4:	6a91      	ldr	r1, [r2, #40]	; 0x28
 80025c6:	687a      	ldr	r2, [r7, #4]
 80025c8:	6ad2      	ldr	r2, [r2, #44]	; 0x2c
 80025ca:	0112      	lsls	r2, r2, #4
 80025cc:	430a      	orrs	r2, r1
 80025ce:	4931      	ldr	r1, [pc, #196]	; (8002694 <HAL_RCC_OscConfig+0x76c>)
 80025d0:	4313      	orrs	r3, r2
 80025d2:	628b      	str	r3, [r1, #40]	; 0x28
 80025d4:	687b      	ldr	r3, [r7, #4]
 80025d6:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 80025d8:	3b01      	subs	r3, #1
 80025da:	f3c3 0208 	ubfx	r2, r3, #0, #9
 80025de:	687b      	ldr	r3, [r7, #4]
 80025e0:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 80025e2:	3b01      	subs	r3, #1
 80025e4:	025b      	lsls	r3, r3, #9
 80025e6:	b29b      	uxth	r3, r3
 80025e8:	431a      	orrs	r2, r3
 80025ea:	687b      	ldr	r3, [r7, #4]
 80025ec:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 80025ee:	3b01      	subs	r3, #1
 80025f0:	041b      	lsls	r3, r3, #16
 80025f2:	f403 03fe 	and.w	r3, r3, #8323072	; 0x7f0000
 80025f6:	431a      	orrs	r2, r3
 80025f8:	687b      	ldr	r3, [r7, #4]
 80025fa:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 80025fc:	3b01      	subs	r3, #1
 80025fe:	061b      	lsls	r3, r3, #24
 8002600:	f003 43fe 	and.w	r3, r3, #2130706432	; 0x7f000000
 8002604:	4923      	ldr	r1, [pc, #140]	; (8002694 <HAL_RCC_OscConfig+0x76c>)
 8002606:	4313      	orrs	r3, r2
 8002608:	630b      	str	r3, [r1, #48]	; 0x30
                             RCC_OscInitStruct->PLL.PLLP,
                             RCC_OscInitStruct->PLL.PLLQ,
                             RCC_OscInitStruct->PLL.PLLR);

         /* Disable PLLFRACN . */
         __HAL_RCC_PLLFRACN_DISABLE();
 800260a:	4b22      	ldr	r3, [pc, #136]	; (8002694 <HAL_RCC_OscConfig+0x76c>)
 800260c:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800260e:	4a21      	ldr	r2, [pc, #132]	; (8002694 <HAL_RCC_OscConfig+0x76c>)
 8002610:	f023 0301 	bic.w	r3, r3, #1
 8002614:	62d3      	str	r3, [r2, #44]	; 0x2c

         /* Configure PLL PLL1FRACN */
         __HAL_RCC_PLLFRACN_CONFIG(RCC_OscInitStruct->PLL.PLLFRACN);
 8002616:	4b1f      	ldr	r3, [pc, #124]	; (8002694 <HAL_RCC_OscConfig+0x76c>)
 8002618:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 800261a:	4b21      	ldr	r3, [pc, #132]	; (80026a0 <HAL_RCC_OscConfig+0x778>)
 800261c:	4013      	ands	r3, r2
 800261e:	687a      	ldr	r2, [r7, #4]
 8002620:	6c92      	ldr	r2, [r2, #72]	; 0x48
 8002622:	00d2      	lsls	r2, r2, #3
 8002624:	491b      	ldr	r1, [pc, #108]	; (8002694 <HAL_RCC_OscConfig+0x76c>)
 8002626:	4313      	orrs	r3, r2
 8002628:	634b      	str	r3, [r1, #52]	; 0x34

        /* Select PLL1 input reference frequency range: VCI */
        __HAL_RCC_PLL_VCIRANGE(RCC_OscInitStruct->PLL.PLLRGE) ;
 800262a:	4b1a      	ldr	r3, [pc, #104]	; (8002694 <HAL_RCC_OscConfig+0x76c>)
 800262c:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800262e:	f023 020c 	bic.w	r2, r3, #12
 8002632:	687b      	ldr	r3, [r7, #4]
 8002634:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8002636:	4917      	ldr	r1, [pc, #92]	; (8002694 <HAL_RCC_OscConfig+0x76c>)
 8002638:	4313      	orrs	r3, r2
 800263a:	62cb      	str	r3, [r1, #44]	; 0x2c

        /* Select PLL1 output frequency range : VCO */
        __HAL_RCC_PLL_VCORANGE(RCC_OscInitStruct->PLL.PLLVCOSEL) ;
 800263c:	4b15      	ldr	r3, [pc, #84]	; (8002694 <HAL_RCC_OscConfig+0x76c>)
 800263e:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8002640:	f023 0202 	bic.w	r2, r3, #2
 8002644:	687b      	ldr	r3, [r7, #4]
 8002646:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 8002648:	4912      	ldr	r1, [pc, #72]	; (8002694 <HAL_RCC_OscConfig+0x76c>)
 800264a:	4313      	orrs	r3, r2
 800264c:	62cb      	str	r3, [r1, #44]	; 0x2c

        /* Enable PLL System Clock output. */
         __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL1_DIVP);
 800264e:	4b11      	ldr	r3, [pc, #68]	; (8002694 <HAL_RCC_OscConfig+0x76c>)
 8002650:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8002652:	4a10      	ldr	r2, [pc, #64]	; (8002694 <HAL_RCC_OscConfig+0x76c>)
 8002654:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 8002658:	62d3      	str	r3, [r2, #44]	; 0x2c

        /* Enable PLL1Q Clock output. */
         __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL1_DIVQ);
 800265a:	4b0e      	ldr	r3, [pc, #56]	; (8002694 <HAL_RCC_OscConfig+0x76c>)
 800265c:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800265e:	4a0d      	ldr	r2, [pc, #52]	; (8002694 <HAL_RCC_OscConfig+0x76c>)
 8002660:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
 8002664:	62d3      	str	r3, [r2, #44]	; 0x2c

        /* Enable PLL1R  Clock output. */
         __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL1_DIVR);
 8002666:	4b0b      	ldr	r3, [pc, #44]	; (8002694 <HAL_RCC_OscConfig+0x76c>)
 8002668:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800266a:	4a0a      	ldr	r2, [pc, #40]	; (8002694 <HAL_RCC_OscConfig+0x76c>)
 800266c:	f443 2380 	orr.w	r3, r3, #262144	; 0x40000
 8002670:	62d3      	str	r3, [r2, #44]	; 0x2c

        /* Enable PLL1FRACN . */
         __HAL_RCC_PLLFRACN_ENABLE();
 8002672:	4b08      	ldr	r3, [pc, #32]	; (8002694 <HAL_RCC_OscConfig+0x76c>)
 8002674:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8002676:	4a07      	ldr	r2, [pc, #28]	; (8002694 <HAL_RCC_OscConfig+0x76c>)
 8002678:	f043 0301 	orr.w	r3, r3, #1
 800267c:	62d3      	str	r3, [r2, #44]	; 0x2c

        /* Enable the main PLL. */
        __HAL_RCC_PLL_ENABLE();
 800267e:	4b05      	ldr	r3, [pc, #20]	; (8002694 <HAL_RCC_OscConfig+0x76c>)
 8002680:	681b      	ldr	r3, [r3, #0]
 8002682:	4a04      	ldr	r2, [pc, #16]	; (8002694 <HAL_RCC_OscConfig+0x76c>)
 8002684:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
 8002688:	6013      	str	r3, [r2, #0]

        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 800268a:	f7ff f855 	bl	8001738 <HAL_GetTick>
 800268e:	6278      	str	r0, [r7, #36]	; 0x24

        /* Wait till PLL is ready */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == 0U)
 8002690:	e011      	b.n	80026b6 <HAL_RCC_OscConfig+0x78e>
 8002692:	bf00      	nop
 8002694:	58024400 	.word	0x58024400
 8002698:	58024800 	.word	0x58024800
 800269c:	fffffc0c 	.word	0xfffffc0c
 80026a0:	ffff0007 	.word	0xffff0007
        {
          if((HAL_GetTick() - tickstart ) > PLL_TIMEOUT_VALUE)
 80026a4:	f7ff f848 	bl	8001738 <HAL_GetTick>
 80026a8:	4602      	mov	r2, r0
 80026aa:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80026ac:	1ad3      	subs	r3, r2, r3
 80026ae:	2b02      	cmp	r3, #2
 80026b0:	d901      	bls.n	80026b6 <HAL_RCC_OscConfig+0x78e>
          {
            return HAL_TIMEOUT;
 80026b2:	2303      	movs	r3, #3
 80026b4:	e05f      	b.n	8002776 <HAL_RCC_OscConfig+0x84e>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == 0U)
 80026b6:	4b32      	ldr	r3, [pc, #200]	; (8002780 <HAL_RCC_OscConfig+0x858>)
 80026b8:	681b      	ldr	r3, [r3, #0]
 80026ba:	f003 7300 	and.w	r3, r3, #33554432	; 0x2000000
 80026be:	2b00      	cmp	r3, #0
 80026c0:	d0f0      	beq.n	80026a4 <HAL_RCC_OscConfig+0x77c>
 80026c2:	e057      	b.n	8002774 <HAL_RCC_OscConfig+0x84c>
        }
      }
      else
      {
        /* Disable the main PLL. */
        __HAL_RCC_PLL_DISABLE();
 80026c4:	4b2e      	ldr	r3, [pc, #184]	; (8002780 <HAL_RCC_OscConfig+0x858>)
 80026c6:	681b      	ldr	r3, [r3, #0]
 80026c8:	4a2d      	ldr	r2, [pc, #180]	; (8002780 <HAL_RCC_OscConfig+0x858>)
 80026ca:	f023 7380 	bic.w	r3, r3, #16777216	; 0x1000000
 80026ce:	6013      	str	r3, [r2, #0]

        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 80026d0:	f7ff f832 	bl	8001738 <HAL_GetTick>
 80026d4:	6278      	str	r0, [r7, #36]	; 0x24

        /* Wait till PLL is disabled */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) != 0U)
 80026d6:	e008      	b.n	80026ea <HAL_RCC_OscConfig+0x7c2>
        {
          if((HAL_GetTick() - tickstart ) > PLL_TIMEOUT_VALUE)
 80026d8:	f7ff f82e 	bl	8001738 <HAL_GetTick>
 80026dc:	4602      	mov	r2, r0
 80026de:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80026e0:	1ad3      	subs	r3, r2, r3
 80026e2:	2b02      	cmp	r3, #2
 80026e4:	d901      	bls.n	80026ea <HAL_RCC_OscConfig+0x7c2>
          {
            return HAL_TIMEOUT;
 80026e6:	2303      	movs	r3, #3
 80026e8:	e045      	b.n	8002776 <HAL_RCC_OscConfig+0x84e>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) != 0U)
 80026ea:	4b25      	ldr	r3, [pc, #148]	; (8002780 <HAL_RCC_OscConfig+0x858>)
 80026ec:	681b      	ldr	r3, [r3, #0]
 80026ee:	f003 7300 	and.w	r3, r3, #33554432	; 0x2000000
 80026f2:	2b00      	cmp	r3, #0
 80026f4:	d1f0      	bne.n	80026d8 <HAL_RCC_OscConfig+0x7b0>
 80026f6:	e03d      	b.n	8002774 <HAL_RCC_OscConfig+0x84c>
      }
    }
    else
    {
      /* Do not return HAL_ERROR if request repeats the current configuration */
      temp1_pllckcfg = RCC->PLLCKSELR;
 80026f8:	4b21      	ldr	r3, [pc, #132]	; (8002780 <HAL_RCC_OscConfig+0x858>)
 80026fa:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 80026fc:	613b      	str	r3, [r7, #16]
      temp2_pllckcfg = RCC->PLL1DIVR;
 80026fe:	4b20      	ldr	r3, [pc, #128]	; (8002780 <HAL_RCC_OscConfig+0x858>)
 8002700:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8002702:	60fb      	str	r3, [r7, #12]
      if(((RCC_OscInitStruct->PLL.PLLState) == RCC_PLL_OFF) ||
 8002704:	687b      	ldr	r3, [r7, #4]
 8002706:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8002708:	2b01      	cmp	r3, #1
 800270a:	d031      	beq.n	8002770 <HAL_RCC_OscConfig+0x848>
	 (READ_BIT(temp1_pllckcfg, RCC_PLLCKSELR_PLLSRC) != RCC_OscInitStruct->PLL.PLLSource) ||
 800270c:	693b      	ldr	r3, [r7, #16]
 800270e:	f003 0203 	and.w	r2, r3, #3
 8002712:	687b      	ldr	r3, [r7, #4]
 8002714:	6a9b      	ldr	r3, [r3, #40]	; 0x28
      if(((RCC_OscInitStruct->PLL.PLLState) == RCC_PLL_OFF) ||
 8002716:	429a      	cmp	r2, r3
 8002718:	d12a      	bne.n	8002770 <HAL_RCC_OscConfig+0x848>
         ((READ_BIT(temp1_pllckcfg, RCC_PLLCKSELR_DIVM1) >> RCC_PLLCKSELR_DIVM1_Pos) != RCC_OscInitStruct->PLL.PLLM) ||
 800271a:	693b      	ldr	r3, [r7, #16]
 800271c:	091b      	lsrs	r3, r3, #4
 800271e:	f003 023f 	and.w	r2, r3, #63	; 0x3f
 8002722:	687b      	ldr	r3, [r7, #4]
 8002724:	6adb      	ldr	r3, [r3, #44]	; 0x2c
	 (READ_BIT(temp1_pllckcfg, RCC_PLLCKSELR_PLLSRC) != RCC_OscInitStruct->PLL.PLLSource) ||
 8002726:	429a      	cmp	r2, r3
 8002728:	d122      	bne.n	8002770 <HAL_RCC_OscConfig+0x848>
         (READ_BIT(temp2_pllckcfg, RCC_PLL1DIVR_N1) != (RCC_OscInitStruct->PLL.PLLN - 1U)) ||
 800272a:	68fb      	ldr	r3, [r7, #12]
 800272c:	f3c3 0208 	ubfx	r2, r3, #0, #9
 8002730:	687b      	ldr	r3, [r7, #4]
 8002732:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8002734:	3b01      	subs	r3, #1
         ((READ_BIT(temp1_pllckcfg, RCC_PLLCKSELR_DIVM1) >> RCC_PLLCKSELR_DIVM1_Pos) != RCC_OscInitStruct->PLL.PLLM) ||
 8002736:	429a      	cmp	r2, r3
 8002738:	d11a      	bne.n	8002770 <HAL_RCC_OscConfig+0x848>
         ((READ_BIT(temp2_pllckcfg, RCC_PLL1DIVR_P1) >> RCC_PLL1DIVR_P1_Pos) != (RCC_OscInitStruct->PLL.PLLP - 1U)) ||
 800273a:	68fb      	ldr	r3, [r7, #12]
 800273c:	0a5b      	lsrs	r3, r3, #9
 800273e:	f003 027f 	and.w	r2, r3, #127	; 0x7f
 8002742:	687b      	ldr	r3, [r7, #4]
 8002744:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8002746:	3b01      	subs	r3, #1
         (READ_BIT(temp2_pllckcfg, RCC_PLL1DIVR_N1) != (RCC_OscInitStruct->PLL.PLLN - 1U)) ||
 8002748:	429a      	cmp	r2, r3
 800274a:	d111      	bne.n	8002770 <HAL_RCC_OscConfig+0x848>
         ((READ_BIT(temp2_pllckcfg, RCC_PLL1DIVR_Q1) >> RCC_PLL1DIVR_Q1_Pos) != (RCC_OscInitStruct->PLL.PLLQ - 1U)) ||
 800274c:	68fb      	ldr	r3, [r7, #12]
 800274e:	0c1b      	lsrs	r3, r3, #16
 8002750:	f003 027f 	and.w	r2, r3, #127	; 0x7f
 8002754:	687b      	ldr	r3, [r7, #4]
 8002756:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 8002758:	3b01      	subs	r3, #1
         ((READ_BIT(temp2_pllckcfg, RCC_PLL1DIVR_P1) >> RCC_PLL1DIVR_P1_Pos) != (RCC_OscInitStruct->PLL.PLLP - 1U)) ||
 800275a:	429a      	cmp	r2, r3
 800275c:	d108      	bne.n	8002770 <HAL_RCC_OscConfig+0x848>
         ((READ_BIT(temp2_pllckcfg, RCC_PLL1DIVR_R1) >> RCC_PLL1DIVR_R1_Pos) != (RCC_OscInitStruct->PLL.PLLR - 1U)))
 800275e:	68fb      	ldr	r3, [r7, #12]
 8002760:	0e1b      	lsrs	r3, r3, #24
 8002762:	f003 027f 	and.w	r2, r3, #127	; 0x7f
 8002766:	687b      	ldr	r3, [r7, #4]
 8002768:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 800276a:	3b01      	subs	r3, #1
         ((READ_BIT(temp2_pllckcfg, RCC_PLL1DIVR_Q1) >> RCC_PLL1DIVR_Q1_Pos) != (RCC_OscInitStruct->PLL.PLLQ - 1U)) ||
 800276c:	429a      	cmp	r2, r3
 800276e:	d001      	beq.n	8002774 <HAL_RCC_OscConfig+0x84c>
      {
        return HAL_ERROR;
 8002770:	2301      	movs	r3, #1
 8002772:	e000      	b.n	8002776 <HAL_RCC_OscConfig+0x84e>
      }
    }
  }
  return HAL_OK;
 8002774:	2300      	movs	r3, #0
}
 8002776:	4618      	mov	r0, r3
 8002778:	3730      	adds	r7, #48	; 0x30
 800277a:	46bd      	mov	sp, r7
 800277c:	bd80      	pop	{r7, pc}
 800277e:	bf00      	nop
 8002780:	58024400 	.word	0x58024400

08002784 <HAL_RCC_ClockConfig>:
  *         D1CPRE[3:0] bits to ensure that  Domain1 core clock not exceed the maximum allowed frequency
  *         (for more details refer to section above "Initialization/de-initialization functions")
  * @retval None
  */
HAL_StatusTypeDef HAL_RCC_ClockConfig(RCC_ClkInitTypeDef  *RCC_ClkInitStruct, uint32_t FLatency)
{
 8002784:	b580      	push	{r7, lr}
 8002786:	b086      	sub	sp, #24
 8002788:	af00      	add	r7, sp, #0
 800278a:	6078      	str	r0, [r7, #4]
 800278c:	6039      	str	r1, [r7, #0]
  HAL_StatusTypeDef halstatus;
  uint32_t tickstart;
  uint32_t common_system_clock;

   /* Check Null pointer */
  if(RCC_ClkInitStruct == NULL)
 800278e:	687b      	ldr	r3, [r7, #4]
 8002790:	2b00      	cmp	r3, #0
 8002792:	d101      	bne.n	8002798 <HAL_RCC_ClockConfig+0x14>
  {
    return HAL_ERROR;
 8002794:	2301      	movs	r3, #1
 8002796:	e19c      	b.n	8002ad2 <HAL_RCC_ClockConfig+0x34e>
  /* To correctly read data from FLASH memory, the number of wait states (LATENCY)
    must be correctly programmed according to the frequency of the CPU clock
    (HCLK) and the supply voltage of the device. */

  /* Increasing the CPU frequency */
  if(FLatency > __HAL_FLASH_GET_LATENCY())
 8002798:	4b8a      	ldr	r3, [pc, #552]	; (80029c4 <HAL_RCC_ClockConfig+0x240>)
 800279a:	681b      	ldr	r3, [r3, #0]
 800279c:	f003 030f 	and.w	r3, r3, #15
 80027a0:	683a      	ldr	r2, [r7, #0]
 80027a2:	429a      	cmp	r2, r3
 80027a4:	d910      	bls.n	80027c8 <HAL_RCC_ClockConfig+0x44>
  {
    /* Program the new number of wait states to the LATENCY bits in the FLASH_ACR register */
    __HAL_FLASH_SET_LATENCY(FLatency);
 80027a6:	4b87      	ldr	r3, [pc, #540]	; (80029c4 <HAL_RCC_ClockConfig+0x240>)
 80027a8:	681b      	ldr	r3, [r3, #0]
 80027aa:	f023 020f 	bic.w	r2, r3, #15
 80027ae:	4985      	ldr	r1, [pc, #532]	; (80029c4 <HAL_RCC_ClockConfig+0x240>)
 80027b0:	683b      	ldr	r3, [r7, #0]
 80027b2:	4313      	orrs	r3, r2
 80027b4:	600b      	str	r3, [r1, #0]

    /* Check that the new number of wait states is taken into account to access the Flash
    memory by reading the FLASH_ACR register */
    if(__HAL_FLASH_GET_LATENCY() != FLatency)
 80027b6:	4b83      	ldr	r3, [pc, #524]	; (80029c4 <HAL_RCC_ClockConfig+0x240>)
 80027b8:	681b      	ldr	r3, [r3, #0]
 80027ba:	f003 030f 	and.w	r3, r3, #15
 80027be:	683a      	ldr	r2, [r7, #0]
 80027c0:	429a      	cmp	r2, r3
 80027c2:	d001      	beq.n	80027c8 <HAL_RCC_ClockConfig+0x44>
    {
      return HAL_ERROR;
 80027c4:	2301      	movs	r3, #1
 80027c6:	e184      	b.n	8002ad2 <HAL_RCC_ClockConfig+0x34e>

  }

  /* Increasing the BUS frequency divider */
  /*-------------------------- D1PCLK1/CDPCLK1 Configuration ---------------------------*/
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_D1PCLK1) == RCC_CLOCKTYPE_D1PCLK1)
 80027c8:	687b      	ldr	r3, [r7, #4]
 80027ca:	681b      	ldr	r3, [r3, #0]
 80027cc:	f003 0304 	and.w	r3, r3, #4
 80027d0:	2b00      	cmp	r3, #0
 80027d2:	d010      	beq.n	80027f6 <HAL_RCC_ClockConfig+0x72>
  {
#if defined (RCC_D1CFGR_D1PPRE)
    if((RCC_ClkInitStruct->APB3CLKDivider) > (RCC->D1CFGR & RCC_D1CFGR_D1PPRE))
 80027d4:	687b      	ldr	r3, [r7, #4]
 80027d6:	691a      	ldr	r2, [r3, #16]
 80027d8:	4b7b      	ldr	r3, [pc, #492]	; (80029c8 <HAL_RCC_ClockConfig+0x244>)
 80027da:	699b      	ldr	r3, [r3, #24]
 80027dc:	f003 0370 	and.w	r3, r3, #112	; 0x70
 80027e0:	429a      	cmp	r2, r3
 80027e2:	d908      	bls.n	80027f6 <HAL_RCC_ClockConfig+0x72>
    {
      assert_param(IS_RCC_D1PCLK1(RCC_ClkInitStruct->APB3CLKDivider));
      MODIFY_REG(RCC->D1CFGR, RCC_D1CFGR_D1PPRE, RCC_ClkInitStruct->APB3CLKDivider);
 80027e4:	4b78      	ldr	r3, [pc, #480]	; (80029c8 <HAL_RCC_ClockConfig+0x244>)
 80027e6:	699b      	ldr	r3, [r3, #24]
 80027e8:	f023 0270 	bic.w	r2, r3, #112	; 0x70
 80027ec:	687b      	ldr	r3, [r7, #4]
 80027ee:	691b      	ldr	r3, [r3, #16]
 80027f0:	4975      	ldr	r1, [pc, #468]	; (80029c8 <HAL_RCC_ClockConfig+0x244>)
 80027f2:	4313      	orrs	r3, r2
 80027f4:	618b      	str	r3, [r1, #24]
    }
#endif
  }

  /*-------------------------- PCLK1 Configuration ---------------------------*/
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK1) == RCC_CLOCKTYPE_PCLK1)
 80027f6:	687b      	ldr	r3, [r7, #4]
 80027f8:	681b      	ldr	r3, [r3, #0]
 80027fa:	f003 0308 	and.w	r3, r3, #8
 80027fe:	2b00      	cmp	r3, #0
 8002800:	d010      	beq.n	8002824 <HAL_RCC_ClockConfig+0xa0>
  {
#if defined (RCC_D2CFGR_D2PPRE1)
    if((RCC_ClkInitStruct->APB1CLKDivider) > (RCC->D2CFGR & RCC_D2CFGR_D2PPRE1))
 8002802:	687b      	ldr	r3, [r7, #4]
 8002804:	695a      	ldr	r2, [r3, #20]
 8002806:	4b70      	ldr	r3, [pc, #448]	; (80029c8 <HAL_RCC_ClockConfig+0x244>)
 8002808:	69db      	ldr	r3, [r3, #28]
 800280a:	f003 0370 	and.w	r3, r3, #112	; 0x70
 800280e:	429a      	cmp	r2, r3
 8002810:	d908      	bls.n	8002824 <HAL_RCC_ClockConfig+0xa0>
    {
      assert_param(IS_RCC_PCLK1(RCC_ClkInitStruct->APB1CLKDivider));
      MODIFY_REG(RCC->D2CFGR, RCC_D2CFGR_D2PPRE1, (RCC_ClkInitStruct->APB1CLKDivider));
 8002812:	4b6d      	ldr	r3, [pc, #436]	; (80029c8 <HAL_RCC_ClockConfig+0x244>)
 8002814:	69db      	ldr	r3, [r3, #28]
 8002816:	f023 0270 	bic.w	r2, r3, #112	; 0x70
 800281a:	687b      	ldr	r3, [r7, #4]
 800281c:	695b      	ldr	r3, [r3, #20]
 800281e:	496a      	ldr	r1, [pc, #424]	; (80029c8 <HAL_RCC_ClockConfig+0x244>)
 8002820:	4313      	orrs	r3, r2
 8002822:	61cb      	str	r3, [r1, #28]
      MODIFY_REG(RCC->CDCFGR2, RCC_CDCFGR2_CDPPRE1, (RCC_ClkInitStruct->APB1CLKDivider));
  }
#endif
    }
  /*-------------------------- PCLK2 Configuration ---------------------------*/
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK2) == RCC_CLOCKTYPE_PCLK2)
 8002824:	687b      	ldr	r3, [r7, #4]
 8002826:	681b      	ldr	r3, [r3, #0]
 8002828:	f003 0310 	and.w	r3, r3, #16
 800282c:	2b00      	cmp	r3, #0
 800282e:	d010      	beq.n	8002852 <HAL_RCC_ClockConfig+0xce>
  {
#if defined(RCC_D2CFGR_D2PPRE2)
    if((RCC_ClkInitStruct->APB2CLKDivider) > (RCC->D2CFGR & RCC_D2CFGR_D2PPRE2))
 8002830:	687b      	ldr	r3, [r7, #4]
 8002832:	699a      	ldr	r2, [r3, #24]
 8002834:	4b64      	ldr	r3, [pc, #400]	; (80029c8 <HAL_RCC_ClockConfig+0x244>)
 8002836:	69db      	ldr	r3, [r3, #28]
 8002838:	f403 63e0 	and.w	r3, r3, #1792	; 0x700
 800283c:	429a      	cmp	r2, r3
 800283e:	d908      	bls.n	8002852 <HAL_RCC_ClockConfig+0xce>
    {
      assert_param(IS_RCC_PCLK2(RCC_ClkInitStruct->APB2CLKDivider));
      MODIFY_REG(RCC->D2CFGR, RCC_D2CFGR_D2PPRE2, (RCC_ClkInitStruct->APB2CLKDivider));
 8002840:	4b61      	ldr	r3, [pc, #388]	; (80029c8 <HAL_RCC_ClockConfig+0x244>)
 8002842:	69db      	ldr	r3, [r3, #28]
 8002844:	f423 62e0 	bic.w	r2, r3, #1792	; 0x700
 8002848:	687b      	ldr	r3, [r7, #4]
 800284a:	699b      	ldr	r3, [r3, #24]
 800284c:	495e      	ldr	r1, [pc, #376]	; (80029c8 <HAL_RCC_ClockConfig+0x244>)
 800284e:	4313      	orrs	r3, r2
 8002850:	61cb      	str	r3, [r1, #28]
    }
#endif
  }

  /*-------------------------- D3PCLK1 Configuration ---------------------------*/
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_D3PCLK1) == RCC_CLOCKTYPE_D3PCLK1)
 8002852:	687b      	ldr	r3, [r7, #4]
 8002854:	681b      	ldr	r3, [r3, #0]
 8002856:	f003 0320 	and.w	r3, r3, #32
 800285a:	2b00      	cmp	r3, #0
 800285c:	d010      	beq.n	8002880 <HAL_RCC_ClockConfig+0xfc>
  {
#if defined(RCC_D3CFGR_D3PPRE)
    if((RCC_ClkInitStruct->APB4CLKDivider) > (RCC->D3CFGR & RCC_D3CFGR_D3PPRE))
 800285e:	687b      	ldr	r3, [r7, #4]
 8002860:	69da      	ldr	r2, [r3, #28]
 8002862:	4b59      	ldr	r3, [pc, #356]	; (80029c8 <HAL_RCC_ClockConfig+0x244>)
 8002864:	6a1b      	ldr	r3, [r3, #32]
 8002866:	f003 0370 	and.w	r3, r3, #112	; 0x70
 800286a:	429a      	cmp	r2, r3
 800286c:	d908      	bls.n	8002880 <HAL_RCC_ClockConfig+0xfc>
    {
      assert_param(IS_RCC_D3PCLK1(RCC_ClkInitStruct->APB4CLKDivider));
      MODIFY_REG(RCC->D3CFGR, RCC_D3CFGR_D3PPRE, (RCC_ClkInitStruct->APB4CLKDivider) );
 800286e:	4b56      	ldr	r3, [pc, #344]	; (80029c8 <HAL_RCC_ClockConfig+0x244>)
 8002870:	6a1b      	ldr	r3, [r3, #32]
 8002872:	f023 0270 	bic.w	r2, r3, #112	; 0x70
 8002876:	687b      	ldr	r3, [r7, #4]
 8002878:	69db      	ldr	r3, [r3, #28]
 800287a:	4953      	ldr	r1, [pc, #332]	; (80029c8 <HAL_RCC_ClockConfig+0x244>)
 800287c:	4313      	orrs	r3, r2
 800287e:	620b      	str	r3, [r1, #32]
    }
#endif
  }

   /*-------------------------- HCLK Configuration --------------------------*/
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_HCLK) == RCC_CLOCKTYPE_HCLK)
 8002880:	687b      	ldr	r3, [r7, #4]
 8002882:	681b      	ldr	r3, [r3, #0]
 8002884:	f003 0302 	and.w	r3, r3, #2
 8002888:	2b00      	cmp	r3, #0
 800288a:	d010      	beq.n	80028ae <HAL_RCC_ClockConfig+0x12a>
  {
#if defined (RCC_D1CFGR_HPRE)
    if((RCC_ClkInitStruct->AHBCLKDivider) > (RCC->D1CFGR & RCC_D1CFGR_HPRE))
 800288c:	687b      	ldr	r3, [r7, #4]
 800288e:	68da      	ldr	r2, [r3, #12]
 8002890:	4b4d      	ldr	r3, [pc, #308]	; (80029c8 <HAL_RCC_ClockConfig+0x244>)
 8002892:	699b      	ldr	r3, [r3, #24]
 8002894:	f003 030f 	and.w	r3, r3, #15
 8002898:	429a      	cmp	r2, r3
 800289a:	d908      	bls.n	80028ae <HAL_RCC_ClockConfig+0x12a>
    {
      /* Set the new HCLK clock divider */
      assert_param(IS_RCC_HCLK(RCC_ClkInitStruct->AHBCLKDivider));
      MODIFY_REG(RCC->D1CFGR, RCC_D1CFGR_HPRE, RCC_ClkInitStruct->AHBCLKDivider);
 800289c:	4b4a      	ldr	r3, [pc, #296]	; (80029c8 <HAL_RCC_ClockConfig+0x244>)
 800289e:	699b      	ldr	r3, [r3, #24]
 80028a0:	f023 020f 	bic.w	r2, r3, #15
 80028a4:	687b      	ldr	r3, [r7, #4]
 80028a6:	68db      	ldr	r3, [r3, #12]
 80028a8:	4947      	ldr	r1, [pc, #284]	; (80029c8 <HAL_RCC_ClockConfig+0x244>)
 80028aa:	4313      	orrs	r3, r2
 80028ac:	618b      	str	r3, [r1, #24]
    }
#endif
  }

    /*------------------------- SYSCLK Configuration -------------------------*/
    if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_SYSCLK) == RCC_CLOCKTYPE_SYSCLK)
 80028ae:	687b      	ldr	r3, [r7, #4]
 80028b0:	681b      	ldr	r3, [r3, #0]
 80028b2:	f003 0301 	and.w	r3, r3, #1
 80028b6:	2b00      	cmp	r3, #0
 80028b8:	d055      	beq.n	8002966 <HAL_RCC_ClockConfig+0x1e2>
    {
      assert_param(IS_RCC_SYSCLK(RCC_ClkInitStruct->SYSCLKDivider));
      assert_param(IS_RCC_SYSCLKSOURCE(RCC_ClkInitStruct->SYSCLKSource));
#if defined(RCC_D1CFGR_D1CPRE)
      MODIFY_REG(RCC->D1CFGR, RCC_D1CFGR_D1CPRE, RCC_ClkInitStruct->SYSCLKDivider);
 80028ba:	4b43      	ldr	r3, [pc, #268]	; (80029c8 <HAL_RCC_ClockConfig+0x244>)
 80028bc:	699b      	ldr	r3, [r3, #24]
 80028be:	f423 6270 	bic.w	r2, r3, #3840	; 0xf00
 80028c2:	687b      	ldr	r3, [r7, #4]
 80028c4:	689b      	ldr	r3, [r3, #8]
 80028c6:	4940      	ldr	r1, [pc, #256]	; (80029c8 <HAL_RCC_ClockConfig+0x244>)
 80028c8:	4313      	orrs	r3, r2
 80028ca:	618b      	str	r3, [r1, #24]
#else
      MODIFY_REG(RCC->CDCFGR1, RCC_CDCFGR1_CDCPRE, RCC_ClkInitStruct->SYSCLKDivider);
#endif
      /* HSE is selected as System Clock Source */
      if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
 80028cc:	687b      	ldr	r3, [r7, #4]
 80028ce:	685b      	ldr	r3, [r3, #4]
 80028d0:	2b02      	cmp	r3, #2
 80028d2:	d107      	bne.n	80028e4 <HAL_RCC_ClockConfig+0x160>
      {
        /* Check the HSE ready flag */
        if(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == 0U)
 80028d4:	4b3c      	ldr	r3, [pc, #240]	; (80029c8 <HAL_RCC_ClockConfig+0x244>)
 80028d6:	681b      	ldr	r3, [r3, #0]
 80028d8:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
 80028dc:	2b00      	cmp	r3, #0
 80028de:	d121      	bne.n	8002924 <HAL_RCC_ClockConfig+0x1a0>
        {
          return HAL_ERROR;
 80028e0:	2301      	movs	r3, #1
 80028e2:	e0f6      	b.n	8002ad2 <HAL_RCC_ClockConfig+0x34e>
        }
      }
      /* PLL is selected as System Clock Source */
      else if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLCLK)
 80028e4:	687b      	ldr	r3, [r7, #4]
 80028e6:	685b      	ldr	r3, [r3, #4]
 80028e8:	2b03      	cmp	r3, #3
 80028ea:	d107      	bne.n	80028fc <HAL_RCC_ClockConfig+0x178>
      {
        /* Check the PLL ready flag */
        if(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == 0U)
 80028ec:	4b36      	ldr	r3, [pc, #216]	; (80029c8 <HAL_RCC_ClockConfig+0x244>)
 80028ee:	681b      	ldr	r3, [r3, #0]
 80028f0:	f003 7300 	and.w	r3, r3, #33554432	; 0x2000000
 80028f4:	2b00      	cmp	r3, #0
 80028f6:	d115      	bne.n	8002924 <HAL_RCC_ClockConfig+0x1a0>
        {
          return HAL_ERROR;
 80028f8:	2301      	movs	r3, #1
 80028fa:	e0ea      	b.n	8002ad2 <HAL_RCC_ClockConfig+0x34e>
        }
      }
      /* CSI is selected as System Clock Source */
      else if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_CSI)
 80028fc:	687b      	ldr	r3, [r7, #4]
 80028fe:	685b      	ldr	r3, [r3, #4]
 8002900:	2b01      	cmp	r3, #1
 8002902:	d107      	bne.n	8002914 <HAL_RCC_ClockConfig+0x190>
      {
        /* Check the PLL ready flag */
        if(__HAL_RCC_GET_FLAG(RCC_FLAG_CSIRDY) == 0U)
 8002904:	4b30      	ldr	r3, [pc, #192]	; (80029c8 <HAL_RCC_ClockConfig+0x244>)
 8002906:	681b      	ldr	r3, [r3, #0]
 8002908:	f403 7380 	and.w	r3, r3, #256	; 0x100
 800290c:	2b00      	cmp	r3, #0
 800290e:	d109      	bne.n	8002924 <HAL_RCC_ClockConfig+0x1a0>
        {
          return HAL_ERROR;
 8002910:	2301      	movs	r3, #1
 8002912:	e0de      	b.n	8002ad2 <HAL_RCC_ClockConfig+0x34e>
      }
      /* HSI is selected as System Clock Source */
      else
      {
        /* Check the HSI ready flag */
        if(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == 0U)
 8002914:	4b2c      	ldr	r3, [pc, #176]	; (80029c8 <HAL_RCC_ClockConfig+0x244>)
 8002916:	681b      	ldr	r3, [r3, #0]
 8002918:	f003 0304 	and.w	r3, r3, #4
 800291c:	2b00      	cmp	r3, #0
 800291e:	d101      	bne.n	8002924 <HAL_RCC_ClockConfig+0x1a0>
        {
          return HAL_ERROR;
 8002920:	2301      	movs	r3, #1
 8002922:	e0d6      	b.n	8002ad2 <HAL_RCC_ClockConfig+0x34e>
        }
      }
      MODIFY_REG(RCC->CFGR, RCC_CFGR_SW, RCC_ClkInitStruct->SYSCLKSource);
 8002924:	4b28      	ldr	r3, [pc, #160]	; (80029c8 <HAL_RCC_ClockConfig+0x244>)
 8002926:	691b      	ldr	r3, [r3, #16]
 8002928:	f023 0207 	bic.w	r2, r3, #7
 800292c:	687b      	ldr	r3, [r7, #4]
 800292e:	685b      	ldr	r3, [r3, #4]
 8002930:	4925      	ldr	r1, [pc, #148]	; (80029c8 <HAL_RCC_ClockConfig+0x244>)
 8002932:	4313      	orrs	r3, r2
 8002934:	610b      	str	r3, [r1, #16]

      /* Get Start Tick*/
      tickstart = HAL_GetTick();
 8002936:	f7fe feff 	bl	8001738 <HAL_GetTick>
 800293a:	6178      	str	r0, [r7, #20]

        while (__HAL_RCC_GET_SYSCLK_SOURCE() !=  (RCC_ClkInitStruct->SYSCLKSource << RCC_CFGR_SWS_Pos))
 800293c:	e00a      	b.n	8002954 <HAL_RCC_ClockConfig+0x1d0>
        {
          if((HAL_GetTick() - tickstart ) > CLOCKSWITCH_TIMEOUT_VALUE)
 800293e:	f7fe fefb 	bl	8001738 <HAL_GetTick>
 8002942:	4602      	mov	r2, r0
 8002944:	697b      	ldr	r3, [r7, #20]
 8002946:	1ad3      	subs	r3, r2, r3
 8002948:	f241 3288 	movw	r2, #5000	; 0x1388
 800294c:	4293      	cmp	r3, r2
 800294e:	d901      	bls.n	8002954 <HAL_RCC_ClockConfig+0x1d0>
          {
            return HAL_TIMEOUT;
 8002950:	2303      	movs	r3, #3
 8002952:	e0be      	b.n	8002ad2 <HAL_RCC_ClockConfig+0x34e>
        while (__HAL_RCC_GET_SYSCLK_SOURCE() !=  (RCC_ClkInitStruct->SYSCLKSource << RCC_CFGR_SWS_Pos))
 8002954:	4b1c      	ldr	r3, [pc, #112]	; (80029c8 <HAL_RCC_ClockConfig+0x244>)
 8002956:	691b      	ldr	r3, [r3, #16]
 8002958:	f003 0238 	and.w	r2, r3, #56	; 0x38
 800295c:	687b      	ldr	r3, [r7, #4]
 800295e:	685b      	ldr	r3, [r3, #4]
 8002960:	00db      	lsls	r3, r3, #3
 8002962:	429a      	cmp	r2, r3
 8002964:	d1eb      	bne.n	800293e <HAL_RCC_ClockConfig+0x1ba>

    }

    /* Decreasing the BUS frequency divider */
   /*-------------------------- HCLK Configuration --------------------------*/
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_HCLK) == RCC_CLOCKTYPE_HCLK)
 8002966:	687b      	ldr	r3, [r7, #4]
 8002968:	681b      	ldr	r3, [r3, #0]
 800296a:	f003 0302 	and.w	r3, r3, #2
 800296e:	2b00      	cmp	r3, #0
 8002970:	d010      	beq.n	8002994 <HAL_RCC_ClockConfig+0x210>
  {
#if defined(RCC_D1CFGR_HPRE)
    if((RCC_ClkInitStruct->AHBCLKDivider) < (RCC->D1CFGR & RCC_D1CFGR_HPRE))
 8002972:	687b      	ldr	r3, [r7, #4]
 8002974:	68da      	ldr	r2, [r3, #12]
 8002976:	4b14      	ldr	r3, [pc, #80]	; (80029c8 <HAL_RCC_ClockConfig+0x244>)
 8002978:	699b      	ldr	r3, [r3, #24]
 800297a:	f003 030f 	and.w	r3, r3, #15
 800297e:	429a      	cmp	r2, r3
 8002980:	d208      	bcs.n	8002994 <HAL_RCC_ClockConfig+0x210>
    {
      /* Set the new HCLK clock divider */
      assert_param(IS_RCC_HCLK(RCC_ClkInitStruct->AHBCLKDivider));
      MODIFY_REG(RCC->D1CFGR, RCC_D1CFGR_HPRE, RCC_ClkInitStruct->AHBCLKDivider);
 8002982:	4b11      	ldr	r3, [pc, #68]	; (80029c8 <HAL_RCC_ClockConfig+0x244>)
 8002984:	699b      	ldr	r3, [r3, #24]
 8002986:	f023 020f 	bic.w	r2, r3, #15
 800298a:	687b      	ldr	r3, [r7, #4]
 800298c:	68db      	ldr	r3, [r3, #12]
 800298e:	490e      	ldr	r1, [pc, #56]	; (80029c8 <HAL_RCC_ClockConfig+0x244>)
 8002990:	4313      	orrs	r3, r2
 8002992:	618b      	str	r3, [r1, #24]
    }
#endif
  }

  /* Decreasing the number of wait states because of lower CPU frequency */
  if(FLatency < __HAL_FLASH_GET_LATENCY())
 8002994:	4b0b      	ldr	r3, [pc, #44]	; (80029c4 <HAL_RCC_ClockConfig+0x240>)
 8002996:	681b      	ldr	r3, [r3, #0]
 8002998:	f003 030f 	and.w	r3, r3, #15
 800299c:	683a      	ldr	r2, [r7, #0]
 800299e:	429a      	cmp	r2, r3
 80029a0:	d214      	bcs.n	80029cc <HAL_RCC_ClockConfig+0x248>
  {
    /* Program the new number of wait states to the LATENCY bits in the FLASH_ACR register */
    __HAL_FLASH_SET_LATENCY(FLatency);
 80029a2:	4b08      	ldr	r3, [pc, #32]	; (80029c4 <HAL_RCC_ClockConfig+0x240>)
 80029a4:	681b      	ldr	r3, [r3, #0]
 80029a6:	f023 020f 	bic.w	r2, r3, #15
 80029aa:	4906      	ldr	r1, [pc, #24]	; (80029c4 <HAL_RCC_ClockConfig+0x240>)
 80029ac:	683b      	ldr	r3, [r7, #0]
 80029ae:	4313      	orrs	r3, r2
 80029b0:	600b      	str	r3, [r1, #0]

    /* Check that the new number of wait states is taken into account to access the Flash
    memory by reading the FLASH_ACR register */
    if(__HAL_FLASH_GET_LATENCY() != FLatency)
 80029b2:	4b04      	ldr	r3, [pc, #16]	; (80029c4 <HAL_RCC_ClockConfig+0x240>)
 80029b4:	681b      	ldr	r3, [r3, #0]
 80029b6:	f003 030f 	and.w	r3, r3, #15
 80029ba:	683a      	ldr	r2, [r7, #0]
 80029bc:	429a      	cmp	r2, r3
 80029be:	d005      	beq.n	80029cc <HAL_RCC_ClockConfig+0x248>
    {
      return HAL_ERROR;
 80029c0:	2301      	movs	r3, #1
 80029c2:	e086      	b.n	8002ad2 <HAL_RCC_ClockConfig+0x34e>
 80029c4:	52002000 	.word	0x52002000
 80029c8:	58024400 	.word	0x58024400
    }
 }

  /*-------------------------- D1PCLK1/CDPCLK Configuration ---------------------------*/
 if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_D1PCLK1) == RCC_CLOCKTYPE_D1PCLK1)
 80029cc:	687b      	ldr	r3, [r7, #4]
 80029ce:	681b      	ldr	r3, [r3, #0]
 80029d0:	f003 0304 	and.w	r3, r3, #4
 80029d4:	2b00      	cmp	r3, #0
 80029d6:	d010      	beq.n	80029fa <HAL_RCC_ClockConfig+0x276>
 {
#if defined(RCC_D1CFGR_D1PPRE)
   if((RCC_ClkInitStruct->APB3CLKDivider) < (RCC->D1CFGR & RCC_D1CFGR_D1PPRE))
 80029d8:	687b      	ldr	r3, [r7, #4]
 80029da:	691a      	ldr	r2, [r3, #16]
 80029dc:	4b3f      	ldr	r3, [pc, #252]	; (8002adc <HAL_RCC_ClockConfig+0x358>)
 80029de:	699b      	ldr	r3, [r3, #24]
 80029e0:	f003 0370 	and.w	r3, r3, #112	; 0x70
 80029e4:	429a      	cmp	r2, r3
 80029e6:	d208      	bcs.n	80029fa <HAL_RCC_ClockConfig+0x276>
   {
     assert_param(IS_RCC_D1PCLK1(RCC_ClkInitStruct->APB3CLKDivider));
     MODIFY_REG(RCC->D1CFGR, RCC_D1CFGR_D1PPRE, RCC_ClkInitStruct->APB3CLKDivider);
 80029e8:	4b3c      	ldr	r3, [pc, #240]	; (8002adc <HAL_RCC_ClockConfig+0x358>)
 80029ea:	699b      	ldr	r3, [r3, #24]
 80029ec:	f023 0270 	bic.w	r2, r3, #112	; 0x70
 80029f0:	687b      	ldr	r3, [r7, #4]
 80029f2:	691b      	ldr	r3, [r3, #16]
 80029f4:	4939      	ldr	r1, [pc, #228]	; (8002adc <HAL_RCC_ClockConfig+0x358>)
 80029f6:	4313      	orrs	r3, r2
 80029f8:	618b      	str	r3, [r1, #24]
   }
#endif
 }

  /*-------------------------- PCLK1 Configuration ---------------------------*/
 if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK1) == RCC_CLOCKTYPE_PCLK1)
 80029fa:	687b      	ldr	r3, [r7, #4]
 80029fc:	681b      	ldr	r3, [r3, #0]
 80029fe:	f003 0308 	and.w	r3, r3, #8
 8002a02:	2b00      	cmp	r3, #0
 8002a04:	d010      	beq.n	8002a28 <HAL_RCC_ClockConfig+0x2a4>
 {
#if defined(RCC_D2CFGR_D2PPRE1)
   if((RCC_ClkInitStruct->APB1CLKDivider) < (RCC->D2CFGR & RCC_D2CFGR_D2PPRE1))
 8002a06:	687b      	ldr	r3, [r7, #4]
 8002a08:	695a      	ldr	r2, [r3, #20]
 8002a0a:	4b34      	ldr	r3, [pc, #208]	; (8002adc <HAL_RCC_ClockConfig+0x358>)
 8002a0c:	69db      	ldr	r3, [r3, #28]
 8002a0e:	f003 0370 	and.w	r3, r3, #112	; 0x70
 8002a12:	429a      	cmp	r2, r3
 8002a14:	d208      	bcs.n	8002a28 <HAL_RCC_ClockConfig+0x2a4>
   {
     assert_param(IS_RCC_PCLK1(RCC_ClkInitStruct->APB1CLKDivider));
     MODIFY_REG(RCC->D2CFGR, RCC_D2CFGR_D2PPRE1, (RCC_ClkInitStruct->APB1CLKDivider));
 8002a16:	4b31      	ldr	r3, [pc, #196]	; (8002adc <HAL_RCC_ClockConfig+0x358>)
 8002a18:	69db      	ldr	r3, [r3, #28]
 8002a1a:	f023 0270 	bic.w	r2, r3, #112	; 0x70
 8002a1e:	687b      	ldr	r3, [r7, #4]
 8002a20:	695b      	ldr	r3, [r3, #20]
 8002a22:	492e      	ldr	r1, [pc, #184]	; (8002adc <HAL_RCC_ClockConfig+0x358>)
 8002a24:	4313      	orrs	r3, r2
 8002a26:	61cb      	str	r3, [r1, #28]
   }
#endif
 }

  /*-------------------------- PCLK2 Configuration ---------------------------*/
 if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK2) == RCC_CLOCKTYPE_PCLK2)
 8002a28:	687b      	ldr	r3, [r7, #4]
 8002a2a:	681b      	ldr	r3, [r3, #0]
 8002a2c:	f003 0310 	and.w	r3, r3, #16
 8002a30:	2b00      	cmp	r3, #0
 8002a32:	d010      	beq.n	8002a56 <HAL_RCC_ClockConfig+0x2d2>
 {
#if defined (RCC_D2CFGR_D2PPRE2)
   if((RCC_ClkInitStruct->APB2CLKDivider) < (RCC->D2CFGR & RCC_D2CFGR_D2PPRE2))
 8002a34:	687b      	ldr	r3, [r7, #4]
 8002a36:	699a      	ldr	r2, [r3, #24]
 8002a38:	4b28      	ldr	r3, [pc, #160]	; (8002adc <HAL_RCC_ClockConfig+0x358>)
 8002a3a:	69db      	ldr	r3, [r3, #28]
 8002a3c:	f403 63e0 	and.w	r3, r3, #1792	; 0x700
 8002a40:	429a      	cmp	r2, r3
 8002a42:	d208      	bcs.n	8002a56 <HAL_RCC_ClockConfig+0x2d2>
   {
     assert_param(IS_RCC_PCLK2(RCC_ClkInitStruct->APB2CLKDivider));
     MODIFY_REG(RCC->D2CFGR, RCC_D2CFGR_D2PPRE2, (RCC_ClkInitStruct->APB2CLKDivider));
 8002a44:	4b25      	ldr	r3, [pc, #148]	; (8002adc <HAL_RCC_ClockConfig+0x358>)
 8002a46:	69db      	ldr	r3, [r3, #28]
 8002a48:	f423 62e0 	bic.w	r2, r3, #1792	; 0x700
 8002a4c:	687b      	ldr	r3, [r7, #4]
 8002a4e:	699b      	ldr	r3, [r3, #24]
 8002a50:	4922      	ldr	r1, [pc, #136]	; (8002adc <HAL_RCC_ClockConfig+0x358>)
 8002a52:	4313      	orrs	r3, r2
 8002a54:	61cb      	str	r3, [r1, #28]
   }
#endif
 }

  /*-------------------------- D3PCLK1/SRDPCLK1 Configuration ---------------------------*/
 if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_D3PCLK1) == RCC_CLOCKTYPE_D3PCLK1)
 8002a56:	687b      	ldr	r3, [r7, #4]
 8002a58:	681b      	ldr	r3, [r3, #0]
 8002a5a:	f003 0320 	and.w	r3, r3, #32
 8002a5e:	2b00      	cmp	r3, #0
 8002a60:	d010      	beq.n	8002a84 <HAL_RCC_ClockConfig+0x300>
 {
#if defined(RCC_D3CFGR_D3PPRE)
   if((RCC_ClkInitStruct->APB4CLKDivider) < (RCC->D3CFGR & RCC_D3CFGR_D3PPRE))
 8002a62:	687b      	ldr	r3, [r7, #4]
 8002a64:	69da      	ldr	r2, [r3, #28]
 8002a66:	4b1d      	ldr	r3, [pc, #116]	; (8002adc <HAL_RCC_ClockConfig+0x358>)
 8002a68:	6a1b      	ldr	r3, [r3, #32]
 8002a6a:	f003 0370 	and.w	r3, r3, #112	; 0x70
 8002a6e:	429a      	cmp	r2, r3
 8002a70:	d208      	bcs.n	8002a84 <HAL_RCC_ClockConfig+0x300>
   {
     assert_param(IS_RCC_D3PCLK1(RCC_ClkInitStruct->APB4CLKDivider));
     MODIFY_REG(RCC->D3CFGR, RCC_D3CFGR_D3PPRE, (RCC_ClkInitStruct->APB4CLKDivider) );
 8002a72:	4b1a      	ldr	r3, [pc, #104]	; (8002adc <HAL_RCC_ClockConfig+0x358>)
 8002a74:	6a1b      	ldr	r3, [r3, #32]
 8002a76:	f023 0270 	bic.w	r2, r3, #112	; 0x70
 8002a7a:	687b      	ldr	r3, [r7, #4]
 8002a7c:	69db      	ldr	r3, [r3, #28]
 8002a7e:	4917      	ldr	r1, [pc, #92]	; (8002adc <HAL_RCC_ClockConfig+0x358>)
 8002a80:	4313      	orrs	r3, r2
 8002a82:	620b      	str	r3, [r1, #32]
#endif
 }

  /* Update the SystemCoreClock global variable */
#if defined(RCC_D1CFGR_D1CPRE)
  common_system_clock = HAL_RCC_GetSysClockFreq() >> ((D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_D1CPRE)>> RCC_D1CFGR_D1CPRE_Pos]) & 0x1FU);
 8002a84:	f000 f834 	bl	8002af0 <HAL_RCC_GetSysClockFreq>
 8002a88:	4602      	mov	r2, r0
 8002a8a:	4b14      	ldr	r3, [pc, #80]	; (8002adc <HAL_RCC_ClockConfig+0x358>)
 8002a8c:	699b      	ldr	r3, [r3, #24]
 8002a8e:	0a1b      	lsrs	r3, r3, #8
 8002a90:	f003 030f 	and.w	r3, r3, #15
 8002a94:	4912      	ldr	r1, [pc, #72]	; (8002ae0 <HAL_RCC_ClockConfig+0x35c>)
 8002a96:	5ccb      	ldrb	r3, [r1, r3]
 8002a98:	f003 031f 	and.w	r3, r3, #31
 8002a9c:	fa22 f303 	lsr.w	r3, r2, r3
 8002aa0:	613b      	str	r3, [r7, #16]
#else
  common_system_clock = HAL_RCC_GetSysClockFreq() >> ((D1CorePrescTable[(RCC->CDCFGR1 & RCC_CDCFGR1_CDCPRE)>> RCC_CDCFGR1_CDCPRE_Pos]) & 0x1FU);
#endif

#if defined(RCC_D1CFGR_HPRE)
  SystemD2Clock = (common_system_clock >> ((D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_HPRE)>> RCC_D1CFGR_HPRE_Pos]) & 0x1FU));
 8002aa2:	4b0e      	ldr	r3, [pc, #56]	; (8002adc <HAL_RCC_ClockConfig+0x358>)
 8002aa4:	699b      	ldr	r3, [r3, #24]
 8002aa6:	f003 030f 	and.w	r3, r3, #15
 8002aaa:	4a0d      	ldr	r2, [pc, #52]	; (8002ae0 <HAL_RCC_ClockConfig+0x35c>)
 8002aac:	5cd3      	ldrb	r3, [r2, r3]
 8002aae:	f003 031f 	and.w	r3, r3, #31
 8002ab2:	693a      	ldr	r2, [r7, #16]
 8002ab4:	fa22 f303 	lsr.w	r3, r2, r3
 8002ab8:	4a0a      	ldr	r2, [pc, #40]	; (8002ae4 <HAL_RCC_ClockConfig+0x360>)
 8002aba:	6013      	str	r3, [r2, #0]
#endif

#if defined(DUAL_CORE) && defined(CORE_CM4)
  SystemCoreClock = SystemD2Clock;
#else
  SystemCoreClock = common_system_clock;
 8002abc:	4a0a      	ldr	r2, [pc, #40]	; (8002ae8 <HAL_RCC_ClockConfig+0x364>)
 8002abe:	693b      	ldr	r3, [r7, #16]
 8002ac0:	6013      	str	r3, [r2, #0]
#endif /* DUAL_CORE && CORE_CM4 */

  /* Configure the source of time base considering new system clocks settings*/
  halstatus = HAL_InitTick (uwTickPrio);
 8002ac2:	4b0a      	ldr	r3, [pc, #40]	; (8002aec <HAL_RCC_ClockConfig+0x368>)
 8002ac4:	681b      	ldr	r3, [r3, #0]
 8002ac6:	4618      	mov	r0, r3
 8002ac8:	f7fe faf2 	bl	80010b0 <HAL_InitTick>
 8002acc:	4603      	mov	r3, r0
 8002ace:	73fb      	strb	r3, [r7, #15]

  return halstatus;
 8002ad0:	7bfb      	ldrb	r3, [r7, #15]
}
 8002ad2:	4618      	mov	r0, r3
 8002ad4:	3718      	adds	r7, #24
 8002ad6:	46bd      	mov	sp, r7
 8002ad8:	bd80      	pop	{r7, pc}
 8002ada:	bf00      	nop
 8002adc:	58024400 	.word	0x58024400
 8002ae0:	0802621c 	.word	0x0802621c
 8002ae4:	24000004 	.word	0x24000004
 8002ae8:	24000000 	.word	0x24000000
 8002aec:	24000008 	.word	0x24000008

08002af0 <HAL_RCC_GetSysClockFreq>:
  *
  *
  * @retval SYSCLK frequency
  */
uint32_t HAL_RCC_GetSysClockFreq(void)
{
 8002af0:	b480      	push	{r7}
 8002af2:	b089      	sub	sp, #36	; 0x24
 8002af4:	af00      	add	r7, sp, #0
  float_t fracn1, pllvco;
  uint32_t sysclockfreq;

  /* Get SYSCLK source -------------------------------------------------------*/

  switch (RCC->CFGR & RCC_CFGR_SWS)
 8002af6:	4bb3      	ldr	r3, [pc, #716]	; (8002dc4 <HAL_RCC_GetSysClockFreq+0x2d4>)
 8002af8:	691b      	ldr	r3, [r3, #16]
 8002afa:	f003 0338 	and.w	r3, r3, #56	; 0x38
 8002afe:	2b18      	cmp	r3, #24
 8002b00:	f200 8155 	bhi.w	8002dae <HAL_RCC_GetSysClockFreq+0x2be>
 8002b04:	a201      	add	r2, pc, #4	; (adr r2, 8002b0c <HAL_RCC_GetSysClockFreq+0x1c>)
 8002b06:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8002b0a:	bf00      	nop
 8002b0c:	08002b71 	.word	0x08002b71
 8002b10:	08002daf 	.word	0x08002daf
 8002b14:	08002daf 	.word	0x08002daf
 8002b18:	08002daf 	.word	0x08002daf
 8002b1c:	08002daf 	.word	0x08002daf
 8002b20:	08002daf 	.word	0x08002daf
 8002b24:	08002daf 	.word	0x08002daf
 8002b28:	08002daf 	.word	0x08002daf
 8002b2c:	08002b97 	.word	0x08002b97
 8002b30:	08002daf 	.word	0x08002daf
 8002b34:	08002daf 	.word	0x08002daf
 8002b38:	08002daf 	.word	0x08002daf
 8002b3c:	08002daf 	.word	0x08002daf
 8002b40:	08002daf 	.word	0x08002daf
 8002b44:	08002daf 	.word	0x08002daf
 8002b48:	08002daf 	.word	0x08002daf
 8002b4c:	08002b9d 	.word	0x08002b9d
 8002b50:	08002daf 	.word	0x08002daf
 8002b54:	08002daf 	.word	0x08002daf
 8002b58:	08002daf 	.word	0x08002daf
 8002b5c:	08002daf 	.word	0x08002daf
 8002b60:	08002daf 	.word	0x08002daf
 8002b64:	08002daf 	.word	0x08002daf
 8002b68:	08002daf 	.word	0x08002daf
 8002b6c:	08002ba3 	.word	0x08002ba3
  {
  case RCC_CFGR_SWS_HSI:  /* HSI used as system clock source */

   if (__HAL_RCC_GET_FLAG(RCC_FLAG_HSIDIV) != 0U)
 8002b70:	4b94      	ldr	r3, [pc, #592]	; (8002dc4 <HAL_RCC_GetSysClockFreq+0x2d4>)
 8002b72:	681b      	ldr	r3, [r3, #0]
 8002b74:	f003 0320 	and.w	r3, r3, #32
 8002b78:	2b00      	cmp	r3, #0
 8002b7a:	d009      	beq.n	8002b90 <HAL_RCC_GetSysClockFreq+0xa0>
      {
        sysclockfreq = (uint32_t) (HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER()>> 3));
 8002b7c:	4b91      	ldr	r3, [pc, #580]	; (8002dc4 <HAL_RCC_GetSysClockFreq+0x2d4>)
 8002b7e:	681b      	ldr	r3, [r3, #0]
 8002b80:	08db      	lsrs	r3, r3, #3
 8002b82:	f003 0303 	and.w	r3, r3, #3
 8002b86:	4a90      	ldr	r2, [pc, #576]	; (8002dc8 <HAL_RCC_GetSysClockFreq+0x2d8>)
 8002b88:	fa22 f303 	lsr.w	r3, r2, r3
 8002b8c:	61bb      	str	r3, [r7, #24]
      else
      {
        sysclockfreq = (uint32_t) HSI_VALUE;
      }

    break;
 8002b8e:	e111      	b.n	8002db4 <HAL_RCC_GetSysClockFreq+0x2c4>
        sysclockfreq = (uint32_t) HSI_VALUE;
 8002b90:	4b8d      	ldr	r3, [pc, #564]	; (8002dc8 <HAL_RCC_GetSysClockFreq+0x2d8>)
 8002b92:	61bb      	str	r3, [r7, #24]
    break;
 8002b94:	e10e      	b.n	8002db4 <HAL_RCC_GetSysClockFreq+0x2c4>

  case RCC_CFGR_SWS_CSI:  /* CSI used as system clock  source */
    sysclockfreq = CSI_VALUE;
 8002b96:	4b8d      	ldr	r3, [pc, #564]	; (8002dcc <HAL_RCC_GetSysClockFreq+0x2dc>)
 8002b98:	61bb      	str	r3, [r7, #24]
    break;
 8002b9a:	e10b      	b.n	8002db4 <HAL_RCC_GetSysClockFreq+0x2c4>

  case RCC_CFGR_SWS_HSE:  /* HSE used as system clock  source */
    sysclockfreq = HSE_VALUE;
 8002b9c:	4b8c      	ldr	r3, [pc, #560]	; (8002dd0 <HAL_RCC_GetSysClockFreq+0x2e0>)
 8002b9e:	61bb      	str	r3, [r7, #24]
    break;
 8002ba0:	e108      	b.n	8002db4 <HAL_RCC_GetSysClockFreq+0x2c4>
  case RCC_CFGR_SWS_PLL1:  /* PLL1 used as system clock  source */

    /* PLL_VCO = (HSE_VALUE or HSI_VALUE or CSI_VALUE/ PLLM) * PLLN
    SYSCLK = PLL_VCO / PLLR
    */
    pllsource = (RCC->PLLCKSELR & RCC_PLLCKSELR_PLLSRC);
 8002ba2:	4b88      	ldr	r3, [pc, #544]	; (8002dc4 <HAL_RCC_GetSysClockFreq+0x2d4>)
 8002ba4:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8002ba6:	f003 0303 	and.w	r3, r3, #3
 8002baa:	617b      	str	r3, [r7, #20]
    pllm = ((RCC->PLLCKSELR & RCC_PLLCKSELR_DIVM1)>> 4)  ;
 8002bac:	4b85      	ldr	r3, [pc, #532]	; (8002dc4 <HAL_RCC_GetSysClockFreq+0x2d4>)
 8002bae:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8002bb0:	091b      	lsrs	r3, r3, #4
 8002bb2:	f003 033f 	and.w	r3, r3, #63	; 0x3f
 8002bb6:	613b      	str	r3, [r7, #16]
    pllfracen = ((RCC-> PLLCFGR & RCC_PLLCFGR_PLL1FRACEN)>>RCC_PLLCFGR_PLL1FRACEN_Pos);
 8002bb8:	4b82      	ldr	r3, [pc, #520]	; (8002dc4 <HAL_RCC_GetSysClockFreq+0x2d4>)
 8002bba:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8002bbc:	f003 0301 	and.w	r3, r3, #1
 8002bc0:	60fb      	str	r3, [r7, #12]
    fracn1 = (float_t)(uint32_t)(pllfracen* ((RCC->PLL1FRACR & RCC_PLL1FRACR_FRACN1)>> 3));
 8002bc2:	4b80      	ldr	r3, [pc, #512]	; (8002dc4 <HAL_RCC_GetSysClockFreq+0x2d4>)
 8002bc4:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8002bc6:	08db      	lsrs	r3, r3, #3
 8002bc8:	f3c3 030c 	ubfx	r3, r3, #0, #13
 8002bcc:	68fa      	ldr	r2, [r7, #12]
 8002bce:	fb02 f303 	mul.w	r3, r2, r3
 8002bd2:	ee07 3a90 	vmov	s15, r3
 8002bd6:	eef8 7a67 	vcvt.f32.u32	s15, s15
 8002bda:	edc7 7a02 	vstr	s15, [r7, #8]

    if (pllm != 0U)
 8002bde:	693b      	ldr	r3, [r7, #16]
 8002be0:	2b00      	cmp	r3, #0
 8002be2:	f000 80e1 	beq.w	8002da8 <HAL_RCC_GetSysClockFreq+0x2b8>
 8002be6:	697b      	ldr	r3, [r7, #20]
 8002be8:	2b02      	cmp	r3, #2
 8002bea:	f000 8083 	beq.w	8002cf4 <HAL_RCC_GetSysClockFreq+0x204>
 8002bee:	697b      	ldr	r3, [r7, #20]
 8002bf0:	2b02      	cmp	r3, #2
 8002bf2:	f200 80a1 	bhi.w	8002d38 <HAL_RCC_GetSysClockFreq+0x248>
 8002bf6:	697b      	ldr	r3, [r7, #20]
 8002bf8:	2b00      	cmp	r3, #0
 8002bfa:	d003      	beq.n	8002c04 <HAL_RCC_GetSysClockFreq+0x114>
 8002bfc:	697b      	ldr	r3, [r7, #20]
 8002bfe:	2b01      	cmp	r3, #1
 8002c00:	d056      	beq.n	8002cb0 <HAL_RCC_GetSysClockFreq+0x1c0>
 8002c02:	e099      	b.n	8002d38 <HAL_RCC_GetSysClockFreq+0x248>
    {
      switch (pllsource)
      {
      case RCC_PLLSOURCE_HSI:  /* HSI used as PLL clock source */

       if (__HAL_RCC_GET_FLAG(RCC_FLAG_HSIDIV) != 0U)
 8002c04:	4b6f      	ldr	r3, [pc, #444]	; (8002dc4 <HAL_RCC_GetSysClockFreq+0x2d4>)
 8002c06:	681b      	ldr	r3, [r3, #0]
 8002c08:	f003 0320 	and.w	r3, r3, #32
 8002c0c:	2b00      	cmp	r3, #0
 8002c0e:	d02d      	beq.n	8002c6c <HAL_RCC_GetSysClockFreq+0x17c>
        {
          hsivalue= (HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER()>> 3));
 8002c10:	4b6c      	ldr	r3, [pc, #432]	; (8002dc4 <HAL_RCC_GetSysClockFreq+0x2d4>)
 8002c12:	681b      	ldr	r3, [r3, #0]
 8002c14:	08db      	lsrs	r3, r3, #3
 8002c16:	f003 0303 	and.w	r3, r3, #3
 8002c1a:	4a6b      	ldr	r2, [pc, #428]	; (8002dc8 <HAL_RCC_GetSysClockFreq+0x2d8>)
 8002c1c:	fa22 f303 	lsr.w	r3, r2, r3
 8002c20:	607b      	str	r3, [r7, #4]
          pllvco = ( (float_t)hsivalue / (float_t)pllm) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_N1) + (fracn1/(float_t)0x2000) +(float_t)1 );
 8002c22:	687b      	ldr	r3, [r7, #4]
 8002c24:	ee07 3a90 	vmov	s15, r3
 8002c28:	eef8 6a67 	vcvt.f32.u32	s13, s15
 8002c2c:	693b      	ldr	r3, [r7, #16]
 8002c2e:	ee07 3a90 	vmov	s15, r3
 8002c32:	eef8 7a67 	vcvt.f32.u32	s15, s15
 8002c36:	ee86 7aa7 	vdiv.f32	s14, s13, s15
 8002c3a:	4b62      	ldr	r3, [pc, #392]	; (8002dc4 <HAL_RCC_GetSysClockFreq+0x2d4>)
 8002c3c:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8002c3e:	f3c3 0308 	ubfx	r3, r3, #0, #9
 8002c42:	ee07 3a90 	vmov	s15, r3
 8002c46:	eef8 6a67 	vcvt.f32.u32	s13, s15
 8002c4a:	ed97 6a02 	vldr	s12, [r7, #8]
 8002c4e:	eddf 5a61 	vldr	s11, [pc, #388]	; 8002dd4 <HAL_RCC_GetSysClockFreq+0x2e4>
 8002c52:	eec6 7a25 	vdiv.f32	s15, s12, s11
 8002c56:	ee76 7aa7 	vadd.f32	s15, s13, s15
 8002c5a:	eef7 6a00 	vmov.f32	s13, #112	; 0x3f800000  1.0
 8002c5e:	ee77 7aa6 	vadd.f32	s15, s15, s13
 8002c62:	ee67 7a27 	vmul.f32	s15, s14, s15
 8002c66:	edc7 7a07 	vstr	s15, [r7, #28]
        }
        else
        {
          pllvco = ((float_t)HSI_VALUE / (float_t)pllm) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_N1) + (fracn1/(float_t)0x2000) +(float_t)1 );
        }
        break;
 8002c6a:	e087      	b.n	8002d7c <HAL_RCC_GetSysClockFreq+0x28c>
          pllvco = ((float_t)HSI_VALUE / (float_t)pllm) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_N1) + (fracn1/(float_t)0x2000) +(float_t)1 );
 8002c6c:	693b      	ldr	r3, [r7, #16]
 8002c6e:	ee07 3a90 	vmov	s15, r3
 8002c72:	eef8 7a67 	vcvt.f32.u32	s15, s15
 8002c76:	eddf 6a58 	vldr	s13, [pc, #352]	; 8002dd8 <HAL_RCC_GetSysClockFreq+0x2e8>
 8002c7a:	ee86 7aa7 	vdiv.f32	s14, s13, s15
 8002c7e:	4b51      	ldr	r3, [pc, #324]	; (8002dc4 <HAL_RCC_GetSysClockFreq+0x2d4>)
 8002c80:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8002c82:	f3c3 0308 	ubfx	r3, r3, #0, #9
 8002c86:	ee07 3a90 	vmov	s15, r3
 8002c8a:	eef8 6a67 	vcvt.f32.u32	s13, s15
 8002c8e:	ed97 6a02 	vldr	s12, [r7, #8]
 8002c92:	eddf 5a50 	vldr	s11, [pc, #320]	; 8002dd4 <HAL_RCC_GetSysClockFreq+0x2e4>
 8002c96:	eec6 7a25 	vdiv.f32	s15, s12, s11
 8002c9a:	ee76 7aa7 	vadd.f32	s15, s13, s15
 8002c9e:	eef7 6a00 	vmov.f32	s13, #112	; 0x3f800000  1.0
 8002ca2:	ee77 7aa6 	vadd.f32	s15, s15, s13
 8002ca6:	ee67 7a27 	vmul.f32	s15, s14, s15
 8002caa:	edc7 7a07 	vstr	s15, [r7, #28]
        break;
 8002cae:	e065      	b.n	8002d7c <HAL_RCC_GetSysClockFreq+0x28c>

      case RCC_PLLSOURCE_CSI:  /* CSI used as PLL clock source */
        pllvco = ((float_t)CSI_VALUE / (float_t)pllm) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_N1) + (fracn1/(float_t)0x2000) +(float_t)1 );
 8002cb0:	693b      	ldr	r3, [r7, #16]
 8002cb2:	ee07 3a90 	vmov	s15, r3
 8002cb6:	eef8 7a67 	vcvt.f32.u32	s15, s15
 8002cba:	eddf 6a48 	vldr	s13, [pc, #288]	; 8002ddc <HAL_RCC_GetSysClockFreq+0x2ec>
 8002cbe:	ee86 7aa7 	vdiv.f32	s14, s13, s15
 8002cc2:	4b40      	ldr	r3, [pc, #256]	; (8002dc4 <HAL_RCC_GetSysClockFreq+0x2d4>)
 8002cc4:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8002cc6:	f3c3 0308 	ubfx	r3, r3, #0, #9
 8002cca:	ee07 3a90 	vmov	s15, r3
 8002cce:	eef8 6a67 	vcvt.f32.u32	s13, s15
 8002cd2:	ed97 6a02 	vldr	s12, [r7, #8]
 8002cd6:	eddf 5a3f 	vldr	s11, [pc, #252]	; 8002dd4 <HAL_RCC_GetSysClockFreq+0x2e4>
 8002cda:	eec6 7a25 	vdiv.f32	s15, s12, s11
 8002cde:	ee76 7aa7 	vadd.f32	s15, s13, s15
 8002ce2:	eef7 6a00 	vmov.f32	s13, #112	; 0x3f800000  1.0
 8002ce6:	ee77 7aa6 	vadd.f32	s15, s15, s13
 8002cea:	ee67 7a27 	vmul.f32	s15, s14, s15
 8002cee:	edc7 7a07 	vstr	s15, [r7, #28]
        break;
 8002cf2:	e043      	b.n	8002d7c <HAL_RCC_GetSysClockFreq+0x28c>

      case RCC_PLLSOURCE_HSE:  /* HSE used as PLL clock source */
        pllvco = ((float_t)HSE_VALUE / (float_t)pllm) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_N1) + (fracn1/(float_t)0x2000) +(float_t)1 );
 8002cf4:	693b      	ldr	r3, [r7, #16]
 8002cf6:	ee07 3a90 	vmov	s15, r3
 8002cfa:	eef8 7a67 	vcvt.f32.u32	s15, s15
 8002cfe:	eddf 6a38 	vldr	s13, [pc, #224]	; 8002de0 <HAL_RCC_GetSysClockFreq+0x2f0>
 8002d02:	ee86 7aa7 	vdiv.f32	s14, s13, s15
 8002d06:	4b2f      	ldr	r3, [pc, #188]	; (8002dc4 <HAL_RCC_GetSysClockFreq+0x2d4>)
 8002d08:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8002d0a:	f3c3 0308 	ubfx	r3, r3, #0, #9
 8002d0e:	ee07 3a90 	vmov	s15, r3
 8002d12:	eef8 6a67 	vcvt.f32.u32	s13, s15
 8002d16:	ed97 6a02 	vldr	s12, [r7, #8]
 8002d1a:	eddf 5a2e 	vldr	s11, [pc, #184]	; 8002dd4 <HAL_RCC_GetSysClockFreq+0x2e4>
 8002d1e:	eec6 7a25 	vdiv.f32	s15, s12, s11
 8002d22:	ee76 7aa7 	vadd.f32	s15, s13, s15
 8002d26:	eef7 6a00 	vmov.f32	s13, #112	; 0x3f800000  1.0
 8002d2a:	ee77 7aa6 	vadd.f32	s15, s15, s13
 8002d2e:	ee67 7a27 	vmul.f32	s15, s14, s15
 8002d32:	edc7 7a07 	vstr	s15, [r7, #28]
        break;
 8002d36:	e021      	b.n	8002d7c <HAL_RCC_GetSysClockFreq+0x28c>

      default:
        pllvco = ((float_t)CSI_VALUE / (float_t)pllm) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_N1) + (fracn1/(float_t)0x2000) +(float_t)1 );
 8002d38:	693b      	ldr	r3, [r7, #16]
 8002d3a:	ee07 3a90 	vmov	s15, r3
 8002d3e:	eef8 7a67 	vcvt.f32.u32	s15, s15
 8002d42:	eddf 6a26 	vldr	s13, [pc, #152]	; 8002ddc <HAL_RCC_GetSysClockFreq+0x2ec>
 8002d46:	ee86 7aa7 	vdiv.f32	s14, s13, s15
 8002d4a:	4b1e      	ldr	r3, [pc, #120]	; (8002dc4 <HAL_RCC_GetSysClockFreq+0x2d4>)
 8002d4c:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8002d4e:	f3c3 0308 	ubfx	r3, r3, #0, #9
 8002d52:	ee07 3a90 	vmov	s15, r3
 8002d56:	eef8 6a67 	vcvt.f32.u32	s13, s15
 8002d5a:	ed97 6a02 	vldr	s12, [r7, #8]
 8002d5e:	eddf 5a1d 	vldr	s11, [pc, #116]	; 8002dd4 <HAL_RCC_GetSysClockFreq+0x2e4>
 8002d62:	eec6 7a25 	vdiv.f32	s15, s12, s11
 8002d66:	ee76 7aa7 	vadd.f32	s15, s13, s15
 8002d6a:	eef7 6a00 	vmov.f32	s13, #112	; 0x3f800000  1.0
 8002d6e:	ee77 7aa6 	vadd.f32	s15, s15, s13
 8002d72:	ee67 7a27 	vmul.f32	s15, s14, s15
 8002d76:	edc7 7a07 	vstr	s15, [r7, #28]
        break;
 8002d7a:	bf00      	nop
      }
      pllp = (((RCC->PLL1DIVR & RCC_PLL1DIVR_P1) >>9) + 1U ) ;
 8002d7c:	4b11      	ldr	r3, [pc, #68]	; (8002dc4 <HAL_RCC_GetSysClockFreq+0x2d4>)
 8002d7e:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8002d80:	0a5b      	lsrs	r3, r3, #9
 8002d82:	f003 037f 	and.w	r3, r3, #127	; 0x7f
 8002d86:	3301      	adds	r3, #1
 8002d88:	603b      	str	r3, [r7, #0]
      sysclockfreq =  (uint32_t)(float_t)(pllvco/(float_t)pllp);
 8002d8a:	683b      	ldr	r3, [r7, #0]
 8002d8c:	ee07 3a90 	vmov	s15, r3
 8002d90:	eeb8 7a67 	vcvt.f32.u32	s14, s15
 8002d94:	edd7 6a07 	vldr	s13, [r7, #28]
 8002d98:	eec6 7a87 	vdiv.f32	s15, s13, s14
 8002d9c:	eefc 7ae7 	vcvt.u32.f32	s15, s15
 8002da0:	ee17 3a90 	vmov	r3, s15
 8002da4:	61bb      	str	r3, [r7, #24]
    }
    else
    {
      sysclockfreq = 0U;
    }
    break;
 8002da6:	e005      	b.n	8002db4 <HAL_RCC_GetSysClockFreq+0x2c4>
      sysclockfreq = 0U;
 8002da8:	2300      	movs	r3, #0
 8002daa:	61bb      	str	r3, [r7, #24]
    break;
 8002dac:	e002      	b.n	8002db4 <HAL_RCC_GetSysClockFreq+0x2c4>

  default:
    sysclockfreq = CSI_VALUE;
 8002dae:	4b07      	ldr	r3, [pc, #28]	; (8002dcc <HAL_RCC_GetSysClockFreq+0x2dc>)
 8002db0:	61bb      	str	r3, [r7, #24]
    break;
 8002db2:	bf00      	nop
  }

  return sysclockfreq;
 8002db4:	69bb      	ldr	r3, [r7, #24]
}
 8002db6:	4618      	mov	r0, r3
 8002db8:	3724      	adds	r7, #36	; 0x24
 8002dba:	46bd      	mov	sp, r7
 8002dbc:	f85d 7b04 	ldr.w	r7, [sp], #4
 8002dc0:	4770      	bx	lr
 8002dc2:	bf00      	nop
 8002dc4:	58024400 	.word	0x58024400
 8002dc8:	03d09000 	.word	0x03d09000
 8002dcc:	003d0900 	.word	0x003d0900
 8002dd0:	017d7840 	.word	0x017d7840
 8002dd4:	46000000 	.word	0x46000000
 8002dd8:	4c742400 	.word	0x4c742400
 8002ddc:	4a742400 	.word	0x4a742400
 8002de0:	4bbebc20 	.word	0x4bbebc20

08002de4 <HAL_RCC_GetHCLKFreq>:
  * @note   The SystemD2Clock CMSIS variable is used to store System domain2 Clock Frequency
  *         and updated within this function
  * @retval HCLK frequency
  */
uint32_t HAL_RCC_GetHCLKFreq(void)
{
 8002de4:	b580      	push	{r7, lr}
 8002de6:	b082      	sub	sp, #8
 8002de8:	af00      	add	r7, sp, #0
uint32_t common_system_clock;

#if defined(RCC_D1CFGR_D1CPRE)
  common_system_clock = HAL_RCC_GetSysClockFreq() >> (D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_D1CPRE)>> RCC_D1CFGR_D1CPRE_Pos] & 0x1FU);
 8002dea:	f7ff fe81 	bl	8002af0 <HAL_RCC_GetSysClockFreq>
 8002dee:	4602      	mov	r2, r0
 8002df0:	4b10      	ldr	r3, [pc, #64]	; (8002e34 <HAL_RCC_GetHCLKFreq+0x50>)
 8002df2:	699b      	ldr	r3, [r3, #24]
 8002df4:	0a1b      	lsrs	r3, r3, #8
 8002df6:	f003 030f 	and.w	r3, r3, #15
 8002dfa:	490f      	ldr	r1, [pc, #60]	; (8002e38 <HAL_RCC_GetHCLKFreq+0x54>)
 8002dfc:	5ccb      	ldrb	r3, [r1, r3]
 8002dfe:	f003 031f 	and.w	r3, r3, #31
 8002e02:	fa22 f303 	lsr.w	r3, r2, r3
 8002e06:	607b      	str	r3, [r7, #4]
#else
  common_system_clock = HAL_RCC_GetSysClockFreq() >> (D1CorePrescTable[(RCC->CDCFGR1 & RCC_CDCFGR1_CDCPRE)>> RCC_CDCFGR1_CDCPRE_Pos] & 0x1FU);
#endif

#if defined(RCC_D1CFGR_HPRE)
  SystemD2Clock = (common_system_clock >> ((D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_HPRE)>> RCC_D1CFGR_HPRE_Pos]) & 0x1FU));
 8002e08:	4b0a      	ldr	r3, [pc, #40]	; (8002e34 <HAL_RCC_GetHCLKFreq+0x50>)
 8002e0a:	699b      	ldr	r3, [r3, #24]
 8002e0c:	f003 030f 	and.w	r3, r3, #15
 8002e10:	4a09      	ldr	r2, [pc, #36]	; (8002e38 <HAL_RCC_GetHCLKFreq+0x54>)
 8002e12:	5cd3      	ldrb	r3, [r2, r3]
 8002e14:	f003 031f 	and.w	r3, r3, #31
 8002e18:	687a      	ldr	r2, [r7, #4]
 8002e1a:	fa22 f303 	lsr.w	r3, r2, r3
 8002e1e:	4a07      	ldr	r2, [pc, #28]	; (8002e3c <HAL_RCC_GetHCLKFreq+0x58>)
 8002e20:	6013      	str	r3, [r2, #0]
#endif

#if defined(DUAL_CORE) && defined(CORE_CM4)
  SystemCoreClock = SystemD2Clock;
#else
  SystemCoreClock = common_system_clock;
 8002e22:	4a07      	ldr	r2, [pc, #28]	; (8002e40 <HAL_RCC_GetHCLKFreq+0x5c>)
 8002e24:	687b      	ldr	r3, [r7, #4]
 8002e26:	6013      	str	r3, [r2, #0]
#endif /* DUAL_CORE && CORE_CM4 */

  return SystemD2Clock;
 8002e28:	4b04      	ldr	r3, [pc, #16]	; (8002e3c <HAL_RCC_GetHCLKFreq+0x58>)
 8002e2a:	681b      	ldr	r3, [r3, #0]
}
 8002e2c:	4618      	mov	r0, r3
 8002e2e:	3708      	adds	r7, #8
 8002e30:	46bd      	mov	sp, r7
 8002e32:	bd80      	pop	{r7, pc}
 8002e34:	58024400 	.word	0x58024400
 8002e38:	0802621c 	.word	0x0802621c
 8002e3c:	24000004 	.word	0x24000004
 8002e40:	24000000 	.word	0x24000000

08002e44 <HAL_RCC_GetPCLK1Freq>:
  * @note   Each time PCLK1 changes, this function must be called to update the
  *         right PCLK1 value. Otherwise, any configuration based on this function will be incorrect.
  * @retval PCLK1 frequency
  */
uint32_t HAL_RCC_GetPCLK1Freq(void)
{
 8002e44:	b580      	push	{r7, lr}
 8002e46:	af00      	add	r7, sp, #0
#if defined (RCC_D2CFGR_D2PPRE1)
  /* Get HCLK source and Compute PCLK1 frequency ---------------------------*/
  return (HAL_RCC_GetHCLKFreq() >> ((D1CorePrescTable[(RCC->D2CFGR & RCC_D2CFGR_D2PPRE1)>> RCC_D2CFGR_D2PPRE1_Pos]) & 0x1FU));
 8002e48:	f7ff ffcc 	bl	8002de4 <HAL_RCC_GetHCLKFreq>
 8002e4c:	4602      	mov	r2, r0
 8002e4e:	4b06      	ldr	r3, [pc, #24]	; (8002e68 <HAL_RCC_GetPCLK1Freq+0x24>)
 8002e50:	69db      	ldr	r3, [r3, #28]
 8002e52:	091b      	lsrs	r3, r3, #4
 8002e54:	f003 0307 	and.w	r3, r3, #7
 8002e58:	4904      	ldr	r1, [pc, #16]	; (8002e6c <HAL_RCC_GetPCLK1Freq+0x28>)
 8002e5a:	5ccb      	ldrb	r3, [r1, r3]
 8002e5c:	f003 031f 	and.w	r3, r3, #31
 8002e60:	fa22 f303 	lsr.w	r3, r2, r3
#else
 /* Get HCLK source and Compute PCLK1 frequency ---------------------------*/
  return (HAL_RCC_GetHCLKFreq() >> ((D1CorePrescTable[(RCC->CDCFGR2 & RCC_CDCFGR2_CDPPRE1)>> RCC_CDCFGR2_CDPPRE1_Pos]) & 0x1FU));
#endif
}
 8002e64:	4618      	mov	r0, r3
 8002e66:	bd80      	pop	{r7, pc}
 8002e68:	58024400 	.word	0x58024400
 8002e6c:	0802621c 	.word	0x0802621c

08002e70 <HAL_RCC_GetPCLK2Freq>:
  * @note   Each time PCLK2 changes, this function must be called to update the
  *         right PCLK2 value. Otherwise, any configuration based on this function will be incorrect.
  * @retval PCLK1 frequency
  */
uint32_t HAL_RCC_GetPCLK2Freq(void)
{
 8002e70:	b580      	push	{r7, lr}
 8002e72:	af00      	add	r7, sp, #0
  /* Get HCLK source and Compute PCLK1 frequency ---------------------------*/
#if defined(RCC_D2CFGR_D2PPRE2)
  return (HAL_RCC_GetHCLKFreq() >> ((D1CorePrescTable[(RCC->D2CFGR & RCC_D2CFGR_D2PPRE2)>> RCC_D2CFGR_D2PPRE2_Pos]) & 0x1FU));
 8002e74:	f7ff ffb6 	bl	8002de4 <HAL_RCC_GetHCLKFreq>
 8002e78:	4602      	mov	r2, r0
 8002e7a:	4b06      	ldr	r3, [pc, #24]	; (8002e94 <HAL_RCC_GetPCLK2Freq+0x24>)
 8002e7c:	69db      	ldr	r3, [r3, #28]
 8002e7e:	0a1b      	lsrs	r3, r3, #8
 8002e80:	f003 0307 	and.w	r3, r3, #7
 8002e84:	4904      	ldr	r1, [pc, #16]	; (8002e98 <HAL_RCC_GetPCLK2Freq+0x28>)
 8002e86:	5ccb      	ldrb	r3, [r1, r3]
 8002e88:	f003 031f 	and.w	r3, r3, #31
 8002e8c:	fa22 f303 	lsr.w	r3, r2, r3
#else
  return (HAL_RCC_GetHCLKFreq() >> ((D1CorePrescTable[(RCC->CDCFGR2 & RCC_CDCFGR2_CDPPRE2)>> RCC_CDCFGR2_CDPPRE2_Pos]) & 0x1FU));
#endif
}
 8002e90:	4618      	mov	r0, r3
 8002e92:	bd80      	pop	{r7, pc}
 8002e94:	58024400 	.word	0x58024400
 8002e98:	0802621c 	.word	0x0802621c

08002e9c <HAL_RCC_GetClockConfig>:
  * will be configured.
  * @param  pFLatency: Pointer on the Flash Latency.
  * @retval None
  */
void HAL_RCC_GetClockConfig(RCC_ClkInitTypeDef  *RCC_ClkInitStruct, uint32_t *pFLatency)
{
 8002e9c:	b480      	push	{r7}
 8002e9e:	b083      	sub	sp, #12
 8002ea0:	af00      	add	r7, sp, #0
 8002ea2:	6078      	str	r0, [r7, #4]
 8002ea4:	6039      	str	r1, [r7, #0]
  /* Set all possible values for the Clock type parameter --------------------*/
  RCC_ClkInitStruct->ClockType = RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_D1PCLK1 | RCC_CLOCKTYPE_PCLK1 |
 8002ea6:	687b      	ldr	r3, [r7, #4]
 8002ea8:	223f      	movs	r2, #63	; 0x3f
 8002eaa:	601a      	str	r2, [r3, #0]
                                 RCC_CLOCKTYPE_PCLK2 |  RCC_CLOCKTYPE_D3PCLK1  ;

  /* Get the SYSCLK configuration --------------------------------------------*/
  RCC_ClkInitStruct->SYSCLKSource = (uint32_t)(RCC->CFGR & RCC_CFGR_SW);
 8002eac:	4b1a      	ldr	r3, [pc, #104]	; (8002f18 <HAL_RCC_GetClockConfig+0x7c>)
 8002eae:	691b      	ldr	r3, [r3, #16]
 8002eb0:	f003 0207 	and.w	r2, r3, #7
 8002eb4:	687b      	ldr	r3, [r7, #4]
 8002eb6:	605a      	str	r2, [r3, #4]

#if defined(RCC_D1CFGR_D1CPRE)
  /* Get the SYSCLK configuration ----------------------------------------------*/
  RCC_ClkInitStruct->SYSCLKDivider = (uint32_t)(RCC->D1CFGR & RCC_D1CFGR_D1CPRE);
 8002eb8:	4b17      	ldr	r3, [pc, #92]	; (8002f18 <HAL_RCC_GetClockConfig+0x7c>)
 8002eba:	699b      	ldr	r3, [r3, #24]
 8002ebc:	f403 6270 	and.w	r2, r3, #3840	; 0xf00
 8002ec0:	687b      	ldr	r3, [r7, #4]
 8002ec2:	609a      	str	r2, [r3, #8]

  /* Get the D1HCLK configuration ----------------------------------------------*/
  RCC_ClkInitStruct->AHBCLKDivider = (uint32_t)(RCC->D1CFGR & RCC_D1CFGR_HPRE);
 8002ec4:	4b14      	ldr	r3, [pc, #80]	; (8002f18 <HAL_RCC_GetClockConfig+0x7c>)
 8002ec6:	699b      	ldr	r3, [r3, #24]
 8002ec8:	f003 020f 	and.w	r2, r3, #15
 8002ecc:	687b      	ldr	r3, [r7, #4]
 8002ece:	60da      	str	r2, [r3, #12]

  /* Get the APB3 configuration ----------------------------------------------*/
  RCC_ClkInitStruct->APB3CLKDivider = (uint32_t)(RCC->D1CFGR & RCC_D1CFGR_D1PPRE);
 8002ed0:	4b11      	ldr	r3, [pc, #68]	; (8002f18 <HAL_RCC_GetClockConfig+0x7c>)
 8002ed2:	699b      	ldr	r3, [r3, #24]
 8002ed4:	f003 0270 	and.w	r2, r3, #112	; 0x70
 8002ed8:	687b      	ldr	r3, [r7, #4]
 8002eda:	611a      	str	r2, [r3, #16]

  /* Get the APB1 configuration ----------------------------------------------*/
  RCC_ClkInitStruct->APB1CLKDivider = (uint32_t)(RCC->D2CFGR & RCC_D2CFGR_D2PPRE1);
 8002edc:	4b0e      	ldr	r3, [pc, #56]	; (8002f18 <HAL_RCC_GetClockConfig+0x7c>)
 8002ede:	69db      	ldr	r3, [r3, #28]
 8002ee0:	f003 0270 	and.w	r2, r3, #112	; 0x70
 8002ee4:	687b      	ldr	r3, [r7, #4]
 8002ee6:	615a      	str	r2, [r3, #20]

  /* Get the APB2 configuration ----------------------------------------------*/
  RCC_ClkInitStruct->APB2CLKDivider = (uint32_t)(RCC->D2CFGR & RCC_D2CFGR_D2PPRE2);
 8002ee8:	4b0b      	ldr	r3, [pc, #44]	; (8002f18 <HAL_RCC_GetClockConfig+0x7c>)
 8002eea:	69db      	ldr	r3, [r3, #28]
 8002eec:	f403 62e0 	and.w	r2, r3, #1792	; 0x700
 8002ef0:	687b      	ldr	r3, [r7, #4]
 8002ef2:	619a      	str	r2, [r3, #24]

  /* Get the APB4 configuration ----------------------------------------------*/
  RCC_ClkInitStruct->APB4CLKDivider = (uint32_t)(RCC->D3CFGR & RCC_D3CFGR_D3PPRE);
 8002ef4:	4b08      	ldr	r3, [pc, #32]	; (8002f18 <HAL_RCC_GetClockConfig+0x7c>)
 8002ef6:	6a1b      	ldr	r3, [r3, #32]
 8002ef8:	f003 0270 	and.w	r2, r3, #112	; 0x70
 8002efc:	687b      	ldr	r3, [r7, #4]
 8002efe:	61da      	str	r2, [r3, #28]
  /* Get the APB4 configuration ----------------------------------------------*/
  RCC_ClkInitStruct->APB4CLKDivider = (uint32_t)(RCC->SRDCFGR & RCC_SRDCFGR_SRDPPRE);
#endif

  /* Get the Flash Wait State (Latency) configuration ------------------------*/
  *pFLatency = (uint32_t)(FLASH->ACR & FLASH_ACR_LATENCY);
 8002f00:	4b06      	ldr	r3, [pc, #24]	; (8002f1c <HAL_RCC_GetClockConfig+0x80>)
 8002f02:	681b      	ldr	r3, [r3, #0]
 8002f04:	f003 020f 	and.w	r2, r3, #15
 8002f08:	683b      	ldr	r3, [r7, #0]
 8002f0a:	601a      	str	r2, [r3, #0]
}
 8002f0c:	bf00      	nop
 8002f0e:	370c      	adds	r7, #12
 8002f10:	46bd      	mov	sp, r7
 8002f12:	f85d 7b04 	ldr.w	r7, [sp], #4
 8002f16:	4770      	bx	lr
 8002f18:	58024400 	.word	0x58024400
 8002f1c:	52002000 	.word	0x52002000

08002f20 <HAL_RCCEx_PeriphCLKConfig>:
  * (*) : Available on some STM32H7 lines only.
  *
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RCCEx_PeriphCLKConfig(RCC_PeriphCLKInitTypeDef  *PeriphClkInit)
{
 8002f20:	b580      	push	{r7, lr}
 8002f22:	b086      	sub	sp, #24
 8002f24:	af00      	add	r7, sp, #0
 8002f26:	6078      	str	r0, [r7, #4]
  uint32_t tmpreg;
  uint32_t tickstart;
  HAL_StatusTypeDef ret = HAL_OK;      /* Intermediate status */
 8002f28:	2300      	movs	r3, #0
 8002f2a:	75fb      	strb	r3, [r7, #23]
  HAL_StatusTypeDef status = HAL_OK;   /* Final status */
 8002f2c:	2300      	movs	r3, #0
 8002f2e:	75bb      	strb	r3, [r7, #22]

  /*---------------------------- SPDIFRX configuration -------------------------------*/

  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SPDIFRX) == RCC_PERIPHCLK_SPDIFRX)
 8002f30:	687b      	ldr	r3, [r7, #4]
 8002f32:	681b      	ldr	r3, [r3, #0]
 8002f34:	f003 6300 	and.w	r3, r3, #134217728	; 0x8000000
 8002f38:	2b00      	cmp	r3, #0
 8002f3a:	d03f      	beq.n	8002fbc <HAL_RCCEx_PeriphCLKConfig+0x9c>
  {

    switch(PeriphClkInit->SpdifrxClockSelection)
 8002f3c:	687b      	ldr	r3, [r7, #4]
 8002f3e:	6e9b      	ldr	r3, [r3, #104]	; 0x68
 8002f40:	f5b3 1f40 	cmp.w	r3, #3145728	; 0x300000
 8002f44:	d02a      	beq.n	8002f9c <HAL_RCCEx_PeriphCLKConfig+0x7c>
 8002f46:	f5b3 1f40 	cmp.w	r3, #3145728	; 0x300000
 8002f4a:	d824      	bhi.n	8002f96 <HAL_RCCEx_PeriphCLKConfig+0x76>
 8002f4c:	f5b3 1f00 	cmp.w	r3, #2097152	; 0x200000
 8002f50:	d018      	beq.n	8002f84 <HAL_RCCEx_PeriphCLKConfig+0x64>
 8002f52:	f5b3 1f00 	cmp.w	r3, #2097152	; 0x200000
 8002f56:	d81e      	bhi.n	8002f96 <HAL_RCCEx_PeriphCLKConfig+0x76>
 8002f58:	2b00      	cmp	r3, #0
 8002f5a:	d003      	beq.n	8002f64 <HAL_RCCEx_PeriphCLKConfig+0x44>
 8002f5c:	f5b3 1f80 	cmp.w	r3, #1048576	; 0x100000
 8002f60:	d007      	beq.n	8002f72 <HAL_RCCEx_PeriphCLKConfig+0x52>
 8002f62:	e018      	b.n	8002f96 <HAL_RCCEx_PeriphCLKConfig+0x76>
    {
    case RCC_SPDIFRXCLKSOURCE_PLL:      /* PLL is used as clock source for SPDIFRX*/
      /* Enable PLL1Q Clock output generated form System PLL . */
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL1_DIVQ);
 8002f64:	4ba3      	ldr	r3, [pc, #652]	; (80031f4 <HAL_RCCEx_PeriphCLKConfig+0x2d4>)
 8002f66:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8002f68:	4aa2      	ldr	r2, [pc, #648]	; (80031f4 <HAL_RCCEx_PeriphCLKConfig+0x2d4>)
 8002f6a:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
 8002f6e:	62d3      	str	r3, [r2, #44]	; 0x2c

      /* SPDIFRX clock source configuration done later after clock selection check */
      break;
 8002f70:	e015      	b.n	8002f9e <HAL_RCCEx_PeriphCLKConfig+0x7e>

    case RCC_SPDIFRXCLKSOURCE_PLL2: /* PLL2 is used as clock source for SPDIFRX*/

      ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2),DIVIDER_R_UPDATE);
 8002f72:	687b      	ldr	r3, [r7, #4]
 8002f74:	3304      	adds	r3, #4
 8002f76:	2102      	movs	r1, #2
 8002f78:	4618      	mov	r0, r3
 8002f7a:	f001 f9fd 	bl	8004378 <RCCEx_PLL2_Config>
 8002f7e:	4603      	mov	r3, r0
 8002f80:	75fb      	strb	r3, [r7, #23]

      /* SPDIFRX clock source configuration done later after clock selection check */
      break;
 8002f82:	e00c      	b.n	8002f9e <HAL_RCCEx_PeriphCLKConfig+0x7e>

    case RCC_SPDIFRXCLKSOURCE_PLL3:  /* PLL3 is used as clock source for SPDIFRX*/
      ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3),DIVIDER_R_UPDATE);
 8002f84:	687b      	ldr	r3, [r7, #4]
 8002f86:	3324      	adds	r3, #36	; 0x24
 8002f88:	2102      	movs	r1, #2
 8002f8a:	4618      	mov	r0, r3
 8002f8c:	f001 faa6 	bl	80044dc <RCCEx_PLL3_Config>
 8002f90:	4603      	mov	r3, r0
 8002f92:	75fb      	strb	r3, [r7, #23]

      /* SPDIFRX clock source configuration done later after clock selection check */
      break;
 8002f94:	e003      	b.n	8002f9e <HAL_RCCEx_PeriphCLKConfig+0x7e>
      /* Internal OSC clock is used as source of SPDIFRX clock*/
      /* SPDIFRX clock source configuration done later after clock selection check */
      break;

    default:
      ret = HAL_ERROR;
 8002f96:	2301      	movs	r3, #1
 8002f98:	75fb      	strb	r3, [r7, #23]
      break;
 8002f9a:	e000      	b.n	8002f9e <HAL_RCCEx_PeriphCLKConfig+0x7e>
      break;
 8002f9c:	bf00      	nop
    }

    if(ret == HAL_OK)
 8002f9e:	7dfb      	ldrb	r3, [r7, #23]
 8002fa0:	2b00      	cmp	r3, #0
 8002fa2:	d109      	bne.n	8002fb8 <HAL_RCCEx_PeriphCLKConfig+0x98>
    {
      /* Set the source of SPDIFRX clock*/
      __HAL_RCC_SPDIFRX_CONFIG(PeriphClkInit->SpdifrxClockSelection);
 8002fa4:	4b93      	ldr	r3, [pc, #588]	; (80031f4 <HAL_RCCEx_PeriphCLKConfig+0x2d4>)
 8002fa6:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 8002fa8:	f423 1240 	bic.w	r2, r3, #3145728	; 0x300000
 8002fac:	687b      	ldr	r3, [r7, #4]
 8002fae:	6e9b      	ldr	r3, [r3, #104]	; 0x68
 8002fb0:	4990      	ldr	r1, [pc, #576]	; (80031f4 <HAL_RCCEx_PeriphCLKConfig+0x2d4>)
 8002fb2:	4313      	orrs	r3, r2
 8002fb4:	650b      	str	r3, [r1, #80]	; 0x50
 8002fb6:	e001      	b.n	8002fbc <HAL_RCCEx_PeriphCLKConfig+0x9c>
    }
    else
    {
      /* set overall return value */
      status = ret;
 8002fb8:	7dfb      	ldrb	r3, [r7, #23]
 8002fba:	75bb      	strb	r3, [r7, #22]
    }
  }

  /*---------------------------- SAI1 configuration -------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI1) == RCC_PERIPHCLK_SAI1)
 8002fbc:	687b      	ldr	r3, [r7, #4]
 8002fbe:	681b      	ldr	r3, [r3, #0]
 8002fc0:	f403 7380 	and.w	r3, r3, #256	; 0x100
 8002fc4:	2b00      	cmp	r3, #0
 8002fc6:	d03d      	beq.n	8003044 <HAL_RCCEx_PeriphCLKConfig+0x124>
  {
    switch(PeriphClkInit->Sai1ClockSelection)
 8002fc8:	687b      	ldr	r3, [r7, #4]
 8002fca:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 8002fcc:	2b04      	cmp	r3, #4
 8002fce:	d826      	bhi.n	800301e <HAL_RCCEx_PeriphCLKConfig+0xfe>
 8002fd0:	a201      	add	r2, pc, #4	; (adr r2, 8002fd8 <HAL_RCCEx_PeriphCLKConfig+0xb8>)
 8002fd2:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8002fd6:	bf00      	nop
 8002fd8:	08002fed 	.word	0x08002fed
 8002fdc:	08002ffb 	.word	0x08002ffb
 8002fe0:	0800300d 	.word	0x0800300d
 8002fe4:	08003025 	.word	0x08003025
 8002fe8:	08003025 	.word	0x08003025
    {
    case RCC_SAI1CLKSOURCE_PLL:      /* PLL is used as clock source for SAI1*/
      /* Enable SAI Clock output generated form System PLL . */
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL1_DIVQ);
 8002fec:	4b81      	ldr	r3, [pc, #516]	; (80031f4 <HAL_RCCEx_PeriphCLKConfig+0x2d4>)
 8002fee:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8002ff0:	4a80      	ldr	r2, [pc, #512]	; (80031f4 <HAL_RCCEx_PeriphCLKConfig+0x2d4>)
 8002ff2:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
 8002ff6:	62d3      	str	r3, [r2, #44]	; 0x2c

      /* SAI1 clock source configuration done later after clock selection check */
      break;
 8002ff8:	e015      	b.n	8003026 <HAL_RCCEx_PeriphCLKConfig+0x106>

    case RCC_SAI1CLKSOURCE_PLL2: /* PLL2 is used as clock source for SAI1*/

      ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2),DIVIDER_P_UPDATE);
 8002ffa:	687b      	ldr	r3, [r7, #4]
 8002ffc:	3304      	adds	r3, #4
 8002ffe:	2100      	movs	r1, #0
 8003000:	4618      	mov	r0, r3
 8003002:	f001 f9b9 	bl	8004378 <RCCEx_PLL2_Config>
 8003006:	4603      	mov	r3, r0
 8003008:	75fb      	strb	r3, [r7, #23]

      /* SAI1 clock source configuration done later after clock selection check */
      break;
 800300a:	e00c      	b.n	8003026 <HAL_RCCEx_PeriphCLKConfig+0x106>

    case RCC_SAI1CLKSOURCE_PLL3:  /* PLL3 is used as clock source for SAI1*/
      ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3),DIVIDER_P_UPDATE);
 800300c:	687b      	ldr	r3, [r7, #4]
 800300e:	3324      	adds	r3, #36	; 0x24
 8003010:	2100      	movs	r1, #0
 8003012:	4618      	mov	r0, r3
 8003014:	f001 fa62 	bl	80044dc <RCCEx_PLL3_Config>
 8003018:	4603      	mov	r3, r0
 800301a:	75fb      	strb	r3, [r7, #23]

      /* SAI1 clock source configuration done later after clock selection check */
      break;
 800301c:	e003      	b.n	8003026 <HAL_RCCEx_PeriphCLKConfig+0x106>
      /* HSI, HSE, or CSI oscillator is used as source of SAI1 clock */
      /* SAI1 clock source configuration done later after clock selection check */
      break;

    default:
      ret = HAL_ERROR;
 800301e:	2301      	movs	r3, #1
 8003020:	75fb      	strb	r3, [r7, #23]
      break;
 8003022:	e000      	b.n	8003026 <HAL_RCCEx_PeriphCLKConfig+0x106>
      break;
 8003024:	bf00      	nop
    }

    if(ret == HAL_OK)
 8003026:	7dfb      	ldrb	r3, [r7, #23]
 8003028:	2b00      	cmp	r3, #0
 800302a:	d109      	bne.n	8003040 <HAL_RCCEx_PeriphCLKConfig+0x120>
    {
      /* Set the source of SAI1 clock*/
      __HAL_RCC_SAI1_CONFIG(PeriphClkInit->Sai1ClockSelection);
 800302c:	4b71      	ldr	r3, [pc, #452]	; (80031f4 <HAL_RCCEx_PeriphCLKConfig+0x2d4>)
 800302e:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 8003030:	f023 0207 	bic.w	r2, r3, #7
 8003034:	687b      	ldr	r3, [r7, #4]
 8003036:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 8003038:	496e      	ldr	r1, [pc, #440]	; (80031f4 <HAL_RCCEx_PeriphCLKConfig+0x2d4>)
 800303a:	4313      	orrs	r3, r2
 800303c:	650b      	str	r3, [r1, #80]	; 0x50
 800303e:	e001      	b.n	8003044 <HAL_RCCEx_PeriphCLKConfig+0x124>
    }
    else
    {
      /* set overall return value */
      status = ret;
 8003040:	7dfb      	ldrb	r3, [r7, #23]
 8003042:	75bb      	strb	r3, [r7, #22]
    }
  }

#if defined(SAI3)
  /*---------------------------- SAI2/3 configuration -------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI23) == RCC_PERIPHCLK_SAI23)
 8003044:	687b      	ldr	r3, [r7, #4]
 8003046:	681b      	ldr	r3, [r3, #0]
 8003048:	f403 7300 	and.w	r3, r3, #512	; 0x200
 800304c:	2b00      	cmp	r3, #0
 800304e:	d042      	beq.n	80030d6 <HAL_RCCEx_PeriphCLKConfig+0x1b6>
  {
    switch(PeriphClkInit->Sai23ClockSelection)
 8003050:	687b      	ldr	r3, [r7, #4]
 8003052:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
 8003054:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
 8003058:	d02b      	beq.n	80030b2 <HAL_RCCEx_PeriphCLKConfig+0x192>
 800305a:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
 800305e:	d825      	bhi.n	80030ac <HAL_RCCEx_PeriphCLKConfig+0x18c>
 8003060:	2bc0      	cmp	r3, #192	; 0xc0
 8003062:	d028      	beq.n	80030b6 <HAL_RCCEx_PeriphCLKConfig+0x196>
 8003064:	2bc0      	cmp	r3, #192	; 0xc0
 8003066:	d821      	bhi.n	80030ac <HAL_RCCEx_PeriphCLKConfig+0x18c>
 8003068:	2b80      	cmp	r3, #128	; 0x80
 800306a:	d016      	beq.n	800309a <HAL_RCCEx_PeriphCLKConfig+0x17a>
 800306c:	2b80      	cmp	r3, #128	; 0x80
 800306e:	d81d      	bhi.n	80030ac <HAL_RCCEx_PeriphCLKConfig+0x18c>
 8003070:	2b00      	cmp	r3, #0
 8003072:	d002      	beq.n	800307a <HAL_RCCEx_PeriphCLKConfig+0x15a>
 8003074:	2b40      	cmp	r3, #64	; 0x40
 8003076:	d007      	beq.n	8003088 <HAL_RCCEx_PeriphCLKConfig+0x168>
 8003078:	e018      	b.n	80030ac <HAL_RCCEx_PeriphCLKConfig+0x18c>
    {
    case RCC_SAI23CLKSOURCE_PLL:      /* PLL is used as clock source for SAI2/3 */
      /* Enable SAI Clock output generated form System PLL . */
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL1_DIVQ);
 800307a:	4b5e      	ldr	r3, [pc, #376]	; (80031f4 <HAL_RCCEx_PeriphCLKConfig+0x2d4>)
 800307c:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800307e:	4a5d      	ldr	r2, [pc, #372]	; (80031f4 <HAL_RCCEx_PeriphCLKConfig+0x2d4>)
 8003080:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
 8003084:	62d3      	str	r3, [r2, #44]	; 0x2c

      /* SAI2/3 clock source configuration done later after clock selection check */
      break;
 8003086:	e017      	b.n	80030b8 <HAL_RCCEx_PeriphCLKConfig+0x198>

    case RCC_SAI23CLKSOURCE_PLL2: /* PLL2 is used as clock source for SAI2/3 */

      ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2),DIVIDER_P_UPDATE);
 8003088:	687b      	ldr	r3, [r7, #4]
 800308a:	3304      	adds	r3, #4
 800308c:	2100      	movs	r1, #0
 800308e:	4618      	mov	r0, r3
 8003090:	f001 f972 	bl	8004378 <RCCEx_PLL2_Config>
 8003094:	4603      	mov	r3, r0
 8003096:	75fb      	strb	r3, [r7, #23]

      /* SAI2/3 clock source configuration done later after clock selection check */
      break;
 8003098:	e00e      	b.n	80030b8 <HAL_RCCEx_PeriphCLKConfig+0x198>

    case RCC_SAI23CLKSOURCE_PLL3:  /* PLL3 is used as clock source for SAI2/3 */
      ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3),DIVIDER_P_UPDATE);
 800309a:	687b      	ldr	r3, [r7, #4]
 800309c:	3324      	adds	r3, #36	; 0x24
 800309e:	2100      	movs	r1, #0
 80030a0:	4618      	mov	r0, r3
 80030a2:	f001 fa1b 	bl	80044dc <RCCEx_PLL3_Config>
 80030a6:	4603      	mov	r3, r0
 80030a8:	75fb      	strb	r3, [r7, #23]

      /* SAI2/3 clock source configuration done later after clock selection check */
      break;
 80030aa:	e005      	b.n	80030b8 <HAL_RCCEx_PeriphCLKConfig+0x198>
      /* HSI, HSE, or CSI oscillator is used as source of SAI2/3 clock */
      /* SAI2/3 clock source configuration done later after clock selection check */
      break;

    default:
      ret = HAL_ERROR;
 80030ac:	2301      	movs	r3, #1
 80030ae:	75fb      	strb	r3, [r7, #23]
      break;
 80030b0:	e002      	b.n	80030b8 <HAL_RCCEx_PeriphCLKConfig+0x198>
      break;
 80030b2:	bf00      	nop
 80030b4:	e000      	b.n	80030b8 <HAL_RCCEx_PeriphCLKConfig+0x198>
      break;
 80030b6:	bf00      	nop
    }

    if(ret == HAL_OK)
 80030b8:	7dfb      	ldrb	r3, [r7, #23]
 80030ba:	2b00      	cmp	r3, #0
 80030bc:	d109      	bne.n	80030d2 <HAL_RCCEx_PeriphCLKConfig+0x1b2>
    {
      /* Set the source of SAI2/3 clock*/
      __HAL_RCC_SAI23_CONFIG(PeriphClkInit->Sai23ClockSelection);
 80030be:	4b4d      	ldr	r3, [pc, #308]	; (80031f4 <HAL_RCCEx_PeriphCLKConfig+0x2d4>)
 80030c0:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 80030c2:	f423 72e0 	bic.w	r2, r3, #448	; 0x1c0
 80030c6:	687b      	ldr	r3, [r7, #4]
 80030c8:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
 80030ca:	494a      	ldr	r1, [pc, #296]	; (80031f4 <HAL_RCCEx_PeriphCLKConfig+0x2d4>)
 80030cc:	4313      	orrs	r3, r2
 80030ce:	650b      	str	r3, [r1, #80]	; 0x50
 80030d0:	e001      	b.n	80030d6 <HAL_RCCEx_PeriphCLKConfig+0x1b6>
    }
    else
    {
      /* set overall return value */
      status = ret;
 80030d2:	7dfb      	ldrb	r3, [r7, #23]
 80030d4:	75bb      	strb	r3, [r7, #22]
  }
#endif  /*SAI2B*/

#if defined(SAI4)
  /*---------------------------- SAI4A configuration -------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI4A) == RCC_PERIPHCLK_SAI4A)
 80030d6:	687b      	ldr	r3, [r7, #4]
 80030d8:	681b      	ldr	r3, [r3, #0]
 80030da:	f403 6380 	and.w	r3, r3, #1024	; 0x400
 80030de:	2b00      	cmp	r3, #0
 80030e0:	d049      	beq.n	8003176 <HAL_RCCEx_PeriphCLKConfig+0x256>
  {
    switch(PeriphClkInit->Sai4AClockSelection)
 80030e2:	687b      	ldr	r3, [r7, #4]
 80030e4:	f8d3 30a8 	ldr.w	r3, [r3, #168]	; 0xa8
 80030e8:	f5b3 0f00 	cmp.w	r3, #8388608	; 0x800000
 80030ec:	d030      	beq.n	8003150 <HAL_RCCEx_PeriphCLKConfig+0x230>
 80030ee:	f5b3 0f00 	cmp.w	r3, #8388608	; 0x800000
 80030f2:	d82a      	bhi.n	800314a <HAL_RCCEx_PeriphCLKConfig+0x22a>
 80030f4:	f5b3 0fc0 	cmp.w	r3, #6291456	; 0x600000
 80030f8:	d02c      	beq.n	8003154 <HAL_RCCEx_PeriphCLKConfig+0x234>
 80030fa:	f5b3 0fc0 	cmp.w	r3, #6291456	; 0x600000
 80030fe:	d824      	bhi.n	800314a <HAL_RCCEx_PeriphCLKConfig+0x22a>
 8003100:	f5b3 0f80 	cmp.w	r3, #4194304	; 0x400000
 8003104:	d018      	beq.n	8003138 <HAL_RCCEx_PeriphCLKConfig+0x218>
 8003106:	f5b3 0f80 	cmp.w	r3, #4194304	; 0x400000
 800310a:	d81e      	bhi.n	800314a <HAL_RCCEx_PeriphCLKConfig+0x22a>
 800310c:	2b00      	cmp	r3, #0
 800310e:	d003      	beq.n	8003118 <HAL_RCCEx_PeriphCLKConfig+0x1f8>
 8003110:	f5b3 1f00 	cmp.w	r3, #2097152	; 0x200000
 8003114:	d007      	beq.n	8003126 <HAL_RCCEx_PeriphCLKConfig+0x206>
 8003116:	e018      	b.n	800314a <HAL_RCCEx_PeriphCLKConfig+0x22a>
    {
    case RCC_SAI4ACLKSOURCE_PLL:      /* PLL is used as clock source for SAI2*/
      /* Enable SAI Clock output generated form System PLL . */
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL1_DIVQ);
 8003118:	4b36      	ldr	r3, [pc, #216]	; (80031f4 <HAL_RCCEx_PeriphCLKConfig+0x2d4>)
 800311a:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800311c:	4a35      	ldr	r2, [pc, #212]	; (80031f4 <HAL_RCCEx_PeriphCLKConfig+0x2d4>)
 800311e:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
 8003122:	62d3      	str	r3, [r2, #44]	; 0x2c

      /* SAI1 clock source configuration done later after clock selection check */
      break;
 8003124:	e017      	b.n	8003156 <HAL_RCCEx_PeriphCLKConfig+0x236>

    case RCC_SAI4ACLKSOURCE_PLL2: /* PLL2 is used as clock source for SAI2*/

      ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2),DIVIDER_P_UPDATE);
 8003126:	687b      	ldr	r3, [r7, #4]
 8003128:	3304      	adds	r3, #4
 800312a:	2100      	movs	r1, #0
 800312c:	4618      	mov	r0, r3
 800312e:	f001 f923 	bl	8004378 <RCCEx_PLL2_Config>
 8003132:	4603      	mov	r3, r0
 8003134:	75fb      	strb	r3, [r7, #23]

      /* SAI2 clock source configuration done later after clock selection check */
      break;
 8003136:	e00e      	b.n	8003156 <HAL_RCCEx_PeriphCLKConfig+0x236>

    case RCC_SAI4ACLKSOURCE_PLL3:  /* PLL3 is used as clock source for SAI2*/
      ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3),DIVIDER_P_UPDATE);
 8003138:	687b      	ldr	r3, [r7, #4]
 800313a:	3324      	adds	r3, #36	; 0x24
 800313c:	2100      	movs	r1, #0
 800313e:	4618      	mov	r0, r3
 8003140:	f001 f9cc 	bl	80044dc <RCCEx_PLL3_Config>
 8003144:	4603      	mov	r3, r0
 8003146:	75fb      	strb	r3, [r7, #23]

      /* SAI1 clock source configuration done later after clock selection check */
      break;
 8003148:	e005      	b.n	8003156 <HAL_RCCEx_PeriphCLKConfig+0x236>
      /* SAI4A clock source configuration done later after clock selection check */
      break;
#endif /* RCC_VER_3_0 */

    default:
      ret = HAL_ERROR;
 800314a:	2301      	movs	r3, #1
 800314c:	75fb      	strb	r3, [r7, #23]
      break;
 800314e:	e002      	b.n	8003156 <HAL_RCCEx_PeriphCLKConfig+0x236>
      break;
 8003150:	bf00      	nop
 8003152:	e000      	b.n	8003156 <HAL_RCCEx_PeriphCLKConfig+0x236>
      break;
 8003154:	bf00      	nop
    }

    if(ret == HAL_OK)
 8003156:	7dfb      	ldrb	r3, [r7, #23]
 8003158:	2b00      	cmp	r3, #0
 800315a:	d10a      	bne.n	8003172 <HAL_RCCEx_PeriphCLKConfig+0x252>
    {
      /* Set the source of SAI4A clock*/
      __HAL_RCC_SAI4A_CONFIG(PeriphClkInit->Sai4AClockSelection);
 800315c:	4b25      	ldr	r3, [pc, #148]	; (80031f4 <HAL_RCCEx_PeriphCLKConfig+0x2d4>)
 800315e:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 8003160:	f423 0260 	bic.w	r2, r3, #14680064	; 0xe00000
 8003164:	687b      	ldr	r3, [r7, #4]
 8003166:	f8d3 30a8 	ldr.w	r3, [r3, #168]	; 0xa8
 800316a:	4922      	ldr	r1, [pc, #136]	; (80031f4 <HAL_RCCEx_PeriphCLKConfig+0x2d4>)
 800316c:	4313      	orrs	r3, r2
 800316e:	658b      	str	r3, [r1, #88]	; 0x58
 8003170:	e001      	b.n	8003176 <HAL_RCCEx_PeriphCLKConfig+0x256>
    }
    else
    {
      /* set overall return value */
      status = ret;
 8003172:	7dfb      	ldrb	r3, [r7, #23]
 8003174:	75bb      	strb	r3, [r7, #22]
    }
  }
  /*---------------------------- SAI4B configuration -------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI4B) == RCC_PERIPHCLK_SAI4B)
 8003176:	687b      	ldr	r3, [r7, #4]
 8003178:	681b      	ldr	r3, [r3, #0]
 800317a:	f403 6300 	and.w	r3, r3, #2048	; 0x800
 800317e:	2b00      	cmp	r3, #0
 8003180:	d04b      	beq.n	800321a <HAL_RCCEx_PeriphCLKConfig+0x2fa>
  {
    switch(PeriphClkInit->Sai4BClockSelection)
 8003182:	687b      	ldr	r3, [r7, #4]
 8003184:	f8d3 30ac 	ldr.w	r3, [r3, #172]	; 0xac
 8003188:	f1b3 6f80 	cmp.w	r3, #67108864	; 0x4000000
 800318c:	d030      	beq.n	80031f0 <HAL_RCCEx_PeriphCLKConfig+0x2d0>
 800318e:	f1b3 6f80 	cmp.w	r3, #67108864	; 0x4000000
 8003192:	d82a      	bhi.n	80031ea <HAL_RCCEx_PeriphCLKConfig+0x2ca>
 8003194:	f1b3 7f40 	cmp.w	r3, #50331648	; 0x3000000
 8003198:	d02e      	beq.n	80031f8 <HAL_RCCEx_PeriphCLKConfig+0x2d8>
 800319a:	f1b3 7f40 	cmp.w	r3, #50331648	; 0x3000000
 800319e:	d824      	bhi.n	80031ea <HAL_RCCEx_PeriphCLKConfig+0x2ca>
 80031a0:	f1b3 7f00 	cmp.w	r3, #33554432	; 0x2000000
 80031a4:	d018      	beq.n	80031d8 <HAL_RCCEx_PeriphCLKConfig+0x2b8>
 80031a6:	f1b3 7f00 	cmp.w	r3, #33554432	; 0x2000000
 80031aa:	d81e      	bhi.n	80031ea <HAL_RCCEx_PeriphCLKConfig+0x2ca>
 80031ac:	2b00      	cmp	r3, #0
 80031ae:	d003      	beq.n	80031b8 <HAL_RCCEx_PeriphCLKConfig+0x298>
 80031b0:	f1b3 7f80 	cmp.w	r3, #16777216	; 0x1000000
 80031b4:	d007      	beq.n	80031c6 <HAL_RCCEx_PeriphCLKConfig+0x2a6>
 80031b6:	e018      	b.n	80031ea <HAL_RCCEx_PeriphCLKConfig+0x2ca>
    {
    case RCC_SAI4BCLKSOURCE_PLL:      /* PLL is used as clock source for SAI2*/
      /* Enable SAI Clock output generated form System PLL . */
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL1_DIVQ);
 80031b8:	4b0e      	ldr	r3, [pc, #56]	; (80031f4 <HAL_RCCEx_PeriphCLKConfig+0x2d4>)
 80031ba:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 80031bc:	4a0d      	ldr	r2, [pc, #52]	; (80031f4 <HAL_RCCEx_PeriphCLKConfig+0x2d4>)
 80031be:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
 80031c2:	62d3      	str	r3, [r2, #44]	; 0x2c

      /* SAI1 clock source configuration done later after clock selection check */
      break;
 80031c4:	e019      	b.n	80031fa <HAL_RCCEx_PeriphCLKConfig+0x2da>

    case RCC_SAI4BCLKSOURCE_PLL2: /* PLL2 is used as clock source for SAI2*/

      ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2),DIVIDER_P_UPDATE);
 80031c6:	687b      	ldr	r3, [r7, #4]
 80031c8:	3304      	adds	r3, #4
 80031ca:	2100      	movs	r1, #0
 80031cc:	4618      	mov	r0, r3
 80031ce:	f001 f8d3 	bl	8004378 <RCCEx_PLL2_Config>
 80031d2:	4603      	mov	r3, r0
 80031d4:	75fb      	strb	r3, [r7, #23]

      /* SAI2 clock source configuration done later after clock selection check */
      break;
 80031d6:	e010      	b.n	80031fa <HAL_RCCEx_PeriphCLKConfig+0x2da>

    case RCC_SAI4BCLKSOURCE_PLL3:  /* PLL3 is used as clock source for SAI2*/
      ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3), DIVIDER_P_UPDATE);
 80031d8:	687b      	ldr	r3, [r7, #4]
 80031da:	3324      	adds	r3, #36	; 0x24
 80031dc:	2100      	movs	r1, #0
 80031de:	4618      	mov	r0, r3
 80031e0:	f001 f97c 	bl	80044dc <RCCEx_PLL3_Config>
 80031e4:	4603      	mov	r3, r0
 80031e6:	75fb      	strb	r3, [r7, #23]

      /* SAI1 clock source configuration done later after clock selection check */
      break;
 80031e8:	e007      	b.n	80031fa <HAL_RCCEx_PeriphCLKConfig+0x2da>
      /* SAI4B clock source configuration done later after clock selection check */
      break;
#endif /* RCC_VER_3_0 */

    default:
      ret = HAL_ERROR;
 80031ea:	2301      	movs	r3, #1
 80031ec:	75fb      	strb	r3, [r7, #23]
      break;
 80031ee:	e004      	b.n	80031fa <HAL_RCCEx_PeriphCLKConfig+0x2da>
      break;
 80031f0:	bf00      	nop
 80031f2:	e002      	b.n	80031fa <HAL_RCCEx_PeriphCLKConfig+0x2da>
 80031f4:	58024400 	.word	0x58024400
      break;
 80031f8:	bf00      	nop
    }

    if(ret == HAL_OK)
 80031fa:	7dfb      	ldrb	r3, [r7, #23]
 80031fc:	2b00      	cmp	r3, #0
 80031fe:	d10a      	bne.n	8003216 <HAL_RCCEx_PeriphCLKConfig+0x2f6>
    {
      /* Set the source of SAI4B clock*/
      __HAL_RCC_SAI4B_CONFIG(PeriphClkInit->Sai4BClockSelection);
 8003200:	4b99      	ldr	r3, [pc, #612]	; (8003468 <HAL_RCCEx_PeriphCLKConfig+0x548>)
 8003202:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 8003204:	f023 62e0 	bic.w	r2, r3, #117440512	; 0x7000000
 8003208:	687b      	ldr	r3, [r7, #4]
 800320a:	f8d3 30ac 	ldr.w	r3, [r3, #172]	; 0xac
 800320e:	4996      	ldr	r1, [pc, #600]	; (8003468 <HAL_RCCEx_PeriphCLKConfig+0x548>)
 8003210:	4313      	orrs	r3, r2
 8003212:	658b      	str	r3, [r1, #88]	; 0x58
 8003214:	e001      	b.n	800321a <HAL_RCCEx_PeriphCLKConfig+0x2fa>
    }
    else
    {
      /* set overall return value */
      status = ret;
 8003216:	7dfb      	ldrb	r3, [r7, #23]
 8003218:	75bb      	strb	r3, [r7, #22]
  }
#endif  /*SAI4*/

#if defined(QUADSPI)
  /*---------------------------- QSPI configuration -------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_QSPI) == RCC_PERIPHCLK_QSPI)
 800321a:	687b      	ldr	r3, [r7, #4]
 800321c:	681b      	ldr	r3, [r3, #0]
 800321e:	f003 7300 	and.w	r3, r3, #33554432	; 0x2000000
 8003222:	2b00      	cmp	r3, #0
 8003224:	d032      	beq.n	800328c <HAL_RCCEx_PeriphCLKConfig+0x36c>
  {
    switch(PeriphClkInit->QspiClockSelection)
 8003226:	687b      	ldr	r3, [r7, #4]
 8003228:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 800322a:	2b30      	cmp	r3, #48	; 0x30
 800322c:	d01c      	beq.n	8003268 <HAL_RCCEx_PeriphCLKConfig+0x348>
 800322e:	2b30      	cmp	r3, #48	; 0x30
 8003230:	d817      	bhi.n	8003262 <HAL_RCCEx_PeriphCLKConfig+0x342>
 8003232:	2b20      	cmp	r3, #32
 8003234:	d00c      	beq.n	8003250 <HAL_RCCEx_PeriphCLKConfig+0x330>
 8003236:	2b20      	cmp	r3, #32
 8003238:	d813      	bhi.n	8003262 <HAL_RCCEx_PeriphCLKConfig+0x342>
 800323a:	2b00      	cmp	r3, #0
 800323c:	d016      	beq.n	800326c <HAL_RCCEx_PeriphCLKConfig+0x34c>
 800323e:	2b10      	cmp	r3, #16
 8003240:	d10f      	bne.n	8003262 <HAL_RCCEx_PeriphCLKConfig+0x342>
    {
    case RCC_QSPICLKSOURCE_PLL:      /* PLL is used as clock source for QSPI*/
      /* Enable QSPI Clock output generated form System PLL . */
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL1_DIVQ);
 8003242:	4b89      	ldr	r3, [pc, #548]	; (8003468 <HAL_RCCEx_PeriphCLKConfig+0x548>)
 8003244:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8003246:	4a88      	ldr	r2, [pc, #544]	; (8003468 <HAL_RCCEx_PeriphCLKConfig+0x548>)
 8003248:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
 800324c:	62d3      	str	r3, [r2, #44]	; 0x2c

      /* QSPI clock source configuration done later after clock selection check */
      break;
 800324e:	e00e      	b.n	800326e <HAL_RCCEx_PeriphCLKConfig+0x34e>

    case RCC_QSPICLKSOURCE_PLL2: /* PLL2 is used as clock source for QSPI*/

      ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2),DIVIDER_R_UPDATE);
 8003250:	687b      	ldr	r3, [r7, #4]
 8003252:	3304      	adds	r3, #4
 8003254:	2102      	movs	r1, #2
 8003256:	4618      	mov	r0, r3
 8003258:	f001 f88e 	bl	8004378 <RCCEx_PLL2_Config>
 800325c:	4603      	mov	r3, r0
 800325e:	75fb      	strb	r3, [r7, #23]

      /* QSPI clock source configuration done later after clock selection check */
      break;
 8003260:	e005      	b.n	800326e <HAL_RCCEx_PeriphCLKConfig+0x34e>
    case RCC_QSPICLKSOURCE_D1HCLK:
      /* Domain1 HCLK  clock selected as QSPI kernel peripheral clock */
      break;

    default:
      ret = HAL_ERROR;
 8003262:	2301      	movs	r3, #1
 8003264:	75fb      	strb	r3, [r7, #23]
      break;
 8003266:	e002      	b.n	800326e <HAL_RCCEx_PeriphCLKConfig+0x34e>
      break;
 8003268:	bf00      	nop
 800326a:	e000      	b.n	800326e <HAL_RCCEx_PeriphCLKConfig+0x34e>
      break;
 800326c:	bf00      	nop
    }

    if(ret == HAL_OK)
 800326e:	7dfb      	ldrb	r3, [r7, #23]
 8003270:	2b00      	cmp	r3, #0
 8003272:	d109      	bne.n	8003288 <HAL_RCCEx_PeriphCLKConfig+0x368>
    {
      /* Set the source of QSPI clock*/
      __HAL_RCC_QSPI_CONFIG(PeriphClkInit->QspiClockSelection);
 8003274:	4b7c      	ldr	r3, [pc, #496]	; (8003468 <HAL_RCCEx_PeriphCLKConfig+0x548>)
 8003276:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 8003278:	f023 0230 	bic.w	r2, r3, #48	; 0x30
 800327c:	687b      	ldr	r3, [r7, #4]
 800327e:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 8003280:	4979      	ldr	r1, [pc, #484]	; (8003468 <HAL_RCCEx_PeriphCLKConfig+0x548>)
 8003282:	4313      	orrs	r3, r2
 8003284:	64cb      	str	r3, [r1, #76]	; 0x4c
 8003286:	e001      	b.n	800328c <HAL_RCCEx_PeriphCLKConfig+0x36c>
    }
    else
    {
      /* set overall return value */
      status = ret;
 8003288:	7dfb      	ldrb	r3, [r7, #23]
 800328a:	75bb      	strb	r3, [r7, #22]
    }
  }
#endif  /*OCTOSPI*/

  /*---------------------------- SPI1/2/3 configuration -------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SPI123) == RCC_PERIPHCLK_SPI123)
 800328c:	687b      	ldr	r3, [r7, #4]
 800328e:	681b      	ldr	r3, [r3, #0]
 8003290:	f403 5380 	and.w	r3, r3, #4096	; 0x1000
 8003294:	2b00      	cmp	r3, #0
 8003296:	d047      	beq.n	8003328 <HAL_RCCEx_PeriphCLKConfig+0x408>
  {
    switch(PeriphClkInit->Spi123ClockSelection)
 8003298:	687b      	ldr	r3, [r7, #4]
 800329a:	6e1b      	ldr	r3, [r3, #96]	; 0x60
 800329c:	f5b3 4f80 	cmp.w	r3, #16384	; 0x4000
 80032a0:	d030      	beq.n	8003304 <HAL_RCCEx_PeriphCLKConfig+0x3e4>
 80032a2:	f5b3 4f80 	cmp.w	r3, #16384	; 0x4000
 80032a6:	d82a      	bhi.n	80032fe <HAL_RCCEx_PeriphCLKConfig+0x3de>
 80032a8:	f5b3 5f40 	cmp.w	r3, #12288	; 0x3000
 80032ac:	d02c      	beq.n	8003308 <HAL_RCCEx_PeriphCLKConfig+0x3e8>
 80032ae:	f5b3 5f40 	cmp.w	r3, #12288	; 0x3000
 80032b2:	d824      	bhi.n	80032fe <HAL_RCCEx_PeriphCLKConfig+0x3de>
 80032b4:	f5b3 5f00 	cmp.w	r3, #8192	; 0x2000
 80032b8:	d018      	beq.n	80032ec <HAL_RCCEx_PeriphCLKConfig+0x3cc>
 80032ba:	f5b3 5f00 	cmp.w	r3, #8192	; 0x2000
 80032be:	d81e      	bhi.n	80032fe <HAL_RCCEx_PeriphCLKConfig+0x3de>
 80032c0:	2b00      	cmp	r3, #0
 80032c2:	d003      	beq.n	80032cc <HAL_RCCEx_PeriphCLKConfig+0x3ac>
 80032c4:	f5b3 5f80 	cmp.w	r3, #4096	; 0x1000
 80032c8:	d007      	beq.n	80032da <HAL_RCCEx_PeriphCLKConfig+0x3ba>
 80032ca:	e018      	b.n	80032fe <HAL_RCCEx_PeriphCLKConfig+0x3de>
    {
    case RCC_SPI123CLKSOURCE_PLL:      /* PLL is used as clock source for SPI1/2/3 */
      /* Enable SPI Clock output generated form System PLL . */
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL1_DIVQ);
 80032cc:	4b66      	ldr	r3, [pc, #408]	; (8003468 <HAL_RCCEx_PeriphCLKConfig+0x548>)
 80032ce:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 80032d0:	4a65      	ldr	r2, [pc, #404]	; (8003468 <HAL_RCCEx_PeriphCLKConfig+0x548>)
 80032d2:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
 80032d6:	62d3      	str	r3, [r2, #44]	; 0x2c

      /* SPI1/2/3 clock source configuration done later after clock selection check */
      break;
 80032d8:	e017      	b.n	800330a <HAL_RCCEx_PeriphCLKConfig+0x3ea>

    case RCC_SPI123CLKSOURCE_PLL2: /* PLL2 is used as clock source for SPI1/2/3 */
      ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2),DIVIDER_P_UPDATE);
 80032da:	687b      	ldr	r3, [r7, #4]
 80032dc:	3304      	adds	r3, #4
 80032de:	2100      	movs	r1, #0
 80032e0:	4618      	mov	r0, r3
 80032e2:	f001 f849 	bl	8004378 <RCCEx_PLL2_Config>
 80032e6:	4603      	mov	r3, r0
 80032e8:	75fb      	strb	r3, [r7, #23]

      /* SPI1/2/3 clock source configuration done later after clock selection check */
      break;
 80032ea:	e00e      	b.n	800330a <HAL_RCCEx_PeriphCLKConfig+0x3ea>

    case RCC_SPI123CLKSOURCE_PLL3:  /* PLL3 is used as clock source for SPI1/2/3 */
      ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3),DIVIDER_P_UPDATE);
 80032ec:	687b      	ldr	r3, [r7, #4]
 80032ee:	3324      	adds	r3, #36	; 0x24
 80032f0:	2100      	movs	r1, #0
 80032f2:	4618      	mov	r0, r3
 80032f4:	f001 f8f2 	bl	80044dc <RCCEx_PLL3_Config>
 80032f8:	4603      	mov	r3, r0
 80032fa:	75fb      	strb	r3, [r7, #23]

      /* SPI1/2/3 clock source configuration done later after clock selection check */
      break;
 80032fc:	e005      	b.n	800330a <HAL_RCCEx_PeriphCLKConfig+0x3ea>
      /* HSI, HSE, or CSI oscillator is used as source of SPI1/2/3 clock */
      /* SPI1/2/3 clock source configuration done later after clock selection check */
      break;

    default:
      ret = HAL_ERROR;
 80032fe:	2301      	movs	r3, #1
 8003300:	75fb      	strb	r3, [r7, #23]
      break;
 8003302:	e002      	b.n	800330a <HAL_RCCEx_PeriphCLKConfig+0x3ea>
      break;
 8003304:	bf00      	nop
 8003306:	e000      	b.n	800330a <HAL_RCCEx_PeriphCLKConfig+0x3ea>
      break;
 8003308:	bf00      	nop
    }

    if(ret == HAL_OK)
 800330a:	7dfb      	ldrb	r3, [r7, #23]
 800330c:	2b00      	cmp	r3, #0
 800330e:	d109      	bne.n	8003324 <HAL_RCCEx_PeriphCLKConfig+0x404>
    {
      /* Set the source of SPI1/2/3 clock*/
      __HAL_RCC_SPI123_CONFIG(PeriphClkInit->Spi123ClockSelection);
 8003310:	4b55      	ldr	r3, [pc, #340]	; (8003468 <HAL_RCCEx_PeriphCLKConfig+0x548>)
 8003312:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 8003314:	f423 42e0 	bic.w	r2, r3, #28672	; 0x7000
 8003318:	687b      	ldr	r3, [r7, #4]
 800331a:	6e1b      	ldr	r3, [r3, #96]	; 0x60
 800331c:	4952      	ldr	r1, [pc, #328]	; (8003468 <HAL_RCCEx_PeriphCLKConfig+0x548>)
 800331e:	4313      	orrs	r3, r2
 8003320:	650b      	str	r3, [r1, #80]	; 0x50
 8003322:	e001      	b.n	8003328 <HAL_RCCEx_PeriphCLKConfig+0x408>
    }
    else
    {
      /* set overall return value */
      status = ret;
 8003324:	7dfb      	ldrb	r3, [r7, #23]
 8003326:	75bb      	strb	r3, [r7, #22]
    }
  }

  /*---------------------------- SPI4/5 configuration -------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SPI45) == RCC_PERIPHCLK_SPI45)
 8003328:	687b      	ldr	r3, [r7, #4]
 800332a:	681b      	ldr	r3, [r3, #0]
 800332c:	f403 5300 	and.w	r3, r3, #8192	; 0x2000
 8003330:	2b00      	cmp	r3, #0
 8003332:	d049      	beq.n	80033c8 <HAL_RCCEx_PeriphCLKConfig+0x4a8>
  {
    switch(PeriphClkInit->Spi45ClockSelection)
 8003334:	687b      	ldr	r3, [r7, #4]
 8003336:	6e5b      	ldr	r3, [r3, #100]	; 0x64
 8003338:	f5b3 2fa0 	cmp.w	r3, #327680	; 0x50000
 800333c:	d02e      	beq.n	800339c <HAL_RCCEx_PeriphCLKConfig+0x47c>
 800333e:	f5b3 2fa0 	cmp.w	r3, #327680	; 0x50000
 8003342:	d828      	bhi.n	8003396 <HAL_RCCEx_PeriphCLKConfig+0x476>
 8003344:	f5b3 2f80 	cmp.w	r3, #262144	; 0x40000
 8003348:	d02a      	beq.n	80033a0 <HAL_RCCEx_PeriphCLKConfig+0x480>
 800334a:	f5b3 2f80 	cmp.w	r3, #262144	; 0x40000
 800334e:	d822      	bhi.n	8003396 <HAL_RCCEx_PeriphCLKConfig+0x476>
 8003350:	f5b3 3f40 	cmp.w	r3, #196608	; 0x30000
 8003354:	d026      	beq.n	80033a4 <HAL_RCCEx_PeriphCLKConfig+0x484>
 8003356:	f5b3 3f40 	cmp.w	r3, #196608	; 0x30000
 800335a:	d81c      	bhi.n	8003396 <HAL_RCCEx_PeriphCLKConfig+0x476>
 800335c:	f5b3 3f00 	cmp.w	r3, #131072	; 0x20000
 8003360:	d010      	beq.n	8003384 <HAL_RCCEx_PeriphCLKConfig+0x464>
 8003362:	f5b3 3f00 	cmp.w	r3, #131072	; 0x20000
 8003366:	d816      	bhi.n	8003396 <HAL_RCCEx_PeriphCLKConfig+0x476>
 8003368:	2b00      	cmp	r3, #0
 800336a:	d01d      	beq.n	80033a8 <HAL_RCCEx_PeriphCLKConfig+0x488>
 800336c:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
 8003370:	d111      	bne.n	8003396 <HAL_RCCEx_PeriphCLKConfig+0x476>
      /* SPI4/5 clock source configuration done later after clock selection check */
      break;

    case RCC_SPI45CLKSOURCE_PLL2: /* PLL2 is used as clock source for SPI4/5 */

      ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2),DIVIDER_Q_UPDATE);
 8003372:	687b      	ldr	r3, [r7, #4]
 8003374:	3304      	adds	r3, #4
 8003376:	2101      	movs	r1, #1
 8003378:	4618      	mov	r0, r3
 800337a:	f000 fffd 	bl	8004378 <RCCEx_PLL2_Config>
 800337e:	4603      	mov	r3, r0
 8003380:	75fb      	strb	r3, [r7, #23]

      /* SPI4/5 clock source configuration done later after clock selection check */
      break;
 8003382:	e012      	b.n	80033aa <HAL_RCCEx_PeriphCLKConfig+0x48a>
    case RCC_SPI45CLKSOURCE_PLL3:  /* PLL3 is used as clock source for SPI4/5 */
      ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3),DIVIDER_Q_UPDATE);
 8003384:	687b      	ldr	r3, [r7, #4]
 8003386:	3324      	adds	r3, #36	; 0x24
 8003388:	2101      	movs	r1, #1
 800338a:	4618      	mov	r0, r3
 800338c:	f001 f8a6 	bl	80044dc <RCCEx_PLL3_Config>
 8003390:	4603      	mov	r3, r0
 8003392:	75fb      	strb	r3, [r7, #23]
      /* SPI4/5 clock source configuration done later after clock selection check */
      break;
 8003394:	e009      	b.n	80033aa <HAL_RCCEx_PeriphCLKConfig+0x48a>
      /* HSE,  oscillator is used as source of SPI4/5 clock */
      /* SPI4/5 clock source configuration done later after clock selection check */
      break;

    default:
      ret = HAL_ERROR;
 8003396:	2301      	movs	r3, #1
 8003398:	75fb      	strb	r3, [r7, #23]
      break;
 800339a:	e006      	b.n	80033aa <HAL_RCCEx_PeriphCLKConfig+0x48a>
      break;
 800339c:	bf00      	nop
 800339e:	e004      	b.n	80033aa <HAL_RCCEx_PeriphCLKConfig+0x48a>
      break;
 80033a0:	bf00      	nop
 80033a2:	e002      	b.n	80033aa <HAL_RCCEx_PeriphCLKConfig+0x48a>
      break;
 80033a4:	bf00      	nop
 80033a6:	e000      	b.n	80033aa <HAL_RCCEx_PeriphCLKConfig+0x48a>
      break;
 80033a8:	bf00      	nop
    }

    if(ret == HAL_OK)
 80033aa:	7dfb      	ldrb	r3, [r7, #23]
 80033ac:	2b00      	cmp	r3, #0
 80033ae:	d109      	bne.n	80033c4 <HAL_RCCEx_PeriphCLKConfig+0x4a4>
    {
      /* Set the source of SPI4/5 clock*/
      __HAL_RCC_SPI45_CONFIG(PeriphClkInit->Spi45ClockSelection);
 80033b0:	4b2d      	ldr	r3, [pc, #180]	; (8003468 <HAL_RCCEx_PeriphCLKConfig+0x548>)
 80033b2:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 80033b4:	f423 22e0 	bic.w	r2, r3, #458752	; 0x70000
 80033b8:	687b      	ldr	r3, [r7, #4]
 80033ba:	6e5b      	ldr	r3, [r3, #100]	; 0x64
 80033bc:	492a      	ldr	r1, [pc, #168]	; (8003468 <HAL_RCCEx_PeriphCLKConfig+0x548>)
 80033be:	4313      	orrs	r3, r2
 80033c0:	650b      	str	r3, [r1, #80]	; 0x50
 80033c2:	e001      	b.n	80033c8 <HAL_RCCEx_PeriphCLKConfig+0x4a8>
    }
    else
    {
      /* set overall return value */
      status = ret;
 80033c4:	7dfb      	ldrb	r3, [r7, #23]
 80033c6:	75bb      	strb	r3, [r7, #22]
    }
  }

  /*---------------------------- SPI6 configuration -------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SPI6) == RCC_PERIPHCLK_SPI6)
 80033c8:	687b      	ldr	r3, [r7, #4]
 80033ca:	681b      	ldr	r3, [r3, #0]
 80033cc:	f403 4380 	and.w	r3, r3, #16384	; 0x4000
 80033d0:	2b00      	cmp	r3, #0
 80033d2:	d04d      	beq.n	8003470 <HAL_RCCEx_PeriphCLKConfig+0x550>
  {
    switch(PeriphClkInit->Spi6ClockSelection)
 80033d4:	687b      	ldr	r3, [r7, #4]
 80033d6:	f8d3 30b0 	ldr.w	r3, [r3, #176]	; 0xb0
 80033da:	f1b3 4fa0 	cmp.w	r3, #1342177280	; 0x50000000
 80033de:	d02e      	beq.n	800343e <HAL_RCCEx_PeriphCLKConfig+0x51e>
 80033e0:	f1b3 4fa0 	cmp.w	r3, #1342177280	; 0x50000000
 80033e4:	d828      	bhi.n	8003438 <HAL_RCCEx_PeriphCLKConfig+0x518>
 80033e6:	f1b3 4f80 	cmp.w	r3, #1073741824	; 0x40000000
 80033ea:	d02a      	beq.n	8003442 <HAL_RCCEx_PeriphCLKConfig+0x522>
 80033ec:	f1b3 4f80 	cmp.w	r3, #1073741824	; 0x40000000
 80033f0:	d822      	bhi.n	8003438 <HAL_RCCEx_PeriphCLKConfig+0x518>
 80033f2:	f1b3 5f40 	cmp.w	r3, #805306368	; 0x30000000
 80033f6:	d026      	beq.n	8003446 <HAL_RCCEx_PeriphCLKConfig+0x526>
 80033f8:	f1b3 5f40 	cmp.w	r3, #805306368	; 0x30000000
 80033fc:	d81c      	bhi.n	8003438 <HAL_RCCEx_PeriphCLKConfig+0x518>
 80033fe:	f1b3 5f00 	cmp.w	r3, #536870912	; 0x20000000
 8003402:	d010      	beq.n	8003426 <HAL_RCCEx_PeriphCLKConfig+0x506>
 8003404:	f1b3 5f00 	cmp.w	r3, #536870912	; 0x20000000
 8003408:	d816      	bhi.n	8003438 <HAL_RCCEx_PeriphCLKConfig+0x518>
 800340a:	2b00      	cmp	r3, #0
 800340c:	d01d      	beq.n	800344a <HAL_RCCEx_PeriphCLKConfig+0x52a>
 800340e:	f1b3 5f80 	cmp.w	r3, #268435456	; 0x10000000
 8003412:	d111      	bne.n	8003438 <HAL_RCCEx_PeriphCLKConfig+0x518>
      /* SPI6 clock source configuration done later after clock selection check */
      break;

    case RCC_SPI6CLKSOURCE_PLL2: /* PLL2 is used as clock source for SPI6*/

      ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2),DIVIDER_Q_UPDATE);
 8003414:	687b      	ldr	r3, [r7, #4]
 8003416:	3304      	adds	r3, #4
 8003418:	2101      	movs	r1, #1
 800341a:	4618      	mov	r0, r3
 800341c:	f000 ffac 	bl	8004378 <RCCEx_PLL2_Config>
 8003420:	4603      	mov	r3, r0
 8003422:	75fb      	strb	r3, [r7, #23]

      /* SPI6 clock source configuration done later after clock selection check */
      break;
 8003424:	e012      	b.n	800344c <HAL_RCCEx_PeriphCLKConfig+0x52c>
    case RCC_SPI6CLKSOURCE_PLL3:  /* PLL3 is used as clock source for SPI6*/
      ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3),DIVIDER_Q_UPDATE);
 8003426:	687b      	ldr	r3, [r7, #4]
 8003428:	3324      	adds	r3, #36	; 0x24
 800342a:	2101      	movs	r1, #1
 800342c:	4618      	mov	r0, r3
 800342e:	f001 f855 	bl	80044dc <RCCEx_PLL3_Config>
 8003432:	4603      	mov	r3, r0
 8003434:	75fb      	strb	r3, [r7, #23]
      /* SPI6 clock source configuration done later after clock selection check */
      break;
 8003436:	e009      	b.n	800344c <HAL_RCCEx_PeriphCLKConfig+0x52c>
      /* SPI6 clock source configuration done later after clock selection check */
      break;
#endif

    default:
      ret = HAL_ERROR;
 8003438:	2301      	movs	r3, #1
 800343a:	75fb      	strb	r3, [r7, #23]
      break;
 800343c:	e006      	b.n	800344c <HAL_RCCEx_PeriphCLKConfig+0x52c>
      break;
 800343e:	bf00      	nop
 8003440:	e004      	b.n	800344c <HAL_RCCEx_PeriphCLKConfig+0x52c>
      break;
 8003442:	bf00      	nop
 8003444:	e002      	b.n	800344c <HAL_RCCEx_PeriphCLKConfig+0x52c>
      break;
 8003446:	bf00      	nop
 8003448:	e000      	b.n	800344c <HAL_RCCEx_PeriphCLKConfig+0x52c>
      break;
 800344a:	bf00      	nop
    }

    if(ret == HAL_OK)
 800344c:	7dfb      	ldrb	r3, [r7, #23]
 800344e:	2b00      	cmp	r3, #0
 8003450:	d10c      	bne.n	800346c <HAL_RCCEx_PeriphCLKConfig+0x54c>
    {
      /* Set the source of SPI6 clock*/
      __HAL_RCC_SPI6_CONFIG(PeriphClkInit->Spi6ClockSelection);
 8003452:	4b05      	ldr	r3, [pc, #20]	; (8003468 <HAL_RCCEx_PeriphCLKConfig+0x548>)
 8003454:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 8003456:	f023 42e0 	bic.w	r2, r3, #1879048192	; 0x70000000
 800345a:	687b      	ldr	r3, [r7, #4]
 800345c:	f8d3 30b0 	ldr.w	r3, [r3, #176]	; 0xb0
 8003460:	4901      	ldr	r1, [pc, #4]	; (8003468 <HAL_RCCEx_PeriphCLKConfig+0x548>)
 8003462:	4313      	orrs	r3, r2
 8003464:	658b      	str	r3, [r1, #88]	; 0x58
 8003466:	e003      	b.n	8003470 <HAL_RCCEx_PeriphCLKConfig+0x550>
 8003468:	58024400 	.word	0x58024400
    }
    else
    {
      /* set overall return value */
      status = ret;
 800346c:	7dfb      	ldrb	r3, [r7, #23]
 800346e:	75bb      	strb	r3, [r7, #22]
    }
  }

#if defined(DSI)
  /*---------------------------- DSI configuration -------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_DSI) == RCC_PERIPHCLK_DSI)
 8003470:	687b      	ldr	r3, [r7, #4]
 8003472:	681b      	ldr	r3, [r3, #0]
 8003474:	f003 6380 	and.w	r3, r3, #67108864	; 0x4000000
 8003478:	2b00      	cmp	r3, #0
 800347a:	d022      	beq.n	80034c2 <HAL_RCCEx_PeriphCLKConfig+0x5a2>
  {
    switch(PeriphClkInit->DsiClockSelection)
 800347c:	687b      	ldr	r3, [r7, #4]
 800347e:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 8003480:	2b00      	cmp	r3, #0
 8003482:	d00e      	beq.n	80034a2 <HAL_RCCEx_PeriphCLKConfig+0x582>
 8003484:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
 8003488:	d108      	bne.n	800349c <HAL_RCCEx_PeriphCLKConfig+0x57c>
    {

    case RCC_DSICLKSOURCE_PLL2: /* PLL2 is used as clock source for DSI*/

      ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2),DIVIDER_Q_UPDATE);
 800348a:	687b      	ldr	r3, [r7, #4]
 800348c:	3304      	adds	r3, #4
 800348e:	2101      	movs	r1, #1
 8003490:	4618      	mov	r0, r3
 8003492:	f000 ff71 	bl	8004378 <RCCEx_PLL2_Config>
 8003496:	4603      	mov	r3, r0
 8003498:	75fb      	strb	r3, [r7, #23]

      /* DSI clock source configuration done later after clock selection check */
      break;
 800349a:	e003      	b.n	80034a4 <HAL_RCCEx_PeriphCLKConfig+0x584>
      /* PHY is used as clock source for DSI*/
      /* DSI clock source configuration done later after clock selection check */
      break;

    default:
      ret = HAL_ERROR;
 800349c:	2301      	movs	r3, #1
 800349e:	75fb      	strb	r3, [r7, #23]
      break;
 80034a0:	e000      	b.n	80034a4 <HAL_RCCEx_PeriphCLKConfig+0x584>
      break;
 80034a2:	bf00      	nop
    }

    if(ret == HAL_OK)
 80034a4:	7dfb      	ldrb	r3, [r7, #23]
 80034a6:	2b00      	cmp	r3, #0
 80034a8:	d109      	bne.n	80034be <HAL_RCCEx_PeriphCLKConfig+0x59e>
    {
      /* Set the source of DSI clock*/
      __HAL_RCC_DSI_CONFIG(PeriphClkInit->DsiClockSelection);
 80034aa:	4b82      	ldr	r3, [pc, #520]	; (80036b4 <HAL_RCCEx_PeriphCLKConfig+0x794>)
 80034ac:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 80034ae:	f423 7280 	bic.w	r2, r3, #256	; 0x100
 80034b2:	687b      	ldr	r3, [r7, #4]
 80034b4:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 80034b6:	497f      	ldr	r1, [pc, #508]	; (80036b4 <HAL_RCCEx_PeriphCLKConfig+0x794>)
 80034b8:	4313      	orrs	r3, r2
 80034ba:	64cb      	str	r3, [r1, #76]	; 0x4c
 80034bc:	e001      	b.n	80034c2 <HAL_RCCEx_PeriphCLKConfig+0x5a2>
    }
    else
    {
      /* set overall return value */
      status = ret;
 80034be:	7dfb      	ldrb	r3, [r7, #23]
 80034c0:	75bb      	strb	r3, [r7, #22]
  }
#endif /*DSI*/

#if defined(FDCAN1) || defined(FDCAN2)
  /*---------------------------- FDCAN configuration -------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_FDCAN) == RCC_PERIPHCLK_FDCAN)
 80034c2:	687b      	ldr	r3, [r7, #4]
 80034c4:	681b      	ldr	r3, [r3, #0]
 80034c6:	f403 4300 	and.w	r3, r3, #32768	; 0x8000
 80034ca:	2b00      	cmp	r3, #0
 80034cc:	d02f      	beq.n	800352e <HAL_RCCEx_PeriphCLKConfig+0x60e>
  {
    switch(PeriphClkInit->FdcanClockSelection)
 80034ce:	687b      	ldr	r3, [r7, #4]
 80034d0:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 80034d2:	f1b3 5f00 	cmp.w	r3, #536870912	; 0x20000000
 80034d6:	d00e      	beq.n	80034f6 <HAL_RCCEx_PeriphCLKConfig+0x5d6>
 80034d8:	f1b3 5f00 	cmp.w	r3, #536870912	; 0x20000000
 80034dc:	d814      	bhi.n	8003508 <HAL_RCCEx_PeriphCLKConfig+0x5e8>
 80034de:	2b00      	cmp	r3, #0
 80034e0:	d015      	beq.n	800350e <HAL_RCCEx_PeriphCLKConfig+0x5ee>
 80034e2:	f1b3 5f80 	cmp.w	r3, #268435456	; 0x10000000
 80034e6:	d10f      	bne.n	8003508 <HAL_RCCEx_PeriphCLKConfig+0x5e8>
    {
    case RCC_FDCANCLKSOURCE_PLL:      /* PLL is used as clock source for FDCAN*/
      /* Enable FDCAN Clock output generated form System PLL . */
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL1_DIVQ);
 80034e8:	4b72      	ldr	r3, [pc, #456]	; (80036b4 <HAL_RCCEx_PeriphCLKConfig+0x794>)
 80034ea:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 80034ec:	4a71      	ldr	r2, [pc, #452]	; (80036b4 <HAL_RCCEx_PeriphCLKConfig+0x794>)
 80034ee:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
 80034f2:	62d3      	str	r3, [r2, #44]	; 0x2c

      /* FDCAN clock source configuration done later after clock selection check */
      break;
 80034f4:	e00c      	b.n	8003510 <HAL_RCCEx_PeriphCLKConfig+0x5f0>

    case RCC_FDCANCLKSOURCE_PLL2: /* PLL2 is used as clock source for FDCAN*/

      ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2),DIVIDER_Q_UPDATE);
 80034f6:	687b      	ldr	r3, [r7, #4]
 80034f8:	3304      	adds	r3, #4
 80034fa:	2101      	movs	r1, #1
 80034fc:	4618      	mov	r0, r3
 80034fe:	f000 ff3b 	bl	8004378 <RCCEx_PLL2_Config>
 8003502:	4603      	mov	r3, r0
 8003504:	75fb      	strb	r3, [r7, #23]

      /* FDCAN clock source configuration done later after clock selection check */
      break;
 8003506:	e003      	b.n	8003510 <HAL_RCCEx_PeriphCLKConfig+0x5f0>
      /* HSE is used as clock source for FDCAN*/
      /* FDCAN clock source configuration done later after clock selection check */
      break;

    default:
      ret = HAL_ERROR;
 8003508:	2301      	movs	r3, #1
 800350a:	75fb      	strb	r3, [r7, #23]
      break;
 800350c:	e000      	b.n	8003510 <HAL_RCCEx_PeriphCLKConfig+0x5f0>
      break;
 800350e:	bf00      	nop
    }

    if(ret == HAL_OK)
 8003510:	7dfb      	ldrb	r3, [r7, #23]
 8003512:	2b00      	cmp	r3, #0
 8003514:	d109      	bne.n	800352a <HAL_RCCEx_PeriphCLKConfig+0x60a>
    {
      /* Set the source of FDCAN clock*/
      __HAL_RCC_FDCAN_CONFIG(PeriphClkInit->FdcanClockSelection);
 8003516:	4b67      	ldr	r3, [pc, #412]	; (80036b4 <HAL_RCCEx_PeriphCLKConfig+0x794>)
 8003518:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 800351a:	f023 5240 	bic.w	r2, r3, #805306368	; 0x30000000
 800351e:	687b      	ldr	r3, [r7, #4]
 8003520:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 8003522:	4964      	ldr	r1, [pc, #400]	; (80036b4 <HAL_RCCEx_PeriphCLKConfig+0x794>)
 8003524:	4313      	orrs	r3, r2
 8003526:	650b      	str	r3, [r1, #80]	; 0x50
 8003528:	e001      	b.n	800352e <HAL_RCCEx_PeriphCLKConfig+0x60e>
    }
    else
    {
      /* set overall return value */
      status = ret;
 800352a:	7dfb      	ldrb	r3, [r7, #23]
 800352c:	75bb      	strb	r3, [r7, #22]
    }
  }
#endif /*FDCAN1 || FDCAN2*/

  /*---------------------------- FMC configuration -------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_FMC) == RCC_PERIPHCLK_FMC)
 800352e:	687b      	ldr	r3, [r7, #4]
 8003530:	681b      	ldr	r3, [r3, #0]
 8003532:	f003 7380 	and.w	r3, r3, #16777216	; 0x1000000
 8003536:	2b00      	cmp	r3, #0
 8003538:	d031      	beq.n	800359e <HAL_RCCEx_PeriphCLKConfig+0x67e>
  {
    switch(PeriphClkInit->FmcClockSelection)
 800353a:	687b      	ldr	r3, [r7, #4]
 800353c:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 800353e:	2b03      	cmp	r3, #3
 8003540:	d81a      	bhi.n	8003578 <HAL_RCCEx_PeriphCLKConfig+0x658>
 8003542:	a201      	add	r2, pc, #4	; (adr r2, 8003548 <HAL_RCCEx_PeriphCLKConfig+0x628>)
 8003544:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8003548:	0800357f 	.word	0x0800357f
 800354c:	08003559 	.word	0x08003559
 8003550:	08003567 	.word	0x08003567
 8003554:	0800357f 	.word	0x0800357f
    {
    case RCC_FMCCLKSOURCE_PLL:      /* PLL is used as clock source for FMC*/
      /* Enable FMC Clock output generated form System PLL . */
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL1_DIVQ);
 8003558:	4b56      	ldr	r3, [pc, #344]	; (80036b4 <HAL_RCCEx_PeriphCLKConfig+0x794>)
 800355a:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800355c:	4a55      	ldr	r2, [pc, #340]	; (80036b4 <HAL_RCCEx_PeriphCLKConfig+0x794>)
 800355e:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
 8003562:	62d3      	str	r3, [r2, #44]	; 0x2c

      /* FMC clock source configuration done later after clock selection check */
      break;
 8003564:	e00c      	b.n	8003580 <HAL_RCCEx_PeriphCLKConfig+0x660>

    case RCC_FMCCLKSOURCE_PLL2: /* PLL2 is used as clock source for FMC*/

      ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2),DIVIDER_R_UPDATE);
 8003566:	687b      	ldr	r3, [r7, #4]
 8003568:	3304      	adds	r3, #4
 800356a:	2102      	movs	r1, #2
 800356c:	4618      	mov	r0, r3
 800356e:	f000 ff03 	bl	8004378 <RCCEx_PLL2_Config>
 8003572:	4603      	mov	r3, r0
 8003574:	75fb      	strb	r3, [r7, #23]

      /* FMC clock source configuration done later after clock selection check */
      break;
 8003576:	e003      	b.n	8003580 <HAL_RCCEx_PeriphCLKConfig+0x660>
    case RCC_FMCCLKSOURCE_HCLK:
      /* D1/CD HCLK  clock selected as FMC kernel peripheral clock */
      break;

    default:
      ret = HAL_ERROR;
 8003578:	2301      	movs	r3, #1
 800357a:	75fb      	strb	r3, [r7, #23]
      break;
 800357c:	e000      	b.n	8003580 <HAL_RCCEx_PeriphCLKConfig+0x660>
      break;
 800357e:	bf00      	nop
    }

    if(ret == HAL_OK)
 8003580:	7dfb      	ldrb	r3, [r7, #23]
 8003582:	2b00      	cmp	r3, #0
 8003584:	d109      	bne.n	800359a <HAL_RCCEx_PeriphCLKConfig+0x67a>
    {
      /* Set the source of FMC clock*/
      __HAL_RCC_FMC_CONFIG(PeriphClkInit->FmcClockSelection);
 8003586:	4b4b      	ldr	r3, [pc, #300]	; (80036b4 <HAL_RCCEx_PeriphCLKConfig+0x794>)
 8003588:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 800358a:	f023 0203 	bic.w	r2, r3, #3
 800358e:	687b      	ldr	r3, [r7, #4]
 8003590:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 8003592:	4948      	ldr	r1, [pc, #288]	; (80036b4 <HAL_RCCEx_PeriphCLKConfig+0x794>)
 8003594:	4313      	orrs	r3, r2
 8003596:	64cb      	str	r3, [r1, #76]	; 0x4c
 8003598:	e001      	b.n	800359e <HAL_RCCEx_PeriphCLKConfig+0x67e>
    }
    else
    {
      /* set overall return value */
      status = ret;
 800359a:	7dfb      	ldrb	r3, [r7, #23]
 800359c:	75bb      	strb	r3, [r7, #22]
    }
  }

  /*---------------------------- RTC configuration -------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_RTC) == RCC_PERIPHCLK_RTC)
 800359e:	687b      	ldr	r3, [r7, #4]
 80035a0:	681b      	ldr	r3, [r3, #0]
 80035a2:	f403 0380 	and.w	r3, r3, #4194304	; 0x400000
 80035a6:	2b00      	cmp	r3, #0
 80035a8:	f000 808c 	beq.w	80036c4 <HAL_RCCEx_PeriphCLKConfig+0x7a4>
  {
    /* check for RTC Parameters used to output RTCCLK */
    assert_param(IS_RCC_RTCCLKSOURCE(PeriphClkInit->RTCClockSelection));

    /* Enable write access to Backup domain */
    SET_BIT(PWR->CR1, PWR_CR1_DBP);
 80035ac:	4b42      	ldr	r3, [pc, #264]	; (80036b8 <HAL_RCCEx_PeriphCLKConfig+0x798>)
 80035ae:	681b      	ldr	r3, [r3, #0]
 80035b0:	4a41      	ldr	r2, [pc, #260]	; (80036b8 <HAL_RCCEx_PeriphCLKConfig+0x798>)
 80035b2:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 80035b6:	6013      	str	r3, [r2, #0]

    /* Wait for Backup domain Write protection disable */
    tickstart = HAL_GetTick();
 80035b8:	f7fe f8be 	bl	8001738 <HAL_GetTick>
 80035bc:	6138      	str	r0, [r7, #16]

    while((PWR->CR1 & PWR_CR1_DBP) == 0U)
 80035be:	e009      	b.n	80035d4 <HAL_RCCEx_PeriphCLKConfig+0x6b4>
    {
      if((HAL_GetTick() - tickstart) > RCC_DBP_TIMEOUT_VALUE)
 80035c0:	f7fe f8ba 	bl	8001738 <HAL_GetTick>
 80035c4:	4602      	mov	r2, r0
 80035c6:	693b      	ldr	r3, [r7, #16]
 80035c8:	1ad3      	subs	r3, r2, r3
 80035ca:	2b64      	cmp	r3, #100	; 0x64
 80035cc:	d902      	bls.n	80035d4 <HAL_RCCEx_PeriphCLKConfig+0x6b4>
      {
        ret = HAL_TIMEOUT;
 80035ce:	2303      	movs	r3, #3
 80035d0:	75fb      	strb	r3, [r7, #23]
        break;
 80035d2:	e005      	b.n	80035e0 <HAL_RCCEx_PeriphCLKConfig+0x6c0>
    while((PWR->CR1 & PWR_CR1_DBP) == 0U)
 80035d4:	4b38      	ldr	r3, [pc, #224]	; (80036b8 <HAL_RCCEx_PeriphCLKConfig+0x798>)
 80035d6:	681b      	ldr	r3, [r3, #0]
 80035d8:	f403 7380 	and.w	r3, r3, #256	; 0x100
 80035dc:	2b00      	cmp	r3, #0
 80035de:	d0ef      	beq.n	80035c0 <HAL_RCCEx_PeriphCLKConfig+0x6a0>
      }
    }

    if(ret == HAL_OK)
 80035e0:	7dfb      	ldrb	r3, [r7, #23]
 80035e2:	2b00      	cmp	r3, #0
 80035e4:	d16c      	bne.n	80036c0 <HAL_RCCEx_PeriphCLKConfig+0x7a0>
    {
      /* Reset the Backup domain only if the RTC Clock source selection is modified */
      if((RCC->BDCR & RCC_BDCR_RTCSEL) != (PeriphClkInit->RTCClockSelection & RCC_BDCR_RTCSEL))
 80035e6:	4b33      	ldr	r3, [pc, #204]	; (80036b4 <HAL_RCCEx_PeriphCLKConfig+0x794>)
 80035e8:	6f1a      	ldr	r2, [r3, #112]	; 0x70
 80035ea:	687b      	ldr	r3, [r7, #4]
 80035ec:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 80035f0:	4053      	eors	r3, r2
 80035f2:	f403 7340 	and.w	r3, r3, #768	; 0x300
 80035f6:	2b00      	cmp	r3, #0
 80035f8:	d013      	beq.n	8003622 <HAL_RCCEx_PeriphCLKConfig+0x702>
      {
        /* Store the content of BDCR register before the reset of Backup Domain */
        tmpreg = (RCC->BDCR & ~(RCC_BDCR_RTCSEL));
 80035fa:	4b2e      	ldr	r3, [pc, #184]	; (80036b4 <HAL_RCCEx_PeriphCLKConfig+0x794>)
 80035fc:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 80035fe:	f423 7340 	bic.w	r3, r3, #768	; 0x300
 8003602:	60fb      	str	r3, [r7, #12]
        /* RTC Clock selection can be changed only if the Backup Domain is reset */
        __HAL_RCC_BACKUPRESET_FORCE();
 8003604:	4b2b      	ldr	r3, [pc, #172]	; (80036b4 <HAL_RCCEx_PeriphCLKConfig+0x794>)
 8003606:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 8003608:	4a2a      	ldr	r2, [pc, #168]	; (80036b4 <HAL_RCCEx_PeriphCLKConfig+0x794>)
 800360a:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 800360e:	6713      	str	r3, [r2, #112]	; 0x70
        __HAL_RCC_BACKUPRESET_RELEASE();
 8003610:	4b28      	ldr	r3, [pc, #160]	; (80036b4 <HAL_RCCEx_PeriphCLKConfig+0x794>)
 8003612:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 8003614:	4a27      	ldr	r2, [pc, #156]	; (80036b4 <HAL_RCCEx_PeriphCLKConfig+0x794>)
 8003616:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
 800361a:	6713      	str	r3, [r2, #112]	; 0x70
        /* Restore the Content of BDCR register */
        RCC->BDCR = tmpreg;
 800361c:	4a25      	ldr	r2, [pc, #148]	; (80036b4 <HAL_RCCEx_PeriphCLKConfig+0x794>)
 800361e:	68fb      	ldr	r3, [r7, #12]
 8003620:	6713      	str	r3, [r2, #112]	; 0x70
      }

      /* If LSE is selected as RTC clock source (and enabled prior to Backup Domain reset), wait for LSE reactivation */
      if(PeriphClkInit->RTCClockSelection == RCC_RTCCLKSOURCE_LSE)
 8003622:	687b      	ldr	r3, [r7, #4]
 8003624:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 8003628:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
 800362c:	d115      	bne.n	800365a <HAL_RCCEx_PeriphCLKConfig+0x73a>
      {
        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 800362e:	f7fe f883 	bl	8001738 <HAL_GetTick>
 8003632:	6138      	str	r0, [r7, #16]

        /* Wait till LSE is ready */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == 0U)
 8003634:	e00b      	b.n	800364e <HAL_RCCEx_PeriphCLKConfig+0x72e>
        {
          if((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 8003636:	f7fe f87f 	bl	8001738 <HAL_GetTick>
 800363a:	4602      	mov	r2, r0
 800363c:	693b      	ldr	r3, [r7, #16]
 800363e:	1ad3      	subs	r3, r2, r3
 8003640:	f241 3288 	movw	r2, #5000	; 0x1388
 8003644:	4293      	cmp	r3, r2
 8003646:	d902      	bls.n	800364e <HAL_RCCEx_PeriphCLKConfig+0x72e>
          {
            ret = HAL_TIMEOUT;
 8003648:	2303      	movs	r3, #3
 800364a:	75fb      	strb	r3, [r7, #23]
            break;
 800364c:	e005      	b.n	800365a <HAL_RCCEx_PeriphCLKConfig+0x73a>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == 0U)
 800364e:	4b19      	ldr	r3, [pc, #100]	; (80036b4 <HAL_RCCEx_PeriphCLKConfig+0x794>)
 8003650:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 8003652:	f003 0302 	and.w	r3, r3, #2
 8003656:	2b00      	cmp	r3, #0
 8003658:	d0ed      	beq.n	8003636 <HAL_RCCEx_PeriphCLKConfig+0x716>
          }
        }
      }

      if(ret == HAL_OK)
 800365a:	7dfb      	ldrb	r3, [r7, #23]
 800365c:	2b00      	cmp	r3, #0
 800365e:	d126      	bne.n	80036ae <HAL_RCCEx_PeriphCLKConfig+0x78e>
      {
        __HAL_RCC_RTC_CONFIG(PeriphClkInit->RTCClockSelection);
 8003660:	687b      	ldr	r3, [r7, #4]
 8003662:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 8003666:	f403 7340 	and.w	r3, r3, #768	; 0x300
 800366a:	f5b3 7f40 	cmp.w	r3, #768	; 0x300
 800366e:	d10d      	bne.n	800368c <HAL_RCCEx_PeriphCLKConfig+0x76c>
 8003670:	4b10      	ldr	r3, [pc, #64]	; (80036b4 <HAL_RCCEx_PeriphCLKConfig+0x794>)
 8003672:	691b      	ldr	r3, [r3, #16]
 8003674:	f423 527c 	bic.w	r2, r3, #16128	; 0x3f00
 8003678:	687b      	ldr	r3, [r7, #4]
 800367a:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 800367e:	0919      	lsrs	r1, r3, #4
 8003680:	4b0e      	ldr	r3, [pc, #56]	; (80036bc <HAL_RCCEx_PeriphCLKConfig+0x79c>)
 8003682:	400b      	ands	r3, r1
 8003684:	490b      	ldr	r1, [pc, #44]	; (80036b4 <HAL_RCCEx_PeriphCLKConfig+0x794>)
 8003686:	4313      	orrs	r3, r2
 8003688:	610b      	str	r3, [r1, #16]
 800368a:	e005      	b.n	8003698 <HAL_RCCEx_PeriphCLKConfig+0x778>
 800368c:	4b09      	ldr	r3, [pc, #36]	; (80036b4 <HAL_RCCEx_PeriphCLKConfig+0x794>)
 800368e:	691b      	ldr	r3, [r3, #16]
 8003690:	4a08      	ldr	r2, [pc, #32]	; (80036b4 <HAL_RCCEx_PeriphCLKConfig+0x794>)
 8003692:	f423 537c 	bic.w	r3, r3, #16128	; 0x3f00
 8003696:	6113      	str	r3, [r2, #16]
 8003698:	4b06      	ldr	r3, [pc, #24]	; (80036b4 <HAL_RCCEx_PeriphCLKConfig+0x794>)
 800369a:	6f1a      	ldr	r2, [r3, #112]	; 0x70
 800369c:	687b      	ldr	r3, [r7, #4]
 800369e:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 80036a2:	f3c3 030b 	ubfx	r3, r3, #0, #12
 80036a6:	4903      	ldr	r1, [pc, #12]	; (80036b4 <HAL_RCCEx_PeriphCLKConfig+0x794>)
 80036a8:	4313      	orrs	r3, r2
 80036aa:	670b      	str	r3, [r1, #112]	; 0x70
 80036ac:	e00a      	b.n	80036c4 <HAL_RCCEx_PeriphCLKConfig+0x7a4>
      }
      else
      {
        /* set overall return value */
        status = ret;
 80036ae:	7dfb      	ldrb	r3, [r7, #23]
 80036b0:	75bb      	strb	r3, [r7, #22]
 80036b2:	e007      	b.n	80036c4 <HAL_RCCEx_PeriphCLKConfig+0x7a4>
 80036b4:	58024400 	.word	0x58024400
 80036b8:	58024800 	.word	0x58024800
 80036bc:	00ffffcf 	.word	0x00ffffcf
      }
    }
    else
    {
      /* set overall return value */
      status = ret;
 80036c0:	7dfb      	ldrb	r3, [r7, #23]
 80036c2:	75bb      	strb	r3, [r7, #22]
    }
  }


  /*-------------------------- USART1/6 configuration --------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USART16) == RCC_PERIPHCLK_USART16)
 80036c4:	687b      	ldr	r3, [r7, #4]
 80036c6:	681b      	ldr	r3, [r3, #0]
 80036c8:	f003 0301 	and.w	r3, r3, #1
 80036cc:	2b00      	cmp	r3, #0
 80036ce:	d07e      	beq.n	80037ce <HAL_RCCEx_PeriphCLKConfig+0x8ae>
  {
    switch(PeriphClkInit->Usart16ClockSelection)
 80036d0:	687b      	ldr	r3, [r7, #4]
 80036d2:	6fdb      	ldr	r3, [r3, #124]	; 0x7c
 80036d4:	2b28      	cmp	r3, #40	; 0x28
 80036d6:	d867      	bhi.n	80037a8 <HAL_RCCEx_PeriphCLKConfig+0x888>
 80036d8:	a201      	add	r2, pc, #4	; (adr r2, 80036e0 <HAL_RCCEx_PeriphCLKConfig+0x7c0>)
 80036da:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 80036de:	bf00      	nop
 80036e0:	080037af 	.word	0x080037af
 80036e4:	080037a9 	.word	0x080037a9
 80036e8:	080037a9 	.word	0x080037a9
 80036ec:	080037a9 	.word	0x080037a9
 80036f0:	080037a9 	.word	0x080037a9
 80036f4:	080037a9 	.word	0x080037a9
 80036f8:	080037a9 	.word	0x080037a9
 80036fc:	080037a9 	.word	0x080037a9
 8003700:	08003785 	.word	0x08003785
 8003704:	080037a9 	.word	0x080037a9
 8003708:	080037a9 	.word	0x080037a9
 800370c:	080037a9 	.word	0x080037a9
 8003710:	080037a9 	.word	0x080037a9
 8003714:	080037a9 	.word	0x080037a9
 8003718:	080037a9 	.word	0x080037a9
 800371c:	080037a9 	.word	0x080037a9
 8003720:	08003797 	.word	0x08003797
 8003724:	080037a9 	.word	0x080037a9
 8003728:	080037a9 	.word	0x080037a9
 800372c:	080037a9 	.word	0x080037a9
 8003730:	080037a9 	.word	0x080037a9
 8003734:	080037a9 	.word	0x080037a9
 8003738:	080037a9 	.word	0x080037a9
 800373c:	080037a9 	.word	0x080037a9
 8003740:	080037af 	.word	0x080037af
 8003744:	080037a9 	.word	0x080037a9
 8003748:	080037a9 	.word	0x080037a9
 800374c:	080037a9 	.word	0x080037a9
 8003750:	080037a9 	.word	0x080037a9
 8003754:	080037a9 	.word	0x080037a9
 8003758:	080037a9 	.word	0x080037a9
 800375c:	080037a9 	.word	0x080037a9
 8003760:	080037af 	.word	0x080037af
 8003764:	080037a9 	.word	0x080037a9
 8003768:	080037a9 	.word	0x080037a9
 800376c:	080037a9 	.word	0x080037a9
 8003770:	080037a9 	.word	0x080037a9
 8003774:	080037a9 	.word	0x080037a9
 8003778:	080037a9 	.word	0x080037a9
 800377c:	080037a9 	.word	0x080037a9
 8003780:	080037af 	.word	0x080037af
    case RCC_USART16CLKSOURCE_PCLK2: /* CD/D2 PCLK2 as clock source for USART1/6 */
      /* USART1/6 clock source configuration done later after clock selection check */
      break;

    case RCC_USART16CLKSOURCE_PLL2: /* PLL2 is used as clock source for USART1/6 */
      ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2),DIVIDER_Q_UPDATE);
 8003784:	687b      	ldr	r3, [r7, #4]
 8003786:	3304      	adds	r3, #4
 8003788:	2101      	movs	r1, #1
 800378a:	4618      	mov	r0, r3
 800378c:	f000 fdf4 	bl	8004378 <RCCEx_PLL2_Config>
 8003790:	4603      	mov	r3, r0
 8003792:	75fb      	strb	r3, [r7, #23]
      /* USART1/6 clock source configuration done later after clock selection check */
      break;
 8003794:	e00c      	b.n	80037b0 <HAL_RCCEx_PeriphCLKConfig+0x890>

    case RCC_USART16CLKSOURCE_PLL3: /* PLL3 is used as clock source for USART1/6 */
      ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3),DIVIDER_Q_UPDATE);
 8003796:	687b      	ldr	r3, [r7, #4]
 8003798:	3324      	adds	r3, #36	; 0x24
 800379a:	2101      	movs	r1, #1
 800379c:	4618      	mov	r0, r3
 800379e:	f000 fe9d 	bl	80044dc <RCCEx_PLL3_Config>
 80037a2:	4603      	mov	r3, r0
 80037a4:	75fb      	strb	r3, [r7, #23]
      /* USART1/6 clock source configuration done later after clock selection check */
      break;
 80037a6:	e003      	b.n	80037b0 <HAL_RCCEx_PeriphCLKConfig+0x890>
      /* LSE,  oscillator is used as source of USART1/6 clock */
      /* USART1/6 clock source configuration done later after clock selection check */
      break;

    default:
      ret = HAL_ERROR;
 80037a8:	2301      	movs	r3, #1
 80037aa:	75fb      	strb	r3, [r7, #23]
      break;
 80037ac:	e000      	b.n	80037b0 <HAL_RCCEx_PeriphCLKConfig+0x890>
      break;
 80037ae:	bf00      	nop
    }

    if(ret == HAL_OK)
 80037b0:	7dfb      	ldrb	r3, [r7, #23]
 80037b2:	2b00      	cmp	r3, #0
 80037b4:	d109      	bne.n	80037ca <HAL_RCCEx_PeriphCLKConfig+0x8aa>
    {
      /* Set the source of USART1/6 clock */
      __HAL_RCC_USART16_CONFIG(PeriphClkInit->Usart16ClockSelection);
 80037b6:	4b96      	ldr	r3, [pc, #600]	; (8003a10 <HAL_RCCEx_PeriphCLKConfig+0xaf0>)
 80037b8:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 80037ba:	f023 0238 	bic.w	r2, r3, #56	; 0x38
 80037be:	687b      	ldr	r3, [r7, #4]
 80037c0:	6fdb      	ldr	r3, [r3, #124]	; 0x7c
 80037c2:	4993      	ldr	r1, [pc, #588]	; (8003a10 <HAL_RCCEx_PeriphCLKConfig+0xaf0>)
 80037c4:	4313      	orrs	r3, r2
 80037c6:	654b      	str	r3, [r1, #84]	; 0x54
 80037c8:	e001      	b.n	80037ce <HAL_RCCEx_PeriphCLKConfig+0x8ae>
    }
    else
    {
      /* set overall return value */
      status = ret;
 80037ca:	7dfb      	ldrb	r3, [r7, #23]
 80037cc:	75bb      	strb	r3, [r7, #22]
    }
  }

  /*-------------------------- USART2/3/4/5/7/8 Configuration --------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USART234578) == RCC_PERIPHCLK_USART234578)
 80037ce:	687b      	ldr	r3, [r7, #4]
 80037d0:	681b      	ldr	r3, [r3, #0]
 80037d2:	f003 0302 	and.w	r3, r3, #2
 80037d6:	2b00      	cmp	r3, #0
 80037d8:	d037      	beq.n	800384a <HAL_RCCEx_PeriphCLKConfig+0x92a>
  {
    switch(PeriphClkInit->Usart234578ClockSelection)
 80037da:	687b      	ldr	r3, [r7, #4]
 80037dc:	6f9b      	ldr	r3, [r3, #120]	; 0x78
 80037de:	2b05      	cmp	r3, #5
 80037e0:	d820      	bhi.n	8003824 <HAL_RCCEx_PeriphCLKConfig+0x904>
 80037e2:	a201      	add	r2, pc, #4	; (adr r2, 80037e8 <HAL_RCCEx_PeriphCLKConfig+0x8c8>)
 80037e4:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 80037e8:	0800382b 	.word	0x0800382b
 80037ec:	08003801 	.word	0x08003801
 80037f0:	08003813 	.word	0x08003813
 80037f4:	0800382b 	.word	0x0800382b
 80037f8:	0800382b 	.word	0x0800382b
 80037fc:	0800382b 	.word	0x0800382b
    case RCC_USART234578CLKSOURCE_PCLK1: /* CD/D2 PCLK1 as clock source for USART2/3/4/5/7/8 */
      /* USART2/3/4/5/7/8 clock source configuration done later after clock selection check */
      break;

    case RCC_USART234578CLKSOURCE_PLL2: /* PLL2 is used as clock source for USART2/3/4/5/7/8 */
      ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2),DIVIDER_Q_UPDATE);
 8003800:	687b      	ldr	r3, [r7, #4]
 8003802:	3304      	adds	r3, #4
 8003804:	2101      	movs	r1, #1
 8003806:	4618      	mov	r0, r3
 8003808:	f000 fdb6 	bl	8004378 <RCCEx_PLL2_Config>
 800380c:	4603      	mov	r3, r0
 800380e:	75fb      	strb	r3, [r7, #23]
      /* USART2/3/4/5/7/8 clock source configuration done later after clock selection check */
      break;
 8003810:	e00c      	b.n	800382c <HAL_RCCEx_PeriphCLKConfig+0x90c>

    case RCC_USART234578CLKSOURCE_PLL3: /* PLL3 is used as clock source for USART2/3/4/5/7/8 */
      ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3),DIVIDER_Q_UPDATE);
 8003812:	687b      	ldr	r3, [r7, #4]
 8003814:	3324      	adds	r3, #36	; 0x24
 8003816:	2101      	movs	r1, #1
 8003818:	4618      	mov	r0, r3
 800381a:	f000 fe5f 	bl	80044dc <RCCEx_PLL3_Config>
 800381e:	4603      	mov	r3, r0
 8003820:	75fb      	strb	r3, [r7, #23]
      /* USART2/3/4/5/7/8 clock source configuration done later after clock selection check */
      break;
 8003822:	e003      	b.n	800382c <HAL_RCCEx_PeriphCLKConfig+0x90c>
      /* LSE,  oscillator is used as source of USART2/3/4/5/7/8 clock */
      /* USART2/3/4/5/7/8 clock source configuration done later after clock selection check */
      break;

    default:
      ret = HAL_ERROR;
 8003824:	2301      	movs	r3, #1
 8003826:	75fb      	strb	r3, [r7, #23]
      break;
 8003828:	e000      	b.n	800382c <HAL_RCCEx_PeriphCLKConfig+0x90c>
      break;
 800382a:	bf00      	nop
    }

    if(ret == HAL_OK)
 800382c:	7dfb      	ldrb	r3, [r7, #23]
 800382e:	2b00      	cmp	r3, #0
 8003830:	d109      	bne.n	8003846 <HAL_RCCEx_PeriphCLKConfig+0x926>
    {
      /* Set the source of USART2/3/4/5/7/8 clock */
      __HAL_RCC_USART234578_CONFIG(PeriphClkInit->Usart234578ClockSelection);
 8003832:	4b77      	ldr	r3, [pc, #476]	; (8003a10 <HAL_RCCEx_PeriphCLKConfig+0xaf0>)
 8003834:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 8003836:	f023 0207 	bic.w	r2, r3, #7
 800383a:	687b      	ldr	r3, [r7, #4]
 800383c:	6f9b      	ldr	r3, [r3, #120]	; 0x78
 800383e:	4974      	ldr	r1, [pc, #464]	; (8003a10 <HAL_RCCEx_PeriphCLKConfig+0xaf0>)
 8003840:	4313      	orrs	r3, r2
 8003842:	654b      	str	r3, [r1, #84]	; 0x54
 8003844:	e001      	b.n	800384a <HAL_RCCEx_PeriphCLKConfig+0x92a>
    }
    else
    {
      /* set overall return value */
      status = ret;
 8003846:	7dfb      	ldrb	r3, [r7, #23]
 8003848:	75bb      	strb	r3, [r7, #22]
    }
  }

  /*-------------------------- LPUART1 Configuration -------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LPUART1) == RCC_PERIPHCLK_LPUART1)
 800384a:	687b      	ldr	r3, [r7, #4]
 800384c:	681b      	ldr	r3, [r3, #0]
 800384e:	f003 0304 	and.w	r3, r3, #4
 8003852:	2b00      	cmp	r3, #0
 8003854:	d03a      	beq.n	80038cc <HAL_RCCEx_PeriphCLKConfig+0x9ac>
  {
    switch(PeriphClkInit->Lpuart1ClockSelection)
 8003856:	687b      	ldr	r3, [r7, #4]
 8003858:	f8d3 3094 	ldr.w	r3, [r3, #148]	; 0x94
 800385c:	2b05      	cmp	r3, #5
 800385e:	d821      	bhi.n	80038a4 <HAL_RCCEx_PeriphCLKConfig+0x984>
 8003860:	a201      	add	r2, pc, #4	; (adr r2, 8003868 <HAL_RCCEx_PeriphCLKConfig+0x948>)
 8003862:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8003866:	bf00      	nop
 8003868:	080038ab 	.word	0x080038ab
 800386c:	08003881 	.word	0x08003881
 8003870:	08003893 	.word	0x08003893
 8003874:	080038ab 	.word	0x080038ab
 8003878:	080038ab 	.word	0x080038ab
 800387c:	080038ab 	.word	0x080038ab
    case RCC_LPUART1CLKSOURCE_PCLK4: /* SRD/D3 PCLK1 (PCLK4) as clock source for LPUART1 */
      /* LPUART1 clock source configuration done later after clock selection check */
      break;

    case RCC_LPUART1CLKSOURCE_PLL2: /* PLL2 is used as clock source for LPUART1 */
      ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2),DIVIDER_Q_UPDATE);
 8003880:	687b      	ldr	r3, [r7, #4]
 8003882:	3304      	adds	r3, #4
 8003884:	2101      	movs	r1, #1
 8003886:	4618      	mov	r0, r3
 8003888:	f000 fd76 	bl	8004378 <RCCEx_PLL2_Config>
 800388c:	4603      	mov	r3, r0
 800388e:	75fb      	strb	r3, [r7, #23]
      /* LPUART1 clock source configuration done later after clock selection check */
      break;
 8003890:	e00c      	b.n	80038ac <HAL_RCCEx_PeriphCLKConfig+0x98c>

    case RCC_LPUART1CLKSOURCE_PLL3: /* PLL3 is used as clock source for LPUART1 */
      ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3),DIVIDER_Q_UPDATE);
 8003892:	687b      	ldr	r3, [r7, #4]
 8003894:	3324      	adds	r3, #36	; 0x24
 8003896:	2101      	movs	r1, #1
 8003898:	4618      	mov	r0, r3
 800389a:	f000 fe1f 	bl	80044dc <RCCEx_PLL3_Config>
 800389e:	4603      	mov	r3, r0
 80038a0:	75fb      	strb	r3, [r7, #23]
      /* LPUART1 clock source configuration done later after clock selection check */
      break;
 80038a2:	e003      	b.n	80038ac <HAL_RCCEx_PeriphCLKConfig+0x98c>
      /* LSE,  oscillator is used as source of LPUART1 clock */
      /* LPUART1 clock source configuration done later after clock selection check */
      break;

    default:
      ret = HAL_ERROR;
 80038a4:	2301      	movs	r3, #1
 80038a6:	75fb      	strb	r3, [r7, #23]
      break;
 80038a8:	e000      	b.n	80038ac <HAL_RCCEx_PeriphCLKConfig+0x98c>
      break;
 80038aa:	bf00      	nop
    }

    if(ret == HAL_OK)
 80038ac:	7dfb      	ldrb	r3, [r7, #23]
 80038ae:	2b00      	cmp	r3, #0
 80038b0:	d10a      	bne.n	80038c8 <HAL_RCCEx_PeriphCLKConfig+0x9a8>
    {
      /* Set the source of LPUART1 clock */
      __HAL_RCC_LPUART1_CONFIG(PeriphClkInit->Lpuart1ClockSelection);
 80038b2:	4b57      	ldr	r3, [pc, #348]	; (8003a10 <HAL_RCCEx_PeriphCLKConfig+0xaf0>)
 80038b4:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 80038b6:	f023 0207 	bic.w	r2, r3, #7
 80038ba:	687b      	ldr	r3, [r7, #4]
 80038bc:	f8d3 3094 	ldr.w	r3, [r3, #148]	; 0x94
 80038c0:	4953      	ldr	r1, [pc, #332]	; (8003a10 <HAL_RCCEx_PeriphCLKConfig+0xaf0>)
 80038c2:	4313      	orrs	r3, r2
 80038c4:	658b      	str	r3, [r1, #88]	; 0x58
 80038c6:	e001      	b.n	80038cc <HAL_RCCEx_PeriphCLKConfig+0x9ac>
    }
    else
    {
      /* set overall return value */
      status = ret;
 80038c8:	7dfb      	ldrb	r3, [r7, #23]
 80038ca:	75bb      	strb	r3, [r7, #22]
    }
  }

  /*---------------------------- LPTIM1 configuration -------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LPTIM1) == RCC_PERIPHCLK_LPTIM1)
 80038cc:	687b      	ldr	r3, [r7, #4]
 80038ce:	681b      	ldr	r3, [r3, #0]
 80038d0:	f003 0320 	and.w	r3, r3, #32
 80038d4:	2b00      	cmp	r3, #0
 80038d6:	d04b      	beq.n	8003970 <HAL_RCCEx_PeriphCLKConfig+0xa50>
  {
    switch(PeriphClkInit->Lptim1ClockSelection)
 80038d8:	687b      	ldr	r3, [r7, #4]
 80038da:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 80038de:	f1b3 4fa0 	cmp.w	r3, #1342177280	; 0x50000000
 80038e2:	d02e      	beq.n	8003942 <HAL_RCCEx_PeriphCLKConfig+0xa22>
 80038e4:	f1b3 4fa0 	cmp.w	r3, #1342177280	; 0x50000000
 80038e8:	d828      	bhi.n	800393c <HAL_RCCEx_PeriphCLKConfig+0xa1c>
 80038ea:	f1b3 4f80 	cmp.w	r3, #1073741824	; 0x40000000
 80038ee:	d02a      	beq.n	8003946 <HAL_RCCEx_PeriphCLKConfig+0xa26>
 80038f0:	f1b3 4f80 	cmp.w	r3, #1073741824	; 0x40000000
 80038f4:	d822      	bhi.n	800393c <HAL_RCCEx_PeriphCLKConfig+0xa1c>
 80038f6:	f1b3 5f40 	cmp.w	r3, #805306368	; 0x30000000
 80038fa:	d026      	beq.n	800394a <HAL_RCCEx_PeriphCLKConfig+0xa2a>
 80038fc:	f1b3 5f40 	cmp.w	r3, #805306368	; 0x30000000
 8003900:	d81c      	bhi.n	800393c <HAL_RCCEx_PeriphCLKConfig+0xa1c>
 8003902:	f1b3 5f00 	cmp.w	r3, #536870912	; 0x20000000
 8003906:	d010      	beq.n	800392a <HAL_RCCEx_PeriphCLKConfig+0xa0a>
 8003908:	f1b3 5f00 	cmp.w	r3, #536870912	; 0x20000000
 800390c:	d816      	bhi.n	800393c <HAL_RCCEx_PeriphCLKConfig+0xa1c>
 800390e:	2b00      	cmp	r3, #0
 8003910:	d01d      	beq.n	800394e <HAL_RCCEx_PeriphCLKConfig+0xa2e>
 8003912:	f1b3 5f80 	cmp.w	r3, #268435456	; 0x10000000
 8003916:	d111      	bne.n	800393c <HAL_RCCEx_PeriphCLKConfig+0xa1c>
      /* LPTIM1 clock source configuration done later after clock selection check */
      break;

    case RCC_LPTIM1CLKSOURCE_PLL2: /* PLL2 is used as clock source for LPTIM1*/

      ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2),DIVIDER_P_UPDATE);
 8003918:	687b      	ldr	r3, [r7, #4]
 800391a:	3304      	adds	r3, #4
 800391c:	2100      	movs	r1, #0
 800391e:	4618      	mov	r0, r3
 8003920:	f000 fd2a 	bl	8004378 <RCCEx_PLL2_Config>
 8003924:	4603      	mov	r3, r0
 8003926:	75fb      	strb	r3, [r7, #23]

      /* LPTIM1 clock source configuration done later after clock selection check */
      break;
 8003928:	e012      	b.n	8003950 <HAL_RCCEx_PeriphCLKConfig+0xa30>

    case RCC_LPTIM1CLKSOURCE_PLL3:  /* PLL3 is used as clock source for LPTIM1*/
      ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3),DIVIDER_R_UPDATE);
 800392a:	687b      	ldr	r3, [r7, #4]
 800392c:	3324      	adds	r3, #36	; 0x24
 800392e:	2102      	movs	r1, #2
 8003930:	4618      	mov	r0, r3
 8003932:	f000 fdd3 	bl	80044dc <RCCEx_PLL3_Config>
 8003936:	4603      	mov	r3, r0
 8003938:	75fb      	strb	r3, [r7, #23]

      /* LPTIM1 clock source configuration done later after clock selection check */
      break;
 800393a:	e009      	b.n	8003950 <HAL_RCCEx_PeriphCLKConfig+0xa30>
      /* HSI, HSE, or CSI oscillator is used as source of LPTIM1 clock */
      /* LPTIM1 clock source configuration done later after clock selection check */
      break;

    default:
      ret = HAL_ERROR;
 800393c:	2301      	movs	r3, #1
 800393e:	75fb      	strb	r3, [r7, #23]
      break;
 8003940:	e006      	b.n	8003950 <HAL_RCCEx_PeriphCLKConfig+0xa30>
      break;
 8003942:	bf00      	nop
 8003944:	e004      	b.n	8003950 <HAL_RCCEx_PeriphCLKConfig+0xa30>
      break;
 8003946:	bf00      	nop
 8003948:	e002      	b.n	8003950 <HAL_RCCEx_PeriphCLKConfig+0xa30>
      break;
 800394a:	bf00      	nop
 800394c:	e000      	b.n	8003950 <HAL_RCCEx_PeriphCLKConfig+0xa30>
      break;
 800394e:	bf00      	nop
    }

    if(ret == HAL_OK)
 8003950:	7dfb      	ldrb	r3, [r7, #23]
 8003952:	2b00      	cmp	r3, #0
 8003954:	d10a      	bne.n	800396c <HAL_RCCEx_PeriphCLKConfig+0xa4c>
    {
      /* Set the source of LPTIM1 clock*/
      __HAL_RCC_LPTIM1_CONFIG(PeriphClkInit->Lptim1ClockSelection);
 8003956:	4b2e      	ldr	r3, [pc, #184]	; (8003a10 <HAL_RCCEx_PeriphCLKConfig+0xaf0>)
 8003958:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 800395a:	f023 42e0 	bic.w	r2, r3, #1879048192	; 0x70000000
 800395e:	687b      	ldr	r3, [r7, #4]
 8003960:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 8003964:	492a      	ldr	r1, [pc, #168]	; (8003a10 <HAL_RCCEx_PeriphCLKConfig+0xaf0>)
 8003966:	4313      	orrs	r3, r2
 8003968:	654b      	str	r3, [r1, #84]	; 0x54
 800396a:	e001      	b.n	8003970 <HAL_RCCEx_PeriphCLKConfig+0xa50>
    }
    else
    {
      /* set overall return value */
      status = ret;
 800396c:	7dfb      	ldrb	r3, [r7, #23]
 800396e:	75bb      	strb	r3, [r7, #22]
    }
  }

  /*---------------------------- LPTIM2 configuration -------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LPTIM2) == RCC_PERIPHCLK_LPTIM2)
 8003970:	687b      	ldr	r3, [r7, #4]
 8003972:	681b      	ldr	r3, [r3, #0]
 8003974:	f003 0340 	and.w	r3, r3, #64	; 0x40
 8003978:	2b00      	cmp	r3, #0
 800397a:	d04d      	beq.n	8003a18 <HAL_RCCEx_PeriphCLKConfig+0xaf8>
  {
    switch(PeriphClkInit->Lptim2ClockSelection)
 800397c:	687b      	ldr	r3, [r7, #4]
 800397e:	f8d3 309c 	ldr.w	r3, [r3, #156]	; 0x9c
 8003982:	f5b3 5fa0 	cmp.w	r3, #5120	; 0x1400
 8003986:	d02e      	beq.n	80039e6 <HAL_RCCEx_PeriphCLKConfig+0xac6>
 8003988:	f5b3 5fa0 	cmp.w	r3, #5120	; 0x1400
 800398c:	d828      	bhi.n	80039e0 <HAL_RCCEx_PeriphCLKConfig+0xac0>
 800398e:	f5b3 5f80 	cmp.w	r3, #4096	; 0x1000
 8003992:	d02a      	beq.n	80039ea <HAL_RCCEx_PeriphCLKConfig+0xaca>
 8003994:	f5b3 5f80 	cmp.w	r3, #4096	; 0x1000
 8003998:	d822      	bhi.n	80039e0 <HAL_RCCEx_PeriphCLKConfig+0xac0>
 800399a:	f5b3 6f40 	cmp.w	r3, #3072	; 0xc00
 800399e:	d026      	beq.n	80039ee <HAL_RCCEx_PeriphCLKConfig+0xace>
 80039a0:	f5b3 6f40 	cmp.w	r3, #3072	; 0xc00
 80039a4:	d81c      	bhi.n	80039e0 <HAL_RCCEx_PeriphCLKConfig+0xac0>
 80039a6:	f5b3 6f00 	cmp.w	r3, #2048	; 0x800
 80039aa:	d010      	beq.n	80039ce <HAL_RCCEx_PeriphCLKConfig+0xaae>
 80039ac:	f5b3 6f00 	cmp.w	r3, #2048	; 0x800
 80039b0:	d816      	bhi.n	80039e0 <HAL_RCCEx_PeriphCLKConfig+0xac0>
 80039b2:	2b00      	cmp	r3, #0
 80039b4:	d01d      	beq.n	80039f2 <HAL_RCCEx_PeriphCLKConfig+0xad2>
 80039b6:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
 80039ba:	d111      	bne.n	80039e0 <HAL_RCCEx_PeriphCLKConfig+0xac0>
      /* LPTIM2 clock source configuration done later after clock selection check */
      break;

    case RCC_LPTIM2CLKSOURCE_PLL2: /* PLL2 is used as clock source for LPTIM2*/

      ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2),DIVIDER_P_UPDATE);
 80039bc:	687b      	ldr	r3, [r7, #4]
 80039be:	3304      	adds	r3, #4
 80039c0:	2100      	movs	r1, #0
 80039c2:	4618      	mov	r0, r3
 80039c4:	f000 fcd8 	bl	8004378 <RCCEx_PLL2_Config>
 80039c8:	4603      	mov	r3, r0
 80039ca:	75fb      	strb	r3, [r7, #23]

      /* LPTIM2 clock source configuration done later after clock selection check */
      break;
 80039cc:	e012      	b.n	80039f4 <HAL_RCCEx_PeriphCLKConfig+0xad4>

    case RCC_LPTIM2CLKSOURCE_PLL3:  /* PLL3 is used as clock source for LPTIM2*/
      ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3),DIVIDER_R_UPDATE);
 80039ce:	687b      	ldr	r3, [r7, #4]
 80039d0:	3324      	adds	r3, #36	; 0x24
 80039d2:	2102      	movs	r1, #2
 80039d4:	4618      	mov	r0, r3
 80039d6:	f000 fd81 	bl	80044dc <RCCEx_PLL3_Config>
 80039da:	4603      	mov	r3, r0
 80039dc:	75fb      	strb	r3, [r7, #23]

      /* LPTIM2 clock source configuration done later after clock selection check */
      break;
 80039de:	e009      	b.n	80039f4 <HAL_RCCEx_PeriphCLKConfig+0xad4>
      /* HSI, HSE, or CSI oscillator is used as source of LPTIM2 clock */
      /* LPTIM2 clock source configuration done later after clock selection check */
      break;

    default:
      ret = HAL_ERROR;
 80039e0:	2301      	movs	r3, #1
 80039e2:	75fb      	strb	r3, [r7, #23]
      break;
 80039e4:	e006      	b.n	80039f4 <HAL_RCCEx_PeriphCLKConfig+0xad4>
      break;
 80039e6:	bf00      	nop
 80039e8:	e004      	b.n	80039f4 <HAL_RCCEx_PeriphCLKConfig+0xad4>
      break;
 80039ea:	bf00      	nop
 80039ec:	e002      	b.n	80039f4 <HAL_RCCEx_PeriphCLKConfig+0xad4>
      break;
 80039ee:	bf00      	nop
 80039f0:	e000      	b.n	80039f4 <HAL_RCCEx_PeriphCLKConfig+0xad4>
      break;
 80039f2:	bf00      	nop
    }

    if(ret == HAL_OK)
 80039f4:	7dfb      	ldrb	r3, [r7, #23]
 80039f6:	2b00      	cmp	r3, #0
 80039f8:	d10c      	bne.n	8003a14 <HAL_RCCEx_PeriphCLKConfig+0xaf4>
    {
      /* Set the source of LPTIM2 clock*/
      __HAL_RCC_LPTIM2_CONFIG(PeriphClkInit->Lptim2ClockSelection);
 80039fa:	4b05      	ldr	r3, [pc, #20]	; (8003a10 <HAL_RCCEx_PeriphCLKConfig+0xaf0>)
 80039fc:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 80039fe:	f423 52e0 	bic.w	r2, r3, #7168	; 0x1c00
 8003a02:	687b      	ldr	r3, [r7, #4]
 8003a04:	f8d3 309c 	ldr.w	r3, [r3, #156]	; 0x9c
 8003a08:	4901      	ldr	r1, [pc, #4]	; (8003a10 <HAL_RCCEx_PeriphCLKConfig+0xaf0>)
 8003a0a:	4313      	orrs	r3, r2
 8003a0c:	658b      	str	r3, [r1, #88]	; 0x58
 8003a0e:	e003      	b.n	8003a18 <HAL_RCCEx_PeriphCLKConfig+0xaf8>
 8003a10:	58024400 	.word	0x58024400
    }
    else
    {
      /* set overall return value */
      status = ret;
 8003a14:	7dfb      	ldrb	r3, [r7, #23]
 8003a16:	75bb      	strb	r3, [r7, #22]
    }
  }

  /*---------------------------- LPTIM345 configuration -------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LPTIM345) == RCC_PERIPHCLK_LPTIM345)
 8003a18:	687b      	ldr	r3, [r7, #4]
 8003a1a:	681b      	ldr	r3, [r3, #0]
 8003a1c:	f003 0380 	and.w	r3, r3, #128	; 0x80
 8003a20:	2b00      	cmp	r3, #0
 8003a22:	d04b      	beq.n	8003abc <HAL_RCCEx_PeriphCLKConfig+0xb9c>
  {
    switch(PeriphClkInit->Lptim345ClockSelection)
 8003a24:	687b      	ldr	r3, [r7, #4]
 8003a26:	f8d3 30a0 	ldr.w	r3, [r3, #160]	; 0xa0
 8003a2a:	f5b3 4f20 	cmp.w	r3, #40960	; 0xa000
 8003a2e:	d02e      	beq.n	8003a8e <HAL_RCCEx_PeriphCLKConfig+0xb6e>
 8003a30:	f5b3 4f20 	cmp.w	r3, #40960	; 0xa000
 8003a34:	d828      	bhi.n	8003a88 <HAL_RCCEx_PeriphCLKConfig+0xb68>
 8003a36:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
 8003a3a:	d02a      	beq.n	8003a92 <HAL_RCCEx_PeriphCLKConfig+0xb72>
 8003a3c:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
 8003a40:	d822      	bhi.n	8003a88 <HAL_RCCEx_PeriphCLKConfig+0xb68>
 8003a42:	f5b3 4fc0 	cmp.w	r3, #24576	; 0x6000
 8003a46:	d026      	beq.n	8003a96 <HAL_RCCEx_PeriphCLKConfig+0xb76>
 8003a48:	f5b3 4fc0 	cmp.w	r3, #24576	; 0x6000
 8003a4c:	d81c      	bhi.n	8003a88 <HAL_RCCEx_PeriphCLKConfig+0xb68>
 8003a4e:	f5b3 4f80 	cmp.w	r3, #16384	; 0x4000
 8003a52:	d010      	beq.n	8003a76 <HAL_RCCEx_PeriphCLKConfig+0xb56>
 8003a54:	f5b3 4f80 	cmp.w	r3, #16384	; 0x4000
 8003a58:	d816      	bhi.n	8003a88 <HAL_RCCEx_PeriphCLKConfig+0xb68>
 8003a5a:	2b00      	cmp	r3, #0
 8003a5c:	d01d      	beq.n	8003a9a <HAL_RCCEx_PeriphCLKConfig+0xb7a>
 8003a5e:	f5b3 5f00 	cmp.w	r3, #8192	; 0x2000
 8003a62:	d111      	bne.n	8003a88 <HAL_RCCEx_PeriphCLKConfig+0xb68>
    case RCC_LPTIM345CLKSOURCE_PCLK4:      /* SRD/D3 PCLK1 (PCLK4) as clock source for LPTIM3/4/5 */
      /* LPTIM3/4/5 clock source configuration done later after clock selection check */
      break;

    case RCC_LPTIM345CLKSOURCE_PLL2: /* PLL2 is used as clock source for LPTIM3/4/5 */
      ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2),DIVIDER_P_UPDATE);
 8003a64:	687b      	ldr	r3, [r7, #4]
 8003a66:	3304      	adds	r3, #4
 8003a68:	2100      	movs	r1, #0
 8003a6a:	4618      	mov	r0, r3
 8003a6c:	f000 fc84 	bl	8004378 <RCCEx_PLL2_Config>
 8003a70:	4603      	mov	r3, r0
 8003a72:	75fb      	strb	r3, [r7, #23]

      /* LPTIM3/4/5 clock source configuration done later after clock selection check */
      break;
 8003a74:	e012      	b.n	8003a9c <HAL_RCCEx_PeriphCLKConfig+0xb7c>

    case RCC_LPTIM345CLKSOURCE_PLL3:  /* PLL3 is used as clock source for LPTIM3/4/5 */
      ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3),DIVIDER_R_UPDATE);
 8003a76:	687b      	ldr	r3, [r7, #4]
 8003a78:	3324      	adds	r3, #36	; 0x24
 8003a7a:	2102      	movs	r1, #2
 8003a7c:	4618      	mov	r0, r3
 8003a7e:	f000 fd2d 	bl	80044dc <RCCEx_PLL3_Config>
 8003a82:	4603      	mov	r3, r0
 8003a84:	75fb      	strb	r3, [r7, #23]

      /* LPTIM3/4/5 clock source configuration done later after clock selection check */
      break;
 8003a86:	e009      	b.n	8003a9c <HAL_RCCEx_PeriphCLKConfig+0xb7c>
      /* HSI, HSE, or CSI oscillator is used as source of LPTIM3/4/5 clock */
      /* LPTIM3/4/5 clock source configuration done later after clock selection check */
      break;

    default:
      ret = HAL_ERROR;
 8003a88:	2301      	movs	r3, #1
 8003a8a:	75fb      	strb	r3, [r7, #23]
      break;
 8003a8c:	e006      	b.n	8003a9c <HAL_RCCEx_PeriphCLKConfig+0xb7c>
      break;
 8003a8e:	bf00      	nop
 8003a90:	e004      	b.n	8003a9c <HAL_RCCEx_PeriphCLKConfig+0xb7c>
      break;
 8003a92:	bf00      	nop
 8003a94:	e002      	b.n	8003a9c <HAL_RCCEx_PeriphCLKConfig+0xb7c>
      break;
 8003a96:	bf00      	nop
 8003a98:	e000      	b.n	8003a9c <HAL_RCCEx_PeriphCLKConfig+0xb7c>
      break;
 8003a9a:	bf00      	nop
    }

    if(ret == HAL_OK)
 8003a9c:	7dfb      	ldrb	r3, [r7, #23]
 8003a9e:	2b00      	cmp	r3, #0
 8003aa0:	d10a      	bne.n	8003ab8 <HAL_RCCEx_PeriphCLKConfig+0xb98>
    {
      /* Set the source of LPTIM3/4/5 clock */
      __HAL_RCC_LPTIM345_CONFIG(PeriphClkInit->Lptim345ClockSelection);
 8003aa2:	4b9e      	ldr	r3, [pc, #632]	; (8003d1c <HAL_RCCEx_PeriphCLKConfig+0xdfc>)
 8003aa4:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 8003aa6:	f423 4260 	bic.w	r2, r3, #57344	; 0xe000
 8003aaa:	687b      	ldr	r3, [r7, #4]
 8003aac:	f8d3 30a0 	ldr.w	r3, [r3, #160]	; 0xa0
 8003ab0:	499a      	ldr	r1, [pc, #616]	; (8003d1c <HAL_RCCEx_PeriphCLKConfig+0xdfc>)
 8003ab2:	4313      	orrs	r3, r2
 8003ab4:	658b      	str	r3, [r1, #88]	; 0x58
 8003ab6:	e001      	b.n	8003abc <HAL_RCCEx_PeriphCLKConfig+0xb9c>
    }
    else
    {
      /* set overall return value */
      status = ret;
 8003ab8:	7dfb      	ldrb	r3, [r7, #23]
 8003aba:	75bb      	strb	r3, [r7, #22]

      __HAL_RCC_I2C1235_CONFIG(PeriphClkInit->I2c1235ClockSelection);

  }
#else
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2C123) == RCC_PERIPHCLK_I2C123)
 8003abc:	687b      	ldr	r3, [r7, #4]
 8003abe:	681b      	ldr	r3, [r3, #0]
 8003ac0:	f003 0308 	and.w	r3, r3, #8
 8003ac4:	2b00      	cmp	r3, #0
 8003ac6:	d01a      	beq.n	8003afe <HAL_RCCEx_PeriphCLKConfig+0xbde>
  {
    /* Check the parameters */
    assert_param(IS_RCC_I2C123CLKSOURCE(PeriphClkInit->I2c123ClockSelection));

    if ((PeriphClkInit->I2c123ClockSelection )== RCC_I2C123CLKSOURCE_PLL3 )
 8003ac8:	687b      	ldr	r3, [r7, #4]
 8003aca:	f8d3 3084 	ldr.w	r3, [r3, #132]	; 0x84
 8003ace:	f5b3 5f80 	cmp.w	r3, #4096	; 0x1000
 8003ad2:	d10a      	bne.n	8003aea <HAL_RCCEx_PeriphCLKConfig+0xbca>
    {
        if(RCCEx_PLL3_Config(&(PeriphClkInit->PLL3),DIVIDER_R_UPDATE)!= HAL_OK)
 8003ad4:	687b      	ldr	r3, [r7, #4]
 8003ad6:	3324      	adds	r3, #36	; 0x24
 8003ad8:	2102      	movs	r1, #2
 8003ada:	4618      	mov	r0, r3
 8003adc:	f000 fcfe 	bl	80044dc <RCCEx_PLL3_Config>
 8003ae0:	4603      	mov	r3, r0
 8003ae2:	2b00      	cmp	r3, #0
 8003ae4:	d001      	beq.n	8003aea <HAL_RCCEx_PeriphCLKConfig+0xbca>
        {
          status = HAL_ERROR;
 8003ae6:	2301      	movs	r3, #1
 8003ae8:	75bb      	strb	r3, [r7, #22]
        }
    }

      __HAL_RCC_I2C123_CONFIG(PeriphClkInit->I2c123ClockSelection);
 8003aea:	4b8c      	ldr	r3, [pc, #560]	; (8003d1c <HAL_RCCEx_PeriphCLKConfig+0xdfc>)
 8003aec:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 8003aee:	f423 5240 	bic.w	r2, r3, #12288	; 0x3000
 8003af2:	687b      	ldr	r3, [r7, #4]
 8003af4:	f8d3 3084 	ldr.w	r3, [r3, #132]	; 0x84
 8003af8:	4988      	ldr	r1, [pc, #544]	; (8003d1c <HAL_RCCEx_PeriphCLKConfig+0xdfc>)
 8003afa:	4313      	orrs	r3, r2
 8003afc:	654b      	str	r3, [r1, #84]	; 0x54

  }
#endif /* I2C5 */

  /*------------------------------ I2C4 Configuration ------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2C4) == RCC_PERIPHCLK_I2C4)
 8003afe:	687b      	ldr	r3, [r7, #4]
 8003b00:	681b      	ldr	r3, [r3, #0]
 8003b02:	f003 0310 	and.w	r3, r3, #16
 8003b06:	2b00      	cmp	r3, #0
 8003b08:	d01a      	beq.n	8003b40 <HAL_RCCEx_PeriphCLKConfig+0xc20>
  {
    /* Check the parameters */
    assert_param(IS_RCC_I2C4CLKSOURCE(PeriphClkInit->I2c4ClockSelection));

    if ((PeriphClkInit->I2c4ClockSelection) == RCC_I2C4CLKSOURCE_PLL3 )
 8003b0a:	687b      	ldr	r3, [r7, #4]
 8003b0c:	f8d3 3098 	ldr.w	r3, [r3, #152]	; 0x98
 8003b10:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
 8003b14:	d10a      	bne.n	8003b2c <HAL_RCCEx_PeriphCLKConfig+0xc0c>
    {
      if(RCCEx_PLL3_Config(&(PeriphClkInit->PLL3),DIVIDER_R_UPDATE)!= HAL_OK)
 8003b16:	687b      	ldr	r3, [r7, #4]
 8003b18:	3324      	adds	r3, #36	; 0x24
 8003b1a:	2102      	movs	r1, #2
 8003b1c:	4618      	mov	r0, r3
 8003b1e:	f000 fcdd 	bl	80044dc <RCCEx_PLL3_Config>
 8003b22:	4603      	mov	r3, r0
 8003b24:	2b00      	cmp	r3, #0
 8003b26:	d001      	beq.n	8003b2c <HAL_RCCEx_PeriphCLKConfig+0xc0c>
      {
        status = HAL_ERROR;
 8003b28:	2301      	movs	r3, #1
 8003b2a:	75bb      	strb	r3, [r7, #22]
      }
    }

      __HAL_RCC_I2C4_CONFIG(PeriphClkInit->I2c4ClockSelection);
 8003b2c:	4b7b      	ldr	r3, [pc, #492]	; (8003d1c <HAL_RCCEx_PeriphCLKConfig+0xdfc>)
 8003b2e:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 8003b30:	f423 7240 	bic.w	r2, r3, #768	; 0x300
 8003b34:	687b      	ldr	r3, [r7, #4]
 8003b36:	f8d3 3098 	ldr.w	r3, [r3, #152]	; 0x98
 8003b3a:	4978      	ldr	r1, [pc, #480]	; (8003d1c <HAL_RCCEx_PeriphCLKConfig+0xdfc>)
 8003b3c:	4313      	orrs	r3, r2
 8003b3e:	658b      	str	r3, [r1, #88]	; 0x58

  }

  /*---------------------------- ADC configuration -------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_ADC) == RCC_PERIPHCLK_ADC)
 8003b40:	687b      	ldr	r3, [r7, #4]
 8003b42:	681b      	ldr	r3, [r3, #0]
 8003b44:	f403 2300 	and.w	r3, r3, #524288	; 0x80000
 8003b48:	2b00      	cmp	r3, #0
 8003b4a:	d034      	beq.n	8003bb6 <HAL_RCCEx_PeriphCLKConfig+0xc96>
  {
    switch(PeriphClkInit->AdcClockSelection)
 8003b4c:	687b      	ldr	r3, [r7, #4]
 8003b4e:	f8d3 30a4 	ldr.w	r3, [r3, #164]	; 0xa4
 8003b52:	f5b3 3f00 	cmp.w	r3, #131072	; 0x20000
 8003b56:	d01d      	beq.n	8003b94 <HAL_RCCEx_PeriphCLKConfig+0xc74>
 8003b58:	f5b3 3f00 	cmp.w	r3, #131072	; 0x20000
 8003b5c:	d817      	bhi.n	8003b8e <HAL_RCCEx_PeriphCLKConfig+0xc6e>
 8003b5e:	2b00      	cmp	r3, #0
 8003b60:	d003      	beq.n	8003b6a <HAL_RCCEx_PeriphCLKConfig+0xc4a>
 8003b62:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
 8003b66:	d009      	beq.n	8003b7c <HAL_RCCEx_PeriphCLKConfig+0xc5c>
 8003b68:	e011      	b.n	8003b8e <HAL_RCCEx_PeriphCLKConfig+0xc6e>
    {

    case RCC_ADCCLKSOURCE_PLL2: /* PLL2 is used as clock source for ADC*/

      ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2),DIVIDER_P_UPDATE);
 8003b6a:	687b      	ldr	r3, [r7, #4]
 8003b6c:	3304      	adds	r3, #4
 8003b6e:	2100      	movs	r1, #0
 8003b70:	4618      	mov	r0, r3
 8003b72:	f000 fc01 	bl	8004378 <RCCEx_PLL2_Config>
 8003b76:	4603      	mov	r3, r0
 8003b78:	75fb      	strb	r3, [r7, #23]

      /* ADC clock source configuration done later after clock selection check */
      break;
 8003b7a:	e00c      	b.n	8003b96 <HAL_RCCEx_PeriphCLKConfig+0xc76>

    case RCC_ADCCLKSOURCE_PLL3:  /* PLL3 is used as clock source for ADC*/
      ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3),DIVIDER_R_UPDATE);
 8003b7c:	687b      	ldr	r3, [r7, #4]
 8003b7e:	3324      	adds	r3, #36	; 0x24
 8003b80:	2102      	movs	r1, #2
 8003b82:	4618      	mov	r0, r3
 8003b84:	f000 fcaa 	bl	80044dc <RCCEx_PLL3_Config>
 8003b88:	4603      	mov	r3, r0
 8003b8a:	75fb      	strb	r3, [r7, #23]

      /* ADC clock source configuration done later after clock selection check */
      break;
 8003b8c:	e003      	b.n	8003b96 <HAL_RCCEx_PeriphCLKConfig+0xc76>
      /* HSI, HSE, or CSI oscillator is used as source of ADC clock */
      /* ADC clock source configuration done later after clock selection check */
      break;

    default:
      ret = HAL_ERROR;
 8003b8e:	2301      	movs	r3, #1
 8003b90:	75fb      	strb	r3, [r7, #23]
      break;
 8003b92:	e000      	b.n	8003b96 <HAL_RCCEx_PeriphCLKConfig+0xc76>
      break;
 8003b94:	bf00      	nop
    }

    if(ret == HAL_OK)
 8003b96:	7dfb      	ldrb	r3, [r7, #23]
 8003b98:	2b00      	cmp	r3, #0
 8003b9a:	d10a      	bne.n	8003bb2 <HAL_RCCEx_PeriphCLKConfig+0xc92>
    {
      /* Set the source of ADC clock*/
      __HAL_RCC_ADC_CONFIG(PeriphClkInit->AdcClockSelection);
 8003b9c:	4b5f      	ldr	r3, [pc, #380]	; (8003d1c <HAL_RCCEx_PeriphCLKConfig+0xdfc>)
 8003b9e:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 8003ba0:	f423 3240 	bic.w	r2, r3, #196608	; 0x30000
 8003ba4:	687b      	ldr	r3, [r7, #4]
 8003ba6:	f8d3 30a4 	ldr.w	r3, [r3, #164]	; 0xa4
 8003baa:	495c      	ldr	r1, [pc, #368]	; (8003d1c <HAL_RCCEx_PeriphCLKConfig+0xdfc>)
 8003bac:	4313      	orrs	r3, r2
 8003bae:	658b      	str	r3, [r1, #88]	; 0x58
 8003bb0:	e001      	b.n	8003bb6 <HAL_RCCEx_PeriphCLKConfig+0xc96>
    }
    else
    {
      /* set overall return value */
      status = ret;
 8003bb2:	7dfb      	ldrb	r3, [r7, #23]
 8003bb4:	75bb      	strb	r3, [r7, #22]
    }
  }

  /*------------------------------ USB Configuration -------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USB) == RCC_PERIPHCLK_USB)
 8003bb6:	687b      	ldr	r3, [r7, #4]
 8003bb8:	681b      	ldr	r3, [r3, #0]
 8003bba:	f403 2380 	and.w	r3, r3, #262144	; 0x40000
 8003bbe:	2b00      	cmp	r3, #0
 8003bc0:	d033      	beq.n	8003c2a <HAL_RCCEx_PeriphCLKConfig+0xd0a>
  {

    switch(PeriphClkInit->UsbClockSelection)
 8003bc2:	687b      	ldr	r3, [r7, #4]
 8003bc4:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
 8003bc8:	f5b3 1f40 	cmp.w	r3, #3145728	; 0x300000
 8003bcc:	d01c      	beq.n	8003c08 <HAL_RCCEx_PeriphCLKConfig+0xce8>
 8003bce:	f5b3 1f40 	cmp.w	r3, #3145728	; 0x300000
 8003bd2:	d816      	bhi.n	8003c02 <HAL_RCCEx_PeriphCLKConfig+0xce2>
 8003bd4:	f5b3 1f80 	cmp.w	r3, #1048576	; 0x100000
 8003bd8:	d003      	beq.n	8003be2 <HAL_RCCEx_PeriphCLKConfig+0xcc2>
 8003bda:	f5b3 1f00 	cmp.w	r3, #2097152	; 0x200000
 8003bde:	d007      	beq.n	8003bf0 <HAL_RCCEx_PeriphCLKConfig+0xcd0>
 8003be0:	e00f      	b.n	8003c02 <HAL_RCCEx_PeriphCLKConfig+0xce2>
    {
    case RCC_USBCLKSOURCE_PLL:      /* PLL is used as clock source for USB*/
      /* Enable USB Clock output generated form System USB . */
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL1_DIVQ);
 8003be2:	4b4e      	ldr	r3, [pc, #312]	; (8003d1c <HAL_RCCEx_PeriphCLKConfig+0xdfc>)
 8003be4:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8003be6:	4a4d      	ldr	r2, [pc, #308]	; (8003d1c <HAL_RCCEx_PeriphCLKConfig+0xdfc>)
 8003be8:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
 8003bec:	62d3      	str	r3, [r2, #44]	; 0x2c

      /* USB clock source configuration done later after clock selection check */
      break;
 8003bee:	e00c      	b.n	8003c0a <HAL_RCCEx_PeriphCLKConfig+0xcea>

    case RCC_USBCLKSOURCE_PLL3: /* PLL3 is used as clock source for USB*/

      ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3),DIVIDER_Q_UPDATE);
 8003bf0:	687b      	ldr	r3, [r7, #4]
 8003bf2:	3324      	adds	r3, #36	; 0x24
 8003bf4:	2101      	movs	r1, #1
 8003bf6:	4618      	mov	r0, r3
 8003bf8:	f000 fc70 	bl	80044dc <RCCEx_PLL3_Config>
 8003bfc:	4603      	mov	r3, r0
 8003bfe:	75fb      	strb	r3, [r7, #23]

      /* USB clock source configuration done later after clock selection check */
      break;
 8003c00:	e003      	b.n	8003c0a <HAL_RCCEx_PeriphCLKConfig+0xcea>
      /* HSI48 oscillator is used as source of USB clock */
      /* USB clock source configuration done later after clock selection check */
      break;

    default:
      ret = HAL_ERROR;
 8003c02:	2301      	movs	r3, #1
 8003c04:	75fb      	strb	r3, [r7, #23]
      break;
 8003c06:	e000      	b.n	8003c0a <HAL_RCCEx_PeriphCLKConfig+0xcea>
      break;
 8003c08:	bf00      	nop
    }

    if(ret == HAL_OK)
 8003c0a:	7dfb      	ldrb	r3, [r7, #23]
 8003c0c:	2b00      	cmp	r3, #0
 8003c0e:	d10a      	bne.n	8003c26 <HAL_RCCEx_PeriphCLKConfig+0xd06>
    {
      /* Set the source of USB clock*/
      __HAL_RCC_USB_CONFIG(PeriphClkInit->UsbClockSelection);
 8003c10:	4b42      	ldr	r3, [pc, #264]	; (8003d1c <HAL_RCCEx_PeriphCLKConfig+0xdfc>)
 8003c12:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 8003c14:	f423 1240 	bic.w	r2, r3, #3145728	; 0x300000
 8003c18:	687b      	ldr	r3, [r7, #4]
 8003c1a:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
 8003c1e:	493f      	ldr	r1, [pc, #252]	; (8003d1c <HAL_RCCEx_PeriphCLKConfig+0xdfc>)
 8003c20:	4313      	orrs	r3, r2
 8003c22:	654b      	str	r3, [r1, #84]	; 0x54
 8003c24:	e001      	b.n	8003c2a <HAL_RCCEx_PeriphCLKConfig+0xd0a>
    }
    else
    {
      /* set overall return value */
      status = ret;
 8003c26:	7dfb      	ldrb	r3, [r7, #23]
 8003c28:	75bb      	strb	r3, [r7, #22]
    }

  }

  /*------------------------------------- SDMMC Configuration ------------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SDMMC) == RCC_PERIPHCLK_SDMMC)
 8003c2a:	687b      	ldr	r3, [r7, #4]
 8003c2c:	681b      	ldr	r3, [r3, #0]
 8003c2e:	f403 3380 	and.w	r3, r3, #65536	; 0x10000
 8003c32:	2b00      	cmp	r3, #0
 8003c34:	d029      	beq.n	8003c8a <HAL_RCCEx_PeriphCLKConfig+0xd6a>
  {
    /* Check the parameters */
    assert_param(IS_RCC_SDMMC(PeriphClkInit->SdmmcClockSelection));

    switch(PeriphClkInit->SdmmcClockSelection)
 8003c36:	687b      	ldr	r3, [r7, #4]
 8003c38:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 8003c3a:	2b00      	cmp	r3, #0
 8003c3c:	d003      	beq.n	8003c46 <HAL_RCCEx_PeriphCLKConfig+0xd26>
 8003c3e:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
 8003c42:	d007      	beq.n	8003c54 <HAL_RCCEx_PeriphCLKConfig+0xd34>
 8003c44:	e00f      	b.n	8003c66 <HAL_RCCEx_PeriphCLKConfig+0xd46>
    {
    case RCC_SDMMCCLKSOURCE_PLL:      /* PLL is used as clock source for SDMMC*/
      /* Enable SDMMC Clock output generated form System PLL . */
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL1_DIVQ);
 8003c46:	4b35      	ldr	r3, [pc, #212]	; (8003d1c <HAL_RCCEx_PeriphCLKConfig+0xdfc>)
 8003c48:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8003c4a:	4a34      	ldr	r2, [pc, #208]	; (8003d1c <HAL_RCCEx_PeriphCLKConfig+0xdfc>)
 8003c4c:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
 8003c50:	62d3      	str	r3, [r2, #44]	; 0x2c

      /* SDMMC clock source configuration done later after clock selection check */
      break;
 8003c52:	e00b      	b.n	8003c6c <HAL_RCCEx_PeriphCLKConfig+0xd4c>

    case RCC_SDMMCCLKSOURCE_PLL2: /* PLL2 is used as clock source for SDMMC*/

      ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2),DIVIDER_R_UPDATE);
 8003c54:	687b      	ldr	r3, [r7, #4]
 8003c56:	3304      	adds	r3, #4
 8003c58:	2102      	movs	r1, #2
 8003c5a:	4618      	mov	r0, r3
 8003c5c:	f000 fb8c 	bl	8004378 <RCCEx_PLL2_Config>
 8003c60:	4603      	mov	r3, r0
 8003c62:	75fb      	strb	r3, [r7, #23]

      /* SDMMC clock source configuration done later after clock selection check */
      break;
 8003c64:	e002      	b.n	8003c6c <HAL_RCCEx_PeriphCLKConfig+0xd4c>

    default:
      ret = HAL_ERROR;
 8003c66:	2301      	movs	r3, #1
 8003c68:	75fb      	strb	r3, [r7, #23]
      break;
 8003c6a:	bf00      	nop
    }

    if(ret == HAL_OK)
 8003c6c:	7dfb      	ldrb	r3, [r7, #23]
 8003c6e:	2b00      	cmp	r3, #0
 8003c70:	d109      	bne.n	8003c86 <HAL_RCCEx_PeriphCLKConfig+0xd66>
    {
      /* Set the source of SDMMC clock*/
      __HAL_RCC_SDMMC_CONFIG(PeriphClkInit->SdmmcClockSelection);
 8003c72:	4b2a      	ldr	r3, [pc, #168]	; (8003d1c <HAL_RCCEx_PeriphCLKConfig+0xdfc>)
 8003c74:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 8003c76:	f423 3280 	bic.w	r2, r3, #65536	; 0x10000
 8003c7a:	687b      	ldr	r3, [r7, #4]
 8003c7c:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 8003c7e:	4927      	ldr	r1, [pc, #156]	; (8003d1c <HAL_RCCEx_PeriphCLKConfig+0xdfc>)
 8003c80:	4313      	orrs	r3, r2
 8003c82:	64cb      	str	r3, [r1, #76]	; 0x4c
 8003c84:	e001      	b.n	8003c8a <HAL_RCCEx_PeriphCLKConfig+0xd6a>
    }
    else
    {
      /* set overall return value */
      status = ret;
 8003c86:	7dfb      	ldrb	r3, [r7, #23]
 8003c88:	75bb      	strb	r3, [r7, #22]
    }
  }

#if defined(LTDC)
  /*-------------------------------------- LTDC Configuration -----------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LTDC) == RCC_PERIPHCLK_LTDC)
 8003c8a:	687b      	ldr	r3, [r7, #4]
 8003c8c:	681b      	ldr	r3, [r3, #0]
 8003c8e:	f003 5300 	and.w	r3, r3, #536870912	; 0x20000000
 8003c92:	2b00      	cmp	r3, #0
 8003c94:	d00a      	beq.n	8003cac <HAL_RCCEx_PeriphCLKConfig+0xd8c>
  {
    if(RCCEx_PLL3_Config(&(PeriphClkInit->PLL3),DIVIDER_R_UPDATE)!=HAL_OK)
 8003c96:	687b      	ldr	r3, [r7, #4]
 8003c98:	3324      	adds	r3, #36	; 0x24
 8003c9a:	2102      	movs	r1, #2
 8003c9c:	4618      	mov	r0, r3
 8003c9e:	f000 fc1d 	bl	80044dc <RCCEx_PLL3_Config>
 8003ca2:	4603      	mov	r3, r0
 8003ca4:	2b00      	cmp	r3, #0
 8003ca6:	d001      	beq.n	8003cac <HAL_RCCEx_PeriphCLKConfig+0xd8c>
    {
      status=HAL_ERROR;
 8003ca8:	2301      	movs	r3, #1
 8003caa:	75bb      	strb	r3, [r7, #22]
    }
  }
#endif /* LTDC */

  /*------------------------------ RNG Configuration -------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_RNG) == RCC_PERIPHCLK_RNG)
 8003cac:	687b      	ldr	r3, [r7, #4]
 8003cae:	681b      	ldr	r3, [r3, #0]
 8003cb0:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
 8003cb4:	2b00      	cmp	r3, #0
 8003cb6:	d035      	beq.n	8003d24 <HAL_RCCEx_PeriphCLKConfig+0xe04>
  {

    switch(PeriphClkInit->RngClockSelection)
 8003cb8:	687b      	ldr	r3, [r7, #4]
 8003cba:	f8d3 3080 	ldr.w	r3, [r3, #128]	; 0x80
 8003cbe:	f5b3 7f40 	cmp.w	r3, #768	; 0x300
 8003cc2:	d017      	beq.n	8003cf4 <HAL_RCCEx_PeriphCLKConfig+0xdd4>
 8003cc4:	f5b3 7f40 	cmp.w	r3, #768	; 0x300
 8003cc8:	d811      	bhi.n	8003cee <HAL_RCCEx_PeriphCLKConfig+0xdce>
 8003cca:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
 8003cce:	d013      	beq.n	8003cf8 <HAL_RCCEx_PeriphCLKConfig+0xdd8>
 8003cd0:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
 8003cd4:	d80b      	bhi.n	8003cee <HAL_RCCEx_PeriphCLKConfig+0xdce>
 8003cd6:	2b00      	cmp	r3, #0
 8003cd8:	d010      	beq.n	8003cfc <HAL_RCCEx_PeriphCLKConfig+0xddc>
 8003cda:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
 8003cde:	d106      	bne.n	8003cee <HAL_RCCEx_PeriphCLKConfig+0xdce>
    {
    case RCC_RNGCLKSOURCE_PLL:     /* PLL is used as clock source for RNG*/
      /* Enable RNG Clock output generated form System RNG . */
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL1_DIVQ);
 8003ce0:	4b0e      	ldr	r3, [pc, #56]	; (8003d1c <HAL_RCCEx_PeriphCLKConfig+0xdfc>)
 8003ce2:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8003ce4:	4a0d      	ldr	r2, [pc, #52]	; (8003d1c <HAL_RCCEx_PeriphCLKConfig+0xdfc>)
 8003ce6:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
 8003cea:	62d3      	str	r3, [r2, #44]	; 0x2c

      /* RNG clock source configuration done later after clock selection check */
      break;
 8003cec:	e007      	b.n	8003cfe <HAL_RCCEx_PeriphCLKConfig+0xdde>
      /* HSI48 oscillator is used as source of RNG clock */
      /* RNG clock source configuration done later after clock selection check */
      break;

    default:
      ret = HAL_ERROR;
 8003cee:	2301      	movs	r3, #1
 8003cf0:	75fb      	strb	r3, [r7, #23]
      break;
 8003cf2:	e004      	b.n	8003cfe <HAL_RCCEx_PeriphCLKConfig+0xdde>
      break;
 8003cf4:	bf00      	nop
 8003cf6:	e002      	b.n	8003cfe <HAL_RCCEx_PeriphCLKConfig+0xdde>
      break;
 8003cf8:	bf00      	nop
 8003cfa:	e000      	b.n	8003cfe <HAL_RCCEx_PeriphCLKConfig+0xdde>
      break;
 8003cfc:	bf00      	nop
    }

    if(ret == HAL_OK)
 8003cfe:	7dfb      	ldrb	r3, [r7, #23]
 8003d00:	2b00      	cmp	r3, #0
 8003d02:	d10d      	bne.n	8003d20 <HAL_RCCEx_PeriphCLKConfig+0xe00>
    {
      /* Set the source of RNG clock*/
      __HAL_RCC_RNG_CONFIG(PeriphClkInit->RngClockSelection);
 8003d04:	4b05      	ldr	r3, [pc, #20]	; (8003d1c <HAL_RCCEx_PeriphCLKConfig+0xdfc>)
 8003d06:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 8003d08:	f423 7240 	bic.w	r2, r3, #768	; 0x300
 8003d0c:	687b      	ldr	r3, [r7, #4]
 8003d0e:	f8d3 3080 	ldr.w	r3, [r3, #128]	; 0x80
 8003d12:	4902      	ldr	r1, [pc, #8]	; (8003d1c <HAL_RCCEx_PeriphCLKConfig+0xdfc>)
 8003d14:	4313      	orrs	r3, r2
 8003d16:	654b      	str	r3, [r1, #84]	; 0x54
 8003d18:	e004      	b.n	8003d24 <HAL_RCCEx_PeriphCLKConfig+0xe04>
 8003d1a:	bf00      	nop
 8003d1c:	58024400 	.word	0x58024400
    }
    else
    {
      /* set overall return value */
      status = ret;
 8003d20:	7dfb      	ldrb	r3, [r7, #23]
 8003d22:	75bb      	strb	r3, [r7, #22]
    }

  }

  /*------------------------------ SWPMI1 Configuration ------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SWPMI1) == RCC_PERIPHCLK_SWPMI1)
 8003d24:	687b      	ldr	r3, [r7, #4]
 8003d26:	681b      	ldr	r3, [r3, #0]
 8003d28:	f403 1380 	and.w	r3, r3, #1048576	; 0x100000
 8003d2c:	2b00      	cmp	r3, #0
 8003d2e:	d008      	beq.n	8003d42 <HAL_RCCEx_PeriphCLKConfig+0xe22>
  {
    /* Check the parameters */
    assert_param(IS_RCC_SWPMI1CLKSOURCE(PeriphClkInit->Swpmi1ClockSelection));

    /* Configure the SWPMI1 interface clock source */
    __HAL_RCC_SWPMI1_CONFIG(PeriphClkInit->Swpmi1ClockSelection);
 8003d30:	4b31      	ldr	r3, [pc, #196]	; (8003df8 <HAL_RCCEx_PeriphCLKConfig+0xed8>)
 8003d32:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 8003d34:	f023 4200 	bic.w	r2, r3, #2147483648	; 0x80000000
 8003d38:	687b      	ldr	r3, [r7, #4]
 8003d3a:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 8003d3c:	492e      	ldr	r1, [pc, #184]	; (8003df8 <HAL_RCCEx_PeriphCLKConfig+0xed8>)
 8003d3e:	4313      	orrs	r3, r2
 8003d40:	650b      	str	r3, [r1, #80]	; 0x50
  }
#if defined(HRTIM1)
  /*------------------------------ HRTIM1 clock Configuration ----------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_HRTIM1) == RCC_PERIPHCLK_HRTIM1)
 8003d42:	687b      	ldr	r3, [r7, #4]
 8003d44:	681b      	ldr	r3, [r3, #0]
 8003d46:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
 8003d4a:	2b00      	cmp	r3, #0
 8003d4c:	d009      	beq.n	8003d62 <HAL_RCCEx_PeriphCLKConfig+0xe42>
  {
    /* Check the parameters */
    assert_param(IS_RCC_HRTIM1CLKSOURCE(PeriphClkInit->Hrtim1ClockSelection));

    /* Configure the HRTIM1 clock source */
    __HAL_RCC_HRTIM1_CONFIG(PeriphClkInit->Hrtim1ClockSelection);
 8003d4e:	4b2a      	ldr	r3, [pc, #168]	; (8003df8 <HAL_RCCEx_PeriphCLKConfig+0xed8>)
 8003d50:	691b      	ldr	r3, [r3, #16]
 8003d52:	f423 4280 	bic.w	r2, r3, #16384	; 0x4000
 8003d56:	687b      	ldr	r3, [r7, #4]
 8003d58:	f8d3 30b8 	ldr.w	r3, [r3, #184]	; 0xb8
 8003d5c:	4926      	ldr	r1, [pc, #152]	; (8003df8 <HAL_RCCEx_PeriphCLKConfig+0xed8>)
 8003d5e:	4313      	orrs	r3, r2
 8003d60:	610b      	str	r3, [r1, #16]
  }
#endif  /*HRTIM1*/
  /*------------------------------ DFSDM1 Configuration ------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_DFSDM1) == RCC_PERIPHCLK_DFSDM1)
 8003d62:	687b      	ldr	r3, [r7, #4]
 8003d64:	681b      	ldr	r3, [r3, #0]
 8003d66:	f403 1300 	and.w	r3, r3, #2097152	; 0x200000
 8003d6a:	2b00      	cmp	r3, #0
 8003d6c:	d008      	beq.n	8003d80 <HAL_RCCEx_PeriphCLKConfig+0xe60>
  {
    /* Check the parameters */
    assert_param(IS_RCC_DFSDM1CLKSOURCE(PeriphClkInit->Dfsdm1ClockSelection));

    /* Configure the DFSDM1 interface clock source */
    __HAL_RCC_DFSDM1_CONFIG(PeriphClkInit->Dfsdm1ClockSelection);
 8003d6e:	4b22      	ldr	r3, [pc, #136]	; (8003df8 <HAL_RCCEx_PeriphCLKConfig+0xed8>)
 8003d70:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 8003d72:	f023 7280 	bic.w	r2, r3, #16777216	; 0x1000000
 8003d76:	687b      	ldr	r3, [r7, #4]
 8003d78:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 8003d7a:	491f      	ldr	r1, [pc, #124]	; (8003df8 <HAL_RCCEx_PeriphCLKConfig+0xed8>)
 8003d7c:	4313      	orrs	r3, r2
 8003d7e:	650b      	str	r3, [r1, #80]	; 0x50
    __HAL_RCC_DFSDM2_CONFIG(PeriphClkInit->Dfsdm2ClockSelection);
  }
#endif  /* DFSDM2 */

  /*------------------------------------ TIM configuration --------------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_TIM) == RCC_PERIPHCLK_TIM)
 8003d80:	687b      	ldr	r3, [r7, #4]
 8003d82:	681b      	ldr	r3, [r3, #0]
 8003d84:	f003 4380 	and.w	r3, r3, #1073741824	; 0x40000000
 8003d88:	2b00      	cmp	r3, #0
 8003d8a:	d00d      	beq.n	8003da8 <HAL_RCCEx_PeriphCLKConfig+0xe88>
  {
    /* Check the parameters */
    assert_param(IS_RCC_TIMPRES(PeriphClkInit->TIMPresSelection));

    /* Configure Timer Prescaler */
    __HAL_RCC_TIMCLKPRESCALER(PeriphClkInit->TIMPresSelection);
 8003d8c:	4b1a      	ldr	r3, [pc, #104]	; (8003df8 <HAL_RCCEx_PeriphCLKConfig+0xed8>)
 8003d8e:	691b      	ldr	r3, [r3, #16]
 8003d90:	4a19      	ldr	r2, [pc, #100]	; (8003df8 <HAL_RCCEx_PeriphCLKConfig+0xed8>)
 8003d92:	f423 4300 	bic.w	r3, r3, #32768	; 0x8000
 8003d96:	6113      	str	r3, [r2, #16]
 8003d98:	4b17      	ldr	r3, [pc, #92]	; (8003df8 <HAL_RCCEx_PeriphCLKConfig+0xed8>)
 8003d9a:	691a      	ldr	r2, [r3, #16]
 8003d9c:	687b      	ldr	r3, [r7, #4]
 8003d9e:	f8d3 30bc 	ldr.w	r3, [r3, #188]	; 0xbc
 8003da2:	4915      	ldr	r1, [pc, #84]	; (8003df8 <HAL_RCCEx_PeriphCLKConfig+0xed8>)
 8003da4:	4313      	orrs	r3, r2
 8003da6:	610b      	str	r3, [r1, #16]
  }

  /*------------------------------------ CKPER configuration --------------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_CKPER) == RCC_PERIPHCLK_CKPER)
 8003da8:	687b      	ldr	r3, [r7, #4]
 8003daa:	681b      	ldr	r3, [r3, #0]
 8003dac:	2b00      	cmp	r3, #0
 8003dae:	da08      	bge.n	8003dc2 <HAL_RCCEx_PeriphCLKConfig+0xea2>
  {
    /* Check the parameters */
    assert_param(IS_RCC_CLKPSOURCE(PeriphClkInit->CkperClockSelection));

    /* Configure the CKPER clock source */
    __HAL_RCC_CLKP_CONFIG(PeriphClkInit->CkperClockSelection);
 8003db0:	4b11      	ldr	r3, [pc, #68]	; (8003df8 <HAL_RCCEx_PeriphCLKConfig+0xed8>)
 8003db2:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 8003db4:	f023 5240 	bic.w	r2, r3, #805306368	; 0x30000000
 8003db8:	687b      	ldr	r3, [r7, #4]
 8003dba:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 8003dbc:	490e      	ldr	r1, [pc, #56]	; (8003df8 <HAL_RCCEx_PeriphCLKConfig+0xed8>)
 8003dbe:	4313      	orrs	r3, r2
 8003dc0:	64cb      	str	r3, [r1, #76]	; 0x4c
  }

  /*------------------------------ CEC Configuration ------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_CEC) == RCC_PERIPHCLK_CEC)
 8003dc2:	687b      	ldr	r3, [r7, #4]
 8003dc4:	681b      	ldr	r3, [r3, #0]
 8003dc6:	f403 0300 	and.w	r3, r3, #8388608	; 0x800000
 8003dca:	2b00      	cmp	r3, #0
 8003dcc:	d009      	beq.n	8003de2 <HAL_RCCEx_PeriphCLKConfig+0xec2>
  {
    /* Check the parameters */
    assert_param(IS_RCC_CECCLKSOURCE(PeriphClkInit->CecClockSelection));

    /* Configure the CEC interface clock source */
    __HAL_RCC_CEC_CONFIG(PeriphClkInit->CecClockSelection);
 8003dce:	4b0a      	ldr	r3, [pc, #40]	; (8003df8 <HAL_RCCEx_PeriphCLKConfig+0xed8>)
 8003dd0:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 8003dd2:	f423 0240 	bic.w	r2, r3, #12582912	; 0xc00000
 8003dd6:	687b      	ldr	r3, [r7, #4]
 8003dd8:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
 8003ddc:	4906      	ldr	r1, [pc, #24]	; (8003df8 <HAL_RCCEx_PeriphCLKConfig+0xed8>)
 8003dde:	4313      	orrs	r3, r2
 8003de0:	654b      	str	r3, [r1, #84]	; 0x54
  }

  if (status == HAL_OK)
 8003de2:	7dbb      	ldrb	r3, [r7, #22]
 8003de4:	2b00      	cmp	r3, #0
 8003de6:	d101      	bne.n	8003dec <HAL_RCCEx_PeriphCLKConfig+0xecc>
  {
    return HAL_OK;
 8003de8:	2300      	movs	r3, #0
 8003dea:	e000      	b.n	8003dee <HAL_RCCEx_PeriphCLKConfig+0xece>
  }
  return HAL_ERROR;
 8003dec:	2301      	movs	r3, #1
}
 8003dee:	4618      	mov	r0, r3
 8003df0:	3718      	adds	r7, #24
 8003df2:	46bd      	mov	sp, r7
 8003df4:	bd80      	pop	{r7, pc}
 8003df6:	bf00      	nop
 8003df8:	58024400 	.word	0x58024400

08003dfc <HAL_RCCEx_GetD3PCLK1Freq>:
  * @note   Each time D3PCLK1 changes, this function must be called to update the
  *         right D3PCLK1 value. Otherwise, any configuration based on this function will be incorrect.
  * @retval D3PCLK1 frequency
  */
uint32_t HAL_RCCEx_GetD3PCLK1Freq(void)
{
 8003dfc:	b580      	push	{r7, lr}
 8003dfe:	af00      	add	r7, sp, #0
#if defined(RCC_D3CFGR_D3PPRE)
  /* Get HCLK source and Compute D3PCLK1 frequency ---------------------------*/
  return (HAL_RCC_GetHCLKFreq() >> (D1CorePrescTable[(RCC->D3CFGR & RCC_D3CFGR_D3PPRE)>> RCC_D3CFGR_D3PPRE_Pos] & 0x1FU));
 8003e00:	f7fe fff0 	bl	8002de4 <HAL_RCC_GetHCLKFreq>
 8003e04:	4602      	mov	r2, r0
 8003e06:	4b06      	ldr	r3, [pc, #24]	; (8003e20 <HAL_RCCEx_GetD3PCLK1Freq+0x24>)
 8003e08:	6a1b      	ldr	r3, [r3, #32]
 8003e0a:	091b      	lsrs	r3, r3, #4
 8003e0c:	f003 0307 	and.w	r3, r3, #7
 8003e10:	4904      	ldr	r1, [pc, #16]	; (8003e24 <HAL_RCCEx_GetD3PCLK1Freq+0x28>)
 8003e12:	5ccb      	ldrb	r3, [r1, r3]
 8003e14:	f003 031f 	and.w	r3, r3, #31
 8003e18:	fa22 f303 	lsr.w	r3, r2, r3
#else
  /* Get HCLK source and Compute D3PCLK1 frequency ---------------------------*/
  return (HAL_RCC_GetHCLKFreq() >> (D1CorePrescTable[(RCC->SRDCFGR & RCC_SRDCFGR_SRDPPRE)>> RCC_SRDCFGR_SRDPPRE_Pos] & 0x1FU));
#endif
}
 8003e1c:	4618      	mov	r0, r3
 8003e1e:	bd80      	pop	{r7, pc}
 8003e20:	58024400 	.word	0x58024400
 8003e24:	0802621c 	.word	0x0802621c

08003e28 <HAL_RCCEx_GetPLL2ClockFreq>:
  *         right PLL2CLK value. Otherwise, any configuration based on this function will be incorrect.
  * @param  PLL2_Clocks structure.
  * @retval None
  */
void HAL_RCCEx_GetPLL2ClockFreq(PLL2_ClocksTypeDef* PLL2_Clocks)
{
 8003e28:	b480      	push	{r7}
 8003e2a:	b089      	sub	sp, #36	; 0x24
 8003e2c:	af00      	add	r7, sp, #0
 8003e2e:	6078      	str	r0, [r7, #4]
  float_t fracn2, pll2vco;

  /* PLL_VCO = (HSE_VALUE or HSI_VALUE or CSI_VALUE/ PLL2M) * PLL2N
     PLL2xCLK = PLL2_VCO / PLL2x
  */
  pllsource = (RCC->PLLCKSELR & RCC_PLLCKSELR_PLLSRC);
 8003e30:	4ba1      	ldr	r3, [pc, #644]	; (80040b8 <HAL_RCCEx_GetPLL2ClockFreq+0x290>)
 8003e32:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8003e34:	f003 0303 	and.w	r3, r3, #3
 8003e38:	61bb      	str	r3, [r7, #24]
  pll2m = ((RCC->PLLCKSELR & RCC_PLLCKSELR_DIVM2)>> 12);
 8003e3a:	4b9f      	ldr	r3, [pc, #636]	; (80040b8 <HAL_RCCEx_GetPLL2ClockFreq+0x290>)
 8003e3c:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8003e3e:	0b1b      	lsrs	r3, r3, #12
 8003e40:	f003 033f 	and.w	r3, r3, #63	; 0x3f
 8003e44:	617b      	str	r3, [r7, #20]
  pll2fracen = (RCC->PLLCFGR & RCC_PLLCFGR_PLL2FRACEN) >> RCC_PLLCFGR_PLL2FRACEN_Pos;
 8003e46:	4b9c      	ldr	r3, [pc, #624]	; (80040b8 <HAL_RCCEx_GetPLL2ClockFreq+0x290>)
 8003e48:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8003e4a:	091b      	lsrs	r3, r3, #4
 8003e4c:	f003 0301 	and.w	r3, r3, #1
 8003e50:	613b      	str	r3, [r7, #16]
  fracn2 =(float_t)(uint32_t)(pll2fracen* ((RCC->PLL2FRACR & RCC_PLL2FRACR_FRACN2)>> 3));
 8003e52:	4b99      	ldr	r3, [pc, #612]	; (80040b8 <HAL_RCCEx_GetPLL2ClockFreq+0x290>)
 8003e54:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 8003e56:	08db      	lsrs	r3, r3, #3
 8003e58:	f3c3 030c 	ubfx	r3, r3, #0, #13
 8003e5c:	693a      	ldr	r2, [r7, #16]
 8003e5e:	fb02 f303 	mul.w	r3, r2, r3
 8003e62:	ee07 3a90 	vmov	s15, r3
 8003e66:	eef8 7a67 	vcvt.f32.u32	s15, s15
 8003e6a:	edc7 7a03 	vstr	s15, [r7, #12]

  if (pll2m != 0U)
 8003e6e:	697b      	ldr	r3, [r7, #20]
 8003e70:	2b00      	cmp	r3, #0
 8003e72:	f000 8111 	beq.w	8004098 <HAL_RCCEx_GetPLL2ClockFreq+0x270>
  {
    switch (pllsource)
 8003e76:	69bb      	ldr	r3, [r7, #24]
 8003e78:	2b02      	cmp	r3, #2
 8003e7a:	f000 8083 	beq.w	8003f84 <HAL_RCCEx_GetPLL2ClockFreq+0x15c>
 8003e7e:	69bb      	ldr	r3, [r7, #24]
 8003e80:	2b02      	cmp	r3, #2
 8003e82:	f200 80a1 	bhi.w	8003fc8 <HAL_RCCEx_GetPLL2ClockFreq+0x1a0>
 8003e86:	69bb      	ldr	r3, [r7, #24]
 8003e88:	2b00      	cmp	r3, #0
 8003e8a:	d003      	beq.n	8003e94 <HAL_RCCEx_GetPLL2ClockFreq+0x6c>
 8003e8c:	69bb      	ldr	r3, [r7, #24]
 8003e8e:	2b01      	cmp	r3, #1
 8003e90:	d056      	beq.n	8003f40 <HAL_RCCEx_GetPLL2ClockFreq+0x118>
 8003e92:	e099      	b.n	8003fc8 <HAL_RCCEx_GetPLL2ClockFreq+0x1a0>
    {

    case RCC_PLLSOURCE_HSI:  /* HSI used as PLL clock source */

      if (__HAL_RCC_GET_FLAG(RCC_FLAG_HSIDIV) != 0U)
 8003e94:	4b88      	ldr	r3, [pc, #544]	; (80040b8 <HAL_RCCEx_GetPLL2ClockFreq+0x290>)
 8003e96:	681b      	ldr	r3, [r3, #0]
 8003e98:	f003 0320 	and.w	r3, r3, #32
 8003e9c:	2b00      	cmp	r3, #0
 8003e9e:	d02d      	beq.n	8003efc <HAL_RCCEx_GetPLL2ClockFreq+0xd4>
      {
        hsivalue = (HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER()>> 3));
 8003ea0:	4b85      	ldr	r3, [pc, #532]	; (80040b8 <HAL_RCCEx_GetPLL2ClockFreq+0x290>)
 8003ea2:	681b      	ldr	r3, [r3, #0]
 8003ea4:	08db      	lsrs	r3, r3, #3
 8003ea6:	f003 0303 	and.w	r3, r3, #3
 8003eaa:	4a84      	ldr	r2, [pc, #528]	; (80040bc <HAL_RCCEx_GetPLL2ClockFreq+0x294>)
 8003eac:	fa22 f303 	lsr.w	r3, r2, r3
 8003eb0:	60bb      	str	r3, [r7, #8]
        pll2vco = ( (float_t)hsivalue / (float_t)pll2m) * ((float_t)(uint32_t)(RCC->PLL2DIVR & RCC_PLL2DIVR_N2) + (fracn2/(float_t)0x2000) +(float_t)1 );
 8003eb2:	68bb      	ldr	r3, [r7, #8]
 8003eb4:	ee07 3a90 	vmov	s15, r3
 8003eb8:	eef8 6a67 	vcvt.f32.u32	s13, s15
 8003ebc:	697b      	ldr	r3, [r7, #20]
 8003ebe:	ee07 3a90 	vmov	s15, r3
 8003ec2:	eef8 7a67 	vcvt.f32.u32	s15, s15
 8003ec6:	ee86 7aa7 	vdiv.f32	s14, s13, s15
 8003eca:	4b7b      	ldr	r3, [pc, #492]	; (80040b8 <HAL_RCCEx_GetPLL2ClockFreq+0x290>)
 8003ecc:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 8003ece:	f3c3 0308 	ubfx	r3, r3, #0, #9
 8003ed2:	ee07 3a90 	vmov	s15, r3
 8003ed6:	eef8 6a67 	vcvt.f32.u32	s13, s15
 8003eda:	ed97 6a03 	vldr	s12, [r7, #12]
 8003ede:	eddf 5a78 	vldr	s11, [pc, #480]	; 80040c0 <HAL_RCCEx_GetPLL2ClockFreq+0x298>
 8003ee2:	eec6 7a25 	vdiv.f32	s15, s12, s11
 8003ee6:	ee76 7aa7 	vadd.f32	s15, s13, s15
 8003eea:	eef7 6a00 	vmov.f32	s13, #112	; 0x3f800000  1.0
 8003eee:	ee77 7aa6 	vadd.f32	s15, s15, s13
 8003ef2:	ee67 7a27 	vmul.f32	s15, s14, s15
 8003ef6:	edc7 7a07 	vstr	s15, [r7, #28]
      }
      else
      {
        pll2vco = ((float_t)HSI_VALUE / (float_t)pll2m) * ((float_t)(uint32_t)(RCC->PLL2DIVR & RCC_PLL2DIVR_N2) + (fracn2/(float_t)0x2000) +(float_t)1 );
      }
      break;
 8003efa:	e087      	b.n	800400c <HAL_RCCEx_GetPLL2ClockFreq+0x1e4>
        pll2vco = ((float_t)HSI_VALUE / (float_t)pll2m) * ((float_t)(uint32_t)(RCC->PLL2DIVR & RCC_PLL2DIVR_N2) + (fracn2/(float_t)0x2000) +(float_t)1 );
 8003efc:	697b      	ldr	r3, [r7, #20]
 8003efe:	ee07 3a90 	vmov	s15, r3
 8003f02:	eef8 7a67 	vcvt.f32.u32	s15, s15
 8003f06:	eddf 6a6f 	vldr	s13, [pc, #444]	; 80040c4 <HAL_RCCEx_GetPLL2ClockFreq+0x29c>
 8003f0a:	ee86 7aa7 	vdiv.f32	s14, s13, s15
 8003f0e:	4b6a      	ldr	r3, [pc, #424]	; (80040b8 <HAL_RCCEx_GetPLL2ClockFreq+0x290>)
 8003f10:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 8003f12:	f3c3 0308 	ubfx	r3, r3, #0, #9
 8003f16:	ee07 3a90 	vmov	s15, r3
 8003f1a:	eef8 6a67 	vcvt.f32.u32	s13, s15
 8003f1e:	ed97 6a03 	vldr	s12, [r7, #12]
 8003f22:	eddf 5a67 	vldr	s11, [pc, #412]	; 80040c0 <HAL_RCCEx_GetPLL2ClockFreq+0x298>
 8003f26:	eec6 7a25 	vdiv.f32	s15, s12, s11
 8003f2a:	ee76 7aa7 	vadd.f32	s15, s13, s15
 8003f2e:	eef7 6a00 	vmov.f32	s13, #112	; 0x3f800000  1.0
 8003f32:	ee77 7aa6 	vadd.f32	s15, s15, s13
 8003f36:	ee67 7a27 	vmul.f32	s15, s14, s15
 8003f3a:	edc7 7a07 	vstr	s15, [r7, #28]
      break;
 8003f3e:	e065      	b.n	800400c <HAL_RCCEx_GetPLL2ClockFreq+0x1e4>

    case RCC_PLLSOURCE_CSI:  /* CSI used as PLL clock source */
      pll2vco = ((float_t)CSI_VALUE / (float_t)pll2m) * ((float_t)(uint32_t)(RCC->PLL2DIVR & RCC_PLL2DIVR_N2) + (fracn2/(float_t)0x2000) +(float_t)1 );
 8003f40:	697b      	ldr	r3, [r7, #20]
 8003f42:	ee07 3a90 	vmov	s15, r3
 8003f46:	eef8 7a67 	vcvt.f32.u32	s15, s15
 8003f4a:	eddf 6a5f 	vldr	s13, [pc, #380]	; 80040c8 <HAL_RCCEx_GetPLL2ClockFreq+0x2a0>
 8003f4e:	ee86 7aa7 	vdiv.f32	s14, s13, s15
 8003f52:	4b59      	ldr	r3, [pc, #356]	; (80040b8 <HAL_RCCEx_GetPLL2ClockFreq+0x290>)
 8003f54:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 8003f56:	f3c3 0308 	ubfx	r3, r3, #0, #9
 8003f5a:	ee07 3a90 	vmov	s15, r3
 8003f5e:	eef8 6a67 	vcvt.f32.u32	s13, s15
 8003f62:	ed97 6a03 	vldr	s12, [r7, #12]
 8003f66:	eddf 5a56 	vldr	s11, [pc, #344]	; 80040c0 <HAL_RCCEx_GetPLL2ClockFreq+0x298>
 8003f6a:	eec6 7a25 	vdiv.f32	s15, s12, s11
 8003f6e:	ee76 7aa7 	vadd.f32	s15, s13, s15
 8003f72:	eef7 6a00 	vmov.f32	s13, #112	; 0x3f800000  1.0
 8003f76:	ee77 7aa6 	vadd.f32	s15, s15, s13
 8003f7a:	ee67 7a27 	vmul.f32	s15, s14, s15
 8003f7e:	edc7 7a07 	vstr	s15, [r7, #28]
      break;
 8003f82:	e043      	b.n	800400c <HAL_RCCEx_GetPLL2ClockFreq+0x1e4>

    case RCC_PLLSOURCE_HSE:  /* HSE used as PLL clock source */
      pll2vco = ((float_t)HSE_VALUE / (float_t)pll2m) * ((float_t)(uint32_t)(RCC->PLL2DIVR & RCC_PLL2DIVR_N2) + (fracn2/(float_t)0x2000) +(float_t)1 );
 8003f84:	697b      	ldr	r3, [r7, #20]
 8003f86:	ee07 3a90 	vmov	s15, r3
 8003f8a:	eef8 7a67 	vcvt.f32.u32	s15, s15
 8003f8e:	eddf 6a4f 	vldr	s13, [pc, #316]	; 80040cc <HAL_RCCEx_GetPLL2ClockFreq+0x2a4>
 8003f92:	ee86 7aa7 	vdiv.f32	s14, s13, s15
 8003f96:	4b48      	ldr	r3, [pc, #288]	; (80040b8 <HAL_RCCEx_GetPLL2ClockFreq+0x290>)
 8003f98:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 8003f9a:	f3c3 0308 	ubfx	r3, r3, #0, #9
 8003f9e:	ee07 3a90 	vmov	s15, r3
 8003fa2:	eef8 6a67 	vcvt.f32.u32	s13, s15
 8003fa6:	ed97 6a03 	vldr	s12, [r7, #12]
 8003faa:	eddf 5a45 	vldr	s11, [pc, #276]	; 80040c0 <HAL_RCCEx_GetPLL2ClockFreq+0x298>
 8003fae:	eec6 7a25 	vdiv.f32	s15, s12, s11
 8003fb2:	ee76 7aa7 	vadd.f32	s15, s13, s15
 8003fb6:	eef7 6a00 	vmov.f32	s13, #112	; 0x3f800000  1.0
 8003fba:	ee77 7aa6 	vadd.f32	s15, s15, s13
 8003fbe:	ee67 7a27 	vmul.f32	s15, s14, s15
 8003fc2:	edc7 7a07 	vstr	s15, [r7, #28]
      break;
 8003fc6:	e021      	b.n	800400c <HAL_RCCEx_GetPLL2ClockFreq+0x1e4>

    default:
      pll2vco = ((float_t)CSI_VALUE / (float_t)pll2m) * ((float_t)(uint32_t)(RCC->PLL2DIVR & RCC_PLL2DIVR_N2) + (fracn2/(float_t)0x2000) +(float_t)1 );
 8003fc8:	697b      	ldr	r3, [r7, #20]
 8003fca:	ee07 3a90 	vmov	s15, r3
 8003fce:	eef8 7a67 	vcvt.f32.u32	s15, s15
 8003fd2:	eddf 6a3d 	vldr	s13, [pc, #244]	; 80040c8 <HAL_RCCEx_GetPLL2ClockFreq+0x2a0>
 8003fd6:	ee86 7aa7 	vdiv.f32	s14, s13, s15
 8003fda:	4b37      	ldr	r3, [pc, #220]	; (80040b8 <HAL_RCCEx_GetPLL2ClockFreq+0x290>)
 8003fdc:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 8003fde:	f3c3 0308 	ubfx	r3, r3, #0, #9
 8003fe2:	ee07 3a90 	vmov	s15, r3
 8003fe6:	eef8 6a67 	vcvt.f32.u32	s13, s15
 8003fea:	ed97 6a03 	vldr	s12, [r7, #12]
 8003fee:	eddf 5a34 	vldr	s11, [pc, #208]	; 80040c0 <HAL_RCCEx_GetPLL2ClockFreq+0x298>
 8003ff2:	eec6 7a25 	vdiv.f32	s15, s12, s11
 8003ff6:	ee76 7aa7 	vadd.f32	s15, s13, s15
 8003ffa:	eef7 6a00 	vmov.f32	s13, #112	; 0x3f800000  1.0
 8003ffe:	ee77 7aa6 	vadd.f32	s15, s15, s13
 8004002:	ee67 7a27 	vmul.f32	s15, s14, s15
 8004006:	edc7 7a07 	vstr	s15, [r7, #28]
      break;
 800400a:	bf00      	nop
    }
    PLL2_Clocks->PLL2_P_Frequency = (uint32_t)(float_t)(pll2vco/((float_t)(uint32_t)((RCC->PLL2DIVR & RCC_PLL2DIVR_P2) >>9)  + (float_t)1 )) ;
 800400c:	4b2a      	ldr	r3, [pc, #168]	; (80040b8 <HAL_RCCEx_GetPLL2ClockFreq+0x290>)
 800400e:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 8004010:	0a5b      	lsrs	r3, r3, #9
 8004012:	f003 037f 	and.w	r3, r3, #127	; 0x7f
 8004016:	ee07 3a90 	vmov	s15, r3
 800401a:	eef8 7a67 	vcvt.f32.u32	s15, s15
 800401e:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
 8004022:	ee37 7a87 	vadd.f32	s14, s15, s14
 8004026:	edd7 6a07 	vldr	s13, [r7, #28]
 800402a:	eec6 7a87 	vdiv.f32	s15, s13, s14
 800402e:	eefc 7ae7 	vcvt.u32.f32	s15, s15
 8004032:	ee17 2a90 	vmov	r2, s15
 8004036:	687b      	ldr	r3, [r7, #4]
 8004038:	601a      	str	r2, [r3, #0]
    PLL2_Clocks->PLL2_Q_Frequency = (uint32_t)(float_t)(pll2vco/((float_t)(uint32_t)((RCC->PLL2DIVR & RCC_PLL2DIVR_Q2) >>16) + (float_t)1 )) ;
 800403a:	4b1f      	ldr	r3, [pc, #124]	; (80040b8 <HAL_RCCEx_GetPLL2ClockFreq+0x290>)
 800403c:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 800403e:	0c1b      	lsrs	r3, r3, #16
 8004040:	f003 037f 	and.w	r3, r3, #127	; 0x7f
 8004044:	ee07 3a90 	vmov	s15, r3
 8004048:	eef8 7a67 	vcvt.f32.u32	s15, s15
 800404c:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
 8004050:	ee37 7a87 	vadd.f32	s14, s15, s14
 8004054:	edd7 6a07 	vldr	s13, [r7, #28]
 8004058:	eec6 7a87 	vdiv.f32	s15, s13, s14
 800405c:	eefc 7ae7 	vcvt.u32.f32	s15, s15
 8004060:	ee17 2a90 	vmov	r2, s15
 8004064:	687b      	ldr	r3, [r7, #4]
 8004066:	605a      	str	r2, [r3, #4]
    PLL2_Clocks->PLL2_R_Frequency = (uint32_t)(float_t)(pll2vco/((float_t)(uint32_t)((RCC->PLL2DIVR & RCC_PLL2DIVR_R2) >>24) + (float_t)1 )) ;
 8004068:	4b13      	ldr	r3, [pc, #76]	; (80040b8 <HAL_RCCEx_GetPLL2ClockFreq+0x290>)
 800406a:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 800406c:	0e1b      	lsrs	r3, r3, #24
 800406e:	f003 037f 	and.w	r3, r3, #127	; 0x7f
 8004072:	ee07 3a90 	vmov	s15, r3
 8004076:	eef8 7a67 	vcvt.f32.u32	s15, s15
 800407a:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
 800407e:	ee37 7a87 	vadd.f32	s14, s15, s14
 8004082:	edd7 6a07 	vldr	s13, [r7, #28]
 8004086:	eec6 7a87 	vdiv.f32	s15, s13, s14
 800408a:	eefc 7ae7 	vcvt.u32.f32	s15, s15
 800408e:	ee17 2a90 	vmov	r2, s15
 8004092:	687b      	ldr	r3, [r7, #4]
 8004094:	609a      	str	r2, [r3, #8]
  {
    PLL2_Clocks->PLL2_P_Frequency = 0U;
    PLL2_Clocks->PLL2_Q_Frequency = 0U;
    PLL2_Clocks->PLL2_R_Frequency = 0U;
  }
}
 8004096:	e008      	b.n	80040aa <HAL_RCCEx_GetPLL2ClockFreq+0x282>
    PLL2_Clocks->PLL2_P_Frequency = 0U;
 8004098:	687b      	ldr	r3, [r7, #4]
 800409a:	2200      	movs	r2, #0
 800409c:	601a      	str	r2, [r3, #0]
    PLL2_Clocks->PLL2_Q_Frequency = 0U;
 800409e:	687b      	ldr	r3, [r7, #4]
 80040a0:	2200      	movs	r2, #0
 80040a2:	605a      	str	r2, [r3, #4]
    PLL2_Clocks->PLL2_R_Frequency = 0U;
 80040a4:	687b      	ldr	r3, [r7, #4]
 80040a6:	2200      	movs	r2, #0
 80040a8:	609a      	str	r2, [r3, #8]
}
 80040aa:	bf00      	nop
 80040ac:	3724      	adds	r7, #36	; 0x24
 80040ae:	46bd      	mov	sp, r7
 80040b0:	f85d 7b04 	ldr.w	r7, [sp], #4
 80040b4:	4770      	bx	lr
 80040b6:	bf00      	nop
 80040b8:	58024400 	.word	0x58024400
 80040bc:	03d09000 	.word	0x03d09000
 80040c0:	46000000 	.word	0x46000000
 80040c4:	4c742400 	.word	0x4c742400
 80040c8:	4a742400 	.word	0x4a742400
 80040cc:	4bbebc20 	.word	0x4bbebc20

080040d0 <HAL_RCCEx_GetPLL3ClockFreq>:
  *         right PLL3CLK value. Otherwise, any configuration based on this function will be incorrect.
  * @param  PLL3_Clocks structure.
  * @retval None
  */
void HAL_RCCEx_GetPLL3ClockFreq(PLL3_ClocksTypeDef* PLL3_Clocks)
{
 80040d0:	b480      	push	{r7}
 80040d2:	b089      	sub	sp, #36	; 0x24
 80040d4:	af00      	add	r7, sp, #0
 80040d6:	6078      	str	r0, [r7, #4]
  float_t fracn3, pll3vco;

  /* PLL3_VCO = (HSE_VALUE or HSI_VALUE or CSI_VALUE/ PLL3M) * PLL3N
     PLL3xCLK = PLL3_VCO / PLLxR
  */
  pllsource = (RCC->PLLCKSELR & RCC_PLLCKSELR_PLLSRC);
 80040d8:	4ba1      	ldr	r3, [pc, #644]	; (8004360 <HAL_RCCEx_GetPLL3ClockFreq+0x290>)
 80040da:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 80040dc:	f003 0303 	and.w	r3, r3, #3
 80040e0:	61bb      	str	r3, [r7, #24]
  pll3m = ((RCC->PLLCKSELR & RCC_PLLCKSELR_DIVM3)>> 20)  ;
 80040e2:	4b9f      	ldr	r3, [pc, #636]	; (8004360 <HAL_RCCEx_GetPLL3ClockFreq+0x290>)
 80040e4:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 80040e6:	0d1b      	lsrs	r3, r3, #20
 80040e8:	f003 033f 	and.w	r3, r3, #63	; 0x3f
 80040ec:	617b      	str	r3, [r7, #20]
  pll3fracen = (RCC->PLLCFGR & RCC_PLLCFGR_PLL3FRACEN) >> RCC_PLLCFGR_PLL3FRACEN_Pos;
 80040ee:	4b9c      	ldr	r3, [pc, #624]	; (8004360 <HAL_RCCEx_GetPLL3ClockFreq+0x290>)
 80040f0:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 80040f2:	0a1b      	lsrs	r3, r3, #8
 80040f4:	f003 0301 	and.w	r3, r3, #1
 80040f8:	613b      	str	r3, [r7, #16]
  fracn3 = (float_t)(uint32_t)(pll3fracen* ((RCC->PLL3FRACR & RCC_PLL3FRACR_FRACN3)>> 3));
 80040fa:	4b99      	ldr	r3, [pc, #612]	; (8004360 <HAL_RCCEx_GetPLL3ClockFreq+0x290>)
 80040fc:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 80040fe:	08db      	lsrs	r3, r3, #3
 8004100:	f3c3 030c 	ubfx	r3, r3, #0, #13
 8004104:	693a      	ldr	r2, [r7, #16]
 8004106:	fb02 f303 	mul.w	r3, r2, r3
 800410a:	ee07 3a90 	vmov	s15, r3
 800410e:	eef8 7a67 	vcvt.f32.u32	s15, s15
 8004112:	edc7 7a03 	vstr	s15, [r7, #12]

  if (pll3m != 0U)
 8004116:	697b      	ldr	r3, [r7, #20]
 8004118:	2b00      	cmp	r3, #0
 800411a:	f000 8111 	beq.w	8004340 <HAL_RCCEx_GetPLL3ClockFreq+0x270>
  {
    switch (pllsource)
 800411e:	69bb      	ldr	r3, [r7, #24]
 8004120:	2b02      	cmp	r3, #2
 8004122:	f000 8083 	beq.w	800422c <HAL_RCCEx_GetPLL3ClockFreq+0x15c>
 8004126:	69bb      	ldr	r3, [r7, #24]
 8004128:	2b02      	cmp	r3, #2
 800412a:	f200 80a1 	bhi.w	8004270 <HAL_RCCEx_GetPLL3ClockFreq+0x1a0>
 800412e:	69bb      	ldr	r3, [r7, #24]
 8004130:	2b00      	cmp	r3, #0
 8004132:	d003      	beq.n	800413c <HAL_RCCEx_GetPLL3ClockFreq+0x6c>
 8004134:	69bb      	ldr	r3, [r7, #24]
 8004136:	2b01      	cmp	r3, #1
 8004138:	d056      	beq.n	80041e8 <HAL_RCCEx_GetPLL3ClockFreq+0x118>
 800413a:	e099      	b.n	8004270 <HAL_RCCEx_GetPLL3ClockFreq+0x1a0>
    {
    case RCC_PLLSOURCE_HSI:  /* HSI used as PLL clock source */

      if (__HAL_RCC_GET_FLAG(RCC_FLAG_HSIDIV) != 0U)
 800413c:	4b88      	ldr	r3, [pc, #544]	; (8004360 <HAL_RCCEx_GetPLL3ClockFreq+0x290>)
 800413e:	681b      	ldr	r3, [r3, #0]
 8004140:	f003 0320 	and.w	r3, r3, #32
 8004144:	2b00      	cmp	r3, #0
 8004146:	d02d      	beq.n	80041a4 <HAL_RCCEx_GetPLL3ClockFreq+0xd4>
      {
        hsivalue = (HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER()>> 3));
 8004148:	4b85      	ldr	r3, [pc, #532]	; (8004360 <HAL_RCCEx_GetPLL3ClockFreq+0x290>)
 800414a:	681b      	ldr	r3, [r3, #0]
 800414c:	08db      	lsrs	r3, r3, #3
 800414e:	f003 0303 	and.w	r3, r3, #3
 8004152:	4a84      	ldr	r2, [pc, #528]	; (8004364 <HAL_RCCEx_GetPLL3ClockFreq+0x294>)
 8004154:	fa22 f303 	lsr.w	r3, r2, r3
 8004158:	60bb      	str	r3, [r7, #8]
        pll3vco = ((float_t)hsivalue / (float_t)pll3m) * ((float_t)(uint32_t)(RCC->PLL3DIVR & RCC_PLL3DIVR_N3) + (fracn3/(float_t)0x2000) +(float_t)1 );
 800415a:	68bb      	ldr	r3, [r7, #8]
 800415c:	ee07 3a90 	vmov	s15, r3
 8004160:	eef8 6a67 	vcvt.f32.u32	s13, s15
 8004164:	697b      	ldr	r3, [r7, #20]
 8004166:	ee07 3a90 	vmov	s15, r3
 800416a:	eef8 7a67 	vcvt.f32.u32	s15, s15
 800416e:	ee86 7aa7 	vdiv.f32	s14, s13, s15
 8004172:	4b7b      	ldr	r3, [pc, #492]	; (8004360 <HAL_RCCEx_GetPLL3ClockFreq+0x290>)
 8004174:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8004176:	f3c3 0308 	ubfx	r3, r3, #0, #9
 800417a:	ee07 3a90 	vmov	s15, r3
 800417e:	eef8 6a67 	vcvt.f32.u32	s13, s15
 8004182:	ed97 6a03 	vldr	s12, [r7, #12]
 8004186:	eddf 5a78 	vldr	s11, [pc, #480]	; 8004368 <HAL_RCCEx_GetPLL3ClockFreq+0x298>
 800418a:	eec6 7a25 	vdiv.f32	s15, s12, s11
 800418e:	ee76 7aa7 	vadd.f32	s15, s13, s15
 8004192:	eef7 6a00 	vmov.f32	s13, #112	; 0x3f800000  1.0
 8004196:	ee77 7aa6 	vadd.f32	s15, s15, s13
 800419a:	ee67 7a27 	vmul.f32	s15, s14, s15
 800419e:	edc7 7a07 	vstr	s15, [r7, #28]
      }
      else
      {
        pll3vco = ((float_t)HSI_VALUE / (float_t)pll3m) * ((float_t)(uint32_t)(RCC->PLL3DIVR & RCC_PLL3DIVR_N3) + (fracn3/(float_t)0x2000) +(float_t)1 );
      }
      break;
 80041a2:	e087      	b.n	80042b4 <HAL_RCCEx_GetPLL3ClockFreq+0x1e4>
        pll3vco = ((float_t)HSI_VALUE / (float_t)pll3m) * ((float_t)(uint32_t)(RCC->PLL3DIVR & RCC_PLL3DIVR_N3) + (fracn3/(float_t)0x2000) +(float_t)1 );
 80041a4:	697b      	ldr	r3, [r7, #20]
 80041a6:	ee07 3a90 	vmov	s15, r3
 80041aa:	eef8 7a67 	vcvt.f32.u32	s15, s15
 80041ae:	eddf 6a6f 	vldr	s13, [pc, #444]	; 800436c <HAL_RCCEx_GetPLL3ClockFreq+0x29c>
 80041b2:	ee86 7aa7 	vdiv.f32	s14, s13, s15
 80041b6:	4b6a      	ldr	r3, [pc, #424]	; (8004360 <HAL_RCCEx_GetPLL3ClockFreq+0x290>)
 80041b8:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 80041ba:	f3c3 0308 	ubfx	r3, r3, #0, #9
 80041be:	ee07 3a90 	vmov	s15, r3
 80041c2:	eef8 6a67 	vcvt.f32.u32	s13, s15
 80041c6:	ed97 6a03 	vldr	s12, [r7, #12]
 80041ca:	eddf 5a67 	vldr	s11, [pc, #412]	; 8004368 <HAL_RCCEx_GetPLL3ClockFreq+0x298>
 80041ce:	eec6 7a25 	vdiv.f32	s15, s12, s11
 80041d2:	ee76 7aa7 	vadd.f32	s15, s13, s15
 80041d6:	eef7 6a00 	vmov.f32	s13, #112	; 0x3f800000  1.0
 80041da:	ee77 7aa6 	vadd.f32	s15, s15, s13
 80041de:	ee67 7a27 	vmul.f32	s15, s14, s15
 80041e2:	edc7 7a07 	vstr	s15, [r7, #28]
      break;
 80041e6:	e065      	b.n	80042b4 <HAL_RCCEx_GetPLL3ClockFreq+0x1e4>
    case RCC_PLLSOURCE_CSI:  /* CSI used as PLL clock source */
      pll3vco = ((float_t)CSI_VALUE / (float_t)pll3m) * ((float_t)(uint32_t)(RCC->PLL3DIVR & RCC_PLL3DIVR_N3) + (fracn3/(float_t)0x2000) +(float_t)1 );
 80041e8:	697b      	ldr	r3, [r7, #20]
 80041ea:	ee07 3a90 	vmov	s15, r3
 80041ee:	eef8 7a67 	vcvt.f32.u32	s15, s15
 80041f2:	eddf 6a5f 	vldr	s13, [pc, #380]	; 8004370 <HAL_RCCEx_GetPLL3ClockFreq+0x2a0>
 80041f6:	ee86 7aa7 	vdiv.f32	s14, s13, s15
 80041fa:	4b59      	ldr	r3, [pc, #356]	; (8004360 <HAL_RCCEx_GetPLL3ClockFreq+0x290>)
 80041fc:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 80041fe:	f3c3 0308 	ubfx	r3, r3, #0, #9
 8004202:	ee07 3a90 	vmov	s15, r3
 8004206:	eef8 6a67 	vcvt.f32.u32	s13, s15
 800420a:	ed97 6a03 	vldr	s12, [r7, #12]
 800420e:	eddf 5a56 	vldr	s11, [pc, #344]	; 8004368 <HAL_RCCEx_GetPLL3ClockFreq+0x298>
 8004212:	eec6 7a25 	vdiv.f32	s15, s12, s11
 8004216:	ee76 7aa7 	vadd.f32	s15, s13, s15
 800421a:	eef7 6a00 	vmov.f32	s13, #112	; 0x3f800000  1.0
 800421e:	ee77 7aa6 	vadd.f32	s15, s15, s13
 8004222:	ee67 7a27 	vmul.f32	s15, s14, s15
 8004226:	edc7 7a07 	vstr	s15, [r7, #28]
      break;
 800422a:	e043      	b.n	80042b4 <HAL_RCCEx_GetPLL3ClockFreq+0x1e4>

    case RCC_PLLSOURCE_HSE:  /* HSE used as PLL clock source */
      pll3vco = ((float_t)HSE_VALUE / (float_t)pll3m) * ((float_t)(uint32_t)(RCC->PLL3DIVR & RCC_PLL3DIVR_N3) + (fracn3/(float_t)0x2000) +(float_t)1 );
 800422c:	697b      	ldr	r3, [r7, #20]
 800422e:	ee07 3a90 	vmov	s15, r3
 8004232:	eef8 7a67 	vcvt.f32.u32	s15, s15
 8004236:	eddf 6a4f 	vldr	s13, [pc, #316]	; 8004374 <HAL_RCCEx_GetPLL3ClockFreq+0x2a4>
 800423a:	ee86 7aa7 	vdiv.f32	s14, s13, s15
 800423e:	4b48      	ldr	r3, [pc, #288]	; (8004360 <HAL_RCCEx_GetPLL3ClockFreq+0x290>)
 8004240:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8004242:	f3c3 0308 	ubfx	r3, r3, #0, #9
 8004246:	ee07 3a90 	vmov	s15, r3
 800424a:	eef8 6a67 	vcvt.f32.u32	s13, s15
 800424e:	ed97 6a03 	vldr	s12, [r7, #12]
 8004252:	eddf 5a45 	vldr	s11, [pc, #276]	; 8004368 <HAL_RCCEx_GetPLL3ClockFreq+0x298>
 8004256:	eec6 7a25 	vdiv.f32	s15, s12, s11
 800425a:	ee76 7aa7 	vadd.f32	s15, s13, s15
 800425e:	eef7 6a00 	vmov.f32	s13, #112	; 0x3f800000  1.0
 8004262:	ee77 7aa6 	vadd.f32	s15, s15, s13
 8004266:	ee67 7a27 	vmul.f32	s15, s14, s15
 800426a:	edc7 7a07 	vstr	s15, [r7, #28]
      break;
 800426e:	e021      	b.n	80042b4 <HAL_RCCEx_GetPLL3ClockFreq+0x1e4>

    default:
      pll3vco = ((float_t)CSI_VALUE / (float_t)pll3m) * ((float_t)(uint32_t)(RCC->PLL3DIVR & RCC_PLL3DIVR_N3) + (fracn3/(float_t)0x2000) +(float_t)1 );
 8004270:	697b      	ldr	r3, [r7, #20]
 8004272:	ee07 3a90 	vmov	s15, r3
 8004276:	eef8 7a67 	vcvt.f32.u32	s15, s15
 800427a:	eddf 6a3d 	vldr	s13, [pc, #244]	; 8004370 <HAL_RCCEx_GetPLL3ClockFreq+0x2a0>
 800427e:	ee86 7aa7 	vdiv.f32	s14, s13, s15
 8004282:	4b37      	ldr	r3, [pc, #220]	; (8004360 <HAL_RCCEx_GetPLL3ClockFreq+0x290>)
 8004284:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8004286:	f3c3 0308 	ubfx	r3, r3, #0, #9
 800428a:	ee07 3a90 	vmov	s15, r3
 800428e:	eef8 6a67 	vcvt.f32.u32	s13, s15
 8004292:	ed97 6a03 	vldr	s12, [r7, #12]
 8004296:	eddf 5a34 	vldr	s11, [pc, #208]	; 8004368 <HAL_RCCEx_GetPLL3ClockFreq+0x298>
 800429a:	eec6 7a25 	vdiv.f32	s15, s12, s11
 800429e:	ee76 7aa7 	vadd.f32	s15, s13, s15
 80042a2:	eef7 6a00 	vmov.f32	s13, #112	; 0x3f800000  1.0
 80042a6:	ee77 7aa6 	vadd.f32	s15, s15, s13
 80042aa:	ee67 7a27 	vmul.f32	s15, s14, s15
 80042ae:	edc7 7a07 	vstr	s15, [r7, #28]
      break;
 80042b2:	bf00      	nop
    }
    PLL3_Clocks->PLL3_P_Frequency = (uint32_t)(float_t)(pll3vco/((float_t)(uint32_t)((RCC->PLL3DIVR & RCC_PLL3DIVR_P3) >>9)  + (float_t)1 )) ;
 80042b4:	4b2a      	ldr	r3, [pc, #168]	; (8004360 <HAL_RCCEx_GetPLL3ClockFreq+0x290>)
 80042b6:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 80042b8:	0a5b      	lsrs	r3, r3, #9
 80042ba:	f003 037f 	and.w	r3, r3, #127	; 0x7f
 80042be:	ee07 3a90 	vmov	s15, r3
 80042c2:	eef8 7a67 	vcvt.f32.u32	s15, s15
 80042c6:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
 80042ca:	ee37 7a87 	vadd.f32	s14, s15, s14
 80042ce:	edd7 6a07 	vldr	s13, [r7, #28]
 80042d2:	eec6 7a87 	vdiv.f32	s15, s13, s14
 80042d6:	eefc 7ae7 	vcvt.u32.f32	s15, s15
 80042da:	ee17 2a90 	vmov	r2, s15
 80042de:	687b      	ldr	r3, [r7, #4]
 80042e0:	601a      	str	r2, [r3, #0]
    PLL3_Clocks->PLL3_Q_Frequency = (uint32_t)(float_t)(pll3vco/((float_t)(uint32_t)((RCC->PLL3DIVR & RCC_PLL3DIVR_Q3) >>16) + (float_t)1 )) ;
 80042e2:	4b1f      	ldr	r3, [pc, #124]	; (8004360 <HAL_RCCEx_GetPLL3ClockFreq+0x290>)
 80042e4:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 80042e6:	0c1b      	lsrs	r3, r3, #16
 80042e8:	f003 037f 	and.w	r3, r3, #127	; 0x7f
 80042ec:	ee07 3a90 	vmov	s15, r3
 80042f0:	eef8 7a67 	vcvt.f32.u32	s15, s15
 80042f4:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
 80042f8:	ee37 7a87 	vadd.f32	s14, s15, s14
 80042fc:	edd7 6a07 	vldr	s13, [r7, #28]
 8004300:	eec6 7a87 	vdiv.f32	s15, s13, s14
 8004304:	eefc 7ae7 	vcvt.u32.f32	s15, s15
 8004308:	ee17 2a90 	vmov	r2, s15
 800430c:	687b      	ldr	r3, [r7, #4]
 800430e:	605a      	str	r2, [r3, #4]
    PLL3_Clocks->PLL3_R_Frequency = (uint32_t)(float_t)(pll3vco/((float_t)(uint32_t)((RCC->PLL3DIVR & RCC_PLL3DIVR_R3) >>24) + (float_t)1 )) ;
 8004310:	4b13      	ldr	r3, [pc, #76]	; (8004360 <HAL_RCCEx_GetPLL3ClockFreq+0x290>)
 8004312:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8004314:	0e1b      	lsrs	r3, r3, #24
 8004316:	f003 037f 	and.w	r3, r3, #127	; 0x7f
 800431a:	ee07 3a90 	vmov	s15, r3
 800431e:	eef8 7a67 	vcvt.f32.u32	s15, s15
 8004322:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
 8004326:	ee37 7a87 	vadd.f32	s14, s15, s14
 800432a:	edd7 6a07 	vldr	s13, [r7, #28]
 800432e:	eec6 7a87 	vdiv.f32	s15, s13, s14
 8004332:	eefc 7ae7 	vcvt.u32.f32	s15, s15
 8004336:	ee17 2a90 	vmov	r2, s15
 800433a:	687b      	ldr	r3, [r7, #4]
 800433c:	609a      	str	r2, [r3, #8]
    PLL3_Clocks->PLL3_P_Frequency = 0U;
    PLL3_Clocks->PLL3_Q_Frequency = 0U;
    PLL3_Clocks->PLL3_R_Frequency = 0U;
  }

}
 800433e:	e008      	b.n	8004352 <HAL_RCCEx_GetPLL3ClockFreq+0x282>
    PLL3_Clocks->PLL3_P_Frequency = 0U;
 8004340:	687b      	ldr	r3, [r7, #4]
 8004342:	2200      	movs	r2, #0
 8004344:	601a      	str	r2, [r3, #0]
    PLL3_Clocks->PLL3_Q_Frequency = 0U;
 8004346:	687b      	ldr	r3, [r7, #4]
 8004348:	2200      	movs	r2, #0
 800434a:	605a      	str	r2, [r3, #4]
    PLL3_Clocks->PLL3_R_Frequency = 0U;
 800434c:	687b      	ldr	r3, [r7, #4]
 800434e:	2200      	movs	r2, #0
 8004350:	609a      	str	r2, [r3, #8]
}
 8004352:	bf00      	nop
 8004354:	3724      	adds	r7, #36	; 0x24
 8004356:	46bd      	mov	sp, r7
 8004358:	f85d 7b04 	ldr.w	r7, [sp], #4
 800435c:	4770      	bx	lr
 800435e:	bf00      	nop
 8004360:	58024400 	.word	0x58024400
 8004364:	03d09000 	.word	0x03d09000
 8004368:	46000000 	.word	0x46000000
 800436c:	4c742400 	.word	0x4c742400
 8004370:	4a742400 	.word	0x4a742400
 8004374:	4bbebc20 	.word	0x4bbebc20

08004378 <RCCEx_PLL2_Config>:
  * @note   PLL2 is temporary disabled to apply new parameters
  *
  * @retval HAL status
  */
static HAL_StatusTypeDef RCCEx_PLL2_Config(RCC_PLL2InitTypeDef *pll2, uint32_t Divider)
{
 8004378:	b580      	push	{r7, lr}
 800437a:	b084      	sub	sp, #16
 800437c:	af00      	add	r7, sp, #0
 800437e:	6078      	str	r0, [r7, #4]
 8004380:	6039      	str	r1, [r7, #0]

  uint32_t tickstart;
  HAL_StatusTypeDef status = HAL_OK;
 8004382:	2300      	movs	r3, #0
 8004384:	73fb      	strb	r3, [r7, #15]
  assert_param(IS_RCC_PLL2RGE_VALUE(pll2->PLL2RGE));
  assert_param(IS_RCC_PLL2VCO_VALUE(pll2->PLL2VCOSEL));
  assert_param(IS_RCC_PLLFRACN_VALUE(pll2->PLL2FRACN));

  /* Check that PLL2 OSC clock source is already set */
  if(__HAL_RCC_GET_PLL_OSCSOURCE() == RCC_PLLSOURCE_NONE)
 8004386:	4b53      	ldr	r3, [pc, #332]	; (80044d4 <RCCEx_PLL2_Config+0x15c>)
 8004388:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 800438a:	f003 0303 	and.w	r3, r3, #3
 800438e:	2b03      	cmp	r3, #3
 8004390:	d101      	bne.n	8004396 <RCCEx_PLL2_Config+0x1e>
  {
    return HAL_ERROR;
 8004392:	2301      	movs	r3, #1
 8004394:	e099      	b.n	80044ca <RCCEx_PLL2_Config+0x152>


  else
  {
    /* Disable  PLL2. */
    __HAL_RCC_PLL2_DISABLE();
 8004396:	4b4f      	ldr	r3, [pc, #316]	; (80044d4 <RCCEx_PLL2_Config+0x15c>)
 8004398:	681b      	ldr	r3, [r3, #0]
 800439a:	4a4e      	ldr	r2, [pc, #312]	; (80044d4 <RCCEx_PLL2_Config+0x15c>)
 800439c:	f023 6380 	bic.w	r3, r3, #67108864	; 0x4000000
 80043a0:	6013      	str	r3, [r2, #0]

    /* Get Start Tick*/
    tickstart = HAL_GetTick();
 80043a2:	f7fd f9c9 	bl	8001738 <HAL_GetTick>
 80043a6:	60b8      	str	r0, [r7, #8]

    /* Wait till PLL is disabled */
    while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLL2RDY) != 0U)
 80043a8:	e008      	b.n	80043bc <RCCEx_PLL2_Config+0x44>
    {
      if( (HAL_GetTick() - tickstart ) > PLL2_TIMEOUT_VALUE)
 80043aa:	f7fd f9c5 	bl	8001738 <HAL_GetTick>
 80043ae:	4602      	mov	r2, r0
 80043b0:	68bb      	ldr	r3, [r7, #8]
 80043b2:	1ad3      	subs	r3, r2, r3
 80043b4:	2b02      	cmp	r3, #2
 80043b6:	d901      	bls.n	80043bc <RCCEx_PLL2_Config+0x44>
      {
        return HAL_TIMEOUT;
 80043b8:	2303      	movs	r3, #3
 80043ba:	e086      	b.n	80044ca <RCCEx_PLL2_Config+0x152>
    while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLL2RDY) != 0U)
 80043bc:	4b45      	ldr	r3, [pc, #276]	; (80044d4 <RCCEx_PLL2_Config+0x15c>)
 80043be:	681b      	ldr	r3, [r3, #0]
 80043c0:	f003 6300 	and.w	r3, r3, #134217728	; 0x8000000
 80043c4:	2b00      	cmp	r3, #0
 80043c6:	d1f0      	bne.n	80043aa <RCCEx_PLL2_Config+0x32>
      }
    }

    /* Configure PLL2 multiplication and division factors. */
    __HAL_RCC_PLL2_CONFIG(pll2->PLL2M,
 80043c8:	4b42      	ldr	r3, [pc, #264]	; (80044d4 <RCCEx_PLL2_Config+0x15c>)
 80043ca:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 80043cc:	f423 327c 	bic.w	r2, r3, #258048	; 0x3f000
 80043d0:	687b      	ldr	r3, [r7, #4]
 80043d2:	681b      	ldr	r3, [r3, #0]
 80043d4:	031b      	lsls	r3, r3, #12
 80043d6:	493f      	ldr	r1, [pc, #252]	; (80044d4 <RCCEx_PLL2_Config+0x15c>)
 80043d8:	4313      	orrs	r3, r2
 80043da:	628b      	str	r3, [r1, #40]	; 0x28
 80043dc:	687b      	ldr	r3, [r7, #4]
 80043de:	685b      	ldr	r3, [r3, #4]
 80043e0:	3b01      	subs	r3, #1
 80043e2:	f3c3 0208 	ubfx	r2, r3, #0, #9
 80043e6:	687b      	ldr	r3, [r7, #4]
 80043e8:	689b      	ldr	r3, [r3, #8]
 80043ea:	3b01      	subs	r3, #1
 80043ec:	025b      	lsls	r3, r3, #9
 80043ee:	b29b      	uxth	r3, r3
 80043f0:	431a      	orrs	r2, r3
 80043f2:	687b      	ldr	r3, [r7, #4]
 80043f4:	68db      	ldr	r3, [r3, #12]
 80043f6:	3b01      	subs	r3, #1
 80043f8:	041b      	lsls	r3, r3, #16
 80043fa:	f403 03fe 	and.w	r3, r3, #8323072	; 0x7f0000
 80043fe:	431a      	orrs	r2, r3
 8004400:	687b      	ldr	r3, [r7, #4]
 8004402:	691b      	ldr	r3, [r3, #16]
 8004404:	3b01      	subs	r3, #1
 8004406:	061b      	lsls	r3, r3, #24
 8004408:	f003 43fe 	and.w	r3, r3, #2130706432	; 0x7f000000
 800440c:	4931      	ldr	r1, [pc, #196]	; (80044d4 <RCCEx_PLL2_Config+0x15c>)
 800440e:	4313      	orrs	r3, r2
 8004410:	638b      	str	r3, [r1, #56]	; 0x38
                          pll2->PLL2P,
                          pll2->PLL2Q,
                          pll2->PLL2R);

    /* Select PLL2 input reference frequency range: VCI */
    __HAL_RCC_PLL2_VCIRANGE(pll2->PLL2RGE) ;
 8004412:	4b30      	ldr	r3, [pc, #192]	; (80044d4 <RCCEx_PLL2_Config+0x15c>)
 8004414:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8004416:	f023 02c0 	bic.w	r2, r3, #192	; 0xc0
 800441a:	687b      	ldr	r3, [r7, #4]
 800441c:	695b      	ldr	r3, [r3, #20]
 800441e:	492d      	ldr	r1, [pc, #180]	; (80044d4 <RCCEx_PLL2_Config+0x15c>)
 8004420:	4313      	orrs	r3, r2
 8004422:	62cb      	str	r3, [r1, #44]	; 0x2c

    /* Select PLL2 output frequency range : VCO */
    __HAL_RCC_PLL2_VCORANGE(pll2->PLL2VCOSEL) ;
 8004424:	4b2b      	ldr	r3, [pc, #172]	; (80044d4 <RCCEx_PLL2_Config+0x15c>)
 8004426:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8004428:	f023 0220 	bic.w	r2, r3, #32
 800442c:	687b      	ldr	r3, [r7, #4]
 800442e:	699b      	ldr	r3, [r3, #24]
 8004430:	4928      	ldr	r1, [pc, #160]	; (80044d4 <RCCEx_PLL2_Config+0x15c>)
 8004432:	4313      	orrs	r3, r2
 8004434:	62cb      	str	r3, [r1, #44]	; 0x2c

    /* Disable PLL2FRACN . */
    __HAL_RCC_PLL2FRACN_DISABLE();
 8004436:	4b27      	ldr	r3, [pc, #156]	; (80044d4 <RCCEx_PLL2_Config+0x15c>)
 8004438:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800443a:	4a26      	ldr	r2, [pc, #152]	; (80044d4 <RCCEx_PLL2_Config+0x15c>)
 800443c:	f023 0310 	bic.w	r3, r3, #16
 8004440:	62d3      	str	r3, [r2, #44]	; 0x2c

    /* Configures PLL2 clock Fractional Part Of The Multiplication Factor */
    __HAL_RCC_PLL2FRACN_CONFIG(pll2->PLL2FRACN);
 8004442:	4b24      	ldr	r3, [pc, #144]	; (80044d4 <RCCEx_PLL2_Config+0x15c>)
 8004444:	6bda      	ldr	r2, [r3, #60]	; 0x3c
 8004446:	4b24      	ldr	r3, [pc, #144]	; (80044d8 <RCCEx_PLL2_Config+0x160>)
 8004448:	4013      	ands	r3, r2
 800444a:	687a      	ldr	r2, [r7, #4]
 800444c:	69d2      	ldr	r2, [r2, #28]
 800444e:	00d2      	lsls	r2, r2, #3
 8004450:	4920      	ldr	r1, [pc, #128]	; (80044d4 <RCCEx_PLL2_Config+0x15c>)
 8004452:	4313      	orrs	r3, r2
 8004454:	63cb      	str	r3, [r1, #60]	; 0x3c

    /* Enable PLL2FRACN . */
    __HAL_RCC_PLL2FRACN_ENABLE();
 8004456:	4b1f      	ldr	r3, [pc, #124]	; (80044d4 <RCCEx_PLL2_Config+0x15c>)
 8004458:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800445a:	4a1e      	ldr	r2, [pc, #120]	; (80044d4 <RCCEx_PLL2_Config+0x15c>)
 800445c:	f043 0310 	orr.w	r3, r3, #16
 8004460:	62d3      	str	r3, [r2, #44]	; 0x2c

    /* Enable the PLL2 clock output */
    if(Divider == DIVIDER_P_UPDATE)
 8004462:	683b      	ldr	r3, [r7, #0]
 8004464:	2b00      	cmp	r3, #0
 8004466:	d106      	bne.n	8004476 <RCCEx_PLL2_Config+0xfe>
    {
      __HAL_RCC_PLL2CLKOUT_ENABLE(RCC_PLL2_DIVP);
 8004468:	4b1a      	ldr	r3, [pc, #104]	; (80044d4 <RCCEx_PLL2_Config+0x15c>)
 800446a:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800446c:	4a19      	ldr	r2, [pc, #100]	; (80044d4 <RCCEx_PLL2_Config+0x15c>)
 800446e:	f443 2300 	orr.w	r3, r3, #524288	; 0x80000
 8004472:	62d3      	str	r3, [r2, #44]	; 0x2c
 8004474:	e00f      	b.n	8004496 <RCCEx_PLL2_Config+0x11e>
    }
    else if(Divider == DIVIDER_Q_UPDATE)
 8004476:	683b      	ldr	r3, [r7, #0]
 8004478:	2b01      	cmp	r3, #1
 800447a:	d106      	bne.n	800448a <RCCEx_PLL2_Config+0x112>
    {
      __HAL_RCC_PLL2CLKOUT_ENABLE(RCC_PLL2_DIVQ);
 800447c:	4b15      	ldr	r3, [pc, #84]	; (80044d4 <RCCEx_PLL2_Config+0x15c>)
 800447e:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8004480:	4a14      	ldr	r2, [pc, #80]	; (80044d4 <RCCEx_PLL2_Config+0x15c>)
 8004482:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
 8004486:	62d3      	str	r3, [r2, #44]	; 0x2c
 8004488:	e005      	b.n	8004496 <RCCEx_PLL2_Config+0x11e>
    }
    else
    {
      __HAL_RCC_PLL2CLKOUT_ENABLE(RCC_PLL2_DIVR);
 800448a:	4b12      	ldr	r3, [pc, #72]	; (80044d4 <RCCEx_PLL2_Config+0x15c>)
 800448c:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800448e:	4a11      	ldr	r2, [pc, #68]	; (80044d4 <RCCEx_PLL2_Config+0x15c>)
 8004490:	f443 1300 	orr.w	r3, r3, #2097152	; 0x200000
 8004494:	62d3      	str	r3, [r2, #44]	; 0x2c
    }

    /* Enable  PLL2. */
    __HAL_RCC_PLL2_ENABLE();
 8004496:	4b0f      	ldr	r3, [pc, #60]	; (80044d4 <RCCEx_PLL2_Config+0x15c>)
 8004498:	681b      	ldr	r3, [r3, #0]
 800449a:	4a0e      	ldr	r2, [pc, #56]	; (80044d4 <RCCEx_PLL2_Config+0x15c>)
 800449c:	f043 6380 	orr.w	r3, r3, #67108864	; 0x4000000
 80044a0:	6013      	str	r3, [r2, #0]

    /* Get Start Tick*/
    tickstart = HAL_GetTick();
 80044a2:	f7fd f949 	bl	8001738 <HAL_GetTick>
 80044a6:	60b8      	str	r0, [r7, #8]

    /* Wait till PLL2 is ready */
    while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLL2RDY) == 0U)
 80044a8:	e008      	b.n	80044bc <RCCEx_PLL2_Config+0x144>
    {
      if( (HAL_GetTick() - tickstart ) > PLL2_TIMEOUT_VALUE)
 80044aa:	f7fd f945 	bl	8001738 <HAL_GetTick>
 80044ae:	4602      	mov	r2, r0
 80044b0:	68bb      	ldr	r3, [r7, #8]
 80044b2:	1ad3      	subs	r3, r2, r3
 80044b4:	2b02      	cmp	r3, #2
 80044b6:	d901      	bls.n	80044bc <RCCEx_PLL2_Config+0x144>
      {
        return HAL_TIMEOUT;
 80044b8:	2303      	movs	r3, #3
 80044ba:	e006      	b.n	80044ca <RCCEx_PLL2_Config+0x152>
    while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLL2RDY) == 0U)
 80044bc:	4b05      	ldr	r3, [pc, #20]	; (80044d4 <RCCEx_PLL2_Config+0x15c>)
 80044be:	681b      	ldr	r3, [r3, #0]
 80044c0:	f003 6300 	and.w	r3, r3, #134217728	; 0x8000000
 80044c4:	2b00      	cmp	r3, #0
 80044c6:	d0f0      	beq.n	80044aa <RCCEx_PLL2_Config+0x132>
    }

  }


  return status;
 80044c8:	7bfb      	ldrb	r3, [r7, #15]
}
 80044ca:	4618      	mov	r0, r3
 80044cc:	3710      	adds	r7, #16
 80044ce:	46bd      	mov	sp, r7
 80044d0:	bd80      	pop	{r7, pc}
 80044d2:	bf00      	nop
 80044d4:	58024400 	.word	0x58024400
 80044d8:	ffff0007 	.word	0xffff0007

080044dc <RCCEx_PLL3_Config>:
  * @note   PLL3 is temporary disabled to apply new parameters
  *
  * @retval HAL status
  */
static HAL_StatusTypeDef RCCEx_PLL3_Config(RCC_PLL3InitTypeDef *pll3, uint32_t Divider)
{
 80044dc:	b580      	push	{r7, lr}
 80044de:	b084      	sub	sp, #16
 80044e0:	af00      	add	r7, sp, #0
 80044e2:	6078      	str	r0, [r7, #4]
 80044e4:	6039      	str	r1, [r7, #0]
  uint32_t tickstart;
  HAL_StatusTypeDef status = HAL_OK;
 80044e6:	2300      	movs	r3, #0
 80044e8:	73fb      	strb	r3, [r7, #15]
  assert_param(IS_RCC_PLL3RGE_VALUE(pll3->PLL3RGE));
  assert_param(IS_RCC_PLL3VCO_VALUE(pll3->PLL3VCOSEL));
  assert_param(IS_RCC_PLLFRACN_VALUE(pll3->PLL3FRACN));

  /* Check that PLL3 OSC clock source is already set */
  if(__HAL_RCC_GET_PLL_OSCSOURCE() == RCC_PLLSOURCE_NONE)
 80044ea:	4b53      	ldr	r3, [pc, #332]	; (8004638 <RCCEx_PLL3_Config+0x15c>)
 80044ec:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 80044ee:	f003 0303 	and.w	r3, r3, #3
 80044f2:	2b03      	cmp	r3, #3
 80044f4:	d101      	bne.n	80044fa <RCCEx_PLL3_Config+0x1e>
  {
    return HAL_ERROR;
 80044f6:	2301      	movs	r3, #1
 80044f8:	e099      	b.n	800462e <RCCEx_PLL3_Config+0x152>


  else
  {
    /* Disable  PLL3. */
    __HAL_RCC_PLL3_DISABLE();
 80044fa:	4b4f      	ldr	r3, [pc, #316]	; (8004638 <RCCEx_PLL3_Config+0x15c>)
 80044fc:	681b      	ldr	r3, [r3, #0]
 80044fe:	4a4e      	ldr	r2, [pc, #312]	; (8004638 <RCCEx_PLL3_Config+0x15c>)
 8004500:	f023 5380 	bic.w	r3, r3, #268435456	; 0x10000000
 8004504:	6013      	str	r3, [r2, #0]

    /* Get Start Tick*/
    tickstart = HAL_GetTick();
 8004506:	f7fd f917 	bl	8001738 <HAL_GetTick>
 800450a:	60b8      	str	r0, [r7, #8]
    /* Wait till PLL3 is ready */
    while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLL3RDY) != 0U)
 800450c:	e008      	b.n	8004520 <RCCEx_PLL3_Config+0x44>
    {
      if( (HAL_GetTick() - tickstart ) > PLL3_TIMEOUT_VALUE)
 800450e:	f7fd f913 	bl	8001738 <HAL_GetTick>
 8004512:	4602      	mov	r2, r0
 8004514:	68bb      	ldr	r3, [r7, #8]
 8004516:	1ad3      	subs	r3, r2, r3
 8004518:	2b02      	cmp	r3, #2
 800451a:	d901      	bls.n	8004520 <RCCEx_PLL3_Config+0x44>
      {
        return HAL_TIMEOUT;
 800451c:	2303      	movs	r3, #3
 800451e:	e086      	b.n	800462e <RCCEx_PLL3_Config+0x152>
    while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLL3RDY) != 0U)
 8004520:	4b45      	ldr	r3, [pc, #276]	; (8004638 <RCCEx_PLL3_Config+0x15c>)
 8004522:	681b      	ldr	r3, [r3, #0]
 8004524:	f003 5300 	and.w	r3, r3, #536870912	; 0x20000000
 8004528:	2b00      	cmp	r3, #0
 800452a:	d1f0      	bne.n	800450e <RCCEx_PLL3_Config+0x32>
      }
    }

    /* Configure the PLL3  multiplication and division factors. */
    __HAL_RCC_PLL3_CONFIG(pll3->PLL3M,
 800452c:	4b42      	ldr	r3, [pc, #264]	; (8004638 <RCCEx_PLL3_Config+0x15c>)
 800452e:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8004530:	f023 727c 	bic.w	r2, r3, #66060288	; 0x3f00000
 8004534:	687b      	ldr	r3, [r7, #4]
 8004536:	681b      	ldr	r3, [r3, #0]
 8004538:	051b      	lsls	r3, r3, #20
 800453a:	493f      	ldr	r1, [pc, #252]	; (8004638 <RCCEx_PLL3_Config+0x15c>)
 800453c:	4313      	orrs	r3, r2
 800453e:	628b      	str	r3, [r1, #40]	; 0x28
 8004540:	687b      	ldr	r3, [r7, #4]
 8004542:	685b      	ldr	r3, [r3, #4]
 8004544:	3b01      	subs	r3, #1
 8004546:	f3c3 0208 	ubfx	r2, r3, #0, #9
 800454a:	687b      	ldr	r3, [r7, #4]
 800454c:	689b      	ldr	r3, [r3, #8]
 800454e:	3b01      	subs	r3, #1
 8004550:	025b      	lsls	r3, r3, #9
 8004552:	b29b      	uxth	r3, r3
 8004554:	431a      	orrs	r2, r3
 8004556:	687b      	ldr	r3, [r7, #4]
 8004558:	68db      	ldr	r3, [r3, #12]
 800455a:	3b01      	subs	r3, #1
 800455c:	041b      	lsls	r3, r3, #16
 800455e:	f403 03fe 	and.w	r3, r3, #8323072	; 0x7f0000
 8004562:	431a      	orrs	r2, r3
 8004564:	687b      	ldr	r3, [r7, #4]
 8004566:	691b      	ldr	r3, [r3, #16]
 8004568:	3b01      	subs	r3, #1
 800456a:	061b      	lsls	r3, r3, #24
 800456c:	f003 43fe 	and.w	r3, r3, #2130706432	; 0x7f000000
 8004570:	4931      	ldr	r1, [pc, #196]	; (8004638 <RCCEx_PLL3_Config+0x15c>)
 8004572:	4313      	orrs	r3, r2
 8004574:	640b      	str	r3, [r1, #64]	; 0x40
                          pll3->PLL3P,
                          pll3->PLL3Q,
                          pll3->PLL3R);

    /* Select PLL3 input reference frequency range: VCI */
    __HAL_RCC_PLL3_VCIRANGE(pll3->PLL3RGE) ;
 8004576:	4b30      	ldr	r3, [pc, #192]	; (8004638 <RCCEx_PLL3_Config+0x15c>)
 8004578:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800457a:	f423 6240 	bic.w	r2, r3, #3072	; 0xc00
 800457e:	687b      	ldr	r3, [r7, #4]
 8004580:	695b      	ldr	r3, [r3, #20]
 8004582:	492d      	ldr	r1, [pc, #180]	; (8004638 <RCCEx_PLL3_Config+0x15c>)
 8004584:	4313      	orrs	r3, r2
 8004586:	62cb      	str	r3, [r1, #44]	; 0x2c

    /* Select PLL3 output frequency range : VCO */
    __HAL_RCC_PLL3_VCORANGE(pll3->PLL3VCOSEL) ;
 8004588:	4b2b      	ldr	r3, [pc, #172]	; (8004638 <RCCEx_PLL3_Config+0x15c>)
 800458a:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800458c:	f423 7200 	bic.w	r2, r3, #512	; 0x200
 8004590:	687b      	ldr	r3, [r7, #4]
 8004592:	699b      	ldr	r3, [r3, #24]
 8004594:	4928      	ldr	r1, [pc, #160]	; (8004638 <RCCEx_PLL3_Config+0x15c>)
 8004596:	4313      	orrs	r3, r2
 8004598:	62cb      	str	r3, [r1, #44]	; 0x2c

    /* Disable PLL3FRACN . */
    __HAL_RCC_PLL3FRACN_DISABLE();
 800459a:	4b27      	ldr	r3, [pc, #156]	; (8004638 <RCCEx_PLL3_Config+0x15c>)
 800459c:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800459e:	4a26      	ldr	r2, [pc, #152]	; (8004638 <RCCEx_PLL3_Config+0x15c>)
 80045a0:	f423 7380 	bic.w	r3, r3, #256	; 0x100
 80045a4:	62d3      	str	r3, [r2, #44]	; 0x2c

    /* Configures PLL3 clock Fractional Part Of The Multiplication Factor */
    __HAL_RCC_PLL3FRACN_CONFIG(pll3->PLL3FRACN);
 80045a6:	4b24      	ldr	r3, [pc, #144]	; (8004638 <RCCEx_PLL3_Config+0x15c>)
 80045a8:	6c5a      	ldr	r2, [r3, #68]	; 0x44
 80045aa:	4b24      	ldr	r3, [pc, #144]	; (800463c <RCCEx_PLL3_Config+0x160>)
 80045ac:	4013      	ands	r3, r2
 80045ae:	687a      	ldr	r2, [r7, #4]
 80045b0:	69d2      	ldr	r2, [r2, #28]
 80045b2:	00d2      	lsls	r2, r2, #3
 80045b4:	4920      	ldr	r1, [pc, #128]	; (8004638 <RCCEx_PLL3_Config+0x15c>)
 80045b6:	4313      	orrs	r3, r2
 80045b8:	644b      	str	r3, [r1, #68]	; 0x44

    /* Enable PLL3FRACN . */
    __HAL_RCC_PLL3FRACN_ENABLE();
 80045ba:	4b1f      	ldr	r3, [pc, #124]	; (8004638 <RCCEx_PLL3_Config+0x15c>)
 80045bc:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 80045be:	4a1e      	ldr	r2, [pc, #120]	; (8004638 <RCCEx_PLL3_Config+0x15c>)
 80045c0:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 80045c4:	62d3      	str	r3, [r2, #44]	; 0x2c

    /* Enable the PLL3 clock output */
    if(Divider == DIVIDER_P_UPDATE)
 80045c6:	683b      	ldr	r3, [r7, #0]
 80045c8:	2b00      	cmp	r3, #0
 80045ca:	d106      	bne.n	80045da <RCCEx_PLL3_Config+0xfe>
    {
      __HAL_RCC_PLL3CLKOUT_ENABLE(RCC_PLL3_DIVP);
 80045cc:	4b1a      	ldr	r3, [pc, #104]	; (8004638 <RCCEx_PLL3_Config+0x15c>)
 80045ce:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 80045d0:	4a19      	ldr	r2, [pc, #100]	; (8004638 <RCCEx_PLL3_Config+0x15c>)
 80045d2:	f443 0380 	orr.w	r3, r3, #4194304	; 0x400000
 80045d6:	62d3      	str	r3, [r2, #44]	; 0x2c
 80045d8:	e00f      	b.n	80045fa <RCCEx_PLL3_Config+0x11e>
    }
    else if(Divider == DIVIDER_Q_UPDATE)
 80045da:	683b      	ldr	r3, [r7, #0]
 80045dc:	2b01      	cmp	r3, #1
 80045de:	d106      	bne.n	80045ee <RCCEx_PLL3_Config+0x112>
    {
      __HAL_RCC_PLL3CLKOUT_ENABLE(RCC_PLL3_DIVQ);
 80045e0:	4b15      	ldr	r3, [pc, #84]	; (8004638 <RCCEx_PLL3_Config+0x15c>)
 80045e2:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 80045e4:	4a14      	ldr	r2, [pc, #80]	; (8004638 <RCCEx_PLL3_Config+0x15c>)
 80045e6:	f443 0300 	orr.w	r3, r3, #8388608	; 0x800000
 80045ea:	62d3      	str	r3, [r2, #44]	; 0x2c
 80045ec:	e005      	b.n	80045fa <RCCEx_PLL3_Config+0x11e>
    }
    else
    {
      __HAL_RCC_PLL3CLKOUT_ENABLE(RCC_PLL3_DIVR);
 80045ee:	4b12      	ldr	r3, [pc, #72]	; (8004638 <RCCEx_PLL3_Config+0x15c>)
 80045f0:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 80045f2:	4a11      	ldr	r2, [pc, #68]	; (8004638 <RCCEx_PLL3_Config+0x15c>)
 80045f4:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
 80045f8:	62d3      	str	r3, [r2, #44]	; 0x2c
    }

    /* Enable  PLL3. */
    __HAL_RCC_PLL3_ENABLE();
 80045fa:	4b0f      	ldr	r3, [pc, #60]	; (8004638 <RCCEx_PLL3_Config+0x15c>)
 80045fc:	681b      	ldr	r3, [r3, #0]
 80045fe:	4a0e      	ldr	r2, [pc, #56]	; (8004638 <RCCEx_PLL3_Config+0x15c>)
 8004600:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
 8004604:	6013      	str	r3, [r2, #0]

    /* Get Start Tick*/
    tickstart = HAL_GetTick();
 8004606:	f7fd f897 	bl	8001738 <HAL_GetTick>
 800460a:	60b8      	str	r0, [r7, #8]

    /* Wait till PLL3 is ready */
    while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLL3RDY) == 0U)
 800460c:	e008      	b.n	8004620 <RCCEx_PLL3_Config+0x144>
    {
      if( (HAL_GetTick() - tickstart ) > PLL3_TIMEOUT_VALUE)
 800460e:	f7fd f893 	bl	8001738 <HAL_GetTick>
 8004612:	4602      	mov	r2, r0
 8004614:	68bb      	ldr	r3, [r7, #8]
 8004616:	1ad3      	subs	r3, r2, r3
 8004618:	2b02      	cmp	r3, #2
 800461a:	d901      	bls.n	8004620 <RCCEx_PLL3_Config+0x144>
      {
        return HAL_TIMEOUT;
 800461c:	2303      	movs	r3, #3
 800461e:	e006      	b.n	800462e <RCCEx_PLL3_Config+0x152>
    while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLL3RDY) == 0U)
 8004620:	4b05      	ldr	r3, [pc, #20]	; (8004638 <RCCEx_PLL3_Config+0x15c>)
 8004622:	681b      	ldr	r3, [r3, #0]
 8004624:	f003 5300 	and.w	r3, r3, #536870912	; 0x20000000
 8004628:	2b00      	cmp	r3, #0
 800462a:	d0f0      	beq.n	800460e <RCCEx_PLL3_Config+0x132>
    }

  }


  return status;
 800462c:	7bfb      	ldrb	r3, [r7, #15]
}
 800462e:	4618      	mov	r0, r3
 8004630:	3710      	adds	r7, #16
 8004632:	46bd      	mov	sp, r7
 8004634:	bd80      	pop	{r7, pc}
 8004636:	bf00      	nop
 8004638:	58024400 	.word	0x58024400
 800463c:	ffff0007 	.word	0xffff0007

08004640 <HAL_SPI_Init>:
  * @param  hspi: pointer to a SPI_HandleTypeDef structure that contains
  *               the configuration information for SPI module.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_SPI_Init(SPI_HandleTypeDef *hspi)
{
 8004640:	b580      	push	{r7, lr}
 8004642:	b084      	sub	sp, #16
 8004644:	af00      	add	r7, sp, #0
 8004646:	6078      	str	r0, [r7, #4]
  uint32_t crc_length;
  uint32_t packet_length;

  /* Check the SPI handle allocation */
  if (hspi == NULL)
 8004648:	687b      	ldr	r3, [r7, #4]
 800464a:	2b00      	cmp	r3, #0
 800464c:	d101      	bne.n	8004652 <HAL_SPI_Init+0x12>
  {
    return HAL_ERROR;
 800464e:	2301      	movs	r3, #1
 8004650:	e0f1      	b.n	8004836 <HAL_SPI_Init+0x1f6>
    assert_param(IS_SPI_CRC_POLYNOMIAL(hspi->Init.CRCPolynomial));
    assert_param(IS_SPI_CRC_INITIALIZATION_PATTERN(hspi->Init.TxCRCInitializationPattern));
    assert_param(IS_SPI_CRC_INITIALIZATION_PATTERN(hspi->Init.RxCRCInitializationPattern));
  }
#else
  hspi->Init.CRCCalculation = SPI_CRCCALCULATION_DISABLE;
 8004652:	687b      	ldr	r3, [r7, #4]
 8004654:	2200      	movs	r2, #0
 8004656:	629a      	str	r2, [r3, #40]	; 0x28
#endif /* USE_SPI_CRC */

  /* Verify that the SPI instance supports Data Size higher than 16bits */
  if ((!IS_SPI_HIGHEND_INSTANCE(hspi->Instance)) && (hspi->Init.DataSize > SPI_DATASIZE_16BIT))
 8004658:	687b      	ldr	r3, [r7, #4]
 800465a:	681b      	ldr	r3, [r3, #0]
 800465c:	4a78      	ldr	r2, [pc, #480]	; (8004840 <HAL_SPI_Init+0x200>)
 800465e:	4293      	cmp	r3, r2
 8004660:	d00f      	beq.n	8004682 <HAL_SPI_Init+0x42>
 8004662:	687b      	ldr	r3, [r7, #4]
 8004664:	681b      	ldr	r3, [r3, #0]
 8004666:	4a77      	ldr	r2, [pc, #476]	; (8004844 <HAL_SPI_Init+0x204>)
 8004668:	4293      	cmp	r3, r2
 800466a:	d00a      	beq.n	8004682 <HAL_SPI_Init+0x42>
 800466c:	687b      	ldr	r3, [r7, #4]
 800466e:	681b      	ldr	r3, [r3, #0]
 8004670:	4a75      	ldr	r2, [pc, #468]	; (8004848 <HAL_SPI_Init+0x208>)
 8004672:	4293      	cmp	r3, r2
 8004674:	d005      	beq.n	8004682 <HAL_SPI_Init+0x42>
 8004676:	687b      	ldr	r3, [r7, #4]
 8004678:	68db      	ldr	r3, [r3, #12]
 800467a:	2b0f      	cmp	r3, #15
 800467c:	d901      	bls.n	8004682 <HAL_SPI_Init+0x42>
  {
    return HAL_ERROR;
 800467e:	2301      	movs	r3, #1
 8004680:	e0d9      	b.n	8004836 <HAL_SPI_Init+0x1f6>
  }

  /* Verify that the SPI instance supports requested data packing */
  packet_length = SPI_GetPacketSize(hspi);
 8004682:	6878      	ldr	r0, [r7, #4]
 8004684:	f000 fc9c 	bl	8004fc0 <SPI_GetPacketSize>
 8004688:	60f8      	str	r0, [r7, #12]
  if (((!IS_SPI_HIGHEND_INSTANCE(hspi->Instance)) && (packet_length > SPI_LOWEND_FIFO_SIZE)) ||
 800468a:	687b      	ldr	r3, [r7, #4]
 800468c:	681b      	ldr	r3, [r3, #0]
 800468e:	4a6c      	ldr	r2, [pc, #432]	; (8004840 <HAL_SPI_Init+0x200>)
 8004690:	4293      	cmp	r3, r2
 8004692:	d00c      	beq.n	80046ae <HAL_SPI_Init+0x6e>
 8004694:	687b      	ldr	r3, [r7, #4]
 8004696:	681b      	ldr	r3, [r3, #0]
 8004698:	4a6a      	ldr	r2, [pc, #424]	; (8004844 <HAL_SPI_Init+0x204>)
 800469a:	4293      	cmp	r3, r2
 800469c:	d007      	beq.n	80046ae <HAL_SPI_Init+0x6e>
 800469e:	687b      	ldr	r3, [r7, #4]
 80046a0:	681b      	ldr	r3, [r3, #0]
 80046a2:	4a69      	ldr	r2, [pc, #420]	; (8004848 <HAL_SPI_Init+0x208>)
 80046a4:	4293      	cmp	r3, r2
 80046a6:	d002      	beq.n	80046ae <HAL_SPI_Init+0x6e>
 80046a8:	68fb      	ldr	r3, [r7, #12]
 80046aa:	2b08      	cmp	r3, #8
 80046ac:	d811      	bhi.n	80046d2 <HAL_SPI_Init+0x92>
      ((IS_SPI_HIGHEND_INSTANCE(hspi->Instance)) && (packet_length > SPI_HIGHEND_FIFO_SIZE)))
 80046ae:	687b      	ldr	r3, [r7, #4]
 80046b0:	681b      	ldr	r3, [r3, #0]
  if (((!IS_SPI_HIGHEND_INSTANCE(hspi->Instance)) && (packet_length > SPI_LOWEND_FIFO_SIZE)) ||
 80046b2:	4a63      	ldr	r2, [pc, #396]	; (8004840 <HAL_SPI_Init+0x200>)
 80046b4:	4293      	cmp	r3, r2
 80046b6:	d009      	beq.n	80046cc <HAL_SPI_Init+0x8c>
      ((IS_SPI_HIGHEND_INSTANCE(hspi->Instance)) && (packet_length > SPI_HIGHEND_FIFO_SIZE)))
 80046b8:	687b      	ldr	r3, [r7, #4]
 80046ba:	681b      	ldr	r3, [r3, #0]
 80046bc:	4a61      	ldr	r2, [pc, #388]	; (8004844 <HAL_SPI_Init+0x204>)
 80046be:	4293      	cmp	r3, r2
 80046c0:	d004      	beq.n	80046cc <HAL_SPI_Init+0x8c>
 80046c2:	687b      	ldr	r3, [r7, #4]
 80046c4:	681b      	ldr	r3, [r3, #0]
 80046c6:	4a60      	ldr	r2, [pc, #384]	; (8004848 <HAL_SPI_Init+0x208>)
 80046c8:	4293      	cmp	r3, r2
 80046ca:	d104      	bne.n	80046d6 <HAL_SPI_Init+0x96>
 80046cc:	68fb      	ldr	r3, [r7, #12]
 80046ce:	2b10      	cmp	r3, #16
 80046d0:	d901      	bls.n	80046d6 <HAL_SPI_Init+0x96>
  {
    return HAL_ERROR;
 80046d2:	2301      	movs	r3, #1
 80046d4:	e0af      	b.n	8004836 <HAL_SPI_Init+0x1f6>
  {
    crc_length = hspi->Init.DataSize << SPI_CFG1_CRCSIZE_Pos;
  }
#endif /* USE_SPI_CRC */

  if (hspi->State == HAL_SPI_STATE_RESET)
 80046d6:	687b      	ldr	r3, [r7, #4]
 80046d8:	f893 3081 	ldrb.w	r3, [r3, #129]	; 0x81
 80046dc:	b2db      	uxtb	r3, r3
 80046de:	2b00      	cmp	r3, #0
 80046e0:	d106      	bne.n	80046f0 <HAL_SPI_Init+0xb0>
  {
    /* Allocate lock resource and initialize it */
    hspi->Lock = HAL_UNLOCKED;
 80046e2:	687b      	ldr	r3, [r7, #4]
 80046e4:	2200      	movs	r2, #0
 80046e6:	f883 2080 	strb.w	r2, [r3, #128]	; 0x80

    /* Init the low level hardware : GPIO, CLOCK, NVIC... */
    hspi->MspInitCallback(hspi);
#else
    /* Init the low level hardware : GPIO, CLOCK, NVIC... */
    HAL_SPI_MspInit(hspi);
 80046ea:	6878      	ldr	r0, [r7, #4]
 80046ec:	f7fc fc3a 	bl	8000f64 <HAL_SPI_MspInit>
#endif /* USE_HAL_SPI_REGISTER_CALLBACKS */
  }

  hspi->State = HAL_SPI_STATE_BUSY;
 80046f0:	687b      	ldr	r3, [r7, #4]
 80046f2:	2202      	movs	r2, #2
 80046f4:	f883 2081 	strb.w	r2, [r3, #129]	; 0x81

  /* Disable the selected SPI peripheral */
  __HAL_SPI_DISABLE(hspi);
 80046f8:	687b      	ldr	r3, [r7, #4]
 80046fa:	681b      	ldr	r3, [r3, #0]
 80046fc:	681a      	ldr	r2, [r3, #0]
 80046fe:	687b      	ldr	r3, [r7, #4]
 8004700:	681b      	ldr	r3, [r3, #0]
 8004702:	f022 0201 	bic.w	r2, r2, #1
 8004706:	601a      	str	r2, [r3, #0]

#if (USE_SPI_CRC == 0)
  /* Keep the default value of CRCSIZE in case of CRC is not used */
  crc_length = hspi->Instance->CFG1 & SPI_CFG1_CRCSIZE;
 8004708:	687b      	ldr	r3, [r7, #4]
 800470a:	681b      	ldr	r3, [r3, #0]
 800470c:	689b      	ldr	r3, [r3, #8]
 800470e:	f403 13f8 	and.w	r3, r3, #2031616	; 0x1f0000
 8004712:	60bb      	str	r3, [r7, #8]
  /*----------------------- SPIx CR1 & CR2 Configuration ---------------------*/
  /* Configure : SPI Mode, Communication Mode, Clock polarity and phase, NSS management,
  Communication speed, First bit, CRC calculation state, CRC Length */

  /* SPIx NSS Software Management Configuration */
  if ((hspi->Init.NSS == SPI_NSS_SOFT) && (((hspi->Init.Mode == SPI_MODE_MASTER) &&  \
 8004714:	687b      	ldr	r3, [r7, #4]
 8004716:	699b      	ldr	r3, [r3, #24]
 8004718:	f1b3 6f80 	cmp.w	r3, #67108864	; 0x4000000
 800471c:	d119      	bne.n	8004752 <HAL_SPI_Init+0x112>
 800471e:	687b      	ldr	r3, [r7, #4]
 8004720:	685b      	ldr	r3, [r3, #4]
 8004722:	f5b3 0f80 	cmp.w	r3, #4194304	; 0x400000
 8004726:	d103      	bne.n	8004730 <HAL_SPI_Init+0xf0>
                                            (hspi->Init.NSSPolarity == SPI_NSS_POLARITY_LOW)) || \
 8004728:	687b      	ldr	r3, [r7, #4]
 800472a:	6b9b      	ldr	r3, [r3, #56]	; 0x38
  if ((hspi->Init.NSS == SPI_NSS_SOFT) && (((hspi->Init.Mode == SPI_MODE_MASTER) &&  \
 800472c:	2b00      	cmp	r3, #0
 800472e:	d008      	beq.n	8004742 <HAL_SPI_Init+0x102>
                                           ((hspi->Init.Mode == SPI_MODE_SLAVE) && \
 8004730:	687b      	ldr	r3, [r7, #4]
 8004732:	685b      	ldr	r3, [r3, #4]
                                            (hspi->Init.NSSPolarity == SPI_NSS_POLARITY_LOW)) || \
 8004734:	2b00      	cmp	r3, #0
 8004736:	d10c      	bne.n	8004752 <HAL_SPI_Init+0x112>
                                            (hspi->Init.NSSPolarity == SPI_NSS_POLARITY_HIGH))))
 8004738:	687b      	ldr	r3, [r7, #4]
 800473a:	6b9b      	ldr	r3, [r3, #56]	; 0x38
                                           ((hspi->Init.Mode == SPI_MODE_SLAVE) && \
 800473c:	f1b3 5f80 	cmp.w	r3, #268435456	; 0x10000000
 8004740:	d107      	bne.n	8004752 <HAL_SPI_Init+0x112>
  {
    SET_BIT(hspi->Instance->CR1, SPI_CR1_SSI);
 8004742:	687b      	ldr	r3, [r7, #4]
 8004744:	681b      	ldr	r3, [r3, #0]
 8004746:	681a      	ldr	r2, [r3, #0]
 8004748:	687b      	ldr	r3, [r7, #4]
 800474a:	681b      	ldr	r3, [r3, #0]
 800474c:	f442 5280 	orr.w	r2, r2, #4096	; 0x1000
 8004750:	601a      	str	r2, [r3, #0]
  }

  /* SPIx CFG1 Configuration */
  WRITE_REG(hspi->Instance->CFG1, (hspi->Init.BaudRatePrescaler | hspi->Init.CRCCalculation | crc_length |
 8004752:	687b      	ldr	r3, [r7, #4]
 8004754:	69da      	ldr	r2, [r3, #28]
 8004756:	687b      	ldr	r3, [r7, #4]
 8004758:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 800475a:	431a      	orrs	r2, r3
 800475c:	68bb      	ldr	r3, [r7, #8]
 800475e:	431a      	orrs	r2, r3
 8004760:	687b      	ldr	r3, [r7, #4]
 8004762:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 8004764:	ea42 0103 	orr.w	r1, r2, r3
 8004768:	687b      	ldr	r3, [r7, #4]
 800476a:	68da      	ldr	r2, [r3, #12]
 800476c:	687b      	ldr	r3, [r7, #4]
 800476e:	681b      	ldr	r3, [r3, #0]
 8004770:	430a      	orrs	r2, r1
 8004772:	609a      	str	r2, [r3, #8]
                                   hspi->Init.FifoThreshold     | hspi->Init.DataSize));

  /* SPIx CFG2 Configuration */
  WRITE_REG(hspi->Instance->CFG2, (hspi->Init.NSSPMode                | hspi->Init.TIMode    |
 8004774:	687b      	ldr	r3, [r7, #4]
 8004776:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 8004778:	687b      	ldr	r3, [r7, #4]
 800477a:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800477c:	431a      	orrs	r2, r3
 800477e:	687b      	ldr	r3, [r7, #4]
 8004780:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 8004782:	431a      	orrs	r2, r3
 8004784:	687b      	ldr	r3, [r7, #4]
 8004786:	699b      	ldr	r3, [r3, #24]
 8004788:	431a      	orrs	r2, r3
 800478a:	687b      	ldr	r3, [r7, #4]
 800478c:	691b      	ldr	r3, [r3, #16]
 800478e:	431a      	orrs	r2, r3
 8004790:	687b      	ldr	r3, [r7, #4]
 8004792:	695b      	ldr	r3, [r3, #20]
 8004794:	431a      	orrs	r2, r3
 8004796:	687b      	ldr	r3, [r7, #4]
 8004798:	6a1b      	ldr	r3, [r3, #32]
 800479a:	431a      	orrs	r2, r3
 800479c:	687b      	ldr	r3, [r7, #4]
 800479e:	685b      	ldr	r3, [r3, #4]
 80047a0:	431a      	orrs	r2, r3
 80047a2:	687b      	ldr	r3, [r7, #4]
 80047a4:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 80047a6:	431a      	orrs	r2, r3
 80047a8:	687b      	ldr	r3, [r7, #4]
 80047aa:	689b      	ldr	r3, [r3, #8]
 80047ac:	431a      	orrs	r2, r3
 80047ae:	687b      	ldr	r3, [r7, #4]
 80047b0:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 80047b2:	ea42 0103 	orr.w	r1, r2, r3
 80047b6:	687b      	ldr	r3, [r7, #4]
 80047b8:	6d9a      	ldr	r2, [r3, #88]	; 0x58
 80047ba:	687b      	ldr	r3, [r7, #4]
 80047bc:	681b      	ldr	r3, [r3, #0]
 80047be:	430a      	orrs	r2, r1
 80047c0:	60da      	str	r2, [r3, #12]
    WRITE_REG(hspi->Instance->CRCPOLY, hspi->Init.CRCPolynomial);
  }
#endif /* USE_SPI_CRC */

  /* Insure that Underrun configuration is managed only by Salve */
  if (hspi->Init.Mode == SPI_MODE_SLAVE)
 80047c2:	687b      	ldr	r3, [r7, #4]
 80047c4:	685b      	ldr	r3, [r3, #4]
 80047c6:	2b00      	cmp	r3, #0
 80047c8:	d113      	bne.n	80047f2 <HAL_SPI_Init+0x1b2>
    /* Set Default Underrun configuration */
#if (USE_SPI_CRC != 0UL)
    if (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_DISABLE)
#endif /* USE_SPI_CRC */
    {
      MODIFY_REG(hspi->Instance->CFG1, SPI_CFG1_UDRDET, SPI_CFG1_UDRDET_0);
 80047ca:	687b      	ldr	r3, [r7, #4]
 80047cc:	681b      	ldr	r3, [r3, #0]
 80047ce:	689b      	ldr	r3, [r3, #8]
 80047d0:	f423 52c0 	bic.w	r2, r3, #6144	; 0x1800
 80047d4:	687b      	ldr	r3, [r7, #4]
 80047d6:	681b      	ldr	r3, [r3, #0]
 80047d8:	f442 6200 	orr.w	r2, r2, #2048	; 0x800
 80047dc:	609a      	str	r2, [r3, #8]
    }
    MODIFY_REG(hspi->Instance->CFG1, SPI_CFG1_UDRCFG, SPI_CFG1_UDRCFG_1);
 80047de:	687b      	ldr	r3, [r7, #4]
 80047e0:	681b      	ldr	r3, [r3, #0]
 80047e2:	689b      	ldr	r3, [r3, #8]
 80047e4:	f423 62c0 	bic.w	r2, r3, #1536	; 0x600
 80047e8:	687b      	ldr	r3, [r7, #4]
 80047ea:	681b      	ldr	r3, [r3, #0]
 80047ec:	f442 6280 	orr.w	r2, r2, #1024	; 0x400
 80047f0:	609a      	str	r2, [r3, #8]
  }

#if defined(SPI_I2SCFGR_I2SMOD)
  /* Activate the SPI mode (Make sure that I2SMOD bit in I2SCFGR register is reset) */
  CLEAR_BIT(hspi->Instance->I2SCFGR, SPI_I2SCFGR_I2SMOD);
 80047f2:	687b      	ldr	r3, [r7, #4]
 80047f4:	681b      	ldr	r3, [r3, #0]
 80047f6:	6d1a      	ldr	r2, [r3, #80]	; 0x50
 80047f8:	687b      	ldr	r3, [r7, #4]
 80047fa:	681b      	ldr	r3, [r3, #0]
 80047fc:	f022 0201 	bic.w	r2, r2, #1
 8004800:	651a      	str	r2, [r3, #80]	; 0x50
#endif /* SPI_I2SCFGR_I2SMOD */

  /* Insure that AFCNTR is managed only by Master */
  if ((hspi->Init.Mode & SPI_MODE_MASTER) == SPI_MODE_MASTER)
 8004802:	687b      	ldr	r3, [r7, #4]
 8004804:	685b      	ldr	r3, [r3, #4]
 8004806:	f403 0380 	and.w	r3, r3, #4194304	; 0x400000
 800480a:	2b00      	cmp	r3, #0
 800480c:	d00a      	beq.n	8004824 <HAL_SPI_Init+0x1e4>
  {
    /* Alternate function GPIOs control */
    MODIFY_REG(hspi->Instance->CFG2, SPI_CFG2_AFCNTR, (hspi->Init.MasterKeepIOState));
 800480e:	687b      	ldr	r3, [r7, #4]
 8004810:	681b      	ldr	r3, [r3, #0]
 8004812:	68db      	ldr	r3, [r3, #12]
 8004814:	f023 4100 	bic.w	r1, r3, #2147483648	; 0x80000000
 8004818:	687b      	ldr	r3, [r7, #4]
 800481a:	6d5a      	ldr	r2, [r3, #84]	; 0x54
 800481c:	687b      	ldr	r3, [r7, #4]
 800481e:	681b      	ldr	r3, [r3, #0]
 8004820:	430a      	orrs	r2, r1
 8004822:	60da      	str	r2, [r3, #12]
  }

  hspi->ErrorCode = HAL_SPI_ERROR_NONE;
 8004824:	687b      	ldr	r3, [r7, #4]
 8004826:	2200      	movs	r2, #0
 8004828:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84
  hspi->State     = HAL_SPI_STATE_READY;
 800482c:	687b      	ldr	r3, [r7, #4]
 800482e:	2201      	movs	r2, #1
 8004830:	f883 2081 	strb.w	r2, [r3, #129]	; 0x81

  return HAL_OK;
 8004834:	2300      	movs	r3, #0
}
 8004836:	4618      	mov	r0, r3
 8004838:	3710      	adds	r7, #16
 800483a:	46bd      	mov	sp, r7
 800483c:	bd80      	pop	{r7, pc}
 800483e:	bf00      	nop
 8004840:	40013000 	.word	0x40013000
 8004844:	40003800 	.word	0x40003800
 8004848:	40003c00 	.word	0x40003c00

0800484c <HAL_SPI_TransmitReceive>:
  * @param  Timeout: Timeout duration
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_SPI_TransmitReceive(SPI_HandleTypeDef *hspi, uint8_t *pTxData, uint8_t *pRxData, uint16_t Size,
                                          uint32_t Timeout)
{
 800484c:	b580      	push	{r7, lr}
 800484e:	b08e      	sub	sp, #56	; 0x38
 8004850:	af02      	add	r7, sp, #8
 8004852:	60f8      	str	r0, [r7, #12]
 8004854:	60b9      	str	r1, [r7, #8]
 8004856:	607a      	str	r2, [r7, #4]
 8004858:	807b      	strh	r3, [r7, #2]
  HAL_SPI_StateTypeDef tmp_state;
  HAL_StatusTypeDef errorcode = HAL_OK;
 800485a:	2300      	movs	r3, #0
 800485c:	f887 302b 	strb.w	r3, [r7, #43]	; 0x2b
#if defined (__GNUC__)
  __IO uint16_t *ptxdr_16bits = (__IO uint16_t *)(&(hspi->Instance->TXDR));
 8004860:	68fb      	ldr	r3, [r7, #12]
 8004862:	681b      	ldr	r3, [r3, #0]
 8004864:	3320      	adds	r3, #32
 8004866:	627b      	str	r3, [r7, #36]	; 0x24
  __IO uint16_t *prxdr_16bits = (__IO uint16_t *)(&(hspi->Instance->RXDR));
 8004868:	68fb      	ldr	r3, [r7, #12]
 800486a:	681b      	ldr	r3, [r3, #0]
 800486c:	3330      	adds	r3, #48	; 0x30
 800486e:	623b      	str	r3, [r7, #32]

  /* Check Direction parameter */
  assert_param(IS_SPI_DIRECTION_2LINES(hspi->Init.Direction));

  /* Lock the process */
  __HAL_LOCK(hspi);
 8004870:	68fb      	ldr	r3, [r7, #12]
 8004872:	f893 3080 	ldrb.w	r3, [r3, #128]	; 0x80
 8004876:	2b01      	cmp	r3, #1
 8004878:	d101      	bne.n	800487e <HAL_SPI_TransmitReceive+0x32>
 800487a:	2302      	movs	r3, #2
 800487c:	e2ce      	b.n	8004e1c <HAL_SPI_TransmitReceive+0x5d0>
 800487e:	68fb      	ldr	r3, [r7, #12]
 8004880:	2201      	movs	r2, #1
 8004882:	f883 2080 	strb.w	r2, [r3, #128]	; 0x80

  /* Init tickstart for timeout management*/
  tickstart = HAL_GetTick();
 8004886:	f7fc ff57 	bl	8001738 <HAL_GetTick>
 800488a:	61f8      	str	r0, [r7, #28]

  initial_TxXferCount = Size;
 800488c:	887b      	ldrh	r3, [r7, #2]
 800488e:	85fb      	strh	r3, [r7, #46]	; 0x2e
  initial_RxXferCount = Size;
 8004890:	887b      	ldrh	r3, [r7, #2]
 8004892:	85bb      	strh	r3, [r7, #44]	; 0x2c
  tmp_state           = hspi->State;
 8004894:	68fb      	ldr	r3, [r7, #12]
 8004896:	f893 3081 	ldrb.w	r3, [r3, #129]	; 0x81
 800489a:	76fb      	strb	r3, [r7, #27]
  tmp_mode            = hspi->Init.Mode;
 800489c:	68fb      	ldr	r3, [r7, #12]
 800489e:	685b      	ldr	r3, [r3, #4]
 80048a0:	617b      	str	r3, [r7, #20]

  if (!((tmp_state == HAL_SPI_STATE_READY) || \
 80048a2:	7efb      	ldrb	r3, [r7, #27]
 80048a4:	2b01      	cmp	r3, #1
 80048a6:	d014      	beq.n	80048d2 <HAL_SPI_TransmitReceive+0x86>
 80048a8:	697b      	ldr	r3, [r7, #20]
 80048aa:	f5b3 0f80 	cmp.w	r3, #4194304	; 0x400000
 80048ae:	d106      	bne.n	80048be <HAL_SPI_TransmitReceive+0x72>
        ((tmp_mode == SPI_MODE_MASTER) && \
         (hspi->Init.Direction == SPI_DIRECTION_2LINES) && \
 80048b0:	68fb      	ldr	r3, [r7, #12]
 80048b2:	689b      	ldr	r3, [r3, #8]
        ((tmp_mode == SPI_MODE_MASTER) && \
 80048b4:	2b00      	cmp	r3, #0
 80048b6:	d102      	bne.n	80048be <HAL_SPI_TransmitReceive+0x72>
         (hspi->Init.Direction == SPI_DIRECTION_2LINES) && \
 80048b8:	7efb      	ldrb	r3, [r7, #27]
 80048ba:	2b04      	cmp	r3, #4
 80048bc:	d009      	beq.n	80048d2 <HAL_SPI_TransmitReceive+0x86>
         (tmp_state == HAL_SPI_STATE_BUSY_RX))))
  {
    errorcode = HAL_BUSY;
 80048be:	2302      	movs	r3, #2
 80048c0:	f887 302b 	strb.w	r3, [r7, #43]	; 0x2b
    __HAL_UNLOCK(hspi);
 80048c4:	68fb      	ldr	r3, [r7, #12]
 80048c6:	2200      	movs	r2, #0
 80048c8:	f883 2080 	strb.w	r2, [r3, #128]	; 0x80
    return errorcode;
 80048cc:	f897 302b 	ldrb.w	r3, [r7, #43]	; 0x2b
 80048d0:	e2a4      	b.n	8004e1c <HAL_SPI_TransmitReceive+0x5d0>
  }

  if ((pTxData == NULL) || (pRxData == NULL) || (Size == 0UL))
 80048d2:	68bb      	ldr	r3, [r7, #8]
 80048d4:	2b00      	cmp	r3, #0
 80048d6:	d005      	beq.n	80048e4 <HAL_SPI_TransmitReceive+0x98>
 80048d8:	687b      	ldr	r3, [r7, #4]
 80048da:	2b00      	cmp	r3, #0
 80048dc:	d002      	beq.n	80048e4 <HAL_SPI_TransmitReceive+0x98>
 80048de:	887b      	ldrh	r3, [r7, #2]
 80048e0:	2b00      	cmp	r3, #0
 80048e2:	d109      	bne.n	80048f8 <HAL_SPI_TransmitReceive+0xac>
  {
    errorcode = HAL_ERROR;
 80048e4:	2301      	movs	r3, #1
 80048e6:	f887 302b 	strb.w	r3, [r7, #43]	; 0x2b
    __HAL_UNLOCK(hspi);
 80048ea:	68fb      	ldr	r3, [r7, #12]
 80048ec:	2200      	movs	r2, #0
 80048ee:	f883 2080 	strb.w	r2, [r3, #128]	; 0x80
    return errorcode;
 80048f2:	f897 302b 	ldrb.w	r3, [r7, #43]	; 0x2b
 80048f6:	e291      	b.n	8004e1c <HAL_SPI_TransmitReceive+0x5d0>
  }

  /* Don't overwrite in case of HAL_SPI_STATE_BUSY_RX */
  if (hspi->State != HAL_SPI_STATE_BUSY_RX)
 80048f8:	68fb      	ldr	r3, [r7, #12]
 80048fa:	f893 3081 	ldrb.w	r3, [r3, #129]	; 0x81
 80048fe:	b2db      	uxtb	r3, r3
 8004900:	2b04      	cmp	r3, #4
 8004902:	d003      	beq.n	800490c <HAL_SPI_TransmitReceive+0xc0>
  {
    hspi->State = HAL_SPI_STATE_BUSY_TX_RX;
 8004904:	68fb      	ldr	r3, [r7, #12]
 8004906:	2205      	movs	r2, #5
 8004908:	f883 2081 	strb.w	r2, [r3, #129]	; 0x81
  }

  /* Set the transaction information */
  hspi->ErrorCode   = HAL_SPI_ERROR_NONE;
 800490c:	68fb      	ldr	r3, [r7, #12]
 800490e:	2200      	movs	r2, #0
 8004910:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84
  hspi->pRxBuffPtr  = (uint8_t *)pRxData;
 8004914:	68fb      	ldr	r3, [r7, #12]
 8004916:	687a      	ldr	r2, [r7, #4]
 8004918:	665a      	str	r2, [r3, #100]	; 0x64
  hspi->RxXferCount = Size;
 800491a:	68fb      	ldr	r3, [r7, #12]
 800491c:	887a      	ldrh	r2, [r7, #2]
 800491e:	f8a3 206a 	strh.w	r2, [r3, #106]	; 0x6a
  hspi->RxXferSize  = Size;
 8004922:	68fb      	ldr	r3, [r7, #12]
 8004924:	887a      	ldrh	r2, [r7, #2]
 8004926:	f8a3 2068 	strh.w	r2, [r3, #104]	; 0x68
  hspi->pTxBuffPtr  = (uint8_t *)pTxData;
 800492a:	68fb      	ldr	r3, [r7, #12]
 800492c:	68ba      	ldr	r2, [r7, #8]
 800492e:	65da      	str	r2, [r3, #92]	; 0x5c
  hspi->TxXferCount = Size;
 8004930:	68fb      	ldr	r3, [r7, #12]
 8004932:	887a      	ldrh	r2, [r7, #2]
 8004934:	f8a3 2062 	strh.w	r2, [r3, #98]	; 0x62
  hspi->TxXferSize  = Size;
 8004938:	68fb      	ldr	r3, [r7, #12]
 800493a:	887a      	ldrh	r2, [r7, #2]
 800493c:	f8a3 2060 	strh.w	r2, [r3, #96]	; 0x60

  /*Init field not used in handle to zero */
  hspi->RxISR       = NULL;
 8004940:	68fb      	ldr	r3, [r7, #12]
 8004942:	2200      	movs	r2, #0
 8004944:	671a      	str	r2, [r3, #112]	; 0x70
  hspi->TxISR       = NULL;
 8004946:	68fb      	ldr	r3, [r7, #12]
 8004948:	2200      	movs	r2, #0
 800494a:	675a      	str	r2, [r3, #116]	; 0x74

  /* Set the number of data at current transfer */
  MODIFY_REG(hspi->Instance->CR2, SPI_CR2_TSIZE, Size);
 800494c:	68fb      	ldr	r3, [r7, #12]
 800494e:	681b      	ldr	r3, [r3, #0]
 8004950:	685a      	ldr	r2, [r3, #4]
 8004952:	4b81      	ldr	r3, [pc, #516]	; (8004b58 <HAL_SPI_TransmitReceive+0x30c>)
 8004954:	4013      	ands	r3, r2
 8004956:	8879      	ldrh	r1, [r7, #2]
 8004958:	68fa      	ldr	r2, [r7, #12]
 800495a:	6812      	ldr	r2, [r2, #0]
 800495c:	430b      	orrs	r3, r1
 800495e:	6053      	str	r3, [r2, #4]

  __HAL_SPI_ENABLE(hspi);
 8004960:	68fb      	ldr	r3, [r7, #12]
 8004962:	681b      	ldr	r3, [r3, #0]
 8004964:	681a      	ldr	r2, [r3, #0]
 8004966:	68fb      	ldr	r3, [r7, #12]
 8004968:	681b      	ldr	r3, [r3, #0]
 800496a:	f042 0201 	orr.w	r2, r2, #1
 800496e:	601a      	str	r2, [r3, #0]

  if (hspi->Init.Mode == SPI_MODE_MASTER)
 8004970:	68fb      	ldr	r3, [r7, #12]
 8004972:	685b      	ldr	r3, [r3, #4]
 8004974:	f5b3 0f80 	cmp.w	r3, #4194304	; 0x400000
 8004978:	d107      	bne.n	800498a <HAL_SPI_TransmitReceive+0x13e>
  {
    /* Master transfer start */
    SET_BIT(hspi->Instance->CR1, SPI_CR1_CSTART);
 800497a:	68fb      	ldr	r3, [r7, #12]
 800497c:	681b      	ldr	r3, [r3, #0]
 800497e:	681a      	ldr	r2, [r3, #0]
 8004980:	68fb      	ldr	r3, [r7, #12]
 8004982:	681b      	ldr	r3, [r3, #0]
 8004984:	f442 7200 	orr.w	r2, r2, #512	; 0x200
 8004988:	601a      	str	r2, [r3, #0]
  }

  /* Transmit and Receive data in 32 Bit mode */
  if (hspi->Init.DataSize > SPI_DATASIZE_16BIT)
 800498a:	68fb      	ldr	r3, [r7, #12]
 800498c:	68db      	ldr	r3, [r3, #12]
 800498e:	2b0f      	cmp	r3, #15
 8004990:	d970      	bls.n	8004a74 <HAL_SPI_TransmitReceive+0x228>
  {
    while ((initial_TxXferCount > 0UL) || (initial_RxXferCount > 0UL))
 8004992:	e068      	b.n	8004a66 <HAL_SPI_TransmitReceive+0x21a>
    {
      /* Check TXP flag */
      if ((__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_TXP)) && (initial_TxXferCount > 0UL))
 8004994:	68fb      	ldr	r3, [r7, #12]
 8004996:	681b      	ldr	r3, [r3, #0]
 8004998:	695b      	ldr	r3, [r3, #20]
 800499a:	f003 0302 	and.w	r3, r3, #2
 800499e:	2b02      	cmp	r3, #2
 80049a0:	d11a      	bne.n	80049d8 <HAL_SPI_TransmitReceive+0x18c>
 80049a2:	8dfb      	ldrh	r3, [r7, #46]	; 0x2e
 80049a4:	2b00      	cmp	r3, #0
 80049a6:	d017      	beq.n	80049d8 <HAL_SPI_TransmitReceive+0x18c>
      {
        *((__IO uint32_t *)&hspi->Instance->TXDR) = *((uint32_t *)hspi->pTxBuffPtr);
 80049a8:	68fb      	ldr	r3, [r7, #12]
 80049aa:	6dda      	ldr	r2, [r3, #92]	; 0x5c
 80049ac:	68fb      	ldr	r3, [r7, #12]
 80049ae:	681b      	ldr	r3, [r3, #0]
 80049b0:	6812      	ldr	r2, [r2, #0]
 80049b2:	621a      	str	r2, [r3, #32]
        hspi->pTxBuffPtr += sizeof(uint32_t);
 80049b4:	68fb      	ldr	r3, [r7, #12]
 80049b6:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
 80049b8:	1d1a      	adds	r2, r3, #4
 80049ba:	68fb      	ldr	r3, [r7, #12]
 80049bc:	65da      	str	r2, [r3, #92]	; 0x5c
        hspi->TxXferCount --;
 80049be:	68fb      	ldr	r3, [r7, #12]
 80049c0:	f8b3 3062 	ldrh.w	r3, [r3, #98]	; 0x62
 80049c4:	b29b      	uxth	r3, r3
 80049c6:	3b01      	subs	r3, #1
 80049c8:	b29a      	uxth	r2, r3
 80049ca:	68fb      	ldr	r3, [r7, #12]
 80049cc:	f8a3 2062 	strh.w	r2, [r3, #98]	; 0x62
        initial_TxXferCount = hspi->TxXferCount;
 80049d0:	68fb      	ldr	r3, [r7, #12]
 80049d2:	f8b3 3062 	ldrh.w	r3, [r3, #98]	; 0x62
 80049d6:	85fb      	strh	r3, [r7, #46]	; 0x2e
      }

      /* Check RXWNE/EOT flag */
      if (((hspi->Instance->SR & (SPI_FLAG_RXWNE | SPI_FLAG_EOT)) != 0UL) && (initial_RxXferCount > 0UL))
 80049d8:	68fb      	ldr	r3, [r7, #12]
 80049da:	681b      	ldr	r3, [r3, #0]
 80049dc:	695a      	ldr	r2, [r3, #20]
 80049de:	f248 0308 	movw	r3, #32776	; 0x8008
 80049e2:	4013      	ands	r3, r2
 80049e4:	2b00      	cmp	r3, #0
 80049e6:	d01a      	beq.n	8004a1e <HAL_SPI_TransmitReceive+0x1d2>
 80049e8:	8dbb      	ldrh	r3, [r7, #44]	; 0x2c
 80049ea:	2b00      	cmp	r3, #0
 80049ec:	d017      	beq.n	8004a1e <HAL_SPI_TransmitReceive+0x1d2>
      {
        *((uint32_t *)hspi->pRxBuffPtr) = *((__IO uint32_t *)&hspi->Instance->RXDR);
 80049ee:	68fb      	ldr	r3, [r7, #12]
 80049f0:	681a      	ldr	r2, [r3, #0]
 80049f2:	68fb      	ldr	r3, [r7, #12]
 80049f4:	6e5b      	ldr	r3, [r3, #100]	; 0x64
 80049f6:	6b12      	ldr	r2, [r2, #48]	; 0x30
 80049f8:	601a      	str	r2, [r3, #0]
        hspi->pRxBuffPtr += sizeof(uint32_t);
 80049fa:	68fb      	ldr	r3, [r7, #12]
 80049fc:	6e5b      	ldr	r3, [r3, #100]	; 0x64
 80049fe:	1d1a      	adds	r2, r3, #4
 8004a00:	68fb      	ldr	r3, [r7, #12]
 8004a02:	665a      	str	r2, [r3, #100]	; 0x64
        hspi->RxXferCount --;
 8004a04:	68fb      	ldr	r3, [r7, #12]
 8004a06:	f8b3 306a 	ldrh.w	r3, [r3, #106]	; 0x6a
 8004a0a:	b29b      	uxth	r3, r3
 8004a0c:	3b01      	subs	r3, #1
 8004a0e:	b29a      	uxth	r2, r3
 8004a10:	68fb      	ldr	r3, [r7, #12]
 8004a12:	f8a3 206a 	strh.w	r2, [r3, #106]	; 0x6a
        initial_RxXferCount = hspi->RxXferCount;
 8004a16:	68fb      	ldr	r3, [r7, #12]
 8004a18:	f8b3 306a 	ldrh.w	r3, [r3, #106]	; 0x6a
 8004a1c:	85bb      	strh	r3, [r7, #44]	; 0x2c
      }

      /* Timeout management */
      if ((((HAL_GetTick() - tickstart) >=  Timeout) && (Timeout != HAL_MAX_DELAY)) || (Timeout == 0U))
 8004a1e:	f7fc fe8b 	bl	8001738 <HAL_GetTick>
 8004a22:	4602      	mov	r2, r0
 8004a24:	69fb      	ldr	r3, [r7, #28]
 8004a26:	1ad3      	subs	r3, r2, r3
 8004a28:	6bba      	ldr	r2, [r7, #56]	; 0x38
 8004a2a:	429a      	cmp	r2, r3
 8004a2c:	d803      	bhi.n	8004a36 <HAL_SPI_TransmitReceive+0x1ea>
 8004a2e:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8004a30:	f1b3 3fff 	cmp.w	r3, #4294967295
 8004a34:	d102      	bne.n	8004a3c <HAL_SPI_TransmitReceive+0x1f0>
 8004a36:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8004a38:	2b00      	cmp	r3, #0
 8004a3a:	d114      	bne.n	8004a66 <HAL_SPI_TransmitReceive+0x21a>
      {
        /* Call standard close procedure with error check */
        SPI_CloseTransfer(hspi);
 8004a3c:	68f8      	ldr	r0, [r7, #12]
 8004a3e:	f000 f9f1 	bl	8004e24 <SPI_CloseTransfer>

        /* Unlock the process */
        __HAL_UNLOCK(hspi);
 8004a42:	68fb      	ldr	r3, [r7, #12]
 8004a44:	2200      	movs	r2, #0
 8004a46:	f883 2080 	strb.w	r2, [r3, #128]	; 0x80

        SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_TIMEOUT);
 8004a4a:	68fb      	ldr	r3, [r7, #12]
 8004a4c:	f8d3 3084 	ldr.w	r3, [r3, #132]	; 0x84
 8004a50:	f443 7280 	orr.w	r2, r3, #256	; 0x100
 8004a54:	68fb      	ldr	r3, [r7, #12]
 8004a56:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84
        hspi->State = HAL_SPI_STATE_READY;
 8004a5a:	68fb      	ldr	r3, [r7, #12]
 8004a5c:	2201      	movs	r2, #1
 8004a5e:	f883 2081 	strb.w	r2, [r3, #129]	; 0x81
        return HAL_TIMEOUT;
 8004a62:	2303      	movs	r3, #3
 8004a64:	e1da      	b.n	8004e1c <HAL_SPI_TransmitReceive+0x5d0>
    while ((initial_TxXferCount > 0UL) || (initial_RxXferCount > 0UL))
 8004a66:	8dfb      	ldrh	r3, [r7, #46]	; 0x2e
 8004a68:	2b00      	cmp	r3, #0
 8004a6a:	d193      	bne.n	8004994 <HAL_SPI_TransmitReceive+0x148>
 8004a6c:	8dbb      	ldrh	r3, [r7, #44]	; 0x2c
 8004a6e:	2b00      	cmp	r3, #0
 8004a70:	d190      	bne.n	8004994 <HAL_SPI_TransmitReceive+0x148>
 8004a72:	e1ac      	b.n	8004dce <HAL_SPI_TransmitReceive+0x582>
      }
    }
  }
  /* Transmit and Receive data in 16 Bit mode */
  else if (hspi->Init.DataSize > SPI_DATASIZE_8BIT)
 8004a74:	68fb      	ldr	r3, [r7, #12]
 8004a76:	68db      	ldr	r3, [r3, #12]
 8004a78:	2b07      	cmp	r3, #7
 8004a7a:	f240 81a0 	bls.w	8004dbe <HAL_SPI_TransmitReceive+0x572>
  {
    while ((initial_TxXferCount > 0UL) || (initial_RxXferCount > 0UL))
 8004a7e:	e0a9      	b.n	8004bd4 <HAL_SPI_TransmitReceive+0x388>
    {
      /* Check TXP flag */
      if (__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_TXP) && (initial_TxXferCount > 0UL))
 8004a80:	68fb      	ldr	r3, [r7, #12]
 8004a82:	681b      	ldr	r3, [r3, #0]
 8004a84:	695b      	ldr	r3, [r3, #20]
 8004a86:	f003 0302 	and.w	r3, r3, #2
 8004a8a:	2b02      	cmp	r3, #2
 8004a8c:	d139      	bne.n	8004b02 <HAL_SPI_TransmitReceive+0x2b6>
 8004a8e:	8dfb      	ldrh	r3, [r7, #46]	; 0x2e
 8004a90:	2b00      	cmp	r3, #0
 8004a92:	d036      	beq.n	8004b02 <HAL_SPI_TransmitReceive+0x2b6>
      {
        if ((initial_TxXferCount > 1UL) && (hspi->Init.FifoThreshold > SPI_FIFO_THRESHOLD_01DATA))
 8004a94:	8dfb      	ldrh	r3, [r7, #46]	; 0x2e
 8004a96:	2b01      	cmp	r3, #1
 8004a98:	d91c      	bls.n	8004ad4 <HAL_SPI_TransmitReceive+0x288>
 8004a9a:	68fb      	ldr	r3, [r7, #12]
 8004a9c:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 8004a9e:	2b00      	cmp	r3, #0
 8004aa0:	d018      	beq.n	8004ad4 <HAL_SPI_TransmitReceive+0x288>
        {
          *((__IO uint32_t *)&hspi->Instance->TXDR) = *((uint32_t *)hspi->pTxBuffPtr);
 8004aa2:	68fb      	ldr	r3, [r7, #12]
 8004aa4:	6dda      	ldr	r2, [r3, #92]	; 0x5c
 8004aa6:	68fb      	ldr	r3, [r7, #12]
 8004aa8:	681b      	ldr	r3, [r3, #0]
 8004aaa:	6812      	ldr	r2, [r2, #0]
 8004aac:	621a      	str	r2, [r3, #32]
          hspi->pTxBuffPtr += sizeof(uint32_t);
 8004aae:	68fb      	ldr	r3, [r7, #12]
 8004ab0:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
 8004ab2:	1d1a      	adds	r2, r3, #4
 8004ab4:	68fb      	ldr	r3, [r7, #12]
 8004ab6:	65da      	str	r2, [r3, #92]	; 0x5c
          hspi->TxXferCount -= (uint16_t)2UL;
 8004ab8:	68fb      	ldr	r3, [r7, #12]
 8004aba:	f8b3 3062 	ldrh.w	r3, [r3, #98]	; 0x62
 8004abe:	b29b      	uxth	r3, r3
 8004ac0:	3b02      	subs	r3, #2
 8004ac2:	b29a      	uxth	r2, r3
 8004ac4:	68fb      	ldr	r3, [r7, #12]
 8004ac6:	f8a3 2062 	strh.w	r2, [r3, #98]	; 0x62
          initial_TxXferCount = hspi->TxXferCount;
 8004aca:	68fb      	ldr	r3, [r7, #12]
 8004acc:	f8b3 3062 	ldrh.w	r3, [r3, #98]	; 0x62
 8004ad0:	85fb      	strh	r3, [r7, #46]	; 0x2e
 8004ad2:	e016      	b.n	8004b02 <HAL_SPI_TransmitReceive+0x2b6>
        }
        else
        {
#if defined (__GNUC__)
          *ptxdr_16bits = *((uint16_t *)hspi->pTxBuffPtr);
 8004ad4:	68fb      	ldr	r3, [r7, #12]
 8004ad6:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
 8004ad8:	881a      	ldrh	r2, [r3, #0]
 8004ada:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8004adc:	801a      	strh	r2, [r3, #0]
#else
          *((__IO uint16_t *)&hspi->Instance->TXDR) = *((uint16_t *)hspi->pTxBuffPtr);
#endif /* __GNUC__ */
          hspi->pTxBuffPtr += sizeof(uint16_t);
 8004ade:	68fb      	ldr	r3, [r7, #12]
 8004ae0:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
 8004ae2:	1c9a      	adds	r2, r3, #2
 8004ae4:	68fb      	ldr	r3, [r7, #12]
 8004ae6:	65da      	str	r2, [r3, #92]	; 0x5c
          hspi->TxXferCount--;
 8004ae8:	68fb      	ldr	r3, [r7, #12]
 8004aea:	f8b3 3062 	ldrh.w	r3, [r3, #98]	; 0x62
 8004aee:	b29b      	uxth	r3, r3
 8004af0:	3b01      	subs	r3, #1
 8004af2:	b29a      	uxth	r2, r3
 8004af4:	68fb      	ldr	r3, [r7, #12]
 8004af6:	f8a3 2062 	strh.w	r2, [r3, #98]	; 0x62
          initial_TxXferCount = hspi->TxXferCount;
 8004afa:	68fb      	ldr	r3, [r7, #12]
 8004afc:	f8b3 3062 	ldrh.w	r3, [r3, #98]	; 0x62
 8004b00:	85fb      	strh	r3, [r7, #46]	; 0x2e
        }
      }

      /* Check RXWNE/FRLVL flag */
      if (((hspi->Instance->SR & (SPI_FLAG_RXWNE | SPI_FLAG_FRLVL)) != 0UL) && (initial_RxXferCount > 0UL))
 8004b02:	68fb      	ldr	r3, [r7, #12]
 8004b04:	681b      	ldr	r3, [r3, #0]
 8004b06:	695b      	ldr	r3, [r3, #20]
 8004b08:	f403 4360 	and.w	r3, r3, #57344	; 0xe000
 8004b0c:	2b00      	cmp	r3, #0
 8004b0e:	d03d      	beq.n	8004b8c <HAL_SPI_TransmitReceive+0x340>
 8004b10:	8dbb      	ldrh	r3, [r7, #44]	; 0x2c
 8004b12:	2b00      	cmp	r3, #0
 8004b14:	d03a      	beq.n	8004b8c <HAL_SPI_TransmitReceive+0x340>
      {
        if ((hspi->Instance->SR & SPI_FLAG_RXWNE) != 0UL)
 8004b16:	68fb      	ldr	r3, [r7, #12]
 8004b18:	681b      	ldr	r3, [r3, #0]
 8004b1a:	695b      	ldr	r3, [r3, #20]
 8004b1c:	f403 4300 	and.w	r3, r3, #32768	; 0x8000
 8004b20:	2b00      	cmp	r3, #0
 8004b22:	d01b      	beq.n	8004b5c <HAL_SPI_TransmitReceive+0x310>
        {
          *((uint32_t *)hspi->pRxBuffPtr) = *((__IO uint32_t *)&hspi->Instance->RXDR);
 8004b24:	68fb      	ldr	r3, [r7, #12]
 8004b26:	681a      	ldr	r2, [r3, #0]
 8004b28:	68fb      	ldr	r3, [r7, #12]
 8004b2a:	6e5b      	ldr	r3, [r3, #100]	; 0x64
 8004b2c:	6b12      	ldr	r2, [r2, #48]	; 0x30
 8004b2e:	601a      	str	r2, [r3, #0]
          hspi->pRxBuffPtr += sizeof(uint32_t);
 8004b30:	68fb      	ldr	r3, [r7, #12]
 8004b32:	6e5b      	ldr	r3, [r3, #100]	; 0x64
 8004b34:	1d1a      	adds	r2, r3, #4
 8004b36:	68fb      	ldr	r3, [r7, #12]
 8004b38:	665a      	str	r2, [r3, #100]	; 0x64
          hspi->RxXferCount -= (uint16_t)2UL;
 8004b3a:	68fb      	ldr	r3, [r7, #12]
 8004b3c:	f8b3 306a 	ldrh.w	r3, [r3, #106]	; 0x6a
 8004b40:	b29b      	uxth	r3, r3
 8004b42:	3b02      	subs	r3, #2
 8004b44:	b29a      	uxth	r2, r3
 8004b46:	68fb      	ldr	r3, [r7, #12]
 8004b48:	f8a3 206a 	strh.w	r2, [r3, #106]	; 0x6a
          initial_RxXferCount = hspi->RxXferCount;
 8004b4c:	68fb      	ldr	r3, [r7, #12]
 8004b4e:	f8b3 306a 	ldrh.w	r3, [r3, #106]	; 0x6a
 8004b52:	85bb      	strh	r3, [r7, #44]	; 0x2c
 8004b54:	e01a      	b.n	8004b8c <HAL_SPI_TransmitReceive+0x340>
 8004b56:	bf00      	nop
 8004b58:	ffff0000 	.word	0xffff0000
        }
        else
        {
#if defined (__GNUC__)
          *((uint16_t *)hspi->pRxBuffPtr) = *prxdr_16bits;
 8004b5c:	68fb      	ldr	r3, [r7, #12]
 8004b5e:	6e5b      	ldr	r3, [r3, #100]	; 0x64
 8004b60:	6a3a      	ldr	r2, [r7, #32]
 8004b62:	8812      	ldrh	r2, [r2, #0]
 8004b64:	b292      	uxth	r2, r2
 8004b66:	801a      	strh	r2, [r3, #0]
#else
          *((uint16_t *)hspi->pRxBuffPtr) = *((__IO uint16_t *)&hspi->Instance->RXDR);
#endif /* __GNUC__ */
          hspi->pRxBuffPtr += sizeof(uint16_t);
 8004b68:	68fb      	ldr	r3, [r7, #12]
 8004b6a:	6e5b      	ldr	r3, [r3, #100]	; 0x64
 8004b6c:	1c9a      	adds	r2, r3, #2
 8004b6e:	68fb      	ldr	r3, [r7, #12]
 8004b70:	665a      	str	r2, [r3, #100]	; 0x64
          hspi->RxXferCount--;
 8004b72:	68fb      	ldr	r3, [r7, #12]
 8004b74:	f8b3 306a 	ldrh.w	r3, [r3, #106]	; 0x6a
 8004b78:	b29b      	uxth	r3, r3
 8004b7a:	3b01      	subs	r3, #1
 8004b7c:	b29a      	uxth	r2, r3
 8004b7e:	68fb      	ldr	r3, [r7, #12]
 8004b80:	f8a3 206a 	strh.w	r2, [r3, #106]	; 0x6a
          initial_RxXferCount = hspi->RxXferCount;
 8004b84:	68fb      	ldr	r3, [r7, #12]
 8004b86:	f8b3 306a 	ldrh.w	r3, [r3, #106]	; 0x6a
 8004b8a:	85bb      	strh	r3, [r7, #44]	; 0x2c
        }
      }

      /* Timeout management */
      if ((((HAL_GetTick() - tickstart) >=  Timeout) && (Timeout != HAL_MAX_DELAY)) || (Timeout == 0U))
 8004b8c:	f7fc fdd4 	bl	8001738 <HAL_GetTick>
 8004b90:	4602      	mov	r2, r0
 8004b92:	69fb      	ldr	r3, [r7, #28]
 8004b94:	1ad3      	subs	r3, r2, r3
 8004b96:	6bba      	ldr	r2, [r7, #56]	; 0x38
 8004b98:	429a      	cmp	r2, r3
 8004b9a:	d803      	bhi.n	8004ba4 <HAL_SPI_TransmitReceive+0x358>
 8004b9c:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8004b9e:	f1b3 3fff 	cmp.w	r3, #4294967295
 8004ba2:	d102      	bne.n	8004baa <HAL_SPI_TransmitReceive+0x35e>
 8004ba4:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8004ba6:	2b00      	cmp	r3, #0
 8004ba8:	d114      	bne.n	8004bd4 <HAL_SPI_TransmitReceive+0x388>
      {
        /* Call standard close procedure with error check */
        SPI_CloseTransfer(hspi);
 8004baa:	68f8      	ldr	r0, [r7, #12]
 8004bac:	f000 f93a 	bl	8004e24 <SPI_CloseTransfer>

        /* Unlock the process */
        __HAL_UNLOCK(hspi);
 8004bb0:	68fb      	ldr	r3, [r7, #12]
 8004bb2:	2200      	movs	r2, #0
 8004bb4:	f883 2080 	strb.w	r2, [r3, #128]	; 0x80

        SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_TIMEOUT);
 8004bb8:	68fb      	ldr	r3, [r7, #12]
 8004bba:	f8d3 3084 	ldr.w	r3, [r3, #132]	; 0x84
 8004bbe:	f443 7280 	orr.w	r2, r3, #256	; 0x100
 8004bc2:	68fb      	ldr	r3, [r7, #12]
 8004bc4:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84
        hspi->State = HAL_SPI_STATE_READY;
 8004bc8:	68fb      	ldr	r3, [r7, #12]
 8004bca:	2201      	movs	r2, #1
 8004bcc:	f883 2081 	strb.w	r2, [r3, #129]	; 0x81
        return HAL_TIMEOUT;
 8004bd0:	2303      	movs	r3, #3
 8004bd2:	e123      	b.n	8004e1c <HAL_SPI_TransmitReceive+0x5d0>
    while ((initial_TxXferCount > 0UL) || (initial_RxXferCount > 0UL))
 8004bd4:	8dfb      	ldrh	r3, [r7, #46]	; 0x2e
 8004bd6:	2b00      	cmp	r3, #0
 8004bd8:	f47f af52 	bne.w	8004a80 <HAL_SPI_TransmitReceive+0x234>
 8004bdc:	8dbb      	ldrh	r3, [r7, #44]	; 0x2c
 8004bde:	2b00      	cmp	r3, #0
 8004be0:	f47f af4e 	bne.w	8004a80 <HAL_SPI_TransmitReceive+0x234>
 8004be4:	e0f3      	b.n	8004dce <HAL_SPI_TransmitReceive+0x582>
  else
  {
    while ((initial_TxXferCount > 0UL) || (initial_RxXferCount > 0UL))
    {
      /* check TXP flag */
      if ((__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_TXP)) && (initial_TxXferCount > 0UL))
 8004be6:	68fb      	ldr	r3, [r7, #12]
 8004be8:	681b      	ldr	r3, [r3, #0]
 8004bea:	695b      	ldr	r3, [r3, #20]
 8004bec:	f003 0302 	and.w	r3, r3, #2
 8004bf0:	2b02      	cmp	r3, #2
 8004bf2:	d15a      	bne.n	8004caa <HAL_SPI_TransmitReceive+0x45e>
 8004bf4:	8dfb      	ldrh	r3, [r7, #46]	; 0x2e
 8004bf6:	2b00      	cmp	r3, #0
 8004bf8:	d057      	beq.n	8004caa <HAL_SPI_TransmitReceive+0x45e>
      {
        if ((initial_TxXferCount > 3UL) && (hspi->Init.FifoThreshold > SPI_FIFO_THRESHOLD_03DATA))
 8004bfa:	8dfb      	ldrh	r3, [r7, #46]	; 0x2e
 8004bfc:	2b03      	cmp	r3, #3
 8004bfe:	d91c      	bls.n	8004c3a <HAL_SPI_TransmitReceive+0x3ee>
 8004c00:	68fb      	ldr	r3, [r7, #12]
 8004c02:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 8004c04:	2b40      	cmp	r3, #64	; 0x40
 8004c06:	d918      	bls.n	8004c3a <HAL_SPI_TransmitReceive+0x3ee>
        {
          *((__IO uint32_t *)&hspi->Instance->TXDR) = *((uint32_t *)hspi->pTxBuffPtr);
 8004c08:	68fb      	ldr	r3, [r7, #12]
 8004c0a:	6dda      	ldr	r2, [r3, #92]	; 0x5c
 8004c0c:	68fb      	ldr	r3, [r7, #12]
 8004c0e:	681b      	ldr	r3, [r3, #0]
 8004c10:	6812      	ldr	r2, [r2, #0]
 8004c12:	621a      	str	r2, [r3, #32]
          hspi->pTxBuffPtr += sizeof(uint32_t);
 8004c14:	68fb      	ldr	r3, [r7, #12]
 8004c16:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
 8004c18:	1d1a      	adds	r2, r3, #4
 8004c1a:	68fb      	ldr	r3, [r7, #12]
 8004c1c:	65da      	str	r2, [r3, #92]	; 0x5c
          hspi->TxXferCount -= (uint16_t)4UL;
 8004c1e:	68fb      	ldr	r3, [r7, #12]
 8004c20:	f8b3 3062 	ldrh.w	r3, [r3, #98]	; 0x62
 8004c24:	b29b      	uxth	r3, r3
 8004c26:	3b04      	subs	r3, #4
 8004c28:	b29a      	uxth	r2, r3
 8004c2a:	68fb      	ldr	r3, [r7, #12]
 8004c2c:	f8a3 2062 	strh.w	r2, [r3, #98]	; 0x62
          initial_TxXferCount = hspi->TxXferCount;
 8004c30:	68fb      	ldr	r3, [r7, #12]
 8004c32:	f8b3 3062 	ldrh.w	r3, [r3, #98]	; 0x62
 8004c36:	85fb      	strh	r3, [r7, #46]	; 0x2e
 8004c38:	e037      	b.n	8004caa <HAL_SPI_TransmitReceive+0x45e>
        }
        else if ((initial_TxXferCount > 1UL) && (hspi->Init.FifoThreshold > SPI_FIFO_THRESHOLD_01DATA))
 8004c3a:	8dfb      	ldrh	r3, [r7, #46]	; 0x2e
 8004c3c:	2b01      	cmp	r3, #1
 8004c3e:	d91b      	bls.n	8004c78 <HAL_SPI_TransmitReceive+0x42c>
 8004c40:	68fb      	ldr	r3, [r7, #12]
 8004c42:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 8004c44:	2b00      	cmp	r3, #0
 8004c46:	d017      	beq.n	8004c78 <HAL_SPI_TransmitReceive+0x42c>
        {
#if defined (__GNUC__)
          *ptxdr_16bits = *((uint16_t *)hspi->pTxBuffPtr);
 8004c48:	68fb      	ldr	r3, [r7, #12]
 8004c4a:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
 8004c4c:	881a      	ldrh	r2, [r3, #0]
 8004c4e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8004c50:	801a      	strh	r2, [r3, #0]
#else
          *((__IO uint16_t *)&hspi->Instance->TXDR) = *((uint16_t *)hspi->pTxBuffPtr);
#endif /* __GNUC__ */
          hspi->pTxBuffPtr += sizeof(uint16_t);
 8004c52:	68fb      	ldr	r3, [r7, #12]
 8004c54:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
 8004c56:	1c9a      	adds	r2, r3, #2
 8004c58:	68fb      	ldr	r3, [r7, #12]
 8004c5a:	65da      	str	r2, [r3, #92]	; 0x5c
          hspi->TxXferCount -= (uint16_t)2UL;
 8004c5c:	68fb      	ldr	r3, [r7, #12]
 8004c5e:	f8b3 3062 	ldrh.w	r3, [r3, #98]	; 0x62
 8004c62:	b29b      	uxth	r3, r3
 8004c64:	3b02      	subs	r3, #2
 8004c66:	b29a      	uxth	r2, r3
 8004c68:	68fb      	ldr	r3, [r7, #12]
 8004c6a:	f8a3 2062 	strh.w	r2, [r3, #98]	; 0x62
          initial_TxXferCount = hspi->TxXferCount;
 8004c6e:	68fb      	ldr	r3, [r7, #12]
 8004c70:	f8b3 3062 	ldrh.w	r3, [r3, #98]	; 0x62
 8004c74:	85fb      	strh	r3, [r7, #46]	; 0x2e
 8004c76:	e018      	b.n	8004caa <HAL_SPI_TransmitReceive+0x45e>
        }
        else
        {
          *((__IO uint8_t *)&hspi->Instance->TXDR) = *((uint8_t *)hspi->pTxBuffPtr);
 8004c78:	68fb      	ldr	r3, [r7, #12]
 8004c7a:	6dda      	ldr	r2, [r3, #92]	; 0x5c
 8004c7c:	68fb      	ldr	r3, [r7, #12]
 8004c7e:	681b      	ldr	r3, [r3, #0]
 8004c80:	3320      	adds	r3, #32
 8004c82:	7812      	ldrb	r2, [r2, #0]
 8004c84:	701a      	strb	r2, [r3, #0]
          hspi->pTxBuffPtr += sizeof(uint8_t);
 8004c86:	68fb      	ldr	r3, [r7, #12]
 8004c88:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
 8004c8a:	1c5a      	adds	r2, r3, #1
 8004c8c:	68fb      	ldr	r3, [r7, #12]
 8004c8e:	65da      	str	r2, [r3, #92]	; 0x5c
          hspi->TxXferCount--;
 8004c90:	68fb      	ldr	r3, [r7, #12]
 8004c92:	f8b3 3062 	ldrh.w	r3, [r3, #98]	; 0x62
 8004c96:	b29b      	uxth	r3, r3
 8004c98:	3b01      	subs	r3, #1
 8004c9a:	b29a      	uxth	r2, r3
 8004c9c:	68fb      	ldr	r3, [r7, #12]
 8004c9e:	f8a3 2062 	strh.w	r2, [r3, #98]	; 0x62
          initial_TxXferCount = hspi->TxXferCount;
 8004ca2:	68fb      	ldr	r3, [r7, #12]
 8004ca4:	f8b3 3062 	ldrh.w	r3, [r3, #98]	; 0x62
 8004ca8:	85fb      	strh	r3, [r7, #46]	; 0x2e
        }
      }

      /* Wait until RXWNE/FRLVL flag is reset */
      if (((hspi->Instance->SR & (SPI_FLAG_RXWNE | SPI_FLAG_FRLVL)) != 0UL) && (initial_RxXferCount > 0UL))
 8004caa:	68fb      	ldr	r3, [r7, #12]
 8004cac:	681b      	ldr	r3, [r3, #0]
 8004cae:	695b      	ldr	r3, [r3, #20]
 8004cb0:	f403 4360 	and.w	r3, r3, #57344	; 0xe000
 8004cb4:	2b00      	cmp	r3, #0
 8004cb6:	d05e      	beq.n	8004d76 <HAL_SPI_TransmitReceive+0x52a>
 8004cb8:	8dbb      	ldrh	r3, [r7, #44]	; 0x2c
 8004cba:	2b00      	cmp	r3, #0
 8004cbc:	d05b      	beq.n	8004d76 <HAL_SPI_TransmitReceive+0x52a>
      {
        if ((hspi->Instance->SR & SPI_FLAG_RXWNE) != 0UL)
 8004cbe:	68fb      	ldr	r3, [r7, #12]
 8004cc0:	681b      	ldr	r3, [r3, #0]
 8004cc2:	695b      	ldr	r3, [r3, #20]
 8004cc4:	f403 4300 	and.w	r3, r3, #32768	; 0x8000
 8004cc8:	2b00      	cmp	r3, #0
 8004cca:	d018      	beq.n	8004cfe <HAL_SPI_TransmitReceive+0x4b2>
        {
          *((uint32_t *)hspi->pRxBuffPtr) = *((__IO uint32_t *)&hspi->Instance->RXDR);
 8004ccc:	68fb      	ldr	r3, [r7, #12]
 8004cce:	681a      	ldr	r2, [r3, #0]
 8004cd0:	68fb      	ldr	r3, [r7, #12]
 8004cd2:	6e5b      	ldr	r3, [r3, #100]	; 0x64
 8004cd4:	6b12      	ldr	r2, [r2, #48]	; 0x30
 8004cd6:	601a      	str	r2, [r3, #0]
          hspi->pRxBuffPtr += sizeof(uint32_t);
 8004cd8:	68fb      	ldr	r3, [r7, #12]
 8004cda:	6e5b      	ldr	r3, [r3, #100]	; 0x64
 8004cdc:	1d1a      	adds	r2, r3, #4
 8004cde:	68fb      	ldr	r3, [r7, #12]
 8004ce0:	665a      	str	r2, [r3, #100]	; 0x64
          hspi->RxXferCount -= (uint16_t)4UL;
 8004ce2:	68fb      	ldr	r3, [r7, #12]
 8004ce4:	f8b3 306a 	ldrh.w	r3, [r3, #106]	; 0x6a
 8004ce8:	b29b      	uxth	r3, r3
 8004cea:	3b04      	subs	r3, #4
 8004cec:	b29a      	uxth	r2, r3
 8004cee:	68fb      	ldr	r3, [r7, #12]
 8004cf0:	f8a3 206a 	strh.w	r2, [r3, #106]	; 0x6a
          initial_RxXferCount = hspi->RxXferCount;
 8004cf4:	68fb      	ldr	r3, [r7, #12]
 8004cf6:	f8b3 306a 	ldrh.w	r3, [r3, #106]	; 0x6a
 8004cfa:	85bb      	strh	r3, [r7, #44]	; 0x2c
 8004cfc:	e03b      	b.n	8004d76 <HAL_SPI_TransmitReceive+0x52a>
        }
        else if ((hspi->Instance->SR & SPI_FLAG_FRLVL) > SPI_RX_FIFO_1PACKET)
 8004cfe:	68fb      	ldr	r3, [r7, #12]
 8004d00:	681b      	ldr	r3, [r3, #0]
 8004d02:	695b      	ldr	r3, [r3, #20]
 8004d04:	f403 43c0 	and.w	r3, r3, #24576	; 0x6000
 8004d08:	f5b3 5f00 	cmp.w	r3, #8192	; 0x2000
 8004d0c:	d918      	bls.n	8004d40 <HAL_SPI_TransmitReceive+0x4f4>
        {
#if defined (__GNUC__)
          *((uint16_t *)hspi->pRxBuffPtr) = *prxdr_16bits;
 8004d0e:	68fb      	ldr	r3, [r7, #12]
 8004d10:	6e5b      	ldr	r3, [r3, #100]	; 0x64
 8004d12:	6a3a      	ldr	r2, [r7, #32]
 8004d14:	8812      	ldrh	r2, [r2, #0]
 8004d16:	b292      	uxth	r2, r2
 8004d18:	801a      	strh	r2, [r3, #0]
#else
          *((uint16_t *)hspi->pRxBuffPtr) = *((__IO uint16_t *)&hspi->Instance->RXDR);
#endif /* __GNUC__ */
          hspi->pRxBuffPtr += sizeof(uint16_t);
 8004d1a:	68fb      	ldr	r3, [r7, #12]
 8004d1c:	6e5b      	ldr	r3, [r3, #100]	; 0x64
 8004d1e:	1c9a      	adds	r2, r3, #2
 8004d20:	68fb      	ldr	r3, [r7, #12]
 8004d22:	665a      	str	r2, [r3, #100]	; 0x64
          hspi->RxXferCount -= (uint16_t)2UL;
 8004d24:	68fb      	ldr	r3, [r7, #12]
 8004d26:	f8b3 306a 	ldrh.w	r3, [r3, #106]	; 0x6a
 8004d2a:	b29b      	uxth	r3, r3
 8004d2c:	3b02      	subs	r3, #2
 8004d2e:	b29a      	uxth	r2, r3
 8004d30:	68fb      	ldr	r3, [r7, #12]
 8004d32:	f8a3 206a 	strh.w	r2, [r3, #106]	; 0x6a
          initial_RxXferCount = hspi->RxXferCount;
 8004d36:	68fb      	ldr	r3, [r7, #12]
 8004d38:	f8b3 306a 	ldrh.w	r3, [r3, #106]	; 0x6a
 8004d3c:	85bb      	strh	r3, [r7, #44]	; 0x2c
 8004d3e:	e01a      	b.n	8004d76 <HAL_SPI_TransmitReceive+0x52a>
        }
        else
        {
          *((uint8_t *)hspi->pRxBuffPtr) = *((__IO uint8_t *)&hspi->Instance->RXDR);
 8004d40:	68fb      	ldr	r3, [r7, #12]
 8004d42:	681b      	ldr	r3, [r3, #0]
 8004d44:	f103 0230 	add.w	r2, r3, #48	; 0x30
 8004d48:	68fb      	ldr	r3, [r7, #12]
 8004d4a:	6e5b      	ldr	r3, [r3, #100]	; 0x64
 8004d4c:	7812      	ldrb	r2, [r2, #0]
 8004d4e:	b2d2      	uxtb	r2, r2
 8004d50:	701a      	strb	r2, [r3, #0]
          hspi->pRxBuffPtr += sizeof(uint8_t);
 8004d52:	68fb      	ldr	r3, [r7, #12]
 8004d54:	6e5b      	ldr	r3, [r3, #100]	; 0x64
 8004d56:	1c5a      	adds	r2, r3, #1
 8004d58:	68fb      	ldr	r3, [r7, #12]
 8004d5a:	665a      	str	r2, [r3, #100]	; 0x64
          hspi->RxXferCount--;
 8004d5c:	68fb      	ldr	r3, [r7, #12]
 8004d5e:	f8b3 306a 	ldrh.w	r3, [r3, #106]	; 0x6a
 8004d62:	b29b      	uxth	r3, r3
 8004d64:	3b01      	subs	r3, #1
 8004d66:	b29a      	uxth	r2, r3
 8004d68:	68fb      	ldr	r3, [r7, #12]
 8004d6a:	f8a3 206a 	strh.w	r2, [r3, #106]	; 0x6a
          initial_RxXferCount = hspi->RxXferCount;
 8004d6e:	68fb      	ldr	r3, [r7, #12]
 8004d70:	f8b3 306a 	ldrh.w	r3, [r3, #106]	; 0x6a
 8004d74:	85bb      	strh	r3, [r7, #44]	; 0x2c
        }
      }

      /* Timeout management */
      if ((((HAL_GetTick() - tickstart) >=  Timeout) && (Timeout != HAL_MAX_DELAY)) || (Timeout == 0U))
 8004d76:	f7fc fcdf 	bl	8001738 <HAL_GetTick>
 8004d7a:	4602      	mov	r2, r0
 8004d7c:	69fb      	ldr	r3, [r7, #28]
 8004d7e:	1ad3      	subs	r3, r2, r3
 8004d80:	6bba      	ldr	r2, [r7, #56]	; 0x38
 8004d82:	429a      	cmp	r2, r3
 8004d84:	d803      	bhi.n	8004d8e <HAL_SPI_TransmitReceive+0x542>
 8004d86:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8004d88:	f1b3 3fff 	cmp.w	r3, #4294967295
 8004d8c:	d102      	bne.n	8004d94 <HAL_SPI_TransmitReceive+0x548>
 8004d8e:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8004d90:	2b00      	cmp	r3, #0
 8004d92:	d114      	bne.n	8004dbe <HAL_SPI_TransmitReceive+0x572>
      {
        /* Call standard close procedure with error check */
        SPI_CloseTransfer(hspi);
 8004d94:	68f8      	ldr	r0, [r7, #12]
 8004d96:	f000 f845 	bl	8004e24 <SPI_CloseTransfer>

        /* Unlock the process */
        __HAL_UNLOCK(hspi);
 8004d9a:	68fb      	ldr	r3, [r7, #12]
 8004d9c:	2200      	movs	r2, #0
 8004d9e:	f883 2080 	strb.w	r2, [r3, #128]	; 0x80

        SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_TIMEOUT);
 8004da2:	68fb      	ldr	r3, [r7, #12]
 8004da4:	f8d3 3084 	ldr.w	r3, [r3, #132]	; 0x84
 8004da8:	f443 7280 	orr.w	r2, r3, #256	; 0x100
 8004dac:	68fb      	ldr	r3, [r7, #12]
 8004dae:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84
        hspi->State = HAL_SPI_STATE_READY;
 8004db2:	68fb      	ldr	r3, [r7, #12]
 8004db4:	2201      	movs	r2, #1
 8004db6:	f883 2081 	strb.w	r2, [r3, #129]	; 0x81
        return HAL_TIMEOUT;
 8004dba:	2303      	movs	r3, #3
 8004dbc:	e02e      	b.n	8004e1c <HAL_SPI_TransmitReceive+0x5d0>
    while ((initial_TxXferCount > 0UL) || (initial_RxXferCount > 0UL))
 8004dbe:	8dfb      	ldrh	r3, [r7, #46]	; 0x2e
 8004dc0:	2b00      	cmp	r3, #0
 8004dc2:	f47f af10 	bne.w	8004be6 <HAL_SPI_TransmitReceive+0x39a>
 8004dc6:	8dbb      	ldrh	r3, [r7, #44]	; 0x2c
 8004dc8:	2b00      	cmp	r3, #0
 8004dca:	f47f af0c 	bne.w	8004be6 <HAL_SPI_TransmitReceive+0x39a>
      }
    }
  }

  /* Wait for Tx/Rx (and CRC) data to be sent/received */
  if (SPI_WaitOnFlagUntilTimeout(hspi, SPI_FLAG_EOT, RESET, tickstart, Timeout) != HAL_OK)
 8004dce:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8004dd0:	9300      	str	r3, [sp, #0]
 8004dd2:	69fb      	ldr	r3, [r7, #28]
 8004dd4:	2200      	movs	r2, #0
 8004dd6:	2108      	movs	r1, #8
 8004dd8:	68f8      	ldr	r0, [r7, #12]
 8004dda:	f000 f8c3 	bl	8004f64 <SPI_WaitOnFlagUntilTimeout>
 8004dde:	4603      	mov	r3, r0
 8004de0:	2b00      	cmp	r3, #0
 8004de2:	d007      	beq.n	8004df4 <HAL_SPI_TransmitReceive+0x5a8>
  {
    SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_FLAG);
 8004de4:	68fb      	ldr	r3, [r7, #12]
 8004de6:	f8d3 3084 	ldr.w	r3, [r3, #132]	; 0x84
 8004dea:	f043 0220 	orr.w	r2, r3, #32
 8004dee:	68fb      	ldr	r3, [r7, #12]
 8004df0:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84
  }

  /* Call standard close procedure with error check */
  SPI_CloseTransfer(hspi);
 8004df4:	68f8      	ldr	r0, [r7, #12]
 8004df6:	f000 f815 	bl	8004e24 <SPI_CloseTransfer>

  /* Unlock the process */
  __HAL_UNLOCK(hspi);
 8004dfa:	68fb      	ldr	r3, [r7, #12]
 8004dfc:	2200      	movs	r2, #0
 8004dfe:	f883 2080 	strb.w	r2, [r3, #128]	; 0x80

  hspi->State = HAL_SPI_STATE_READY;
 8004e02:	68fb      	ldr	r3, [r7, #12]
 8004e04:	2201      	movs	r2, #1
 8004e06:	f883 2081 	strb.w	r2, [r3, #129]	; 0x81

  if (hspi->ErrorCode != HAL_SPI_ERROR_NONE)
 8004e0a:	68fb      	ldr	r3, [r7, #12]
 8004e0c:	f8d3 3084 	ldr.w	r3, [r3, #132]	; 0x84
 8004e10:	2b00      	cmp	r3, #0
 8004e12:	d001      	beq.n	8004e18 <HAL_SPI_TransmitReceive+0x5cc>
  {
    return HAL_ERROR;
 8004e14:	2301      	movs	r3, #1
 8004e16:	e001      	b.n	8004e1c <HAL_SPI_TransmitReceive+0x5d0>
  }
  return errorcode;
 8004e18:	f897 302b 	ldrb.w	r3, [r7, #43]	; 0x2b
}
 8004e1c:	4618      	mov	r0, r3
 8004e1e:	3730      	adds	r7, #48	; 0x30
 8004e20:	46bd      	mov	sp, r7
 8004e22:	bd80      	pop	{r7, pc}

08004e24 <SPI_CloseTransfer>:
  *               the configuration information for SPI module.
  * @retval HAL_ERROR: if any error detected
  *         HAL_OK: if nothing detected
  */
static void SPI_CloseTransfer(SPI_HandleTypeDef *hspi)
{
 8004e24:	b480      	push	{r7}
 8004e26:	b085      	sub	sp, #20
 8004e28:	af00      	add	r7, sp, #0
 8004e2a:	6078      	str	r0, [r7, #4]
  uint32_t itflag = hspi->Instance->SR;
 8004e2c:	687b      	ldr	r3, [r7, #4]
 8004e2e:	681b      	ldr	r3, [r3, #0]
 8004e30:	695b      	ldr	r3, [r3, #20]
 8004e32:	60fb      	str	r3, [r7, #12]

  __HAL_SPI_CLEAR_EOTFLAG(hspi);
 8004e34:	687b      	ldr	r3, [r7, #4]
 8004e36:	681b      	ldr	r3, [r3, #0]
 8004e38:	699a      	ldr	r2, [r3, #24]
 8004e3a:	687b      	ldr	r3, [r7, #4]
 8004e3c:	681b      	ldr	r3, [r3, #0]
 8004e3e:	f042 0208 	orr.w	r2, r2, #8
 8004e42:	619a      	str	r2, [r3, #24]
  __HAL_SPI_CLEAR_TXTFFLAG(hspi);
 8004e44:	687b      	ldr	r3, [r7, #4]
 8004e46:	681b      	ldr	r3, [r3, #0]
 8004e48:	699a      	ldr	r2, [r3, #24]
 8004e4a:	687b      	ldr	r3, [r7, #4]
 8004e4c:	681b      	ldr	r3, [r3, #0]
 8004e4e:	f042 0210 	orr.w	r2, r2, #16
 8004e52:	619a      	str	r2, [r3, #24]

  /* Disable SPI peripheral */
  __HAL_SPI_DISABLE(hspi);
 8004e54:	687b      	ldr	r3, [r7, #4]
 8004e56:	681b      	ldr	r3, [r3, #0]
 8004e58:	681a      	ldr	r2, [r3, #0]
 8004e5a:	687b      	ldr	r3, [r7, #4]
 8004e5c:	681b      	ldr	r3, [r3, #0]
 8004e5e:	f022 0201 	bic.w	r2, r2, #1
 8004e62:	601a      	str	r2, [r3, #0]

  /* Disable ITs */
  __HAL_SPI_DISABLE_IT(hspi, (SPI_IT_EOT | SPI_IT_TXP | SPI_IT_RXP | SPI_IT_DXP | SPI_IT_UDR | SPI_IT_OVR | \
 8004e64:	687b      	ldr	r3, [r7, #4]
 8004e66:	681b      	ldr	r3, [r3, #0]
 8004e68:	6919      	ldr	r1, [r3, #16]
 8004e6a:	687b      	ldr	r3, [r7, #4]
 8004e6c:	681a      	ldr	r2, [r3, #0]
 8004e6e:	4b3c      	ldr	r3, [pc, #240]	; (8004f60 <SPI_CloseTransfer+0x13c>)
 8004e70:	400b      	ands	r3, r1
 8004e72:	6113      	str	r3, [r2, #16]
                              SPI_IT_FRE | SPI_IT_MODF));

  /* Disable Tx DMA Request */
  CLEAR_BIT(hspi->Instance->CFG1, SPI_CFG1_TXDMAEN | SPI_CFG1_RXDMAEN);
 8004e74:	687b      	ldr	r3, [r7, #4]
 8004e76:	681b      	ldr	r3, [r3, #0]
 8004e78:	689a      	ldr	r2, [r3, #8]
 8004e7a:	687b      	ldr	r3, [r7, #4]
 8004e7c:	681b      	ldr	r3, [r3, #0]
 8004e7e:	f422 4240 	bic.w	r2, r2, #49152	; 0xc000
 8004e82:	609a      	str	r2, [r3, #8]

  /* Report UnderRun error for non RX Only communication */
  if (hspi->State != HAL_SPI_STATE_BUSY_RX)
 8004e84:	687b      	ldr	r3, [r7, #4]
 8004e86:	f893 3081 	ldrb.w	r3, [r3, #129]	; 0x81
 8004e8a:	b2db      	uxtb	r3, r3
 8004e8c:	2b04      	cmp	r3, #4
 8004e8e:	d014      	beq.n	8004eba <SPI_CloseTransfer+0x96>
  {
    if ((itflag & SPI_FLAG_UDR) != 0UL)
 8004e90:	68fb      	ldr	r3, [r7, #12]
 8004e92:	f003 0320 	and.w	r3, r3, #32
 8004e96:	2b00      	cmp	r3, #0
 8004e98:	d00f      	beq.n	8004eba <SPI_CloseTransfer+0x96>
    {
      SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_UDR);
 8004e9a:	687b      	ldr	r3, [r7, #4]
 8004e9c:	f8d3 3084 	ldr.w	r3, [r3, #132]	; 0x84
 8004ea0:	f043 0280 	orr.w	r2, r3, #128	; 0x80
 8004ea4:	687b      	ldr	r3, [r7, #4]
 8004ea6:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84
      __HAL_SPI_CLEAR_UDRFLAG(hspi);
 8004eaa:	687b      	ldr	r3, [r7, #4]
 8004eac:	681b      	ldr	r3, [r3, #0]
 8004eae:	699a      	ldr	r2, [r3, #24]
 8004eb0:	687b      	ldr	r3, [r7, #4]
 8004eb2:	681b      	ldr	r3, [r3, #0]
 8004eb4:	f042 0220 	orr.w	r2, r2, #32
 8004eb8:	619a      	str	r2, [r3, #24]
    }
  }

  /* Report OverRun error for non TX Only communication */
  if (hspi->State != HAL_SPI_STATE_BUSY_TX)
 8004eba:	687b      	ldr	r3, [r7, #4]
 8004ebc:	f893 3081 	ldrb.w	r3, [r3, #129]	; 0x81
 8004ec0:	b2db      	uxtb	r3, r3
 8004ec2:	2b03      	cmp	r3, #3
 8004ec4:	d014      	beq.n	8004ef0 <SPI_CloseTransfer+0xcc>
  {
    if ((itflag & SPI_FLAG_OVR) != 0UL)
 8004ec6:	68fb      	ldr	r3, [r7, #12]
 8004ec8:	f003 0340 	and.w	r3, r3, #64	; 0x40
 8004ecc:	2b00      	cmp	r3, #0
 8004ece:	d00f      	beq.n	8004ef0 <SPI_CloseTransfer+0xcc>
    {
      SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_OVR);
 8004ed0:	687b      	ldr	r3, [r7, #4]
 8004ed2:	f8d3 3084 	ldr.w	r3, [r3, #132]	; 0x84
 8004ed6:	f043 0204 	orr.w	r2, r3, #4
 8004eda:	687b      	ldr	r3, [r7, #4]
 8004edc:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84
      __HAL_SPI_CLEAR_OVRFLAG(hspi);
 8004ee0:	687b      	ldr	r3, [r7, #4]
 8004ee2:	681b      	ldr	r3, [r3, #0]
 8004ee4:	699a      	ldr	r2, [r3, #24]
 8004ee6:	687b      	ldr	r3, [r7, #4]
 8004ee8:	681b      	ldr	r3, [r3, #0]
 8004eea:	f042 0240 	orr.w	r2, r2, #64	; 0x40
 8004eee:	619a      	str	r2, [r3, #24]
    }
#endif /* USE_SPI_CRC */
  }

  /* SPI Mode Fault error interrupt occurred -------------------------------*/
  if ((itflag & SPI_FLAG_MODF) != 0UL)
 8004ef0:	68fb      	ldr	r3, [r7, #12]
 8004ef2:	f403 7300 	and.w	r3, r3, #512	; 0x200
 8004ef6:	2b00      	cmp	r3, #0
 8004ef8:	d00f      	beq.n	8004f1a <SPI_CloseTransfer+0xf6>
  {
    SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_MODF);
 8004efa:	687b      	ldr	r3, [r7, #4]
 8004efc:	f8d3 3084 	ldr.w	r3, [r3, #132]	; 0x84
 8004f00:	f043 0201 	orr.w	r2, r3, #1
 8004f04:	687b      	ldr	r3, [r7, #4]
 8004f06:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84
    __HAL_SPI_CLEAR_MODFFLAG(hspi);
 8004f0a:	687b      	ldr	r3, [r7, #4]
 8004f0c:	681b      	ldr	r3, [r3, #0]
 8004f0e:	699a      	ldr	r2, [r3, #24]
 8004f10:	687b      	ldr	r3, [r7, #4]
 8004f12:	681b      	ldr	r3, [r3, #0]
 8004f14:	f442 7200 	orr.w	r2, r2, #512	; 0x200
 8004f18:	619a      	str	r2, [r3, #24]
  }

  /* SPI Frame error interrupt occurred ------------------------------------*/
  if ((itflag & SPI_FLAG_FRE) != 0UL)
 8004f1a:	68fb      	ldr	r3, [r7, #12]
 8004f1c:	f403 7380 	and.w	r3, r3, #256	; 0x100
 8004f20:	2b00      	cmp	r3, #0
 8004f22:	d00f      	beq.n	8004f44 <SPI_CloseTransfer+0x120>
  {
    SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_FRE);
 8004f24:	687b      	ldr	r3, [r7, #4]
 8004f26:	f8d3 3084 	ldr.w	r3, [r3, #132]	; 0x84
 8004f2a:	f043 0208 	orr.w	r2, r3, #8
 8004f2e:	687b      	ldr	r3, [r7, #4]
 8004f30:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84
    __HAL_SPI_CLEAR_FREFLAG(hspi);
 8004f34:	687b      	ldr	r3, [r7, #4]
 8004f36:	681b      	ldr	r3, [r3, #0]
 8004f38:	699a      	ldr	r2, [r3, #24]
 8004f3a:	687b      	ldr	r3, [r7, #4]
 8004f3c:	681b      	ldr	r3, [r3, #0]
 8004f3e:	f442 7280 	orr.w	r2, r2, #256	; 0x100
 8004f42:	619a      	str	r2, [r3, #24]
  }

  hspi->TxXferCount = (uint16_t)0UL;
 8004f44:	687b      	ldr	r3, [r7, #4]
 8004f46:	2200      	movs	r2, #0
 8004f48:	f8a3 2062 	strh.w	r2, [r3, #98]	; 0x62
  hspi->RxXferCount = (uint16_t)0UL;
 8004f4c:	687b      	ldr	r3, [r7, #4]
 8004f4e:	2200      	movs	r2, #0
 8004f50:	f8a3 206a 	strh.w	r2, [r3, #106]	; 0x6a
}
 8004f54:	bf00      	nop
 8004f56:	3714      	adds	r7, #20
 8004f58:	46bd      	mov	sp, r7
 8004f5a:	f85d 7b04 	ldr.w	r7, [sp], #4
 8004f5e:	4770      	bx	lr
 8004f60:	fffffc90 	.word	0xfffffc90

08004f64 <SPI_WaitOnFlagUntilTimeout>:
  * @param Tickstart: Tick start value
  * @retval HAL status
  */
static HAL_StatusTypeDef SPI_WaitOnFlagUntilTimeout(SPI_HandleTypeDef *hspi, uint32_t Flag, FlagStatus Status,
                                                    uint32_t Tickstart, uint32_t Timeout)
{
 8004f64:	b580      	push	{r7, lr}
 8004f66:	b084      	sub	sp, #16
 8004f68:	af00      	add	r7, sp, #0
 8004f6a:	60f8      	str	r0, [r7, #12]
 8004f6c:	60b9      	str	r1, [r7, #8]
 8004f6e:	603b      	str	r3, [r7, #0]
 8004f70:	4613      	mov	r3, r2
 8004f72:	71fb      	strb	r3, [r7, #7]
  /* Wait until flag is set */
  while ((__HAL_SPI_GET_FLAG(hspi, Flag) ? SET : RESET) == Status)
 8004f74:	e010      	b.n	8004f98 <SPI_WaitOnFlagUntilTimeout+0x34>
  {
    /* Check for the Timeout */
    if ((((HAL_GetTick() - Tickstart) >=  Timeout) && (Timeout != HAL_MAX_DELAY)) || (Timeout == 0U))
 8004f76:	f7fc fbdf 	bl	8001738 <HAL_GetTick>
 8004f7a:	4602      	mov	r2, r0
 8004f7c:	683b      	ldr	r3, [r7, #0]
 8004f7e:	1ad3      	subs	r3, r2, r3
 8004f80:	69ba      	ldr	r2, [r7, #24]
 8004f82:	429a      	cmp	r2, r3
 8004f84:	d803      	bhi.n	8004f8e <SPI_WaitOnFlagUntilTimeout+0x2a>
 8004f86:	69bb      	ldr	r3, [r7, #24]
 8004f88:	f1b3 3fff 	cmp.w	r3, #4294967295
 8004f8c:	d102      	bne.n	8004f94 <SPI_WaitOnFlagUntilTimeout+0x30>
 8004f8e:	69bb      	ldr	r3, [r7, #24]
 8004f90:	2b00      	cmp	r3, #0
 8004f92:	d101      	bne.n	8004f98 <SPI_WaitOnFlagUntilTimeout+0x34>
    {
      return HAL_TIMEOUT;
 8004f94:	2303      	movs	r3, #3
 8004f96:	e00f      	b.n	8004fb8 <SPI_WaitOnFlagUntilTimeout+0x54>
  while ((__HAL_SPI_GET_FLAG(hspi, Flag) ? SET : RESET) == Status)
 8004f98:	68fb      	ldr	r3, [r7, #12]
 8004f9a:	681b      	ldr	r3, [r3, #0]
 8004f9c:	695a      	ldr	r2, [r3, #20]
 8004f9e:	68bb      	ldr	r3, [r7, #8]
 8004fa0:	4013      	ands	r3, r2
 8004fa2:	68ba      	ldr	r2, [r7, #8]
 8004fa4:	429a      	cmp	r2, r3
 8004fa6:	bf0c      	ite	eq
 8004fa8:	2301      	moveq	r3, #1
 8004faa:	2300      	movne	r3, #0
 8004fac:	b2db      	uxtb	r3, r3
 8004fae:	461a      	mov	r2, r3
 8004fb0:	79fb      	ldrb	r3, [r7, #7]
 8004fb2:	429a      	cmp	r2, r3
 8004fb4:	d0df      	beq.n	8004f76 <SPI_WaitOnFlagUntilTimeout+0x12>
    }
  }
  return HAL_OK;
 8004fb6:	2300      	movs	r3, #0
}
 8004fb8:	4618      	mov	r0, r3
 8004fba:	3710      	adds	r7, #16
 8004fbc:	46bd      	mov	sp, r7
 8004fbe:	bd80      	pop	{r7, pc}

08004fc0 <SPI_GetPacketSize>:
  * @param  hspi: pointer to a SPI_HandleTypeDef structure that contains
  *               the configuration information for SPI module.
  * @retval Packet size occupied in the fifo
  */
static uint32_t SPI_GetPacketSize(SPI_HandleTypeDef *hspi)
{
 8004fc0:	b480      	push	{r7}
 8004fc2:	b085      	sub	sp, #20
 8004fc4:	af00      	add	r7, sp, #0
 8004fc6:	6078      	str	r0, [r7, #4]
  uint32_t fifo_threashold = (hspi->Init.FifoThreshold >> SPI_CFG1_FTHLV_Pos) + 1UL;
 8004fc8:	687b      	ldr	r3, [r7, #4]
 8004fca:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 8004fcc:	095b      	lsrs	r3, r3, #5
 8004fce:	3301      	adds	r3, #1
 8004fd0:	60fb      	str	r3, [r7, #12]
  uint32_t data_size       = (hspi->Init.DataSize      >> SPI_CFG1_DSIZE_Pos) + 1UL;
 8004fd2:	687b      	ldr	r3, [r7, #4]
 8004fd4:	68db      	ldr	r3, [r3, #12]
 8004fd6:	3301      	adds	r3, #1
 8004fd8:	60bb      	str	r3, [r7, #8]

  /* Convert data size to Byte */
  data_size = (data_size + 7UL) / 8UL;
 8004fda:	68bb      	ldr	r3, [r7, #8]
 8004fdc:	3307      	adds	r3, #7
 8004fde:	08db      	lsrs	r3, r3, #3
 8004fe0:	60bb      	str	r3, [r7, #8]

  return data_size * fifo_threashold;
 8004fe2:	68bb      	ldr	r3, [r7, #8]
 8004fe4:	68fa      	ldr	r2, [r7, #12]
 8004fe6:	fb02 f303 	mul.w	r3, r2, r3
}
 8004fea:	4618      	mov	r0, r3
 8004fec:	3714      	adds	r7, #20
 8004fee:	46bd      	mov	sp, r7
 8004ff0:	f85d 7b04 	ldr.w	r7, [sp], #4
 8004ff4:	4770      	bx	lr

08004ff6 <HAL_TIM_Base_Init>:
  *         Ex: call @ref HAL_TIM_Base_DeInit() before HAL_TIM_Base_Init()
  * @param  htim TIM Base handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_TIM_Base_Init(TIM_HandleTypeDef *htim)
{
 8004ff6:	b580      	push	{r7, lr}
 8004ff8:	b082      	sub	sp, #8
 8004ffa:	af00      	add	r7, sp, #0
 8004ffc:	6078      	str	r0, [r7, #4]
  /* Check the TIM handle allocation */
  if (htim == NULL)
 8004ffe:	687b      	ldr	r3, [r7, #4]
 8005000:	2b00      	cmp	r3, #0
 8005002:	d101      	bne.n	8005008 <HAL_TIM_Base_Init+0x12>
  {
    return HAL_ERROR;
 8005004:	2301      	movs	r3, #1
 8005006:	e049      	b.n	800509c <HAL_TIM_Base_Init+0xa6>
  assert_param(IS_TIM_INSTANCE(htim->Instance));
  assert_param(IS_TIM_COUNTER_MODE(htim->Init.CounterMode));
  assert_param(IS_TIM_CLOCKDIVISION_DIV(htim->Init.ClockDivision));
  assert_param(IS_TIM_AUTORELOAD_PRELOAD(htim->Init.AutoReloadPreload));

  if (htim->State == HAL_TIM_STATE_RESET)
 8005008:	687b      	ldr	r3, [r7, #4]
 800500a:	f893 303d 	ldrb.w	r3, [r3, #61]	; 0x3d
 800500e:	b2db      	uxtb	r3, r3
 8005010:	2b00      	cmp	r3, #0
 8005012:	d106      	bne.n	8005022 <HAL_TIM_Base_Init+0x2c>
  {
    /* Allocate lock resource and initialize it */
    htim->Lock = HAL_UNLOCKED;
 8005014:	687b      	ldr	r3, [r7, #4]
 8005016:	2200      	movs	r2, #0
 8005018:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c
    }
    /* Init the low level hardware : GPIO, CLOCK, NVIC */
    htim->Base_MspInitCallback(htim);
#else
    /* Init the low level hardware : GPIO, CLOCK, NVIC */
    HAL_TIM_Base_MspInit(htim);
 800501c:	6878      	ldr	r0, [r7, #4]
 800501e:	f000 f841 	bl	80050a4 <HAL_TIM_Base_MspInit>
#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
  }

  /* Set the TIM state */
  htim->State = HAL_TIM_STATE_BUSY;
 8005022:	687b      	ldr	r3, [r7, #4]
 8005024:	2202      	movs	r2, #2
 8005026:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d

  /* Set the Time Base configuration */
  TIM_Base_SetConfig(htim->Instance, &htim->Init);
 800502a:	687b      	ldr	r3, [r7, #4]
 800502c:	681a      	ldr	r2, [r3, #0]
 800502e:	687b      	ldr	r3, [r7, #4]
 8005030:	3304      	adds	r3, #4
 8005032:	4619      	mov	r1, r3
 8005034:	4610      	mov	r0, r2
 8005036:	f000 f9ff 	bl	8005438 <TIM_Base_SetConfig>

  /* Initialize the DMA burst operation state */
  htim->DMABurstState = HAL_DMA_BURST_STATE_READY;
 800503a:	687b      	ldr	r3, [r7, #4]
 800503c:	2201      	movs	r2, #1
 800503e:	f883 2048 	strb.w	r2, [r3, #72]	; 0x48

  /* Initialize the TIM channels state */
  TIM_CHANNEL_STATE_SET_ALL(htim, HAL_TIM_CHANNEL_STATE_READY);
 8005042:	687b      	ldr	r3, [r7, #4]
 8005044:	2201      	movs	r2, #1
 8005046:	f883 203e 	strb.w	r2, [r3, #62]	; 0x3e
 800504a:	687b      	ldr	r3, [r7, #4]
 800504c:	2201      	movs	r2, #1
 800504e:	f883 203f 	strb.w	r2, [r3, #63]	; 0x3f
 8005052:	687b      	ldr	r3, [r7, #4]
 8005054:	2201      	movs	r2, #1
 8005056:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
 800505a:	687b      	ldr	r3, [r7, #4]
 800505c:	2201      	movs	r2, #1
 800505e:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
 8005062:	687b      	ldr	r3, [r7, #4]
 8005064:	2201      	movs	r2, #1
 8005066:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42
 800506a:	687b      	ldr	r3, [r7, #4]
 800506c:	2201      	movs	r2, #1
 800506e:	f883 2043 	strb.w	r2, [r3, #67]	; 0x43
  TIM_CHANNEL_N_STATE_SET_ALL(htim, HAL_TIM_CHANNEL_STATE_READY);
 8005072:	687b      	ldr	r3, [r7, #4]
 8005074:	2201      	movs	r2, #1
 8005076:	f883 2044 	strb.w	r2, [r3, #68]	; 0x44
 800507a:	687b      	ldr	r3, [r7, #4]
 800507c:	2201      	movs	r2, #1
 800507e:	f883 2045 	strb.w	r2, [r3, #69]	; 0x45
 8005082:	687b      	ldr	r3, [r7, #4]
 8005084:	2201      	movs	r2, #1
 8005086:	f883 2046 	strb.w	r2, [r3, #70]	; 0x46
 800508a:	687b      	ldr	r3, [r7, #4]
 800508c:	2201      	movs	r2, #1
 800508e:	f883 2047 	strb.w	r2, [r3, #71]	; 0x47

  /* Initialize the TIM state*/
  htim->State = HAL_TIM_STATE_READY;
 8005092:	687b      	ldr	r3, [r7, #4]
 8005094:	2201      	movs	r2, #1
 8005096:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d

  return HAL_OK;
 800509a:	2300      	movs	r3, #0
}
 800509c:	4618      	mov	r0, r3
 800509e:	3708      	adds	r7, #8
 80050a0:	46bd      	mov	sp, r7
 80050a2:	bd80      	pop	{r7, pc}

080050a4 <HAL_TIM_Base_MspInit>:
  * @brief  Initializes the TIM Base MSP.
  * @param  htim TIM Base handle
  * @retval None
  */
__weak void HAL_TIM_Base_MspInit(TIM_HandleTypeDef *htim)
{
 80050a4:	b480      	push	{r7}
 80050a6:	b083      	sub	sp, #12
 80050a8:	af00      	add	r7, sp, #0
 80050aa:	6078      	str	r0, [r7, #4]
  UNUSED(htim);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_TIM_Base_MspInit could be implemented in the user file
   */
}
 80050ac:	bf00      	nop
 80050ae:	370c      	adds	r7, #12
 80050b0:	46bd      	mov	sp, r7
 80050b2:	f85d 7b04 	ldr.w	r7, [sp], #4
 80050b6:	4770      	bx	lr

080050b8 <HAL_TIM_Base_Start_IT>:
  * @brief  Starts the TIM Base generation in interrupt mode.
  * @param  htim TIM Base handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_TIM_Base_Start_IT(TIM_HandleTypeDef *htim)
{
 80050b8:	b480      	push	{r7}
 80050ba:	b085      	sub	sp, #20
 80050bc:	af00      	add	r7, sp, #0
 80050be:	6078      	str	r0, [r7, #4]

  /* Check the parameters */
  assert_param(IS_TIM_INSTANCE(htim->Instance));

  /* Check the TIM state */
  if (htim->State != HAL_TIM_STATE_READY)
 80050c0:	687b      	ldr	r3, [r7, #4]
 80050c2:	f893 303d 	ldrb.w	r3, [r3, #61]	; 0x3d
 80050c6:	b2db      	uxtb	r3, r3
 80050c8:	2b01      	cmp	r3, #1
 80050ca:	d001      	beq.n	80050d0 <HAL_TIM_Base_Start_IT+0x18>
  {
    return HAL_ERROR;
 80050cc:	2301      	movs	r3, #1
 80050ce:	e054      	b.n	800517a <HAL_TIM_Base_Start_IT+0xc2>
  }

  /* Set the TIM state */
  htim->State = HAL_TIM_STATE_BUSY;
 80050d0:	687b      	ldr	r3, [r7, #4]
 80050d2:	2202      	movs	r2, #2
 80050d4:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d

  /* Enable the TIM Update interrupt */
  __HAL_TIM_ENABLE_IT(htim, TIM_IT_UPDATE);
 80050d8:	687b      	ldr	r3, [r7, #4]
 80050da:	681b      	ldr	r3, [r3, #0]
 80050dc:	68da      	ldr	r2, [r3, #12]
 80050de:	687b      	ldr	r3, [r7, #4]
 80050e0:	681b      	ldr	r3, [r3, #0]
 80050e2:	f042 0201 	orr.w	r2, r2, #1
 80050e6:	60da      	str	r2, [r3, #12]

  /* Enable the Peripheral, except in trigger mode where enable is automatically done with trigger */
  if (IS_TIM_SLAVE_INSTANCE(htim->Instance))
 80050e8:	687b      	ldr	r3, [r7, #4]
 80050ea:	681b      	ldr	r3, [r3, #0]
 80050ec:	4a26      	ldr	r2, [pc, #152]	; (8005188 <HAL_TIM_Base_Start_IT+0xd0>)
 80050ee:	4293      	cmp	r3, r2
 80050f0:	d022      	beq.n	8005138 <HAL_TIM_Base_Start_IT+0x80>
 80050f2:	687b      	ldr	r3, [r7, #4]
 80050f4:	681b      	ldr	r3, [r3, #0]
 80050f6:	f1b3 4f80 	cmp.w	r3, #1073741824	; 0x40000000
 80050fa:	d01d      	beq.n	8005138 <HAL_TIM_Base_Start_IT+0x80>
 80050fc:	687b      	ldr	r3, [r7, #4]
 80050fe:	681b      	ldr	r3, [r3, #0]
 8005100:	4a22      	ldr	r2, [pc, #136]	; (800518c <HAL_TIM_Base_Start_IT+0xd4>)
 8005102:	4293      	cmp	r3, r2
 8005104:	d018      	beq.n	8005138 <HAL_TIM_Base_Start_IT+0x80>
 8005106:	687b      	ldr	r3, [r7, #4]
 8005108:	681b      	ldr	r3, [r3, #0]
 800510a:	4a21      	ldr	r2, [pc, #132]	; (8005190 <HAL_TIM_Base_Start_IT+0xd8>)
 800510c:	4293      	cmp	r3, r2
 800510e:	d013      	beq.n	8005138 <HAL_TIM_Base_Start_IT+0x80>
 8005110:	687b      	ldr	r3, [r7, #4]
 8005112:	681b      	ldr	r3, [r3, #0]
 8005114:	4a1f      	ldr	r2, [pc, #124]	; (8005194 <HAL_TIM_Base_Start_IT+0xdc>)
 8005116:	4293      	cmp	r3, r2
 8005118:	d00e      	beq.n	8005138 <HAL_TIM_Base_Start_IT+0x80>
 800511a:	687b      	ldr	r3, [r7, #4]
 800511c:	681b      	ldr	r3, [r3, #0]
 800511e:	4a1e      	ldr	r2, [pc, #120]	; (8005198 <HAL_TIM_Base_Start_IT+0xe0>)
 8005120:	4293      	cmp	r3, r2
 8005122:	d009      	beq.n	8005138 <HAL_TIM_Base_Start_IT+0x80>
 8005124:	687b      	ldr	r3, [r7, #4]
 8005126:	681b      	ldr	r3, [r3, #0]
 8005128:	4a1c      	ldr	r2, [pc, #112]	; (800519c <HAL_TIM_Base_Start_IT+0xe4>)
 800512a:	4293      	cmp	r3, r2
 800512c:	d004      	beq.n	8005138 <HAL_TIM_Base_Start_IT+0x80>
 800512e:	687b      	ldr	r3, [r7, #4]
 8005130:	681b      	ldr	r3, [r3, #0]
 8005132:	4a1b      	ldr	r2, [pc, #108]	; (80051a0 <HAL_TIM_Base_Start_IT+0xe8>)
 8005134:	4293      	cmp	r3, r2
 8005136:	d115      	bne.n	8005164 <HAL_TIM_Base_Start_IT+0xac>
  {
    tmpsmcr = htim->Instance->SMCR & TIM_SMCR_SMS;
 8005138:	687b      	ldr	r3, [r7, #4]
 800513a:	681b      	ldr	r3, [r3, #0]
 800513c:	689a      	ldr	r2, [r3, #8]
 800513e:	4b19      	ldr	r3, [pc, #100]	; (80051a4 <HAL_TIM_Base_Start_IT+0xec>)
 8005140:	4013      	ands	r3, r2
 8005142:	60fb      	str	r3, [r7, #12]
    if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))
 8005144:	68fb      	ldr	r3, [r7, #12]
 8005146:	2b06      	cmp	r3, #6
 8005148:	d015      	beq.n	8005176 <HAL_TIM_Base_Start_IT+0xbe>
 800514a:	68fb      	ldr	r3, [r7, #12]
 800514c:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
 8005150:	d011      	beq.n	8005176 <HAL_TIM_Base_Start_IT+0xbe>
    {
      __HAL_TIM_ENABLE(htim);
 8005152:	687b      	ldr	r3, [r7, #4]
 8005154:	681b      	ldr	r3, [r3, #0]
 8005156:	681a      	ldr	r2, [r3, #0]
 8005158:	687b      	ldr	r3, [r7, #4]
 800515a:	681b      	ldr	r3, [r3, #0]
 800515c:	f042 0201 	orr.w	r2, r2, #1
 8005160:	601a      	str	r2, [r3, #0]
    if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))
 8005162:	e008      	b.n	8005176 <HAL_TIM_Base_Start_IT+0xbe>
    }
  }
  else
  {
    __HAL_TIM_ENABLE(htim);
 8005164:	687b      	ldr	r3, [r7, #4]
 8005166:	681b      	ldr	r3, [r3, #0]
 8005168:	681a      	ldr	r2, [r3, #0]
 800516a:	687b      	ldr	r3, [r7, #4]
 800516c:	681b      	ldr	r3, [r3, #0]
 800516e:	f042 0201 	orr.w	r2, r2, #1
 8005172:	601a      	str	r2, [r3, #0]
 8005174:	e000      	b.n	8005178 <HAL_TIM_Base_Start_IT+0xc0>
    if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))
 8005176:	bf00      	nop
  }

  /* Return function status */
  return HAL_OK;
 8005178:	2300      	movs	r3, #0
}
 800517a:	4618      	mov	r0, r3
 800517c:	3714      	adds	r7, #20
 800517e:	46bd      	mov	sp, r7
 8005180:	f85d 7b04 	ldr.w	r7, [sp], #4
 8005184:	4770      	bx	lr
 8005186:	bf00      	nop
 8005188:	40010000 	.word	0x40010000
 800518c:	40000400 	.word	0x40000400
 8005190:	40000800 	.word	0x40000800
 8005194:	40000c00 	.word	0x40000c00
 8005198:	40010400 	.word	0x40010400
 800519c:	40001800 	.word	0x40001800
 80051a0:	40014000 	.word	0x40014000
 80051a4:	00010007 	.word	0x00010007

080051a8 <HAL_TIM_IRQHandler>:
  * @brief  This function handles TIM interrupts requests.
  * @param  htim TIM  handle
  * @retval None
  */
void HAL_TIM_IRQHandler(TIM_HandleTypeDef *htim)
{
 80051a8:	b580      	push	{r7, lr}
 80051aa:	b082      	sub	sp, #8
 80051ac:	af00      	add	r7, sp, #0
 80051ae:	6078      	str	r0, [r7, #4]
  /* Capture compare 1 event */
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC1) != RESET)
 80051b0:	687b      	ldr	r3, [r7, #4]
 80051b2:	681b      	ldr	r3, [r3, #0]
 80051b4:	691b      	ldr	r3, [r3, #16]
 80051b6:	f003 0302 	and.w	r3, r3, #2
 80051ba:	2b02      	cmp	r3, #2
 80051bc:	d122      	bne.n	8005204 <HAL_TIM_IRQHandler+0x5c>
  {
    if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_CC1) != RESET)
 80051be:	687b      	ldr	r3, [r7, #4]
 80051c0:	681b      	ldr	r3, [r3, #0]
 80051c2:	68db      	ldr	r3, [r3, #12]
 80051c4:	f003 0302 	and.w	r3, r3, #2
 80051c8:	2b02      	cmp	r3, #2
 80051ca:	d11b      	bne.n	8005204 <HAL_TIM_IRQHandler+0x5c>
    {
      {
        __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC1);
 80051cc:	687b      	ldr	r3, [r7, #4]
 80051ce:	681b      	ldr	r3, [r3, #0]
 80051d0:	f06f 0202 	mvn.w	r2, #2
 80051d4:	611a      	str	r2, [r3, #16]
        htim->Channel = HAL_TIM_ACTIVE_CHANNEL_1;
 80051d6:	687b      	ldr	r3, [r7, #4]
 80051d8:	2201      	movs	r2, #1
 80051da:	771a      	strb	r2, [r3, #28]

        /* Input capture event */
        if ((htim->Instance->CCMR1 & TIM_CCMR1_CC1S) != 0x00U)
 80051dc:	687b      	ldr	r3, [r7, #4]
 80051de:	681b      	ldr	r3, [r3, #0]
 80051e0:	699b      	ldr	r3, [r3, #24]
 80051e2:	f003 0303 	and.w	r3, r3, #3
 80051e6:	2b00      	cmp	r3, #0
 80051e8:	d003      	beq.n	80051f2 <HAL_TIM_IRQHandler+0x4a>
        {
#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
          htim->IC_CaptureCallback(htim);
#else
          HAL_TIM_IC_CaptureCallback(htim);
 80051ea:	6878      	ldr	r0, [r7, #4]
 80051ec:	f000 f905 	bl	80053fa <HAL_TIM_IC_CaptureCallback>
 80051f0:	e005      	b.n	80051fe <HAL_TIM_IRQHandler+0x56>
        {
#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
          htim->OC_DelayElapsedCallback(htim);
          htim->PWM_PulseFinishedCallback(htim);
#else
          HAL_TIM_OC_DelayElapsedCallback(htim);
 80051f2:	6878      	ldr	r0, [r7, #4]
 80051f4:	f000 f8f7 	bl	80053e6 <HAL_TIM_OC_DelayElapsedCallback>
          HAL_TIM_PWM_PulseFinishedCallback(htim);
 80051f8:	6878      	ldr	r0, [r7, #4]
 80051fa:	f000 f908 	bl	800540e <HAL_TIM_PWM_PulseFinishedCallback>
#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
        }
        htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
 80051fe:	687b      	ldr	r3, [r7, #4]
 8005200:	2200      	movs	r2, #0
 8005202:	771a      	strb	r2, [r3, #28]
      }
    }
  }
  /* Capture compare 2 event */
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC2) != RESET)
 8005204:	687b      	ldr	r3, [r7, #4]
 8005206:	681b      	ldr	r3, [r3, #0]
 8005208:	691b      	ldr	r3, [r3, #16]
 800520a:	f003 0304 	and.w	r3, r3, #4
 800520e:	2b04      	cmp	r3, #4
 8005210:	d122      	bne.n	8005258 <HAL_TIM_IRQHandler+0xb0>
  {
    if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_CC2) != RESET)
 8005212:	687b      	ldr	r3, [r7, #4]
 8005214:	681b      	ldr	r3, [r3, #0]
 8005216:	68db      	ldr	r3, [r3, #12]
 8005218:	f003 0304 	and.w	r3, r3, #4
 800521c:	2b04      	cmp	r3, #4
 800521e:	d11b      	bne.n	8005258 <HAL_TIM_IRQHandler+0xb0>
    {
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC2);
 8005220:	687b      	ldr	r3, [r7, #4]
 8005222:	681b      	ldr	r3, [r3, #0]
 8005224:	f06f 0204 	mvn.w	r2, #4
 8005228:	611a      	str	r2, [r3, #16]
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_2;
 800522a:	687b      	ldr	r3, [r7, #4]
 800522c:	2202      	movs	r2, #2
 800522e:	771a      	strb	r2, [r3, #28]
      /* Input capture event */
      if ((htim->Instance->CCMR1 & TIM_CCMR1_CC2S) != 0x00U)
 8005230:	687b      	ldr	r3, [r7, #4]
 8005232:	681b      	ldr	r3, [r3, #0]
 8005234:	699b      	ldr	r3, [r3, #24]
 8005236:	f403 7340 	and.w	r3, r3, #768	; 0x300
 800523a:	2b00      	cmp	r3, #0
 800523c:	d003      	beq.n	8005246 <HAL_TIM_IRQHandler+0x9e>
      {
#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
        htim->IC_CaptureCallback(htim);
#else
        HAL_TIM_IC_CaptureCallback(htim);
 800523e:	6878      	ldr	r0, [r7, #4]
 8005240:	f000 f8db 	bl	80053fa <HAL_TIM_IC_CaptureCallback>
 8005244:	e005      	b.n	8005252 <HAL_TIM_IRQHandler+0xaa>
      {
#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
        htim->OC_DelayElapsedCallback(htim);
        htim->PWM_PulseFinishedCallback(htim);
#else
        HAL_TIM_OC_DelayElapsedCallback(htim);
 8005246:	6878      	ldr	r0, [r7, #4]
 8005248:	f000 f8cd 	bl	80053e6 <HAL_TIM_OC_DelayElapsedCallback>
        HAL_TIM_PWM_PulseFinishedCallback(htim);
 800524c:	6878      	ldr	r0, [r7, #4]
 800524e:	f000 f8de 	bl	800540e <HAL_TIM_PWM_PulseFinishedCallback>
#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
      }
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
 8005252:	687b      	ldr	r3, [r7, #4]
 8005254:	2200      	movs	r2, #0
 8005256:	771a      	strb	r2, [r3, #28]
    }
  }
  /* Capture compare 3 event */
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC3) != RESET)
 8005258:	687b      	ldr	r3, [r7, #4]
 800525a:	681b      	ldr	r3, [r3, #0]
 800525c:	691b      	ldr	r3, [r3, #16]
 800525e:	f003 0308 	and.w	r3, r3, #8
 8005262:	2b08      	cmp	r3, #8
 8005264:	d122      	bne.n	80052ac <HAL_TIM_IRQHandler+0x104>
  {
    if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_CC3) != RESET)
 8005266:	687b      	ldr	r3, [r7, #4]
 8005268:	681b      	ldr	r3, [r3, #0]
 800526a:	68db      	ldr	r3, [r3, #12]
 800526c:	f003 0308 	and.w	r3, r3, #8
 8005270:	2b08      	cmp	r3, #8
 8005272:	d11b      	bne.n	80052ac <HAL_TIM_IRQHandler+0x104>
    {
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC3);
 8005274:	687b      	ldr	r3, [r7, #4]
 8005276:	681b      	ldr	r3, [r3, #0]
 8005278:	f06f 0208 	mvn.w	r2, #8
 800527c:	611a      	str	r2, [r3, #16]
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_3;
 800527e:	687b      	ldr	r3, [r7, #4]
 8005280:	2204      	movs	r2, #4
 8005282:	771a      	strb	r2, [r3, #28]
      /* Input capture event */
      if ((htim->Instance->CCMR2 & TIM_CCMR2_CC3S) != 0x00U)
 8005284:	687b      	ldr	r3, [r7, #4]
 8005286:	681b      	ldr	r3, [r3, #0]
 8005288:	69db      	ldr	r3, [r3, #28]
 800528a:	f003 0303 	and.w	r3, r3, #3
 800528e:	2b00      	cmp	r3, #0
 8005290:	d003      	beq.n	800529a <HAL_TIM_IRQHandler+0xf2>
      {
#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
        htim->IC_CaptureCallback(htim);
#else
        HAL_TIM_IC_CaptureCallback(htim);
 8005292:	6878      	ldr	r0, [r7, #4]
 8005294:	f000 f8b1 	bl	80053fa <HAL_TIM_IC_CaptureCallback>
 8005298:	e005      	b.n	80052a6 <HAL_TIM_IRQHandler+0xfe>
      {
#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
        htim->OC_DelayElapsedCallback(htim);
        htim->PWM_PulseFinishedCallback(htim);
#else
        HAL_TIM_OC_DelayElapsedCallback(htim);
 800529a:	6878      	ldr	r0, [r7, #4]
 800529c:	f000 f8a3 	bl	80053e6 <HAL_TIM_OC_DelayElapsedCallback>
        HAL_TIM_PWM_PulseFinishedCallback(htim);
 80052a0:	6878      	ldr	r0, [r7, #4]
 80052a2:	f000 f8b4 	bl	800540e <HAL_TIM_PWM_PulseFinishedCallback>
#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
      }
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
 80052a6:	687b      	ldr	r3, [r7, #4]
 80052a8:	2200      	movs	r2, #0
 80052aa:	771a      	strb	r2, [r3, #28]
    }
  }
  /* Capture compare 4 event */
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC4) != RESET)
 80052ac:	687b      	ldr	r3, [r7, #4]
 80052ae:	681b      	ldr	r3, [r3, #0]
 80052b0:	691b      	ldr	r3, [r3, #16]
 80052b2:	f003 0310 	and.w	r3, r3, #16
 80052b6:	2b10      	cmp	r3, #16
 80052b8:	d122      	bne.n	8005300 <HAL_TIM_IRQHandler+0x158>
  {
    if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_CC4) != RESET)
 80052ba:	687b      	ldr	r3, [r7, #4]
 80052bc:	681b      	ldr	r3, [r3, #0]
 80052be:	68db      	ldr	r3, [r3, #12]
 80052c0:	f003 0310 	and.w	r3, r3, #16
 80052c4:	2b10      	cmp	r3, #16
 80052c6:	d11b      	bne.n	8005300 <HAL_TIM_IRQHandler+0x158>
    {
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC4);
 80052c8:	687b      	ldr	r3, [r7, #4]
 80052ca:	681b      	ldr	r3, [r3, #0]
 80052cc:	f06f 0210 	mvn.w	r2, #16
 80052d0:	611a      	str	r2, [r3, #16]
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_4;
 80052d2:	687b      	ldr	r3, [r7, #4]
 80052d4:	2208      	movs	r2, #8
 80052d6:	771a      	strb	r2, [r3, #28]
      /* Input capture event */
      if ((htim->Instance->CCMR2 & TIM_CCMR2_CC4S) != 0x00U)
 80052d8:	687b      	ldr	r3, [r7, #4]
 80052da:	681b      	ldr	r3, [r3, #0]
 80052dc:	69db      	ldr	r3, [r3, #28]
 80052de:	f403 7340 	and.w	r3, r3, #768	; 0x300
 80052e2:	2b00      	cmp	r3, #0
 80052e4:	d003      	beq.n	80052ee <HAL_TIM_IRQHandler+0x146>
      {
#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
        htim->IC_CaptureCallback(htim);
#else
        HAL_TIM_IC_CaptureCallback(htim);
 80052e6:	6878      	ldr	r0, [r7, #4]
 80052e8:	f000 f887 	bl	80053fa <HAL_TIM_IC_CaptureCallback>
 80052ec:	e005      	b.n	80052fa <HAL_TIM_IRQHandler+0x152>
      {
#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
        htim->OC_DelayElapsedCallback(htim);
        htim->PWM_PulseFinishedCallback(htim);
#else
        HAL_TIM_OC_DelayElapsedCallback(htim);
 80052ee:	6878      	ldr	r0, [r7, #4]
 80052f0:	f000 f879 	bl	80053e6 <HAL_TIM_OC_DelayElapsedCallback>
        HAL_TIM_PWM_PulseFinishedCallback(htim);
 80052f4:	6878      	ldr	r0, [r7, #4]
 80052f6:	f000 f88a 	bl	800540e <HAL_TIM_PWM_PulseFinishedCallback>
#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
      }
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
 80052fa:	687b      	ldr	r3, [r7, #4]
 80052fc:	2200      	movs	r2, #0
 80052fe:	771a      	strb	r2, [r3, #28]
    }
  }
  /* TIM Update event */
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_UPDATE) != RESET)
 8005300:	687b      	ldr	r3, [r7, #4]
 8005302:	681b      	ldr	r3, [r3, #0]
 8005304:	691b      	ldr	r3, [r3, #16]
 8005306:	f003 0301 	and.w	r3, r3, #1
 800530a:	2b01      	cmp	r3, #1
 800530c:	d10e      	bne.n	800532c <HAL_TIM_IRQHandler+0x184>
  {
    if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_UPDATE) != RESET)
 800530e:	687b      	ldr	r3, [r7, #4]
 8005310:	681b      	ldr	r3, [r3, #0]
 8005312:	68db      	ldr	r3, [r3, #12]
 8005314:	f003 0301 	and.w	r3, r3, #1
 8005318:	2b01      	cmp	r3, #1
 800531a:	d107      	bne.n	800532c <HAL_TIM_IRQHandler+0x184>
    {
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_UPDATE);
 800531c:	687b      	ldr	r3, [r7, #4]
 800531e:	681b      	ldr	r3, [r3, #0]
 8005320:	f06f 0201 	mvn.w	r2, #1
 8005324:	611a      	str	r2, [r3, #16]
#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
      htim->PeriodElapsedCallback(htim);
#else
      HAL_TIM_PeriodElapsedCallback(htim);
 8005326:	6878      	ldr	r0, [r7, #4]
 8005328:	f7fb fdae 	bl	8000e88 <HAL_TIM_PeriodElapsedCallback>
#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
    }
  }
  /* TIM Break input event */
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_BREAK) != RESET)
 800532c:	687b      	ldr	r3, [r7, #4]
 800532e:	681b      	ldr	r3, [r3, #0]
 8005330:	691b      	ldr	r3, [r3, #16]
 8005332:	f003 0380 	and.w	r3, r3, #128	; 0x80
 8005336:	2b80      	cmp	r3, #128	; 0x80
 8005338:	d10e      	bne.n	8005358 <HAL_TIM_IRQHandler+0x1b0>
  {
    if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_BREAK) != RESET)
 800533a:	687b      	ldr	r3, [r7, #4]
 800533c:	681b      	ldr	r3, [r3, #0]
 800533e:	68db      	ldr	r3, [r3, #12]
 8005340:	f003 0380 	and.w	r3, r3, #128	; 0x80
 8005344:	2b80      	cmp	r3, #128	; 0x80
 8005346:	d107      	bne.n	8005358 <HAL_TIM_IRQHandler+0x1b0>
    {
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_BREAK);
 8005348:	687b      	ldr	r3, [r7, #4]
 800534a:	681b      	ldr	r3, [r3, #0]
 800534c:	f06f 0280 	mvn.w	r2, #128	; 0x80
 8005350:	611a      	str	r2, [r3, #16]
#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
      htim->BreakCallback(htim);
#else
      HAL_TIMEx_BreakCallback(htim);
 8005352:	6878      	ldr	r0, [r7, #4]
 8005354:	f000 f914 	bl	8005580 <HAL_TIMEx_BreakCallback>
#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
    }
  }
  /* TIM Break2 input event */
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_BREAK2) != RESET)
 8005358:	687b      	ldr	r3, [r7, #4]
 800535a:	681b      	ldr	r3, [r3, #0]
 800535c:	691b      	ldr	r3, [r3, #16]
 800535e:	f403 7380 	and.w	r3, r3, #256	; 0x100
 8005362:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
 8005366:	d10e      	bne.n	8005386 <HAL_TIM_IRQHandler+0x1de>
  {
    if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_BREAK) != RESET)
 8005368:	687b      	ldr	r3, [r7, #4]
 800536a:	681b      	ldr	r3, [r3, #0]
 800536c:	68db      	ldr	r3, [r3, #12]
 800536e:	f003 0380 	and.w	r3, r3, #128	; 0x80
 8005372:	2b80      	cmp	r3, #128	; 0x80
 8005374:	d107      	bne.n	8005386 <HAL_TIM_IRQHandler+0x1de>
    {
      __HAL_TIM_CLEAR_FLAG(htim, TIM_FLAG_BREAK2);
 8005376:	687b      	ldr	r3, [r7, #4]
 8005378:	681b      	ldr	r3, [r3, #0]
 800537a:	f46f 7280 	mvn.w	r2, #256	; 0x100
 800537e:	611a      	str	r2, [r3, #16]
#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
      htim->Break2Callback(htim);
#else
      HAL_TIMEx_Break2Callback(htim);
 8005380:	6878      	ldr	r0, [r7, #4]
 8005382:	f000 f907 	bl	8005594 <HAL_TIMEx_Break2Callback>
#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
    }
  }
  /* TIM Trigger detection event */
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_TRIGGER) != RESET)
 8005386:	687b      	ldr	r3, [r7, #4]
 8005388:	681b      	ldr	r3, [r3, #0]
 800538a:	691b      	ldr	r3, [r3, #16]
 800538c:	f003 0340 	and.w	r3, r3, #64	; 0x40
 8005390:	2b40      	cmp	r3, #64	; 0x40
 8005392:	d10e      	bne.n	80053b2 <HAL_TIM_IRQHandler+0x20a>
  {
    if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_TRIGGER) != RESET)
 8005394:	687b      	ldr	r3, [r7, #4]
 8005396:	681b      	ldr	r3, [r3, #0]
 8005398:	68db      	ldr	r3, [r3, #12]
 800539a:	f003 0340 	and.w	r3, r3, #64	; 0x40
 800539e:	2b40      	cmp	r3, #64	; 0x40
 80053a0:	d107      	bne.n	80053b2 <HAL_TIM_IRQHandler+0x20a>
    {
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_TRIGGER);
 80053a2:	687b      	ldr	r3, [r7, #4]
 80053a4:	681b      	ldr	r3, [r3, #0]
 80053a6:	f06f 0240 	mvn.w	r2, #64	; 0x40
 80053aa:	611a      	str	r2, [r3, #16]
#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
      htim->TriggerCallback(htim);
#else
      HAL_TIM_TriggerCallback(htim);
 80053ac:	6878      	ldr	r0, [r7, #4]
 80053ae:	f000 f838 	bl	8005422 <HAL_TIM_TriggerCallback>
#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
    }
  }
  /* TIM commutation event */
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_COM) != RESET)
 80053b2:	687b      	ldr	r3, [r7, #4]
 80053b4:	681b      	ldr	r3, [r3, #0]
 80053b6:	691b      	ldr	r3, [r3, #16]
 80053b8:	f003 0320 	and.w	r3, r3, #32
 80053bc:	2b20      	cmp	r3, #32
 80053be:	d10e      	bne.n	80053de <HAL_TIM_IRQHandler+0x236>
  {
    if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_COM) != RESET)
 80053c0:	687b      	ldr	r3, [r7, #4]
 80053c2:	681b      	ldr	r3, [r3, #0]
 80053c4:	68db      	ldr	r3, [r3, #12]
 80053c6:	f003 0320 	and.w	r3, r3, #32
 80053ca:	2b20      	cmp	r3, #32
 80053cc:	d107      	bne.n	80053de <HAL_TIM_IRQHandler+0x236>
    {
      __HAL_TIM_CLEAR_IT(htim, TIM_FLAG_COM);
 80053ce:	687b      	ldr	r3, [r7, #4]
 80053d0:	681b      	ldr	r3, [r3, #0]
 80053d2:	f06f 0220 	mvn.w	r2, #32
 80053d6:	611a      	str	r2, [r3, #16]
#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
      htim->CommutationCallback(htim);
#else
      HAL_TIMEx_CommutCallback(htim);
 80053d8:	6878      	ldr	r0, [r7, #4]
 80053da:	f000 f8c7 	bl	800556c <HAL_TIMEx_CommutCallback>
#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
    }
  }
}
 80053de:	bf00      	nop
 80053e0:	3708      	adds	r7, #8
 80053e2:	46bd      	mov	sp, r7
 80053e4:	bd80      	pop	{r7, pc}

080053e6 <HAL_TIM_OC_DelayElapsedCallback>:
  * @brief  Output Compare callback in non-blocking mode
  * @param  htim TIM OC handle
  * @retval None
  */
__weak void HAL_TIM_OC_DelayElapsedCallback(TIM_HandleTypeDef *htim)
{
 80053e6:	b480      	push	{r7}
 80053e8:	b083      	sub	sp, #12
 80053ea:	af00      	add	r7, sp, #0
 80053ec:	6078      	str	r0, [r7, #4]
  UNUSED(htim);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_TIM_OC_DelayElapsedCallback could be implemented in the user file
   */
}
 80053ee:	bf00      	nop
 80053f0:	370c      	adds	r7, #12
 80053f2:	46bd      	mov	sp, r7
 80053f4:	f85d 7b04 	ldr.w	r7, [sp], #4
 80053f8:	4770      	bx	lr

080053fa <HAL_TIM_IC_CaptureCallback>:
  * @brief  Input Capture callback in non-blocking mode
  * @param  htim TIM IC handle
  * @retval None
  */
__weak void HAL_TIM_IC_CaptureCallback(TIM_HandleTypeDef *htim)
{
 80053fa:	b480      	push	{r7}
 80053fc:	b083      	sub	sp, #12
 80053fe:	af00      	add	r7, sp, #0
 8005400:	6078      	str	r0, [r7, #4]
  UNUSED(htim);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_TIM_IC_CaptureCallback could be implemented in the user file
   */
}
 8005402:	bf00      	nop
 8005404:	370c      	adds	r7, #12
 8005406:	46bd      	mov	sp, r7
 8005408:	f85d 7b04 	ldr.w	r7, [sp], #4
 800540c:	4770      	bx	lr

0800540e <HAL_TIM_PWM_PulseFinishedCallback>:
  * @brief  PWM Pulse finished callback in non-blocking mode
  * @param  htim TIM handle
  * @retval None
  */
__weak void HAL_TIM_PWM_PulseFinishedCallback(TIM_HandleTypeDef *htim)
{
 800540e:	b480      	push	{r7}
 8005410:	b083      	sub	sp, #12
 8005412:	af00      	add	r7, sp, #0
 8005414:	6078      	str	r0, [r7, #4]
  UNUSED(htim);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_TIM_PWM_PulseFinishedCallback could be implemented in the user file
   */
}
 8005416:	bf00      	nop
 8005418:	370c      	adds	r7, #12
 800541a:	46bd      	mov	sp, r7
 800541c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8005420:	4770      	bx	lr

08005422 <HAL_TIM_TriggerCallback>:
  * @brief  Hall Trigger detection callback in non-blocking mode
  * @param  htim TIM handle
  * @retval None
  */
__weak void HAL_TIM_TriggerCallback(TIM_HandleTypeDef *htim)
{
 8005422:	b480      	push	{r7}
 8005424:	b083      	sub	sp, #12
 8005426:	af00      	add	r7, sp, #0
 8005428:	6078      	str	r0, [r7, #4]
  UNUSED(htim);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_TIM_TriggerCallback could be implemented in the user file
   */
}
 800542a:	bf00      	nop
 800542c:	370c      	adds	r7, #12
 800542e:	46bd      	mov	sp, r7
 8005430:	f85d 7b04 	ldr.w	r7, [sp], #4
 8005434:	4770      	bx	lr
	...

08005438 <TIM_Base_SetConfig>:
  * @param  TIMx TIM peripheral
  * @param  Structure TIM Base configuration structure
  * @retval None
  */
void TIM_Base_SetConfig(TIM_TypeDef *TIMx, TIM_Base_InitTypeDef *Structure)
{
 8005438:	b480      	push	{r7}
 800543a:	b085      	sub	sp, #20
 800543c:	af00      	add	r7, sp, #0
 800543e:	6078      	str	r0, [r7, #4]
 8005440:	6039      	str	r1, [r7, #0]
  uint32_t tmpcr1;
  tmpcr1 = TIMx->CR1;
 8005442:	687b      	ldr	r3, [r7, #4]
 8005444:	681b      	ldr	r3, [r3, #0]
 8005446:	60fb      	str	r3, [r7, #12]

  /* Set TIM Time Base Unit parameters ---------------------------------------*/
  if (IS_TIM_COUNTER_MODE_SELECT_INSTANCE(TIMx))
 8005448:	687b      	ldr	r3, [r7, #4]
 800544a:	4a40      	ldr	r2, [pc, #256]	; (800554c <TIM_Base_SetConfig+0x114>)
 800544c:	4293      	cmp	r3, r2
 800544e:	d013      	beq.n	8005478 <TIM_Base_SetConfig+0x40>
 8005450:	687b      	ldr	r3, [r7, #4]
 8005452:	f1b3 4f80 	cmp.w	r3, #1073741824	; 0x40000000
 8005456:	d00f      	beq.n	8005478 <TIM_Base_SetConfig+0x40>
 8005458:	687b      	ldr	r3, [r7, #4]
 800545a:	4a3d      	ldr	r2, [pc, #244]	; (8005550 <TIM_Base_SetConfig+0x118>)
 800545c:	4293      	cmp	r3, r2
 800545e:	d00b      	beq.n	8005478 <TIM_Base_SetConfig+0x40>
 8005460:	687b      	ldr	r3, [r7, #4]
 8005462:	4a3c      	ldr	r2, [pc, #240]	; (8005554 <TIM_Base_SetConfig+0x11c>)
 8005464:	4293      	cmp	r3, r2
 8005466:	d007      	beq.n	8005478 <TIM_Base_SetConfig+0x40>
 8005468:	687b      	ldr	r3, [r7, #4]
 800546a:	4a3b      	ldr	r2, [pc, #236]	; (8005558 <TIM_Base_SetConfig+0x120>)
 800546c:	4293      	cmp	r3, r2
 800546e:	d003      	beq.n	8005478 <TIM_Base_SetConfig+0x40>
 8005470:	687b      	ldr	r3, [r7, #4]
 8005472:	4a3a      	ldr	r2, [pc, #232]	; (800555c <TIM_Base_SetConfig+0x124>)
 8005474:	4293      	cmp	r3, r2
 8005476:	d108      	bne.n	800548a <TIM_Base_SetConfig+0x52>
  {
    /* Select the Counter Mode */
    tmpcr1 &= ~(TIM_CR1_DIR | TIM_CR1_CMS);
 8005478:	68fb      	ldr	r3, [r7, #12]
 800547a:	f023 0370 	bic.w	r3, r3, #112	; 0x70
 800547e:	60fb      	str	r3, [r7, #12]
    tmpcr1 |= Structure->CounterMode;
 8005480:	683b      	ldr	r3, [r7, #0]
 8005482:	685b      	ldr	r3, [r3, #4]
 8005484:	68fa      	ldr	r2, [r7, #12]
 8005486:	4313      	orrs	r3, r2
 8005488:	60fb      	str	r3, [r7, #12]
  }

  if (IS_TIM_CLOCK_DIVISION_INSTANCE(TIMx))
 800548a:	687b      	ldr	r3, [r7, #4]
 800548c:	4a2f      	ldr	r2, [pc, #188]	; (800554c <TIM_Base_SetConfig+0x114>)
 800548e:	4293      	cmp	r3, r2
 8005490:	d01f      	beq.n	80054d2 <TIM_Base_SetConfig+0x9a>
 8005492:	687b      	ldr	r3, [r7, #4]
 8005494:	f1b3 4f80 	cmp.w	r3, #1073741824	; 0x40000000
 8005498:	d01b      	beq.n	80054d2 <TIM_Base_SetConfig+0x9a>
 800549a:	687b      	ldr	r3, [r7, #4]
 800549c:	4a2c      	ldr	r2, [pc, #176]	; (8005550 <TIM_Base_SetConfig+0x118>)
 800549e:	4293      	cmp	r3, r2
 80054a0:	d017      	beq.n	80054d2 <TIM_Base_SetConfig+0x9a>
 80054a2:	687b      	ldr	r3, [r7, #4]
 80054a4:	4a2b      	ldr	r2, [pc, #172]	; (8005554 <TIM_Base_SetConfig+0x11c>)
 80054a6:	4293      	cmp	r3, r2
 80054a8:	d013      	beq.n	80054d2 <TIM_Base_SetConfig+0x9a>
 80054aa:	687b      	ldr	r3, [r7, #4]
 80054ac:	4a2a      	ldr	r2, [pc, #168]	; (8005558 <TIM_Base_SetConfig+0x120>)
 80054ae:	4293      	cmp	r3, r2
 80054b0:	d00f      	beq.n	80054d2 <TIM_Base_SetConfig+0x9a>
 80054b2:	687b      	ldr	r3, [r7, #4]
 80054b4:	4a29      	ldr	r2, [pc, #164]	; (800555c <TIM_Base_SetConfig+0x124>)
 80054b6:	4293      	cmp	r3, r2
 80054b8:	d00b      	beq.n	80054d2 <TIM_Base_SetConfig+0x9a>
 80054ba:	687b      	ldr	r3, [r7, #4]
 80054bc:	4a28      	ldr	r2, [pc, #160]	; (8005560 <TIM_Base_SetConfig+0x128>)
 80054be:	4293      	cmp	r3, r2
 80054c0:	d007      	beq.n	80054d2 <TIM_Base_SetConfig+0x9a>
 80054c2:	687b      	ldr	r3, [r7, #4]
 80054c4:	4a27      	ldr	r2, [pc, #156]	; (8005564 <TIM_Base_SetConfig+0x12c>)
 80054c6:	4293      	cmp	r3, r2
 80054c8:	d003      	beq.n	80054d2 <TIM_Base_SetConfig+0x9a>
 80054ca:	687b      	ldr	r3, [r7, #4]
 80054cc:	4a26      	ldr	r2, [pc, #152]	; (8005568 <TIM_Base_SetConfig+0x130>)
 80054ce:	4293      	cmp	r3, r2
 80054d0:	d108      	bne.n	80054e4 <TIM_Base_SetConfig+0xac>
  {
    /* Set the clock division */
    tmpcr1 &= ~TIM_CR1_CKD;
 80054d2:	68fb      	ldr	r3, [r7, #12]
 80054d4:	f423 7340 	bic.w	r3, r3, #768	; 0x300
 80054d8:	60fb      	str	r3, [r7, #12]
    tmpcr1 |= (uint32_t)Structure->ClockDivision;
 80054da:	683b      	ldr	r3, [r7, #0]
 80054dc:	68db      	ldr	r3, [r3, #12]
 80054de:	68fa      	ldr	r2, [r7, #12]
 80054e0:	4313      	orrs	r3, r2
 80054e2:	60fb      	str	r3, [r7, #12]
  }

  /* Set the auto-reload preload */
  MODIFY_REG(tmpcr1, TIM_CR1_ARPE, Structure->AutoReloadPreload);
 80054e4:	68fb      	ldr	r3, [r7, #12]
 80054e6:	f023 0280 	bic.w	r2, r3, #128	; 0x80
 80054ea:	683b      	ldr	r3, [r7, #0]
 80054ec:	695b      	ldr	r3, [r3, #20]
 80054ee:	4313      	orrs	r3, r2
 80054f0:	60fb      	str	r3, [r7, #12]

  TIMx->CR1 = tmpcr1;
 80054f2:	687b      	ldr	r3, [r7, #4]
 80054f4:	68fa      	ldr	r2, [r7, #12]
 80054f6:	601a      	str	r2, [r3, #0]

  /* Set the Autoreload value */
  TIMx->ARR = (uint32_t)Structure->Period ;
 80054f8:	683b      	ldr	r3, [r7, #0]
 80054fa:	689a      	ldr	r2, [r3, #8]
 80054fc:	687b      	ldr	r3, [r7, #4]
 80054fe:	62da      	str	r2, [r3, #44]	; 0x2c

  /* Set the Prescaler value */
  TIMx->PSC = Structure->Prescaler;
 8005500:	683b      	ldr	r3, [r7, #0]
 8005502:	681a      	ldr	r2, [r3, #0]
 8005504:	687b      	ldr	r3, [r7, #4]
 8005506:	629a      	str	r2, [r3, #40]	; 0x28

  if (IS_TIM_REPETITION_COUNTER_INSTANCE(TIMx))
 8005508:	687b      	ldr	r3, [r7, #4]
 800550a:	4a10      	ldr	r2, [pc, #64]	; (800554c <TIM_Base_SetConfig+0x114>)
 800550c:	4293      	cmp	r3, r2
 800550e:	d00f      	beq.n	8005530 <TIM_Base_SetConfig+0xf8>
 8005510:	687b      	ldr	r3, [r7, #4]
 8005512:	4a12      	ldr	r2, [pc, #72]	; (800555c <TIM_Base_SetConfig+0x124>)
 8005514:	4293      	cmp	r3, r2
 8005516:	d00b      	beq.n	8005530 <TIM_Base_SetConfig+0xf8>
 8005518:	687b      	ldr	r3, [r7, #4]
 800551a:	4a11      	ldr	r2, [pc, #68]	; (8005560 <TIM_Base_SetConfig+0x128>)
 800551c:	4293      	cmp	r3, r2
 800551e:	d007      	beq.n	8005530 <TIM_Base_SetConfig+0xf8>
 8005520:	687b      	ldr	r3, [r7, #4]
 8005522:	4a10      	ldr	r2, [pc, #64]	; (8005564 <TIM_Base_SetConfig+0x12c>)
 8005524:	4293      	cmp	r3, r2
 8005526:	d003      	beq.n	8005530 <TIM_Base_SetConfig+0xf8>
 8005528:	687b      	ldr	r3, [r7, #4]
 800552a:	4a0f      	ldr	r2, [pc, #60]	; (8005568 <TIM_Base_SetConfig+0x130>)
 800552c:	4293      	cmp	r3, r2
 800552e:	d103      	bne.n	8005538 <TIM_Base_SetConfig+0x100>
  {
    /* Set the Repetition Counter value */
    TIMx->RCR = Structure->RepetitionCounter;
 8005530:	683b      	ldr	r3, [r7, #0]
 8005532:	691a      	ldr	r2, [r3, #16]
 8005534:	687b      	ldr	r3, [r7, #4]
 8005536:	631a      	str	r2, [r3, #48]	; 0x30
  }

  /* Generate an update event to reload the Prescaler
     and the repetition counter (only for advanced timer) value immediately */
  TIMx->EGR = TIM_EGR_UG;
 8005538:	687b      	ldr	r3, [r7, #4]
 800553a:	2201      	movs	r2, #1
 800553c:	615a      	str	r2, [r3, #20]
}
 800553e:	bf00      	nop
 8005540:	3714      	adds	r7, #20
 8005542:	46bd      	mov	sp, r7
 8005544:	f85d 7b04 	ldr.w	r7, [sp], #4
 8005548:	4770      	bx	lr
 800554a:	bf00      	nop
 800554c:	40010000 	.word	0x40010000
 8005550:	40000400 	.word	0x40000400
 8005554:	40000800 	.word	0x40000800
 8005558:	40000c00 	.word	0x40000c00
 800555c:	40010400 	.word	0x40010400
 8005560:	40014000 	.word	0x40014000
 8005564:	40014400 	.word	0x40014400
 8005568:	40014800 	.word	0x40014800

0800556c <HAL_TIMEx_CommutCallback>:
  * @brief  Hall commutation changed callback in non-blocking mode
  * @param  htim TIM handle
  * @retval None
  */
__weak void HAL_TIMEx_CommutCallback(TIM_HandleTypeDef *htim)
{
 800556c:	b480      	push	{r7}
 800556e:	b083      	sub	sp, #12
 8005570:	af00      	add	r7, sp, #0
 8005572:	6078      	str	r0, [r7, #4]
  UNUSED(htim);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_TIMEx_CommutCallback could be implemented in the user file
   */
}
 8005574:	bf00      	nop
 8005576:	370c      	adds	r7, #12
 8005578:	46bd      	mov	sp, r7
 800557a:	f85d 7b04 	ldr.w	r7, [sp], #4
 800557e:	4770      	bx	lr

08005580 <HAL_TIMEx_BreakCallback>:
  * @brief  Hall Break detection callback in non-blocking mode
  * @param  htim TIM handle
  * @retval None
  */
__weak void HAL_TIMEx_BreakCallback(TIM_HandleTypeDef *htim)
{
 8005580:	b480      	push	{r7}
 8005582:	b083      	sub	sp, #12
 8005584:	af00      	add	r7, sp, #0
 8005586:	6078      	str	r0, [r7, #4]
  UNUSED(htim);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_TIMEx_BreakCallback could be implemented in the user file
   */
}
 8005588:	bf00      	nop
 800558a:	370c      	adds	r7, #12
 800558c:	46bd      	mov	sp, r7
 800558e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8005592:	4770      	bx	lr

08005594 <HAL_TIMEx_Break2Callback>:
  * @brief  Hall Break2 detection callback in non blocking mode
  * @param  htim: TIM handle
  * @retval None
  */
__weak void HAL_TIMEx_Break2Callback(TIM_HandleTypeDef *htim)
{
 8005594:	b480      	push	{r7}
 8005596:	b083      	sub	sp, #12
 8005598:	af00      	add	r7, sp, #0
 800559a:	6078      	str	r0, [r7, #4]
  UNUSED(htim);

  /* NOTE : This function Should not be modified, when the callback is needed,
            the HAL_TIMEx_Break2Callback could be implemented in the user file
   */
}
 800559c:	bf00      	nop
 800559e:	370c      	adds	r7, #12
 80055a0:	46bd      	mov	sp, r7
 80055a2:	f85d 7b04 	ldr.w	r7, [sp], #4
 80055a6:	4770      	bx	lr

080055a8 <HAL_UART_Init>:
  *        parameters in the UART_InitTypeDef and initialize the associated handle.
  * @param huart UART handle.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_UART_Init(UART_HandleTypeDef *huart)
{
 80055a8:	b580      	push	{r7, lr}
 80055aa:	b082      	sub	sp, #8
 80055ac:	af00      	add	r7, sp, #0
 80055ae:	6078      	str	r0, [r7, #4]
  /* Check the UART handle allocation */
  if (huart == NULL)
 80055b0:	687b      	ldr	r3, [r7, #4]
 80055b2:	2b00      	cmp	r3, #0
 80055b4:	d101      	bne.n	80055ba <HAL_UART_Init+0x12>
  {
    return HAL_ERROR;
 80055b6:	2301      	movs	r3, #1
 80055b8:	e042      	b.n	8005640 <HAL_UART_Init+0x98>
  {
    /* Check the parameters */
    assert_param((IS_UART_INSTANCE(huart->Instance)) || (IS_LPUART_INSTANCE(huart->Instance)));
  }

  if (huart->gState == HAL_UART_STATE_RESET)
 80055ba:	687b      	ldr	r3, [r7, #4]
 80055bc:	f8d3 3084 	ldr.w	r3, [r3, #132]	; 0x84
 80055c0:	2b00      	cmp	r3, #0
 80055c2:	d106      	bne.n	80055d2 <HAL_UART_Init+0x2a>
  {
    /* Allocate lock resource and initialize it */
    huart->Lock = HAL_UNLOCKED;
 80055c4:	687b      	ldr	r3, [r7, #4]
 80055c6:	2200      	movs	r2, #0
 80055c8:	f883 2080 	strb.w	r2, [r3, #128]	; 0x80

    /* Init the low level hardware */
    huart->MspInitCallback(huart);
#else
    /* Init the low level hardware : GPIO, CLOCK */
    HAL_UART_MspInit(huart);
 80055cc:	6878      	ldr	r0, [r7, #4]
 80055ce:	f7fb ff0f 	bl	80013f0 <HAL_UART_MspInit>
#endif /* (USE_HAL_UART_REGISTER_CALLBACKS) */
  }

  huart->gState = HAL_UART_STATE_BUSY;
 80055d2:	687b      	ldr	r3, [r7, #4]
 80055d4:	2224      	movs	r2, #36	; 0x24
 80055d6:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84

  __HAL_UART_DISABLE(huart);
 80055da:	687b      	ldr	r3, [r7, #4]
 80055dc:	681b      	ldr	r3, [r3, #0]
 80055de:	681a      	ldr	r2, [r3, #0]
 80055e0:	687b      	ldr	r3, [r7, #4]
 80055e2:	681b      	ldr	r3, [r3, #0]
 80055e4:	f022 0201 	bic.w	r2, r2, #1
 80055e8:	601a      	str	r2, [r3, #0]

  /* Set the UART Communication parameters */
  if (UART_SetConfig(huart) == HAL_ERROR)
 80055ea:	6878      	ldr	r0, [r7, #4]
 80055ec:	f000 f8c2 	bl	8005774 <UART_SetConfig>
 80055f0:	4603      	mov	r3, r0
 80055f2:	2b01      	cmp	r3, #1
 80055f4:	d101      	bne.n	80055fa <HAL_UART_Init+0x52>
  {
    return HAL_ERROR;
 80055f6:	2301      	movs	r3, #1
 80055f8:	e022      	b.n	8005640 <HAL_UART_Init+0x98>
  }

  if (huart->AdvancedInit.AdvFeatureInit != UART_ADVFEATURE_NO_INIT)
 80055fa:	687b      	ldr	r3, [r7, #4]
 80055fc:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 80055fe:	2b00      	cmp	r3, #0
 8005600:	d002      	beq.n	8005608 <HAL_UART_Init+0x60>
  {
    UART_AdvFeatureConfig(huart);
 8005602:	6878      	ldr	r0, [r7, #4]
 8005604:	f000 fe1e 	bl	8006244 <UART_AdvFeatureConfig>
  }

  /* In asynchronous mode, the following bits must be kept cleared:
  - LINEN and CLKEN bits in the USART_CR2 register,
  - SCEN, HDSEL and IREN  bits in the USART_CR3 register.*/
  CLEAR_BIT(huart->Instance->CR2, (USART_CR2_LINEN | USART_CR2_CLKEN));
 8005608:	687b      	ldr	r3, [r7, #4]
 800560a:	681b      	ldr	r3, [r3, #0]
 800560c:	685a      	ldr	r2, [r3, #4]
 800560e:	687b      	ldr	r3, [r7, #4]
 8005610:	681b      	ldr	r3, [r3, #0]
 8005612:	f422 4290 	bic.w	r2, r2, #18432	; 0x4800
 8005616:	605a      	str	r2, [r3, #4]
  CLEAR_BIT(huart->Instance->CR3, (USART_CR3_SCEN | USART_CR3_HDSEL | USART_CR3_IREN));
 8005618:	687b      	ldr	r3, [r7, #4]
 800561a:	681b      	ldr	r3, [r3, #0]
 800561c:	689a      	ldr	r2, [r3, #8]
 800561e:	687b      	ldr	r3, [r7, #4]
 8005620:	681b      	ldr	r3, [r3, #0]
 8005622:	f022 022a 	bic.w	r2, r2, #42	; 0x2a
 8005626:	609a      	str	r2, [r3, #8]

  __HAL_UART_ENABLE(huart);
 8005628:	687b      	ldr	r3, [r7, #4]
 800562a:	681b      	ldr	r3, [r3, #0]
 800562c:	681a      	ldr	r2, [r3, #0]
 800562e:	687b      	ldr	r3, [r7, #4]
 8005630:	681b      	ldr	r3, [r3, #0]
 8005632:	f042 0201 	orr.w	r2, r2, #1
 8005636:	601a      	str	r2, [r3, #0]

  /* TEACK and/or REACK to check before moving huart->gState and huart->RxState to Ready */
  return (UART_CheckIdleState(huart));
 8005638:	6878      	ldr	r0, [r7, #4]
 800563a:	f000 fea5 	bl	8006388 <UART_CheckIdleState>
 800563e:	4603      	mov	r3, r0
}
 8005640:	4618      	mov	r0, r3
 8005642:	3708      	adds	r7, #8
 8005644:	46bd      	mov	sp, r7
 8005646:	bd80      	pop	{r7, pc}

08005648 <HAL_UART_Transmit>:
  * @param Size    Amount of data elements (u8 or u16) to be sent.
  * @param Timeout Timeout duration.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_UART_Transmit(UART_HandleTypeDef *huart, const uint8_t *pData, uint16_t Size, uint32_t Timeout)
{
 8005648:	b580      	push	{r7, lr}
 800564a:	b08a      	sub	sp, #40	; 0x28
 800564c:	af02      	add	r7, sp, #8
 800564e:	60f8      	str	r0, [r7, #12]
 8005650:	60b9      	str	r1, [r7, #8]
 8005652:	603b      	str	r3, [r7, #0]
 8005654:	4613      	mov	r3, r2
 8005656:	80fb      	strh	r3, [r7, #6]
  const uint8_t  *pdata8bits;
  const uint16_t *pdata16bits;
  uint32_t tickstart;

  /* Check that a Tx process is not already ongoing */
  if (huart->gState == HAL_UART_STATE_READY)
 8005658:	68fb      	ldr	r3, [r7, #12]
 800565a:	f8d3 3084 	ldr.w	r3, [r3, #132]	; 0x84
 800565e:	2b20      	cmp	r3, #32
 8005660:	f040 8083 	bne.w	800576a <HAL_UART_Transmit+0x122>
  {
    if ((pData == NULL) || (Size == 0U))
 8005664:	68bb      	ldr	r3, [r7, #8]
 8005666:	2b00      	cmp	r3, #0
 8005668:	d002      	beq.n	8005670 <HAL_UART_Transmit+0x28>
 800566a:	88fb      	ldrh	r3, [r7, #6]
 800566c:	2b00      	cmp	r3, #0
 800566e:	d101      	bne.n	8005674 <HAL_UART_Transmit+0x2c>
    {
      return  HAL_ERROR;
 8005670:	2301      	movs	r3, #1
 8005672:	e07b      	b.n	800576c <HAL_UART_Transmit+0x124>
    }

    __HAL_LOCK(huart);
 8005674:	68fb      	ldr	r3, [r7, #12]
 8005676:	f893 3080 	ldrb.w	r3, [r3, #128]	; 0x80
 800567a:	2b01      	cmp	r3, #1
 800567c:	d101      	bne.n	8005682 <HAL_UART_Transmit+0x3a>
 800567e:	2302      	movs	r3, #2
 8005680:	e074      	b.n	800576c <HAL_UART_Transmit+0x124>
 8005682:	68fb      	ldr	r3, [r7, #12]
 8005684:	2201      	movs	r2, #1
 8005686:	f883 2080 	strb.w	r2, [r3, #128]	; 0x80

    huart->ErrorCode = HAL_UART_ERROR_NONE;
 800568a:	68fb      	ldr	r3, [r7, #12]
 800568c:	2200      	movs	r2, #0
 800568e:	f8c3 208c 	str.w	r2, [r3, #140]	; 0x8c
    huart->gState = HAL_UART_STATE_BUSY_TX;
 8005692:	68fb      	ldr	r3, [r7, #12]
 8005694:	2221      	movs	r2, #33	; 0x21
 8005696:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84

    /* Init tickstart for timeout management */
    tickstart = HAL_GetTick();
 800569a:	f7fc f84d 	bl	8001738 <HAL_GetTick>
 800569e:	6178      	str	r0, [r7, #20]

    huart->TxXferSize  = Size;
 80056a0:	68fb      	ldr	r3, [r7, #12]
 80056a2:	88fa      	ldrh	r2, [r7, #6]
 80056a4:	f8a3 2054 	strh.w	r2, [r3, #84]	; 0x54
    huart->TxXferCount = Size;
 80056a8:	68fb      	ldr	r3, [r7, #12]
 80056aa:	88fa      	ldrh	r2, [r7, #6]
 80056ac:	f8a3 2056 	strh.w	r2, [r3, #86]	; 0x56

    /* In case of 9bits/No Parity transfer, pData needs to be handled as a uint16_t pointer */
    if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))
 80056b0:	68fb      	ldr	r3, [r7, #12]
 80056b2:	689b      	ldr	r3, [r3, #8]
 80056b4:	f5b3 5f80 	cmp.w	r3, #4096	; 0x1000
 80056b8:	d108      	bne.n	80056cc <HAL_UART_Transmit+0x84>
 80056ba:	68fb      	ldr	r3, [r7, #12]
 80056bc:	691b      	ldr	r3, [r3, #16]
 80056be:	2b00      	cmp	r3, #0
 80056c0:	d104      	bne.n	80056cc <HAL_UART_Transmit+0x84>
    {
      pdata8bits  = NULL;
 80056c2:	2300      	movs	r3, #0
 80056c4:	61fb      	str	r3, [r7, #28]
      pdata16bits = (const uint16_t *) pData;
 80056c6:	68bb      	ldr	r3, [r7, #8]
 80056c8:	61bb      	str	r3, [r7, #24]
 80056ca:	e003      	b.n	80056d4 <HAL_UART_Transmit+0x8c>
    }
    else
    {
      pdata8bits  = pData;
 80056cc:	68bb      	ldr	r3, [r7, #8]
 80056ce:	61fb      	str	r3, [r7, #28]
      pdata16bits = NULL;
 80056d0:	2300      	movs	r3, #0
 80056d2:	61bb      	str	r3, [r7, #24]
    }

    __HAL_UNLOCK(huart);
 80056d4:	68fb      	ldr	r3, [r7, #12]
 80056d6:	2200      	movs	r2, #0
 80056d8:	f883 2080 	strb.w	r2, [r3, #128]	; 0x80

    while (huart->TxXferCount > 0U)
 80056dc:	e02c      	b.n	8005738 <HAL_UART_Transmit+0xf0>
    {
      if (UART_WaitOnFlagUntilTimeout(huart, UART_FLAG_TXE, RESET, tickstart, Timeout) != HAL_OK)
 80056de:	683b      	ldr	r3, [r7, #0]
 80056e0:	9300      	str	r3, [sp, #0]
 80056e2:	697b      	ldr	r3, [r7, #20]
 80056e4:	2200      	movs	r2, #0
 80056e6:	2180      	movs	r1, #128	; 0x80
 80056e8:	68f8      	ldr	r0, [r7, #12]
 80056ea:	f000 fe98 	bl	800641e <UART_WaitOnFlagUntilTimeout>
 80056ee:	4603      	mov	r3, r0
 80056f0:	2b00      	cmp	r3, #0
 80056f2:	d001      	beq.n	80056f8 <HAL_UART_Transmit+0xb0>
      {
        return HAL_TIMEOUT;
 80056f4:	2303      	movs	r3, #3
 80056f6:	e039      	b.n	800576c <HAL_UART_Transmit+0x124>
      }
      if (pdata8bits == NULL)
 80056f8:	69fb      	ldr	r3, [r7, #28]
 80056fa:	2b00      	cmp	r3, #0
 80056fc:	d10b      	bne.n	8005716 <HAL_UART_Transmit+0xce>
      {
        huart->Instance->TDR = (uint16_t)(*pdata16bits & 0x01FFU);
 80056fe:	69bb      	ldr	r3, [r7, #24]
 8005700:	881b      	ldrh	r3, [r3, #0]
 8005702:	461a      	mov	r2, r3
 8005704:	68fb      	ldr	r3, [r7, #12]
 8005706:	681b      	ldr	r3, [r3, #0]
 8005708:	f3c2 0208 	ubfx	r2, r2, #0, #9
 800570c:	629a      	str	r2, [r3, #40]	; 0x28
        pdata16bits++;
 800570e:	69bb      	ldr	r3, [r7, #24]
 8005710:	3302      	adds	r3, #2
 8005712:	61bb      	str	r3, [r7, #24]
 8005714:	e007      	b.n	8005726 <HAL_UART_Transmit+0xde>
      }
      else
      {
        huart->Instance->TDR = (uint8_t)(*pdata8bits & 0xFFU);
 8005716:	69fb      	ldr	r3, [r7, #28]
 8005718:	781a      	ldrb	r2, [r3, #0]
 800571a:	68fb      	ldr	r3, [r7, #12]
 800571c:	681b      	ldr	r3, [r3, #0]
 800571e:	629a      	str	r2, [r3, #40]	; 0x28
        pdata8bits++;
 8005720:	69fb      	ldr	r3, [r7, #28]
 8005722:	3301      	adds	r3, #1
 8005724:	61fb      	str	r3, [r7, #28]
      }
      huart->TxXferCount--;
 8005726:	68fb      	ldr	r3, [r7, #12]
 8005728:	f8b3 3056 	ldrh.w	r3, [r3, #86]	; 0x56
 800572c:	b29b      	uxth	r3, r3
 800572e:	3b01      	subs	r3, #1
 8005730:	b29a      	uxth	r2, r3
 8005732:	68fb      	ldr	r3, [r7, #12]
 8005734:	f8a3 2056 	strh.w	r2, [r3, #86]	; 0x56
    while (huart->TxXferCount > 0U)
 8005738:	68fb      	ldr	r3, [r7, #12]
 800573a:	f8b3 3056 	ldrh.w	r3, [r3, #86]	; 0x56
 800573e:	b29b      	uxth	r3, r3
 8005740:	2b00      	cmp	r3, #0
 8005742:	d1cc      	bne.n	80056de <HAL_UART_Transmit+0x96>
    }

    if (UART_WaitOnFlagUntilTimeout(huart, UART_FLAG_TC, RESET, tickstart, Timeout) != HAL_OK)
 8005744:	683b      	ldr	r3, [r7, #0]
 8005746:	9300      	str	r3, [sp, #0]
 8005748:	697b      	ldr	r3, [r7, #20]
 800574a:	2200      	movs	r2, #0
 800574c:	2140      	movs	r1, #64	; 0x40
 800574e:	68f8      	ldr	r0, [r7, #12]
 8005750:	f000 fe65 	bl	800641e <UART_WaitOnFlagUntilTimeout>
 8005754:	4603      	mov	r3, r0
 8005756:	2b00      	cmp	r3, #0
 8005758:	d001      	beq.n	800575e <HAL_UART_Transmit+0x116>
    {
      return HAL_TIMEOUT;
 800575a:	2303      	movs	r3, #3
 800575c:	e006      	b.n	800576c <HAL_UART_Transmit+0x124>
    }

    /* At end of Tx process, restore huart->gState to Ready */
    huart->gState = HAL_UART_STATE_READY;
 800575e:	68fb      	ldr	r3, [r7, #12]
 8005760:	2220      	movs	r2, #32
 8005762:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84

    return HAL_OK;
 8005766:	2300      	movs	r3, #0
 8005768:	e000      	b.n	800576c <HAL_UART_Transmit+0x124>
  }
  else
  {
    return HAL_BUSY;
 800576a:	2302      	movs	r3, #2
  }
}
 800576c:	4618      	mov	r0, r3
 800576e:	3720      	adds	r7, #32
 8005770:	46bd      	mov	sp, r7
 8005772:	bd80      	pop	{r7, pc}

08005774 <UART_SetConfig>:
  * @brief Configure the UART peripheral.
  * @param huart UART handle.
  * @retval HAL status
  */
HAL_StatusTypeDef UART_SetConfig(UART_HandleTypeDef *huart)
{
 8005774:	e92d 4fb0 	stmdb	sp!, {r4, r5, r7, r8, r9, sl, fp, lr}
 8005778:	b092      	sub	sp, #72	; 0x48
 800577a:	af00      	add	r7, sp, #0
 800577c:	6178      	str	r0, [r7, #20]
  uint32_t tmpreg;
  uint16_t brrtemp;
  UART_ClockSourceTypeDef clocksource;
  uint32_t usartdiv;
  HAL_StatusTypeDef ret               = HAL_OK;
 800577e:	2300      	movs	r3, #0
 8005780:	f887 3042 	strb.w	r3, [r7, #66]	; 0x42
  *  the UART Word Length, Parity, Mode and oversampling:
  *  set the M bits according to huart->Init.WordLength value
  *  set PCE and PS bits according to huart->Init.Parity value
  *  set TE and RE bits according to huart->Init.Mode value
  *  set OVER8 bit according to huart->Init.OverSampling value */
  tmpreg = (uint32_t)huart->Init.WordLength | huart->Init.Parity | huart->Init.Mode | huart->Init.OverSampling ;
 8005784:	697b      	ldr	r3, [r7, #20]
 8005786:	689a      	ldr	r2, [r3, #8]
 8005788:	697b      	ldr	r3, [r7, #20]
 800578a:	691b      	ldr	r3, [r3, #16]
 800578c:	431a      	orrs	r2, r3
 800578e:	697b      	ldr	r3, [r7, #20]
 8005790:	695b      	ldr	r3, [r3, #20]
 8005792:	431a      	orrs	r2, r3
 8005794:	697b      	ldr	r3, [r7, #20]
 8005796:	69db      	ldr	r3, [r3, #28]
 8005798:	4313      	orrs	r3, r2
 800579a:	647b      	str	r3, [r7, #68]	; 0x44
  MODIFY_REG(huart->Instance->CR1, USART_CR1_FIELDS, tmpreg);
 800579c:	697b      	ldr	r3, [r7, #20]
 800579e:	681b      	ldr	r3, [r3, #0]
 80057a0:	681a      	ldr	r2, [r3, #0]
 80057a2:	4bbe      	ldr	r3, [pc, #760]	; (8005a9c <UART_SetConfig+0x328>)
 80057a4:	4013      	ands	r3, r2
 80057a6:	697a      	ldr	r2, [r7, #20]
 80057a8:	6812      	ldr	r2, [r2, #0]
 80057aa:	6c79      	ldr	r1, [r7, #68]	; 0x44
 80057ac:	430b      	orrs	r3, r1
 80057ae:	6013      	str	r3, [r2, #0]

  /*-------------------------- USART CR2 Configuration -----------------------*/
  /* Configure the UART Stop Bits: Set STOP[13:12] bits according
  * to huart->Init.StopBits value */
  MODIFY_REG(huart->Instance->CR2, USART_CR2_STOP, huart->Init.StopBits);
 80057b0:	697b      	ldr	r3, [r7, #20]
 80057b2:	681b      	ldr	r3, [r3, #0]
 80057b4:	685b      	ldr	r3, [r3, #4]
 80057b6:	f423 5140 	bic.w	r1, r3, #12288	; 0x3000
 80057ba:	697b      	ldr	r3, [r7, #20]
 80057bc:	68da      	ldr	r2, [r3, #12]
 80057be:	697b      	ldr	r3, [r7, #20]
 80057c0:	681b      	ldr	r3, [r3, #0]
 80057c2:	430a      	orrs	r2, r1
 80057c4:	605a      	str	r2, [r3, #4]
  /* Configure
  * - UART HardWare Flow Control: set CTSE and RTSE bits according
  *   to huart->Init.HwFlowCtl value
  * - one-bit sampling method versus three samples' majority rule according
  *   to huart->Init.OneBitSampling (not applicable to LPUART) */
  tmpreg = (uint32_t)huart->Init.HwFlowCtl;
 80057c6:	697b      	ldr	r3, [r7, #20]
 80057c8:	699b      	ldr	r3, [r3, #24]
 80057ca:	647b      	str	r3, [r7, #68]	; 0x44

  if (!(UART_INSTANCE_LOWPOWER(huart)))
 80057cc:	697b      	ldr	r3, [r7, #20]
 80057ce:	681b      	ldr	r3, [r3, #0]
 80057d0:	4ab3      	ldr	r2, [pc, #716]	; (8005aa0 <UART_SetConfig+0x32c>)
 80057d2:	4293      	cmp	r3, r2
 80057d4:	d004      	beq.n	80057e0 <UART_SetConfig+0x6c>
  {
    tmpreg |= huart->Init.OneBitSampling;
 80057d6:	697b      	ldr	r3, [r7, #20]
 80057d8:	6a1b      	ldr	r3, [r3, #32]
 80057da:	6c7a      	ldr	r2, [r7, #68]	; 0x44
 80057dc:	4313      	orrs	r3, r2
 80057de:	647b      	str	r3, [r7, #68]	; 0x44
  }
  MODIFY_REG(huart->Instance->CR3, USART_CR3_FIELDS, tmpreg);
 80057e0:	697b      	ldr	r3, [r7, #20]
 80057e2:	681b      	ldr	r3, [r3, #0]
 80057e4:	689a      	ldr	r2, [r3, #8]
 80057e6:	4baf      	ldr	r3, [pc, #700]	; (8005aa4 <UART_SetConfig+0x330>)
 80057e8:	4013      	ands	r3, r2
 80057ea:	697a      	ldr	r2, [r7, #20]
 80057ec:	6812      	ldr	r2, [r2, #0]
 80057ee:	6c79      	ldr	r1, [r7, #68]	; 0x44
 80057f0:	430b      	orrs	r3, r1
 80057f2:	6093      	str	r3, [r2, #8]

  /*-------------------------- USART PRESC Configuration -----------------------*/
  /* Configure
  * - UART Clock Prescaler : set PRESCALER according to huart->Init.ClockPrescaler value */
  MODIFY_REG(huart->Instance->PRESC, USART_PRESC_PRESCALER, huart->Init.ClockPrescaler);
 80057f4:	697b      	ldr	r3, [r7, #20]
 80057f6:	681b      	ldr	r3, [r3, #0]
 80057f8:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 80057fa:	f023 010f 	bic.w	r1, r3, #15
 80057fe:	697b      	ldr	r3, [r7, #20]
 8005800:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 8005802:	697b      	ldr	r3, [r7, #20]
 8005804:	681b      	ldr	r3, [r3, #0]
 8005806:	430a      	orrs	r2, r1
 8005808:	62da      	str	r2, [r3, #44]	; 0x2c

  /*-------------------------- USART BRR Configuration -----------------------*/
  UART_GETCLOCKSOURCE(huart, clocksource);
 800580a:	697b      	ldr	r3, [r7, #20]
 800580c:	681b      	ldr	r3, [r3, #0]
 800580e:	4aa6      	ldr	r2, [pc, #664]	; (8005aa8 <UART_SetConfig+0x334>)
 8005810:	4293      	cmp	r3, r2
 8005812:	d177      	bne.n	8005904 <UART_SetConfig+0x190>
 8005814:	4ba5      	ldr	r3, [pc, #660]	; (8005aac <UART_SetConfig+0x338>)
 8005816:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 8005818:	f003 0338 	and.w	r3, r3, #56	; 0x38
 800581c:	2b28      	cmp	r3, #40	; 0x28
 800581e:	d86d      	bhi.n	80058fc <UART_SetConfig+0x188>
 8005820:	a201      	add	r2, pc, #4	; (adr r2, 8005828 <UART_SetConfig+0xb4>)
 8005822:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8005826:	bf00      	nop
 8005828:	080058cd 	.word	0x080058cd
 800582c:	080058fd 	.word	0x080058fd
 8005830:	080058fd 	.word	0x080058fd
 8005834:	080058fd 	.word	0x080058fd
 8005838:	080058fd 	.word	0x080058fd
 800583c:	080058fd 	.word	0x080058fd
 8005840:	080058fd 	.word	0x080058fd
 8005844:	080058fd 	.word	0x080058fd
 8005848:	080058d5 	.word	0x080058d5
 800584c:	080058fd 	.word	0x080058fd
 8005850:	080058fd 	.word	0x080058fd
 8005854:	080058fd 	.word	0x080058fd
 8005858:	080058fd 	.word	0x080058fd
 800585c:	080058fd 	.word	0x080058fd
 8005860:	080058fd 	.word	0x080058fd
 8005864:	080058fd 	.word	0x080058fd
 8005868:	080058dd 	.word	0x080058dd
 800586c:	080058fd 	.word	0x080058fd
 8005870:	080058fd 	.word	0x080058fd
 8005874:	080058fd 	.word	0x080058fd
 8005878:	080058fd 	.word	0x080058fd
 800587c:	080058fd 	.word	0x080058fd
 8005880:	080058fd 	.word	0x080058fd
 8005884:	080058fd 	.word	0x080058fd
 8005888:	080058e5 	.word	0x080058e5
 800588c:	080058fd 	.word	0x080058fd
 8005890:	080058fd 	.word	0x080058fd
 8005894:	080058fd 	.word	0x080058fd
 8005898:	080058fd 	.word	0x080058fd
 800589c:	080058fd 	.word	0x080058fd
 80058a0:	080058fd 	.word	0x080058fd
 80058a4:	080058fd 	.word	0x080058fd
 80058a8:	080058ed 	.word	0x080058ed
 80058ac:	080058fd 	.word	0x080058fd
 80058b0:	080058fd 	.word	0x080058fd
 80058b4:	080058fd 	.word	0x080058fd
 80058b8:	080058fd 	.word	0x080058fd
 80058bc:	080058fd 	.word	0x080058fd
 80058c0:	080058fd 	.word	0x080058fd
 80058c4:	080058fd 	.word	0x080058fd
 80058c8:	080058f5 	.word	0x080058f5
 80058cc:	2301      	movs	r3, #1
 80058ce:	f887 3043 	strb.w	r3, [r7, #67]	; 0x43
 80058d2:	e222      	b.n	8005d1a <UART_SetConfig+0x5a6>
 80058d4:	2304      	movs	r3, #4
 80058d6:	f887 3043 	strb.w	r3, [r7, #67]	; 0x43
 80058da:	e21e      	b.n	8005d1a <UART_SetConfig+0x5a6>
 80058dc:	2308      	movs	r3, #8
 80058de:	f887 3043 	strb.w	r3, [r7, #67]	; 0x43
 80058e2:	e21a      	b.n	8005d1a <UART_SetConfig+0x5a6>
 80058e4:	2310      	movs	r3, #16
 80058e6:	f887 3043 	strb.w	r3, [r7, #67]	; 0x43
 80058ea:	e216      	b.n	8005d1a <UART_SetConfig+0x5a6>
 80058ec:	2320      	movs	r3, #32
 80058ee:	f887 3043 	strb.w	r3, [r7, #67]	; 0x43
 80058f2:	e212      	b.n	8005d1a <UART_SetConfig+0x5a6>
 80058f4:	2340      	movs	r3, #64	; 0x40
 80058f6:	f887 3043 	strb.w	r3, [r7, #67]	; 0x43
 80058fa:	e20e      	b.n	8005d1a <UART_SetConfig+0x5a6>
 80058fc:	2380      	movs	r3, #128	; 0x80
 80058fe:	f887 3043 	strb.w	r3, [r7, #67]	; 0x43
 8005902:	e20a      	b.n	8005d1a <UART_SetConfig+0x5a6>
 8005904:	697b      	ldr	r3, [r7, #20]
 8005906:	681b      	ldr	r3, [r3, #0]
 8005908:	4a69      	ldr	r2, [pc, #420]	; (8005ab0 <UART_SetConfig+0x33c>)
 800590a:	4293      	cmp	r3, r2
 800590c:	d130      	bne.n	8005970 <UART_SetConfig+0x1fc>
 800590e:	4b67      	ldr	r3, [pc, #412]	; (8005aac <UART_SetConfig+0x338>)
 8005910:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 8005912:	f003 0307 	and.w	r3, r3, #7
 8005916:	2b05      	cmp	r3, #5
 8005918:	d826      	bhi.n	8005968 <UART_SetConfig+0x1f4>
 800591a:	a201      	add	r2, pc, #4	; (adr r2, 8005920 <UART_SetConfig+0x1ac>)
 800591c:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8005920:	08005939 	.word	0x08005939
 8005924:	08005941 	.word	0x08005941
 8005928:	08005949 	.word	0x08005949
 800592c:	08005951 	.word	0x08005951
 8005930:	08005959 	.word	0x08005959
 8005934:	08005961 	.word	0x08005961
 8005938:	2300      	movs	r3, #0
 800593a:	f887 3043 	strb.w	r3, [r7, #67]	; 0x43
 800593e:	e1ec      	b.n	8005d1a <UART_SetConfig+0x5a6>
 8005940:	2304      	movs	r3, #4
 8005942:	f887 3043 	strb.w	r3, [r7, #67]	; 0x43
 8005946:	e1e8      	b.n	8005d1a <UART_SetConfig+0x5a6>
 8005948:	2308      	movs	r3, #8
 800594a:	f887 3043 	strb.w	r3, [r7, #67]	; 0x43
 800594e:	e1e4      	b.n	8005d1a <UART_SetConfig+0x5a6>
 8005950:	2310      	movs	r3, #16
 8005952:	f887 3043 	strb.w	r3, [r7, #67]	; 0x43
 8005956:	e1e0      	b.n	8005d1a <UART_SetConfig+0x5a6>
 8005958:	2320      	movs	r3, #32
 800595a:	f887 3043 	strb.w	r3, [r7, #67]	; 0x43
 800595e:	e1dc      	b.n	8005d1a <UART_SetConfig+0x5a6>
 8005960:	2340      	movs	r3, #64	; 0x40
 8005962:	f887 3043 	strb.w	r3, [r7, #67]	; 0x43
 8005966:	e1d8      	b.n	8005d1a <UART_SetConfig+0x5a6>
 8005968:	2380      	movs	r3, #128	; 0x80
 800596a:	f887 3043 	strb.w	r3, [r7, #67]	; 0x43
 800596e:	e1d4      	b.n	8005d1a <UART_SetConfig+0x5a6>
 8005970:	697b      	ldr	r3, [r7, #20]
 8005972:	681b      	ldr	r3, [r3, #0]
 8005974:	4a4f      	ldr	r2, [pc, #316]	; (8005ab4 <UART_SetConfig+0x340>)
 8005976:	4293      	cmp	r3, r2
 8005978:	d130      	bne.n	80059dc <UART_SetConfig+0x268>
 800597a:	4b4c      	ldr	r3, [pc, #304]	; (8005aac <UART_SetConfig+0x338>)
 800597c:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 800597e:	f003 0307 	and.w	r3, r3, #7
 8005982:	2b05      	cmp	r3, #5
 8005984:	d826      	bhi.n	80059d4 <UART_SetConfig+0x260>
 8005986:	a201      	add	r2, pc, #4	; (adr r2, 800598c <UART_SetConfig+0x218>)
 8005988:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 800598c:	080059a5 	.word	0x080059a5
 8005990:	080059ad 	.word	0x080059ad
 8005994:	080059b5 	.word	0x080059b5
 8005998:	080059bd 	.word	0x080059bd
 800599c:	080059c5 	.word	0x080059c5
 80059a0:	080059cd 	.word	0x080059cd
 80059a4:	2300      	movs	r3, #0
 80059a6:	f887 3043 	strb.w	r3, [r7, #67]	; 0x43
 80059aa:	e1b6      	b.n	8005d1a <UART_SetConfig+0x5a6>
 80059ac:	2304      	movs	r3, #4
 80059ae:	f887 3043 	strb.w	r3, [r7, #67]	; 0x43
 80059b2:	e1b2      	b.n	8005d1a <UART_SetConfig+0x5a6>
 80059b4:	2308      	movs	r3, #8
 80059b6:	f887 3043 	strb.w	r3, [r7, #67]	; 0x43
 80059ba:	e1ae      	b.n	8005d1a <UART_SetConfig+0x5a6>
 80059bc:	2310      	movs	r3, #16
 80059be:	f887 3043 	strb.w	r3, [r7, #67]	; 0x43
 80059c2:	e1aa      	b.n	8005d1a <UART_SetConfig+0x5a6>
 80059c4:	2320      	movs	r3, #32
 80059c6:	f887 3043 	strb.w	r3, [r7, #67]	; 0x43
 80059ca:	e1a6      	b.n	8005d1a <UART_SetConfig+0x5a6>
 80059cc:	2340      	movs	r3, #64	; 0x40
 80059ce:	f887 3043 	strb.w	r3, [r7, #67]	; 0x43
 80059d2:	e1a2      	b.n	8005d1a <UART_SetConfig+0x5a6>
 80059d4:	2380      	movs	r3, #128	; 0x80
 80059d6:	f887 3043 	strb.w	r3, [r7, #67]	; 0x43
 80059da:	e19e      	b.n	8005d1a <UART_SetConfig+0x5a6>
 80059dc:	697b      	ldr	r3, [r7, #20]
 80059de:	681b      	ldr	r3, [r3, #0]
 80059e0:	4a35      	ldr	r2, [pc, #212]	; (8005ab8 <UART_SetConfig+0x344>)
 80059e2:	4293      	cmp	r3, r2
 80059e4:	d130      	bne.n	8005a48 <UART_SetConfig+0x2d4>
 80059e6:	4b31      	ldr	r3, [pc, #196]	; (8005aac <UART_SetConfig+0x338>)
 80059e8:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 80059ea:	f003 0307 	and.w	r3, r3, #7
 80059ee:	2b05      	cmp	r3, #5
 80059f0:	d826      	bhi.n	8005a40 <UART_SetConfig+0x2cc>
 80059f2:	a201      	add	r2, pc, #4	; (adr r2, 80059f8 <UART_SetConfig+0x284>)
 80059f4:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 80059f8:	08005a11 	.word	0x08005a11
 80059fc:	08005a19 	.word	0x08005a19
 8005a00:	08005a21 	.word	0x08005a21
 8005a04:	08005a29 	.word	0x08005a29
 8005a08:	08005a31 	.word	0x08005a31
 8005a0c:	08005a39 	.word	0x08005a39
 8005a10:	2300      	movs	r3, #0
 8005a12:	f887 3043 	strb.w	r3, [r7, #67]	; 0x43
 8005a16:	e180      	b.n	8005d1a <UART_SetConfig+0x5a6>
 8005a18:	2304      	movs	r3, #4
 8005a1a:	f887 3043 	strb.w	r3, [r7, #67]	; 0x43
 8005a1e:	e17c      	b.n	8005d1a <UART_SetConfig+0x5a6>
 8005a20:	2308      	movs	r3, #8
 8005a22:	f887 3043 	strb.w	r3, [r7, #67]	; 0x43
 8005a26:	e178      	b.n	8005d1a <UART_SetConfig+0x5a6>
 8005a28:	2310      	movs	r3, #16
 8005a2a:	f887 3043 	strb.w	r3, [r7, #67]	; 0x43
 8005a2e:	e174      	b.n	8005d1a <UART_SetConfig+0x5a6>
 8005a30:	2320      	movs	r3, #32
 8005a32:	f887 3043 	strb.w	r3, [r7, #67]	; 0x43
 8005a36:	e170      	b.n	8005d1a <UART_SetConfig+0x5a6>
 8005a38:	2340      	movs	r3, #64	; 0x40
 8005a3a:	f887 3043 	strb.w	r3, [r7, #67]	; 0x43
 8005a3e:	e16c      	b.n	8005d1a <UART_SetConfig+0x5a6>
 8005a40:	2380      	movs	r3, #128	; 0x80
 8005a42:	f887 3043 	strb.w	r3, [r7, #67]	; 0x43
 8005a46:	e168      	b.n	8005d1a <UART_SetConfig+0x5a6>
 8005a48:	697b      	ldr	r3, [r7, #20]
 8005a4a:	681b      	ldr	r3, [r3, #0]
 8005a4c:	4a1b      	ldr	r2, [pc, #108]	; (8005abc <UART_SetConfig+0x348>)
 8005a4e:	4293      	cmp	r3, r2
 8005a50:	d142      	bne.n	8005ad8 <UART_SetConfig+0x364>
 8005a52:	4b16      	ldr	r3, [pc, #88]	; (8005aac <UART_SetConfig+0x338>)
 8005a54:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 8005a56:	f003 0307 	and.w	r3, r3, #7
 8005a5a:	2b05      	cmp	r3, #5
 8005a5c:	d838      	bhi.n	8005ad0 <UART_SetConfig+0x35c>
 8005a5e:	a201      	add	r2, pc, #4	; (adr r2, 8005a64 <UART_SetConfig+0x2f0>)
 8005a60:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8005a64:	08005a7d 	.word	0x08005a7d
 8005a68:	08005a85 	.word	0x08005a85
 8005a6c:	08005a8d 	.word	0x08005a8d
 8005a70:	08005a95 	.word	0x08005a95
 8005a74:	08005ac1 	.word	0x08005ac1
 8005a78:	08005ac9 	.word	0x08005ac9
 8005a7c:	2300      	movs	r3, #0
 8005a7e:	f887 3043 	strb.w	r3, [r7, #67]	; 0x43
 8005a82:	e14a      	b.n	8005d1a <UART_SetConfig+0x5a6>
 8005a84:	2304      	movs	r3, #4
 8005a86:	f887 3043 	strb.w	r3, [r7, #67]	; 0x43
 8005a8a:	e146      	b.n	8005d1a <UART_SetConfig+0x5a6>
 8005a8c:	2308      	movs	r3, #8
 8005a8e:	f887 3043 	strb.w	r3, [r7, #67]	; 0x43
 8005a92:	e142      	b.n	8005d1a <UART_SetConfig+0x5a6>
 8005a94:	2310      	movs	r3, #16
 8005a96:	f887 3043 	strb.w	r3, [r7, #67]	; 0x43
 8005a9a:	e13e      	b.n	8005d1a <UART_SetConfig+0x5a6>
 8005a9c:	cfff69f3 	.word	0xcfff69f3
 8005aa0:	58000c00 	.word	0x58000c00
 8005aa4:	11fff4ff 	.word	0x11fff4ff
 8005aa8:	40011000 	.word	0x40011000
 8005aac:	58024400 	.word	0x58024400
 8005ab0:	40004400 	.word	0x40004400
 8005ab4:	40004800 	.word	0x40004800
 8005ab8:	40004c00 	.word	0x40004c00
 8005abc:	40005000 	.word	0x40005000
 8005ac0:	2320      	movs	r3, #32
 8005ac2:	f887 3043 	strb.w	r3, [r7, #67]	; 0x43
 8005ac6:	e128      	b.n	8005d1a <UART_SetConfig+0x5a6>
 8005ac8:	2340      	movs	r3, #64	; 0x40
 8005aca:	f887 3043 	strb.w	r3, [r7, #67]	; 0x43
 8005ace:	e124      	b.n	8005d1a <UART_SetConfig+0x5a6>
 8005ad0:	2380      	movs	r3, #128	; 0x80
 8005ad2:	f887 3043 	strb.w	r3, [r7, #67]	; 0x43
 8005ad6:	e120      	b.n	8005d1a <UART_SetConfig+0x5a6>
 8005ad8:	697b      	ldr	r3, [r7, #20]
 8005ada:	681b      	ldr	r3, [r3, #0]
 8005adc:	4acb      	ldr	r2, [pc, #812]	; (8005e0c <UART_SetConfig+0x698>)
 8005ade:	4293      	cmp	r3, r2
 8005ae0:	d176      	bne.n	8005bd0 <UART_SetConfig+0x45c>
 8005ae2:	4bcb      	ldr	r3, [pc, #812]	; (8005e10 <UART_SetConfig+0x69c>)
 8005ae4:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 8005ae6:	f003 0338 	and.w	r3, r3, #56	; 0x38
 8005aea:	2b28      	cmp	r3, #40	; 0x28
 8005aec:	d86c      	bhi.n	8005bc8 <UART_SetConfig+0x454>
 8005aee:	a201      	add	r2, pc, #4	; (adr r2, 8005af4 <UART_SetConfig+0x380>)
 8005af0:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8005af4:	08005b99 	.word	0x08005b99
 8005af8:	08005bc9 	.word	0x08005bc9
 8005afc:	08005bc9 	.word	0x08005bc9
 8005b00:	08005bc9 	.word	0x08005bc9
 8005b04:	08005bc9 	.word	0x08005bc9
 8005b08:	08005bc9 	.word	0x08005bc9
 8005b0c:	08005bc9 	.word	0x08005bc9
 8005b10:	08005bc9 	.word	0x08005bc9
 8005b14:	08005ba1 	.word	0x08005ba1
 8005b18:	08005bc9 	.word	0x08005bc9
 8005b1c:	08005bc9 	.word	0x08005bc9
 8005b20:	08005bc9 	.word	0x08005bc9
 8005b24:	08005bc9 	.word	0x08005bc9
 8005b28:	08005bc9 	.word	0x08005bc9
 8005b2c:	08005bc9 	.word	0x08005bc9
 8005b30:	08005bc9 	.word	0x08005bc9
 8005b34:	08005ba9 	.word	0x08005ba9
 8005b38:	08005bc9 	.word	0x08005bc9
 8005b3c:	08005bc9 	.word	0x08005bc9
 8005b40:	08005bc9 	.word	0x08005bc9
 8005b44:	08005bc9 	.word	0x08005bc9
 8005b48:	08005bc9 	.word	0x08005bc9
 8005b4c:	08005bc9 	.word	0x08005bc9
 8005b50:	08005bc9 	.word	0x08005bc9
 8005b54:	08005bb1 	.word	0x08005bb1
 8005b58:	08005bc9 	.word	0x08005bc9
 8005b5c:	08005bc9 	.word	0x08005bc9
 8005b60:	08005bc9 	.word	0x08005bc9
 8005b64:	08005bc9 	.word	0x08005bc9
 8005b68:	08005bc9 	.word	0x08005bc9
 8005b6c:	08005bc9 	.word	0x08005bc9
 8005b70:	08005bc9 	.word	0x08005bc9
 8005b74:	08005bb9 	.word	0x08005bb9
 8005b78:	08005bc9 	.word	0x08005bc9
 8005b7c:	08005bc9 	.word	0x08005bc9
 8005b80:	08005bc9 	.word	0x08005bc9
 8005b84:	08005bc9 	.word	0x08005bc9
 8005b88:	08005bc9 	.word	0x08005bc9
 8005b8c:	08005bc9 	.word	0x08005bc9
 8005b90:	08005bc9 	.word	0x08005bc9
 8005b94:	08005bc1 	.word	0x08005bc1
 8005b98:	2301      	movs	r3, #1
 8005b9a:	f887 3043 	strb.w	r3, [r7, #67]	; 0x43
 8005b9e:	e0bc      	b.n	8005d1a <UART_SetConfig+0x5a6>
 8005ba0:	2304      	movs	r3, #4
 8005ba2:	f887 3043 	strb.w	r3, [r7, #67]	; 0x43
 8005ba6:	e0b8      	b.n	8005d1a <UART_SetConfig+0x5a6>
 8005ba8:	2308      	movs	r3, #8
 8005baa:	f887 3043 	strb.w	r3, [r7, #67]	; 0x43
 8005bae:	e0b4      	b.n	8005d1a <UART_SetConfig+0x5a6>
 8005bb0:	2310      	movs	r3, #16
 8005bb2:	f887 3043 	strb.w	r3, [r7, #67]	; 0x43
 8005bb6:	e0b0      	b.n	8005d1a <UART_SetConfig+0x5a6>
 8005bb8:	2320      	movs	r3, #32
 8005bba:	f887 3043 	strb.w	r3, [r7, #67]	; 0x43
 8005bbe:	e0ac      	b.n	8005d1a <UART_SetConfig+0x5a6>
 8005bc0:	2340      	movs	r3, #64	; 0x40
 8005bc2:	f887 3043 	strb.w	r3, [r7, #67]	; 0x43
 8005bc6:	e0a8      	b.n	8005d1a <UART_SetConfig+0x5a6>
 8005bc8:	2380      	movs	r3, #128	; 0x80
 8005bca:	f887 3043 	strb.w	r3, [r7, #67]	; 0x43
 8005bce:	e0a4      	b.n	8005d1a <UART_SetConfig+0x5a6>
 8005bd0:	697b      	ldr	r3, [r7, #20]
 8005bd2:	681b      	ldr	r3, [r3, #0]
 8005bd4:	4a8f      	ldr	r2, [pc, #572]	; (8005e14 <UART_SetConfig+0x6a0>)
 8005bd6:	4293      	cmp	r3, r2
 8005bd8:	d130      	bne.n	8005c3c <UART_SetConfig+0x4c8>
 8005bda:	4b8d      	ldr	r3, [pc, #564]	; (8005e10 <UART_SetConfig+0x69c>)
 8005bdc:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 8005bde:	f003 0307 	and.w	r3, r3, #7
 8005be2:	2b05      	cmp	r3, #5
 8005be4:	d826      	bhi.n	8005c34 <UART_SetConfig+0x4c0>
 8005be6:	a201      	add	r2, pc, #4	; (adr r2, 8005bec <UART_SetConfig+0x478>)
 8005be8:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8005bec:	08005c05 	.word	0x08005c05
 8005bf0:	08005c0d 	.word	0x08005c0d
 8005bf4:	08005c15 	.word	0x08005c15
 8005bf8:	08005c1d 	.word	0x08005c1d
 8005bfc:	08005c25 	.word	0x08005c25
 8005c00:	08005c2d 	.word	0x08005c2d
 8005c04:	2300      	movs	r3, #0
 8005c06:	f887 3043 	strb.w	r3, [r7, #67]	; 0x43
 8005c0a:	e086      	b.n	8005d1a <UART_SetConfig+0x5a6>
 8005c0c:	2304      	movs	r3, #4
 8005c0e:	f887 3043 	strb.w	r3, [r7, #67]	; 0x43
 8005c12:	e082      	b.n	8005d1a <UART_SetConfig+0x5a6>
 8005c14:	2308      	movs	r3, #8
 8005c16:	f887 3043 	strb.w	r3, [r7, #67]	; 0x43
 8005c1a:	e07e      	b.n	8005d1a <UART_SetConfig+0x5a6>
 8005c1c:	2310      	movs	r3, #16
 8005c1e:	f887 3043 	strb.w	r3, [r7, #67]	; 0x43
 8005c22:	e07a      	b.n	8005d1a <UART_SetConfig+0x5a6>
 8005c24:	2320      	movs	r3, #32
 8005c26:	f887 3043 	strb.w	r3, [r7, #67]	; 0x43
 8005c2a:	e076      	b.n	8005d1a <UART_SetConfig+0x5a6>
 8005c2c:	2340      	movs	r3, #64	; 0x40
 8005c2e:	f887 3043 	strb.w	r3, [r7, #67]	; 0x43
 8005c32:	e072      	b.n	8005d1a <UART_SetConfig+0x5a6>
 8005c34:	2380      	movs	r3, #128	; 0x80
 8005c36:	f887 3043 	strb.w	r3, [r7, #67]	; 0x43
 8005c3a:	e06e      	b.n	8005d1a <UART_SetConfig+0x5a6>
 8005c3c:	697b      	ldr	r3, [r7, #20]
 8005c3e:	681b      	ldr	r3, [r3, #0]
 8005c40:	4a75      	ldr	r2, [pc, #468]	; (8005e18 <UART_SetConfig+0x6a4>)
 8005c42:	4293      	cmp	r3, r2
 8005c44:	d130      	bne.n	8005ca8 <UART_SetConfig+0x534>
 8005c46:	4b72      	ldr	r3, [pc, #456]	; (8005e10 <UART_SetConfig+0x69c>)
 8005c48:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 8005c4a:	f003 0307 	and.w	r3, r3, #7
 8005c4e:	2b05      	cmp	r3, #5
 8005c50:	d826      	bhi.n	8005ca0 <UART_SetConfig+0x52c>
 8005c52:	a201      	add	r2, pc, #4	; (adr r2, 8005c58 <UART_SetConfig+0x4e4>)
 8005c54:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8005c58:	08005c71 	.word	0x08005c71
 8005c5c:	08005c79 	.word	0x08005c79
 8005c60:	08005c81 	.word	0x08005c81
 8005c64:	08005c89 	.word	0x08005c89
 8005c68:	08005c91 	.word	0x08005c91
 8005c6c:	08005c99 	.word	0x08005c99
 8005c70:	2300      	movs	r3, #0
 8005c72:	f887 3043 	strb.w	r3, [r7, #67]	; 0x43
 8005c76:	e050      	b.n	8005d1a <UART_SetConfig+0x5a6>
 8005c78:	2304      	movs	r3, #4
 8005c7a:	f887 3043 	strb.w	r3, [r7, #67]	; 0x43
 8005c7e:	e04c      	b.n	8005d1a <UART_SetConfig+0x5a6>
 8005c80:	2308      	movs	r3, #8
 8005c82:	f887 3043 	strb.w	r3, [r7, #67]	; 0x43
 8005c86:	e048      	b.n	8005d1a <UART_SetConfig+0x5a6>
 8005c88:	2310      	movs	r3, #16
 8005c8a:	f887 3043 	strb.w	r3, [r7, #67]	; 0x43
 8005c8e:	e044      	b.n	8005d1a <UART_SetConfig+0x5a6>
 8005c90:	2320      	movs	r3, #32
 8005c92:	f887 3043 	strb.w	r3, [r7, #67]	; 0x43
 8005c96:	e040      	b.n	8005d1a <UART_SetConfig+0x5a6>
 8005c98:	2340      	movs	r3, #64	; 0x40
 8005c9a:	f887 3043 	strb.w	r3, [r7, #67]	; 0x43
 8005c9e:	e03c      	b.n	8005d1a <UART_SetConfig+0x5a6>
 8005ca0:	2380      	movs	r3, #128	; 0x80
 8005ca2:	f887 3043 	strb.w	r3, [r7, #67]	; 0x43
 8005ca6:	e038      	b.n	8005d1a <UART_SetConfig+0x5a6>
 8005ca8:	697b      	ldr	r3, [r7, #20]
 8005caa:	681b      	ldr	r3, [r3, #0]
 8005cac:	4a5b      	ldr	r2, [pc, #364]	; (8005e1c <UART_SetConfig+0x6a8>)
 8005cae:	4293      	cmp	r3, r2
 8005cb0:	d130      	bne.n	8005d14 <UART_SetConfig+0x5a0>
 8005cb2:	4b57      	ldr	r3, [pc, #348]	; (8005e10 <UART_SetConfig+0x69c>)
 8005cb4:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 8005cb6:	f003 0307 	and.w	r3, r3, #7
 8005cba:	2b05      	cmp	r3, #5
 8005cbc:	d826      	bhi.n	8005d0c <UART_SetConfig+0x598>
 8005cbe:	a201      	add	r2, pc, #4	; (adr r2, 8005cc4 <UART_SetConfig+0x550>)
 8005cc0:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8005cc4:	08005cdd 	.word	0x08005cdd
 8005cc8:	08005ce5 	.word	0x08005ce5
 8005ccc:	08005ced 	.word	0x08005ced
 8005cd0:	08005cf5 	.word	0x08005cf5
 8005cd4:	08005cfd 	.word	0x08005cfd
 8005cd8:	08005d05 	.word	0x08005d05
 8005cdc:	2302      	movs	r3, #2
 8005cde:	f887 3043 	strb.w	r3, [r7, #67]	; 0x43
 8005ce2:	e01a      	b.n	8005d1a <UART_SetConfig+0x5a6>
 8005ce4:	2304      	movs	r3, #4
 8005ce6:	f887 3043 	strb.w	r3, [r7, #67]	; 0x43
 8005cea:	e016      	b.n	8005d1a <UART_SetConfig+0x5a6>
 8005cec:	2308      	movs	r3, #8
 8005cee:	f887 3043 	strb.w	r3, [r7, #67]	; 0x43
 8005cf2:	e012      	b.n	8005d1a <UART_SetConfig+0x5a6>
 8005cf4:	2310      	movs	r3, #16
 8005cf6:	f887 3043 	strb.w	r3, [r7, #67]	; 0x43
 8005cfa:	e00e      	b.n	8005d1a <UART_SetConfig+0x5a6>
 8005cfc:	2320      	movs	r3, #32
 8005cfe:	f887 3043 	strb.w	r3, [r7, #67]	; 0x43
 8005d02:	e00a      	b.n	8005d1a <UART_SetConfig+0x5a6>
 8005d04:	2340      	movs	r3, #64	; 0x40
 8005d06:	f887 3043 	strb.w	r3, [r7, #67]	; 0x43
 8005d0a:	e006      	b.n	8005d1a <UART_SetConfig+0x5a6>
 8005d0c:	2380      	movs	r3, #128	; 0x80
 8005d0e:	f887 3043 	strb.w	r3, [r7, #67]	; 0x43
 8005d12:	e002      	b.n	8005d1a <UART_SetConfig+0x5a6>
 8005d14:	2380      	movs	r3, #128	; 0x80
 8005d16:	f887 3043 	strb.w	r3, [r7, #67]	; 0x43

  /* Check LPUART instance */
  if (UART_INSTANCE_LOWPOWER(huart))
 8005d1a:	697b      	ldr	r3, [r7, #20]
 8005d1c:	681b      	ldr	r3, [r3, #0]
 8005d1e:	4a3f      	ldr	r2, [pc, #252]	; (8005e1c <UART_SetConfig+0x6a8>)
 8005d20:	4293      	cmp	r3, r2
 8005d22:	f040 80f8 	bne.w	8005f16 <UART_SetConfig+0x7a2>
  {
    /* Retrieve frequency clock */
    switch (clocksource)
 8005d26:	f897 3043 	ldrb.w	r3, [r7, #67]	; 0x43
 8005d2a:	2b20      	cmp	r3, #32
 8005d2c:	dc46      	bgt.n	8005dbc <UART_SetConfig+0x648>
 8005d2e:	2b02      	cmp	r3, #2
 8005d30:	f2c0 8082 	blt.w	8005e38 <UART_SetConfig+0x6c4>
 8005d34:	3b02      	subs	r3, #2
 8005d36:	2b1e      	cmp	r3, #30
 8005d38:	d87e      	bhi.n	8005e38 <UART_SetConfig+0x6c4>
 8005d3a:	a201      	add	r2, pc, #4	; (adr r2, 8005d40 <UART_SetConfig+0x5cc>)
 8005d3c:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8005d40:	08005dc3 	.word	0x08005dc3
 8005d44:	08005e39 	.word	0x08005e39
 8005d48:	08005dcb 	.word	0x08005dcb
 8005d4c:	08005e39 	.word	0x08005e39
 8005d50:	08005e39 	.word	0x08005e39
 8005d54:	08005e39 	.word	0x08005e39
 8005d58:	08005ddb 	.word	0x08005ddb
 8005d5c:	08005e39 	.word	0x08005e39
 8005d60:	08005e39 	.word	0x08005e39
 8005d64:	08005e39 	.word	0x08005e39
 8005d68:	08005e39 	.word	0x08005e39
 8005d6c:	08005e39 	.word	0x08005e39
 8005d70:	08005e39 	.word	0x08005e39
 8005d74:	08005e39 	.word	0x08005e39
 8005d78:	08005deb 	.word	0x08005deb
 8005d7c:	08005e39 	.word	0x08005e39
 8005d80:	08005e39 	.word	0x08005e39
 8005d84:	08005e39 	.word	0x08005e39
 8005d88:	08005e39 	.word	0x08005e39
 8005d8c:	08005e39 	.word	0x08005e39
 8005d90:	08005e39 	.word	0x08005e39
 8005d94:	08005e39 	.word	0x08005e39
 8005d98:	08005e39 	.word	0x08005e39
 8005d9c:	08005e39 	.word	0x08005e39
 8005da0:	08005e39 	.word	0x08005e39
 8005da4:	08005e39 	.word	0x08005e39
 8005da8:	08005e39 	.word	0x08005e39
 8005dac:	08005e39 	.word	0x08005e39
 8005db0:	08005e39 	.word	0x08005e39
 8005db4:	08005e39 	.word	0x08005e39
 8005db8:	08005e2b 	.word	0x08005e2b
 8005dbc:	2b40      	cmp	r3, #64	; 0x40
 8005dbe:	d037      	beq.n	8005e30 <UART_SetConfig+0x6bc>
 8005dc0:	e03a      	b.n	8005e38 <UART_SetConfig+0x6c4>
    {
      case UART_CLOCKSOURCE_D3PCLK1:
        pclk = HAL_RCCEx_GetD3PCLK1Freq();
 8005dc2:	f7fe f81b 	bl	8003dfc <HAL_RCCEx_GetD3PCLK1Freq>
 8005dc6:	63f8      	str	r0, [r7, #60]	; 0x3c
        break;
 8005dc8:	e03c      	b.n	8005e44 <UART_SetConfig+0x6d0>
      case UART_CLOCKSOURCE_PLL2:
        HAL_RCCEx_GetPLL2ClockFreq(&pll2_clocks);
 8005dca:	f107 0324 	add.w	r3, r7, #36	; 0x24
 8005dce:	4618      	mov	r0, r3
 8005dd0:	f7fe f82a 	bl	8003e28 <HAL_RCCEx_GetPLL2ClockFreq>
        pclk = pll2_clocks.PLL2_Q_Frequency;
 8005dd4:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8005dd6:	63fb      	str	r3, [r7, #60]	; 0x3c
        break;
 8005dd8:	e034      	b.n	8005e44 <UART_SetConfig+0x6d0>
      case UART_CLOCKSOURCE_PLL3:
        HAL_RCCEx_GetPLL3ClockFreq(&pll3_clocks);
 8005dda:	f107 0318 	add.w	r3, r7, #24
 8005dde:	4618      	mov	r0, r3
 8005de0:	f7fe f976 	bl	80040d0 <HAL_RCCEx_GetPLL3ClockFreq>
        pclk = pll3_clocks.PLL3_Q_Frequency;
 8005de4:	69fb      	ldr	r3, [r7, #28]
 8005de6:	63fb      	str	r3, [r7, #60]	; 0x3c
        break;
 8005de8:	e02c      	b.n	8005e44 <UART_SetConfig+0x6d0>
      case UART_CLOCKSOURCE_HSI:
        if (__HAL_RCC_GET_FLAG(RCC_FLAG_HSIDIV) != 0U)
 8005dea:	4b09      	ldr	r3, [pc, #36]	; (8005e10 <UART_SetConfig+0x69c>)
 8005dec:	681b      	ldr	r3, [r3, #0]
 8005dee:	f003 0320 	and.w	r3, r3, #32
 8005df2:	2b00      	cmp	r3, #0
 8005df4:	d016      	beq.n	8005e24 <UART_SetConfig+0x6b0>
        {
          pclk = (uint32_t)(HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER() >> 3U));
 8005df6:	4b06      	ldr	r3, [pc, #24]	; (8005e10 <UART_SetConfig+0x69c>)
 8005df8:	681b      	ldr	r3, [r3, #0]
 8005dfa:	08db      	lsrs	r3, r3, #3
 8005dfc:	f003 0303 	and.w	r3, r3, #3
 8005e00:	4a07      	ldr	r2, [pc, #28]	; (8005e20 <UART_SetConfig+0x6ac>)
 8005e02:	fa22 f303 	lsr.w	r3, r2, r3
 8005e06:	63fb      	str	r3, [r7, #60]	; 0x3c
        }
        else
        {
          pclk = (uint32_t) HSI_VALUE;
        }
        break;
 8005e08:	e01c      	b.n	8005e44 <UART_SetConfig+0x6d0>
 8005e0a:	bf00      	nop
 8005e0c:	40011400 	.word	0x40011400
 8005e10:	58024400 	.word	0x58024400
 8005e14:	40007800 	.word	0x40007800
 8005e18:	40007c00 	.word	0x40007c00
 8005e1c:	58000c00 	.word	0x58000c00
 8005e20:	03d09000 	.word	0x03d09000
          pclk = (uint32_t) HSI_VALUE;
 8005e24:	4b9d      	ldr	r3, [pc, #628]	; (800609c <UART_SetConfig+0x928>)
 8005e26:	63fb      	str	r3, [r7, #60]	; 0x3c
        break;
 8005e28:	e00c      	b.n	8005e44 <UART_SetConfig+0x6d0>
      case UART_CLOCKSOURCE_CSI:
        pclk = (uint32_t) CSI_VALUE;
 8005e2a:	4b9d      	ldr	r3, [pc, #628]	; (80060a0 <UART_SetConfig+0x92c>)
 8005e2c:	63fb      	str	r3, [r7, #60]	; 0x3c
        break;
 8005e2e:	e009      	b.n	8005e44 <UART_SetConfig+0x6d0>
      case UART_CLOCKSOURCE_LSE:
        pclk = (uint32_t) LSE_VALUE;
 8005e30:	f44f 4300 	mov.w	r3, #32768	; 0x8000
 8005e34:	63fb      	str	r3, [r7, #60]	; 0x3c
        break;
 8005e36:	e005      	b.n	8005e44 <UART_SetConfig+0x6d0>
      default:
        pclk = 0U;
 8005e38:	2300      	movs	r3, #0
 8005e3a:	63fb      	str	r3, [r7, #60]	; 0x3c
        ret = HAL_ERROR;
 8005e3c:	2301      	movs	r3, #1
 8005e3e:	f887 3042 	strb.w	r3, [r7, #66]	; 0x42
        break;
 8005e42:	bf00      	nop
    }

    /* If proper clock source reported */
    if (pclk != 0U)
 8005e44:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8005e46:	2b00      	cmp	r3, #0
 8005e48:	f000 81de 	beq.w	8006208 <UART_SetConfig+0xa94>
    {
      /* Compute clock after Prescaler */
      lpuart_ker_ck_pres = (pclk / UARTPrescTable[huart->Init.ClockPrescaler]);
 8005e4c:	697b      	ldr	r3, [r7, #20]
 8005e4e:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8005e50:	4a94      	ldr	r2, [pc, #592]	; (80060a4 <UART_SetConfig+0x930>)
 8005e52:	f832 3013 	ldrh.w	r3, [r2, r3, lsl #1]
 8005e56:	461a      	mov	r2, r3
 8005e58:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8005e5a:	fbb3 f3f2 	udiv	r3, r3, r2
 8005e5e:	633b      	str	r3, [r7, #48]	; 0x30

      /* Ensure that Frequency clock is in the range [3 * baudrate, 4096 * baudrate] */
      if ((lpuart_ker_ck_pres < (3U * huart->Init.BaudRate)) ||
 8005e60:	697b      	ldr	r3, [r7, #20]
 8005e62:	685a      	ldr	r2, [r3, #4]
 8005e64:	4613      	mov	r3, r2
 8005e66:	005b      	lsls	r3, r3, #1
 8005e68:	4413      	add	r3, r2
 8005e6a:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 8005e6c:	429a      	cmp	r2, r3
 8005e6e:	d305      	bcc.n	8005e7c <UART_SetConfig+0x708>
          (lpuart_ker_ck_pres > (4096U * huart->Init.BaudRate)))
 8005e70:	697b      	ldr	r3, [r7, #20]
 8005e72:	685b      	ldr	r3, [r3, #4]
 8005e74:	031b      	lsls	r3, r3, #12
      if ((lpuart_ker_ck_pres < (3U * huart->Init.BaudRate)) ||
 8005e76:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 8005e78:	429a      	cmp	r2, r3
 8005e7a:	d903      	bls.n	8005e84 <UART_SetConfig+0x710>
      {
        ret = HAL_ERROR;
 8005e7c:	2301      	movs	r3, #1
 8005e7e:	f887 3042 	strb.w	r3, [r7, #66]	; 0x42
 8005e82:	e1c1      	b.n	8006208 <UART_SetConfig+0xa94>
      }
      else
      {
        /* Check computed UsartDiv value is in allocated range
           (it is forbidden to write values lower than 0x300 in the LPUART_BRR register) */
        usartdiv = (uint32_t)(UART_DIV_LPUART(pclk, huart->Init.BaudRate, huart->Init.ClockPrescaler));
 8005e84:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8005e86:	2200      	movs	r2, #0
 8005e88:	60bb      	str	r3, [r7, #8]
 8005e8a:	60fa      	str	r2, [r7, #12]
 8005e8c:	697b      	ldr	r3, [r7, #20]
 8005e8e:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8005e90:	4a84      	ldr	r2, [pc, #528]	; (80060a4 <UART_SetConfig+0x930>)
 8005e92:	f832 3013 	ldrh.w	r3, [r2, r3, lsl #1]
 8005e96:	b29b      	uxth	r3, r3
 8005e98:	2200      	movs	r2, #0
 8005e9a:	603b      	str	r3, [r7, #0]
 8005e9c:	607a      	str	r2, [r7, #4]
 8005e9e:	e9d7 2300 	ldrd	r2, r3, [r7]
 8005ea2:	e9d7 0102 	ldrd	r0, r1, [r7, #8]
 8005ea6:	f7fa fb9b 	bl	80005e0 <__aeabi_uldivmod>
 8005eaa:	4602      	mov	r2, r0
 8005eac:	460b      	mov	r3, r1
 8005eae:	4610      	mov	r0, r2
 8005eb0:	4619      	mov	r1, r3
 8005eb2:	f04f 0200 	mov.w	r2, #0
 8005eb6:	f04f 0300 	mov.w	r3, #0
 8005eba:	020b      	lsls	r3, r1, #8
 8005ebc:	ea43 6310 	orr.w	r3, r3, r0, lsr #24
 8005ec0:	0202      	lsls	r2, r0, #8
 8005ec2:	6979      	ldr	r1, [r7, #20]
 8005ec4:	6849      	ldr	r1, [r1, #4]
 8005ec6:	0849      	lsrs	r1, r1, #1
 8005ec8:	2000      	movs	r0, #0
 8005eca:	460c      	mov	r4, r1
 8005ecc:	4605      	mov	r5, r0
 8005ece:	eb12 0804 	adds.w	r8, r2, r4
 8005ed2:	eb43 0905 	adc.w	r9, r3, r5
 8005ed6:	697b      	ldr	r3, [r7, #20]
 8005ed8:	685b      	ldr	r3, [r3, #4]
 8005eda:	2200      	movs	r2, #0
 8005edc:	469a      	mov	sl, r3
 8005ede:	4693      	mov	fp, r2
 8005ee0:	4652      	mov	r2, sl
 8005ee2:	465b      	mov	r3, fp
 8005ee4:	4640      	mov	r0, r8
 8005ee6:	4649      	mov	r1, r9
 8005ee8:	f7fa fb7a 	bl	80005e0 <__aeabi_uldivmod>
 8005eec:	4602      	mov	r2, r0
 8005eee:	460b      	mov	r3, r1
 8005ef0:	4613      	mov	r3, r2
 8005ef2:	63bb      	str	r3, [r7, #56]	; 0x38
        if ((usartdiv >= LPUART_BRR_MIN) && (usartdiv <= LPUART_BRR_MAX))
 8005ef4:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8005ef6:	f5b3 7f40 	cmp.w	r3, #768	; 0x300
 8005efa:	d308      	bcc.n	8005f0e <UART_SetConfig+0x79a>
 8005efc:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8005efe:	f5b3 1f80 	cmp.w	r3, #1048576	; 0x100000
 8005f02:	d204      	bcs.n	8005f0e <UART_SetConfig+0x79a>
        {
          huart->Instance->BRR = usartdiv;
 8005f04:	697b      	ldr	r3, [r7, #20]
 8005f06:	681b      	ldr	r3, [r3, #0]
 8005f08:	6bba      	ldr	r2, [r7, #56]	; 0x38
 8005f0a:	60da      	str	r2, [r3, #12]
 8005f0c:	e17c      	b.n	8006208 <UART_SetConfig+0xa94>
        }
        else
        {
          ret = HAL_ERROR;
 8005f0e:	2301      	movs	r3, #1
 8005f10:	f887 3042 	strb.w	r3, [r7, #66]	; 0x42
 8005f14:	e178      	b.n	8006208 <UART_SetConfig+0xa94>
      } /* if ( (lpuart_ker_ck_pres < (3 * huart->Init.BaudRate) ) ||
                (lpuart_ker_ck_pres > (4096 * huart->Init.BaudRate) )) */
    } /* if (pclk != 0) */
  }
  /* Check UART Over Sampling to set Baud Rate Register */
  else if (huart->Init.OverSampling == UART_OVERSAMPLING_8)
 8005f16:	697b      	ldr	r3, [r7, #20]
 8005f18:	69db      	ldr	r3, [r3, #28]
 8005f1a:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
 8005f1e:	f040 80c5 	bne.w	80060ac <UART_SetConfig+0x938>
  {
    switch (clocksource)
 8005f22:	f897 3043 	ldrb.w	r3, [r7, #67]	; 0x43
 8005f26:	2b20      	cmp	r3, #32
 8005f28:	dc48      	bgt.n	8005fbc <UART_SetConfig+0x848>
 8005f2a:	2b00      	cmp	r3, #0
 8005f2c:	db7b      	blt.n	8006026 <UART_SetConfig+0x8b2>
 8005f2e:	2b20      	cmp	r3, #32
 8005f30:	d879      	bhi.n	8006026 <UART_SetConfig+0x8b2>
 8005f32:	a201      	add	r2, pc, #4	; (adr r2, 8005f38 <UART_SetConfig+0x7c4>)
 8005f34:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8005f38:	08005fc3 	.word	0x08005fc3
 8005f3c:	08005fcb 	.word	0x08005fcb
 8005f40:	08006027 	.word	0x08006027
 8005f44:	08006027 	.word	0x08006027
 8005f48:	08005fd3 	.word	0x08005fd3
 8005f4c:	08006027 	.word	0x08006027
 8005f50:	08006027 	.word	0x08006027
 8005f54:	08006027 	.word	0x08006027
 8005f58:	08005fe3 	.word	0x08005fe3
 8005f5c:	08006027 	.word	0x08006027
 8005f60:	08006027 	.word	0x08006027
 8005f64:	08006027 	.word	0x08006027
 8005f68:	08006027 	.word	0x08006027
 8005f6c:	08006027 	.word	0x08006027
 8005f70:	08006027 	.word	0x08006027
 8005f74:	08006027 	.word	0x08006027
 8005f78:	08005ff3 	.word	0x08005ff3
 8005f7c:	08006027 	.word	0x08006027
 8005f80:	08006027 	.word	0x08006027
 8005f84:	08006027 	.word	0x08006027
 8005f88:	08006027 	.word	0x08006027
 8005f8c:	08006027 	.word	0x08006027
 8005f90:	08006027 	.word	0x08006027
 8005f94:	08006027 	.word	0x08006027
 8005f98:	08006027 	.word	0x08006027
 8005f9c:	08006027 	.word	0x08006027
 8005fa0:	08006027 	.word	0x08006027
 8005fa4:	08006027 	.word	0x08006027
 8005fa8:	08006027 	.word	0x08006027
 8005fac:	08006027 	.word	0x08006027
 8005fb0:	08006027 	.word	0x08006027
 8005fb4:	08006027 	.word	0x08006027
 8005fb8:	08006019 	.word	0x08006019
 8005fbc:	2b40      	cmp	r3, #64	; 0x40
 8005fbe:	d02e      	beq.n	800601e <UART_SetConfig+0x8aa>
 8005fc0:	e031      	b.n	8006026 <UART_SetConfig+0x8b2>
    {
      case UART_CLOCKSOURCE_D2PCLK1:
        pclk = HAL_RCC_GetPCLK1Freq();
 8005fc2:	f7fc ff3f 	bl	8002e44 <HAL_RCC_GetPCLK1Freq>
 8005fc6:	63f8      	str	r0, [r7, #60]	; 0x3c
        break;
 8005fc8:	e033      	b.n	8006032 <UART_SetConfig+0x8be>
      case UART_CLOCKSOURCE_D2PCLK2:
        pclk = HAL_RCC_GetPCLK2Freq();
 8005fca:	f7fc ff51 	bl	8002e70 <HAL_RCC_GetPCLK2Freq>
 8005fce:	63f8      	str	r0, [r7, #60]	; 0x3c
        break;
 8005fd0:	e02f      	b.n	8006032 <UART_SetConfig+0x8be>
      case UART_CLOCKSOURCE_PLL2:
        HAL_RCCEx_GetPLL2ClockFreq(&pll2_clocks);
 8005fd2:	f107 0324 	add.w	r3, r7, #36	; 0x24
 8005fd6:	4618      	mov	r0, r3
 8005fd8:	f7fd ff26 	bl	8003e28 <HAL_RCCEx_GetPLL2ClockFreq>
        pclk = pll2_clocks.PLL2_Q_Frequency;
 8005fdc:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8005fde:	63fb      	str	r3, [r7, #60]	; 0x3c
        break;
 8005fe0:	e027      	b.n	8006032 <UART_SetConfig+0x8be>
      case UART_CLOCKSOURCE_PLL3:
        HAL_RCCEx_GetPLL3ClockFreq(&pll3_clocks);
 8005fe2:	f107 0318 	add.w	r3, r7, #24
 8005fe6:	4618      	mov	r0, r3
 8005fe8:	f7fe f872 	bl	80040d0 <HAL_RCCEx_GetPLL3ClockFreq>
        pclk = pll3_clocks.PLL3_Q_Frequency;
 8005fec:	69fb      	ldr	r3, [r7, #28]
 8005fee:	63fb      	str	r3, [r7, #60]	; 0x3c
        break;
 8005ff0:	e01f      	b.n	8006032 <UART_SetConfig+0x8be>
      case UART_CLOCKSOURCE_HSI:
        if (__HAL_RCC_GET_FLAG(RCC_FLAG_HSIDIV) != 0U)
 8005ff2:	4b2d      	ldr	r3, [pc, #180]	; (80060a8 <UART_SetConfig+0x934>)
 8005ff4:	681b      	ldr	r3, [r3, #0]
 8005ff6:	f003 0320 	and.w	r3, r3, #32
 8005ffa:	2b00      	cmp	r3, #0
 8005ffc:	d009      	beq.n	8006012 <UART_SetConfig+0x89e>
        {
          pclk = (uint32_t)(HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER() >> 3U));
 8005ffe:	4b2a      	ldr	r3, [pc, #168]	; (80060a8 <UART_SetConfig+0x934>)
 8006000:	681b      	ldr	r3, [r3, #0]
 8006002:	08db      	lsrs	r3, r3, #3
 8006004:	f003 0303 	and.w	r3, r3, #3
 8006008:	4a24      	ldr	r2, [pc, #144]	; (800609c <UART_SetConfig+0x928>)
 800600a:	fa22 f303 	lsr.w	r3, r2, r3
 800600e:	63fb      	str	r3, [r7, #60]	; 0x3c
        }
        else
        {
          pclk = (uint32_t) HSI_VALUE;
        }
        break;
 8006010:	e00f      	b.n	8006032 <UART_SetConfig+0x8be>
          pclk = (uint32_t) HSI_VALUE;
 8006012:	4b22      	ldr	r3, [pc, #136]	; (800609c <UART_SetConfig+0x928>)
 8006014:	63fb      	str	r3, [r7, #60]	; 0x3c
        break;
 8006016:	e00c      	b.n	8006032 <UART_SetConfig+0x8be>
      case UART_CLOCKSOURCE_CSI:
        pclk = (uint32_t) CSI_VALUE;
 8006018:	4b21      	ldr	r3, [pc, #132]	; (80060a0 <UART_SetConfig+0x92c>)
 800601a:	63fb      	str	r3, [r7, #60]	; 0x3c
        break;
 800601c:	e009      	b.n	8006032 <UART_SetConfig+0x8be>
      case UART_CLOCKSOURCE_LSE:
        pclk = (uint32_t) LSE_VALUE;
 800601e:	f44f 4300 	mov.w	r3, #32768	; 0x8000
 8006022:	63fb      	str	r3, [r7, #60]	; 0x3c
        break;
 8006024:	e005      	b.n	8006032 <UART_SetConfig+0x8be>
      default:
        pclk = 0U;
 8006026:	2300      	movs	r3, #0
 8006028:	63fb      	str	r3, [r7, #60]	; 0x3c
        ret = HAL_ERROR;
 800602a:	2301      	movs	r3, #1
 800602c:	f887 3042 	strb.w	r3, [r7, #66]	; 0x42
        break;
 8006030:	bf00      	nop
    }

    /* USARTDIV must be greater than or equal to 0d16 */
    if (pclk != 0U)
 8006032:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8006034:	2b00      	cmp	r3, #0
 8006036:	f000 80e7 	beq.w	8006208 <UART_SetConfig+0xa94>
    {
      usartdiv = (uint32_t)(UART_DIV_SAMPLING8(pclk, huart->Init.BaudRate, huart->Init.ClockPrescaler));
 800603a:	697b      	ldr	r3, [r7, #20]
 800603c:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800603e:	4a19      	ldr	r2, [pc, #100]	; (80060a4 <UART_SetConfig+0x930>)
 8006040:	f832 3013 	ldrh.w	r3, [r2, r3, lsl #1]
 8006044:	461a      	mov	r2, r3
 8006046:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8006048:	fbb3 f3f2 	udiv	r3, r3, r2
 800604c:	005a      	lsls	r2, r3, #1
 800604e:	697b      	ldr	r3, [r7, #20]
 8006050:	685b      	ldr	r3, [r3, #4]
 8006052:	085b      	lsrs	r3, r3, #1
 8006054:	441a      	add	r2, r3
 8006056:	697b      	ldr	r3, [r7, #20]
 8006058:	685b      	ldr	r3, [r3, #4]
 800605a:	fbb2 f3f3 	udiv	r3, r2, r3
 800605e:	63bb      	str	r3, [r7, #56]	; 0x38
      if ((usartdiv >= UART_BRR_MIN) && (usartdiv <= UART_BRR_MAX))
 8006060:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8006062:	2b0f      	cmp	r3, #15
 8006064:	d916      	bls.n	8006094 <UART_SetConfig+0x920>
 8006066:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8006068:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
 800606c:	d212      	bcs.n	8006094 <UART_SetConfig+0x920>
      {
        brrtemp = (uint16_t)(usartdiv & 0xFFF0U);
 800606e:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8006070:	b29b      	uxth	r3, r3
 8006072:	f023 030f 	bic.w	r3, r3, #15
 8006076:	86fb      	strh	r3, [r7, #54]	; 0x36
        brrtemp |= (uint16_t)((usartdiv & (uint16_t)0x000FU) >> 1U);
 8006078:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800607a:	085b      	lsrs	r3, r3, #1
 800607c:	b29b      	uxth	r3, r3
 800607e:	f003 0307 	and.w	r3, r3, #7
 8006082:	b29a      	uxth	r2, r3
 8006084:	8efb      	ldrh	r3, [r7, #54]	; 0x36
 8006086:	4313      	orrs	r3, r2
 8006088:	86fb      	strh	r3, [r7, #54]	; 0x36
        huart->Instance->BRR = brrtemp;
 800608a:	697b      	ldr	r3, [r7, #20]
 800608c:	681b      	ldr	r3, [r3, #0]
 800608e:	8efa      	ldrh	r2, [r7, #54]	; 0x36
 8006090:	60da      	str	r2, [r3, #12]
 8006092:	e0b9      	b.n	8006208 <UART_SetConfig+0xa94>
      }
      else
      {
        ret = HAL_ERROR;
 8006094:	2301      	movs	r3, #1
 8006096:	f887 3042 	strb.w	r3, [r7, #66]	; 0x42
 800609a:	e0b5      	b.n	8006208 <UART_SetConfig+0xa94>
 800609c:	03d09000 	.word	0x03d09000
 80060a0:	003d0900 	.word	0x003d0900
 80060a4:	0802622c 	.word	0x0802622c
 80060a8:	58024400 	.word	0x58024400
      }
    }
  }
  else
  {
    switch (clocksource)
 80060ac:	f897 3043 	ldrb.w	r3, [r7, #67]	; 0x43
 80060b0:	2b20      	cmp	r3, #32
 80060b2:	dc49      	bgt.n	8006148 <UART_SetConfig+0x9d4>
 80060b4:	2b00      	cmp	r3, #0
 80060b6:	db7c      	blt.n	80061b2 <UART_SetConfig+0xa3e>
 80060b8:	2b20      	cmp	r3, #32
 80060ba:	d87a      	bhi.n	80061b2 <UART_SetConfig+0xa3e>
 80060bc:	a201      	add	r2, pc, #4	; (adr r2, 80060c4 <UART_SetConfig+0x950>)
 80060be:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 80060c2:	bf00      	nop
 80060c4:	0800614f 	.word	0x0800614f
 80060c8:	08006157 	.word	0x08006157
 80060cc:	080061b3 	.word	0x080061b3
 80060d0:	080061b3 	.word	0x080061b3
 80060d4:	0800615f 	.word	0x0800615f
 80060d8:	080061b3 	.word	0x080061b3
 80060dc:	080061b3 	.word	0x080061b3
 80060e0:	080061b3 	.word	0x080061b3
 80060e4:	0800616f 	.word	0x0800616f
 80060e8:	080061b3 	.word	0x080061b3
 80060ec:	080061b3 	.word	0x080061b3
 80060f0:	080061b3 	.word	0x080061b3
 80060f4:	080061b3 	.word	0x080061b3
 80060f8:	080061b3 	.word	0x080061b3
 80060fc:	080061b3 	.word	0x080061b3
 8006100:	080061b3 	.word	0x080061b3
 8006104:	0800617f 	.word	0x0800617f
 8006108:	080061b3 	.word	0x080061b3
 800610c:	080061b3 	.word	0x080061b3
 8006110:	080061b3 	.word	0x080061b3
 8006114:	080061b3 	.word	0x080061b3
 8006118:	080061b3 	.word	0x080061b3
 800611c:	080061b3 	.word	0x080061b3
 8006120:	080061b3 	.word	0x080061b3
 8006124:	080061b3 	.word	0x080061b3
 8006128:	080061b3 	.word	0x080061b3
 800612c:	080061b3 	.word	0x080061b3
 8006130:	080061b3 	.word	0x080061b3
 8006134:	080061b3 	.word	0x080061b3
 8006138:	080061b3 	.word	0x080061b3
 800613c:	080061b3 	.word	0x080061b3
 8006140:	080061b3 	.word	0x080061b3
 8006144:	080061a5 	.word	0x080061a5
 8006148:	2b40      	cmp	r3, #64	; 0x40
 800614a:	d02e      	beq.n	80061aa <UART_SetConfig+0xa36>
 800614c:	e031      	b.n	80061b2 <UART_SetConfig+0xa3e>
    {
      case UART_CLOCKSOURCE_D2PCLK1:
        pclk = HAL_RCC_GetPCLK1Freq();
 800614e:	f7fc fe79 	bl	8002e44 <HAL_RCC_GetPCLK1Freq>
 8006152:	63f8      	str	r0, [r7, #60]	; 0x3c
        break;
 8006154:	e033      	b.n	80061be <UART_SetConfig+0xa4a>
      case UART_CLOCKSOURCE_D2PCLK2:
        pclk = HAL_RCC_GetPCLK2Freq();
 8006156:	f7fc fe8b 	bl	8002e70 <HAL_RCC_GetPCLK2Freq>
 800615a:	63f8      	str	r0, [r7, #60]	; 0x3c
        break;
 800615c:	e02f      	b.n	80061be <UART_SetConfig+0xa4a>
      case UART_CLOCKSOURCE_PLL2:
        HAL_RCCEx_GetPLL2ClockFreq(&pll2_clocks);
 800615e:	f107 0324 	add.w	r3, r7, #36	; 0x24
 8006162:	4618      	mov	r0, r3
 8006164:	f7fd fe60 	bl	8003e28 <HAL_RCCEx_GetPLL2ClockFreq>
        pclk = pll2_clocks.PLL2_Q_Frequency;
 8006168:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800616a:	63fb      	str	r3, [r7, #60]	; 0x3c
        break;
 800616c:	e027      	b.n	80061be <UART_SetConfig+0xa4a>
      case UART_CLOCKSOURCE_PLL3:
        HAL_RCCEx_GetPLL3ClockFreq(&pll3_clocks);
 800616e:	f107 0318 	add.w	r3, r7, #24
 8006172:	4618      	mov	r0, r3
 8006174:	f7fd ffac 	bl	80040d0 <HAL_RCCEx_GetPLL3ClockFreq>
        pclk = pll3_clocks.PLL3_Q_Frequency;
 8006178:	69fb      	ldr	r3, [r7, #28]
 800617a:	63fb      	str	r3, [r7, #60]	; 0x3c
        break;
 800617c:	e01f      	b.n	80061be <UART_SetConfig+0xa4a>
      case UART_CLOCKSOURCE_HSI:
        if (__HAL_RCC_GET_FLAG(RCC_FLAG_HSIDIV) != 0U)
 800617e:	4b2d      	ldr	r3, [pc, #180]	; (8006234 <UART_SetConfig+0xac0>)
 8006180:	681b      	ldr	r3, [r3, #0]
 8006182:	f003 0320 	and.w	r3, r3, #32
 8006186:	2b00      	cmp	r3, #0
 8006188:	d009      	beq.n	800619e <UART_SetConfig+0xa2a>
        {
          pclk = (uint32_t)(HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER() >> 3U));
 800618a:	4b2a      	ldr	r3, [pc, #168]	; (8006234 <UART_SetConfig+0xac0>)
 800618c:	681b      	ldr	r3, [r3, #0]
 800618e:	08db      	lsrs	r3, r3, #3
 8006190:	f003 0303 	and.w	r3, r3, #3
 8006194:	4a28      	ldr	r2, [pc, #160]	; (8006238 <UART_SetConfig+0xac4>)
 8006196:	fa22 f303 	lsr.w	r3, r2, r3
 800619a:	63fb      	str	r3, [r7, #60]	; 0x3c
        }
        else
        {
          pclk = (uint32_t) HSI_VALUE;
        }
        break;
 800619c:	e00f      	b.n	80061be <UART_SetConfig+0xa4a>
          pclk = (uint32_t) HSI_VALUE;
 800619e:	4b26      	ldr	r3, [pc, #152]	; (8006238 <UART_SetConfig+0xac4>)
 80061a0:	63fb      	str	r3, [r7, #60]	; 0x3c
        break;
 80061a2:	e00c      	b.n	80061be <UART_SetConfig+0xa4a>
      case UART_CLOCKSOURCE_CSI:
        pclk = (uint32_t) CSI_VALUE;
 80061a4:	4b25      	ldr	r3, [pc, #148]	; (800623c <UART_SetConfig+0xac8>)
 80061a6:	63fb      	str	r3, [r7, #60]	; 0x3c
        break;
 80061a8:	e009      	b.n	80061be <UART_SetConfig+0xa4a>
      case UART_CLOCKSOURCE_LSE:
        pclk = (uint32_t) LSE_VALUE;
 80061aa:	f44f 4300 	mov.w	r3, #32768	; 0x8000
 80061ae:	63fb      	str	r3, [r7, #60]	; 0x3c
        break;
 80061b0:	e005      	b.n	80061be <UART_SetConfig+0xa4a>
      default:
        pclk = 0U;
 80061b2:	2300      	movs	r3, #0
 80061b4:	63fb      	str	r3, [r7, #60]	; 0x3c
        ret = HAL_ERROR;
 80061b6:	2301      	movs	r3, #1
 80061b8:	f887 3042 	strb.w	r3, [r7, #66]	; 0x42
        break;
 80061bc:	bf00      	nop
    }

    if (pclk != 0U)
 80061be:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 80061c0:	2b00      	cmp	r3, #0
 80061c2:	d021      	beq.n	8006208 <UART_SetConfig+0xa94>
    {
      /* USARTDIV must be greater than or equal to 0d16 */
      usartdiv = (uint32_t)(UART_DIV_SAMPLING16(pclk, huart->Init.BaudRate, huart->Init.ClockPrescaler));
 80061c4:	697b      	ldr	r3, [r7, #20]
 80061c6:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 80061c8:	4a1d      	ldr	r2, [pc, #116]	; (8006240 <UART_SetConfig+0xacc>)
 80061ca:	f832 3013 	ldrh.w	r3, [r2, r3, lsl #1]
 80061ce:	461a      	mov	r2, r3
 80061d0:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 80061d2:	fbb3 f2f2 	udiv	r2, r3, r2
 80061d6:	697b      	ldr	r3, [r7, #20]
 80061d8:	685b      	ldr	r3, [r3, #4]
 80061da:	085b      	lsrs	r3, r3, #1
 80061dc:	441a      	add	r2, r3
 80061de:	697b      	ldr	r3, [r7, #20]
 80061e0:	685b      	ldr	r3, [r3, #4]
 80061e2:	fbb2 f3f3 	udiv	r3, r2, r3
 80061e6:	63bb      	str	r3, [r7, #56]	; 0x38
      if ((usartdiv >= UART_BRR_MIN) && (usartdiv <= UART_BRR_MAX))
 80061e8:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 80061ea:	2b0f      	cmp	r3, #15
 80061ec:	d909      	bls.n	8006202 <UART_SetConfig+0xa8e>
 80061ee:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 80061f0:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
 80061f4:	d205      	bcs.n	8006202 <UART_SetConfig+0xa8e>
      {
        huart->Instance->BRR = (uint16_t)usartdiv;
 80061f6:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 80061f8:	b29a      	uxth	r2, r3
 80061fa:	697b      	ldr	r3, [r7, #20]
 80061fc:	681b      	ldr	r3, [r3, #0]
 80061fe:	60da      	str	r2, [r3, #12]
 8006200:	e002      	b.n	8006208 <UART_SetConfig+0xa94>
      }
      else
      {
        ret = HAL_ERROR;
 8006202:	2301      	movs	r3, #1
 8006204:	f887 3042 	strb.w	r3, [r7, #66]	; 0x42
      }
    }
  }

  /* Initialize the number of data to process during RX/TX ISR execution */
  huart->NbTxDataToProcess = 1;
 8006208:	697b      	ldr	r3, [r7, #20]
 800620a:	2201      	movs	r2, #1
 800620c:	f8a3 206a 	strh.w	r2, [r3, #106]	; 0x6a
  huart->NbRxDataToProcess = 1;
 8006210:	697b      	ldr	r3, [r7, #20]
 8006212:	2201      	movs	r2, #1
 8006214:	f8a3 2068 	strh.w	r2, [r3, #104]	; 0x68

  /* Clear ISR function pointers */
  huart->RxISR = NULL;
 8006218:	697b      	ldr	r3, [r7, #20]
 800621a:	2200      	movs	r2, #0
 800621c:	671a      	str	r2, [r3, #112]	; 0x70
  huart->TxISR = NULL;
 800621e:	697b      	ldr	r3, [r7, #20]
 8006220:	2200      	movs	r2, #0
 8006222:	675a      	str	r2, [r3, #116]	; 0x74

  return ret;
 8006224:	f897 3042 	ldrb.w	r3, [r7, #66]	; 0x42
}
 8006228:	4618      	mov	r0, r3
 800622a:	3748      	adds	r7, #72	; 0x48
 800622c:	46bd      	mov	sp, r7
 800622e:	e8bd 8fb0 	ldmia.w	sp!, {r4, r5, r7, r8, r9, sl, fp, pc}
 8006232:	bf00      	nop
 8006234:	58024400 	.word	0x58024400
 8006238:	03d09000 	.word	0x03d09000
 800623c:	003d0900 	.word	0x003d0900
 8006240:	0802622c 	.word	0x0802622c

08006244 <UART_AdvFeatureConfig>:
  * @brief Configure the UART peripheral advanced features.
  * @param huart UART handle.
  * @retval None
  */
void UART_AdvFeatureConfig(UART_HandleTypeDef *huart)
{
 8006244:	b480      	push	{r7}
 8006246:	b083      	sub	sp, #12
 8006248:	af00      	add	r7, sp, #0
 800624a:	6078      	str	r0, [r7, #4]
  /* Check whether the set of advanced features to configure is properly set */
  assert_param(IS_UART_ADVFEATURE_INIT(huart->AdvancedInit.AdvFeatureInit));

  /* if required, configure TX pin active level inversion */
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_TXINVERT_INIT))
 800624c:	687b      	ldr	r3, [r7, #4]
 800624e:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8006250:	f003 0301 	and.w	r3, r3, #1
 8006254:	2b00      	cmp	r3, #0
 8006256:	d00a      	beq.n	800626e <UART_AdvFeatureConfig+0x2a>
  {
    assert_param(IS_UART_ADVFEATURE_TXINV(huart->AdvancedInit.TxPinLevelInvert));
    MODIFY_REG(huart->Instance->CR2, USART_CR2_TXINV, huart->AdvancedInit.TxPinLevelInvert);
 8006258:	687b      	ldr	r3, [r7, #4]
 800625a:	681b      	ldr	r3, [r3, #0]
 800625c:	685b      	ldr	r3, [r3, #4]
 800625e:	f423 3100 	bic.w	r1, r3, #131072	; 0x20000
 8006262:	687b      	ldr	r3, [r7, #4]
 8006264:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 8006266:	687b      	ldr	r3, [r7, #4]
 8006268:	681b      	ldr	r3, [r3, #0]
 800626a:	430a      	orrs	r2, r1
 800626c:	605a      	str	r2, [r3, #4]
  }

  /* if required, configure RX pin active level inversion */
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_RXINVERT_INIT))
 800626e:	687b      	ldr	r3, [r7, #4]
 8006270:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8006272:	f003 0302 	and.w	r3, r3, #2
 8006276:	2b00      	cmp	r3, #0
 8006278:	d00a      	beq.n	8006290 <UART_AdvFeatureConfig+0x4c>
  {
    assert_param(IS_UART_ADVFEATURE_RXINV(huart->AdvancedInit.RxPinLevelInvert));
    MODIFY_REG(huart->Instance->CR2, USART_CR2_RXINV, huart->AdvancedInit.RxPinLevelInvert);
 800627a:	687b      	ldr	r3, [r7, #4]
 800627c:	681b      	ldr	r3, [r3, #0]
 800627e:	685b      	ldr	r3, [r3, #4]
 8006280:	f423 3180 	bic.w	r1, r3, #65536	; 0x10000
 8006284:	687b      	ldr	r3, [r7, #4]
 8006286:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8006288:	687b      	ldr	r3, [r7, #4]
 800628a:	681b      	ldr	r3, [r3, #0]
 800628c:	430a      	orrs	r2, r1
 800628e:	605a      	str	r2, [r3, #4]
  }

  /* if required, configure data inversion */
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_DATAINVERT_INIT))
 8006290:	687b      	ldr	r3, [r7, #4]
 8006292:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8006294:	f003 0304 	and.w	r3, r3, #4
 8006298:	2b00      	cmp	r3, #0
 800629a:	d00a      	beq.n	80062b2 <UART_AdvFeatureConfig+0x6e>
  {
    assert_param(IS_UART_ADVFEATURE_DATAINV(huart->AdvancedInit.DataInvert));
    MODIFY_REG(huart->Instance->CR2, USART_CR2_DATAINV, huart->AdvancedInit.DataInvert);
 800629c:	687b      	ldr	r3, [r7, #4]
 800629e:	681b      	ldr	r3, [r3, #0]
 80062a0:	685b      	ldr	r3, [r3, #4]
 80062a2:	f423 2180 	bic.w	r1, r3, #262144	; 0x40000
 80062a6:	687b      	ldr	r3, [r7, #4]
 80062a8:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 80062aa:	687b      	ldr	r3, [r7, #4]
 80062ac:	681b      	ldr	r3, [r3, #0]
 80062ae:	430a      	orrs	r2, r1
 80062b0:	605a      	str	r2, [r3, #4]
  }

  /* if required, configure RX/TX pins swap */
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_SWAP_INIT))
 80062b2:	687b      	ldr	r3, [r7, #4]
 80062b4:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 80062b6:	f003 0308 	and.w	r3, r3, #8
 80062ba:	2b00      	cmp	r3, #0
 80062bc:	d00a      	beq.n	80062d4 <UART_AdvFeatureConfig+0x90>
  {
    assert_param(IS_UART_ADVFEATURE_SWAP(huart->AdvancedInit.Swap));
    MODIFY_REG(huart->Instance->CR2, USART_CR2_SWAP, huart->AdvancedInit.Swap);
 80062be:	687b      	ldr	r3, [r7, #4]
 80062c0:	681b      	ldr	r3, [r3, #0]
 80062c2:	685b      	ldr	r3, [r3, #4]
 80062c4:	f423 4100 	bic.w	r1, r3, #32768	; 0x8000
 80062c8:	687b      	ldr	r3, [r7, #4]
 80062ca:	6b9a      	ldr	r2, [r3, #56]	; 0x38
 80062cc:	687b      	ldr	r3, [r7, #4]
 80062ce:	681b      	ldr	r3, [r3, #0]
 80062d0:	430a      	orrs	r2, r1
 80062d2:	605a      	str	r2, [r3, #4]
  }

  /* if required, configure RX overrun detection disabling */
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_RXOVERRUNDISABLE_INIT))
 80062d4:	687b      	ldr	r3, [r7, #4]
 80062d6:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 80062d8:	f003 0310 	and.w	r3, r3, #16
 80062dc:	2b00      	cmp	r3, #0
 80062de:	d00a      	beq.n	80062f6 <UART_AdvFeatureConfig+0xb2>
  {
    assert_param(IS_UART_OVERRUN(huart->AdvancedInit.OverrunDisable));
    MODIFY_REG(huart->Instance->CR3, USART_CR3_OVRDIS, huart->AdvancedInit.OverrunDisable);
 80062e0:	687b      	ldr	r3, [r7, #4]
 80062e2:	681b      	ldr	r3, [r3, #0]
 80062e4:	689b      	ldr	r3, [r3, #8]
 80062e6:	f423 5180 	bic.w	r1, r3, #4096	; 0x1000
 80062ea:	687b      	ldr	r3, [r7, #4]
 80062ec:	6bda      	ldr	r2, [r3, #60]	; 0x3c
 80062ee:	687b      	ldr	r3, [r7, #4]
 80062f0:	681b      	ldr	r3, [r3, #0]
 80062f2:	430a      	orrs	r2, r1
 80062f4:	609a      	str	r2, [r3, #8]
  }

  /* if required, configure DMA disabling on reception error */
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_DMADISABLEONERROR_INIT))
 80062f6:	687b      	ldr	r3, [r7, #4]
 80062f8:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 80062fa:	f003 0320 	and.w	r3, r3, #32
 80062fe:	2b00      	cmp	r3, #0
 8006300:	d00a      	beq.n	8006318 <UART_AdvFeatureConfig+0xd4>
  {
    assert_param(IS_UART_ADVFEATURE_DMAONRXERROR(huart->AdvancedInit.DMADisableonRxError));
    MODIFY_REG(huart->Instance->CR3, USART_CR3_DDRE, huart->AdvancedInit.DMADisableonRxError);
 8006302:	687b      	ldr	r3, [r7, #4]
 8006304:	681b      	ldr	r3, [r3, #0]
 8006306:	689b      	ldr	r3, [r3, #8]
 8006308:	f423 5100 	bic.w	r1, r3, #8192	; 0x2000
 800630c:	687b      	ldr	r3, [r7, #4]
 800630e:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 8006310:	687b      	ldr	r3, [r7, #4]
 8006312:	681b      	ldr	r3, [r3, #0]
 8006314:	430a      	orrs	r2, r1
 8006316:	609a      	str	r2, [r3, #8]
  }

  /* if required, configure auto Baud rate detection scheme */
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_AUTOBAUDRATE_INIT))
 8006318:	687b      	ldr	r3, [r7, #4]
 800631a:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 800631c:	f003 0340 	and.w	r3, r3, #64	; 0x40
 8006320:	2b00      	cmp	r3, #0
 8006322:	d01a      	beq.n	800635a <UART_AdvFeatureConfig+0x116>
  {
    assert_param(IS_USART_AUTOBAUDRATE_DETECTION_INSTANCE(huart->Instance));
    assert_param(IS_UART_ADVFEATURE_AUTOBAUDRATE(huart->AdvancedInit.AutoBaudRateEnable));
    MODIFY_REG(huart->Instance->CR2, USART_CR2_ABREN, huart->AdvancedInit.AutoBaudRateEnable);
 8006324:	687b      	ldr	r3, [r7, #4]
 8006326:	681b      	ldr	r3, [r3, #0]
 8006328:	685b      	ldr	r3, [r3, #4]
 800632a:	f423 1180 	bic.w	r1, r3, #1048576	; 0x100000
 800632e:	687b      	ldr	r3, [r7, #4]
 8006330:	6c5a      	ldr	r2, [r3, #68]	; 0x44
 8006332:	687b      	ldr	r3, [r7, #4]
 8006334:	681b      	ldr	r3, [r3, #0]
 8006336:	430a      	orrs	r2, r1
 8006338:	605a      	str	r2, [r3, #4]
    /* set auto Baudrate detection parameters if detection is enabled */
    if (huart->AdvancedInit.AutoBaudRateEnable == UART_ADVFEATURE_AUTOBAUDRATE_ENABLE)
 800633a:	687b      	ldr	r3, [r7, #4]
 800633c:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 800633e:	f5b3 1f80 	cmp.w	r3, #1048576	; 0x100000
 8006342:	d10a      	bne.n	800635a <UART_AdvFeatureConfig+0x116>
    {
      assert_param(IS_UART_ADVFEATURE_AUTOBAUDRATEMODE(huart->AdvancedInit.AutoBaudRateMode));
      MODIFY_REG(huart->Instance->CR2, USART_CR2_ABRMODE, huart->AdvancedInit.AutoBaudRateMode);
 8006344:	687b      	ldr	r3, [r7, #4]
 8006346:	681b      	ldr	r3, [r3, #0]
 8006348:	685b      	ldr	r3, [r3, #4]
 800634a:	f423 01c0 	bic.w	r1, r3, #6291456	; 0x600000
 800634e:	687b      	ldr	r3, [r7, #4]
 8006350:	6c9a      	ldr	r2, [r3, #72]	; 0x48
 8006352:	687b      	ldr	r3, [r7, #4]
 8006354:	681b      	ldr	r3, [r3, #0]
 8006356:	430a      	orrs	r2, r1
 8006358:	605a      	str	r2, [r3, #4]
    }
  }

  /* if required, configure MSB first on communication line */
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_MSBFIRST_INIT))
 800635a:	687b      	ldr	r3, [r7, #4]
 800635c:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 800635e:	f003 0380 	and.w	r3, r3, #128	; 0x80
 8006362:	2b00      	cmp	r3, #0
 8006364:	d00a      	beq.n	800637c <UART_AdvFeatureConfig+0x138>
  {
    assert_param(IS_UART_ADVFEATURE_MSBFIRST(huart->AdvancedInit.MSBFirst));
    MODIFY_REG(huart->Instance->CR2, USART_CR2_MSBFIRST, huart->AdvancedInit.MSBFirst);
 8006366:	687b      	ldr	r3, [r7, #4]
 8006368:	681b      	ldr	r3, [r3, #0]
 800636a:	685b      	ldr	r3, [r3, #4]
 800636c:	f423 2100 	bic.w	r1, r3, #524288	; 0x80000
 8006370:	687b      	ldr	r3, [r7, #4]
 8006372:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 8006374:	687b      	ldr	r3, [r7, #4]
 8006376:	681b      	ldr	r3, [r3, #0]
 8006378:	430a      	orrs	r2, r1
 800637a:	605a      	str	r2, [r3, #4]
  }
}
 800637c:	bf00      	nop
 800637e:	370c      	adds	r7, #12
 8006380:	46bd      	mov	sp, r7
 8006382:	f85d 7b04 	ldr.w	r7, [sp], #4
 8006386:	4770      	bx	lr

08006388 <UART_CheckIdleState>:
  * @brief Check the UART Idle State.
  * @param huart UART handle.
  * @retval HAL status
  */
HAL_StatusTypeDef UART_CheckIdleState(UART_HandleTypeDef *huart)
{
 8006388:	b580      	push	{r7, lr}
 800638a:	b086      	sub	sp, #24
 800638c:	af02      	add	r7, sp, #8
 800638e:	6078      	str	r0, [r7, #4]
  uint32_t tickstart;

  /* Initialize the UART ErrorCode */
  huart->ErrorCode = HAL_UART_ERROR_NONE;
 8006390:	687b      	ldr	r3, [r7, #4]
 8006392:	2200      	movs	r2, #0
 8006394:	f8c3 208c 	str.w	r2, [r3, #140]	; 0x8c

  /* Init tickstart for timeout management */
  tickstart = HAL_GetTick();
 8006398:	f7fb f9ce 	bl	8001738 <HAL_GetTick>
 800639c:	60f8      	str	r0, [r7, #12]

  /* Check if the Transmitter is enabled */
  if ((huart->Instance->CR1 & USART_CR1_TE) == USART_CR1_TE)
 800639e:	687b      	ldr	r3, [r7, #4]
 80063a0:	681b      	ldr	r3, [r3, #0]
 80063a2:	681b      	ldr	r3, [r3, #0]
 80063a4:	f003 0308 	and.w	r3, r3, #8
 80063a8:	2b08      	cmp	r3, #8
 80063aa:	d10e      	bne.n	80063ca <UART_CheckIdleState+0x42>
  {
    /* Wait until TEACK flag is set */
    if (UART_WaitOnFlagUntilTimeout(huart, USART_ISR_TEACK, RESET, tickstart, HAL_UART_TIMEOUT_VALUE) != HAL_OK)
 80063ac:	f06f 437e 	mvn.w	r3, #4261412864	; 0xfe000000
 80063b0:	9300      	str	r3, [sp, #0]
 80063b2:	68fb      	ldr	r3, [r7, #12]
 80063b4:	2200      	movs	r2, #0
 80063b6:	f44f 1100 	mov.w	r1, #2097152	; 0x200000
 80063ba:	6878      	ldr	r0, [r7, #4]
 80063bc:	f000 f82f 	bl	800641e <UART_WaitOnFlagUntilTimeout>
 80063c0:	4603      	mov	r3, r0
 80063c2:	2b00      	cmp	r3, #0
 80063c4:	d001      	beq.n	80063ca <UART_CheckIdleState+0x42>
    {
      /* Timeout occurred */
      return HAL_TIMEOUT;
 80063c6:	2303      	movs	r3, #3
 80063c8:	e025      	b.n	8006416 <UART_CheckIdleState+0x8e>
    }
  }

  /* Check if the Receiver is enabled */
  if ((huart->Instance->CR1 & USART_CR1_RE) == USART_CR1_RE)
 80063ca:	687b      	ldr	r3, [r7, #4]
 80063cc:	681b      	ldr	r3, [r3, #0]
 80063ce:	681b      	ldr	r3, [r3, #0]
 80063d0:	f003 0304 	and.w	r3, r3, #4
 80063d4:	2b04      	cmp	r3, #4
 80063d6:	d10e      	bne.n	80063f6 <UART_CheckIdleState+0x6e>
  {
    /* Wait until REACK flag is set */
    if (UART_WaitOnFlagUntilTimeout(huart, USART_ISR_REACK, RESET, tickstart, HAL_UART_TIMEOUT_VALUE) != HAL_OK)
 80063d8:	f06f 437e 	mvn.w	r3, #4261412864	; 0xfe000000
 80063dc:	9300      	str	r3, [sp, #0]
 80063de:	68fb      	ldr	r3, [r7, #12]
 80063e0:	2200      	movs	r2, #0
 80063e2:	f44f 0180 	mov.w	r1, #4194304	; 0x400000
 80063e6:	6878      	ldr	r0, [r7, #4]
 80063e8:	f000 f819 	bl	800641e <UART_WaitOnFlagUntilTimeout>
 80063ec:	4603      	mov	r3, r0
 80063ee:	2b00      	cmp	r3, #0
 80063f0:	d001      	beq.n	80063f6 <UART_CheckIdleState+0x6e>
    {
      /* Timeout occurred */
      return HAL_TIMEOUT;
 80063f2:	2303      	movs	r3, #3
 80063f4:	e00f      	b.n	8006416 <UART_CheckIdleState+0x8e>
    }
  }

  /* Initialize the UART State */
  huart->gState = HAL_UART_STATE_READY;
 80063f6:	687b      	ldr	r3, [r7, #4]
 80063f8:	2220      	movs	r2, #32
 80063fa:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84
  huart->RxState = HAL_UART_STATE_READY;
 80063fe:	687b      	ldr	r3, [r7, #4]
 8006400:	2220      	movs	r2, #32
 8006402:	f8c3 2088 	str.w	r2, [r3, #136]	; 0x88
  huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
 8006406:	687b      	ldr	r3, [r7, #4]
 8006408:	2200      	movs	r2, #0
 800640a:	66da      	str	r2, [r3, #108]	; 0x6c

  __HAL_UNLOCK(huart);
 800640c:	687b      	ldr	r3, [r7, #4]
 800640e:	2200      	movs	r2, #0
 8006410:	f883 2080 	strb.w	r2, [r3, #128]	; 0x80

  return HAL_OK;
 8006414:	2300      	movs	r3, #0
}
 8006416:	4618      	mov	r0, r3
 8006418:	3710      	adds	r7, #16
 800641a:	46bd      	mov	sp, r7
 800641c:	bd80      	pop	{r7, pc}

0800641e <UART_WaitOnFlagUntilTimeout>:
  * @param Timeout   Timeout duration
  * @retval HAL status
  */
HAL_StatusTypeDef UART_WaitOnFlagUntilTimeout(UART_HandleTypeDef *huart, uint32_t Flag, FlagStatus Status,
                                              uint32_t Tickstart, uint32_t Timeout)
{
 800641e:	b580      	push	{r7, lr}
 8006420:	b09c      	sub	sp, #112	; 0x70
 8006422:	af00      	add	r7, sp, #0
 8006424:	60f8      	str	r0, [r7, #12]
 8006426:	60b9      	str	r1, [r7, #8]
 8006428:	603b      	str	r3, [r7, #0]
 800642a:	4613      	mov	r3, r2
 800642c:	71fb      	strb	r3, [r7, #7]
  /* Wait until flag is set */
  while ((__HAL_UART_GET_FLAG(huart, Flag) ? SET : RESET) == Status)
 800642e:	e0a9      	b.n	8006584 <UART_WaitOnFlagUntilTimeout+0x166>
  {
    /* Check for the Timeout */
    if (Timeout != HAL_MAX_DELAY)
 8006430:	6fbb      	ldr	r3, [r7, #120]	; 0x78
 8006432:	f1b3 3fff 	cmp.w	r3, #4294967295
 8006436:	f000 80a5 	beq.w	8006584 <UART_WaitOnFlagUntilTimeout+0x166>
    {
      if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
 800643a:	f7fb f97d 	bl	8001738 <HAL_GetTick>
 800643e:	4602      	mov	r2, r0
 8006440:	683b      	ldr	r3, [r7, #0]
 8006442:	1ad3      	subs	r3, r2, r3
 8006444:	6fba      	ldr	r2, [r7, #120]	; 0x78
 8006446:	429a      	cmp	r2, r3
 8006448:	d302      	bcc.n	8006450 <UART_WaitOnFlagUntilTimeout+0x32>
 800644a:	6fbb      	ldr	r3, [r7, #120]	; 0x78
 800644c:	2b00      	cmp	r3, #0
 800644e:	d140      	bne.n	80064d2 <UART_WaitOnFlagUntilTimeout+0xb4>
      {
        /* Disable TXE, RXNE, PE and ERR (Frame error, noise error, overrun error)
           interrupts for the interrupt process */
        ATOMIC_CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE_RXFNEIE | USART_CR1_PEIE |
 8006450:	68fb      	ldr	r3, [r7, #12]
 8006452:	681b      	ldr	r3, [r3, #0]
 8006454:	653b      	str	r3, [r7, #80]	; 0x50
 */
__STATIC_FORCEINLINE uint32_t __LDREXW(volatile uint32_t *addr)
{
    uint32_t result;

   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8006456:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 8006458:	e853 3f00 	ldrex	r3, [r3]
 800645c:	64fb      	str	r3, [r7, #76]	; 0x4c
   return(result);
 800645e:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8006460:	f423 73d0 	bic.w	r3, r3, #416	; 0x1a0
 8006464:	667b      	str	r3, [r7, #100]	; 0x64
 8006466:	68fb      	ldr	r3, [r7, #12]
 8006468:	681b      	ldr	r3, [r3, #0]
 800646a:	461a      	mov	r2, r3
 800646c:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 800646e:	65fb      	str	r3, [r7, #92]	; 0x5c
 8006470:	65ba      	str	r2, [r7, #88]	; 0x58
 */
__STATIC_FORCEINLINE uint32_t __STREXW(uint32_t value, volatile uint32_t *addr)
{
   uint32_t result;

   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 8006472:	6db9      	ldr	r1, [r7, #88]	; 0x58
 8006474:	6dfa      	ldr	r2, [r7, #92]	; 0x5c
 8006476:	e841 2300 	strex	r3, r2, [r1]
 800647a:	657b      	str	r3, [r7, #84]	; 0x54
   return(result);
 800647c:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 800647e:	2b00      	cmp	r3, #0
 8006480:	d1e6      	bne.n	8006450 <UART_WaitOnFlagUntilTimeout+0x32>
                                                USART_CR1_TXEIE_TXFNFIE));
        ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
 8006482:	68fb      	ldr	r3, [r7, #12]
 8006484:	681b      	ldr	r3, [r3, #0]
 8006486:	3308      	adds	r3, #8
 8006488:	63fb      	str	r3, [r7, #60]	; 0x3c
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 800648a:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800648c:	e853 3f00 	ldrex	r3, [r3]
 8006490:	63bb      	str	r3, [r7, #56]	; 0x38
   return(result);
 8006492:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8006494:	f023 0301 	bic.w	r3, r3, #1
 8006498:	663b      	str	r3, [r7, #96]	; 0x60
 800649a:	68fb      	ldr	r3, [r7, #12]
 800649c:	681b      	ldr	r3, [r3, #0]
 800649e:	3308      	adds	r3, #8
 80064a0:	6e3a      	ldr	r2, [r7, #96]	; 0x60
 80064a2:	64ba      	str	r2, [r7, #72]	; 0x48
 80064a4:	647b      	str	r3, [r7, #68]	; 0x44
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 80064a6:	6c79      	ldr	r1, [r7, #68]	; 0x44
 80064a8:	6cba      	ldr	r2, [r7, #72]	; 0x48
 80064aa:	e841 2300 	strex	r3, r2, [r1]
 80064ae:	643b      	str	r3, [r7, #64]	; 0x40
   return(result);
 80064b0:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 80064b2:	2b00      	cmp	r3, #0
 80064b4:	d1e5      	bne.n	8006482 <UART_WaitOnFlagUntilTimeout+0x64>

        huart->gState = HAL_UART_STATE_READY;
 80064b6:	68fb      	ldr	r3, [r7, #12]
 80064b8:	2220      	movs	r2, #32
 80064ba:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84
        huart->RxState = HAL_UART_STATE_READY;
 80064be:	68fb      	ldr	r3, [r7, #12]
 80064c0:	2220      	movs	r2, #32
 80064c2:	f8c3 2088 	str.w	r2, [r3, #136]	; 0x88

        __HAL_UNLOCK(huart);
 80064c6:	68fb      	ldr	r3, [r7, #12]
 80064c8:	2200      	movs	r2, #0
 80064ca:	f883 2080 	strb.w	r2, [r3, #128]	; 0x80

        return HAL_TIMEOUT;
 80064ce:	2303      	movs	r3, #3
 80064d0:	e069      	b.n	80065a6 <UART_WaitOnFlagUntilTimeout+0x188>
      }

      if (READ_BIT(huart->Instance->CR1, USART_CR1_RE) != 0U)
 80064d2:	68fb      	ldr	r3, [r7, #12]
 80064d4:	681b      	ldr	r3, [r3, #0]
 80064d6:	681b      	ldr	r3, [r3, #0]
 80064d8:	f003 0304 	and.w	r3, r3, #4
 80064dc:	2b00      	cmp	r3, #0
 80064de:	d051      	beq.n	8006584 <UART_WaitOnFlagUntilTimeout+0x166>
      {
        if (__HAL_UART_GET_FLAG(huart, UART_FLAG_RTOF) == SET)
 80064e0:	68fb      	ldr	r3, [r7, #12]
 80064e2:	681b      	ldr	r3, [r3, #0]
 80064e4:	69db      	ldr	r3, [r3, #28]
 80064e6:	f403 6300 	and.w	r3, r3, #2048	; 0x800
 80064ea:	f5b3 6f00 	cmp.w	r3, #2048	; 0x800
 80064ee:	d149      	bne.n	8006584 <UART_WaitOnFlagUntilTimeout+0x166>
        {
          /* Clear Receiver Timeout flag*/
          __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_RTOF);
 80064f0:	68fb      	ldr	r3, [r7, #12]
 80064f2:	681b      	ldr	r3, [r3, #0]
 80064f4:	f44f 6200 	mov.w	r2, #2048	; 0x800
 80064f8:	621a      	str	r2, [r3, #32]

          /* Disable TXE, RXNE, PE and ERR (Frame error, noise error, overrun error)
             interrupts for the interrupt process */
          ATOMIC_CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE_RXFNEIE | USART_CR1_PEIE |
 80064fa:	68fb      	ldr	r3, [r7, #12]
 80064fc:	681b      	ldr	r3, [r3, #0]
 80064fe:	62bb      	str	r3, [r7, #40]	; 0x28
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8006500:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8006502:	e853 3f00 	ldrex	r3, [r3]
 8006506:	627b      	str	r3, [r7, #36]	; 0x24
   return(result);
 8006508:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800650a:	f423 73d0 	bic.w	r3, r3, #416	; 0x1a0
 800650e:	66fb      	str	r3, [r7, #108]	; 0x6c
 8006510:	68fb      	ldr	r3, [r7, #12]
 8006512:	681b      	ldr	r3, [r3, #0]
 8006514:	461a      	mov	r2, r3
 8006516:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 8006518:	637b      	str	r3, [r7, #52]	; 0x34
 800651a:	633a      	str	r2, [r7, #48]	; 0x30
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 800651c:	6b39      	ldr	r1, [r7, #48]	; 0x30
 800651e:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 8006520:	e841 2300 	strex	r3, r2, [r1]
 8006524:	62fb      	str	r3, [r7, #44]	; 0x2c
   return(result);
 8006526:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8006528:	2b00      	cmp	r3, #0
 800652a:	d1e6      	bne.n	80064fa <UART_WaitOnFlagUntilTimeout+0xdc>
                                                  USART_CR1_TXEIE_TXFNFIE));
          ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
 800652c:	68fb      	ldr	r3, [r7, #12]
 800652e:	681b      	ldr	r3, [r3, #0]
 8006530:	3308      	adds	r3, #8
 8006532:	617b      	str	r3, [r7, #20]
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8006534:	697b      	ldr	r3, [r7, #20]
 8006536:	e853 3f00 	ldrex	r3, [r3]
 800653a:	613b      	str	r3, [r7, #16]
   return(result);
 800653c:	693b      	ldr	r3, [r7, #16]
 800653e:	f023 0301 	bic.w	r3, r3, #1
 8006542:	66bb      	str	r3, [r7, #104]	; 0x68
 8006544:	68fb      	ldr	r3, [r7, #12]
 8006546:	681b      	ldr	r3, [r3, #0]
 8006548:	3308      	adds	r3, #8
 800654a:	6eba      	ldr	r2, [r7, #104]	; 0x68
 800654c:	623a      	str	r2, [r7, #32]
 800654e:	61fb      	str	r3, [r7, #28]
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 8006550:	69f9      	ldr	r1, [r7, #28]
 8006552:	6a3a      	ldr	r2, [r7, #32]
 8006554:	e841 2300 	strex	r3, r2, [r1]
 8006558:	61bb      	str	r3, [r7, #24]
   return(result);
 800655a:	69bb      	ldr	r3, [r7, #24]
 800655c:	2b00      	cmp	r3, #0
 800655e:	d1e5      	bne.n	800652c <UART_WaitOnFlagUntilTimeout+0x10e>

          huart->gState = HAL_UART_STATE_READY;
 8006560:	68fb      	ldr	r3, [r7, #12]
 8006562:	2220      	movs	r2, #32
 8006564:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84
          huart->RxState = HAL_UART_STATE_READY;
 8006568:	68fb      	ldr	r3, [r7, #12]
 800656a:	2220      	movs	r2, #32
 800656c:	f8c3 2088 	str.w	r2, [r3, #136]	; 0x88
          huart->ErrorCode = HAL_UART_ERROR_RTO;
 8006570:	68fb      	ldr	r3, [r7, #12]
 8006572:	2220      	movs	r2, #32
 8006574:	f8c3 208c 	str.w	r2, [r3, #140]	; 0x8c

          /* Process Unlocked */
          __HAL_UNLOCK(huart);
 8006578:	68fb      	ldr	r3, [r7, #12]
 800657a:	2200      	movs	r2, #0
 800657c:	f883 2080 	strb.w	r2, [r3, #128]	; 0x80

          return HAL_TIMEOUT;
 8006580:	2303      	movs	r3, #3
 8006582:	e010      	b.n	80065a6 <UART_WaitOnFlagUntilTimeout+0x188>
  while ((__HAL_UART_GET_FLAG(huart, Flag) ? SET : RESET) == Status)
 8006584:	68fb      	ldr	r3, [r7, #12]
 8006586:	681b      	ldr	r3, [r3, #0]
 8006588:	69da      	ldr	r2, [r3, #28]
 800658a:	68bb      	ldr	r3, [r7, #8]
 800658c:	4013      	ands	r3, r2
 800658e:	68ba      	ldr	r2, [r7, #8]
 8006590:	429a      	cmp	r2, r3
 8006592:	bf0c      	ite	eq
 8006594:	2301      	moveq	r3, #1
 8006596:	2300      	movne	r3, #0
 8006598:	b2db      	uxtb	r3, r3
 800659a:	461a      	mov	r2, r3
 800659c:	79fb      	ldrb	r3, [r7, #7]
 800659e:	429a      	cmp	r2, r3
 80065a0:	f43f af46 	beq.w	8006430 <UART_WaitOnFlagUntilTimeout+0x12>
        }
      }
    }
  }
  return HAL_OK;
 80065a4:	2300      	movs	r3, #0
}
 80065a6:	4618      	mov	r0, r3
 80065a8:	3770      	adds	r7, #112	; 0x70
 80065aa:	46bd      	mov	sp, r7
 80065ac:	bd80      	pop	{r7, pc}

080065ae <HAL_UARTEx_DisableFifoMode>:
  * @brief  Disable the FIFO mode.
  * @param huart      UART handle.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_UARTEx_DisableFifoMode(UART_HandleTypeDef *huart)
{
 80065ae:	b480      	push	{r7}
 80065b0:	b085      	sub	sp, #20
 80065b2:	af00      	add	r7, sp, #0
 80065b4:	6078      	str	r0, [r7, #4]

  /* Check parameters */
  assert_param(IS_UART_FIFO_INSTANCE(huart->Instance));

  /* Process Locked */
  __HAL_LOCK(huart);
 80065b6:	687b      	ldr	r3, [r7, #4]
 80065b8:	f893 3080 	ldrb.w	r3, [r3, #128]	; 0x80
 80065bc:	2b01      	cmp	r3, #1
 80065be:	d101      	bne.n	80065c4 <HAL_UARTEx_DisableFifoMode+0x16>
 80065c0:	2302      	movs	r3, #2
 80065c2:	e027      	b.n	8006614 <HAL_UARTEx_DisableFifoMode+0x66>
 80065c4:	687b      	ldr	r3, [r7, #4]
 80065c6:	2201      	movs	r2, #1
 80065c8:	f883 2080 	strb.w	r2, [r3, #128]	; 0x80

  huart->gState = HAL_UART_STATE_BUSY;
 80065cc:	687b      	ldr	r3, [r7, #4]
 80065ce:	2224      	movs	r2, #36	; 0x24
 80065d0:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84

  /* Save actual UART configuration */
  tmpcr1 = READ_REG(huart->Instance->CR1);
 80065d4:	687b      	ldr	r3, [r7, #4]
 80065d6:	681b      	ldr	r3, [r3, #0]
 80065d8:	681b      	ldr	r3, [r3, #0]
 80065da:	60fb      	str	r3, [r7, #12]

  /* Disable UART */
  __HAL_UART_DISABLE(huart);
 80065dc:	687b      	ldr	r3, [r7, #4]
 80065de:	681b      	ldr	r3, [r3, #0]
 80065e0:	681a      	ldr	r2, [r3, #0]
 80065e2:	687b      	ldr	r3, [r7, #4]
 80065e4:	681b      	ldr	r3, [r3, #0]
 80065e6:	f022 0201 	bic.w	r2, r2, #1
 80065ea:	601a      	str	r2, [r3, #0]

  /* Enable FIFO mode */
  CLEAR_BIT(tmpcr1, USART_CR1_FIFOEN);
 80065ec:	68fb      	ldr	r3, [r7, #12]
 80065ee:	f023 5300 	bic.w	r3, r3, #536870912	; 0x20000000
 80065f2:	60fb      	str	r3, [r7, #12]
  huart->FifoMode = UART_FIFOMODE_DISABLE;
 80065f4:	687b      	ldr	r3, [r7, #4]
 80065f6:	2200      	movs	r2, #0
 80065f8:	665a      	str	r2, [r3, #100]	; 0x64

  /* Restore UART configuration */
  WRITE_REG(huart->Instance->CR1, tmpcr1);
 80065fa:	687b      	ldr	r3, [r7, #4]
 80065fc:	681b      	ldr	r3, [r3, #0]
 80065fe:	68fa      	ldr	r2, [r7, #12]
 8006600:	601a      	str	r2, [r3, #0]

  huart->gState = HAL_UART_STATE_READY;
 8006602:	687b      	ldr	r3, [r7, #4]
 8006604:	2220      	movs	r2, #32
 8006606:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84

  /* Process Unlocked */
  __HAL_UNLOCK(huart);
 800660a:	687b      	ldr	r3, [r7, #4]
 800660c:	2200      	movs	r2, #0
 800660e:	f883 2080 	strb.w	r2, [r3, #128]	; 0x80

  return HAL_OK;
 8006612:	2300      	movs	r3, #0
}
 8006614:	4618      	mov	r0, r3
 8006616:	3714      	adds	r7, #20
 8006618:	46bd      	mov	sp, r7
 800661a:	f85d 7b04 	ldr.w	r7, [sp], #4
 800661e:	4770      	bx	lr

08006620 <HAL_UARTEx_SetTxFifoThreshold>:
  *            @arg @ref UART_TXFIFO_THRESHOLD_7_8
  *            @arg @ref UART_TXFIFO_THRESHOLD_8_8
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_UARTEx_SetTxFifoThreshold(UART_HandleTypeDef *huart, uint32_t Threshold)
{
 8006620:	b580      	push	{r7, lr}
 8006622:	b084      	sub	sp, #16
 8006624:	af00      	add	r7, sp, #0
 8006626:	6078      	str	r0, [r7, #4]
 8006628:	6039      	str	r1, [r7, #0]
  /* Check parameters */
  assert_param(IS_UART_FIFO_INSTANCE(huart->Instance));
  assert_param(IS_UART_TXFIFO_THRESHOLD(Threshold));

  /* Process Locked */
  __HAL_LOCK(huart);
 800662a:	687b      	ldr	r3, [r7, #4]
 800662c:	f893 3080 	ldrb.w	r3, [r3, #128]	; 0x80
 8006630:	2b01      	cmp	r3, #1
 8006632:	d101      	bne.n	8006638 <HAL_UARTEx_SetTxFifoThreshold+0x18>
 8006634:	2302      	movs	r3, #2
 8006636:	e02d      	b.n	8006694 <HAL_UARTEx_SetTxFifoThreshold+0x74>
 8006638:	687b      	ldr	r3, [r7, #4]
 800663a:	2201      	movs	r2, #1
 800663c:	f883 2080 	strb.w	r2, [r3, #128]	; 0x80

  huart->gState = HAL_UART_STATE_BUSY;
 8006640:	687b      	ldr	r3, [r7, #4]
 8006642:	2224      	movs	r2, #36	; 0x24
 8006644:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84

  /* Save actual UART configuration */
  tmpcr1 = READ_REG(huart->Instance->CR1);
 8006648:	687b      	ldr	r3, [r7, #4]
 800664a:	681b      	ldr	r3, [r3, #0]
 800664c:	681b      	ldr	r3, [r3, #0]
 800664e:	60fb      	str	r3, [r7, #12]

  /* Disable UART */
  __HAL_UART_DISABLE(huart);
 8006650:	687b      	ldr	r3, [r7, #4]
 8006652:	681b      	ldr	r3, [r3, #0]
 8006654:	681a      	ldr	r2, [r3, #0]
 8006656:	687b      	ldr	r3, [r7, #4]
 8006658:	681b      	ldr	r3, [r3, #0]
 800665a:	f022 0201 	bic.w	r2, r2, #1
 800665e:	601a      	str	r2, [r3, #0]

  /* Update TX threshold configuration */
  MODIFY_REG(huart->Instance->CR3, USART_CR3_TXFTCFG, Threshold);
 8006660:	687b      	ldr	r3, [r7, #4]
 8006662:	681b      	ldr	r3, [r3, #0]
 8006664:	689b      	ldr	r3, [r3, #8]
 8006666:	f023 4160 	bic.w	r1, r3, #3758096384	; 0xe0000000
 800666a:	687b      	ldr	r3, [r7, #4]
 800666c:	681b      	ldr	r3, [r3, #0]
 800666e:	683a      	ldr	r2, [r7, #0]
 8006670:	430a      	orrs	r2, r1
 8006672:	609a      	str	r2, [r3, #8]

  /* Determine the number of data to process during RX/TX ISR execution */
  UARTEx_SetNbDataToProcess(huart);
 8006674:	6878      	ldr	r0, [r7, #4]
 8006676:	f000 f84f 	bl	8006718 <UARTEx_SetNbDataToProcess>

  /* Restore UART configuration */
  WRITE_REG(huart->Instance->CR1, tmpcr1);
 800667a:	687b      	ldr	r3, [r7, #4]
 800667c:	681b      	ldr	r3, [r3, #0]
 800667e:	68fa      	ldr	r2, [r7, #12]
 8006680:	601a      	str	r2, [r3, #0]

  huart->gState = HAL_UART_STATE_READY;
 8006682:	687b      	ldr	r3, [r7, #4]
 8006684:	2220      	movs	r2, #32
 8006686:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84

  /* Process Unlocked */
  __HAL_UNLOCK(huart);
 800668a:	687b      	ldr	r3, [r7, #4]
 800668c:	2200      	movs	r2, #0
 800668e:	f883 2080 	strb.w	r2, [r3, #128]	; 0x80

  return HAL_OK;
 8006692:	2300      	movs	r3, #0
}
 8006694:	4618      	mov	r0, r3
 8006696:	3710      	adds	r7, #16
 8006698:	46bd      	mov	sp, r7
 800669a:	bd80      	pop	{r7, pc}

0800669c <HAL_UARTEx_SetRxFifoThreshold>:
  *            @arg @ref UART_RXFIFO_THRESHOLD_7_8
  *            @arg @ref UART_RXFIFO_THRESHOLD_8_8
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_UARTEx_SetRxFifoThreshold(UART_HandleTypeDef *huart, uint32_t Threshold)
{
 800669c:	b580      	push	{r7, lr}
 800669e:	b084      	sub	sp, #16
 80066a0:	af00      	add	r7, sp, #0
 80066a2:	6078      	str	r0, [r7, #4]
 80066a4:	6039      	str	r1, [r7, #0]
  /* Check the parameters */
  assert_param(IS_UART_FIFO_INSTANCE(huart->Instance));
  assert_param(IS_UART_RXFIFO_THRESHOLD(Threshold));

  /* Process Locked */
  __HAL_LOCK(huart);
 80066a6:	687b      	ldr	r3, [r7, #4]
 80066a8:	f893 3080 	ldrb.w	r3, [r3, #128]	; 0x80
 80066ac:	2b01      	cmp	r3, #1
 80066ae:	d101      	bne.n	80066b4 <HAL_UARTEx_SetRxFifoThreshold+0x18>
 80066b0:	2302      	movs	r3, #2
 80066b2:	e02d      	b.n	8006710 <HAL_UARTEx_SetRxFifoThreshold+0x74>
 80066b4:	687b      	ldr	r3, [r7, #4]
 80066b6:	2201      	movs	r2, #1
 80066b8:	f883 2080 	strb.w	r2, [r3, #128]	; 0x80

  huart->gState = HAL_UART_STATE_BUSY;
 80066bc:	687b      	ldr	r3, [r7, #4]
 80066be:	2224      	movs	r2, #36	; 0x24
 80066c0:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84

  /* Save actual UART configuration */
  tmpcr1 = READ_REG(huart->Instance->CR1);
 80066c4:	687b      	ldr	r3, [r7, #4]
 80066c6:	681b      	ldr	r3, [r3, #0]
 80066c8:	681b      	ldr	r3, [r3, #0]
 80066ca:	60fb      	str	r3, [r7, #12]

  /* Disable UART */
  __HAL_UART_DISABLE(huart);
 80066cc:	687b      	ldr	r3, [r7, #4]
 80066ce:	681b      	ldr	r3, [r3, #0]
 80066d0:	681a      	ldr	r2, [r3, #0]
 80066d2:	687b      	ldr	r3, [r7, #4]
 80066d4:	681b      	ldr	r3, [r3, #0]
 80066d6:	f022 0201 	bic.w	r2, r2, #1
 80066da:	601a      	str	r2, [r3, #0]

  /* Update RX threshold configuration */
  MODIFY_REG(huart->Instance->CR3, USART_CR3_RXFTCFG, Threshold);
 80066dc:	687b      	ldr	r3, [r7, #4]
 80066de:	681b      	ldr	r3, [r3, #0]
 80066e0:	689b      	ldr	r3, [r3, #8]
 80066e2:	f023 6160 	bic.w	r1, r3, #234881024	; 0xe000000
 80066e6:	687b      	ldr	r3, [r7, #4]
 80066e8:	681b      	ldr	r3, [r3, #0]
 80066ea:	683a      	ldr	r2, [r7, #0]
 80066ec:	430a      	orrs	r2, r1
 80066ee:	609a      	str	r2, [r3, #8]

  /* Determine the number of data to process during RX/TX ISR execution */
  UARTEx_SetNbDataToProcess(huart);
 80066f0:	6878      	ldr	r0, [r7, #4]
 80066f2:	f000 f811 	bl	8006718 <UARTEx_SetNbDataToProcess>

  /* Restore UART configuration */
  WRITE_REG(huart->Instance->CR1, tmpcr1);
 80066f6:	687b      	ldr	r3, [r7, #4]
 80066f8:	681b      	ldr	r3, [r3, #0]
 80066fa:	68fa      	ldr	r2, [r7, #12]
 80066fc:	601a      	str	r2, [r3, #0]

  huart->gState = HAL_UART_STATE_READY;
 80066fe:	687b      	ldr	r3, [r7, #4]
 8006700:	2220      	movs	r2, #32
 8006702:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84

  /* Process Unlocked */
  __HAL_UNLOCK(huart);
 8006706:	687b      	ldr	r3, [r7, #4]
 8006708:	2200      	movs	r2, #0
 800670a:	f883 2080 	strb.w	r2, [r3, #128]	; 0x80

  return HAL_OK;
 800670e:	2300      	movs	r3, #0
}
 8006710:	4618      	mov	r0, r3
 8006712:	3710      	adds	r7, #16
 8006714:	46bd      	mov	sp, r7
 8006716:	bd80      	pop	{r7, pc}

08006718 <UARTEx_SetNbDataToProcess>:
  *       the UART configuration registers.
  * @param huart UART handle.
  * @retval None
  */
static void UARTEx_SetNbDataToProcess(UART_HandleTypeDef *huart)
{
 8006718:	b480      	push	{r7}
 800671a:	b085      	sub	sp, #20
 800671c:	af00      	add	r7, sp, #0
 800671e:	6078      	str	r0, [r7, #4]
  uint8_t rx_fifo_threshold;
  uint8_t tx_fifo_threshold;
  static const uint8_t numerator[] = {1U, 1U, 1U, 3U, 7U, 1U, 0U, 0U};
  static const uint8_t denominator[] = {8U, 4U, 2U, 4U, 8U, 1U, 1U, 1U};

  if (huart->FifoMode == UART_FIFOMODE_DISABLE)
 8006720:	687b      	ldr	r3, [r7, #4]
 8006722:	6e5b      	ldr	r3, [r3, #100]	; 0x64
 8006724:	2b00      	cmp	r3, #0
 8006726:	d108      	bne.n	800673a <UARTEx_SetNbDataToProcess+0x22>
  {
    huart->NbTxDataToProcess = 1U;
 8006728:	687b      	ldr	r3, [r7, #4]
 800672a:	2201      	movs	r2, #1
 800672c:	f8a3 206a 	strh.w	r2, [r3, #106]	; 0x6a
    huart->NbRxDataToProcess = 1U;
 8006730:	687b      	ldr	r3, [r7, #4]
 8006732:	2201      	movs	r2, #1
 8006734:	f8a3 2068 	strh.w	r2, [r3, #104]	; 0x68
    huart->NbTxDataToProcess = ((uint16_t)tx_fifo_depth * numerator[tx_fifo_threshold]) /
                               (uint16_t)denominator[tx_fifo_threshold];
    huart->NbRxDataToProcess = ((uint16_t)rx_fifo_depth * numerator[rx_fifo_threshold]) /
                               (uint16_t)denominator[rx_fifo_threshold];
  }
}
 8006738:	e031      	b.n	800679e <UARTEx_SetNbDataToProcess+0x86>
    rx_fifo_depth = RX_FIFO_DEPTH;
 800673a:	2310      	movs	r3, #16
 800673c:	73fb      	strb	r3, [r7, #15]
    tx_fifo_depth = TX_FIFO_DEPTH;
 800673e:	2310      	movs	r3, #16
 8006740:	73bb      	strb	r3, [r7, #14]
    rx_fifo_threshold = (uint8_t)(READ_BIT(huart->Instance->CR3, USART_CR3_RXFTCFG) >> USART_CR3_RXFTCFG_Pos);
 8006742:	687b      	ldr	r3, [r7, #4]
 8006744:	681b      	ldr	r3, [r3, #0]
 8006746:	689b      	ldr	r3, [r3, #8]
 8006748:	0e5b      	lsrs	r3, r3, #25
 800674a:	b2db      	uxtb	r3, r3
 800674c:	f003 0307 	and.w	r3, r3, #7
 8006750:	737b      	strb	r3, [r7, #13]
    tx_fifo_threshold = (uint8_t)(READ_BIT(huart->Instance->CR3, USART_CR3_TXFTCFG) >> USART_CR3_TXFTCFG_Pos);
 8006752:	687b      	ldr	r3, [r7, #4]
 8006754:	681b      	ldr	r3, [r3, #0]
 8006756:	689b      	ldr	r3, [r3, #8]
 8006758:	0f5b      	lsrs	r3, r3, #29
 800675a:	b2db      	uxtb	r3, r3
 800675c:	f003 0307 	and.w	r3, r3, #7
 8006760:	733b      	strb	r3, [r7, #12]
    huart->NbTxDataToProcess = ((uint16_t)tx_fifo_depth * numerator[tx_fifo_threshold]) /
 8006762:	7bbb      	ldrb	r3, [r7, #14]
 8006764:	7b3a      	ldrb	r2, [r7, #12]
 8006766:	4911      	ldr	r1, [pc, #68]	; (80067ac <UARTEx_SetNbDataToProcess+0x94>)
 8006768:	5c8a      	ldrb	r2, [r1, r2]
 800676a:	fb02 f303 	mul.w	r3, r2, r3
                               (uint16_t)denominator[tx_fifo_threshold];
 800676e:	7b3a      	ldrb	r2, [r7, #12]
 8006770:	490f      	ldr	r1, [pc, #60]	; (80067b0 <UARTEx_SetNbDataToProcess+0x98>)
 8006772:	5c8a      	ldrb	r2, [r1, r2]
    huart->NbTxDataToProcess = ((uint16_t)tx_fifo_depth * numerator[tx_fifo_threshold]) /
 8006774:	fb93 f3f2 	sdiv	r3, r3, r2
 8006778:	b29a      	uxth	r2, r3
 800677a:	687b      	ldr	r3, [r7, #4]
 800677c:	f8a3 206a 	strh.w	r2, [r3, #106]	; 0x6a
    huart->NbRxDataToProcess = ((uint16_t)rx_fifo_depth * numerator[rx_fifo_threshold]) /
 8006780:	7bfb      	ldrb	r3, [r7, #15]
 8006782:	7b7a      	ldrb	r2, [r7, #13]
 8006784:	4909      	ldr	r1, [pc, #36]	; (80067ac <UARTEx_SetNbDataToProcess+0x94>)
 8006786:	5c8a      	ldrb	r2, [r1, r2]
 8006788:	fb02 f303 	mul.w	r3, r2, r3
                               (uint16_t)denominator[rx_fifo_threshold];
 800678c:	7b7a      	ldrb	r2, [r7, #13]
 800678e:	4908      	ldr	r1, [pc, #32]	; (80067b0 <UARTEx_SetNbDataToProcess+0x98>)
 8006790:	5c8a      	ldrb	r2, [r1, r2]
    huart->NbRxDataToProcess = ((uint16_t)rx_fifo_depth * numerator[rx_fifo_threshold]) /
 8006792:	fb93 f3f2 	sdiv	r3, r3, r2
 8006796:	b29a      	uxth	r2, r3
 8006798:	687b      	ldr	r3, [r7, #4]
 800679a:	f8a3 2068 	strh.w	r2, [r3, #104]	; 0x68
}
 800679e:	bf00      	nop
 80067a0:	3714      	adds	r7, #20
 80067a2:	46bd      	mov	sp, r7
 80067a4:	f85d 7b04 	ldr.w	r7, [sp], #4
 80067a8:	4770      	bx	lr
 80067aa:	bf00      	nop
 80067ac:	08026244 	.word	0x08026244
 80067b0:	0802624c 	.word	0x0802624c

080067b4 <_nxe_dhcp_create>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
UINT  _nxe_dhcp_create(NX_DHCP *dhcp_ptr, NX_IP *ip_ptr, CHAR *name_ptr)
{
 80067b4:	b580      	push	{r7, lr}
 80067b6:	b086      	sub	sp, #24
 80067b8:	af00      	add	r7, sp, #0
 80067ba:	60f8      	str	r0, [r7, #12]
 80067bc:	60b9      	str	r1, [r7, #8]
 80067be:	607a      	str	r2, [r7, #4]

UINT    status;


    /* Check for invalid input pointers.  */
    if ((ip_ptr == NX_NULL) || (ip_ptr -> nx_ip_id != NX_IP_ID) || (dhcp_ptr == NX_NULL))
 80067c0:	68bb      	ldr	r3, [r7, #8]
 80067c2:	2b00      	cmp	r3, #0
 80067c4:	d007      	beq.n	80067d6 <_nxe_dhcp_create+0x22>
 80067c6:	68bb      	ldr	r3, [r7, #8]
 80067c8:	681b      	ldr	r3, [r3, #0]
 80067ca:	4a09      	ldr	r2, [pc, #36]	; (80067f0 <_nxe_dhcp_create+0x3c>)
 80067cc:	4293      	cmp	r3, r2
 80067ce:	d102      	bne.n	80067d6 <_nxe_dhcp_create+0x22>
 80067d0:	68fb      	ldr	r3, [r7, #12]
 80067d2:	2b00      	cmp	r3, #0
 80067d4:	d101      	bne.n	80067da <_nxe_dhcp_create+0x26>
    {
    
        return(NX_PTR_ERROR);
 80067d6:	2307      	movs	r3, #7
 80067d8:	e006      	b.n	80067e8 <_nxe_dhcp_create+0x34>
    }

    /* Call actual DHCP create service.  */
    status =  _nx_dhcp_create(dhcp_ptr, ip_ptr, name_ptr);
 80067da:	687a      	ldr	r2, [r7, #4]
 80067dc:	68b9      	ldr	r1, [r7, #8]
 80067de:	68f8      	ldr	r0, [r7, #12]
 80067e0:	f000 f808 	bl	80067f4 <_nx_dhcp_create>
 80067e4:	6178      	str	r0, [r7, #20]

    /* Return status.  */
    return(status);
 80067e6:	697b      	ldr	r3, [r7, #20]
}
 80067e8:	4618      	mov	r0, r3
 80067ea:	3718      	adds	r7, #24
 80067ec:	46bd      	mov	sp, r7
 80067ee:	bd80      	pop	{r7, pc}
 80067f0:	49502020 	.word	0x49502020

080067f4 <_nx_dhcp_create>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
UINT  _nx_dhcp_create(NX_DHCP *dhcp_ptr, NX_IP *ip_ptr, CHAR *name_ptr)
{
 80067f4:	b580      	push	{r7, lr}
 80067f6:	b08e      	sub	sp, #56	; 0x38
 80067f8:	af08      	add	r7, sp, #32
 80067fa:	60f8      	str	r0, [r7, #12]
 80067fc:	60b9      	str	r1, [r7, #8]
 80067fe:	607a      	str	r2, [r7, #4]
            return (NX_DHCP_INVALID_NAME);
    }
#endif /* NX_DHCP_CLIENT_ENABLE_HOST_NAME_CHECK  */

    /* Initialize the DHCP control block to zero.  */
    memset((void *) dhcp_ptr, 0, sizeof(NX_DHCP));
 8006800:	f641 724c 	movw	r2, #8012	; 0x1f4c
 8006804:	2100      	movs	r1, #0
 8006806:	68f8      	ldr	r0, [r7, #12]
 8006808:	f019 f838 	bl	801f87c <memset>
    
    /* Save the IP pointer.  */
    dhcp_ptr -> nx_dhcp_ip_ptr =  ip_ptr;
 800680c:	68fb      	ldr	r3, [r7, #12]
 800680e:	68ba      	ldr	r2, [r7, #8]
 8006810:	609a      	str	r2, [r3, #8]

    /* Save the DHCP name.  */
    dhcp_ptr -> nx_dhcp_name =  name_ptr;
 8006812:	68fb      	ldr	r3, [r7, #12]
 8006814:	687a      	ldr	r2, [r7, #4]
 8006816:	605a      	str	r2, [r3, #4]
        /* Invalid payload, return error status.  */
        return(NX_DHCP_INVALID_PAYLOAD);
    }

    /* Create the pool and check the status */
    status =  nx_packet_pool_create(&dhcp_ptr -> nx_dhcp_pool, "NetX DHCP Client", NX_DHCP_PACKET_PAYLOAD, 
 8006818:	68fb      	ldr	r3, [r7, #12]
 800681a:	f103 000c 	add.w	r0, r3, #12
                                    dhcp_ptr -> nx_dhcp_pool_area, NX_DHCP_PACKET_POOL_SIZE);
 800681e:	68fb      	ldr	r3, [r7, #12]
 8006820:	3348      	adds	r3, #72	; 0x48
    status =  nx_packet_pool_create(&dhcp_ptr -> nx_dhcp_pool, "NetX DHCP Client", NX_DHCP_PACKET_PAYLOAD, 
 8006822:	f44f 6239 	mov.w	r2, #2960	; 0xb90
 8006826:	9200      	str	r2, [sp, #0]
 8006828:	f44f 7214 	mov.w	r2, #592	; 0x250
 800682c:	497c      	ldr	r1, [pc, #496]	; (8006a20 <_nx_dhcp_create+0x22c>)
 800682e:	f005 fc7f 	bl	800c130 <_nx_packet_pool_create>
 8006832:	6178      	str	r0, [r7, #20]

    /* Determine if it was successful.  */
    if (status != NX_SUCCESS)
 8006834:	697b      	ldr	r3, [r7, #20]
 8006836:	2b00      	cmp	r3, #0
 8006838:	d001      	beq.n	800683e <_nx_dhcp_create+0x4a>
    {

        /* No, return error status.  */
        return(status);
 800683a:	697b      	ldr	r3, [r7, #20]
 800683c:	e0ec      	b.n	8006a18 <_nx_dhcp_create+0x224>
    }

    /* Set an internal packet pool pointer to the newly created packet pool. */
    dhcp_ptr -> nx_dhcp_packet_pool_ptr = &dhcp_ptr -> nx_dhcp_pool;
 800683e:	68fb      	ldr	r3, [r7, #12]
 8006840:	f103 020c 	add.w	r2, r3, #12
 8006844:	68fb      	ldr	r3, [r7, #12]
 8006846:	f8c3 2bd8 	str.w	r2, [r3, #3032]	; 0xbd8
#endif /* NX_DHCP_CLIENT_SEND_MAX_DHCP_MESSAGE_OPTION  */

#endif /* NX_DHCP_CLIENT_USER_CREATE_PACKET_POOL  */

    /* Create the Socket and check the status */
    status = nx_udp_socket_create(ip_ptr, &(dhcp_ptr -> nx_dhcp_socket), "NetX DHCP Client",
 800684a:	68fb      	ldr	r3, [r7, #12]
 800684c:	f603 31dc 	addw	r1, r3, #3036	; 0xbdc
 8006850:	2304      	movs	r3, #4
 8006852:	9302      	str	r3, [sp, #8]
 8006854:	2380      	movs	r3, #128	; 0x80
 8006856:	9301      	str	r3, [sp, #4]
 8006858:	f44f 4380 	mov.w	r3, #16384	; 0x4000
 800685c:	9300      	str	r3, [sp, #0]
 800685e:	2300      	movs	r3, #0
 8006860:	4a6f      	ldr	r2, [pc, #444]	; (8006a20 <_nx_dhcp_create+0x22c>)
 8006862:	68b8      	ldr	r0, [r7, #8]
 8006864:	f009 feda 	bl	801061c <_nx_udp_socket_create>
 8006868:	6178      	str	r0, [r7, #20]
                                  NX_DHCP_TYPE_OF_SERVICE, NX_DHCP_FRAGMENT_OPTION, NX_DHCP_TIME_TO_LIVE, NX_DHCP_QUEUE_DEPTH);

    /* Was the socket creation successful?  */
    if (status != NX_SUCCESS)
 800686a:	697b      	ldr	r3, [r7, #20]
 800686c:	2b00      	cmp	r3, #0
 800686e:	d007      	beq.n	8006880 <_nx_dhcp_create+0x8c>
    {

#ifndef NX_DHCP_CLIENT_USER_CREATE_PACKET_POOL 
        /* Delete the packet pool.  */
        nx_packet_pool_delete(dhcp_ptr -> nx_dhcp_packet_pool_ptr);
 8006870:	68fb      	ldr	r3, [r7, #12]
 8006872:	f8d3 3bd8 	ldr.w	r3, [r3, #3032]	; 0xbd8
 8006876:	4618      	mov	r0, r3
 8006878:	f005 fd2a 	bl	800c2d0 <_nx_packet_pool_delete>
#endif

        /* No, return error status.  */
        return(status);
 800687c:	697b      	ldr	r3, [r7, #20]
 800687e:	e0cb      	b.n	8006a18 <_nx_dhcp_create+0x224>
    }


    /* Set the UDP socket receive callback function.  */
    status = nx_udp_socket_receive_notify(&(dhcp_ptr -> nx_dhcp_socket), _nx_dhcp_udp_receive_notify);
 8006880:	68fb      	ldr	r3, [r7, #12]
 8006882:	f603 33dc 	addw	r3, r3, #3036	; 0xbdc
 8006886:	4967      	ldr	r1, [pc, #412]	; (8006a24 <_nx_dhcp_create+0x230>)
 8006888:	4618      	mov	r0, r3
 800688a:	f00a f909 	bl	8010aa0 <_nx_udp_socket_receive_notify>
 800688e:	6178      	str	r0, [r7, #20]

    /* Check status.  */
    if (status != NX_SUCCESS) 
 8006890:	697b      	ldr	r3, [r7, #20]
 8006892:	2b00      	cmp	r3, #0
 8006894:	d00b      	beq.n	80068ae <_nx_dhcp_create+0xba>
    {


#ifndef NX_DHCP_CLIENT_USER_CREATE_PACKET_POOL 
        /* Delete the packet pool.  */
        nx_packet_pool_delete(dhcp_ptr -> nx_dhcp_packet_pool_ptr);
 8006896:	68fb      	ldr	r3, [r7, #12]
 8006898:	f8d3 3bd8 	ldr.w	r3, [r3, #3032]	; 0xbd8
 800689c:	4618      	mov	r0, r3
 800689e:	f005 fd17 	bl	800c2d0 <_nx_packet_pool_delete>
#endif

        /* Delete the UDP socket.  */
        nx_udp_socket_delete(&(dhcp_ptr -> nx_dhcp_socket));
 80068a2:	68fb      	ldr	r3, [r7, #12]
 80068a4:	f603 33dc 	addw	r3, r3, #3036	; 0xbdc
 80068a8:	4618      	mov	r0, r3
 80068aa:	f009 ff47 	bl	801073c <_nx_udp_socket_delete>
    }

    /* Create the ThreadX activity timeout timer.  This will be used to periodically check to see if
       a client connection has gone silent and needs to be terminated.  */
    status =  tx_timer_create(&(dhcp_ptr -> nx_dhcp_timer), "DHCP Client Timer", _nx_dhcp_timeout_entry,
 80068ae:	68fb      	ldr	r3, [r7, #12]
 80068b0:	f503 50eb 	add.w	r0, r3, #7520	; 0x1d60
 80068b4:	68fb      	ldr	r3, [r7, #12]
 80068b6:	222c      	movs	r2, #44	; 0x2c
 80068b8:	9203      	str	r2, [sp, #12]
 80068ba:	2200      	movs	r2, #0
 80068bc:	9202      	str	r2, [sp, #8]
 80068be:	2264      	movs	r2, #100	; 0x64
 80068c0:	9201      	str	r2, [sp, #4]
 80068c2:	2264      	movs	r2, #100	; 0x64
 80068c4:	9200      	str	r2, [sp, #0]
 80068c6:	4a58      	ldr	r2, [pc, #352]	; (8006a28 <_nx_dhcp_create+0x234>)
 80068c8:	4958      	ldr	r1, [pc, #352]	; (8006a2c <_nx_dhcp_create+0x238>)
 80068ca:	f010 f9ad 	bl	8016c28 <_txe_timer_create>
 80068ce:	6178      	str	r0, [r7, #20]
                              (NX_DHCP_TIME_INTERVAL), TX_NO_ACTIVATE);

    NX_TIMER_EXTENSION_PTR_SET(&(dhcp_ptr -> nx_dhcp_timer), dhcp_ptr)

    /* Determine if the semaphore creation was successful.  */
    if (status != NX_SUCCESS)
 80068d0:	697b      	ldr	r3, [r7, #20]
 80068d2:	2b00      	cmp	r3, #0
 80068d4:	d00d      	beq.n	80068f2 <_nx_dhcp_create+0xfe>
    {

        /* Delete the UDP socket.  */
        nx_udp_socket_delete(&(dhcp_ptr -> nx_dhcp_socket));
 80068d6:	68fb      	ldr	r3, [r7, #12]
 80068d8:	f603 33dc 	addw	r3, r3, #3036	; 0xbdc
 80068dc:	4618      	mov	r0, r3
 80068de:	f009 ff2d 	bl	801073c <_nx_udp_socket_delete>

#ifndef NX_DHCP_CLIENT_USER_CREATE_PACKET_POOL 
        /* Delete the packet pool.  */
        nx_packet_pool_delete(dhcp_ptr -> nx_dhcp_packet_pool_ptr);
 80068e2:	68fb      	ldr	r3, [r7, #12]
 80068e4:	f8d3 3bd8 	ldr.w	r3, [r3, #3032]	; 0xbd8
 80068e8:	4618      	mov	r0, r3
 80068ea:	f005 fcf1 	bl	800c2d0 <_nx_packet_pool_delete>
#endif

        /* No, return error status.  */
        return(status);
 80068ee:	697b      	ldr	r3, [r7, #20]
 80068f0:	e092      	b.n	8006a18 <_nx_dhcp_create+0x224>
    }

    /* Create the DHCP mutex.  */
    status =  tx_mutex_create(&(dhcp_ptr -> nx_dhcp_mutex), "NetX DHCP Client", TX_NO_INHERIT);
 80068f2:	68fb      	ldr	r3, [r7, #12]
 80068f4:	f641 5008 	movw	r0, #7432	; 0x1d08
 80068f8:	4418      	add	r0, r3
 80068fa:	2334      	movs	r3, #52	; 0x34
 80068fc:	2200      	movs	r2, #0
 80068fe:	4948      	ldr	r1, [pc, #288]	; (8006a20 <_nx_dhcp_create+0x22c>)
 8006900:	f00f fbac 	bl	801605c <_txe_mutex_create>
 8006904:	6178      	str	r0, [r7, #20]

    /* Determine if the semaphore creation was successful.  */
    if (status != NX_SUCCESS)
 8006906:	697b      	ldr	r3, [r7, #20]
 8006908:	2b00      	cmp	r3, #0
 800690a:	d013      	beq.n	8006934 <_nx_dhcp_create+0x140>
    {

        /* Delete the UDP socket.  */
        nx_udp_socket_delete(&(dhcp_ptr -> nx_dhcp_socket));
 800690c:	68fb      	ldr	r3, [r7, #12]
 800690e:	f603 33dc 	addw	r3, r3, #3036	; 0xbdc
 8006912:	4618      	mov	r0, r3
 8006914:	f009 ff12 	bl	801073c <_nx_udp_socket_delete>

#ifndef NX_DHCP_CLIENT_USER_CREATE_PACKET_POOL 
        /* Delete the packet pool.  */
        nx_packet_pool_delete(dhcp_ptr -> nx_dhcp_packet_pool_ptr);
 8006918:	68fb      	ldr	r3, [r7, #12]
 800691a:	f8d3 3bd8 	ldr.w	r3, [r3, #3032]	; 0xbd8
 800691e:	4618      	mov	r0, r3
 8006920:	f005 fcd6 	bl	800c2d0 <_nx_packet_pool_delete>
#endif

        /* Delete the timer.  */
        tx_timer_delete(&(dhcp_ptr -> nx_dhcp_timer));
 8006924:	68fb      	ldr	r3, [r7, #12]
 8006926:	f503 53eb 	add.w	r3, r3, #7520	; 0x1d60
 800692a:	4618      	mov	r0, r3
 800692c:	f010 fa28 	bl	8016d80 <_txe_timer_delete>

        /* No, return error status.  */
        return(status);
 8006930:	697b      	ldr	r3, [r7, #20]
 8006932:	e071      	b.n	8006a18 <_nx_dhcp_create+0x224>
    }

    /* Create the DHCP processing thread.  */
    status =  tx_thread_create(&(dhcp_ptr -> nx_dhcp_thread), "NetX DHCP Client", _nx_dhcp_thread_entry, (ULONG)(ALIGN_TYPE)dhcp_ptr,
 8006934:	68fb      	ldr	r3, [r7, #12]
 8006936:	f603 4054 	addw	r0, r3, #3156	; 0xc54
 800693a:	68fa      	ldr	r2, [r7, #12]
 800693c:	68fb      	ldr	r3, [r7, #12]
 800693e:	f603 5308 	addw	r3, r3, #3336	; 0xd08
 8006942:	21b4      	movs	r1, #180	; 0xb4
 8006944:	9106      	str	r1, [sp, #24]
 8006946:	2100      	movs	r1, #0
 8006948:	9105      	str	r1, [sp, #20]
 800694a:	2101      	movs	r1, #1
 800694c:	9104      	str	r1, [sp, #16]
 800694e:	2103      	movs	r1, #3
 8006950:	9103      	str	r1, [sp, #12]
 8006952:	2103      	movs	r1, #3
 8006954:	9102      	str	r1, [sp, #8]
 8006956:	f44f 5180 	mov.w	r1, #4096	; 0x1000
 800695a:	9101      	str	r1, [sp, #4]
 800695c:	9300      	str	r3, [sp, #0]
 800695e:	4613      	mov	r3, r2
 8006960:	4a33      	ldr	r2, [pc, #204]	; (8006a30 <_nx_dhcp_create+0x23c>)
 8006962:	492f      	ldr	r1, [pc, #188]	; (8006a20 <_nx_dhcp_create+0x22c>)
 8006964:	f00f ffbe 	bl	80168e4 <_txe_thread_create>
 8006968:	6178      	str	r0, [r7, #20]
                                NX_DHCP_THREAD_PRIORITY, NX_DHCP_THREAD_PRIORITY, 1, TX_DONT_START);

    NX_THREAD_EXTENSION_PTR_SET(&(dhcp_ptr -> nx_dhcp_thread), dhcp_ptr)

    /* Determine if the thread creation was successful.  */
    if (status != NX_SUCCESS)
 800696a:	697b      	ldr	r3, [r7, #20]
 800696c:	2b00      	cmp	r3, #0
 800696e:	d01a      	beq.n	80069a6 <_nx_dhcp_create+0x1b2>
    {

        /* Delete the mutex.  */
        tx_mutex_delete(&(dhcp_ptr -> nx_dhcp_mutex));
 8006970:	68fa      	ldr	r2, [r7, #12]
 8006972:	f641 5308 	movw	r3, #7432	; 0x1d08
 8006976:	4413      	add	r3, r2
 8006978:	4618      	mov	r0, r3
 800697a:	f00f fc0d 	bl	8016198 <_txe_mutex_delete>

        /* Delete the UDP socket.  */
        nx_udp_socket_delete(&(dhcp_ptr -> nx_dhcp_socket));
 800697e:	68fb      	ldr	r3, [r7, #12]
 8006980:	f603 33dc 	addw	r3, r3, #3036	; 0xbdc
 8006984:	4618      	mov	r0, r3
 8006986:	f009 fed9 	bl	801073c <_nx_udp_socket_delete>

#ifndef NX_DHCP_CLIENT_USER_CREATE_PACKET_POOL 
        /* Delete the packet pool.  */
        nx_packet_pool_delete(dhcp_ptr -> nx_dhcp_packet_pool_ptr);
 800698a:	68fb      	ldr	r3, [r7, #12]
 800698c:	f8d3 3bd8 	ldr.w	r3, [r3, #3032]	; 0xbd8
 8006990:	4618      	mov	r0, r3
 8006992:	f005 fc9d 	bl	800c2d0 <_nx_packet_pool_delete>
#endif

        /* Delete the timer.  */
        tx_timer_delete(&(dhcp_ptr -> nx_dhcp_timer));
 8006996:	68fb      	ldr	r3, [r7, #12]
 8006998:	f503 53eb 	add.w	r3, r3, #7520	; 0x1d60
 800699c:	4618      	mov	r0, r3
 800699e:	f010 f9ef 	bl	8016d80 <_txe_timer_delete>

        /* No, return error status.  */
        return(status);
 80069a2:	697b      	ldr	r3, [r7, #20]
 80069a4:	e038      	b.n	8006a18 <_nx_dhcp_create+0x224>
    }

    /* Create a DHCP event flag group. .  */
    status = tx_event_flags_create(&(dhcp_ptr -> nx_dhcp_events), (CHAR *)"DHCP Client Events");
 80069a6:	68fa      	ldr	r2, [r7, #12]
 80069a8:	f641 533c 	movw	r3, #7484	; 0x1d3c
 80069ac:	4413      	add	r3, r2
 80069ae:	2224      	movs	r2, #36	; 0x24
 80069b0:	4920      	ldr	r1, [pc, #128]	; (8006a34 <_nx_dhcp_create+0x240>)
 80069b2:	4618      	mov	r0, r3
 80069b4:	f00f fa3c 	bl	8015e30 <_txe_event_flags_create>
 80069b8:	6178      	str	r0, [r7, #20]

    /* Check for error. */
    if (status != TX_SUCCESS)
 80069ba:	697b      	ldr	r3, [r7, #20]
 80069bc:	2b00      	cmp	r3, #0
 80069be:	d020      	beq.n	8006a02 <_nx_dhcp_create+0x20e>
    {

        /* Delete the thread.  */
        tx_thread_delete(&(dhcp_ptr -> nx_dhcp_thread));
 80069c0:	68fb      	ldr	r3, [r7, #12]
 80069c2:	f603 4354 	addw	r3, r3, #3156	; 0xc54
 80069c6:	4618      	mov	r0, r3
 80069c8:	f010 f87e 	bl	8016ac8 <_txe_thread_delete>

        /* Delete the mutex.  */
        tx_mutex_delete(&(dhcp_ptr -> nx_dhcp_mutex));
 80069cc:	68fa      	ldr	r2, [r7, #12]
 80069ce:	f641 5308 	movw	r3, #7432	; 0x1d08
 80069d2:	4413      	add	r3, r2
 80069d4:	4618      	mov	r0, r3
 80069d6:	f00f fbdf 	bl	8016198 <_txe_mutex_delete>

        /* Delete the timer.  */
        tx_timer_delete(&(dhcp_ptr -> nx_dhcp_timer));
 80069da:	68fb      	ldr	r3, [r7, #12]
 80069dc:	f503 53eb 	add.w	r3, r3, #7520	; 0x1d60
 80069e0:	4618      	mov	r0, r3
 80069e2:	f010 f9cd 	bl	8016d80 <_txe_timer_delete>

        /* Delete the UDP socket.  */
        nx_udp_socket_delete(&(dhcp_ptr -> nx_dhcp_socket));
 80069e6:	68fb      	ldr	r3, [r7, #12]
 80069e8:	f603 33dc 	addw	r3, r3, #3036	; 0xbdc
 80069ec:	4618      	mov	r0, r3
 80069ee:	f009 fea5 	bl	801073c <_nx_udp_socket_delete>

#ifndef NX_DHCP_CLIENT_USER_CREATE_PACKET_POOL 
        /* Delete the packet pool.  */
        nx_packet_pool_delete(dhcp_ptr -> nx_dhcp_packet_pool_ptr);
 80069f2:	68fb      	ldr	r3, [r7, #12]
 80069f4:	f8d3 3bd8 	ldr.w	r3, [r3, #3032]	; 0xbd8
 80069f8:	4618      	mov	r0, r3
 80069fa:	f005 fc69 	bl	800c2d0 <_nx_packet_pool_delete>
#endif

        /* No, return error status.  */
        return(status);
 80069fe:	697b      	ldr	r3, [r7, #20]
 8006a00:	e00a      	b.n	8006a18 <_nx_dhcp_create+0x224>
    }

    /* Update the dhcp structure ID.  */
    dhcp_ptr -> nx_dhcp_id =  NX_DHCP_ID;
 8006a02:	68fb      	ldr	r3, [r7, #12]
 8006a04:	4a0c      	ldr	r2, [pc, #48]	; (8006a38 <_nx_dhcp_create+0x244>)
 8006a06:	601a      	str	r2, [r3, #0]

    /* Save the DHCP instance.  */
    _nx_dhcp_created_ptr = dhcp_ptr;
 8006a08:	4a0c      	ldr	r2, [pc, #48]	; (8006a3c <_nx_dhcp_create+0x248>)
 8006a0a:	68fb      	ldr	r3, [r7, #12]
 8006a0c:	6013      	str	r3, [r2, #0]

    /* Default enable DHCP on the primary interface (0).  */
    _nx_dhcp_interface_enable(dhcp_ptr, 0);
 8006a0e:	2100      	movs	r1, #0
 8006a10:	68f8      	ldr	r0, [r7, #12]
 8006a12:	f000 fa07 	bl	8006e24 <_nx_dhcp_interface_enable>

    /* Return a successful status.  */
    return(NX_SUCCESS);
 8006a16:	2300      	movs	r3, #0
}
 8006a18:	4618      	mov	r0, r3
 8006a1a:	3718      	adds	r7, #24
 8006a1c:	46bd      	mov	sp, r7
 8006a1e:	bd80      	pop	{r7, pc}
 8006a20:	08021ddc 	.word	0x08021ddc
 8006a24:	08006f61 	.word	0x08006f61
 8006a28:	08006f89 	.word	0x08006f89
 8006a2c:	08021df0 	.word	0x08021df0
 8006a30:	08006faf 	.word	0x08006faf
 8006a34:	08021e04 	.word	0x08021e04
 8006a38:	44484350 	.word	0x44484350
 8006a3c:	24000b04 	.word	0x24000b04

08006a40 <_nx_dhcp_interface_reinitialize>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
UINT _nx_dhcp_interface_reinitialize(NX_DHCP *dhcp_ptr, UINT iface_index)
{
 8006a40:	b580      	push	{r7, lr}
 8006a42:	b088      	sub	sp, #32
 8006a44:	af00      	add	r7, sp, #0
 8006a46:	6078      	str	r0, [r7, #4]
 8006a48:	6039      	str	r1, [r7, #0]

UINT                      status;
ULONG                     ip_address;
ULONG                     network_mask;
ULONG                     gateway_address;
NX_DHCP_INTERFACE_RECORD *interface_record = NX_NULL;
 8006a4a:	2300      	movs	r3, #0
 8006a4c:	60fb      	str	r3, [r7, #12]

  
    /* Obtain DHCP Client protection mutex. */
    tx_mutex_get(&(dhcp_ptr -> nx_dhcp_mutex), NX_WAIT_FOREVER);
 8006a4e:	687a      	ldr	r2, [r7, #4]
 8006a50:	f641 5308 	movw	r3, #7432	; 0x1d08
 8006a54:	4413      	add	r3, r2
 8006a56:	f04f 31ff 	mov.w	r1, #4294967295
 8006a5a:	4618      	mov	r0, r3
 8006a5c:	f00f fbda 	bl	8016214 <_txe_mutex_get>

    /* Find the interface record.  */
    status = _nx_dhcp_interface_record_find(dhcp_ptr, iface_index, &interface_record);
 8006a60:	f107 030c 	add.w	r3, r7, #12
 8006a64:	461a      	mov	r2, r3
 8006a66:	6839      	ldr	r1, [r7, #0]
 8006a68:	6878      	ldr	r0, [r7, #4]
 8006a6a:	f001 fe46 	bl	80086fa <_nx_dhcp_interface_record_find>
 8006a6e:	61f8      	str	r0, [r7, #28]

    /* Check status.  */
    if (status)
 8006a70:	69fb      	ldr	r3, [r7, #28]
 8006a72:	2b00      	cmp	r3, #0
 8006a74:	d008      	beq.n	8006a88 <_nx_dhcp_interface_reinitialize+0x48>
    {

        tx_mutex_put(&(dhcp_ptr -> nx_dhcp_mutex));
 8006a76:	687a      	ldr	r2, [r7, #4]
 8006a78:	f641 5308 	movw	r3, #7432	; 0x1d08
 8006a7c:	4413      	add	r3, r2
 8006a7e:	4618      	mov	r0, r3
 8006a80:	f00f fc22 	bl	80162c8 <_txe_mutex_put>
        return(status);
 8006a84:	69fb      	ldr	r3, [r7, #28]
 8006a86:	e063      	b.n	8006b50 <_nx_dhcp_interface_reinitialize+0x110>
    }

    /* Check if have IP address.  */
    if (interface_record -> nx_dhcp_ip_address)
 8006a88:	68fb      	ldr	r3, [r7, #12]
 8006a8a:	68db      	ldr	r3, [r3, #12]
 8006a8c:	2b00      	cmp	r3, #0
 8006a8e:	d018      	beq.n	8006ac2 <_nx_dhcp_interface_reinitialize+0x82>
    {

        /* Get the IP address.  */
        status = nx_ip_interface_address_get(dhcp_ptr -> nx_dhcp_ip_ptr, iface_index, &ip_address, &network_mask);
 8006a90:	687b      	ldr	r3, [r7, #4]
 8006a92:	6898      	ldr	r0, [r3, #8]
 8006a94:	f107 0314 	add.w	r3, r7, #20
 8006a98:	f107 0218 	add.w	r2, r7, #24
 8006a9c:	6839      	ldr	r1, [r7, #0]
 8006a9e:	f003 ffdb 	bl	800aa58 <_nx_ip_interface_address_get>
 8006aa2:	61f8      	str	r0, [r7, #28]

        /* Check if the IP address is set by DHCP.  */
        if ((status == NX_SUCCESS) && (ip_address == interface_record -> nx_dhcp_ip_address))
 8006aa4:	69fb      	ldr	r3, [r7, #28]
 8006aa6:	2b00      	cmp	r3, #0
 8006aa8:	d10b      	bne.n	8006ac2 <_nx_dhcp_interface_reinitialize+0x82>
 8006aaa:	68fb      	ldr	r3, [r7, #12]
 8006aac:	68da      	ldr	r2, [r3, #12]
 8006aae:	69bb      	ldr	r3, [r7, #24]
 8006ab0:	429a      	cmp	r2, r3
 8006ab2:	d106      	bne.n	8006ac2 <_nx_dhcp_interface_reinitialize+0x82>
        {

            /* Clear the IP address.  */
            nx_ip_interface_address_set(dhcp_ptr -> nx_dhcp_ip_ptr, iface_index, 0, 0);
 8006ab4:	687b      	ldr	r3, [r7, #4]
 8006ab6:	6898      	ldr	r0, [r3, #8]
 8006ab8:	2300      	movs	r3, #0
 8006aba:	2200      	movs	r2, #0
 8006abc:	6839      	ldr	r1, [r7, #0]
 8006abe:	f004 f82e 	bl	800ab1e <_nx_ip_interface_address_set>
        }
    }

    /* Check if have gateway address.  */
    if (interface_record -> nx_dhcp_gateway_address)
 8006ac2:	68fb      	ldr	r3, [r7, #12]
 8006ac4:	691b      	ldr	r3, [r3, #16]
 8006ac6:	2b00      	cmp	r3, #0
 8006ac8:	d015      	beq.n	8006af6 <_nx_dhcp_interface_reinitialize+0xb6>
    {

        /* Get the gateway address.  */
        status = nx_ip_gateway_address_get(dhcp_ptr -> nx_dhcp_ip_ptr, &gateway_address);
 8006aca:	687b      	ldr	r3, [r7, #4]
 8006acc:	689b      	ldr	r3, [r3, #8]
 8006ace:	f107 0210 	add.w	r2, r7, #16
 8006ad2:	4611      	mov	r1, r2
 8006ad4:	4618      	mov	r0, r3
 8006ad6:	f003 fe52 	bl	800a77e <_nx_ip_gateway_address_get>
 8006ada:	61f8      	str	r0, [r7, #28]

        /* Check status.  */
        if ((status == NX_SUCCESS) && (gateway_address == interface_record -> nx_dhcp_gateway_address))
 8006adc:	69fb      	ldr	r3, [r7, #28]
 8006ade:	2b00      	cmp	r3, #0
 8006ae0:	d109      	bne.n	8006af6 <_nx_dhcp_interface_reinitialize+0xb6>
 8006ae2:	68fb      	ldr	r3, [r7, #12]
 8006ae4:	691a      	ldr	r2, [r3, #16]
 8006ae6:	693b      	ldr	r3, [r7, #16]
 8006ae8:	429a      	cmp	r2, r3
 8006aea:	d104      	bne.n	8006af6 <_nx_dhcp_interface_reinitialize+0xb6>
        {

            /* Clear the Gateway/Router IP address.  */
            nx_ip_gateway_address_clear(dhcp_ptr -> nx_dhcp_ip_ptr);
 8006aec:	687b      	ldr	r3, [r7, #4]
 8006aee:	689b      	ldr	r3, [r3, #8]
 8006af0:	4618      	mov	r0, r3
 8006af2:	f003 fe19 	bl	800a728 <_nx_ip_gateway_address_clear>
        }
    }

    /* Initialize the client DHCP IP address with the NULL IP address.  */
    interface_record -> nx_dhcp_ip_address =  NX_BOOTP_NO_ADDRESS; 
 8006af6:	68fb      	ldr	r3, [r7, #12]
 8006af8:	2200      	movs	r2, #0
 8006afa:	60da      	str	r2, [r3, #12]

    /* Initialize the client DHCP server IP address.  */
    interface_record -> nx_dhcp_server_ip =  NX_BOOTP_NO_ADDRESS; 
 8006afc:	68fb      	ldr	r3, [r7, #12]
 8006afe:	2200      	movs	r2, #0
 8006b00:	615a      	str	r2, [r3, #20]

    /* Clear these DHCP Client network values too.*/
    interface_record -> nx_dhcp_gateway_address = NX_BOOTP_NO_ADDRESS; 
 8006b02:	68fb      	ldr	r3, [r7, #12]
 8006b04:	2200      	movs	r2, #0
 8006b06:	611a      	str	r2, [r3, #16]
    interface_record -> nx_dhcp_network_mask = NX_BOOTP_NO_ADDRESS;
 8006b08:	68fb      	ldr	r3, [r7, #12]
 8006b0a:	2200      	movs	r2, #0
 8006b0c:	619a      	str	r2, [r3, #24]

    /* Clear the flag to skip the discovery step. The host application must
       call the nx_dhcp_request_ip_address to reset the flag and the requested IP address. */
    interface_record -> nx_dhcp_skip_discovery = NX_FALSE;
 8006b0e:	68fb      	ldr	r3, [r7, #12]
 8006b10:	2200      	movs	r2, #0
 8006b12:	645a      	str	r2, [r3, #68]	; 0x44
                                                             
    /* Initialize renew and rebind timeout values to zero.  */
    interface_record -> nx_dhcp_rebind_time = 0;
 8006b14:	68fb      	ldr	r3, [r7, #12]
 8006b16:	2200      	movs	r2, #0
 8006b18:	635a      	str	r2, [r3, #52]	; 0x34
    interface_record -> nx_dhcp_renewal_time =  0;
 8006b1a:	68fb      	ldr	r3, [r7, #12]
 8006b1c:	2200      	movs	r2, #0
 8006b1e:	631a      	str	r2, [r3, #48]	; 0x30

    /* Setup for infinite lease time request.  */
    interface_record -> nx_dhcp_lease_time =  NX_DHCP_INFINITE_LEASE;
 8006b20:	68fb      	ldr	r3, [r7, #12]
 8006b22:	f04f 32ff 	mov.w	r2, #4294967295
 8006b26:	62da      	str	r2, [r3, #44]	; 0x2c

    /* Reset the seconds field for starting the DHCP request process. */
    interface_record -> nx_dhcp_seconds = 0;
 8006b28:	68fb      	ldr	r3, [r7, #12]
 8006b2a:	2200      	movs	r2, #0
 8006b2c:	609a      	str	r2, [r3, #8]

    /* Reset the timeout and retransmission interval.  */
    interface_record -> nx_dhcp_timeout = 0;
 8006b2e:	68fb      	ldr	r3, [r7, #12]
 8006b30:	2200      	movs	r2, #0
 8006b32:	621a      	str	r2, [r3, #32]
    interface_record -> nx_dhcp_rtr_interval = 0;
 8006b34:	68fb      	ldr	r3, [r7, #12]
 8006b36:	2200      	movs	r2, #0
 8006b38:	625a      	str	r2, [r3, #36]	; 0x24

    /* Set the DHCP state to the initial state.  */
    interface_record -> nx_dhcp_state =  NX_DHCP_STATE_NOT_STARTED;
 8006b3a:	68fb      	ldr	r3, [r7, #12]
 8006b3c:	2200      	movs	r2, #0
 8006b3e:	705a      	strb	r2, [r3, #1]

    /* Release the mutex.  */
    tx_mutex_put(&(dhcp_ptr -> nx_dhcp_mutex));
 8006b40:	687a      	ldr	r2, [r7, #4]
 8006b42:	f641 5308 	movw	r3, #7432	; 0x1d08
 8006b46:	4413      	add	r3, r2
 8006b48:	4618      	mov	r0, r3
 8006b4a:	f00f fbbd 	bl	80162c8 <_txe_mutex_put>
    return NX_SUCCESS;
 8006b4e:	2300      	movs	r3, #0
}
 8006b50:	4618      	mov	r0, r3
 8006b52:	3720      	adds	r7, #32
 8006b54:	46bd      	mov	sp, r7
 8006b56:	bd80      	pop	{r7, pc}

08006b58 <_nxe_dhcp_start>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
UINT  _nxe_dhcp_start(NX_DHCP *dhcp_ptr)
{
 8006b58:	b580      	push	{r7, lr}
 8006b5a:	b084      	sub	sp, #16
 8006b5c:	af00      	add	r7, sp, #0
 8006b5e:	6078      	str	r0, [r7, #4]

UINT    status;


    /* Check for invalid input pointer.  */
    if ((dhcp_ptr == NX_NULL) || (dhcp_ptr -> nx_dhcp_id != NX_DHCP_ID))
 8006b60:	687b      	ldr	r3, [r7, #4]
 8006b62:	2b00      	cmp	r3, #0
 8006b64:	d004      	beq.n	8006b70 <_nxe_dhcp_start+0x18>
 8006b66:	687b      	ldr	r3, [r7, #4]
 8006b68:	681b      	ldr	r3, [r3, #0]
 8006b6a:	4a11      	ldr	r2, [pc, #68]	; (8006bb0 <_nxe_dhcp_start+0x58>)
 8006b6c:	4293      	cmp	r3, r2
 8006b6e:	d001      	beq.n	8006b74 <_nxe_dhcp_start+0x1c>
        return(NX_PTR_ERROR);
 8006b70:	2307      	movs	r3, #7
 8006b72:	e018      	b.n	8006ba6 <_nxe_dhcp_start+0x4e>
#elif defined(__GNUC__) /* GCC and ARM Compiler 6 */

__attribute__( ( always_inline ) ) static inline unsigned int __get_ipsr_value(void)
{
unsigned int  ipsr_value;
    __asm__ volatile (" MRS  %0,IPSR ": "=r" (ipsr_value) );
 8006b74:	f3ef 8305 	mrs	r3, IPSR
 8006b78:	60bb      	str	r3, [r7, #8]
    return(ipsr_value);
 8006b7a:	68ba      	ldr	r2, [r7, #8]
    
    /* Check for appropriate caller.  */
    NX_THREADS_ONLY_CALLER_CHECKING
 8006b7c:	4b0d      	ldr	r3, [pc, #52]	; (8006bb4 <_nxe_dhcp_start+0x5c>)
 8006b7e:	681b      	ldr	r3, [r3, #0]
 8006b80:	4313      	orrs	r3, r2
 8006b82:	2b00      	cmp	r3, #0
 8006b84:	d108      	bne.n	8006b98 <_nxe_dhcp_start+0x40>
 8006b86:	4b0c      	ldr	r3, [pc, #48]	; (8006bb8 <_nxe_dhcp_start+0x60>)
 8006b88:	681b      	ldr	r3, [r3, #0]
 8006b8a:	2b00      	cmp	r3, #0
 8006b8c:	d004      	beq.n	8006b98 <_nxe_dhcp_start+0x40>
 8006b8e:	4b0a      	ldr	r3, [pc, #40]	; (8006bb8 <_nxe_dhcp_start+0x60>)
 8006b90:	681b      	ldr	r3, [r3, #0]
 8006b92:	4a0a      	ldr	r2, [pc, #40]	; (8006bbc <_nxe_dhcp_start+0x64>)
 8006b94:	4293      	cmp	r3, r2
 8006b96:	d101      	bne.n	8006b9c <_nxe_dhcp_start+0x44>
 8006b98:	2311      	movs	r3, #17
 8006b9a:	e004      	b.n	8006ba6 <_nxe_dhcp_start+0x4e>

    /* Call actual DHCP start service.  */
    status =  _nx_dhcp_start(dhcp_ptr);
 8006b9c:	6878      	ldr	r0, [r7, #4]
 8006b9e:	f000 f80f 	bl	8006bc0 <_nx_dhcp_start>
 8006ba2:	60f8      	str	r0, [r7, #12]

    /* Return status.  */
    return(status);
 8006ba4:	68fb      	ldr	r3, [r7, #12]
}
 8006ba6:	4618      	mov	r0, r3
 8006ba8:	3710      	adds	r7, #16
 8006baa:	46bd      	mov	sp, r7
 8006bac:	bd80      	pop	{r7, pc}
 8006bae:	bf00      	nop
 8006bb0:	44484350 	.word	0x44484350
 8006bb4:	24000078 	.word	0x24000078
 8006bb8:	24031bc4 	.word	0x24031bc4
 8006bbc:	24031d0c 	.word	0x24031d0c

08006bc0 <_nx_dhcp_start>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
UINT  _nx_dhcp_start(NX_DHCP *dhcp_ptr)
{
 8006bc0:	b580      	push	{r7, lr}
 8006bc2:	b086      	sub	sp, #24
 8006bc4:	af00      	add	r7, sp, #0
 8006bc6:	6078      	str	r0, [r7, #4]

UINT    status;
UINT    interfaces_started = 0;
 8006bc8:	2300      	movs	r3, #0
 8006bca:	617b      	str	r3, [r7, #20]
UINT    i;


    /* Get the DHCP mutex.  */
    tx_mutex_get(&(dhcp_ptr -> nx_dhcp_mutex), TX_WAIT_FOREVER);
 8006bcc:	687a      	ldr	r2, [r7, #4]
 8006bce:	f641 5308 	movw	r3, #7432	; 0x1d08
 8006bd2:	4413      	add	r3, r2
 8006bd4:	f04f 31ff 	mov.w	r1, #4294967295
 8006bd8:	4618      	mov	r0, r3
 8006bda:	f00f fb1b 	bl	8016214 <_txe_mutex_get>

    /* Check all interfaces to find out which need to start the DHCP protocol.  */
    for (i = 0; i < NX_DHCP_CLIENT_MAX_RECORDS; i++) 
 8006bde:	2300      	movs	r3, #0
 8006be0:	613b      	str	r3, [r7, #16]
 8006be2:	e028      	b.n	8006c36 <_nx_dhcp_start+0x76>
    {

        /* Check if this record is valid.  */
        if (dhcp_ptr -> nx_dhcp_interface_record[i].nx_dhcp_record_valid == NX_TRUE)
 8006be4:	687a      	ldr	r2, [r7, #4]
 8006be6:	693b      	ldr	r3, [r7, #16]
 8006be8:	f44f 71d8 	mov.w	r1, #432	; 0x1b0
 8006bec:	fb01 f303 	mul.w	r3, r1, r3
 8006bf0:	441a      	add	r2, r3
 8006bf2:	f641 538c 	movw	r3, #7564	; 0x1d8c
 8006bf6:	4413      	add	r3, r2
 8006bf8:	781b      	ldrb	r3, [r3, #0]
 8006bfa:	2b01      	cmp	r3, #1
 8006bfc:	d118      	bne.n	8006c30 <_nx_dhcp_start+0x70>
        {

            /* Start DHCP on this interface.   */
             status = _nx_dhcp_interface_start(dhcp_ptr, dhcp_ptr -> nx_dhcp_interface_record[i].nx_dhcp_interface_index);
 8006bfe:	687a      	ldr	r2, [r7, #4]
 8006c00:	693b      	ldr	r3, [r7, #16]
 8006c02:	f44f 71d8 	mov.w	r1, #432	; 0x1b0
 8006c06:	fb01 f303 	mul.w	r3, r1, r3
 8006c0a:	441a      	add	r2, r3
 8006c0c:	f641 53a8 	movw	r3, #7592	; 0x1da8
 8006c10:	4413      	add	r3, r2
 8006c12:	681b      	ldr	r3, [r3, #0]
 8006c14:	4619      	mov	r1, r3
 8006c16:	6878      	ldr	r0, [r7, #4]
 8006c18:	f000 f828 	bl	8006c6c <_nx_dhcp_interface_start>
 8006c1c:	60f8      	str	r0, [r7, #12]
             /* Note, not all interfaces are enabled to run, so
                status may not be successful. Skip to the next
                interface. */

             /* Check status.  */
             if ((status == NX_SUCCESS) || (status == NX_DHCP_ALREADY_STARTED))
 8006c1e:	68fb      	ldr	r3, [r7, #12]
 8006c20:	2b00      	cmp	r3, #0
 8006c22:	d002      	beq.n	8006c2a <_nx_dhcp_start+0x6a>
 8006c24:	68fb      	ldr	r3, [r7, #12]
 8006c26:	2b93      	cmp	r3, #147	; 0x93
 8006c28:	d102      	bne.n	8006c30 <_nx_dhcp_start+0x70>
             {
                 interfaces_started++;
 8006c2a:	697b      	ldr	r3, [r7, #20]
 8006c2c:	3301      	adds	r3, #1
 8006c2e:	617b      	str	r3, [r7, #20]
    for (i = 0; i < NX_DHCP_CLIENT_MAX_RECORDS; i++) 
 8006c30:	693b      	ldr	r3, [r7, #16]
 8006c32:	3301      	adds	r3, #1
 8006c34:	613b      	str	r3, [r7, #16]
 8006c36:	693b      	ldr	r3, [r7, #16]
 8006c38:	2b00      	cmp	r3, #0
 8006c3a:	d0d3      	beq.n	8006be4 <_nx_dhcp_start+0x24>
             }
        }
    }

    /* Check if any interfaces started DHCP. */
    if (interfaces_started == 0) 
 8006c3c:	697b      	ldr	r3, [r7, #20]
 8006c3e:	2b00      	cmp	r3, #0
 8006c40:	d108      	bne.n	8006c54 <_nx_dhcp_start+0x94>
    {

        /* Release the DHCP mutex.  */
        tx_mutex_put(&(dhcp_ptr -> nx_dhcp_mutex));
 8006c42:	687a      	ldr	r2, [r7, #4]
 8006c44:	f641 5308 	movw	r3, #7432	; 0x1d08
 8006c48:	4413      	add	r3, r2
 8006c4a:	4618      	mov	r0, r3
 8006c4c:	f00f fb3c 	bl	80162c8 <_txe_mutex_put>

        /* Unable to start any interfaces. */
        return NX_DHCP_NO_INTERFACES_STARTED;
 8006c50:	23a6      	movs	r3, #166	; 0xa6
 8006c52:	e007      	b.n	8006c64 <_nx_dhcp_start+0xa4>
    }

    /* Release the DHCP mutex.  */
    tx_mutex_put(&(dhcp_ptr -> nx_dhcp_mutex));
 8006c54:	687a      	ldr	r2, [r7, #4]
 8006c56:	f641 5308 	movw	r3, #7432	; 0x1d08
 8006c5a:	4413      	add	r3, r2
 8006c5c:	4618      	mov	r0, r3
 8006c5e:	f00f fb33 	bl	80162c8 <_txe_mutex_put>

    /* Return completion status.  */
    return(NX_SUCCESS);  
 8006c62:	2300      	movs	r3, #0
}
 8006c64:	4618      	mov	r0, r3
 8006c66:	3718      	adds	r7, #24
 8006c68:	46bd      	mov	sp, r7
 8006c6a:	bd80      	pop	{r7, pc}

08006c6c <_nx_dhcp_interface_start>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
UINT  _nx_dhcp_interface_start(NX_DHCP *dhcp_ptr, UINT iface_index)
{
 8006c6c:	b580      	push	{r7, lr}
 8006c6e:	b086      	sub	sp, #24
 8006c70:	af00      	add	r7, sp, #0
 8006c72:	6078      	str	r0, [r7, #4]
 8006c74:	6039      	str	r1, [r7, #0]

UINT    i;
UINT    status;
NX_DHCP_INTERFACE_RECORD *interface_record = NX_NULL;
 8006c76:	2300      	movs	r3, #0
 8006c78:	60fb      	str	r3, [r7, #12]

    
    /* Get the DHCP mutex.  */
    tx_mutex_get(&(dhcp_ptr -> nx_dhcp_mutex), TX_WAIT_FOREVER);
 8006c7a:	687a      	ldr	r2, [r7, #4]
 8006c7c:	f641 5308 	movw	r3, #7432	; 0x1d08
 8006c80:	4413      	add	r3, r2
 8006c82:	f04f 31ff 	mov.w	r1, #4294967295
 8006c86:	4618      	mov	r0, r3
 8006c88:	f00f fac4 	bl	8016214 <_txe_mutex_get>

    /* Find the interface record.  */
    status = _nx_dhcp_interface_record_find(dhcp_ptr, iface_index, &interface_record);
 8006c8c:	f107 030c 	add.w	r3, r7, #12
 8006c90:	461a      	mov	r2, r3
 8006c92:	6839      	ldr	r1, [r7, #0]
 8006c94:	6878      	ldr	r0, [r7, #4]
 8006c96:	f001 fd30 	bl	80086fa <_nx_dhcp_interface_record_find>
 8006c9a:	6138      	str	r0, [r7, #16]

    /* Check status.  */
    if (status)
 8006c9c:	693b      	ldr	r3, [r7, #16]
 8006c9e:	2b00      	cmp	r3, #0
 8006ca0:	d008      	beq.n	8006cb4 <_nx_dhcp_interface_start+0x48>
    {

        /* Release the DHCP mutex.  */
        tx_mutex_put(&(dhcp_ptr -> nx_dhcp_mutex));
 8006ca2:	687a      	ldr	r2, [r7, #4]
 8006ca4:	f641 5308 	movw	r3, #7432	; 0x1d08
 8006ca8:	4413      	add	r3, r2
 8006caa:	4618      	mov	r0, r3
 8006cac:	f00f fb0c 	bl	80162c8 <_txe_mutex_put>

        return(status);
 8006cb0:	693b      	ldr	r3, [r7, #16]
 8006cb2:	e0b3      	b.n	8006e1c <_nx_dhcp_interface_start+0x1b0>
    }

    /* Check if DHCP is already started.  */
    if (interface_record -> nx_dhcp_state != NX_DHCP_STATE_NOT_STARTED)
 8006cb4:	68fb      	ldr	r3, [r7, #12]
 8006cb6:	785b      	ldrb	r3, [r3, #1]
 8006cb8:	2b00      	cmp	r3, #0
 8006cba:	d008      	beq.n	8006cce <_nx_dhcp_interface_start+0x62>
    {

        /* Release the DHCP mutex.  */
        tx_mutex_put(&(dhcp_ptr -> nx_dhcp_mutex));
 8006cbc:	687a      	ldr	r2, [r7, #4]
 8006cbe:	f641 5308 	movw	r3, #7432	; 0x1d08
 8006cc2:	4413      	add	r3, r2
 8006cc4:	4618      	mov	r0, r3
 8006cc6:	f00f faff 	bl	80162c8 <_txe_mutex_put>
        return(NX_DHCP_ALREADY_STARTED); 
 8006cca:	2393      	movs	r3, #147	; 0x93
 8006ccc:	e0a6      	b.n	8006e1c <_nx_dhcp_interface_start+0x1b0>
    }
                                   
    /* Check if other interface are working.  */
    for (i = 0; i < NX_DHCP_CLIENT_MAX_RECORDS; i++)
 8006cce:	2300      	movs	r3, #0
 8006cd0:	617b      	str	r3, [r7, #20]
 8006cd2:	e01c      	b.n	8006d0e <_nx_dhcp_interface_start+0xa2>
    {

        /* Check which interface record is valid.  */
        if ((dhcp_ptr -> nx_dhcp_interface_record[i].nx_dhcp_record_valid) &&
 8006cd4:	687a      	ldr	r2, [r7, #4]
 8006cd6:	697b      	ldr	r3, [r7, #20]
 8006cd8:	f44f 71d8 	mov.w	r1, #432	; 0x1b0
 8006cdc:	fb01 f303 	mul.w	r3, r1, r3
 8006ce0:	441a      	add	r2, r3
 8006ce2:	f641 538c 	movw	r3, #7564	; 0x1d8c
 8006ce6:	4413      	add	r3, r2
 8006ce8:	781b      	ldrb	r3, [r3, #0]
 8006cea:	2b00      	cmp	r3, #0
 8006cec:	d00c      	beq.n	8006d08 <_nx_dhcp_interface_start+0x9c>
            (dhcp_ptr -> nx_dhcp_interface_record[i].nx_dhcp_state != NX_DHCP_STATE_NOT_STARTED))
 8006cee:	687a      	ldr	r2, [r7, #4]
 8006cf0:	697b      	ldr	r3, [r7, #20]
 8006cf2:	f44f 71d8 	mov.w	r1, #432	; 0x1b0
 8006cf6:	fb01 f303 	mul.w	r3, r1, r3
 8006cfa:	441a      	add	r2, r3
 8006cfc:	f641 538d 	movw	r3, #7565	; 0x1d8d
 8006d00:	4413      	add	r3, r2
 8006d02:	781b      	ldrb	r3, [r3, #0]
        if ((dhcp_ptr -> nx_dhcp_interface_record[i].nx_dhcp_record_valid) &&
 8006d04:	2b00      	cmp	r3, #0
 8006d06:	d106      	bne.n	8006d16 <_nx_dhcp_interface_start+0xaa>
    for (i = 0; i < NX_DHCP_CLIENT_MAX_RECORDS; i++)
 8006d08:	697b      	ldr	r3, [r7, #20]
 8006d0a:	3301      	adds	r3, #1
 8006d0c:	617b      	str	r3, [r7, #20]
 8006d0e:	697b      	ldr	r3, [r7, #20]
 8006d10:	2b00      	cmp	r3, #0
 8006d12:	d0df      	beq.n	8006cd4 <_nx_dhcp_interface_start+0x68>
 8006d14:	e000      	b.n	8006d18 <_nx_dhcp_interface_start+0xac>
        {

            /* Yes, other interface have started DHCP.  */
            break;
 8006d16:	bf00      	nop
        }
    }

    /* Check if any interfaces have started DHCP.  */
    if (i == NX_DHCP_CLIENT_MAX_RECORDS) 
 8006d18:	697b      	ldr	r3, [r7, #20]
 8006d1a:	2b01      	cmp	r3, #1
 8006d1c:	d14a      	bne.n	8006db4 <_nx_dhcp_interface_start+0x148>
    {

        /* Bind the UDP socket to the DHCP Client port.  */
        status =  nx_udp_socket_bind(&(dhcp_ptr -> nx_dhcp_socket), NX_DHCP_CLIENT_UDP_PORT, NX_WAIT_FOREVER);
 8006d1e:	687b      	ldr	r3, [r7, #4]
 8006d20:	f603 33dc 	addw	r3, r3, #3036	; 0xbdc
 8006d24:	f04f 32ff 	mov.w	r2, #4294967295
 8006d28:	2144      	movs	r1, #68	; 0x44
 8006d2a:	4618      	mov	r0, r3
 8006d2c:	f009 fb52 	bl	80103d4 <_nx_udp_socket_bind>
 8006d30:	6138      	str	r0, [r7, #16]

        /* Check for error */
        if (status != NX_SUCCESS)
 8006d32:	693b      	ldr	r3, [r7, #16]
 8006d34:	2b00      	cmp	r3, #0
 8006d36:	d008      	beq.n	8006d4a <_nx_dhcp_interface_start+0xde>
        {

            /* Release the DHCP mutex.  */
            tx_mutex_put(&(dhcp_ptr -> nx_dhcp_mutex));
 8006d38:	687a      	ldr	r2, [r7, #4]
 8006d3a:	f641 5308 	movw	r3, #7432	; 0x1d08
 8006d3e:	4413      	add	r3, r2
 8006d40:	4618      	mov	r0, r3
 8006d42:	f00f fac1 	bl	80162c8 <_txe_mutex_put>
            return(status);
 8006d46:	693b      	ldr	r3, [r7, #16]
 8006d48:	e068      	b.n	8006e1c <_nx_dhcp_interface_start+0x1b0>
        }

        /* Resume the DHCP processing thread.  */
        status = tx_thread_resume(&(dhcp_ptr -> nx_dhcp_thread));
 8006d4a:	687b      	ldr	r3, [r7, #4]
 8006d4c:	f603 4354 	addw	r3, r3, #3156	; 0xc54
 8006d50:	4618      	mov	r0, r3
 8006d52:	f00f ff01 	bl	8016b58 <_txe_thread_resume>
 8006d56:	6138      	str	r0, [r7, #16]

        /* Determine if the resume was successful.  */
        if ((status != TX_SUCCESS) && (status != TX_SUSPEND_LIFTED))
 8006d58:	693b      	ldr	r3, [r7, #16]
 8006d5a:	2b00      	cmp	r3, #0
 8006d5c:	d011      	beq.n	8006d82 <_nx_dhcp_interface_start+0x116>
 8006d5e:	693b      	ldr	r3, [r7, #16]
 8006d60:	2b19      	cmp	r3, #25
 8006d62:	d00e      	beq.n	8006d82 <_nx_dhcp_interface_start+0x116>
        {

            /* Error, unbind the DHCP socket.  */
            nx_udp_socket_unbind(&(dhcp_ptr -> nx_dhcp_socket));
 8006d64:	687b      	ldr	r3, [r7, #4]
 8006d66:	f603 33dc 	addw	r3, r3, #3036	; 0xbdc
 8006d6a:	4618      	mov	r0, r3
 8006d6c:	f009 feee 	bl	8010b4c <_nx_udp_socket_unbind>

            /* Release the DHCP mutex.  */
            tx_mutex_put(&(dhcp_ptr -> nx_dhcp_mutex));
 8006d70:	687a      	ldr	r2, [r7, #4]
 8006d72:	f641 5308 	movw	r3, #7432	; 0x1d08
 8006d76:	4413      	add	r3, r2
 8006d78:	4618      	mov	r0, r3
 8006d7a:	f00f faa5 	bl	80162c8 <_txe_mutex_put>
            return(status);
 8006d7e:	693b      	ldr	r3, [r7, #16]
 8006d80:	e04c      	b.n	8006e1c <_nx_dhcp_interface_start+0x1b0>
        }

        /* Activate DHCP Timer.  */
        status = tx_timer_activate(&(dhcp_ptr -> nx_dhcp_timer));
 8006d82:	687b      	ldr	r3, [r7, #4]
 8006d84:	f503 53eb 	add.w	r3, r3, #7520	; 0x1d60
 8006d88:	4618      	mov	r0, r3
 8006d8a:	f00f ff2f 	bl	8016bec <_txe_timer_activate>
 8006d8e:	6138      	str	r0, [r7, #16]

        /* Determine if the resume was successful.  */
        if (status != NX_SUCCESS)
 8006d90:	693b      	ldr	r3, [r7, #16]
 8006d92:	2b00      	cmp	r3, #0
 8006d94:	d00e      	beq.n	8006db4 <_nx_dhcp_interface_start+0x148>
        {

            /* Error, unbind the DHCP socket.  */
            nx_udp_socket_unbind(&(dhcp_ptr -> nx_dhcp_socket));
 8006d96:	687b      	ldr	r3, [r7, #4]
 8006d98:	f603 33dc 	addw	r3, r3, #3036	; 0xbdc
 8006d9c:	4618      	mov	r0, r3
 8006d9e:	f009 fed5 	bl	8010b4c <_nx_udp_socket_unbind>

            /* Release the DHCP mutex.  */
            tx_mutex_put(&(dhcp_ptr -> nx_dhcp_mutex));
 8006da2:	687a      	ldr	r2, [r7, #4]
 8006da4:	f641 5308 	movw	r3, #7432	; 0x1d08
 8006da8:	4413      	add	r3, r2
 8006daa:	4618      	mov	r0, r3
 8006dac:	f00f fa8c 	bl	80162c8 <_txe_mutex_put>
            return(status);
 8006db0:	693b      	ldr	r3, [r7, #16]
 8006db2:	e033      	b.n	8006e1c <_nx_dhcp_interface_start+0x1b0>
        }
    }

    /* Start DHCP service for this interface record.  */
    /* Start the DHCP protocol again by setting the state back to INIT. */
    interface_record -> nx_dhcp_state = NX_DHCP_STATE_INIT;
 8006db4:	68fb      	ldr	r3, [r7, #12]
 8006db6:	2202      	movs	r2, #2
 8006db8:	705a      	strb	r2, [r3, #1]
    /* The client begins in INIT state and forms a DHCPDISCOVER message.
       The client should wait a random time between one and ten seconds to desynchronize the use of DHCP at startup.  
       RFC2131, Section4.4.1, Page36.  */

    /* Use the minimum value, Wait one second to begain in INIT state and forms a DHCP Discovery message.  */
    interface_record -> nx_dhcp_timeout = NX_IP_PERIODIC_RATE;
 8006dba:	68fb      	ldr	r3, [r7, #12]
 8006dbc:	2264      	movs	r2, #100	; 0x64
 8006dbe:	621a      	str	r2, [r3, #32]
    interface_record -> nx_dhcp_rtr_interval = 0;
 8006dc0:	68fb      	ldr	r3, [r7, #12]
 8006dc2:	2200      	movs	r2, #0
 8006dc4:	625a      	str	r2, [r3, #36]	; 0x24

    /* Determine if the application has specified a routine for DHCP state change notification.  */
    if (dhcp_ptr -> nx_dhcp_state_change_callback)
 8006dc6:	687b      	ldr	r3, [r7, #4]
 8006dc8:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
 8006dcc:	f8d3 3f3c 	ldr.w	r3, [r3, #3900]	; 0xf3c
 8006dd0:	2b00      	cmp	r3, #0
 8006dd2:	d009      	beq.n	8006de8 <_nx_dhcp_interface_start+0x17c>
    {

        /* Yes, call the application's state change notify function with the new state.  */
        (dhcp_ptr -> nx_dhcp_state_change_callback)(dhcp_ptr, interface_record -> nx_dhcp_state);
 8006dd4:	687b      	ldr	r3, [r7, #4]
 8006dd6:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
 8006dda:	f8d3 3f3c 	ldr.w	r3, [r3, #3900]	; 0xf3c
 8006dde:	68fa      	ldr	r2, [r7, #12]
 8006de0:	7852      	ldrb	r2, [r2, #1]
 8006de2:	4611      	mov	r1, r2
 8006de4:	6878      	ldr	r0, [r7, #4]
 8006de6:	4798      	blx	r3
    }

    /* Determine if the application has specified a routine for DHCP interface state change notification.  */
    if (dhcp_ptr -> nx_dhcp_interface_state_change_callback)
 8006de8:	687b      	ldr	r3, [r7, #4]
 8006dea:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
 8006dee:	f8d3 3f40 	ldr.w	r3, [r3, #3904]	; 0xf40
 8006df2:	2b00      	cmp	r3, #0
 8006df4:	d00a      	beq.n	8006e0c <_nx_dhcp_interface_start+0x1a0>
    {

        /* Yes, call the application's state change notify function with the new state.  */
        (dhcp_ptr -> nx_dhcp_interface_state_change_callback)(dhcp_ptr, interface_record -> nx_dhcp_interface_index, interface_record -> nx_dhcp_state);
 8006df6:	687b      	ldr	r3, [r7, #4]
 8006df8:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
 8006dfc:	f8d3 3f40 	ldr.w	r3, [r3, #3904]	; 0xf40
 8006e00:	68fa      	ldr	r2, [r7, #12]
 8006e02:	69d1      	ldr	r1, [r2, #28]
 8006e04:	68fa      	ldr	r2, [r7, #12]
 8006e06:	7852      	ldrb	r2, [r2, #1]
 8006e08:	6878      	ldr	r0, [r7, #4]
 8006e0a:	4798      	blx	r3
    }

    /* Release the DHCP mutex.  */
    tx_mutex_put(&(dhcp_ptr -> nx_dhcp_mutex));
 8006e0c:	687a      	ldr	r2, [r7, #4]
 8006e0e:	f641 5308 	movw	r3, #7432	; 0x1d08
 8006e12:	4413      	add	r3, r2
 8006e14:	4618      	mov	r0, r3
 8006e16:	f00f fa57 	bl	80162c8 <_txe_mutex_put>

    return NX_SUCCESS;
 8006e1a:	2300      	movs	r3, #0
}
 8006e1c:	4618      	mov	r0, r3
 8006e1e:	3718      	adds	r7, #24
 8006e20:	46bd      	mov	sp, r7
 8006e22:	bd80      	pop	{r7, pc}

08006e24 <_nx_dhcp_interface_enable>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
UINT  _nx_dhcp_interface_enable(NX_DHCP *dhcp_ptr, UINT iface_index)   
{
 8006e24:	b590      	push	{r4, r7, lr}
 8006e26:	b087      	sub	sp, #28
 8006e28:	af00      	add	r7, sp, #0
 8006e2a:	6078      	str	r0, [r7, #4]
 8006e2c:	6039      	str	r1, [r7, #0]
UINT                      i;
ULONG                     client_physical_lsw, client_physical_msw;
NX_DHCP_INTERFACE_RECORD *interface_record = NX_NULL;
 8006e2e:	2300      	movs	r3, #0
 8006e30:	613b      	str	r3, [r7, #16]


    /* Get the DHCP mutex.  */
    tx_mutex_get(&(dhcp_ptr -> nx_dhcp_mutex), NX_WAIT_FOREVER);
 8006e32:	687a      	ldr	r2, [r7, #4]
 8006e34:	f641 5308 	movw	r3, #7432	; 0x1d08
 8006e38:	4413      	add	r3, r2
 8006e3a:	f04f 31ff 	mov.w	r1, #4294967295
 8006e3e:	4618      	mov	r0, r3
 8006e40:	f00f f9e8 	bl	8016214 <_txe_mutex_get>

    for (i = 0; i < NX_DHCP_CLIENT_MAX_RECORDS; i++) 
 8006e44:	2300      	movs	r3, #0
 8006e46:	617b      	str	r3, [r7, #20]
 8006e48:	e035      	b.n	8006eb6 <_nx_dhcp_interface_enable+0x92>
    {

        /* Check if this record is valid.  */
        if (dhcp_ptr -> nx_dhcp_interface_record[i].nx_dhcp_record_valid == NX_TRUE)
 8006e4a:	687a      	ldr	r2, [r7, #4]
 8006e4c:	697b      	ldr	r3, [r7, #20]
 8006e4e:	f44f 71d8 	mov.w	r1, #432	; 0x1b0
 8006e52:	fb01 f303 	mul.w	r3, r1, r3
 8006e56:	441a      	add	r2, r3
 8006e58:	f641 538c 	movw	r3, #7564	; 0x1d8c
 8006e5c:	4413      	add	r3, r2
 8006e5e:	781b      	ldrb	r3, [r3, #0]
 8006e60:	2b01      	cmp	r3, #1
 8006e62:	d116      	bne.n	8006e92 <_nx_dhcp_interface_enable+0x6e>
        {

            /* Check if the interface is already enabled. */
            if (dhcp_ptr -> nx_dhcp_interface_record[i].nx_dhcp_interface_index == iface_index)
 8006e64:	687a      	ldr	r2, [r7, #4]
 8006e66:	697b      	ldr	r3, [r7, #20]
 8006e68:	f44f 71d8 	mov.w	r1, #432	; 0x1b0
 8006e6c:	fb01 f303 	mul.w	r3, r1, r3
 8006e70:	441a      	add	r2, r3
 8006e72:	f641 53a8 	movw	r3, #7592	; 0x1da8
 8006e76:	4413      	add	r3, r2
 8006e78:	681b      	ldr	r3, [r3, #0]
 8006e7a:	683a      	ldr	r2, [r7, #0]
 8006e7c:	429a      	cmp	r2, r3
 8006e7e:	d117      	bne.n	8006eb0 <_nx_dhcp_interface_enable+0x8c>
            {

                /* Release the DHCP mutex.  */
                 tx_mutex_put(&(dhcp_ptr -> nx_dhcp_mutex));
 8006e80:	687a      	ldr	r2, [r7, #4]
 8006e82:	f641 5308 	movw	r3, #7432	; 0x1d08
 8006e86:	4413      	add	r3, r2
 8006e88:	4618      	mov	r0, r3
 8006e8a:	f00f fa1d 	bl	80162c8 <_txe_mutex_put>
                 return(NX_DHCP_INTERFACE_ALREADY_ENABLED);
 8006e8e:	23a3      	movs	r3, #163	; 0xa3
 8006e90:	e062      	b.n	8006f58 <_nx_dhcp_interface_enable+0x134>
        }
        else
        {

            /* Yes, we found an available record.  */
            if (interface_record == NX_NULL)
 8006e92:	693b      	ldr	r3, [r7, #16]
 8006e94:	2b00      	cmp	r3, #0
 8006e96:	d10b      	bne.n	8006eb0 <_nx_dhcp_interface_enable+0x8c>
                interface_record = &dhcp_ptr -> nx_dhcp_interface_record[i];
 8006e98:	697b      	ldr	r3, [r7, #20]
 8006e9a:	f44f 72d8 	mov.w	r2, #432	; 0x1b0
 8006e9e:	fb03 f202 	mul.w	r2, r3, r2
 8006ea2:	f641 5388 	movw	r3, #7560	; 0x1d88
 8006ea6:	4413      	add	r3, r2
 8006ea8:	687a      	ldr	r2, [r7, #4]
 8006eaa:	4413      	add	r3, r2
 8006eac:	3304      	adds	r3, #4
 8006eae:	613b      	str	r3, [r7, #16]
    for (i = 0; i < NX_DHCP_CLIENT_MAX_RECORDS; i++) 
 8006eb0:	697b      	ldr	r3, [r7, #20]
 8006eb2:	3301      	adds	r3, #1
 8006eb4:	617b      	str	r3, [r7, #20]
 8006eb6:	697b      	ldr	r3, [r7, #20]
 8006eb8:	2b00      	cmp	r3, #0
 8006eba:	d0c6      	beq.n	8006e4a <_nx_dhcp_interface_enable+0x26>
        }
    }

    /* Check if we found an valid DHCP interface record.  */
    if (interface_record == NX_NULL)
 8006ebc:	693b      	ldr	r3, [r7, #16]
 8006ebe:	2b00      	cmp	r3, #0
 8006ec0:	d108      	bne.n	8006ed4 <_nx_dhcp_interface_enable+0xb0>
    {

        /* No, release the mutex.  */
        tx_mutex_put(&(dhcp_ptr -> nx_dhcp_mutex));
 8006ec2:	687a      	ldr	r2, [r7, #4]
 8006ec4:	f641 5308 	movw	r3, #7432	; 0x1d08
 8006ec8:	4413      	add	r3, r2
 8006eca:	4618      	mov	r0, r3
 8006ecc:	f00f f9fc 	bl	80162c8 <_txe_mutex_put>
        return(NX_DHCP_NO_RECORDS_AVAILABLE);
 8006ed0:	23a7      	movs	r3, #167	; 0xa7
 8006ed2:	e041      	b.n	8006f58 <_nx_dhcp_interface_enable+0x134>
    }

    /* Set this record as valid.  */
    interface_record -> nx_dhcp_record_valid = NX_TRUE;
 8006ed4:	693b      	ldr	r3, [r7, #16]
 8006ed6:	2201      	movs	r2, #1
 8006ed8:	701a      	strb	r2, [r3, #0]

    /* Set interface index. */  
    interface_record -> nx_dhcp_interface_index = iface_index;
 8006eda:	693b      	ldr	r3, [r7, #16]
 8006edc:	683a      	ldr	r2, [r7, #0]
 8006ede:	61da      	str	r2, [r3, #28]

    /* Initialize the client DHCP IP address with the NULL IP address.  */
    interface_record -> nx_dhcp_ip_address =  NX_BOOTP_NO_ADDRESS;
 8006ee0:	693b      	ldr	r3, [r7, #16]
 8006ee2:	2200      	movs	r2, #0
 8006ee4:	60da      	str	r2, [r3, #12]

    /* Initialize the client DHCP server IP address.  */
    interface_record -> nx_dhcp_server_ip =  NX_BOOTP_NO_ADDRESS;
 8006ee6:	693b      	ldr	r3, [r7, #16]
 8006ee8:	2200      	movs	r2, #0
 8006eea:	615a      	str	r2, [r3, #20]

    /* Initialize renew and rebind timeout values to zero.  */
    interface_record -> nx_dhcp_rebind_time = 0;
 8006eec:	693b      	ldr	r3, [r7, #16]
 8006eee:	2200      	movs	r2, #0
 8006ef0:	635a      	str	r2, [r3, #52]	; 0x34
    interface_record -> nx_dhcp_renewal_time =  0;
 8006ef2:	693b      	ldr	r3, [r7, #16]
 8006ef4:	2200      	movs	r2, #0
 8006ef6:	631a      	str	r2, [r3, #48]	; 0x30

    /* Setup for infinite lease time request.  */
    interface_record -> nx_dhcp_lease_time =  NX_DHCP_INFINITE_LEASE;
 8006ef8:	693b      	ldr	r3, [r7, #16]
 8006efa:	f04f 32ff 	mov.w	r2, #4294967295
 8006efe:	62da      	str	r2, [r3, #44]	; 0x2c

    /* Get the client MAC address from the device interface. */
    client_physical_msw = dhcp_ptr ->  nx_dhcp_ip_ptr -> nx_ip_interface[iface_index].nx_interface_physical_address_msw;
 8006f00:	687b      	ldr	r3, [r7, #4]
 8006f02:	689a      	ldr	r2, [r3, #8]
 8006f04:	683b      	ldr	r3, [r7, #0]
 8006f06:	214c      	movs	r1, #76	; 0x4c
 8006f08:	fb01 f303 	mul.w	r3, r1, r3
 8006f0c:	4413      	add	r3, r2
 8006f0e:	f203 732c 	addw	r3, r3, #1836	; 0x72c
 8006f12:	681b      	ldr	r3, [r3, #0]
 8006f14:	60fb      	str	r3, [r7, #12]
    client_physical_lsw = dhcp_ptr ->  nx_dhcp_ip_ptr -> nx_ip_interface[iface_index].nx_interface_physical_address_lsw;
 8006f16:	687b      	ldr	r3, [r7, #4]
 8006f18:	689a      	ldr	r2, [r3, #8]
 8006f1a:	683b      	ldr	r3, [r7, #0]
 8006f1c:	214c      	movs	r1, #76	; 0x4c
 8006f1e:	fb01 f303 	mul.w	r3, r1, r3
 8006f22:	4413      	add	r3, r2
 8006f24:	f503 63e6 	add.w	r3, r3, #1840	; 0x730
 8006f28:	681b      	ldr	r3, [r3, #0]
 8006f2a:	60bb      	str	r3, [r7, #8]

    /* Generate a 'unique' client transaction ID from the MAC address for each message to the server. */
    interface_record -> nx_dhcp_xid =  (ULONG)(client_physical_msw ^ client_physical_lsw ^ (ULONG)NX_RAND());
 8006f2c:	68fa      	ldr	r2, [r7, #12]
 8006f2e:	68bb      	ldr	r3, [r7, #8]
 8006f30:	ea82 0403 	eor.w	r4, r2, r3
 8006f34:	f019 f9be 	bl	80202b4 <rand>
 8006f38:	4603      	mov	r3, r0
 8006f3a:	ea84 0203 	eor.w	r2, r4, r3
 8006f3e:	693b      	ldr	r3, [r7, #16]
 8006f40:	605a      	str	r2, [r3, #4]

    /* Clear the timeout.  */
    interface_record -> nx_dhcp_timeout = 0;
 8006f42:	693b      	ldr	r3, [r7, #16]
 8006f44:	2200      	movs	r2, #0
 8006f46:	621a      	str	r2, [r3, #32]

    /* Release the DHCP mutex.  */
    tx_mutex_put(&(dhcp_ptr -> nx_dhcp_mutex)); 
 8006f48:	687a      	ldr	r2, [r7, #4]
 8006f4a:	f641 5308 	movw	r3, #7432	; 0x1d08
 8006f4e:	4413      	add	r3, r2
 8006f50:	4618      	mov	r0, r3
 8006f52:	f00f f9b9 	bl	80162c8 <_txe_mutex_put>
    return(NX_SUCCESS); 
 8006f56:	2300      	movs	r3, #0
}
 8006f58:	4618      	mov	r0, r3
 8006f5a:	371c      	adds	r7, #28
 8006f5c:	46bd      	mov	sp, r7
 8006f5e:	bd90      	pop	{r4, r7, pc}

08006f60 <_nx_dhcp_udp_receive_notify>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
VOID _nx_dhcp_udp_receive_notify(NX_UDP_SOCKET *socket_ptr)
{
 8006f60:	b580      	push	{r7, lr}
 8006f62:	b082      	sub	sp, #8
 8006f64:	af00      	add	r7, sp, #0
 8006f66:	6078      	str	r0, [r7, #4]

    NX_PARAMETER_NOT_USED(socket_ptr);

    /* Set the data received event flag.  */
    tx_event_flags_set(&(_nx_dhcp_created_ptr -> nx_dhcp_events), NX_DHCP_CLIENT_RECEIVE_EVENT, TX_OR);
 8006f68:	4b06      	ldr	r3, [pc, #24]	; (8006f84 <_nx_dhcp_udp_receive_notify+0x24>)
 8006f6a:	681a      	ldr	r2, [r3, #0]
 8006f6c:	f641 533c 	movw	r3, #7484	; 0x1d3c
 8006f70:	4413      	add	r3, r2
 8006f72:	2200      	movs	r2, #0
 8006f74:	2101      	movs	r1, #1
 8006f76:	4618      	mov	r0, r3
 8006f78:	f00f f842 	bl	8016000 <_txe_event_flags_set>
}
 8006f7c:	bf00      	nop
 8006f7e:	3708      	adds	r7, #8
 8006f80:	46bd      	mov	sp, r7
 8006f82:	bd80      	pop	{r7, pc}
 8006f84:	24000b04 	.word	0x24000b04

08006f88 <_nx_dhcp_timeout_entry>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
VOID _nx_dhcp_timeout_entry(ULONG dhcp)
{
 8006f88:	b580      	push	{r7, lr}
 8006f8a:	b084      	sub	sp, #16
 8006f8c:	af00      	add	r7, sp, #0
 8006f8e:	6078      	str	r0, [r7, #4]

NX_DHCP     *dhcp_ptr;


    /* Setup DHCP pointer.  */
    NX_TIMER_EXTENSION_PTR_GET(dhcp_ptr, NX_DHCP, dhcp)
 8006f90:	687b      	ldr	r3, [r7, #4]
 8006f92:	60fb      	str	r3, [r7, #12]

    /* Set the data event flag.  */
    tx_event_flags_set(&(dhcp_ptr -> nx_dhcp_events), NX_DHCP_CLIENT_TIMER_EVENT, TX_OR);
 8006f94:	68fa      	ldr	r2, [r7, #12]
 8006f96:	f641 533c 	movw	r3, #7484	; 0x1d3c
 8006f9a:	4413      	add	r3, r2
 8006f9c:	2200      	movs	r2, #0
 8006f9e:	2102      	movs	r1, #2
 8006fa0:	4618      	mov	r0, r3
 8006fa2:	f00f f82d 	bl	8016000 <_txe_event_flags_set>
}
 8006fa6:	bf00      	nop
 8006fa8:	3710      	adds	r7, #16
 8006faa:	46bd      	mov	sp, r7
 8006fac:	bd80      	pop	{r7, pc}

08006fae <_nx_dhcp_thread_entry>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
static VOID  _nx_dhcp_thread_entry(ULONG dhcp_instance)
{
 8006fae:	b590      	push	{r4, r7, lr}
 8006fb0:	b08f      	sub	sp, #60	; 0x3c
 8006fb2:	af02      	add	r7, sp, #8
 8006fb4:	6078      	str	r0, [r7, #4]
UINT                      status;
UINT                      iface_index;
UINT                      source_port;
ULONG                     source_ip_address;
UINT                      protocol;
NX_DHCP_INTERFACE_RECORD *interface_record = NX_NULL;
 8006fb6:	2300      	movs	r3, #0
 8006fb8:	60fb      	str	r3, [r7, #12]

    /* Setup the DHCP pointer.  */
    NX_THREAD_EXTENSION_PTR_GET(dhcp_ptr, NX_DHCP, dhcp_instance)
 8006fba:	687b      	ldr	r3, [r7, #4]
 8006fbc:	62fb      	str	r3, [r7, #44]	; 0x2c

    /* Obtain the DHCP mutex before processing an.  */
    tx_mutex_get(&(dhcp_ptr -> nx_dhcp_mutex), TX_WAIT_FOREVER);
 8006fbe:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 8006fc0:	f641 5308 	movw	r3, #7432	; 0x1d08
 8006fc4:	4413      	add	r3, r2
 8006fc6:	f04f 31ff 	mov.w	r1, #4294967295
 8006fca:	4618      	mov	r0, r3
 8006fcc:	f00f f922 	bl	8016214 <_txe_mutex_get>
    /* Enter the DHCP Client task loop.  */
    do
    {

        /* Release the DHCP mutex.  */
        tx_mutex_put(&(dhcp_ptr -> nx_dhcp_mutex));
 8006fd0:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 8006fd2:	f641 5308 	movw	r3, #7432	; 0x1d08
 8006fd6:	4413      	add	r3, r2
 8006fd8:	4618      	mov	r0, r3
 8006fda:	f00f f975 	bl	80162c8 <_txe_mutex_put>

        /* Wait for a DHCP client activity.  */
        tx_event_flags_get(&(dhcp_ptr -> nx_dhcp_events), NX_DHCP_CLIENT_ALL_EVENTS, 
 8006fde:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8006fe0:	f641 503c 	movw	r0, #7484	; 0x1d3c
 8006fe4:	4418      	add	r0, r3
 8006fe6:	f107 0320 	add.w	r3, r7, #32
 8006fea:	f04f 32ff 	mov.w	r2, #4294967295
 8006fee:	9200      	str	r2, [sp, #0]
 8006ff0:	2201      	movs	r2, #1
 8006ff2:	f04f 31ff 	mov.w	r1, #4294967295
 8006ff6:	f00e ffad 	bl	8015f54 <_txe_event_flags_get>
                           TX_OR_CLEAR, &events, TX_WAIT_FOREVER);

        /* Obtain the DHCP mutex before processing an.  */
        tx_mutex_get(&(dhcp_ptr -> nx_dhcp_mutex), TX_WAIT_FOREVER);
 8006ffa:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 8006ffc:	f641 5308 	movw	r3, #7432	; 0x1d08
 8007000:	4413      	add	r3, r2
 8007002:	f04f 31ff 	mov.w	r1, #4294967295
 8007006:	4618      	mov	r0, r3
 8007008:	f00f f904 	bl	8016214 <_txe_mutex_get>

        /* Check for DHCP data received event.  */
        if  (events & NX_DHCP_CLIENT_RECEIVE_EVENT)
 800700c:	6a3b      	ldr	r3, [r7, #32]
 800700e:	f003 0301 	and.w	r3, r3, #1
 8007012:	2b00      	cmp	r3, #0
 8007014:	d03a      	beq.n	800708c <_nx_dhcp_thread_entry+0xde>
            /* Loop to receive DHCP message.  */
            while(1)
            {

                /* Check for an incoming DHCP packet with non blocking option. */
                status = _nx_udp_socket_receive(&dhcp_ptr -> nx_dhcp_socket, &packet_ptr, NX_NO_WAIT);
 8007016:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8007018:	f603 33dc 	addw	r3, r3, #3036	; 0xbdc
 800701c:	f107 0124 	add.w	r1, r7, #36	; 0x24
 8007020:	2200      	movs	r2, #0
 8007022:	4618      	mov	r0, r3
 8007024:	f009 fbea 	bl	80107fc <_nx_udp_socket_receive>
 8007028:	62b8      	str	r0, [r7, #40]	; 0x28

                /* Check for packet receive errors. */
                if (status != NX_SUCCESS)
 800702a:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800702c:	2b00      	cmp	r3, #0
 800702e:	d12c      	bne.n	800708a <_nx_dhcp_thread_entry+0xdc>
                {
                    break;
                }

                /* Find the source IP address, port, interface this packet is on. */
                status = nx_udp_packet_info_extract(packet_ptr, &source_ip_address, &protocol, &source_port, &iface_index);
 8007030:	6a78      	ldr	r0, [r7, #36]	; 0x24
 8007032:	f107 0418 	add.w	r4, r7, #24
 8007036:	f107 0210 	add.w	r2, r7, #16
 800703a:	f107 0114 	add.w	r1, r7, #20
 800703e:	f107 031c 	add.w	r3, r7, #28
 8007042:	9300      	str	r3, [sp, #0]
 8007044:	4623      	mov	r3, r4
 8007046:	f008 ff49 	bl	800fedc <_nx_udp_packet_info_extract>
 800704a:	62b8      	str	r0, [r7, #40]	; 0x28

                /* Check status.  */
                if (status != NX_SUCCESS) 
 800704c:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800704e:	2b00      	cmp	r3, #0
 8007050:	d004      	beq.n	800705c <_nx_dhcp_thread_entry+0xae>
                {

                    nx_packet_release(packet_ptr); 
 8007052:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8007054:	4618      	mov	r0, r3
 8007056:	f005 f9d7 	bl	800c408 <_nx_packet_release>
                    continue;
 800705a:	e015      	b.n	8007088 <_nx_dhcp_thread_entry+0xda>
                }

                /* Find the interface record.  */
                status = _nx_dhcp_interface_record_find(dhcp_ptr, iface_index, &interface_record);
 800705c:	69fb      	ldr	r3, [r7, #28]
 800705e:	f107 020c 	add.w	r2, r7, #12
 8007062:	4619      	mov	r1, r3
 8007064:	6af8      	ldr	r0, [r7, #44]	; 0x2c
 8007066:	f001 fb48 	bl	80086fa <_nx_dhcp_interface_record_find>
 800706a:	62b8      	str	r0, [r7, #40]	; 0x28

                /* Check status.  */
                if (status != NX_SUCCESS)
 800706c:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800706e:	2b00      	cmp	r3, #0
 8007070:	d004      	beq.n	800707c <_nx_dhcp_thread_entry+0xce>
                {

                    /* Release the original packet . */
                    nx_packet_release(packet_ptr);
 8007072:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8007074:	4618      	mov	r0, r3
 8007076:	f005 f9c7 	bl	800c408 <_nx_packet_release>
                    continue;
 800707a:	e005      	b.n	8007088 <_nx_dhcp_thread_entry+0xda>
                }
                
                /* Process DHCP packet.  */
                _nx_dhcp_packet_process(dhcp_ptr, interface_record, packet_ptr);
 800707c:	68fb      	ldr	r3, [r7, #12]
 800707e:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8007080:	4619      	mov	r1, r3
 8007082:	6af8      	ldr	r0, [r7, #44]	; 0x2c
 8007084:	f000 f80c 	bl	80070a0 <_nx_dhcp_packet_process>
                status = _nx_udp_socket_receive(&dhcp_ptr -> nx_dhcp_socket, &packet_ptr, NX_NO_WAIT);
 8007088:	e7c5      	b.n	8007016 <_nx_dhcp_thread_entry+0x68>
                    break;
 800708a:	bf00      	nop
            }
        }

        /* Timer event.  */
        if (events & NX_DHCP_CLIENT_TIMER_EVENT)
 800708c:	6a3b      	ldr	r3, [r7, #32]
 800708e:	f003 0302 	and.w	r3, r3, #2
 8007092:	2b00      	cmp	r3, #0
 8007094:	d09c      	beq.n	8006fd0 <_nx_dhcp_thread_entry+0x22>
        {
            _nx_dhcp_timeout_process(dhcp_ptr);
 8007096:	6af8      	ldr	r0, [r7, #44]	; 0x2c
 8007098:	f000 fa64 	bl	8007564 <_nx_dhcp_timeout_process>
        tx_mutex_put(&(dhcp_ptr -> nx_dhcp_mutex));
 800709c:	e798      	b.n	8006fd0 <_nx_dhcp_thread_entry+0x22>
	...

080070a0 <_nx_dhcp_packet_process>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
VOID  _nx_dhcp_packet_process(NX_DHCP *dhcp_ptr, NX_DHCP_INTERFACE_RECORD *interface_record, NX_PACKET *packet_ptr)
{
 80070a0:	b580      	push	{r7, lr}
 80070a2:	b094      	sub	sp, #80	; 0x50
 80070a4:	af02      	add	r7, sp, #8
 80070a6:	60f8      	str	r0, [r7, #12]
 80070a8:	60b9      	str	r1, [r7, #8]
 80070aa:	607a      	str	r2, [r7, #4]
#ifdef NX_DHCP_CLIENT_SEND_ARP_PROBE
ULONG       probing_delay;
#endif

    /* Set the IP pointer and interface index.  */
    ip_ptr = dhcp_ptr -> nx_dhcp_ip_ptr;
 80070ac:	68fb      	ldr	r3, [r7, #12]
 80070ae:	689b      	ldr	r3, [r3, #8]
 80070b0:	647b      	str	r3, [r7, #68]	; 0x44
    iface_index = interface_record -> nx_dhcp_interface_index;
 80070b2:	68bb      	ldr	r3, [r7, #8]
 80070b4:	69db      	ldr	r3, [r3, #28]
 80070b6:	643b      	str	r3, [r7, #64]	; 0x40

    /* Check for valid packet length.  */
    if (packet_ptr -> nx_packet_length <= NX_BOOTP_OFFSET_OPTIONS)
 80070b8:	687b      	ldr	r3, [r7, #4]
 80070ba:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 80070bc:	2bf0      	cmp	r3, #240	; 0xf0
 80070be:	d803      	bhi.n	80070c8 <_nx_dhcp_packet_process+0x28>
    {

        /* Release the packet. */
        nx_packet_release(packet_ptr);
 80070c0:	6878      	ldr	r0, [r7, #4]
 80070c2:	f005 f9a1 	bl	800c408 <_nx_packet_release>

        /* Return.  */
        return;
 80070c6:	e24a      	b.n	800755e <_nx_dhcp_packet_process+0x4be>
    }

    /* Copy the received packet (datagram) over to a packet from the DHCP Client pool and release
       the packet back to receive packet pool as soon as possible. */
    status =  nx_packet_allocate(dhcp_ptr -> nx_dhcp_packet_pool_ptr, &new_packet_ptr, NX_IPv4_UDP_PACKET, NX_NO_WAIT);
 80070c8:	68fb      	ldr	r3, [r7, #12]
 80070ca:	f8d3 0bd8 	ldr.w	r0, [r3, #3032]	; 0xbd8
 80070ce:	f107 0118 	add.w	r1, r7, #24
 80070d2:	2300      	movs	r3, #0
 80070d4:	222c      	movs	r2, #44	; 0x2c
 80070d6:	f004 fd33 	bl	800bb40 <_nx_packet_allocate>
 80070da:	63f8      	str	r0, [r7, #60]	; 0x3c

    /* Check status.  */
    if (status != NX_SUCCESS)
 80070dc:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 80070de:	2b00      	cmp	r3, #0
 80070e0:	d003      	beq.n	80070ea <_nx_dhcp_packet_process+0x4a>
    {

        /* Release the original packet. */
        nx_packet_release(packet_ptr);
 80070e2:	6878      	ldr	r0, [r7, #4]
 80070e4:	f005 f990 	bl	800c408 <_nx_packet_release>

        /* Error allocating packet, return error status.  */
        return;
 80070e8:	e239      	b.n	800755e <_nx_dhcp_packet_process+0x4be>
    }

    /* Verify the incoming packet does not exceed our DHCP Client packet payload. */
    if ((ULONG)(new_packet_ptr -> nx_packet_data_end - new_packet_ptr -> nx_packet_prepend_ptr) < ((packet_ptr) -> nx_packet_length))
 80070ea:	69bb      	ldr	r3, [r7, #24]
 80070ec:	695a      	ldr	r2, [r3, #20]
 80070ee:	69bb      	ldr	r3, [r7, #24]
 80070f0:	689b      	ldr	r3, [r3, #8]
 80070f2:	1ad3      	subs	r3, r2, r3
 80070f4:	461a      	mov	r2, r3
 80070f6:	687b      	ldr	r3, [r7, #4]
 80070f8:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 80070fa:	429a      	cmp	r2, r3
 80070fc:	d207      	bcs.n	800710e <_nx_dhcp_packet_process+0x6e>
    {

        /* Release the newly allocated packet . */
        nx_packet_release(new_packet_ptr);
 80070fe:	69bb      	ldr	r3, [r7, #24]
 8007100:	4618      	mov	r0, r3
 8007102:	f005 f981 	bl	800c408 <_nx_packet_release>
        
        /* Release the original packet. */
        nx_packet_release(packet_ptr);
 8007106:	6878      	ldr	r0, [r7, #4]
 8007108:	f005 f97e 	bl	800c408 <_nx_packet_release>

        return;
 800710c:	e227      	b.n	800755e <_nx_dhcp_packet_process+0x4be>
    }

    /* Initialize the offset to the beginning of the packet buffer. */
    offset = 0;
 800710e:	2300      	movs	r3, #0
 8007110:	63bb      	str	r3, [r7, #56]	; 0x38
    status = nx_packet_data_extract_offset(packet_ptr, offset, (VOID *)new_packet_ptr -> nx_packet_prepend_ptr, (packet_ptr) -> nx_packet_length, &bytes_copied);
 8007112:	69bb      	ldr	r3, [r7, #24]
 8007114:	689a      	ldr	r2, [r3, #8]
 8007116:	687b      	ldr	r3, [r7, #4]
 8007118:	6a59      	ldr	r1, [r3, #36]	; 0x24
 800711a:	f107 0310 	add.w	r3, r7, #16
 800711e:	9300      	str	r3, [sp, #0]
 8007120:	460b      	mov	r3, r1
 8007122:	6bb9      	ldr	r1, [r7, #56]	; 0x38
 8007124:	6878      	ldr	r0, [r7, #4]
 8007126:	f004 ff20 	bl	800bf6a <_nx_packet_data_extract_offset>
 800712a:	63f8      	str	r0, [r7, #60]	; 0x3c

    /* Check status.  */
    if ((status != NX_SUCCESS) || (bytes_copied == 0))
 800712c:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800712e:	2b00      	cmp	r3, #0
 8007130:	d102      	bne.n	8007138 <_nx_dhcp_packet_process+0x98>
 8007132:	693b      	ldr	r3, [r7, #16]
 8007134:	2b00      	cmp	r3, #0
 8007136:	d107      	bne.n	8007148 <_nx_dhcp_packet_process+0xa8>
    {

        /* Release the allocated packet we'll never send. */
        nx_packet_release(new_packet_ptr);
 8007138:	69bb      	ldr	r3, [r7, #24]
 800713a:	4618      	mov	r0, r3
 800713c:	f005 f964 	bl	800c408 <_nx_packet_release>

        /* Release the original packet. */
        nx_packet_release(packet_ptr);
 8007140:	6878      	ldr	r0, [r7, #4]
 8007142:	f005 f961 	bl	800c408 <_nx_packet_release>

        /* Error extracting packet buffer, return error status.  */
        return;
 8007146:	e20a      	b.n	800755e <_nx_dhcp_packet_process+0x4be>
    }

    /* Update the new packet with the bytes copied.  For chained packets, this will reflect the total
       'datagram' length. */
    new_packet_ptr -> nx_packet_length = bytes_copied; 
 8007148:	69bb      	ldr	r3, [r7, #24]
 800714a:	693a      	ldr	r2, [r7, #16]
 800714c:	625a      	str	r2, [r3, #36]	; 0x24


    /* Now we can release the original packet. */
    nx_packet_release(packet_ptr);
 800714e:	6878      	ldr	r0, [r7, #4]
 8007150:	f005 f95a 	bl	800c408 <_nx_packet_release>

    /* Set the interface index and MAC address.  */
    dhcp_client_mac_msw = ip_ptr -> nx_ip_interface[iface_index].nx_interface_physical_address_msw;
 8007154:	6c7a      	ldr	r2, [r7, #68]	; 0x44
 8007156:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8007158:	214c      	movs	r1, #76	; 0x4c
 800715a:	fb01 f303 	mul.w	r3, r1, r3
 800715e:	4413      	add	r3, r2
 8007160:	f203 732c 	addw	r3, r3, #1836	; 0x72c
 8007164:	681b      	ldr	r3, [r3, #0]
 8007166:	637b      	str	r3, [r7, #52]	; 0x34
    dhcp_client_mac_lsw = ip_ptr -> nx_ip_interface[iface_index].nx_interface_physical_address_lsw;
 8007168:	6c7a      	ldr	r2, [r7, #68]	; 0x44
 800716a:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 800716c:	214c      	movs	r1, #76	; 0x4c
 800716e:	fb01 f303 	mul.w	r3, r1, r3
 8007172:	4413      	add	r3, r2
 8007174:	f503 63e6 	add.w	r3, r3, #1840	; 0x730
 8007178:	681b      	ldr	r3, [r3, #0]
 800717a:	633b      	str	r3, [r7, #48]	; 0x30

    /* Set work_ptr.  */
    work_ptr = new_packet_ptr -> nx_packet_prepend_ptr + NX_BOOTP_OFFSET_CLIENT_HW;
 800717c:	69bb      	ldr	r3, [r7, #24]
 800717e:	689b      	ldr	r3, [r3, #8]
 8007180:	331c      	adds	r3, #28
 8007182:	62fb      	str	r3, [r7, #44]	; 0x2c

    /* Pickup the target MAC address in the DHCP message.  */
    packet_client_mac_msw = (((ULONG)work_ptr[0]) << 8) | ((ULONG)work_ptr[1]);
 8007184:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8007186:	781b      	ldrb	r3, [r3, #0]
 8007188:	021b      	lsls	r3, r3, #8
 800718a:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 800718c:	3201      	adds	r2, #1
 800718e:	7812      	ldrb	r2, [r2, #0]
 8007190:	4313      	orrs	r3, r2
 8007192:	62bb      	str	r3, [r7, #40]	; 0x28
    packet_client_mac_lsw = (((ULONG)work_ptr[2]) << 24) |
 8007194:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8007196:	3302      	adds	r3, #2
 8007198:	781b      	ldrb	r3, [r3, #0]
 800719a:	061a      	lsls	r2, r3, #24
                            (((ULONG)work_ptr[3]) << 16) |
 800719c:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800719e:	3303      	adds	r3, #3
 80071a0:	781b      	ldrb	r3, [r3, #0]
 80071a2:	041b      	lsls	r3, r3, #16
    packet_client_mac_lsw = (((ULONG)work_ptr[2]) << 24) |
 80071a4:	431a      	orrs	r2, r3
                            (((ULONG)work_ptr[4]) << 8) |
 80071a6:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 80071a8:	3304      	adds	r3, #4
 80071aa:	781b      	ldrb	r3, [r3, #0]
 80071ac:	021b      	lsls	r3, r3, #8
                            (((ULONG)work_ptr[3]) << 16) |
 80071ae:	4313      	orrs	r3, r2
                            ((ULONG)work_ptr[5]);
 80071b0:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 80071b2:	3205      	adds	r2, #5
 80071b4:	7812      	ldrb	r2, [r2, #0]
    packet_client_mac_lsw = (((ULONG)work_ptr[2]) << 24) |
 80071b6:	4313      	orrs	r3, r2
 80071b8:	627b      	str	r3, [r7, #36]	; 0x24

    /* Determine if the  MAC address matches ours.  */
    if ((packet_client_mac_msw != dhcp_client_mac_msw) || (packet_client_mac_lsw != dhcp_client_mac_lsw))
 80071ba:	6aba      	ldr	r2, [r7, #40]	; 0x28
 80071bc:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 80071be:	429a      	cmp	r2, r3
 80071c0:	d103      	bne.n	80071ca <_nx_dhcp_packet_process+0x12a>
 80071c2:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 80071c4:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 80071c6:	429a      	cmp	r2, r3
 80071c8:	d004      	beq.n	80071d4 <_nx_dhcp_packet_process+0x134>
    {

        /* Release the allocated packet. */
        nx_packet_release(new_packet_ptr);
 80071ca:	69bb      	ldr	r3, [r7, #24]
 80071cc:	4618      	mov	r0, r3
 80071ce:	f005 f91b 	bl	800c408 <_nx_packet_release>
        return;
 80071d2:	e1c4      	b.n	800755e <_nx_dhcp_packet_process+0x4be>
    }

    /* Check if XIDs match.  */
    if (_nx_dhcp_get_data(new_packet_ptr -> nx_packet_prepend_ptr + NX_BOOTP_OFFSET_XID, 4) != interface_record -> nx_dhcp_xid)
 80071d4:	69bb      	ldr	r3, [r7, #24]
 80071d6:	689b      	ldr	r3, [r3, #8]
 80071d8:	3304      	adds	r3, #4
 80071da:	2104      	movs	r1, #4
 80071dc:	4618      	mov	r0, r3
 80071de:	f001 fa1d 	bl	800861c <_nx_dhcp_get_data>
 80071e2:	4602      	mov	r2, r0
 80071e4:	68bb      	ldr	r3, [r7, #8]
 80071e6:	685b      	ldr	r3, [r3, #4]
 80071e8:	429a      	cmp	r2, r3
 80071ea:	d004      	beq.n	80071f6 <_nx_dhcp_packet_process+0x156>
    {

        /* Release the original packet . */
        nx_packet_release(new_packet_ptr);
 80071ec:	69bb      	ldr	r3, [r7, #24]
 80071ee:	4618      	mov	r0, r3
 80071f0:	f005 f90a 	bl	800c408 <_nx_packet_release>

        /* Error with XID data, return error status.  */
        return;
 80071f4:	e1b3      	b.n	800755e <_nx_dhcp_packet_process+0x4be>
    }

    /* Save the original state for the state change callback; after this point we will likely change it. */                          
    original_state  = interface_record -> nx_dhcp_state;
 80071f6:	68bb      	ldr	r3, [r7, #8]
 80071f8:	785b      	ldrb	r3, [r3, #1]
 80071fa:	623b      	str	r3, [r7, #32]

    /* The action depends on the current state of the dhcp client. */
    switch (interface_record -> nx_dhcp_state)
 80071fc:	68bb      	ldr	r3, [r7, #8]
 80071fe:	785b      	ldrb	r3, [r3, #1]
 8007200:	3b03      	subs	r3, #3
 8007202:	2b04      	cmp	r3, #4
 8007204:	f200 816c 	bhi.w	80074e0 <_nx_dhcp_packet_process+0x440>
 8007208:	a201      	add	r2, pc, #4	; (adr r2, 8007210 <_nx_dhcp_packet_process+0x170>)
 800720a:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 800720e:	bf00      	nop
 8007210:	08007225 	.word	0x08007225
 8007214:	080072b1 	.word	0x080072b1
 8007218:	080074e1 	.word	0x080074e1
 800721c:	08007379 	.word	0x08007379
 8007220:	0800742f 	.word	0x0800742f

        case NX_DHCP_STATE_SELECTING:
        {
    
            /* Set up a buffer pointer.  */
            buffer =  new_packet_ptr -> nx_packet_prepend_ptr;
 8007224:	69bb      	ldr	r3, [r7, #24]
 8007226:	689b      	ldr	r3, [r3, #8]
 8007228:	61fb      	str	r3, [r7, #28]

            /* Get what type of DHCP message it is. */
            status = _nx_dhcp_get_option_value(buffer, NX_DHCP_OPTION_DHCP_TYPE, &dhcp_type, new_packet_ptr -> nx_packet_length);
 800722a:	69bb      	ldr	r3, [r7, #24]
 800722c:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800722e:	f107 0214 	add.w	r2, r7, #20
 8007232:	2135      	movs	r1, #53	; 0x35
 8007234:	69f8      	ldr	r0, [r7, #28]
 8007236:	f001 f89d 	bl	8008374 <_nx_dhcp_get_option_value>
 800723a:	63f8      	str	r0, [r7, #60]	; 0x3c

            /* Determine if it is an Offer.  */        
            if ((status == NX_SUCCESS) && (dhcp_type == NX_DHCP_TYPE_DHCPOFFER))
 800723c:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800723e:	2b00      	cmp	r3, #0
 8007240:	f040 8150 	bne.w	80074e4 <_nx_dhcp_packet_process+0x444>
 8007244:	697b      	ldr	r3, [r7, #20]
 8007246:	2b02      	cmp	r3, #2
 8007248:	f040 814c 	bne.w	80074e4 <_nx_dhcp_packet_process+0x444>
            {

                /* Yes, a valid Offer is received!  */

                /* Increment the number of offers received.  */
                interface_record -> nx_dhcp_offers_received++;
 800724c:	68bb      	ldr	r3, [r7, #8]
 800724e:	f8d3 318c 	ldr.w	r3, [r3, #396]	; 0x18c
 8007252:	1c5a      	adds	r2, r3, #1
 8007254:	68bb      	ldr	r3, [r7, #8]
 8007256:	f8c3 218c 	str.w	r2, [r3, #396]	; 0x18c

                /* Update the DHCP Client interface parameters (IP address, server IP, lease, renewal and rebind times */
                if (_nx_dhcp_extract_information(dhcp_ptr, interface_record, buffer, new_packet_ptr -> nx_packet_length))
 800725a:	69bb      	ldr	r3, [r7, #24]
 800725c:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800725e:	69fa      	ldr	r2, [r7, #28]
 8007260:	68b9      	ldr	r1, [r7, #8]
 8007262:	68f8      	ldr	r0, [r7, #12]
 8007264:	f000 ff66 	bl	8008134 <_nx_dhcp_extract_information>
 8007268:	4603      	mov	r3, r0
 800726a:	2b00      	cmp	r3, #0
 800726c:	f040 813c 	bne.w	80074e8 <_nx_dhcp_packet_process+0x448>
                    break;

                /* Send the DHCP Request to accept the offer.  */
                _nx_dhcp_send_request_internal(dhcp_ptr, interface_record, NX_DHCP_TYPE_DHCPREQUEST);
 8007270:	2203      	movs	r2, #3
 8007272:	68b9      	ldr	r1, [r7, #8]
 8007274:	68f8      	ldr	r0, [r7, #12]
 8007276:	f000 fb2b 	bl	80078d0 <_nx_dhcp_send_request_internal>

                /* Reset the initial timeout to NX_DHCP_MIN_RETRANS_TIMEOUT seconds  */
                interface_record -> nx_dhcp_rtr_interval = NX_DHCP_MIN_RETRANS_TIMEOUT;
 800727a:	68bb      	ldr	r3, [r7, #8]
 800727c:	f44f 72c8 	mov.w	r2, #400	; 0x190
 8007280:	625a      	str	r2, [r3, #36]	; 0x24
                interface_record -> nx_dhcp_timeout = interface_record -> nx_dhcp_rtr_interval;
 8007282:	68bb      	ldr	r3, [r7, #8]
 8007284:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 8007286:	68bb      	ldr	r3, [r7, #8]
 8007288:	621a      	str	r2, [r3, #32]

                /* This will modify the timeout by up to +/- 1 second as recommended by RFC 2131, Section 4.1, Page 24. */
                interface_record -> nx_dhcp_timeout = _nx_dhcp_add_randomize(interface_record -> nx_dhcp_timeout);
 800728a:	68bb      	ldr	r3, [r7, #8]
 800728c:	6a1b      	ldr	r3, [r3, #32]
 800728e:	4618      	mov	r0, r3
 8007290:	f001 f918 	bl	80084c4 <_nx_dhcp_add_randomize>
 8007294:	4602      	mov	r2, r0
 8007296:	68bb      	ldr	r3, [r7, #8]
 8007298:	621a      	str	r2, [r3, #32]

                /* Check if the timeout is zero.  */
                if (interface_record -> nx_dhcp_timeout == 0)
 800729a:	68bb      	ldr	r3, [r7, #8]
 800729c:	6a1b      	ldr	r3, [r3, #32]
 800729e:	2b00      	cmp	r3, #0
 80072a0:	d102      	bne.n	80072a8 <_nx_dhcp_packet_process+0x208>
                    interface_record -> nx_dhcp_timeout = 1;
 80072a2:	68bb      	ldr	r3, [r7, #8]
 80072a4:	2201      	movs	r2, #1
 80072a6:	621a      	str	r2, [r3, #32]

                /* Update the state to Requesting state.  */
                interface_record -> nx_dhcp_state = NX_DHCP_STATE_REQUESTING;
 80072a8:	68bb      	ldr	r3, [r7, #8]
 80072aa:	2204      	movs	r2, #4
 80072ac:	705a      	strb	r2, [r3, #1]
           }

           /* Let the timeout processing handle retransmissions. We're done here */
           break;
 80072ae:	e119      	b.n	80074e4 <_nx_dhcp_packet_process+0x444>
            /* Also initialize status to success since we won't make the get option call. */               
            status = NX_SUCCESS;
#endif

            /* Setup buffer pointer.  */
            buffer = new_packet_ptr -> nx_packet_prepend_ptr;
 80072b0:	69bb      	ldr	r3, [r7, #24]
 80072b2:	689b      	ldr	r3, [r3, #8]
 80072b4:	61fb      	str	r3, [r7, #28]

#ifndef NX_DHCP_ENABLE_BOOTP
            /* There is a valid DHCP response, see if it is an ACK.  */
            status = _nx_dhcp_get_option_value(buffer, NX_DHCP_OPTION_DHCP_TYPE, &dhcp_type, new_packet_ptr ->nx_packet_length);
 80072b6:	69bb      	ldr	r3, [r7, #24]
 80072b8:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 80072ba:	f107 0214 	add.w	r2, r7, #20
 80072be:	2135      	movs	r1, #53	; 0x35
 80072c0:	69f8      	ldr	r0, [r7, #28]
 80072c2:	f001 f857 	bl	8008374 <_nx_dhcp_get_option_value>
 80072c6:	63f8      	str	r0, [r7, #60]	; 0x3c
#endif
            /* Proceed to processing the server response?   */
            if (status == NX_SUCCESS)
 80072c8:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 80072ca:	2b00      	cmp	r3, #0
 80072cc:	f040 810e 	bne.w	80074ec <_nx_dhcp_packet_process+0x44c>
            {

                /* Yes, check and see if it is an ACK back to our previous request.  */
                if (dhcp_type == NX_DHCP_TYPE_DHCPACK)
 80072d0:	697b      	ldr	r3, [r7, #20]
 80072d2:	2b05      	cmp	r3, #5
 80072d4:	d12d      	bne.n	8007332 <_nx_dhcp_packet_process+0x292>
                {

                    /* Increment the number of ACKs received.  */
                    interface_record -> nx_dhcp_acks_received++;
 80072d6:	68bb      	ldr	r3, [r7, #8]
 80072d8:	f8d3 3194 	ldr.w	r3, [r3, #404]	; 0x194
 80072dc:	1c5a      	adds	r2, r3, #1
 80072de:	68bb      	ldr	r3, [r7, #8]
 80072e0:	f8c3 2194 	str.w	r2, [r3, #404]	; 0x194

                    /* Either we got an ACK or we are using BOOTP.  */

                    /* Update the parameters (IP address, server IP, lease, renewal and rebind times */
                    if (_nx_dhcp_extract_information(dhcp_ptr, interface_record, buffer, new_packet_ptr -> nx_packet_length))
 80072e4:	69bb      	ldr	r3, [r7, #24]
 80072e6:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 80072e8:	69fa      	ldr	r2, [r7, #28]
 80072ea:	68b9      	ldr	r1, [r7, #8]
 80072ec:	68f8      	ldr	r0, [r7, #12]
 80072ee:	f000 ff21 	bl	8008134 <_nx_dhcp_extract_information>
 80072f2:	4603      	mov	r3, r0
 80072f4:	2b00      	cmp	r3, #0
 80072f6:	f040 80fb 	bne.w	80074f0 <_nx_dhcp_packet_process+0x450>
                    /* Setup the handler to indicate the we want collision notification.  */
                    ip_ptr -> nx_ip_interface[iface_index].nx_interface_ip_conflict_notify_handler = _nx_dhcp_ip_conflict;

#else    /* NX_DHCP_CLIENT_SEND_ARP_PROBE not defined: */

                    nx_ip_interface_address_set(ip_ptr, iface_index, 
 80072fa:	68bb      	ldr	r3, [r7, #8]
 80072fc:	68da      	ldr	r2, [r3, #12]
 80072fe:	68bb      	ldr	r3, [r7, #8]
 8007300:	699b      	ldr	r3, [r3, #24]
 8007302:	6c39      	ldr	r1, [r7, #64]	; 0x40
 8007304:	6c78      	ldr	r0, [r7, #68]	; 0x44
 8007306:	f003 fc0a 	bl	800ab1e <_nx_ip_interface_address_set>
                                                interface_record -> nx_dhcp_ip_address,
                                                interface_record -> nx_dhcp_network_mask);

                    /* Check if the gateway address is valid.  */
                    if (interface_record -> nx_dhcp_gateway_address)
 800730a:	68bb      	ldr	r3, [r7, #8]
 800730c:	691b      	ldr	r3, [r3, #16]
 800730e:	2b00      	cmp	r3, #0
 8007310:	d007      	beq.n	8007322 <_nx_dhcp_packet_process+0x282>
                    {

                        /* Set the gateway address.  */
                        nx_ip_gateway_address_set(dhcp_ptr -> nx_dhcp_ip_ptr, interface_record -> nx_dhcp_gateway_address);
 8007312:	68fb      	ldr	r3, [r7, #12]
 8007314:	689a      	ldr	r2, [r3, #8]
 8007316:	68bb      	ldr	r3, [r7, #8]
 8007318:	691b      	ldr	r3, [r3, #16]
 800731a:	4619      	mov	r1, r3
 800731c:	4610      	mov	r0, r2
 800731e:	f003 fa52 	bl	800a7c6 <_nx_ip_gateway_address_set>
                    }

                    /* No ARP probe performed. OK to change to the Bound state.  */
                    interface_record -> nx_dhcp_state =  NX_DHCP_STATE_BOUND;
 8007322:	68bb      	ldr	r3, [r7, #8]
 8007324:	2205      	movs	r2, #5
 8007326:	705a      	strb	r2, [r3, #1]
#ifdef NX_DHCP_ENABLE_BOOTP
                    /* BOOTP does not use timeouts.  For the life of this DHCP Client application, keep the same IP address. */
                    interface_record -> nx_dhcp_timeout = NX_WAIT_FOREVER; 
#else
                    /* Set the renewal time received from the server.  */
                    interface_record -> nx_dhcp_timeout = interface_record -> nx_dhcp_renewal_time;
 8007328:	68bb      	ldr	r3, [r7, #8]
 800732a:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 800732c:	68bb      	ldr	r3, [r7, #8]
 800732e:	621a      	str	r2, [r3, #32]
#endif /* NX_DHCP_ENABLE_BOOTP  */

#endif /* NX_DHCP_CLIENT_SEND_ARP_PROBE*/

                    break;
 8007330:	e0e7      	b.n	8007502 <_nx_dhcp_packet_process+0x462>
                }
                else if (dhcp_type == NX_DHCP_TYPE_DHCPNACK)
 8007332:	697b      	ldr	r3, [r7, #20]
 8007334:	2b06      	cmp	r3, #6
 8007336:	f040 80d9 	bne.w	80074ec <_nx_dhcp_packet_process+0x44c>
                {
                                                 
                    /* Increment the number of NACKs received.  */
                    interface_record -> nx_dhcp_nacks_received++;
 800733a:	68bb      	ldr	r3, [r7, #8]
 800733c:	f8d3 3198 	ldr.w	r3, [r3, #408]	; 0x198
 8007340:	1c5a      	adds	r2, r3, #1
 8007342:	68bb      	ldr	r3, [r7, #8]
 8007344:	f8c3 2198 	str.w	r2, [r3, #408]	; 0x198

                    /* Reinitialize DHCP.  */
                    _nx_dhcp_interface_reinitialize(dhcp_ptr, interface_record -> nx_dhcp_interface_index);
 8007348:	68bb      	ldr	r3, [r7, #8]
 800734a:	69db      	ldr	r3, [r3, #28]
 800734c:	4619      	mov	r1, r3
 800734e:	68f8      	ldr	r0, [r7, #12]
 8007350:	f7ff fb76 	bl	8006a40 <_nx_dhcp_interface_reinitialize>

                    /* Restart DHCP service for this interface record.  */

                    /* Start the DHCP protocol again by setting the state back to INIT. */
                    interface_record -> nx_dhcp_state = NX_DHCP_STATE_INIT;
 8007354:	68bb      	ldr	r3, [r7, #8]
 8007356:	2202      	movs	r2, #2
 8007358:	705a      	strb	r2, [r3, #1]
                    /* The client begins in INIT state and forms a DHCPDISCOVER message.
                       The client should wait a random time between one and ten seconds to desynchronize the use of DHCP at startup.  
                       RFC2131, Section4.4.1, Page36.  */

                    /* Use the minimum value, Wait one second to begain in INIT state and forms a DHCP Discovery message.  */
                    interface_record -> nx_dhcp_timeout = NX_IP_PERIODIC_RATE;
 800735a:	68bb      	ldr	r3, [r7, #8]
 800735c:	2264      	movs	r2, #100	; 0x64
 800735e:	621a      	str	r2, [r3, #32]
                    interface_record -> nx_dhcp_rtr_interval = 0;
 8007360:	68bb      	ldr	r3, [r7, #8]
 8007362:	2200      	movs	r2, #0
 8007364:	625a      	str	r2, [r3, #36]	; 0x24

                    /* Check if the timeout is less than 1 second.  */
                    if (interface_record -> nx_dhcp_timeout < NX_IP_PERIODIC_RATE)
 8007366:	68bb      	ldr	r3, [r7, #8]
 8007368:	6a1b      	ldr	r3, [r3, #32]
 800736a:	2b63      	cmp	r3, #99	; 0x63
 800736c:	f200 80be 	bhi.w	80074ec <_nx_dhcp_packet_process+0x44c>
                        interface_record -> nx_dhcp_timeout = NX_IP_PERIODIC_RATE;
 8007370:	68bb      	ldr	r3, [r7, #8]
 8007372:	2264      	movs	r2, #100	; 0x64
 8007374:	621a      	str	r2, [r3, #32]
                }
            }
            break;
 8007376:	e0b9      	b.n	80074ec <_nx_dhcp_packet_process+0x44c>

        case NX_DHCP_STATE_RENEWING:
        {

            /* Setup the buffer pointer.  */
            buffer =  new_packet_ptr -> nx_packet_prepend_ptr;
 8007378:	69bb      	ldr	r3, [r7, #24]
 800737a:	689b      	ldr	r3, [r3, #8]
 800737c:	61fb      	str	r3, [r7, #28]

            /* Check the server response if it accepts are renewal.  */
            status = _nx_dhcp_get_option_value(buffer, NX_DHCP_OPTION_DHCP_TYPE, &dhcp_type, new_packet_ptr ->nx_packet_length);
 800737e:	69bb      	ldr	r3, [r7, #24]
 8007380:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8007382:	f107 0214 	add.w	r2, r7, #20
 8007386:	2135      	movs	r1, #53	; 0x35
 8007388:	69f8      	ldr	r0, [r7, #28]
 800738a:	f000 fff3 	bl	8008374 <_nx_dhcp_get_option_value>
 800738e:	63f8      	str	r0, [r7, #60]	; 0x3c

            /* Was the option retrieved?  */
            if (status == NX_SUCCESS)
 8007390:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8007392:	2b00      	cmp	r3, #0
 8007394:	f040 80ae 	bne.w	80074f4 <_nx_dhcp_packet_process+0x454>
            {

                /* Yes, Check for an ACK.  */
                if (dhcp_type == NX_DHCP_TYPE_DHCPACK)
 8007398:	697b      	ldr	r3, [r7, #20]
 800739a:	2b05      	cmp	r3, #5
 800739c:	d12d      	bne.n	80073fa <_nx_dhcp_packet_process+0x35a>
                {

                    /* Increment the number of ACKs received.  */
                    interface_record -> nx_dhcp_acks_received++;
 800739e:	68bb      	ldr	r3, [r7, #8]
 80073a0:	f8d3 3194 	ldr.w	r3, [r3, #404]	; 0x194
 80073a4:	1c5a      	adds	r2, r3, #1
 80073a6:	68bb      	ldr	r3, [r7, #8]
 80073a8:	f8c3 2194 	str.w	r2, [r3, #404]	; 0x194

                    /* Update the parameters (IP address, server IP, lease, renewal and rebind times */
                    if (_nx_dhcp_extract_information(dhcp_ptr, interface_record, buffer, new_packet_ptr -> nx_packet_length))
 80073ac:	69bb      	ldr	r3, [r7, #24]
 80073ae:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 80073b0:	69fa      	ldr	r2, [r7, #28]
 80073b2:	68b9      	ldr	r1, [r7, #8]
 80073b4:	68f8      	ldr	r0, [r7, #12]
 80073b6:	f000 febd 	bl	8008134 <_nx_dhcp_extract_information>
 80073ba:	4603      	mov	r3, r0
 80073bc:	2b00      	cmp	r3, #0
 80073be:	f040 809b 	bne.w	80074f8 <_nx_dhcp_packet_process+0x458>
                        break;
                    
                    /* Set the IP address and gateway address from the value extracted from the Server's DHCP response. */
                    nx_ip_interface_address_set(ip_ptr, iface_index, 
 80073c2:	68bb      	ldr	r3, [r7, #8]
 80073c4:	68da      	ldr	r2, [r3, #12]
 80073c6:	68bb      	ldr	r3, [r7, #8]
 80073c8:	699b      	ldr	r3, [r3, #24]
 80073ca:	6c39      	ldr	r1, [r7, #64]	; 0x40
 80073cc:	6c78      	ldr	r0, [r7, #68]	; 0x44
 80073ce:	f003 fba6 	bl	800ab1e <_nx_ip_interface_address_set>
                                                interface_record -> nx_dhcp_ip_address,  
                                                interface_record -> nx_dhcp_network_mask);

                    /* Check if the gateway address is valid.  */
                    if (interface_record -> nx_dhcp_gateway_address)
 80073d2:	68bb      	ldr	r3, [r7, #8]
 80073d4:	691b      	ldr	r3, [r3, #16]
 80073d6:	2b00      	cmp	r3, #0
 80073d8:	d007      	beq.n	80073ea <_nx_dhcp_packet_process+0x34a>
                    {

                        /* Set the gateway address.  */
                        nx_ip_gateway_address_set(dhcp_ptr -> nx_dhcp_ip_ptr, interface_record -> nx_dhcp_gateway_address);
 80073da:	68fb      	ldr	r3, [r7, #12]
 80073dc:	689a      	ldr	r2, [r3, #8]
 80073de:	68bb      	ldr	r3, [r7, #8]
 80073e0:	691b      	ldr	r3, [r3, #16]
 80073e2:	4619      	mov	r1, r3
 80073e4:	4610      	mov	r0, r2
 80073e6:	f003 f9ee 	bl	800a7c6 <_nx_ip_gateway_address_set>
                    }

                    /* Lease has been renewed, set the countdown timer back to the renewal time and go back 
                       to the Bound state*/
                    interface_record -> nx_dhcp_timeout = interface_record -> nx_dhcp_renewal_time;
 80073ea:	68bb      	ldr	r3, [r7, #8]
 80073ec:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 80073ee:	68bb      	ldr	r3, [r7, #8]
 80073f0:	621a      	str	r2, [r3, #32]

                    /* Change the state back to bound.  */
                    interface_record -> nx_dhcp_state =  NX_DHCP_STATE_BOUND;
 80073f2:	68bb      	ldr	r3, [r7, #8]
 80073f4:	2205      	movs	r2, #5
 80073f6:	705a      	strb	r2, [r3, #1]
                    /* Use the minimum value, Wait one second to begain in INIT state and forms a DHCP Discovery message.  */
                    interface_record -> nx_dhcp_timeout = NX_IP_PERIODIC_RATE;
                    interface_record -> nx_dhcp_rtr_interval = 0;
                }
            }
            break;
 80073f8:	e07c      	b.n	80074f4 <_nx_dhcp_packet_process+0x454>
                else if (dhcp_type == NX_DHCP_TYPE_DHCPNACK)
 80073fa:	697b      	ldr	r3, [r7, #20]
 80073fc:	2b06      	cmp	r3, #6
 80073fe:	d179      	bne.n	80074f4 <_nx_dhcp_packet_process+0x454>
                    interface_record -> nx_dhcp_nacks_received++;
 8007400:	68bb      	ldr	r3, [r7, #8]
 8007402:	f8d3 3198 	ldr.w	r3, [r3, #408]	; 0x198
 8007406:	1c5a      	adds	r2, r3, #1
 8007408:	68bb      	ldr	r3, [r7, #8]
 800740a:	f8c3 2198 	str.w	r2, [r3, #408]	; 0x198
                    _nx_dhcp_interface_reinitialize(dhcp_ptr, interface_record -> nx_dhcp_interface_index);
 800740e:	68bb      	ldr	r3, [r7, #8]
 8007410:	69db      	ldr	r3, [r3, #28]
 8007412:	4619      	mov	r1, r3
 8007414:	68f8      	ldr	r0, [r7, #12]
 8007416:	f7ff fb13 	bl	8006a40 <_nx_dhcp_interface_reinitialize>
                    interface_record -> nx_dhcp_state = NX_DHCP_STATE_INIT;
 800741a:	68bb      	ldr	r3, [r7, #8]
 800741c:	2202      	movs	r2, #2
 800741e:	705a      	strb	r2, [r3, #1]
                    interface_record -> nx_dhcp_timeout = NX_IP_PERIODIC_RATE;
 8007420:	68bb      	ldr	r3, [r7, #8]
 8007422:	2264      	movs	r2, #100	; 0x64
 8007424:	621a      	str	r2, [r3, #32]
                    interface_record -> nx_dhcp_rtr_interval = 0;
 8007426:	68bb      	ldr	r3, [r7, #8]
 8007428:	2200      	movs	r2, #0
 800742a:	625a      	str	r2, [r3, #36]	; 0x24
            break;
 800742c:	e062      	b.n	80074f4 <_nx_dhcp_packet_process+0x454>

        case NX_DHCP_STATE_REBINDING:
        {

            /* Setup buffer pointer.  */
            buffer =  new_packet_ptr -> nx_packet_prepend_ptr;
 800742e:	69bb      	ldr	r3, [r7, #24]
 8007430:	689b      	ldr	r3, [r3, #8]
 8007432:	61fb      	str	r3, [r7, #28]

            /* There is a valid DHCP response, pickup the type of response.  */
            status = _nx_dhcp_get_option_value(buffer, NX_DHCP_OPTION_DHCP_TYPE, &dhcp_type, new_packet_ptr ->nx_packet_length);
 8007434:	69bb      	ldr	r3, [r7, #24]
 8007436:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8007438:	f107 0214 	add.w	r2, r7, #20
 800743c:	2135      	movs	r1, #53	; 0x35
 800743e:	69f8      	ldr	r0, [r7, #28]
 8007440:	f000 ff98 	bl	8008374 <_nx_dhcp_get_option_value>
 8007444:	63f8      	str	r0, [r7, #60]	; 0x3c

            /* Valid response?  */
            if (status == NX_SUCCESS)
 8007446:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8007448:	2b00      	cmp	r3, #0
 800744a:	d157      	bne.n	80074fc <_nx_dhcp_packet_process+0x45c>
            {

                /* Is it an ACK response?  */
                if (dhcp_type == NX_DHCP_TYPE_DHCPACK)
 800744c:	697b      	ldr	r3, [r7, #20]
 800744e:	2b05      	cmp	r3, #5
 8007450:	d12c      	bne.n	80074ac <_nx_dhcp_packet_process+0x40c>
                {

                    /* Increment the number of ACKs received.  */
                    interface_record -> nx_dhcp_acks_received++;
 8007452:	68bb      	ldr	r3, [r7, #8]
 8007454:	f8d3 3194 	ldr.w	r3, [r3, #404]	; 0x194
 8007458:	1c5a      	adds	r2, r3, #1
 800745a:	68bb      	ldr	r3, [r7, #8]
 800745c:	f8c3 2194 	str.w	r2, [r3, #404]	; 0x194

                    /* Update the parameters (IP address, server IP, lease, renewal and rebind times */
                    if (_nx_dhcp_extract_information(dhcp_ptr, interface_record, buffer, new_packet_ptr -> nx_packet_length))
 8007460:	69bb      	ldr	r3, [r7, #24]
 8007462:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8007464:	69fa      	ldr	r2, [r7, #28]
 8007466:	68b9      	ldr	r1, [r7, #8]
 8007468:	68f8      	ldr	r0, [r7, #12]
 800746a:	f000 fe63 	bl	8008134 <_nx_dhcp_extract_information>
 800746e:	4603      	mov	r3, r0
 8007470:	2b00      	cmp	r3, #0
 8007472:	d145      	bne.n	8007500 <_nx_dhcp_packet_process+0x460>
                        break;

                    /* Set the IP address and gateway address from the value extracted from the Server's DHCP response. */
                    nx_ip_interface_address_set(ip_ptr, iface_index, 
 8007474:	68bb      	ldr	r3, [r7, #8]
 8007476:	68da      	ldr	r2, [r3, #12]
 8007478:	68bb      	ldr	r3, [r7, #8]
 800747a:	699b      	ldr	r3, [r3, #24]
 800747c:	6c39      	ldr	r1, [r7, #64]	; 0x40
 800747e:	6c78      	ldr	r0, [r7, #68]	; 0x44
 8007480:	f003 fb4d 	bl	800ab1e <_nx_ip_interface_address_set>
                                                interface_record -> nx_dhcp_ip_address,  
                                                interface_record -> nx_dhcp_network_mask);

                    /* Check if the gateway address is valid.  */
                    if (interface_record -> nx_dhcp_gateway_address)
 8007484:	68bb      	ldr	r3, [r7, #8]
 8007486:	691b      	ldr	r3, [r3, #16]
 8007488:	2b00      	cmp	r3, #0
 800748a:	d007      	beq.n	800749c <_nx_dhcp_packet_process+0x3fc>
                    {

                        /* Set the gateway address.  */
                        nx_ip_gateway_address_set(dhcp_ptr -> nx_dhcp_ip_ptr, interface_record -> nx_dhcp_gateway_address);
 800748c:	68fb      	ldr	r3, [r7, #12]
 800748e:	689a      	ldr	r2, [r3, #8]
 8007490:	68bb      	ldr	r3, [r7, #8]
 8007492:	691b      	ldr	r3, [r3, #16]
 8007494:	4619      	mov	r1, r3
 8007496:	4610      	mov	r0, r2
 8007498:	f003 f995 	bl	800a7c6 <_nx_ip_gateway_address_set>
                    }

                    /* Lease has been renewed, set the countdown timer back to the renewal time and go back 
                       to the Bound state.  */
                    interface_record -> nx_dhcp_timeout = interface_record -> nx_dhcp_renewal_time;
 800749c:	68bb      	ldr	r3, [r7, #8]
 800749e:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 80074a0:	68bb      	ldr	r3, [r7, #8]
 80074a2:	621a      	str	r2, [r3, #32]

                    /* Change to bound state.  */
                    interface_record -> nx_dhcp_state = NX_DHCP_STATE_BOUND;
 80074a4:	68bb      	ldr	r3, [r7, #8]
 80074a6:	2205      	movs	r2, #5
 80074a8:	705a      	strb	r2, [r3, #1]
                    /* Use the minimum value, Wait one second to begain in INIT state and forms a DHCP Discovery message.  */
                    interface_record -> nx_dhcp_timeout = NX_IP_PERIODIC_RATE;
                    interface_record -> nx_dhcp_rtr_interval = 0;
                }
            }
            break;
 80074aa:	e027      	b.n	80074fc <_nx_dhcp_packet_process+0x45c>
                else if (dhcp_type == NX_DHCP_TYPE_DHCPNACK)
 80074ac:	697b      	ldr	r3, [r7, #20]
 80074ae:	2b06      	cmp	r3, #6
 80074b0:	d124      	bne.n	80074fc <_nx_dhcp_packet_process+0x45c>
                    interface_record -> nx_dhcp_nacks_received++;
 80074b2:	68bb      	ldr	r3, [r7, #8]
 80074b4:	f8d3 3198 	ldr.w	r3, [r3, #408]	; 0x198
 80074b8:	1c5a      	adds	r2, r3, #1
 80074ba:	68bb      	ldr	r3, [r7, #8]
 80074bc:	f8c3 2198 	str.w	r2, [r3, #408]	; 0x198
                    _nx_dhcp_interface_reinitialize(dhcp_ptr, interface_record -> nx_dhcp_interface_index);
 80074c0:	68bb      	ldr	r3, [r7, #8]
 80074c2:	69db      	ldr	r3, [r3, #28]
 80074c4:	4619      	mov	r1, r3
 80074c6:	68f8      	ldr	r0, [r7, #12]
 80074c8:	f7ff faba 	bl	8006a40 <_nx_dhcp_interface_reinitialize>
                    interface_record -> nx_dhcp_state = NX_DHCP_STATE_INIT;
 80074cc:	68bb      	ldr	r3, [r7, #8]
 80074ce:	2202      	movs	r2, #2
 80074d0:	705a      	strb	r2, [r3, #1]
                    interface_record -> nx_dhcp_timeout = NX_IP_PERIODIC_RATE;
 80074d2:	68bb      	ldr	r3, [r7, #8]
 80074d4:	2264      	movs	r2, #100	; 0x64
 80074d6:	621a      	str	r2, [r3, #32]
                    interface_record -> nx_dhcp_rtr_interval = 0;
 80074d8:	68bb      	ldr	r3, [r7, #8]
 80074da:	2200      	movs	r2, #0
 80074dc:	625a      	str	r2, [r3, #36]	; 0x24
            break;
 80074de:	e00d      	b.n	80074fc <_nx_dhcp_packet_process+0x45c>
        }

        default:
            break;
 80074e0:	bf00      	nop
 80074e2:	e00e      	b.n	8007502 <_nx_dhcp_packet_process+0x462>
           break;
 80074e4:	bf00      	nop
 80074e6:	e00c      	b.n	8007502 <_nx_dhcp_packet_process+0x462>
                    break;
 80074e8:	bf00      	nop
 80074ea:	e00a      	b.n	8007502 <_nx_dhcp_packet_process+0x462>
            break;
 80074ec:	bf00      	nop
 80074ee:	e008      	b.n	8007502 <_nx_dhcp_packet_process+0x462>
                        break;
 80074f0:	bf00      	nop
 80074f2:	e006      	b.n	8007502 <_nx_dhcp_packet_process+0x462>
            break;
 80074f4:	bf00      	nop
 80074f6:	e004      	b.n	8007502 <_nx_dhcp_packet_process+0x462>
                        break;
 80074f8:	bf00      	nop
 80074fa:	e002      	b.n	8007502 <_nx_dhcp_packet_process+0x462>
            break;
 80074fc:	bf00      	nop
 80074fe:	e000      	b.n	8007502 <_nx_dhcp_packet_process+0x462>
                        break;
 8007500:	bf00      	nop

    } /* End of switch case */

    /* Release the packet.  */
    nx_packet_release(new_packet_ptr);
 8007502:	69bb      	ldr	r3, [r7, #24]
 8007504:	4618      	mov	r0, r3
 8007506:	f004 ff7f 	bl	800c408 <_nx_packet_release>

    /* Check if the state is changed.  */
    if (original_state != interface_record -> nx_dhcp_state)
 800750a:	68bb      	ldr	r3, [r7, #8]
 800750c:	785b      	ldrb	r3, [r3, #1]
 800750e:	461a      	mov	r2, r3
 8007510:	6a3b      	ldr	r3, [r7, #32]
 8007512:	4293      	cmp	r3, r2
 8007514:	d022      	beq.n	800755c <_nx_dhcp_packet_process+0x4bc>
    {

        /* Determine if the application has specified a routine for DHCP state change notification.  */
        if (dhcp_ptr -> nx_dhcp_state_change_callback)
 8007516:	68fb      	ldr	r3, [r7, #12]
 8007518:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
 800751c:	f8d3 3f3c 	ldr.w	r3, [r3, #3900]	; 0xf3c
 8007520:	2b00      	cmp	r3, #0
 8007522:	d009      	beq.n	8007538 <_nx_dhcp_packet_process+0x498>
        {

            /* Yes, call the application's state change notify function with the new state.  */
            (dhcp_ptr -> nx_dhcp_state_change_callback)(dhcp_ptr, interface_record -> nx_dhcp_state);
 8007524:	68fb      	ldr	r3, [r7, #12]
 8007526:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
 800752a:	f8d3 3f3c 	ldr.w	r3, [r3, #3900]	; 0xf3c
 800752e:	68ba      	ldr	r2, [r7, #8]
 8007530:	7852      	ldrb	r2, [r2, #1]
 8007532:	4611      	mov	r1, r2
 8007534:	68f8      	ldr	r0, [r7, #12]
 8007536:	4798      	blx	r3
        }

        /* Determine if the application has specified a routine for DHCP interface state change notification.  */
        if (dhcp_ptr -> nx_dhcp_interface_state_change_callback)
 8007538:	68fb      	ldr	r3, [r7, #12]
 800753a:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
 800753e:	f8d3 3f40 	ldr.w	r3, [r3, #3904]	; 0xf40
 8007542:	2b00      	cmp	r3, #0
 8007544:	d00a      	beq.n	800755c <_nx_dhcp_packet_process+0x4bc>
        {

            /* Yes, call the application's state change notify function with the new state.  */
            (dhcp_ptr -> nx_dhcp_interface_state_change_callback)(dhcp_ptr, interface_record -> nx_dhcp_interface_index, interface_record -> nx_dhcp_state);
 8007546:	68fb      	ldr	r3, [r7, #12]
 8007548:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
 800754c:	f8d3 3f40 	ldr.w	r3, [r3, #3904]	; 0xf40
 8007550:	68ba      	ldr	r2, [r7, #8]
 8007552:	69d1      	ldr	r1, [r2, #28]
 8007554:	68ba      	ldr	r2, [r7, #8]
 8007556:	7852      	ldrb	r2, [r2, #1]
 8007558:	68f8      	ldr	r0, [r7, #12]
 800755a:	4798      	blx	r3
        }
    }

    return;
 800755c:	bf00      	nop
}
 800755e:	3748      	adds	r7, #72	; 0x48
 8007560:	46bd      	mov	sp, r7
 8007562:	bd80      	pop	{r7, pc}

08007564 <_nx_dhcp_timeout_process>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
VOID _nx_dhcp_timeout_process(NX_DHCP *dhcp_ptr)
{
 8007564:	b580      	push	{r7, lr}
 8007566:	b086      	sub	sp, #24
 8007568:	af00      	add	r7, sp, #0
 800756a:	6078      	str	r0, [r7, #4]

UINT            i;
UINT            original_state;
NX_DHCP_INTERFACE_RECORD *interface_record = NX_NULL;
 800756c:	2300      	movs	r3, #0
 800756e:	613b      	str	r3, [r7, #16]

#endif /* NX_DHCP_CLIENT_SEND_ARP_PROBE  */

    /* Update the timeout on both interfaces. Check what needs to be done
       if a timeout expires, based on Client state. */
    for (i = 0; i < NX_DHCP_CLIENT_MAX_RECORDS; i++) 
 8007570:	2300      	movs	r3, #0
 8007572:	617b      	str	r3, [r7, #20]
 8007574:	e1a2      	b.n	80078bc <_nx_dhcp_timeout_process+0x358>
    {

         /* Check if the DHCP Client is active on this interface. */      
         if (dhcp_ptr -> nx_dhcp_interface_record[i].nx_dhcp_record_valid == NX_FALSE)
 8007576:	687a      	ldr	r2, [r7, #4]
 8007578:	697b      	ldr	r3, [r7, #20]
 800757a:	f44f 71d8 	mov.w	r1, #432	; 0x1b0
 800757e:	fb01 f303 	mul.w	r3, r1, r3
 8007582:	441a      	add	r2, r3
 8007584:	f641 538c 	movw	r3, #7564	; 0x1d8c
 8007588:	4413      	add	r3, r2
 800758a:	781b      	ldrb	r3, [r3, #0]
 800758c:	2b00      	cmp	r3, #0
 800758e:	f000 8191 	beq.w	80078b4 <_nx_dhcp_timeout_process+0x350>
             continue;

         /* Set the interface reocrd pointer.  */
         interface_record = &dhcp_ptr -> nx_dhcp_interface_record[i];
 8007592:	697b      	ldr	r3, [r7, #20]
 8007594:	f44f 72d8 	mov.w	r2, #432	; 0x1b0
 8007598:	fb03 f202 	mul.w	r2, r3, r2
 800759c:	f641 5388 	movw	r3, #7560	; 0x1d88
 80075a0:	4413      	add	r3, r2
 80075a2:	687a      	ldr	r2, [r7, #4]
 80075a4:	4413      	add	r3, r2
 80075a6:	3304      	adds	r3, #4
 80075a8:	613b      	str	r3, [r7, #16]

         /* Update the count.  */
         interface_record -> nx_dhcp_seconds ++;
 80075aa:	693b      	ldr	r3, [r7, #16]
 80075ac:	689b      	ldr	r3, [r3, #8]
 80075ae:	1c5a      	adds	r2, r3, #1
 80075b0:	693b      	ldr	r3, [r7, #16]
 80075b2:	609a      	str	r2, [r3, #8]

        /* Check the timer.  */
        if (interface_record -> nx_dhcp_timeout != 0)
 80075b4:	693b      	ldr	r3, [r7, #16]
 80075b6:	6a1b      	ldr	r3, [r3, #32]
 80075b8:	2b00      	cmp	r3, #0
 80075ba:	f000 817c 	beq.w	80078b6 <_nx_dhcp_timeout_process+0x352>
        {

            /* Apply the timer interval to the current DHCP Client timeout.  */
            if (interface_record -> nx_dhcp_timeout > NX_DHCP_TIME_INTERVAL)
 80075be:	693b      	ldr	r3, [r7, #16]
 80075c0:	6a1b      	ldr	r3, [r3, #32]
 80075c2:	2b64      	cmp	r3, #100	; 0x64
 80075c4:	d906      	bls.n	80075d4 <_nx_dhcp_timeout_process+0x70>
            {

                /* Update the timeout.  */
                interface_record -> nx_dhcp_timeout -= (ULONG)NX_DHCP_TIME_INTERVAL;
 80075c6:	693b      	ldr	r3, [r7, #16]
 80075c8:	6a1b      	ldr	r3, [r3, #32]
 80075ca:	f1a3 0264 	sub.w	r2, r3, #100	; 0x64
 80075ce:	693b      	ldr	r3, [r7, #16]
 80075d0:	621a      	str	r2, [r3, #32]
 80075d2:	e170      	b.n	80078b6 <_nx_dhcp_timeout_process+0x352>
            }
            else
            {

                /* The DHCP Client timeout has expired. */
                interface_record -> nx_dhcp_timeout = 0; 
 80075d4:	693b      	ldr	r3, [r7, #16]
 80075d6:	2200      	movs	r2, #0
 80075d8:	621a      	str	r2, [r3, #32]

                /* Save the current state for state change callback. */
                original_state = interface_record -> nx_dhcp_state;
 80075da:	693b      	ldr	r3, [r7, #16]
 80075dc:	785b      	ldrb	r3, [r3, #1]
 80075de:	60fb      	str	r3, [r7, #12]

                /* Process according to what state the Client is in. */
                switch (interface_record -> nx_dhcp_state)
 80075e0:	693b      	ldr	r3, [r7, #16]
 80075e2:	785b      	ldrb	r3, [r3, #1]
 80075e4:	3b02      	subs	r3, #2
 80075e6:	2b07      	cmp	r3, #7
 80075e8:	f200 8133 	bhi.w	8007852 <_nx_dhcp_timeout_process+0x2ee>
 80075ec:	a201      	add	r2, pc, #4	; (adr r2, 80075f4 <_nx_dhcp_timeout_process+0x90>)
 80075ee:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 80075f2:	bf00      	nop
 80075f4:	08007615 	.word	0x08007615
 80075f8:	08007699 	.word	0x08007699
 80075fc:	080076dd 	.word	0x080076dd
 8007600:	08007721 	.word	0x08007721
 8007604:	0800775f 	.word	0x0800775f
 8007608:	080077e5 	.word	0x080077e5
 800760c:	08007853 	.word	0x08007853
 8007610:	08007853 	.word	0x08007853

                    case NX_DHCP_STATE_INIT:
                    {

                        /* Reset the seconds field for starting the DHCP address acquistiion. */
                        interface_record -> nx_dhcp_seconds = 0;
 8007614:	693b      	ldr	r3, [r7, #16]
 8007616:	2200      	movs	r2, #0
 8007618:	609a      	str	r2, [r3, #8]
                        /* Initial state when there is no address.  Send a DHCPDISCOVER message
                           to find a DHCP server and switch to the SELECTING state.
                           Initial timeout is NX_DHCP_MIN_RETRANS_TIMEOUT seconds. */
#ifndef NX_DHCP_ENABLE_BOOTP
                        /* Only if the DHCP Client is requesting an IP address and is configured to skip the Discovery message. */
                        if ((interface_record -> nx_dhcp_ip_address != NX_BOOTP_NO_ADDRESS) &&
 800761a:	693b      	ldr	r3, [r7, #16]
 800761c:	68db      	ldr	r3, [r3, #12]
 800761e:	2b00      	cmp	r3, #0
 8007620:	d00c      	beq.n	800763c <_nx_dhcp_timeout_process+0xd8>
                            (interface_record -> nx_dhcp_skip_discovery))
 8007622:	693b      	ldr	r3, [r7, #16]
 8007624:	6c5b      	ldr	r3, [r3, #68]	; 0x44
                        if ((interface_record -> nx_dhcp_ip_address != NX_BOOTP_NO_ADDRESS) &&
 8007626:	2b00      	cmp	r3, #0
 8007628:	d008      	beq.n	800763c <_nx_dhcp_timeout_process+0xd8>
                        {

                            /* Send out the DHCP request.  */
                            _nx_dhcp_send_request_internal(dhcp_ptr, interface_record, NX_DHCP_TYPE_DHCPREQUEST);
 800762a:	2203      	movs	r2, #3
 800762c:	6939      	ldr	r1, [r7, #16]
 800762e:	6878      	ldr	r0, [r7, #4]
 8007630:	f000 f94e 	bl	80078d0 <_nx_dhcp_send_request_internal>

                            /* And change to the Requesting state. */
                            interface_record -> nx_dhcp_state = NX_DHCP_STATE_REQUESTING;
 8007634:	693b      	ldr	r3, [r7, #16]
 8007636:	2204      	movs	r2, #4
 8007638:	705a      	strb	r2, [r3, #1]
 800763a:	e007      	b.n	800764c <_nx_dhcp_timeout_process+0xe8>
                        }
                        else
                        {

                            /* Send out the DHCP request.  */
                            _nx_dhcp_send_request_internal(dhcp_ptr, interface_record, NX_DHCP_TYPE_DHCPDISCOVER);
 800763c:	2201      	movs	r2, #1
 800763e:	6939      	ldr	r1, [r7, #16]
 8007640:	6878      	ldr	r0, [r7, #4]
 8007642:	f000 f945 	bl	80078d0 <_nx_dhcp_send_request_internal>

                            /* And change to the Selecting state. */
                            interface_record -> nx_dhcp_state = NX_DHCP_STATE_SELECTING;
 8007646:	693b      	ldr	r3, [r7, #16]
 8007648:	2203      	movs	r2, #3
 800764a:	705a      	strb	r2, [r3, #1]
                        /* And change to the Requesting state. */
                        interface_record -> nx_dhcp_state = NX_DHCP_STATE_REQUESTING;
#endif

                        /* Check if the retransmission interval is zero.  */
                        if (interface_record -> nx_dhcp_rtr_interval == 0)
 800764c:	693b      	ldr	r3, [r7, #16]
 800764e:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8007650:	2b00      	cmp	r3, #0
 8007652:	d104      	bne.n	800765e <_nx_dhcp_timeout_process+0xfa>
                        {

                            /* Set the interval to min retransmission timeout.  */
                            interface_record -> nx_dhcp_rtr_interval = NX_DHCP_MIN_RETRANS_TIMEOUT;
 8007654:	693b      	ldr	r3, [r7, #16]
 8007656:	f44f 72c8 	mov.w	r2, #400	; 0x190
 800765a:	625a      	str	r2, [r3, #36]	; 0x24
 800765c:	e007      	b.n	800766e <_nx_dhcp_timeout_process+0x10a>
                        }
                        else
                        {

                            /* Record the retransmission interval for next retransmission.  */
                            interface_record -> nx_dhcp_rtr_interval = _nx_dhcp_update_timeout(interface_record -> nx_dhcp_rtr_interval);
 800765e:	693b      	ldr	r3, [r7, #16]
 8007660:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8007662:	4618      	mov	r0, r3
 8007664:	f000 ff5c 	bl	8008520 <_nx_dhcp_update_timeout>
 8007668:	4602      	mov	r2, r0
 800766a:	693b      	ldr	r3, [r7, #16]
 800766c:	625a      	str	r2, [r3, #36]	; 0x24
                        }

                        /* Update the timeout for next retransmission.  */
                        interface_record -> nx_dhcp_timeout = interface_record -> nx_dhcp_rtr_interval; 
 800766e:	693b      	ldr	r3, [r7, #16]
 8007670:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 8007672:	693b      	ldr	r3, [r7, #16]
 8007674:	621a      	str	r2, [r3, #32]

                        /* This will modify the timeout by up to +/- 1 second as recommended by RFC 2131, Section 4.1, Page 24. */
                        interface_record -> nx_dhcp_timeout = _nx_dhcp_add_randomize(interface_record -> nx_dhcp_timeout);
 8007676:	693b      	ldr	r3, [r7, #16]
 8007678:	6a1b      	ldr	r3, [r3, #32]
 800767a:	4618      	mov	r0, r3
 800767c:	f000 ff22 	bl	80084c4 <_nx_dhcp_add_randomize>
 8007680:	4602      	mov	r2, r0
 8007682:	693b      	ldr	r3, [r7, #16]
 8007684:	621a      	str	r2, [r3, #32]

                        /* Check if the timeout is zero.  */
                        if (interface_record -> nx_dhcp_timeout == 0)
 8007686:	693b      	ldr	r3, [r7, #16]
 8007688:	6a1b      	ldr	r3, [r3, #32]
 800768a:	2b00      	cmp	r3, #0
 800768c:	f040 80e3 	bne.w	8007856 <_nx_dhcp_timeout_process+0x2f2>
                            interface_record -> nx_dhcp_timeout = 1;
 8007690:	693b      	ldr	r3, [r7, #16]
 8007692:	2201      	movs	r2, #1
 8007694:	621a      	str	r2, [r3, #32]

                        break;
 8007696:	e0de      	b.n	8007856 <_nx_dhcp_timeout_process+0x2f2>
                    case NX_DHCP_STATE_SELECTING:
                    {

#ifndef NX_DHCP_ENABLE_BOOTP
                        /* Retransmit the Discover message.  */
                        _nx_dhcp_send_request_internal(dhcp_ptr, interface_record, NX_DHCP_TYPE_DHCPDISCOVER);
 8007698:	2201      	movs	r2, #1
 800769a:	6939      	ldr	r1, [r7, #16]
 800769c:	6878      	ldr	r0, [r7, #4]
 800769e:	f000 f917 	bl	80078d0 <_nx_dhcp_send_request_internal>
                        /* Retransmit the BOOTP Request message.  */ 
                        _nx_dhcp_send_request_internal(dhcp_ptr, interface_record, NX_DHCP_TYPE_BOOT_REQUEST);
#endif

                        /* Update the retransmision interval.   */
                        interface_record -> nx_dhcp_rtr_interval = _nx_dhcp_update_timeout(interface_record -> nx_dhcp_rtr_interval);
 80076a2:	693b      	ldr	r3, [r7, #16]
 80076a4:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 80076a6:	4618      	mov	r0, r3
 80076a8:	f000 ff3a 	bl	8008520 <_nx_dhcp_update_timeout>
 80076ac:	4602      	mov	r2, r0
 80076ae:	693b      	ldr	r3, [r7, #16]
 80076b0:	625a      	str	r2, [r3, #36]	; 0x24

                        /* Update the timeout for next retransmission.  */
                        interface_record -> nx_dhcp_timeout = interface_record -> nx_dhcp_rtr_interval;
 80076b2:	693b      	ldr	r3, [r7, #16]
 80076b4:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 80076b6:	693b      	ldr	r3, [r7, #16]
 80076b8:	621a      	str	r2, [r3, #32]

                        /* This will modify the timeout by up to +/- 1 second as recommended by RFC 2131, Section 4.1, Page 24. */
                        interface_record -> nx_dhcp_timeout = _nx_dhcp_add_randomize(interface_record -> nx_dhcp_timeout);
 80076ba:	693b      	ldr	r3, [r7, #16]
 80076bc:	6a1b      	ldr	r3, [r3, #32]
 80076be:	4618      	mov	r0, r3
 80076c0:	f000 ff00 	bl	80084c4 <_nx_dhcp_add_randomize>
 80076c4:	4602      	mov	r2, r0
 80076c6:	693b      	ldr	r3, [r7, #16]
 80076c8:	621a      	str	r2, [r3, #32]

                        /* Check if the timeout is zero.  */
                        if (interface_record -> nx_dhcp_timeout == 0)
 80076ca:	693b      	ldr	r3, [r7, #16]
 80076cc:	6a1b      	ldr	r3, [r3, #32]
 80076ce:	2b00      	cmp	r3, #0
 80076d0:	f040 80c3 	bne.w	800785a <_nx_dhcp_timeout_process+0x2f6>
                            interface_record -> nx_dhcp_timeout = 1;
 80076d4:	693b      	ldr	r3, [r7, #16]
 80076d6:	2201      	movs	r2, #1
 80076d8:	621a      	str	r2, [r3, #32]

                        break;
 80076da:	e0be      	b.n	800785a <_nx_dhcp_timeout_process+0x2f6>
                    case NX_DHCP_STATE_REQUESTING:
                    {

#ifndef NX_DHCP_ENABLE_BOOTP
                        /* Send a DHCP request. */
                        _nx_dhcp_send_request_internal(dhcp_ptr, interface_record, NX_DHCP_TYPE_DHCPREQUEST);
 80076dc:	2203      	movs	r2, #3
 80076de:	6939      	ldr	r1, [r7, #16]
 80076e0:	6878      	ldr	r0, [r7, #4]
 80076e2:	f000 f8f5 	bl	80078d0 <_nx_dhcp_send_request_internal>
                        /* Send a BOOTP request. */
                        _nx_dhcp_send_request_internal(dhcp_ptr, interface_record, NX_DHCP_TYPE_BOOT_REQUEST);
#endif
                                                
                        /* Update the retransmision interval.   */
                        interface_record->nx_dhcp_rtr_interval = _nx_dhcp_update_timeout(interface_record -> nx_dhcp_rtr_interval);
 80076e6:	693b      	ldr	r3, [r7, #16]
 80076e8:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 80076ea:	4618      	mov	r0, r3
 80076ec:	f000 ff18 	bl	8008520 <_nx_dhcp_update_timeout>
 80076f0:	4602      	mov	r2, r0
 80076f2:	693b      	ldr	r3, [r7, #16]
 80076f4:	625a      	str	r2, [r3, #36]	; 0x24

                        /* Reset the timeout for next retransmision. */
                        interface_record -> nx_dhcp_timeout = interface_record->nx_dhcp_rtr_interval;
 80076f6:	693b      	ldr	r3, [r7, #16]
 80076f8:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 80076fa:	693b      	ldr	r3, [r7, #16]
 80076fc:	621a      	str	r2, [r3, #32]

                        /* This will modify the timeout by up to +/- 1 second as recommended by RFC 2131, Section 4.1, Page 24. */
                        interface_record -> nx_dhcp_timeout = _nx_dhcp_add_randomize(interface_record -> nx_dhcp_timeout);
 80076fe:	693b      	ldr	r3, [r7, #16]
 8007700:	6a1b      	ldr	r3, [r3, #32]
 8007702:	4618      	mov	r0, r3
 8007704:	f000 fede 	bl	80084c4 <_nx_dhcp_add_randomize>
 8007708:	4602      	mov	r2, r0
 800770a:	693b      	ldr	r3, [r7, #16]
 800770c:	621a      	str	r2, [r3, #32]

                        /* Check if the timeout is zero.  */
                        if (interface_record -> nx_dhcp_timeout == 0)
 800770e:	693b      	ldr	r3, [r7, #16]
 8007710:	6a1b      	ldr	r3, [r3, #32]
 8007712:	2b00      	cmp	r3, #0
 8007714:	f040 80a3 	bne.w	800785e <_nx_dhcp_timeout_process+0x2fa>
                            interface_record -> nx_dhcp_timeout = 1;
 8007718:	693b      	ldr	r3, [r7, #16]
 800771a:	2201      	movs	r2, #1
 800771c:	621a      	str	r2, [r3, #32]

                        break;
 800771e:	e09e      	b.n	800785e <_nx_dhcp_timeout_process+0x2fa>

                    case NX_DHCP_STATE_BOUND:
                    {

                        /* Reset the seconds field for starting the DHCP request process. */
                        interface_record -> nx_dhcp_seconds = 0;
 8007720:	693b      	ldr	r3, [r7, #16]
 8007722:	2200      	movs	r2, #0
 8007724:	609a      	str	r2, [r3, #8]

                        /* The lease has timed out. Time to renew.  */

                        /* And change to the Renewing state. */
                        interface_record -> nx_dhcp_state = NX_DHCP_STATE_RENEWING;
 8007726:	693b      	ldr	r3, [r7, #16]
 8007728:	2206      	movs	r2, #6
 800772a:	705a      	strb	r2, [r3, #1]

                        /* Send the renewal request.  */
                        _nx_dhcp_send_request_internal(dhcp_ptr, interface_record, NX_DHCP_TYPE_DHCPREQUEST);
 800772c:	2203      	movs	r2, #3
 800772e:	6939      	ldr	r1, [r7, #16]
 8007730:	6878      	ldr	r0, [r7, #4]
 8007732:	f000 f8cd 	bl	80078d0 <_nx_dhcp_send_request_internal>

                        /* Set the time remaining based on RFC 2131 when T1 expires. */
                        interface_record -> nx_dhcp_renewal_remain_time = interface_record -> nx_dhcp_rebind_time - interface_record -> nx_dhcp_renewal_time;
 8007736:	693b      	ldr	r3, [r7, #16]
 8007738:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 800773a:	693b      	ldr	r3, [r7, #16]
 800773c:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800773e:	1ad2      	subs	r2, r2, r3
 8007740:	693b      	ldr	r3, [r7, #16]
 8007742:	639a      	str	r2, [r3, #56]	; 0x38
                        interface_record -> nx_dhcp_timeout = _nx_dhcp_update_renewal_timeout(interface_record -> nx_dhcp_renewal_remain_time);
 8007744:	693b      	ldr	r3, [r7, #16]
 8007746:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 8007748:	4618      	mov	r0, r3
 800774a:	f000 ff00 	bl	800854e <_nx_dhcp_update_renewal_timeout>
 800774e:	4602      	mov	r2, r0
 8007750:	693b      	ldr	r3, [r7, #16]
 8007752:	621a      	str	r2, [r3, #32]

                        /* Record the retransmission interval.  */
                        interface_record -> nx_dhcp_rtr_interval = interface_record -> nx_dhcp_timeout;
 8007754:	693b      	ldr	r3, [r7, #16]
 8007756:	6a1a      	ldr	r2, [r3, #32]
 8007758:	693b      	ldr	r3, [r7, #16]
 800775a:	625a      	str	r2, [r3, #36]	; 0x24

                        break;
 800775c:	e080      	b.n	8007860 <_nx_dhcp_timeout_process+0x2fc>

                    case NX_DHCP_STATE_RENEWING:
                    {

                        /* Check if we have reached the end of the renewal time.  */
                        if (interface_record -> nx_dhcp_renewal_remain_time >= interface_record -> nx_dhcp_rtr_interval)
 800775e:	693b      	ldr	r3, [r7, #16]
 8007760:	6b9a      	ldr	r2, [r3, #56]	; 0x38
 8007762:	693b      	ldr	r3, [r7, #16]
 8007764:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8007766:	429a      	cmp	r2, r3
 8007768:	d307      	bcc.n	800777a <_nx_dhcp_timeout_process+0x216>
                        {
                            interface_record -> nx_dhcp_renewal_remain_time -= interface_record -> nx_dhcp_rtr_interval;
 800776a:	693b      	ldr	r3, [r7, #16]
 800776c:	6b9a      	ldr	r2, [r3, #56]	; 0x38
 800776e:	693b      	ldr	r3, [r7, #16]
 8007770:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8007772:	1ad2      	subs	r2, r2, r3
 8007774:	693b      	ldr	r3, [r7, #16]
 8007776:	639a      	str	r2, [r3, #56]	; 0x38
 8007778:	e002      	b.n	8007780 <_nx_dhcp_timeout_process+0x21c>
                        }
                        else
                        {
                            interface_record -> nx_dhcp_renewal_remain_time = 0;
 800777a:	693b      	ldr	r3, [r7, #16]
 800777c:	2200      	movs	r2, #0
 800777e:	639a      	str	r2, [r3, #56]	; 0x38
                        }

                        /* Update the timeout for renew retranmission.  */
                        interface_record -> nx_dhcp_timeout = _nx_dhcp_update_renewal_timeout(interface_record -> nx_dhcp_renewal_remain_time);
 8007780:	693b      	ldr	r3, [r7, #16]
 8007782:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 8007784:	4618      	mov	r0, r3
 8007786:	f000 fee2 	bl	800854e <_nx_dhcp_update_renewal_timeout>
 800778a:	4602      	mov	r2, r0
 800778c:	693b      	ldr	r3, [r7, #16]
 800778e:	621a      	str	r2, [r3, #32]
                                                     
                        /* Check if we are at the limit on retransmission.  */
                        if (interface_record -> nx_dhcp_timeout == 0)
 8007790:	693b      	ldr	r3, [r7, #16]
 8007792:	6a1b      	ldr	r3, [r3, #32]
 8007794:	2b00      	cmp	r3, #0
 8007796:	d11b      	bne.n	80077d0 <_nx_dhcp_timeout_process+0x26c>
                        {

                            /* And change to the Rebinding state. */
                            interface_record -> nx_dhcp_state = NX_DHCP_STATE_REBINDING;
 8007798:	693b      	ldr	r3, [r7, #16]
 800779a:	2207      	movs	r2, #7
 800779c:	705a      	strb	r2, [r3, #1]

                            /* Send the rebind request.  */
                            _nx_dhcp_send_request_internal(dhcp_ptr, interface_record, NX_DHCP_TYPE_DHCPREQUEST);
 800779e:	2203      	movs	r2, #3
 80077a0:	6939      	ldr	r1, [r7, #16]
 80077a2:	6878      	ldr	r0, [r7, #4]
 80077a4:	f000 f894 	bl	80078d0 <_nx_dhcp_send_request_internal>

                            /* Calculate the rebind time based on the RFC 2131. */
                            interface_record -> nx_dhcp_rebind_remain_time = interface_record -> nx_dhcp_lease_time - interface_record -> nx_dhcp_rebind_time;
 80077a8:	693b      	ldr	r3, [r7, #16]
 80077aa:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 80077ac:	693b      	ldr	r3, [r7, #16]
 80077ae:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 80077b0:	1ad2      	subs	r2, r2, r3
 80077b2:	693b      	ldr	r3, [r7, #16]
 80077b4:	63da      	str	r2, [r3, #60]	; 0x3c
                                                                                        
                            /* Calculate the timeout for the response.  */
                            interface_record -> nx_dhcp_timeout = _nx_dhcp_update_renewal_timeout(interface_record -> nx_dhcp_rebind_remain_time);
 80077b6:	693b      	ldr	r3, [r7, #16]
 80077b8:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 80077ba:	4618      	mov	r0, r3
 80077bc:	f000 fec7 	bl	800854e <_nx_dhcp_update_renewal_timeout>
 80077c0:	4602      	mov	r2, r0
 80077c2:	693b      	ldr	r3, [r7, #16]
 80077c4:	621a      	str	r2, [r3, #32]

                            /* Record the retransmission interval.  */
                            interface_record -> nx_dhcp_rtr_interval = interface_record -> nx_dhcp_timeout;
 80077c6:	693b      	ldr	r3, [r7, #16]
 80077c8:	6a1a      	ldr	r2, [r3, #32]
 80077ca:	693b      	ldr	r3, [r7, #16]
 80077cc:	625a      	str	r2, [r3, #36]	; 0x24

                            /* Record the retransmission interval.  */
                            interface_record -> nx_dhcp_rtr_interval = interface_record -> nx_dhcp_timeout;
                        }

                        break;
 80077ce:	e047      	b.n	8007860 <_nx_dhcp_timeout_process+0x2fc>
                            _nx_dhcp_send_request_internal(dhcp_ptr, interface_record, NX_DHCP_TYPE_DHCPREQUEST);
 80077d0:	2203      	movs	r2, #3
 80077d2:	6939      	ldr	r1, [r7, #16]
 80077d4:	6878      	ldr	r0, [r7, #4]
 80077d6:	f000 f87b 	bl	80078d0 <_nx_dhcp_send_request_internal>
                            interface_record -> nx_dhcp_rtr_interval = interface_record -> nx_dhcp_timeout;
 80077da:	693b      	ldr	r3, [r7, #16]
 80077dc:	6a1a      	ldr	r2, [r3, #32]
 80077de:	693b      	ldr	r3, [r7, #16]
 80077e0:	625a      	str	r2, [r3, #36]	; 0x24
                        break;
 80077e2:	e03d      	b.n	8007860 <_nx_dhcp_timeout_process+0x2fc>
                    {

                        /* No response yet, the response must have timed out, 
                            update the timeout and check if we have reached the 
                            end of the rebinding time.  */
                        if (interface_record -> nx_dhcp_rebind_remain_time >= interface_record -> nx_dhcp_rtr_interval)
 80077e4:	693b      	ldr	r3, [r7, #16]
 80077e6:	6bda      	ldr	r2, [r3, #60]	; 0x3c
 80077e8:	693b      	ldr	r3, [r7, #16]
 80077ea:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 80077ec:	429a      	cmp	r2, r3
 80077ee:	d307      	bcc.n	8007800 <_nx_dhcp_timeout_process+0x29c>
                        {
                            interface_record -> nx_dhcp_rebind_remain_time -= interface_record -> nx_dhcp_rtr_interval;
 80077f0:	693b      	ldr	r3, [r7, #16]
 80077f2:	6bda      	ldr	r2, [r3, #60]	; 0x3c
 80077f4:	693b      	ldr	r3, [r7, #16]
 80077f6:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 80077f8:	1ad2      	subs	r2, r2, r3
 80077fa:	693b      	ldr	r3, [r7, #16]
 80077fc:	63da      	str	r2, [r3, #60]	; 0x3c
 80077fe:	e002      	b.n	8007806 <_nx_dhcp_timeout_process+0x2a2>
                        }
                        else
                        {
                            interface_record -> nx_dhcp_rebind_remain_time = 0;
 8007800:	693b      	ldr	r3, [r7, #16]
 8007802:	2200      	movs	r2, #0
 8007804:	63da      	str	r2, [r3, #60]	; 0x3c
                        }

                        /* Update the timeout for renew retranmission.  */
                        interface_record -> nx_dhcp_timeout = _nx_dhcp_update_renewal_timeout(interface_record -> nx_dhcp_rebind_remain_time);
 8007806:	693b      	ldr	r3, [r7, #16]
 8007808:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 800780a:	4618      	mov	r0, r3
 800780c:	f000 fe9f 	bl	800854e <_nx_dhcp_update_renewal_timeout>
 8007810:	4602      	mov	r2, r0
 8007812:	693b      	ldr	r3, [r7, #16]
 8007814:	621a      	str	r2, [r3, #32]
                                                     
                        /* Check if we are at the limit on retransmission.  */
                        if (interface_record -> nx_dhcp_timeout == 0)
 8007816:	693b      	ldr	r3, [r7, #16]
 8007818:	6a1b      	ldr	r3, [r3, #32]
 800781a:	2b00      	cmp	r3, #0
 800781c:	d10f      	bne.n	800783e <_nx_dhcp_timeout_process+0x2da>
                        {

                            /* Timeout. Restart DHCP service for this interface record.  */

                            /* Reinitialize DHCP.  */
                            _nx_dhcp_interface_reinitialize(dhcp_ptr, interface_record -> nx_dhcp_interface_index);
 800781e:	693b      	ldr	r3, [r7, #16]
 8007820:	69db      	ldr	r3, [r3, #28]
 8007822:	4619      	mov	r1, r3
 8007824:	6878      	ldr	r0, [r7, #4]
 8007826:	f7ff f90b 	bl	8006a40 <_nx_dhcp_interface_reinitialize>

                            /* Start the DHCP protocol again by setting the state back to INIT. */
                            interface_record -> nx_dhcp_state = NX_DHCP_STATE_INIT;
 800782a:	693b      	ldr	r3, [r7, #16]
 800782c:	2202      	movs	r2, #2
 800782e:	705a      	strb	r2, [r3, #1]
                            /* The client begins in INIT state and forms a DHCPDISCOVER message.
                               The client should wait a random time between one and ten seconds to desynchronize the use of DHCP at startup.  
                               RFC2131, Section4.4.1, Page36.  */

                            /* Use the minimum value, Wait one second to begain in INIT state and forms a DHCP Discovery message.  */
                            interface_record -> nx_dhcp_timeout = NX_IP_PERIODIC_RATE;
 8007830:	693b      	ldr	r3, [r7, #16]
 8007832:	2264      	movs	r2, #100	; 0x64
 8007834:	621a      	str	r2, [r3, #32]
                            interface_record -> nx_dhcp_rtr_interval = 0;
 8007836:	693b      	ldr	r3, [r7, #16]
 8007838:	2200      	movs	r2, #0
 800783a:	625a      	str	r2, [r3, #36]	; 0x24
                            _nx_dhcp_send_request_internal(dhcp_ptr, interface_record, NX_DHCP_TYPE_DHCPREQUEST);

                            /* Record the retransmission interval.  */
                            interface_record -> nx_dhcp_rtr_interval = interface_record -> nx_dhcp_timeout;
                        }
                        break;
 800783c:	e010      	b.n	8007860 <_nx_dhcp_timeout_process+0x2fc>
                            _nx_dhcp_send_request_internal(dhcp_ptr, interface_record, NX_DHCP_TYPE_DHCPREQUEST);
 800783e:	2203      	movs	r2, #3
 8007840:	6939      	ldr	r1, [r7, #16]
 8007842:	6878      	ldr	r0, [r7, #4]
 8007844:	f000 f844 	bl	80078d0 <_nx_dhcp_send_request_internal>
                            interface_record -> nx_dhcp_rtr_interval = interface_record -> nx_dhcp_timeout;
 8007848:	693b      	ldr	r3, [r7, #16]
 800784a:	6a1a      	ldr	r2, [r3, #32]
 800784c:	693b      	ldr	r3, [r7, #16]
 800784e:	625a      	str	r2, [r3, #36]	; 0x24
                        break;
 8007850:	e006      	b.n	8007860 <_nx_dhcp_timeout_process+0x2fc>
                    }

                    default:
                    {

                        break;
 8007852:	bf00      	nop
 8007854:	e004      	b.n	8007860 <_nx_dhcp_timeout_process+0x2fc>
                        break;
 8007856:	bf00      	nop
 8007858:	e002      	b.n	8007860 <_nx_dhcp_timeout_process+0x2fc>
                        break;
 800785a:	bf00      	nop
 800785c:	e000      	b.n	8007860 <_nx_dhcp_timeout_process+0x2fc>
                        break;
 800785e:	bf00      	nop
                    }
                }

                /* Check if the state is changed.  */
                if (original_state != interface_record -> nx_dhcp_state)
 8007860:	693b      	ldr	r3, [r7, #16]
 8007862:	785b      	ldrb	r3, [r3, #1]
 8007864:	461a      	mov	r2, r3
 8007866:	68fb      	ldr	r3, [r7, #12]
 8007868:	4293      	cmp	r3, r2
 800786a:	d024      	beq.n	80078b6 <_nx_dhcp_timeout_process+0x352>
                {

                    /* Determine if the application has specified a routine for DHCP state change notification.  */
                    if (dhcp_ptr -> nx_dhcp_state_change_callback)
 800786c:	687b      	ldr	r3, [r7, #4]
 800786e:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
 8007872:	f8d3 3f3c 	ldr.w	r3, [r3, #3900]	; 0xf3c
 8007876:	2b00      	cmp	r3, #0
 8007878:	d009      	beq.n	800788e <_nx_dhcp_timeout_process+0x32a>
                    {

                        /* Yes, call the application's state change notify function with the new state.  */
                        (dhcp_ptr -> nx_dhcp_state_change_callback)(dhcp_ptr, interface_record -> nx_dhcp_state);
 800787a:	687b      	ldr	r3, [r7, #4]
 800787c:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
 8007880:	f8d3 3f3c 	ldr.w	r3, [r3, #3900]	; 0xf3c
 8007884:	693a      	ldr	r2, [r7, #16]
 8007886:	7852      	ldrb	r2, [r2, #1]
 8007888:	4611      	mov	r1, r2
 800788a:	6878      	ldr	r0, [r7, #4]
 800788c:	4798      	blx	r3
                    }

                    /* Determine if the application has specified a routine for DHCP interface state change notification.  */
                    if (dhcp_ptr -> nx_dhcp_interface_state_change_callback)
 800788e:	687b      	ldr	r3, [r7, #4]
 8007890:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
 8007894:	f8d3 3f40 	ldr.w	r3, [r3, #3904]	; 0xf40
 8007898:	2b00      	cmp	r3, #0
 800789a:	d00c      	beq.n	80078b6 <_nx_dhcp_timeout_process+0x352>
                    {

                        /* Yes, call the application's state change notify function with the new state.  */
                        (dhcp_ptr -> nx_dhcp_interface_state_change_callback)(dhcp_ptr, interface_record -> nx_dhcp_interface_index, interface_record -> nx_dhcp_state);
 800789c:	687b      	ldr	r3, [r7, #4]
 800789e:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
 80078a2:	f8d3 3f40 	ldr.w	r3, [r3, #3904]	; 0xf40
 80078a6:	693a      	ldr	r2, [r7, #16]
 80078a8:	69d1      	ldr	r1, [r2, #28]
 80078aa:	693a      	ldr	r2, [r7, #16]
 80078ac:	7852      	ldrb	r2, [r2, #1]
 80078ae:	6878      	ldr	r0, [r7, #4]
 80078b0:	4798      	blx	r3
 80078b2:	e000      	b.n	80078b6 <_nx_dhcp_timeout_process+0x352>
             continue;
 80078b4:	bf00      	nop
    for (i = 0; i < NX_DHCP_CLIENT_MAX_RECORDS; i++) 
 80078b6:	697b      	ldr	r3, [r7, #20]
 80078b8:	3301      	adds	r3, #1
 80078ba:	617b      	str	r3, [r7, #20]
 80078bc:	697b      	ldr	r3, [r7, #20]
 80078be:	2b00      	cmp	r3, #0
 80078c0:	f43f ae59 	beq.w	8007576 <_nx_dhcp_timeout_process+0x12>

            } /* End of switch statement. */ 
        }

    } /* Try the next interface record.  */ 
}
 80078c4:	bf00      	nop
 80078c6:	bf00      	nop
 80078c8:	3718      	adds	r7, #24
 80078ca:	46bd      	mov	sp, r7
 80078cc:	bd80      	pop	{r7, pc}
 80078ce:	bf00      	nop

080078d0 <_nx_dhcp_send_request_internal>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
static UINT  _nx_dhcp_send_request_internal(NX_DHCP *dhcp_ptr, NX_DHCP_INTERFACE_RECORD *interface_record, UINT dhcp_message_type)
{
 80078d0:	b590      	push	{r4, r7, lr}
 80078d2:	b093      	sub	sp, #76	; 0x4c
 80078d4:	af02      	add	r7, sp, #8
 80078d6:	60f8      	str	r0, [r7, #12]
 80078d8:	60b9      	str	r1, [r7, #8]
 80078da:	607a      	str	r2, [r7, #4]
ULONG           targetIP;
UINT            status;
ULONG           dhcp_client_mac_msw;
ULONG           dhcp_client_mac_lsw;
UINT            iface_index;
UINT            index = 0;
 80078dc:	2300      	movs	r3, #0
 80078de:	61fb      	str	r3, [r7, #28]
UINT            user_option_length;
UINT            name_length;


    /* Set the interface idnex.  */
    iface_index = interface_record -> nx_dhcp_interface_index;
 80078e0:	68bb      	ldr	r3, [r7, #8]
 80078e2:	69db      	ldr	r3, [r3, #28]
 80078e4:	637b      	str	r3, [r7, #52]	; 0x34

    /* Allocate a DHCP packet.  */
    status =  nx_packet_allocate(dhcp_ptr -> nx_dhcp_packet_pool_ptr, &packet_ptr, NX_IPv4_UDP_PACKET, NX_NO_WAIT);
 80078e6:	68fb      	ldr	r3, [r7, #12]
 80078e8:	f8d3 0bd8 	ldr.w	r0, [r3, #3032]	; 0xbd8
 80078ec:	f107 0120 	add.w	r1, r7, #32
 80078f0:	2300      	movs	r3, #0
 80078f2:	222c      	movs	r2, #44	; 0x2c
 80078f4:	f004 f924 	bl	800bb40 <_nx_packet_allocate>
 80078f8:	63b8      	str	r0, [r7, #56]	; 0x38

    /* Was the packet allocation successful?  */
    if (status != NX_SUCCESS)
 80078fa:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 80078fc:	2b00      	cmp	r3, #0
 80078fe:	d008      	beq.n	8007912 <_nx_dhcp_send_request_internal+0x42>
    {

        /* Increment the DHCP internal error counter.  */
        interface_record -> nx_dhcp_internal_errors++;
 8007900:	68bb      	ldr	r3, [r7, #8]
 8007902:	f8d3 3184 	ldr.w	r3, [r3, #388]	; 0x184
 8007906:	1c5a      	adds	r2, r3, #1
 8007908:	68bb      	ldr	r3, [r7, #8]
 800790a:	f8c3 2184 	str.w	r2, [r3, #388]	; 0x184

        /* Return status.  */
        return(status);
 800790e:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8007910:	e2a4      	b.n	8007e5c <_nx_dhcp_send_request_internal+0x58c>
    }

    /* Set the interface index and MAC address.  */
    dhcp_client_mac_msw = dhcp_ptr -> nx_dhcp_ip_ptr -> nx_ip_interface[iface_index].nx_interface_physical_address_msw;
 8007912:	68fb      	ldr	r3, [r7, #12]
 8007914:	689a      	ldr	r2, [r3, #8]
 8007916:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8007918:	214c      	movs	r1, #76	; 0x4c
 800791a:	fb01 f303 	mul.w	r3, r1, r3
 800791e:	4413      	add	r3, r2
 8007920:	f203 732c 	addw	r3, r3, #1836	; 0x72c
 8007924:	681b      	ldr	r3, [r3, #0]
 8007926:	633b      	str	r3, [r7, #48]	; 0x30
    dhcp_client_mac_lsw = dhcp_ptr -> nx_dhcp_ip_ptr -> nx_ip_interface[iface_index].nx_interface_physical_address_lsw;
 8007928:	68fb      	ldr	r3, [r7, #12]
 800792a:	689a      	ldr	r2, [r3, #8]
 800792c:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800792e:	214c      	movs	r1, #76	; 0x4c
 8007930:	fb01 f303 	mul.w	r3, r1, r3
 8007934:	4413      	add	r3, r2
 8007936:	f503 63e6 	add.w	r3, r3, #1840	; 0x730
 800793a:	681b      	ldr	r3, [r3, #0]
 800793c:	62fb      	str	r3, [r7, #44]	; 0x2c

    /* Setup the buffer pointer.  */
    buffer =  packet_ptr -> nx_packet_prepend_ptr;
 800793e:	6a3b      	ldr	r3, [r7, #32]
 8007940:	689b      	ldr	r3, [r3, #8]
 8007942:	62bb      	str	r3, [r7, #40]	; 0x28

    /* Clear the buffer out... just in case.  */
    memset((void *) buffer, 0, NX_BOOTP_OFFSET_END);
 8007944:	f44f 7296 	mov.w	r2, #300	; 0x12c
 8007948:	2100      	movs	r1, #0
 800794a:	6ab8      	ldr	r0, [r7, #40]	; 0x28
 800794c:	f017 ff96 	bl	801f87c <memset>
    
    /* Setup the standard BootP fields.  */
    buffer[NX_BOOTP_OFFSET_OP] =        NX_BOOTP_OP_REQUEST;
 8007950:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8007952:	2201      	movs	r2, #1
 8007954:	701a      	strb	r2, [r3, #0]
    buffer[NX_BOOTP_OFFSET_HTYPE] =     NX_BOOTP_TYPE_ETHERNET;     
 8007956:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8007958:	3301      	adds	r3, #1
 800795a:	2201      	movs	r2, #1
 800795c:	701a      	strb	r2, [r3, #0]
    buffer[NX_BOOTP_OFFSET_HLEN] =      NX_BOOTP_HLEN_ETHERNET;
 800795e:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8007960:	3302      	adds	r3, #2
 8007962:	2206      	movs	r2, #6
 8007964:	701a      	strb	r2, [r3, #0]
    buffer[NX_BOOTP_OFFSET_HOPS] =      0;
 8007966:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8007968:	3303      	adds	r3, #3
 800796a:	2200      	movs	r2, #0
 800796c:	701a      	strb	r2, [r3, #0]
    buffer[NX_BOOTP_OFFSET_SERVER_NM] = 0;  
 800796e:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8007970:	332c      	adds	r3, #44	; 0x2c
 8007972:	2200      	movs	r2, #0
 8007974:	701a      	strb	r2, [r3, #0]
    buffer[NX_BOOTP_OFFSET_BOOT_FILE] = 0;  
 8007976:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8007978:	336c      	adds	r3, #108	; 0x6c
 800797a:	2200      	movs	r2, #0
 800797c:	701a      	strb	r2, [r3, #0]

    /* Setup the 'Xid' field.  */
    _nx_dhcp_store_data(buffer + NX_BOOTP_OFFSET_XID, 4, interface_record -> nx_dhcp_xid);
 800797e:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8007980:	1d18      	adds	r0, r3, #4
 8007982:	68bb      	ldr	r3, [r7, #8]
 8007984:	685b      	ldr	r3, [r3, #4]
 8007986:	461a      	mov	r2, r3
 8007988:	2104      	movs	r1, #4
 800798a:	f000 fe63 	bl	8008654 <_nx_dhcp_store_data>

    /* Set the 'secs' field according to RFC2131, Secion4.4.1, Page37, Table5. */ 
    if ((dhcp_message_type == NX_DHCP_TYPE_DHCPDECLINE) || (dhcp_message_type == NX_DHCP_TYPE_DHCPRELEASE))
 800798e:	687b      	ldr	r3, [r7, #4]
 8007990:	2b04      	cmp	r3, #4
 8007992:	d002      	beq.n	800799a <_nx_dhcp_send_request_internal+0xca>
 8007994:	687b      	ldr	r3, [r7, #4]
 8007996:	2b07      	cmp	r3, #7
 8007998:	d107      	bne.n	80079aa <_nx_dhcp_send_request_internal+0xda>
    {
        _nx_dhcp_store_data(buffer + NX_BOOTP_OFFSET_SECS, 2, 0);
 800799a:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800799c:	3308      	adds	r3, #8
 800799e:	2200      	movs	r2, #0
 80079a0:	2102      	movs	r1, #2
 80079a2:	4618      	mov	r0, r3
 80079a4:	f000 fe56 	bl	8008654 <_nx_dhcp_store_data>
 80079a8:	e008      	b.n	80079bc <_nx_dhcp_send_request_internal+0xec>
    }
    else
    {
        _nx_dhcp_store_data(buffer + NX_BOOTP_OFFSET_SECS, 2, interface_record -> nx_dhcp_seconds);
 80079aa:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80079ac:	f103 0008 	add.w	r0, r3, #8
 80079b0:	68bb      	ldr	r3, [r7, #8]
 80079b2:	689b      	ldr	r3, [r3, #8]
 80079b4:	461a      	mov	r2, r3
 80079b6:	2102      	movs	r1, #2
 80079b8:	f000 fe4c 	bl	8008654 <_nx_dhcp_store_data>
    }

    /* Set the broadcast flag according to RFC2131, Secion4.4.1, Page38, Table5.  */

    /* Set the broadcast flag to 0 for DHCP Decline and DHCP Release.  */
    if ((dhcp_message_type == NX_DHCP_TYPE_DHCPDECLINE) || (dhcp_message_type == NX_DHCP_TYPE_DHCPRELEASE))
 80079bc:	687b      	ldr	r3, [r7, #4]
 80079be:	2b04      	cmp	r3, #4
 80079c0:	d002      	beq.n	80079c8 <_nx_dhcp_send_request_internal+0xf8>
 80079c2:	687b      	ldr	r3, [r7, #4]
 80079c4:	2b07      	cmp	r3, #7
 80079c6:	d107      	bne.n	80079d8 <_nx_dhcp_send_request_internal+0x108>
    {

        /* Request the response be sent unicast.  */
        _nx_dhcp_store_data(buffer + NX_BOOTP_OFFSET_FLAGS, 1, NX_BOOTP_FLAGS_UNICAST);
 80079c8:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80079ca:	330a      	adds	r3, #10
 80079cc:	2200      	movs	r2, #0
 80079ce:	2101      	movs	r1, #1
 80079d0:	4618      	mov	r0, r3
 80079d2:	f000 fe3f 	bl	8008654 <_nx_dhcp_store_data>
 80079d6:	e012      	b.n	80079fe <_nx_dhcp_send_request_internal+0x12e>
    }

    /* Set the 'broadcast' flag according to user requirement for DHCP Discover, DHCP Request and DHCP Inform.  */
    else if (interface_record -> nx_dhcp_clear_broadcast == NX_TRUE)
 80079d8:	68bb      	ldr	r3, [r7, #8]
 80079da:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 80079dc:	2b01      	cmp	r3, #1
 80079de:	d107      	bne.n	80079f0 <_nx_dhcp_send_request_internal+0x120>
    {

        /* Request the response be sent unicast.  */
        _nx_dhcp_store_data(buffer + NX_BOOTP_OFFSET_FLAGS, 1, NX_BOOTP_FLAGS_UNICAST);
 80079e0:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80079e2:	330a      	adds	r3, #10
 80079e4:	2200      	movs	r2, #0
 80079e6:	2101      	movs	r1, #1
 80079e8:	4618      	mov	r0, r3
 80079ea:	f000 fe33 	bl	8008654 <_nx_dhcp_store_data>
 80079ee:	e006      	b.n	80079fe <_nx_dhcp_send_request_internal+0x12e>
    }
    else
    {

        /* Request the response be sent broadcast.  */
        _nx_dhcp_store_data(buffer + NX_BOOTP_OFFSET_FLAGS, 1, NX_BOOTP_FLAGS_BROADCAST);
 80079f0:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80079f2:	330a      	adds	r3, #10
 80079f4:	2280      	movs	r2, #128	; 0x80
 80079f6:	2101      	movs	r1, #1
 80079f8:	4618      	mov	r0, r3
 80079fa:	f000 fe2b 	bl	8008654 <_nx_dhcp_store_data>
    }

    /* RFC 2131 4.4.1: Do not set the Client IP ("ciaddr" field) address...*/
    if (dhcp_message_type != NX_DHCP_TYPE_DHCPINFORM)
 80079fe:	687b      	ldr	r3, [r7, #4]
 8007a00:	2b08      	cmp	r3, #8
 8007a02:	d007      	beq.n	8007a14 <_nx_dhcp_send_request_internal+0x144>
    {
        _nx_dhcp_store_data(buffer + NX_BOOTP_OFFSET_CLIENT_IP, 4, NX_BOOTP_NO_ADDRESS);
 8007a04:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8007a06:	330c      	adds	r3, #12
 8007a08:	2200      	movs	r2, #0
 8007a0a:	2104      	movs	r1, #4
 8007a0c:	4618      	mov	r0, r3
 8007a0e:	f000 fe21 	bl	8008654 <_nx_dhcp_store_data>
 8007a12:	e008      	b.n	8007a26 <_nx_dhcp_send_request_internal+0x156>
    }
    /* ...unless this is an INFORM REQUEST message. */
    else
    {
        _nx_dhcp_store_data(buffer + NX_BOOTP_OFFSET_CLIENT_IP, 4, interface_record -> nx_dhcp_ip_address);
 8007a14:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8007a16:	f103 000c 	add.w	r0, r3, #12
 8007a1a:	68bb      	ldr	r3, [r7, #8]
 8007a1c:	68db      	ldr	r3, [r3, #12]
 8007a1e:	461a      	mov	r2, r3
 8007a20:	2104      	movs	r1, #4
 8007a22:	f000 fe17 	bl	8008654 <_nx_dhcp_store_data>
    }

    _nx_dhcp_store_data(buffer + NX_BOOTP_OFFSET_YOUR_IP, 4, NX_BOOTP_NO_ADDRESS);   
 8007a26:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8007a28:	3310      	adds	r3, #16
 8007a2a:	2200      	movs	r2, #0
 8007a2c:	2104      	movs	r1, #4
 8007a2e:	4618      	mov	r0, r3
 8007a30:	f000 fe10 	bl	8008654 <_nx_dhcp_store_data>
    _nx_dhcp_store_data(buffer + NX_BOOTP_OFFSET_SERVER_IP, 4, NX_BOOTP_NO_ADDRESS); 
 8007a34:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8007a36:	3314      	adds	r3, #20
 8007a38:	2200      	movs	r2, #0
 8007a3a:	2104      	movs	r1, #4
 8007a3c:	4618      	mov	r0, r3
 8007a3e:	f000 fe09 	bl	8008654 <_nx_dhcp_store_data>
    _nx_dhcp_store_data(buffer + NX_BOOTP_OFFSET_GATEWAY_IP, 4, NX_BOOTP_NO_ADDRESS);
 8007a42:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8007a44:	3318      	adds	r3, #24
 8007a46:	2200      	movs	r2, #0
 8007a48:	2104      	movs	r1, #4
 8007a4a:	4618      	mov	r0, r3
 8007a4c:	f000 fe02 	bl	8008654 <_nx_dhcp_store_data>
    _nx_dhcp_store_data(buffer + NX_BOOTP_OFFSET_CLIENT_HW, 2, dhcp_client_mac_msw);
 8007a50:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8007a52:	331c      	adds	r3, #28
 8007a54:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 8007a56:	2102      	movs	r1, #2
 8007a58:	4618      	mov	r0, r3
 8007a5a:	f000 fdfb 	bl	8008654 <_nx_dhcp_store_data>
    _nx_dhcp_store_data(buffer + NX_BOOTP_OFFSET_CLIENT_HW + 2, 4, dhcp_client_mac_lsw);
 8007a5e:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8007a60:	331e      	adds	r3, #30
 8007a62:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 8007a64:	2104      	movs	r1, #4
 8007a66:	4618      	mov	r0, r3
 8007a68:	f000 fdf4 	bl	8008654 <_nx_dhcp_store_data>

#ifndef NX_DHCP_ENABLE_BOOTP        
    /* Update the index.  */
    index = NX_BOOTP_OFFSET_OPTIONS; 
 8007a6c:	23f0      	movs	r3, #240	; 0xf0
 8007a6e:	61fb      	str	r3, [r7, #28]

    /*  A BOOTP Client should not request DHCP option data. */
    _nx_dhcp_store_data(buffer + NX_BOOTP_OFFSET_VENDOR, 4, NX_BOOTP_MAGIC_COOKIE);
 8007a70:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8007a72:	33ec      	adds	r3, #236	; 0xec
 8007a74:	4aa7      	ldr	r2, [pc, #668]	; (8007d14 <_nx_dhcp_send_request_internal+0x444>)
 8007a76:	2104      	movs	r1, #4
 8007a78:	4618      	mov	r0, r3
 8007a7a:	f000 fdeb 	bl	8008654 <_nx_dhcp_store_data>

    /* Add the actual DHCP request.  */
    _nx_dhcp_add_option_value(buffer, NX_DHCP_OPTION_DHCP_TYPE, NX_DHCP_OPTION_DHCP_TYPE_SIZE, dhcp_message_type, &index);
 8007a7e:	f107 031c 	add.w	r3, r7, #28
 8007a82:	9300      	str	r3, [sp, #0]
 8007a84:	687b      	ldr	r3, [r7, #4]
 8007a86:	2201      	movs	r2, #1
 8007a88:	2135      	movs	r1, #53	; 0x35
 8007a8a:	6ab8      	ldr	r0, [r7, #40]	; 0x28
 8007a8c:	f000 fcb4 	bl	80083f8 <_nx_dhcp_add_option_value>
#endif

    /* Determine if any additional options need to be added relative to the DHCP message type.
       RFC 2131, Table 5: Fields and options used by DHCP Clients.  */
    switch (dhcp_message_type)
 8007a90:	687b      	ldr	r3, [r7, #4]
 8007a92:	3b01      	subs	r3, #1
 8007a94:	2b07      	cmp	r3, #7
 8007a96:	f200 815f 	bhi.w	8007d58 <_nx_dhcp_send_request_internal+0x488>
 8007a9a:	a201      	add	r2, pc, #4	; (adr r2, 8007aa0 <_nx_dhcp_send_request_internal+0x1d0>)
 8007a9c:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8007aa0:	08007ac1 	.word	0x08007ac1
 8007aa4:	08007d59 	.word	0x08007d59
 8007aa8:	08007b5f 	.word	0x08007b5f
 8007aac:	08007c71 	.word	0x08007c71
 8007ab0:	08007d59 	.word	0x08007d59
 8007ab4:	08007d59 	.word	0x08007d59
 8007ab8:	08007cb1 	.word	0x08007cb1
 8007abc:	08007ce9 	.word	0x08007ce9

        case NX_DHCP_TYPE_DHCPDISCOVER:


            /* Determine if we have a valid IP address.  */
            if ((interface_record -> nx_dhcp_ip_address != NX_BOOTP_NO_ADDRESS) && 
 8007ac0:	68bb      	ldr	r3, [r7, #8]
 8007ac2:	68db      	ldr	r3, [r3, #12]
 8007ac4:	2b00      	cmp	r3, #0
 8007ac6:	d00f      	beq.n	8007ae8 <_nx_dhcp_send_request_internal+0x218>
                (interface_record -> nx_dhcp_ip_address != NX_BOOTP_BC_ADDRESS))
 8007ac8:	68bb      	ldr	r3, [r7, #8]
 8007aca:	68db      	ldr	r3, [r3, #12]
            if ((interface_record -> nx_dhcp_ip_address != NX_BOOTP_NO_ADDRESS) && 
 8007acc:	f1b3 3fff 	cmp.w	r3, #4294967295
 8007ad0:	d00a      	beq.n	8007ae8 <_nx_dhcp_send_request_internal+0x218>
            {

                /* Add a IP request option if we have a valid IP address */
                _nx_dhcp_add_option_value(buffer, NX_DHCP_OPTION_DHCP_IP_REQ, NX_DHCP_OPTION_DHCP_IP_REQ_SIZE, 
 8007ad2:	68bb      	ldr	r3, [r7, #8]
 8007ad4:	68da      	ldr	r2, [r3, #12]
 8007ad6:	f107 031c 	add.w	r3, r7, #28
 8007ada:	9300      	str	r3, [sp, #0]
 8007adc:	4613      	mov	r3, r2
 8007ade:	2204      	movs	r2, #4
 8007ae0:	2132      	movs	r1, #50	; 0x32
 8007ae2:	6ab8      	ldr	r0, [r7, #40]	; 0x28
 8007ae4:	f000 fc88 	bl	80083f8 <_nx_dhcp_add_option_value>
                                          interface_record -> nx_dhcp_ip_address, &index);
            }

            /* Add an option request for an infinite lease.  */
            _nx_dhcp_add_option_value(buffer, NX_DHCP_OPTION_DHCP_LEASE, NX_DHCP_OPTION_DHCP_LEASE_SIZE, NX_DHCP_INFINITE_LEASE, &index);
 8007ae8:	f107 031c 	add.w	r3, r7, #28
 8007aec:	9300      	str	r3, [sp, #0]
 8007aee:	f04f 33ff 	mov.w	r3, #4294967295
 8007af2:	2204      	movs	r2, #4
 8007af4:	2133      	movs	r1, #51	; 0x33
 8007af6:	6ab8      	ldr	r0, [r7, #40]	; 0x28
 8007af8:	f000 fc7e 	bl	80083f8 <_nx_dhcp_add_option_value>

            /* Add the system name */
            if (dhcp_ptr -> nx_dhcp_name)
 8007afc:	68fb      	ldr	r3, [r7, #12]
 8007afe:	685b      	ldr	r3, [r3, #4]
 8007b00:	2b00      	cmp	r3, #0
 8007b02:	d01b      	beq.n	8007b3c <_nx_dhcp_send_request_internal+0x26c>
            {

                /* Check name length.  */
                if (_nx_utility_string_length_check(dhcp_ptr -> nx_dhcp_name, &name_length, 255))
 8007b04:	68fb      	ldr	r3, [r7, #12]
 8007b06:	685b      	ldr	r3, [r3, #4]
 8007b08:	f107 0114 	add.w	r1, r7, #20
 8007b0c:	22ff      	movs	r2, #255	; 0xff
 8007b0e:	4618      	mov	r0, r3
 8007b10:	f009 f97e 	bl	8010e10 <_nx_utility_string_length_check>
 8007b14:	4603      	mov	r3, r0
 8007b16:	2b00      	cmp	r3, #0
 8007b18:	d005      	beq.n	8007b26 <_nx_dhcp_send_request_internal+0x256>
                {
                    nx_packet_release(packet_ptr);
 8007b1a:	6a3b      	ldr	r3, [r7, #32]
 8007b1c:	4618      	mov	r0, r3
 8007b1e:	f004 fc73 	bl	800c408 <_nx_packet_release>
                    return(NX_DHCP_INVALID_NAME);
 8007b22:	23a8      	movs	r3, #168	; 0xa8
 8007b24:	e19a      	b.n	8007e5c <_nx_dhcp_send_request_internal+0x58c>
                }

                _nx_dhcp_add_option_string(buffer, NX_DHCP_OPTION_HOST_NAME, name_length, 
 8007b26:	697a      	ldr	r2, [r7, #20]
                                           (UCHAR *) dhcp_ptr -> nx_dhcp_name, &index);
 8007b28:	68fb      	ldr	r3, [r7, #12]
 8007b2a:	6859      	ldr	r1, [r3, #4]
                _nx_dhcp_add_option_string(buffer, NX_DHCP_OPTION_HOST_NAME, name_length, 
 8007b2c:	f107 031c 	add.w	r3, r7, #28
 8007b30:	9300      	str	r3, [sp, #0]
 8007b32:	460b      	mov	r3, r1
 8007b34:	210c      	movs	r1, #12
 8007b36:	6ab8      	ldr	r0, [r7, #40]	; 0x28
 8007b38:	f000 fc91 	bl	800845e <_nx_dhcp_add_option_string>
            }

            /* Add an option request for DHCP parameters (gateway, subnet mask, etc.).  */
            _nx_dhcp_add_option_string(buffer, NX_DHCP_OPTION_DHCP_PARAMETERS, NX_DHCP_REQUEST_PARAMETER_SIZE, _nx_dhcp_request_parameters, &index);
 8007b3c:	f107 031c 	add.w	r3, r7, #28
 8007b40:	9300      	str	r3, [sp, #0]
 8007b42:	4b75      	ldr	r3, [pc, #468]	; (8007d18 <_nx_dhcp_send_request_internal+0x448>)
 8007b44:	2203      	movs	r2, #3
 8007b46:	2137      	movs	r1, #55	; 0x37
 8007b48:	6ab8      	ldr	r0, [r7, #40]	; 0x28
 8007b4a:	f000 fc88 	bl	800845e <_nx_dhcp_add_option_string>
               RFC2132, Section9.10, Page28.  */    
            _nx_dhcp_add_option_value(buffer, NX_DHCP_OPTION_MAX_DHCP_MESSAGE, 2, dhcp_ptr -> nx_dhcp_max_dhcp_message_size, &index);
#endif

            /* Increment the number of Discovery messages sent.  */
            interface_record -> nx_dhcp_discoveries_sent++;
 8007b4e:	68bb      	ldr	r3, [r7, #8]
 8007b50:	f8d3 3188 	ldr.w	r3, [r3, #392]	; 0x188
 8007b54:	1c5a      	adds	r2, r3, #1
 8007b56:	68bb      	ldr	r3, [r7, #8]
 8007b58:	f8c3 2188 	str.w	r2, [r3, #392]	; 0x188
            break;
 8007b5c:	e0fd      	b.n	8007d5a <_nx_dhcp_send_request_internal+0x48a>
      
        case NX_DHCP_TYPE_DHCPREQUEST:

            /* Add the system name */
            if (dhcp_ptr -> nx_dhcp_name)
 8007b5e:	68fb      	ldr	r3, [r7, #12]
 8007b60:	685b      	ldr	r3, [r3, #4]
 8007b62:	2b00      	cmp	r3, #0
 8007b64:	d01b      	beq.n	8007b9e <_nx_dhcp_send_request_internal+0x2ce>
            {

                /* Check name length.  */
                if (_nx_utility_string_length_check(dhcp_ptr -> nx_dhcp_name, &name_length, 255))
 8007b66:	68fb      	ldr	r3, [r7, #12]
 8007b68:	685b      	ldr	r3, [r3, #4]
 8007b6a:	f107 0114 	add.w	r1, r7, #20
 8007b6e:	22ff      	movs	r2, #255	; 0xff
 8007b70:	4618      	mov	r0, r3
 8007b72:	f009 f94d 	bl	8010e10 <_nx_utility_string_length_check>
 8007b76:	4603      	mov	r3, r0
 8007b78:	2b00      	cmp	r3, #0
 8007b7a:	d005      	beq.n	8007b88 <_nx_dhcp_send_request_internal+0x2b8>
                {
                    nx_packet_release(packet_ptr);
 8007b7c:	6a3b      	ldr	r3, [r7, #32]
 8007b7e:	4618      	mov	r0, r3
 8007b80:	f004 fc42 	bl	800c408 <_nx_packet_release>
                    return(NX_DHCP_INVALID_NAME);
 8007b84:	23a8      	movs	r3, #168	; 0xa8
 8007b86:	e169      	b.n	8007e5c <_nx_dhcp_send_request_internal+0x58c>
                }

                _nx_dhcp_add_option_string(buffer, NX_DHCP_OPTION_HOST_NAME, name_length, (UCHAR *) dhcp_ptr -> nx_dhcp_name, &index);
 8007b88:	697a      	ldr	r2, [r7, #20]
 8007b8a:	68fb      	ldr	r3, [r7, #12]
 8007b8c:	6859      	ldr	r1, [r3, #4]
 8007b8e:	f107 031c 	add.w	r3, r7, #28
 8007b92:	9300      	str	r3, [sp, #0]
 8007b94:	460b      	mov	r3, r1
 8007b96:	210c      	movs	r1, #12
 8007b98:	6ab8      	ldr	r0, [r7, #40]	; 0x28
 8007b9a:	f000 fc60 	bl	800845e <_nx_dhcp_add_option_string>
            }

            /* Determine if we have a valid IP address. Must not include if Renewing or Rebinding RCV 2131 4.3.2.  */
            if ((interface_record -> nx_dhcp_ip_address != NX_BOOTP_NO_ADDRESS) && 
 8007b9e:	68bb      	ldr	r3, [r7, #8]
 8007ba0:	68db      	ldr	r3, [r3, #12]
 8007ba2:	2b00      	cmp	r3, #0
 8007ba4:	d017      	beq.n	8007bd6 <_nx_dhcp_send_request_internal+0x306>
                (interface_record -> nx_dhcp_ip_address != NX_BOOTP_BC_ADDRESS) &&
 8007ba6:	68bb      	ldr	r3, [r7, #8]
 8007ba8:	68db      	ldr	r3, [r3, #12]
            if ((interface_record -> nx_dhcp_ip_address != NX_BOOTP_NO_ADDRESS) && 
 8007baa:	f1b3 3fff 	cmp.w	r3, #4294967295
 8007bae:	d012      	beq.n	8007bd6 <_nx_dhcp_send_request_internal+0x306>
                (interface_record -> nx_dhcp_state != NX_DHCP_STATE_RENEWING) && 
 8007bb0:	68bb      	ldr	r3, [r7, #8]
 8007bb2:	785b      	ldrb	r3, [r3, #1]
                (interface_record -> nx_dhcp_ip_address != NX_BOOTP_BC_ADDRESS) &&
 8007bb4:	2b06      	cmp	r3, #6
 8007bb6:	d00e      	beq.n	8007bd6 <_nx_dhcp_send_request_internal+0x306>
                (interface_record -> nx_dhcp_state != NX_DHCP_STATE_REBINDING))
 8007bb8:	68bb      	ldr	r3, [r7, #8]
 8007bba:	785b      	ldrb	r3, [r3, #1]
                (interface_record -> nx_dhcp_state != NX_DHCP_STATE_RENEWING) && 
 8007bbc:	2b07      	cmp	r3, #7
 8007bbe:	d00a      	beq.n	8007bd6 <_nx_dhcp_send_request_internal+0x306>
            {

                /* Add an IP request option if we have a valid IP address.  */
                _nx_dhcp_add_option_value(buffer, NX_DHCP_OPTION_DHCP_IP_REQ, NX_DHCP_OPTION_DHCP_IP_REQ_SIZE, 
 8007bc0:	68bb      	ldr	r3, [r7, #8]
 8007bc2:	68da      	ldr	r2, [r3, #12]
 8007bc4:	f107 031c 	add.w	r3, r7, #28
 8007bc8:	9300      	str	r3, [sp, #0]
 8007bca:	4613      	mov	r3, r2
 8007bcc:	2204      	movs	r2, #4
 8007bce:	2132      	movs	r1, #50	; 0x32
 8007bd0:	6ab8      	ldr	r0, [r7, #40]	; 0x28
 8007bd2:	f000 fc11 	bl	80083f8 <_nx_dhcp_add_option_value>
                                          interface_record -> nx_dhcp_ip_address, &index);
            }

            /* Add a request for an infinite lease if we haven't already set the timers.  */
            if ((interface_record -> nx_dhcp_rebind_time == 0) || 
 8007bd6:	68bb      	ldr	r3, [r7, #8]
 8007bd8:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8007bda:	2b00      	cmp	r3, #0
 8007bdc:	d003      	beq.n	8007be6 <_nx_dhcp_send_request_internal+0x316>
                (interface_record -> nx_dhcp_renewal_time == 0))
 8007bde:	68bb      	ldr	r3, [r7, #8]
 8007be0:	6b1b      	ldr	r3, [r3, #48]	; 0x30
            if ((interface_record -> nx_dhcp_rebind_time == 0) || 
 8007be2:	2b00      	cmp	r3, #0
 8007be4:	d109      	bne.n	8007bfa <_nx_dhcp_send_request_internal+0x32a>
            {

                /* Add the infinite lease option.  */
                _nx_dhcp_add_option_value(buffer, NX_DHCP_OPTION_DHCP_LEASE, NX_DHCP_OPTION_DHCP_LEASE_SIZE, NX_DHCP_INFINITE_LEASE, &index);
 8007be6:	f107 031c 	add.w	r3, r7, #28
 8007bea:	9300      	str	r3, [sp, #0]
 8007bec:	f04f 33ff 	mov.w	r3, #4294967295
 8007bf0:	2204      	movs	r2, #4
 8007bf2:	2133      	movs	r1, #51	; 0x33
 8007bf4:	6ab8      	ldr	r0, [r7, #40]	; 0x28
 8007bf6:	f000 fbff 	bl	80083f8 <_nx_dhcp_add_option_value>
            }

            /* Should add server ID if not renewing.  */
            if ((interface_record -> nx_dhcp_state != NX_DHCP_STATE_RENEWING) &&
 8007bfa:	68bb      	ldr	r3, [r7, #8]
 8007bfc:	785b      	ldrb	r3, [r3, #1]
 8007bfe:	2b06      	cmp	r3, #6
 8007c00:	d014      	beq.n	8007c2c <_nx_dhcp_send_request_internal+0x35c>
                (interface_record -> nx_dhcp_state != NX_DHCP_STATE_REBINDING) && 
 8007c02:	68bb      	ldr	r3, [r7, #8]
 8007c04:	785b      	ldrb	r3, [r3, #1]
            if ((interface_record -> nx_dhcp_state != NX_DHCP_STATE_RENEWING) &&
 8007c06:	2b07      	cmp	r3, #7
 8007c08:	d010      	beq.n	8007c2c <_nx_dhcp_send_request_internal+0x35c>
                (interface_record -> nx_dhcp_server_ip != NX_BOOTP_BC_ADDRESS)
 8007c0a:	68bb      	ldr	r3, [r7, #8]
 8007c0c:	695b      	ldr	r3, [r3, #20]
                (interface_record -> nx_dhcp_state != NX_DHCP_STATE_REBINDING) && 
 8007c0e:	f1b3 3fff 	cmp.w	r3, #4294967295
 8007c12:	d00b      	beq.n	8007c2c <_nx_dhcp_send_request_internal+0x35c>
               )
            {

                /* Add Server identifier option.  */
                _nx_dhcp_add_option_value(buffer, NX_DHCP_OPTION_DHCP_SERVER, NX_DHCP_OPTION_DHCP_SERVER_SIZE, 
 8007c14:	68bb      	ldr	r3, [r7, #8]
 8007c16:	695a      	ldr	r2, [r3, #20]
 8007c18:	f107 031c 	add.w	r3, r7, #28
 8007c1c:	9300      	str	r3, [sp, #0]
 8007c1e:	4613      	mov	r3, r2
 8007c20:	2204      	movs	r2, #4
 8007c22:	2136      	movs	r1, #54	; 0x36
 8007c24:	6ab8      	ldr	r0, [r7, #40]	; 0x28
 8007c26:	f000 fbe7 	bl	80083f8 <_nx_dhcp_add_option_value>
 8007c2a:	e010      	b.n	8007c4e <_nx_dhcp_send_request_internal+0x37e>
                                          interface_record -> nx_dhcp_server_ip, &index);
            }
            else if ((interface_record -> nx_dhcp_state == NX_DHCP_STATE_RENEWING) || 
 8007c2c:	68bb      	ldr	r3, [r7, #8]
 8007c2e:	785b      	ldrb	r3, [r3, #1]
 8007c30:	2b06      	cmp	r3, #6
 8007c32:	d003      	beq.n	8007c3c <_nx_dhcp_send_request_internal+0x36c>
                     (interface_record -> nx_dhcp_state == NX_DHCP_STATE_REBINDING))
 8007c34:	68bb      	ldr	r3, [r7, #8]
 8007c36:	785b      	ldrb	r3, [r3, #1]
            else if ((interface_record -> nx_dhcp_state == NX_DHCP_STATE_RENEWING) || 
 8007c38:	2b07      	cmp	r3, #7
 8007c3a:	d108      	bne.n	8007c4e <_nx_dhcp_send_request_internal+0x37e>

            {

                /* Ensure the renewal message fields are correct.  */
                _nx_dhcp_store_data(buffer + NX_BOOTP_OFFSET_CLIENT_IP, 4, interface_record -> nx_dhcp_ip_address);
 8007c3c:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8007c3e:	f103 000c 	add.w	r0, r3, #12
 8007c42:	68bb      	ldr	r3, [r7, #8]
 8007c44:	68db      	ldr	r3, [r3, #12]
 8007c46:	461a      	mov	r2, r3
 8007c48:	2104      	movs	r1, #4
 8007c4a:	f000 fd03 	bl	8008654 <_nx_dhcp_store_data>
            }

            /* Add the request for the DHCP parameters (gateway, subnet mask, etc.) if not renewing.  */
            _nx_dhcp_add_option_string(buffer, NX_DHCP_OPTION_DHCP_PARAMETERS, NX_DHCP_REQUEST_PARAMETER_SIZE, _nx_dhcp_request_parameters, &index);
 8007c4e:	f107 031c 	add.w	r3, r7, #28
 8007c52:	9300      	str	r3, [sp, #0]
 8007c54:	4b30      	ldr	r3, [pc, #192]	; (8007d18 <_nx_dhcp_send_request_internal+0x448>)
 8007c56:	2203      	movs	r2, #3
 8007c58:	2137      	movs	r1, #55	; 0x37
 8007c5a:	6ab8      	ldr	r0, [r7, #40]	; 0x28
 8007c5c:	f000 fbff 	bl	800845e <_nx_dhcp_add_option_string>
               RFC2132, Section9.10, Page28.  */    
            _nx_dhcp_add_option_value(buffer, NX_DHCP_OPTION_MAX_DHCP_MESSAGE, 2, dhcp_ptr -> nx_dhcp_max_dhcp_message_size, &index);
#endif

            /* Increment the number of Request messages sent.  */
            interface_record -> nx_dhcp_requests_sent++;
 8007c60:	68bb      	ldr	r3, [r7, #8]
 8007c62:	f8d3 3190 	ldr.w	r3, [r3, #400]	; 0x190
 8007c66:	1c5a      	adds	r2, r3, #1
 8007c68:	68bb      	ldr	r3, [r7, #8]
 8007c6a:	f8c3 2190 	str.w	r2, [r3, #400]	; 0x190
            break;
 8007c6e:	e074      	b.n	8007d5a <_nx_dhcp_send_request_internal+0x48a>

        case NX_DHCP_TYPE_DHCPDECLINE:      

            /* Does the Client have a nonzero requested address it is declining? */
            if ((interface_record -> nx_dhcp_ip_address != NX_BOOTP_NO_ADDRESS) && 
 8007c70:	68bb      	ldr	r3, [r7, #8]
 8007c72:	68db      	ldr	r3, [r3, #12]
 8007c74:	2b00      	cmp	r3, #0
 8007c76:	d00f      	beq.n	8007c98 <_nx_dhcp_send_request_internal+0x3c8>
                (interface_record -> nx_dhcp_ip_address != NX_BOOTP_BC_ADDRESS))
 8007c78:	68bb      	ldr	r3, [r7, #8]
 8007c7a:	68db      	ldr	r3, [r3, #12]
            if ((interface_record -> nx_dhcp_ip_address != NX_BOOTP_NO_ADDRESS) && 
 8007c7c:	f1b3 3fff 	cmp.w	r3, #4294967295
 8007c80:	d00a      	beq.n	8007c98 <_nx_dhcp_send_request_internal+0x3c8>
            {

                /* Yes; add Request IP address option.  */
                _nx_dhcp_add_option_value(buffer, NX_DHCP_OPTION_DHCP_IP_REQ, NX_DHCP_OPTION_DHCP_IP_REQ_SIZE, 
 8007c82:	68bb      	ldr	r3, [r7, #8]
 8007c84:	68da      	ldr	r2, [r3, #12]
 8007c86:	f107 031c 	add.w	r3, r7, #28
 8007c8a:	9300      	str	r3, [sp, #0]
 8007c8c:	4613      	mov	r3, r2
 8007c8e:	2204      	movs	r2, #4
 8007c90:	2132      	movs	r1, #50	; 0x32
 8007c92:	6ab8      	ldr	r0, [r7, #40]	; 0x28
 8007c94:	f000 fbb0 	bl	80083f8 <_nx_dhcp_add_option_value>
                                          interface_record -> nx_dhcp_ip_address, &index);
            }     

            /* Add Server identifier option.  */
            _nx_dhcp_add_option_value(buffer, NX_DHCP_OPTION_DHCP_SERVER, NX_DHCP_OPTION_DHCP_SERVER_SIZE, 
 8007c98:	68bb      	ldr	r3, [r7, #8]
 8007c9a:	695a      	ldr	r2, [r3, #20]
 8007c9c:	f107 031c 	add.w	r3, r7, #28
 8007ca0:	9300      	str	r3, [sp, #0]
 8007ca2:	4613      	mov	r3, r2
 8007ca4:	2204      	movs	r2, #4
 8007ca6:	2136      	movs	r1, #54	; 0x36
 8007ca8:	6ab8      	ldr	r0, [r7, #40]	; 0x28
 8007caa:	f000 fba5 	bl	80083f8 <_nx_dhcp_add_option_value>
                                      interface_record -> nx_dhcp_server_ip, &index);

            break;
 8007cae:	e054      	b.n	8007d5a <_nx_dhcp_send_request_internal+0x48a>

        case NX_DHCP_TYPE_DHCPRELEASE:       

            /* Added the 'ciaddr', Indicate the IP address being released.  */
            _nx_dhcp_store_data(buffer + NX_BOOTP_OFFSET_CLIENT_IP, 4, interface_record -> nx_dhcp_ip_address);
 8007cb0:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8007cb2:	f103 000c 	add.w	r0, r3, #12
 8007cb6:	68bb      	ldr	r3, [r7, #8]
 8007cb8:	68db      	ldr	r3, [r3, #12]
 8007cba:	461a      	mov	r2, r3
 8007cbc:	2104      	movs	r1, #4
 8007cbe:	f000 fcc9 	bl	8008654 <_nx_dhcp_store_data>
                                       
            /* Add Server identifier option.  */
            _nx_dhcp_add_option_value(buffer, NX_DHCP_OPTION_DHCP_SERVER, NX_DHCP_OPTION_DHCP_SERVER_SIZE, 
 8007cc2:	68bb      	ldr	r3, [r7, #8]
 8007cc4:	695a      	ldr	r2, [r3, #20]
 8007cc6:	f107 031c 	add.w	r3, r7, #28
 8007cca:	9300      	str	r3, [sp, #0]
 8007ccc:	4613      	mov	r3, r2
 8007cce:	2204      	movs	r2, #4
 8007cd0:	2136      	movs	r1, #54	; 0x36
 8007cd2:	6ab8      	ldr	r0, [r7, #40]	; 0x28
 8007cd4:	f000 fb90 	bl	80083f8 <_nx_dhcp_add_option_value>
                                      interface_record -> nx_dhcp_server_ip, &index);

            /* Increment the number of Release messages sent.  */
            interface_record -> nx_dhcp_releases_sent++;
 8007cd8:	68bb      	ldr	r3, [r7, #8]
 8007cda:	f8d3 319c 	ldr.w	r3, [r3, #412]	; 0x19c
 8007cde:	1c5a      	adds	r2, r3, #1
 8007ce0:	68bb      	ldr	r3, [r7, #8]
 8007ce2:	f8c3 219c 	str.w	r2, [r3, #412]	; 0x19c
            break;
 8007ce6:	e038      	b.n	8007d5a <_nx_dhcp_send_request_internal+0x48a>

        case NX_DHCP_TYPE_DHCPINFORM:

            /* Add the system name */
            if (dhcp_ptr -> nx_dhcp_name)
 8007ce8:	68fb      	ldr	r3, [r7, #12]
 8007cea:	685b      	ldr	r3, [r3, #4]
 8007cec:	2b00      	cmp	r3, #0
 8007cee:	d020      	beq.n	8007d32 <_nx_dhcp_send_request_internal+0x462>
            {

                /* Check name length.  */
                if (_nx_utility_string_length_check(dhcp_ptr -> nx_dhcp_name, &name_length, 255))
 8007cf0:	68fb      	ldr	r3, [r7, #12]
 8007cf2:	685b      	ldr	r3, [r3, #4]
 8007cf4:	f107 0114 	add.w	r1, r7, #20
 8007cf8:	22ff      	movs	r2, #255	; 0xff
 8007cfa:	4618      	mov	r0, r3
 8007cfc:	f009 f888 	bl	8010e10 <_nx_utility_string_length_check>
 8007d00:	4603      	mov	r3, r0
 8007d02:	2b00      	cmp	r3, #0
 8007d04:	d00a      	beq.n	8007d1c <_nx_dhcp_send_request_internal+0x44c>
                {
                    nx_packet_release(packet_ptr);
 8007d06:	6a3b      	ldr	r3, [r7, #32]
 8007d08:	4618      	mov	r0, r3
 8007d0a:	f004 fb7d 	bl	800c408 <_nx_packet_release>
                    return(NX_DHCP_INVALID_NAME);
 8007d0e:	23a8      	movs	r3, #168	; 0xa8
 8007d10:	e0a4      	b.n	8007e5c <_nx_dhcp_send_request_internal+0x58c>
 8007d12:	bf00      	nop
 8007d14:	63825363 	.word	0x63825363
 8007d18:	24000010 	.word	0x24000010
                }

                _nx_dhcp_add_option_string(buffer, NX_DHCP_OPTION_HOST_NAME, name_length, (UCHAR *) dhcp_ptr -> nx_dhcp_name, &index);
 8007d1c:	697a      	ldr	r2, [r7, #20]
 8007d1e:	68fb      	ldr	r3, [r7, #12]
 8007d20:	6859      	ldr	r1, [r3, #4]
 8007d22:	f107 031c 	add.w	r3, r7, #28
 8007d26:	9300      	str	r3, [sp, #0]
 8007d28:	460b      	mov	r3, r1
 8007d2a:	210c      	movs	r1, #12
 8007d2c:	6ab8      	ldr	r0, [r7, #40]	; 0x28
 8007d2e:	f000 fb96 	bl	800845e <_nx_dhcp_add_option_string>
            }

            /* Add an option request for DHCP parameters (gateway, subnet mask, etc.).  */
            _nx_dhcp_add_option_string(buffer, NX_DHCP_OPTION_DHCP_PARAMETERS, 1, &(interface_record -> nx_dhcp_user_option), &index);
 8007d32:	68bb      	ldr	r3, [r7, #8]
 8007d34:	1c9a      	adds	r2, r3, #2
 8007d36:	f107 031c 	add.w	r3, r7, #28
 8007d3a:	9300      	str	r3, [sp, #0]
 8007d3c:	4613      	mov	r3, r2
 8007d3e:	2201      	movs	r2, #1
 8007d40:	2137      	movs	r1, #55	; 0x37
 8007d42:	6ab8      	ldr	r0, [r7, #40]	; 0x28
 8007d44:	f000 fb8b 	bl	800845e <_nx_dhcp_add_option_string>

            /* Increment the number of Inform messages sent.  */
            interface_record -> nx_dhcp_informs_sent++;
 8007d48:	68bb      	ldr	r3, [r7, #8]
 8007d4a:	f8d3 31a8 	ldr.w	r3, [r3, #424]	; 0x1a8
 8007d4e:	1c5a      	adds	r2, r3, #1
 8007d50:	68bb      	ldr	r3, [r7, #8]
 8007d52:	f8c3 21a8 	str.w	r2, [r3, #424]	; 0x1a8

            break;
 8007d56:	e000      	b.n	8007d5a <_nx_dhcp_send_request_internal+0x48a>

        default:
            break;
 8007d58:	bf00      	nop
    }

    /* Add any user supplied options to the buffer.  */
    if (dhcp_ptr -> nx_dhcp_user_option_add)
 8007d5a:	68fb      	ldr	r3, [r7, #12]
 8007d5c:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
 8007d60:	f8d3 3f44 	ldr.w	r3, [r3, #3908]	; 0xf44
 8007d64:	2b00      	cmp	r3, #0
 8007d66:	d024      	beq.n	8007db2 <_nx_dhcp_send_request_internal+0x4e2>
    {

        /* Set the pointer for adding user option.  */
        user_option_ptr = buffer + index;
 8007d68:	69fb      	ldr	r3, [r7, #28]
 8007d6a:	6aba      	ldr	r2, [r7, #40]	; 0x28
 8007d6c:	4413      	add	r3, r2
 8007d6e:	627b      	str	r3, [r7, #36]	; 0x24

        /* Calculate the available length for user options. Minus 1 to add the END option.  */
        user_option_length = (UINT)(packet_ptr -> nx_packet_data_end - user_option_ptr - 1);
 8007d70:	6a3b      	ldr	r3, [r7, #32]
 8007d72:	695a      	ldr	r2, [r3, #20]
 8007d74:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8007d76:	1ad3      	subs	r3, r2, r3
 8007d78:	3b01      	subs	r3, #1
 8007d7a:	61bb      	str	r3, [r7, #24]

        /* Add the specific DHCP option user wanted.  */
        if (dhcp_ptr -> nx_dhcp_user_option_add(dhcp_ptr, iface_index, dhcp_message_type, user_option_ptr, &user_option_length) == NX_TRUE)
 8007d7c:	68fb      	ldr	r3, [r7, #12]
 8007d7e:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
 8007d82:	f8d3 4f44 	ldr.w	r4, [r3, #3908]	; 0xf44
 8007d86:	f107 0318 	add.w	r3, r7, #24
 8007d8a:	9300      	str	r3, [sp, #0]
 8007d8c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8007d8e:	687a      	ldr	r2, [r7, #4]
 8007d90:	6b79      	ldr	r1, [r7, #52]	; 0x34
 8007d92:	68f8      	ldr	r0, [r7, #12]
 8007d94:	47a0      	blx	r4
 8007d96:	4603      	mov	r3, r0
 8007d98:	2b01      	cmp	r3, #1
 8007d9a:	d104      	bne.n	8007da6 <_nx_dhcp_send_request_internal+0x4d6>
        {

            /* Update the index to include the user options.  */
            index += user_option_length;
 8007d9c:	69fa      	ldr	r2, [r7, #28]
 8007d9e:	69bb      	ldr	r3, [r7, #24]
 8007da0:	4413      	add	r3, r2
 8007da2:	61fb      	str	r3, [r7, #28]
 8007da4:	e005      	b.n	8007db2 <_nx_dhcp_send_request_internal+0x4e2>
        }
        else
        {

            /* Invalid user options. Release the packet.  */
            nx_packet_release(packet_ptr);
 8007da6:	6a3b      	ldr	r3, [r7, #32]
 8007da8:	4618      	mov	r0, r3
 8007daa:	f004 fb2d 	bl	800c408 <_nx_packet_release>
            return(NX_DHCP_UNKNOWN_OPTION);
 8007dae:	239f      	movs	r3, #159	; 0x9f
 8007db0:	e054      	b.n	8007e5c <_nx_dhcp_send_request_internal+0x58c>
        }
    }

    /* Setup the packet pointers.  */
    packet_ptr -> nx_packet_length =      NX_BOOTP_OFFSET_END;
 8007db2:	6a3b      	ldr	r3, [r7, #32]
 8007db4:	f44f 7296 	mov.w	r2, #300	; 0x12c
 8007db8:	625a      	str	r2, [r3, #36]	; 0x24
    packet_ptr -> nx_packet_append_ptr =  packet_ptr -> nx_packet_prepend_ptr + NX_BOOTP_OFFSET_END;
 8007dba:	6a3b      	ldr	r3, [r7, #32]
 8007dbc:	689a      	ldr	r2, [r3, #8]
 8007dbe:	6a3b      	ldr	r3, [r7, #32]
 8007dc0:	f502 7296 	add.w	r2, r2, #300	; 0x12c
 8007dc4:	60da      	str	r2, [r3, #12]

#ifndef NX_DHCP_ENABLE_BOOTP

    /* Added the END option.  */
    *(buffer + index) = NX_DHCP_OPTION_END;
 8007dc6:	69fb      	ldr	r3, [r7, #28]
 8007dc8:	6aba      	ldr	r2, [r7, #40]	; 0x28
 8007dca:	4413      	add	r3, r2
 8007dcc:	22ff      	movs	r2, #255	; 0xff
 8007dce:	701a      	strb	r2, [r3, #0]
    index ++;
 8007dd0:	69fb      	ldr	r3, [r7, #28]
 8007dd2:	3301      	adds	r3, #1
 8007dd4:	61fb      	str	r3, [r7, #28]

    /* Check the option length.  */
    if (index > NX_BOOTP_OFFSET_END)
 8007dd6:	69fb      	ldr	r3, [r7, #28]
 8007dd8:	f5b3 7f96 	cmp.w	r3, #300	; 0x12c
 8007ddc:	d908      	bls.n	8007df0 <_nx_dhcp_send_request_internal+0x520>
    {
        packet_ptr -> nx_packet_length = index;
 8007dde:	6a3b      	ldr	r3, [r7, #32]
 8007de0:	69fa      	ldr	r2, [r7, #28]
 8007de2:	625a      	str	r2, [r3, #36]	; 0x24
        packet_ptr -> nx_packet_append_ptr =  packet_ptr -> nx_packet_prepend_ptr + index;
 8007de4:	6a3b      	ldr	r3, [r7, #32]
 8007de6:	6899      	ldr	r1, [r3, #8]
 8007de8:	69fa      	ldr	r2, [r7, #28]
 8007dea:	6a3b      	ldr	r3, [r7, #32]
 8007dec:	440a      	add	r2, r1
 8007dee:	60da      	str	r2, [r3, #12]
    }
#endif

    /* Set the target address according to RFC2131, Section4.3.6, Page33, Table4 and Section4.4.4, Page40.  
       DHCP Request for renewing and DHCP Release message must be unicast.  */
    if (((dhcp_message_type == NX_DHCP_TYPE_DHCPREQUEST) && (interface_record -> nx_dhcp_state == NX_DHCP_STATE_RENEWING)) ||
 8007df0:	687b      	ldr	r3, [r7, #4]
 8007df2:	2b03      	cmp	r3, #3
 8007df4:	d103      	bne.n	8007dfe <_nx_dhcp_send_request_internal+0x52e>
 8007df6:	68bb      	ldr	r3, [r7, #8]
 8007df8:	785b      	ldrb	r3, [r3, #1]
 8007dfa:	2b06      	cmp	r3, #6
 8007dfc:	d002      	beq.n	8007e04 <_nx_dhcp_send_request_internal+0x534>
 8007dfe:	687b      	ldr	r3, [r7, #4]
 8007e00:	2b07      	cmp	r3, #7
 8007e02:	d103      	bne.n	8007e0c <_nx_dhcp_send_request_internal+0x53c>
        (dhcp_message_type == NX_DHCP_TYPE_DHCPRELEASE))
    {

        /* Use the current server's IP address.  */
        targetIP = interface_record -> nx_dhcp_server_ip;
 8007e04:	68bb      	ldr	r3, [r7, #8]
 8007e06:	695b      	ldr	r3, [r3, #20]
 8007e08:	63fb      	str	r3, [r7, #60]	; 0x3c
 8007e0a:	e002      	b.n	8007e12 <_nx_dhcp_send_request_internal+0x542>
    }
    else
    {

        /* Set the server target IP address to broadcast.  */
        targetIP = NX_BOOTP_BC_ADDRESS;
 8007e0c:	f04f 33ff 	mov.w	r3, #4294967295
 8007e10:	63fb      	str	r3, [r7, #60]	; 0x3c
    }

    /* DHCP messages broadcast by a client prior to that client obtaining
       its IP address must have the source address field in the IP header
       set to 0. RFC2131, Section4.1, Page23.  */
    if ((dhcp_message_type == NX_DHCP_TYPE_DHCPDISCOVER) ||
 8007e12:	687b      	ldr	r3, [r7, #4]
 8007e14:	2b01      	cmp	r3, #1
 8007e16:	d006      	beq.n	8007e26 <_nx_dhcp_send_request_internal+0x556>
 8007e18:	687b      	ldr	r3, [r7, #4]
 8007e1a:	2b03      	cmp	r3, #3
 8007e1c:	d10b      	bne.n	8007e36 <_nx_dhcp_send_request_internal+0x566>
        ((dhcp_message_type == NX_DHCP_TYPE_DHCPREQUEST) && (interface_record -> nx_dhcp_state < NX_DHCP_STATE_BOUND)))
 8007e1e:	68bb      	ldr	r3, [r7, #8]
 8007e20:	785b      	ldrb	r3, [r3, #1]
 8007e22:	2b04      	cmp	r3, #4
 8007e24:	d807      	bhi.n	8007e36 <_nx_dhcp_send_request_internal+0x566>
    {

        /* Call function to send the special packet with zero source address.*/
        status = _nx_dhcp_client_send_with_zero_source_address(dhcp_ptr, iface_index, packet_ptr);
 8007e26:	6a3b      	ldr	r3, [r7, #32]
 8007e28:	461a      	mov	r2, r3
 8007e2a:	6b79      	ldr	r1, [r7, #52]	; 0x34
 8007e2c:	68f8      	ldr	r0, [r7, #12]
 8007e2e:	f000 f819 	bl	8007e64 <_nx_dhcp_client_send_with_zero_source_address>
 8007e32:	63b8      	str	r0, [r7, #56]	; 0x38
 8007e34:	e00a      	b.n	8007e4c <_nx_dhcp_send_request_internal+0x57c>
    }
    else
    {

        /* Send the packet.  */
        status = nx_udp_socket_interface_send(&(dhcp_ptr -> nx_dhcp_socket), packet_ptr, targetIP, NX_DHCP_SERVER_UDP_PORT, iface_index);
 8007e36:	68fb      	ldr	r3, [r7, #12]
 8007e38:	f603 30dc 	addw	r0, r3, #3036	; 0xbdc
 8007e3c:	6a39      	ldr	r1, [r7, #32]
 8007e3e:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8007e40:	9300      	str	r3, [sp, #0]
 8007e42:	2343      	movs	r3, #67	; 0x43
 8007e44:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 8007e46:	f008 fe60 	bl	8010b0a <_nx_udp_socket_source_send>
 8007e4a:	63b8      	str	r0, [r7, #56]	; 0x38
    }

    /* If an error is detected, release the packet. */
    if (status != NX_SUCCESS)
 8007e4c:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8007e4e:	2b00      	cmp	r3, #0
 8007e50:	d003      	beq.n	8007e5a <_nx_dhcp_send_request_internal+0x58a>
    {

        /* Release the packet.  */
        nx_packet_release(packet_ptr);
 8007e52:	6a3b      	ldr	r3, [r7, #32]
 8007e54:	4618      	mov	r0, r3
 8007e56:	f004 fad7 	bl	800c408 <_nx_packet_release>
    }

    /* Return completion status.  */
    return(status);
 8007e5a:	6bbb      	ldr	r3, [r7, #56]	; 0x38
}
 8007e5c:	4618      	mov	r0, r3
 8007e5e:	3744      	adds	r7, #68	; 0x44
 8007e60:	46bd      	mov	sp, r7
 8007e62:	bd90      	pop	{r4, r7, pc}

08007e64 <_nx_dhcp_client_send_with_zero_source_address>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
static UINT  _nx_dhcp_client_send_with_zero_source_address(NX_DHCP *dhcp_ptr, UINT iface_index, NX_PACKET *packet_ptr)
{
 8007e64:	b580      	push	{r7, lr}
 8007e66:	b098      	sub	sp, #96	; 0x60
 8007e68:	af02      	add	r7, sp, #8
 8007e6a:	60f8      	str	r0, [r7, #12]
 8007e6c:	60b9      	str	r1, [r7, #8]
 8007e6e:	607a      	str	r2, [r7, #4]
ULONG           checksum;
ULONG           val;
NX_IP_DRIVER    driver_request;
      
    /* Set up the pointer to the associated IP instance.  */
    ip_ptr = dhcp_ptr -> nx_dhcp_ip_ptr;
 8007e70:	68fb      	ldr	r3, [r7, #12]
 8007e72:	689b      	ldr	r3, [r3, #8]
 8007e74:	653b      	str	r3, [r7, #80]	; 0x50

    /* Set up the pointer to the associated socket.  */
    socket_ptr = &dhcp_ptr -> nx_dhcp_socket;
 8007e76:	68fb      	ldr	r3, [r7, #12]
 8007e78:	f603 33dc 	addw	r3, r3, #3036	; 0xbdc
 8007e7c:	64fb      	str	r3, [r7, #76]	; 0x4c

    /* Set up the pointer to the interface.  */
    interface_ptr = &(ip_ptr -> nx_ip_interface[iface_index]);
 8007e7e:	68bb      	ldr	r3, [r7, #8]
 8007e80:	224c      	movs	r2, #76	; 0x4c
 8007e82:	fb02 f303 	mul.w	r3, r2, r3
 8007e86:	f503 63e4 	add.w	r3, r3, #1824	; 0x720
 8007e8a:	6d3a      	ldr	r2, [r7, #80]	; 0x50
 8007e8c:	4413      	add	r3, r2
 8007e8e:	64bb      	str	r3, [r7, #72]	; 0x48
    packet_ptr -> nx_packet_ip_interface = interface_ptr;
 8007e90:	687b      	ldr	r3, [r7, #4]
 8007e92:	6cba      	ldr	r2, [r7, #72]	; 0x48
 8007e94:	631a      	str	r2, [r3, #48]	; 0x30

    /* Set up the address.  */
    ip_src_addr = NX_BOOTP_NO_ADDRESS;
 8007e96:	2300      	movs	r3, #0
 8007e98:	637b      	str	r3, [r7, #52]	; 0x34
    ip_dest_addr = NX_BOOTP_BC_ADDRESS;
 8007e9a:	f04f 33ff 	mov.w	r3, #4294967295
 8007e9e:	633b      	str	r3, [r7, #48]	; 0x30

    /* Check the interface.  */
    if ((!interface_ptr -> nx_interface_valid) || (!interface_ptr -> nx_interface_link_up))
 8007ea0:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 8007ea2:	791b      	ldrb	r3, [r3, #4]
 8007ea4:	2b00      	cmp	r3, #0
 8007ea6:	d003      	beq.n	8007eb0 <_nx_dhcp_client_send_with_zero_source_address+0x4c>
 8007ea8:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 8007eaa:	799b      	ldrb	r3, [r3, #6]
 8007eac:	2b00      	cmp	r3, #0
 8007eae:	d101      	bne.n	8007eb4 <_nx_dhcp_client_send_with_zero_source_address+0x50>
    {

        /* None found; return the error status. */
        return(NX_INVALID_INTERFACE);
 8007eb0:	234c      	movs	r3, #76	; 0x4c
 8007eb2:	e13b      	b.n	800812c <_nx_dhcp_client_send_with_zero_source_address+0x2c8>
    }

    /* Build UDP header.  */

    /* Prepend the UDP header to the packet.  First, make room for the UDP header.  */
    packet_ptr -> nx_packet_prepend_ptr = packet_ptr -> nx_packet_prepend_ptr - sizeof(NX_UDP_HEADER);
 8007eb4:	687b      	ldr	r3, [r7, #4]
 8007eb6:	689b      	ldr	r3, [r3, #8]
 8007eb8:	f1a3 0208 	sub.w	r2, r3, #8
 8007ebc:	687b      	ldr	r3, [r7, #4]
 8007ebe:	609a      	str	r2, [r3, #8]

    /* Set the correct IP version. */
    packet_ptr -> nx_packet_ip_version = NX_IP_VERSION_V4;
 8007ec0:	687b      	ldr	r3, [r7, #4]
 8007ec2:	2204      	movs	r2, #4
 8007ec4:	f883 202c 	strb.w	r2, [r3, #44]	; 0x2c
    
#ifndef NX_DISABLE_UDP_INFO
    /* Increment the total UDP packets sent count.  */
    ip_ptr -> nx_ip_udp_packets_sent++;
 8007ec8:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 8007eca:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
 8007ece:	1c5a      	adds	r2, r3, #1
 8007ed0:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 8007ed2:	f8c3 2088 	str.w	r2, [r3, #136]	; 0x88

    /* Increment the total UDP bytes sent.  */
    ip_ptr -> nx_ip_udp_bytes_sent +=  packet_ptr -> nx_packet_length;
 8007ed6:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 8007ed8:	f8d3 208c 	ldr.w	r2, [r3, #140]	; 0x8c
 8007edc:	687b      	ldr	r3, [r7, #4]
 8007ede:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8007ee0:	441a      	add	r2, r3
 8007ee2:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 8007ee4:	f8c3 208c 	str.w	r2, [r3, #140]	; 0x8c

    /* Increment the total UDP packets sent count for this socket.  */
    socket_ptr -> nx_udp_socket_packets_sent++;
 8007ee8:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8007eea:	691b      	ldr	r3, [r3, #16]
 8007eec:	1c5a      	adds	r2, r3, #1
 8007eee:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8007ef0:	611a      	str	r2, [r3, #16]

    /* Increment the total UDP bytes sent for this socket.  */
    socket_ptr -> nx_udp_socket_bytes_sent +=  packet_ptr -> nx_packet_length;
 8007ef2:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8007ef4:	695a      	ldr	r2, [r3, #20]
 8007ef6:	687b      	ldr	r3, [r7, #4]
 8007ef8:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8007efa:	441a      	add	r2, r3
 8007efc:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8007efe:	615a      	str	r2, [r3, #20]
#endif

    /* Increase the packet length.  */
    packet_ptr -> nx_packet_length = packet_ptr -> nx_packet_length + (ULONG)sizeof(NX_UDP_HEADER);
 8007f00:	687b      	ldr	r3, [r7, #4]
 8007f02:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8007f04:	f103 0208 	add.w	r2, r3, #8
 8007f08:	687b      	ldr	r3, [r7, #4]
 8007f0a:	625a      	str	r2, [r3, #36]	; 0x24

    /* Setup the UDP header pointer.  */
    udp_header_ptr =  (NX_UDP_HEADER *) packet_ptr -> nx_packet_prepend_ptr;
 8007f0c:	687b      	ldr	r3, [r7, #4]
 8007f0e:	689b      	ldr	r3, [r3, #8]
 8007f10:	647b      	str	r3, [r7, #68]	; 0x44

    /* Build the first 32-bit word of the UDP header.  */
    udp_header_ptr -> nx_udp_header_word_0 = (((ULONG)socket_ptr -> nx_udp_socket_port ) << NX_SHIFT_BY_16) | (ULONG) NX_DHCP_SERVER_UDP_PORT;
 8007f12:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8007f14:	689b      	ldr	r3, [r3, #8]
 8007f16:	041b      	lsls	r3, r3, #16
 8007f18:	f043 0243 	orr.w	r2, r3, #67	; 0x43
 8007f1c:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8007f1e:	601a      	str	r2, [r3, #0]

    /* Build the second 32-bit word of the UDP header.  */
    udp_header_ptr -> nx_udp_header_word_1 =  (packet_ptr -> nx_packet_length << NX_SHIFT_BY_16);
 8007f20:	687b      	ldr	r3, [r7, #4]
 8007f22:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8007f24:	041a      	lsls	r2, r3, #16
 8007f26:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8007f28:	605a      	str	r2, [r3, #4]

    /* Endian swapping logic.  If NX_LITTLE_ENDIAN is specified, these macros will
       swap the endian of the UDP header.  */
    NX_CHANGE_ULONG_ENDIAN(udp_header_ptr -> nx_udp_header_word_0);
 8007f2a:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8007f2c:	681b      	ldr	r3, [r3, #0]
 8007f2e:	ba1a      	rev	r2, r3
 8007f30:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8007f32:	601a      	str	r2, [r3, #0]
    NX_CHANGE_ULONG_ENDIAN(udp_header_ptr -> nx_udp_header_word_1);
 8007f34:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8007f36:	685b      	ldr	r3, [r3, #4]
 8007f38:	ba1a      	rev	r2, r3
 8007f3a:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8007f3c:	605a      	str	r2, [r3, #4]

#ifdef NX_DISABLE_UDP_TX_CHECKSUM
    compute_checksum = 0;
#else /* NX_DISABLE_UDP_TX_CHECKSUM */
    compute_checksum = 1;
 8007f3e:	2301      	movs	r3, #1
 8007f40:	643b      	str	r3, [r7, #64]	; 0x40
        compute_checksum = 0;
    else
        compute_checksum = 1;
#endif /* NX_ENABLE_INTERFACE_CAPABILITY */

    if (compute_checksum)
 8007f42:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8007f44:	2b00      	cmp	r3, #0
 8007f46:	d027      	beq.n	8007f98 <_nx_dhcp_client_send_with_zero_source_address+0x134>
    {
        /* Yes, we need to compute the UDP checksum.  */
        checksum = _nx_ip_checksum_compute(packet_ptr,
                                           NX_PROTOCOL_UDP,
                                           (UINT)packet_ptr -> nx_packet_length,
 8007f48:	687b      	ldr	r3, [r7, #4]
 8007f4a:	6a5a      	ldr	r2, [r3, #36]	; 0x24
        checksum = _nx_ip_checksum_compute(packet_ptr,
 8007f4c:	f107 0134 	add.w	r1, r7, #52	; 0x34
 8007f50:	f107 0330 	add.w	r3, r7, #48	; 0x30
 8007f54:	9300      	str	r3, [sp, #0]
 8007f56:	460b      	mov	r3, r1
 8007f58:	2111      	movs	r1, #17
 8007f5a:	6878      	ldr	r0, [r7, #4]
 8007f5c:	f001 fe64 	bl	8009c28 <_nx_ip_checksum_compute>
 8007f60:	4603      	mov	r3, r0
 8007f62:	657b      	str	r3, [r7, #84]	; 0x54
                                           &ip_src_addr,
                                           &ip_dest_addr);

        checksum = ~checksum & NX_LOWER_16_MASK;
 8007f64:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 8007f66:	43db      	mvns	r3, r3
 8007f68:	b29b      	uxth	r3, r3
 8007f6a:	657b      	str	r3, [r7, #84]	; 0x54

        /* If the computed checksum is zero, it will be transmitted as all ones. */
        /* RFC 768, page 2. */
        if (checksum == 0)
 8007f6c:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 8007f6e:	2b00      	cmp	r3, #0
 8007f70:	d102      	bne.n	8007f78 <_nx_dhcp_client_send_with_zero_source_address+0x114>
            checksum = 0xFFFF;
 8007f72:	f64f 73ff 	movw	r3, #65535	; 0xffff
 8007f76:	657b      	str	r3, [r7, #84]	; 0x54

        NX_CHANGE_ULONG_ENDIAN(udp_header_ptr -> nx_udp_header_word_1);
 8007f78:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8007f7a:	685b      	ldr	r3, [r3, #4]
 8007f7c:	ba1a      	rev	r2, r3
 8007f7e:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8007f80:	605a      	str	r2, [r3, #4]

        udp_header_ptr -> nx_udp_header_word_1 = udp_header_ptr -> nx_udp_header_word_1 | checksum;
 8007f82:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8007f84:	685a      	ldr	r2, [r3, #4]
 8007f86:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 8007f88:	431a      	orrs	r2, r3
 8007f8a:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8007f8c:	605a      	str	r2, [r3, #4]

        NX_CHANGE_ULONG_ENDIAN(udp_header_ptr -> nx_udp_header_word_1);
 8007f8e:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8007f90:	685b      	ldr	r3, [r3, #4]
 8007f92:	ba1a      	rev	r2, r3
 8007f94:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8007f96:	605a      	str	r2, [r3, #4]
        /* Set CHECKSUM flag so the driver would invoke the HW checksum. */
        packet_ptr -> nx_packet_interface_capability_flag |= NX_INTERFACE_CAPABILITY_UDP_TX_CHECKSUM;
#endif /* NX_ENABLE_INTERFACE_CAPABILITY  */

    /* Get mutex protection.  */
    tx_mutex_get(&(ip_ptr -> nx_ip_protection), TX_WAIT_FOREVER);
 8007f98:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 8007f9a:	f503 739e 	add.w	r3, r3, #316	; 0x13c
 8007f9e:	f04f 31ff 	mov.w	r1, #4294967295
 8007fa2:	4618      	mov	r0, r3
 8007fa4:	f00e f936 	bl	8016214 <_txe_mutex_get>

    /* Build the IP header.  */

    /* Prepend the IP header to the packet.  First, make room for the IP header.  */
    packet_ptr -> nx_packet_prepend_ptr = packet_ptr -> nx_packet_prepend_ptr - 20;
 8007fa8:	687b      	ldr	r3, [r7, #4]
 8007faa:	689b      	ldr	r3, [r3, #8]
 8007fac:	f1a3 0214 	sub.w	r2, r3, #20
 8007fb0:	687b      	ldr	r3, [r7, #4]
 8007fb2:	609a      	str	r2, [r3, #8]

    /* Increase the packet length.  */
    packet_ptr -> nx_packet_length = packet_ptr -> nx_packet_length + 20;
 8007fb4:	687b      	ldr	r3, [r7, #4]
 8007fb6:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8007fb8:	f103 0214 	add.w	r2, r3, #20
 8007fbc:	687b      	ldr	r3, [r7, #4]
 8007fbe:	625a      	str	r2, [r3, #36]	; 0x24

    /* Setup the IP header pointer.  */
    ip_header_ptr =  (NX_IPV4_HEADER *) packet_ptr -> nx_packet_prepend_ptr; 
 8007fc0:	687b      	ldr	r3, [r7, #4]
 8007fc2:	689b      	ldr	r3, [r3, #8]
 8007fc4:	63fb      	str	r3, [r7, #60]	; 0x3c

    /* Build the first 32-bit word of the IP header.  */
    ip_header_ptr -> nx_ip_header_word_0 =  (NX_IP_VERSION | socket_ptr -> nx_udp_socket_type_of_service | (0xFFFF & packet_ptr -> nx_packet_length));
 8007fc6:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8007fc8:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 8007fca:	687b      	ldr	r3, [r7, #4]
 8007fcc:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8007fce:	b29b      	uxth	r3, r3
 8007fd0:	4313      	orrs	r3, r2
 8007fd2:	f043 428a 	orr.w	r2, r3, #1157627904	; 0x45000000
 8007fd6:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8007fd8:	601a      	str	r2, [r3, #0]

    /* Build the second 32-bit word of the IP header.  */
    ip_header_ptr -> nx_ip_header_word_1 =  (ip_ptr -> nx_ip_packet_id++ << NX_SHIFT_BY_16) | socket_ptr -> nx_udp_socket_fragment_enable;
 8007fda:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 8007fdc:	f8d3 3134 	ldr.w	r3, [r3, #308]	; 0x134
 8007fe0:	1c59      	adds	r1, r3, #1
 8007fe2:	6d3a      	ldr	r2, [r7, #80]	; 0x50
 8007fe4:	f8c2 1134 	str.w	r1, [r2, #308]	; 0x134
 8007fe8:	041a      	lsls	r2, r3, #16
 8007fea:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8007fec:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8007fee:	431a      	orrs	r2, r3
 8007ff0:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8007ff2:	605a      	str	r2, [r3, #4]

    /* Build the third 32-bit word of the IP header.  */
    ip_header_ptr -> nx_ip_header_word_2 =  ((socket_ptr -> nx_udp_socket_time_to_live << NX_IP_TIME_TO_LIVE_SHIFT) | NX_IP_UDP);
 8007ff4:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8007ff6:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8007ff8:	061b      	lsls	r3, r3, #24
 8007ffa:	f443 1288 	orr.w	r2, r3, #1114112	; 0x110000
 8007ffe:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8008000:	609a      	str	r2, [r3, #8]

    /* Place the source IP address in the IP header.  */
    ip_header_ptr -> nx_ip_header_source_ip =  ip_src_addr;
 8008002:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 8008004:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8008006:	60da      	str	r2, [r3, #12]

    /* Place the destination IP address in the IP header.  */
    ip_header_ptr -> nx_ip_header_destination_ip =  ip_dest_addr;
 8008008:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 800800a:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800800c:	611a      	str	r2, [r3, #16]

    /* Endian swapping logic.  If NX_LITTLE_ENDIAN is specified, these macros will
       swap the endian of the IP header.  */
    NX_CHANGE_ULONG_ENDIAN(ip_header_ptr -> nx_ip_header_word_0);
 800800e:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8008010:	681b      	ldr	r3, [r3, #0]
 8008012:	ba1a      	rev	r2, r3
 8008014:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8008016:	601a      	str	r2, [r3, #0]
    NX_CHANGE_ULONG_ENDIAN(ip_header_ptr -> nx_ip_header_word_1);
 8008018:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800801a:	685b      	ldr	r3, [r3, #4]
 800801c:	ba1a      	rev	r2, r3
 800801e:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8008020:	605a      	str	r2, [r3, #4]
    NX_CHANGE_ULONG_ENDIAN(ip_header_ptr -> nx_ip_header_word_2);
 8008022:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8008024:	689b      	ldr	r3, [r3, #8]
 8008026:	ba1a      	rev	r2, r3
 8008028:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800802a:	609a      	str	r2, [r3, #8]
    NX_CHANGE_ULONG_ENDIAN(ip_header_ptr -> nx_ip_header_source_ip);
 800802c:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800802e:	68db      	ldr	r3, [r3, #12]
 8008030:	ba1a      	rev	r2, r3
 8008032:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8008034:	60da      	str	r2, [r3, #12]
    NX_CHANGE_ULONG_ENDIAN(ip_header_ptr -> nx_ip_header_destination_ip);
 8008036:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8008038:	691b      	ldr	r3, [r3, #16]
 800803a:	ba1a      	rev	r2, r3
 800803c:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800803e:	611a      	str	r2, [r3, #16]
     
#ifdef NX_DISABLE_IP_TX_CHECKSUM
    compute_checksum = 0;
#else /* NX_DISABLE_IP_TX_CHECKSUM */
    compute_checksum = 1;
 8008040:	2301      	movs	r3, #1
 8008042:	643b      	str	r3, [r7, #64]	; 0x40
        compute_checksum = 0;
    else
        compute_checksum = 1;
#endif /* NX_ENABLE_INTERFACE_CAPABILITY */

    if (compute_checksum)
 8008044:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8008046:	2b00      	cmp	r3, #0
 8008048:	d018      	beq.n	800807c <_nx_dhcp_client_send_with_zero_source_address+0x218>
    {
        checksum = _nx_ip_checksum_compute(packet_ptr, NX_IP_VERSION_V4, 20, NULL, NULL);
 800804a:	2300      	movs	r3, #0
 800804c:	9300      	str	r3, [sp, #0]
 800804e:	2300      	movs	r3, #0
 8008050:	2214      	movs	r2, #20
 8008052:	2104      	movs	r1, #4
 8008054:	6878      	ldr	r0, [r7, #4]
 8008056:	f001 fde7 	bl	8009c28 <_nx_ip_checksum_compute>
 800805a:	4603      	mov	r3, r0
 800805c:	657b      	str	r3, [r7, #84]	; 0x54

        val = (ULONG)(~checksum);
 800805e:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 8008060:	43db      	mvns	r3, r3
 8008062:	63bb      	str	r3, [r7, #56]	; 0x38
        val = val & NX_LOWER_16_MASK;
 8008064:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8008066:	b29b      	uxth	r3, r3
 8008068:	63bb      	str	r3, [r7, #56]	; 0x38

        /* Convert to network byte order. */
        NX_CHANGE_ULONG_ENDIAN(val);
 800806a:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800806c:	ba1b      	rev	r3, r3
 800806e:	63bb      	str	r3, [r7, #56]	; 0x38

        /* Now store the checksum in the IP header.  */
        ip_header_ptr -> nx_ip_header_word_2 =  ip_header_ptr -> nx_ip_header_word_2 | val;
 8008070:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8008072:	689a      	ldr	r2, [r3, #8]
 8008074:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8008076:	431a      	orrs	r2, r3
 8008078:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800807a:	609a      	str	r2, [r3, #8]
        }
    }
#endif /* NX_ENABLE_IP_PACKET_FILTER */

    /* Build the driver request.  */
    driver_request.nx_ip_driver_ptr =                   ip_ptr;
 800807c:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 800807e:	62bb      	str	r3, [r7, #40]	; 0x28
    driver_request.nx_ip_driver_packet =                packet_ptr;
 8008080:	687b      	ldr	r3, [r7, #4]
 8008082:	623b      	str	r3, [r7, #32]
    driver_request.nx_ip_driver_interface =             packet_ptr -> nx_packet_ip_interface;
 8008084:	687b      	ldr	r3, [r7, #4]
 8008086:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8008088:	62fb      	str	r3, [r7, #44]	; 0x2c
    driver_request.nx_ip_driver_command =               NX_LINK_PACKET_BROADCAST;
 800808a:	2304      	movs	r3, #4
 800808c:	613b      	str	r3, [r7, #16]
    driver_request.nx_ip_driver_physical_address_msw =  0xFFFFUL;
 800808e:	f64f 73ff 	movw	r3, #65535	; 0xffff
 8008092:	61bb      	str	r3, [r7, #24]
    driver_request.nx_ip_driver_physical_address_lsw =  0xFFFFFFFFUL;
 8008094:	f04f 33ff 	mov.w	r3, #4294967295
 8008098:	61fb      	str	r3, [r7, #28]

    /* Determine if fragmentation is needed.  */
    if (packet_ptr -> nx_packet_length > packet_ptr -> nx_packet_ip_interface -> nx_interface_ip_mtu_size)
 800809a:	687b      	ldr	r3, [r7, #4]
 800809c:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 800809e:	687b      	ldr	r3, [r7, #4]
 80080a0:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 80080a2:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 80080a4:	429a      	cmp	r2, r3
 80080a6:	d925      	bls.n	80080f4 <_nx_dhcp_client_send_with_zero_source_address+0x290>
    {

#ifndef NX_DISABLE_FRAGMENTATION
        /* Check the DF bit flag.  */
        if ((ip_ptr -> nx_ip_fragment_processing) && (socket_ptr -> nx_udp_socket_fragment_enable != NX_DONT_FRAGMENT))
 80080a8:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 80080aa:	f8d3 329c 	ldr.w	r3, [r3, #668]	; 0x29c
 80080ae:	2b00      	cmp	r3, #0
 80080b0:	d013      	beq.n	80080da <_nx_dhcp_client_send_with_zero_source_address+0x276>
 80080b2:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 80080b4:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 80080b6:	f5b3 4f80 	cmp.w	r3, #16384	; 0x4000
 80080ba:	d00e      	beq.n	80080da <_nx_dhcp_client_send_with_zero_source_address+0x276>
        {

            /* Fragmentation is needed, call the IP fragment processing routine.  */
            (ip_ptr -> nx_ip_fragment_processing) (&driver_request);
 80080bc:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 80080be:	f8d3 329c 	ldr.w	r3, [r3, #668]	; 0x29c
 80080c2:	f107 0210 	add.w	r2, r7, #16
 80080c6:	4610      	mov	r0, r2
 80080c8:	4798      	blx	r3

            /* Release mutex protection.  */
            tx_mutex_put(&(ip_ptr -> nx_ip_protection));
 80080ca:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 80080cc:	f503 739e 	add.w	r3, r3, #316	; 0x13c
 80080d0:	4618      	mov	r0, r3
 80080d2:	f00e f8f9 	bl	80162c8 <_txe_mutex_put>

            /* Return a successful status.  */
            return(NX_SUCCESS);
 80080d6:	2300      	movs	r3, #0
 80080d8:	e028      	b.n	800812c <_nx_dhcp_client_send_with_zero_source_address+0x2c8>
        {

#ifndef NX_DISABLE_IP_INFO

            /* Increment the IP send packets dropped count.  */
            ip_ptr -> nx_ip_send_packets_dropped++;
 80080da:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 80080dc:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 80080de:	1c5a      	adds	r2, r3, #1
 80080e0:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 80080e2:	655a      	str	r2, [r3, #84]	; 0x54
#endif

            /* Release mutex protection.  */
            tx_mutex_put(&(ip_ptr -> nx_ip_protection));
 80080e4:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 80080e6:	f503 739e 	add.w	r3, r3, #316	; 0x13c
 80080ea:	4618      	mov	r0, r3
 80080ec:	f00e f8ec 	bl	80162c8 <_txe_mutex_put>

            /* Return a not successful status.  */
            return(NX_NOT_SUCCESSFUL);
 80080f0:	2343      	movs	r3, #67	; 0x43
 80080f2:	e01b      	b.n	800812c <_nx_dhcp_client_send_with_zero_source_address+0x2c8>
    }

#ifndef NX_DISABLE_IP_INFO

    /* Increment the IP packet sent count.  */
    ip_ptr -> nx_ip_total_packets_sent++;
 80080f4:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 80080f6:	695b      	ldr	r3, [r3, #20]
 80080f8:	1c5a      	adds	r2, r3, #1
 80080fa:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 80080fc:	615a      	str	r2, [r3, #20]

    /* Increment the IP bytes sent count.  */
    ip_ptr -> nx_ip_total_bytes_sent +=  packet_ptr -> nx_packet_length - 20;
 80080fe:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 8008100:	699a      	ldr	r2, [r3, #24]
 8008102:	687b      	ldr	r3, [r7, #4]
 8008104:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8008106:	4413      	add	r3, r2
 8008108:	f1a3 0214 	sub.w	r2, r3, #20
 800810c:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 800810e:	619a      	str	r2, [r3, #24]
#endif

    /* Broadcast packet.  */
    (packet_ptr -> nx_packet_ip_interface -> nx_interface_link_driver_entry) (&driver_request);
 8008110:	687b      	ldr	r3, [r7, #4]
 8008112:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8008114:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 8008116:	f107 0210 	add.w	r2, r7, #16
 800811a:	4610      	mov	r0, r2
 800811c:	4798      	blx	r3

    /* Release mutex protection.  */
    tx_mutex_put(&(ip_ptr -> nx_ip_protection));
 800811e:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 8008120:	f503 739e 	add.w	r3, r3, #316	; 0x13c
 8008124:	4618      	mov	r0, r3
 8008126:	f00e f8cf 	bl	80162c8 <_txe_mutex_put>

    /* Return a successful status.  */
    return(NX_SUCCESS);
 800812a:	2300      	movs	r3, #0
}
 800812c:	4618      	mov	r0, r3
 800812e:	3758      	adds	r7, #88	; 0x58
 8008130:	46bd      	mov	sp, r7
 8008132:	bd80      	pop	{r7, pc}

08008134 <_nx_dhcp_extract_information>:
/*                                            verified memcpy use cases,  */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
static UINT  _nx_dhcp_extract_information(NX_DHCP *dhcp_ptr, NX_DHCP_INTERFACE_RECORD *interface_record, UCHAR *dhcp_message, UINT length)
{
 8008134:	b580      	push	{r7, lr}
 8008136:	b086      	sub	sp, #24
 8008138:	af00      	add	r7, sp, #0
 800813a:	60f8      	str	r0, [r7, #12]
 800813c:	60b9      	str	r1, [r7, #8]
 800813e:	607a      	str	r2, [r7, #4]
 8008140:	603b      	str	r3, [r7, #0]

ULONG       value;


    /* Extract the IP address.  */
    value =  _nx_dhcp_get_data(dhcp_message + NX_BOOTP_OFFSET_YOUR_IP, 4);
 8008142:	687b      	ldr	r3, [r7, #4]
 8008144:	3310      	adds	r3, #16
 8008146:	2104      	movs	r1, #4
 8008148:	4618      	mov	r0, r3
 800814a:	f000 fa67 	bl	800861c <_nx_dhcp_get_data>
 800814e:	4603      	mov	r3, r0
 8008150:	617b      	str	r3, [r7, #20]

    /* Determine if it is valid.  */
    if ((value != NX_BOOTP_NO_ADDRESS) &&
 8008152:	697b      	ldr	r3, [r7, #20]
 8008154:	2b00      	cmp	r3, #0
 8008156:	d01c      	beq.n	8008192 <_nx_dhcp_extract_information+0x5e>
        (((value & NX_IP_CLASS_A_MASK) == NX_IP_CLASS_A_TYPE) ||
 8008158:	697b      	ldr	r3, [r7, #20]
    if ((value != NX_BOOTP_NO_ADDRESS) &&
 800815a:	2b00      	cmp	r3, #0
 800815c:	da0b      	bge.n	8008176 <_nx_dhcp_extract_information+0x42>
         ((value & NX_IP_CLASS_B_MASK) == NX_IP_CLASS_B_TYPE) ||
 800815e:	697b      	ldr	r3, [r7, #20]
 8008160:	f003 4340 	and.w	r3, r3, #3221225472	; 0xc0000000
        (((value & NX_IP_CLASS_A_MASK) == NX_IP_CLASS_A_TYPE) ||
 8008164:	f1b3 4f00 	cmp.w	r3, #2147483648	; 0x80000000
 8008168:	d005      	beq.n	8008176 <_nx_dhcp_extract_information+0x42>
         ((value & NX_IP_CLASS_C_MASK) == NX_IP_CLASS_C_TYPE)))
 800816a:	697b      	ldr	r3, [r7, #20]
 800816c:	f003 4360 	and.w	r3, r3, #3758096384	; 0xe0000000
         ((value & NX_IP_CLASS_B_MASK) == NX_IP_CLASS_B_TYPE) ||
 8008170:	f1b3 4f40 	cmp.w	r3, #3221225472	; 0xc0000000
 8008174:	d10d      	bne.n	8008192 <_nx_dhcp_extract_information+0x5e>
    {

        /* Store the IP address.  */
        interface_record -> nx_dhcp_ip_address =  value;
 8008176:	697a      	ldr	r2, [r7, #20]
 8008178:	68bb      	ldr	r3, [r7, #8]
 800817a:	60da      	str	r2, [r3, #12]
        return(NX_DHCP_BAD_IP_ADDRESS);
    }
                       
    /* Determine if there is a subnet mask. Note a DHCP Server receiving a BOOTP request
       may send DHCP option data for subnet masks as per RFC 1534 Section 2.  */
    if (_nx_dhcp_get_option_value(dhcp_message, NX_DHCP_OPTION_SUBNET_MASK, &value, length) == NX_SUCCESS)
 800817c:	f107 0214 	add.w	r2, r7, #20
 8008180:	683b      	ldr	r3, [r7, #0]
 8008182:	2101      	movs	r1, #1
 8008184:	6878      	ldr	r0, [r7, #4]
 8008186:	f000 f8f5 	bl	8008374 <_nx_dhcp_get_option_value>
 800818a:	4603      	mov	r3, r0
 800818c:	2b00      	cmp	r3, #0
 800818e:	d002      	beq.n	8008196 <_nx_dhcp_extract_information+0x62>
 8008190:	e012      	b.n	80081b8 <_nx_dhcp_extract_information+0x84>
        return(NX_DHCP_BAD_IP_ADDRESS);
 8008192:	2392      	movs	r3, #146	; 0x92
 8008194:	e0ea      	b.n	800836c <_nx_dhcp_extract_information+0x238>
    {

        /* Make sure there is a valid IP address too.  */
        if (value != NX_BOOTP_NO_ADDRESS)
 8008196:	697b      	ldr	r3, [r7, #20]
 8008198:	2b00      	cmp	r3, #0
 800819a:	d003      	beq.n	80081a4 <_nx_dhcp_extract_information+0x70>
        {

            interface_record -> nx_dhcp_network_mask =  value;
 800819c:	697a      	ldr	r2, [r7, #20]
 800819e:	68bb      	ldr	r3, [r7, #8]
 80081a0:	619a      	str	r2, [r3, #24]
 80081a2:	e009      	b.n	80081b8 <_nx_dhcp_extract_information+0x84>
        {
            ULONG ip_address;

            /* No valid network mask info supplied; use the current network mask if any. Don't
               care about current IP address for now. */
            nx_ip_interface_address_get(dhcp_ptr -> nx_dhcp_ip_ptr, 
 80081a4:	68fb      	ldr	r3, [r7, #12]
 80081a6:	6898      	ldr	r0, [r3, #8]
 80081a8:	68bb      	ldr	r3, [r7, #8]
 80081aa:	69d9      	ldr	r1, [r3, #28]
 80081ac:	68bb      	ldr	r3, [r7, #8]
 80081ae:	3318      	adds	r3, #24
 80081b0:	f107 0210 	add.w	r2, r7, #16
 80081b4:	f002 fc50 	bl	800aa58 <_nx_ip_interface_address_get>
#else  

    /* NX_DHCP_ENABLE_BOOTP  not defined */

    /* Overwrite the server ID if there is a DHCP option for Server ID */
    if (_nx_dhcp_get_option_value(dhcp_message, NX_DHCP_OPTION_DHCP_SERVER, &value, length) == NX_SUCCESS)
 80081b8:	f107 0214 	add.w	r2, r7, #20
 80081bc:	683b      	ldr	r3, [r7, #0]
 80081be:	2136      	movs	r1, #54	; 0x36
 80081c0:	6878      	ldr	r0, [r7, #4]
 80081c2:	f000 f8d7 	bl	8008374 <_nx_dhcp_get_option_value>
 80081c6:	4603      	mov	r3, r0
 80081c8:	2b00      	cmp	r3, #0
 80081ca:	d117      	bne.n	80081fc <_nx_dhcp_extract_information+0xc8>
    {

        /* Determine if it is valid.  */
        if ((value != NX_BOOTP_NO_ADDRESS) &&
 80081cc:	697b      	ldr	r3, [r7, #20]
 80081ce:	2b00      	cmp	r3, #0
 80081d0:	d012      	beq.n	80081f8 <_nx_dhcp_extract_information+0xc4>
            (((value & NX_IP_CLASS_A_MASK) == NX_IP_CLASS_A_TYPE) ||
 80081d2:	697b      	ldr	r3, [r7, #20]
        if ((value != NX_BOOTP_NO_ADDRESS) &&
 80081d4:	2b00      	cmp	r3, #0
 80081d6:	da0b      	bge.n	80081f0 <_nx_dhcp_extract_information+0xbc>
             ((value & NX_IP_CLASS_B_MASK) == NX_IP_CLASS_B_TYPE) ||
 80081d8:	697b      	ldr	r3, [r7, #20]
 80081da:	f003 4340 	and.w	r3, r3, #3221225472	; 0xc0000000
            (((value & NX_IP_CLASS_A_MASK) == NX_IP_CLASS_A_TYPE) ||
 80081de:	f1b3 4f00 	cmp.w	r3, #2147483648	; 0x80000000
 80081e2:	d005      	beq.n	80081f0 <_nx_dhcp_extract_information+0xbc>
             ((value & NX_IP_CLASS_C_MASK) == NX_IP_CLASS_C_TYPE)))
 80081e4:	697b      	ldr	r3, [r7, #20]
 80081e6:	f003 4360 	and.w	r3, r3, #3758096384	; 0xe0000000
             ((value & NX_IP_CLASS_B_MASK) == NX_IP_CLASS_B_TYPE) ||
 80081ea:	f1b3 4f40 	cmp.w	r3, #3221225472	; 0xc0000000
 80081ee:	d103      	bne.n	80081f8 <_nx_dhcp_extract_information+0xc4>
        {

            /* Store the server IP address.  */
            interface_record -> nx_dhcp_server_ip = value;
 80081f0:	697a      	ldr	r2, [r7, #20]
 80081f2:	68bb      	ldr	r3, [r7, #8]
 80081f4:	615a      	str	r2, [r3, #20]
 80081f6:	e001      	b.n	80081fc <_nx_dhcp_extract_information+0xc8>
        }
        else
        {
            return(NX_DHCP_BAD_IP_ADDRESS);
 80081f8:	2392      	movs	r3, #146	; 0x92
 80081fa:	e0b7      	b.n	800836c <_nx_dhcp_extract_information+0x238>
        }
    }

    /* Get the lease time.  */
    if (_nx_dhcp_get_option_value(dhcp_message, NX_DHCP_OPTION_DHCP_LEASE, &value, length) == NX_SUCCESS)
 80081fc:	f107 0214 	add.w	r2, r7, #20
 8008200:	683b      	ldr	r3, [r7, #0]
 8008202:	2133      	movs	r1, #51	; 0x33
 8008204:	6878      	ldr	r0, [r7, #4]
 8008206:	f000 f8b5 	bl	8008374 <_nx_dhcp_get_option_value>
 800820a:	4603      	mov	r3, r0
 800820c:	2b00      	cmp	r3, #0
 800820e:	d120      	bne.n	8008252 <_nx_dhcp_extract_information+0x11e>
    {

        /* Check for an infinite lease. */
        if (value == 0xFFFFFFFF)
 8008210:	697b      	ldr	r3, [r7, #20]
 8008212:	f1b3 3fff 	cmp.w	r3, #4294967295
 8008216:	d109      	bne.n	800822c <_nx_dhcp_extract_information+0xf8>
        {
            /* Store the 'infinite' lease time . */
            interface_record -> nx_dhcp_lease_time = value;
 8008218:	697a      	ldr	r2, [r7, #20]
 800821a:	68bb      	ldr	r3, [r7, #8]
 800821c:	62da      	str	r2, [r3, #44]	; 0x2c
            interface_record -> nx_dhcp_renewal_time = value;
 800821e:	697a      	ldr	r2, [r7, #20]
 8008220:	68bb      	ldr	r3, [r7, #8]
 8008222:	631a      	str	r2, [r3, #48]	; 0x30
            interface_record -> nx_dhcp_rebind_time = value;
 8008224:	697a      	ldr	r2, [r7, #20]
 8008226:	68bb      	ldr	r3, [r7, #8]
 8008228:	635a      	str	r2, [r3, #52]	; 0x34
 800822a:	e012      	b.n	8008252 <_nx_dhcp_extract_information+0x11e>
        }
        else
        {            

            /* Store the lease time in timer ticks.  */
            interface_record -> nx_dhcp_lease_time =  value * (ULONG)NX_IP_PERIODIC_RATE;
 800822c:	697b      	ldr	r3, [r7, #20]
 800822e:	2264      	movs	r2, #100	; 0x64
 8008230:	fb03 f202 	mul.w	r2, r3, r2
 8008234:	68bb      	ldr	r3, [r7, #8]
 8008236:	62da      	str	r2, [r3, #44]	; 0x2c
    
            /* Set the renew and rebind times.  */
            interface_record -> nx_dhcp_renewal_time = interface_record -> nx_dhcp_lease_time / 2;
 8008238:	68bb      	ldr	r3, [r7, #8]
 800823a:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800823c:	085a      	lsrs	r2, r3, #1
 800823e:	68bb      	ldr	r3, [r7, #8]
 8008240:	631a      	str	r2, [r3, #48]	; 0x30
            interface_record -> nx_dhcp_rebind_time =  interface_record -> nx_dhcp_lease_time - (interface_record -> nx_dhcp_lease_time / 8);
 8008242:	68bb      	ldr	r3, [r7, #8]
 8008244:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 8008246:	68bb      	ldr	r3, [r7, #8]
 8008248:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800824a:	08db      	lsrs	r3, r3, #3
 800824c:	1ad2      	subs	r2, r2, r3
 800824e:	68bb      	ldr	r3, [r7, #8]
 8008250:	635a      	str	r2, [r3, #52]	; 0x34
        }
    }
 
    /* Overwrite the renew and rebind times with the specified values if the options are present.  */
    if ((_nx_dhcp_get_option_value(dhcp_message, NX_DHCP_OPTION_RENEWAL, &value, length) == NX_SUCCESS) && 
 8008252:	f107 0214 	add.w	r2, r7, #20
 8008256:	683b      	ldr	r3, [r7, #0]
 8008258:	213a      	movs	r1, #58	; 0x3a
 800825a:	6878      	ldr	r0, [r7, #4]
 800825c:	f000 f88a 	bl	8008374 <_nx_dhcp_get_option_value>
 8008260:	4603      	mov	r3, r0
 8008262:	2b00      	cmp	r3, #0
 8008264:	d112      	bne.n	800828c <_nx_dhcp_extract_information+0x158>
        (value <= interface_record -> nx_dhcp_lease_time))
 8008266:	68bb      	ldr	r3, [r7, #8]
 8008268:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 800826a:	697b      	ldr	r3, [r7, #20]
    if ((_nx_dhcp_get_option_value(dhcp_message, NX_DHCP_OPTION_RENEWAL, &value, length) == NX_SUCCESS) && 
 800826c:	429a      	cmp	r2, r3
 800826e:	d30d      	bcc.n	800828c <_nx_dhcp_extract_information+0x158>
    {       

        /* Check for an infinite lease. */
        if (value == 0xFFFFFFFF)
 8008270:	697b      	ldr	r3, [r7, #20]
 8008272:	f1b3 3fff 	cmp.w	r3, #4294967295
 8008276:	d103      	bne.n	8008280 <_nx_dhcp_extract_information+0x14c>
        {
            /* Set the 'infinite least time.  */
            interface_record -> nx_dhcp_renewal_time = value;
 8008278:	697a      	ldr	r2, [r7, #20]
 800827a:	68bb      	ldr	r3, [r7, #8]
 800827c:	631a      	str	r2, [r3, #48]	; 0x30
 800827e:	e005      	b.n	800828c <_nx_dhcp_extract_information+0x158>
        }
        else
        {

            /* Store the renewal time in timer ticks  */
            interface_record -> nx_dhcp_renewal_time =  value * (ULONG)NX_IP_PERIODIC_RATE;
 8008280:	697b      	ldr	r3, [r7, #20]
 8008282:	2264      	movs	r2, #100	; 0x64
 8008284:	fb03 f202 	mul.w	r2, r3, r2
 8008288:	68bb      	ldr	r3, [r7, #8]
 800828a:	631a      	str	r2, [r3, #48]	; 0x30
        }
    }
  
    /* Determine if there is a rebind time.  */
    if (_nx_dhcp_get_option_value(dhcp_message, NX_DHCP_OPTION_REBIND, &value, length) == NX_SUCCESS)
 800828c:	f107 0214 	add.w	r2, r7, #20
 8008290:	683b      	ldr	r3, [r7, #0]
 8008292:	213b      	movs	r1, #59	; 0x3b
 8008294:	6878      	ldr	r0, [r7, #4]
 8008296:	f000 f86d 	bl	8008374 <_nx_dhcp_get_option_value>
 800829a:	4603      	mov	r3, r0
 800829c:	2b00      	cmp	r3, #0
 800829e:	d119      	bne.n	80082d4 <_nx_dhcp_extract_information+0x1a0>
    {

        /* Check for an infinite lease. */
        if (value == 0xFFFFFFFF)
 80082a0:	697b      	ldr	r3, [r7, #20]
 80082a2:	f1b3 3fff 	cmp.w	r3, #4294967295
 80082a6:	d103      	bne.n	80082b0 <_nx_dhcp_extract_information+0x17c>
        {

            /* Set the 'infinite least time.  */
            interface_record -> nx_dhcp_rebind_time = value;
 80082a8:	697a      	ldr	r2, [r7, #20]
 80082aa:	68bb      	ldr	r3, [r7, #8]
 80082ac:	635a      	str	r2, [r3, #52]	; 0x34
 80082ae:	e011      	b.n	80082d4 <_nx_dhcp_extract_information+0x1a0>
        }
        else
        {

            /* Convert to timer ticks. */
            value = value * (ULONG)NX_IP_PERIODIC_RATE;
 80082b0:	697b      	ldr	r3, [r7, #20]
 80082b2:	2264      	movs	r2, #100	; 0x64
 80082b4:	fb02 f303 	mul.w	r3, r2, r3
 80082b8:	617b      	str	r3, [r7, #20]

            /* Sanity check*/
            if ((value <= interface_record -> nx_dhcp_lease_time) && 
 80082ba:	68bb      	ldr	r3, [r7, #8]
 80082bc:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 80082be:	697b      	ldr	r3, [r7, #20]
 80082c0:	429a      	cmp	r2, r3
 80082c2:	d307      	bcc.n	80082d4 <_nx_dhcp_extract_information+0x1a0>
                (value >= interface_record -> nx_dhcp_renewal_time))
 80082c4:	68bb      	ldr	r3, [r7, #8]
 80082c6:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 80082c8:	697b      	ldr	r3, [r7, #20]
            if ((value <= interface_record -> nx_dhcp_lease_time) && 
 80082ca:	429a      	cmp	r2, r3
 80082cc:	d802      	bhi.n	80082d4 <_nx_dhcp_extract_information+0x1a0>
            {
        
                /* Store the rebind time.  */
                interface_record -> nx_dhcp_rebind_time =  value;
 80082ce:	697a      	ldr	r2, [r7, #20]
 80082d0:	68bb      	ldr	r3, [r7, #8]
 80082d2:	635a      	str	r2, [r3, #52]	; 0x34
            }
        }
    }

    /* Determine if this is an ACK from a server response, which can only happen from a handful of states.  */
    if ((interface_record -> nx_dhcp_state == NX_DHCP_STATE_REQUESTING) ||
 80082d4:	68bb      	ldr	r3, [r7, #8]
 80082d6:	785b      	ldrb	r3, [r3, #1]
 80082d8:	2b04      	cmp	r3, #4
 80082da:	d007      	beq.n	80082ec <_nx_dhcp_extract_information+0x1b8>
        (interface_record -> nx_dhcp_state == NX_DHCP_STATE_RENEWING) ||
 80082dc:	68bb      	ldr	r3, [r7, #8]
 80082de:	785b      	ldrb	r3, [r3, #1]
    if ((interface_record -> nx_dhcp_state == NX_DHCP_STATE_REQUESTING) ||
 80082e0:	2b06      	cmp	r3, #6
 80082e2:	d003      	beq.n	80082ec <_nx_dhcp_extract_information+0x1b8>
        (interface_record -> nx_dhcp_state == NX_DHCP_STATE_REBINDING))
 80082e4:	68bb      	ldr	r3, [r7, #8]
 80082e6:	785b      	ldrb	r3, [r3, #1]
        (interface_record -> nx_dhcp_state == NX_DHCP_STATE_RENEWING) ||
 80082e8:	2b07      	cmp	r3, #7
 80082ea:	d121      	bne.n	8008330 <_nx_dhcp_extract_information+0x1fc>
    {

        /* Determine if the IP gateway/router IP address is present.  */
        if (_nx_dhcp_get_option_value(dhcp_message, NX_DHCP_OPTION_GATEWAYS, &value, length) == NX_SUCCESS)
 80082ec:	f107 0214 	add.w	r2, r7, #20
 80082f0:	683b      	ldr	r3, [r7, #0]
 80082f2:	2103      	movs	r1, #3
 80082f4:	6878      	ldr	r0, [r7, #4]
 80082f6:	f000 f83d 	bl	8008374 <_nx_dhcp_get_option_value>
 80082fa:	4603      	mov	r3, r0
 80082fc:	2b00      	cmp	r3, #0
 80082fe:	d117      	bne.n	8008330 <_nx_dhcp_extract_information+0x1fc>
        {

            /* Determine if it is valid.  */
            if ((value != NX_BOOTP_NO_ADDRESS) &&
 8008300:	697b      	ldr	r3, [r7, #20]
 8008302:	2b00      	cmp	r3, #0
 8008304:	d012      	beq.n	800832c <_nx_dhcp_extract_information+0x1f8>
                (((value & NX_IP_CLASS_A_MASK) == NX_IP_CLASS_A_TYPE) ||
 8008306:	697b      	ldr	r3, [r7, #20]
            if ((value != NX_BOOTP_NO_ADDRESS) &&
 8008308:	2b00      	cmp	r3, #0
 800830a:	da0b      	bge.n	8008324 <_nx_dhcp_extract_information+0x1f0>
                 ((value & NX_IP_CLASS_B_MASK) == NX_IP_CLASS_B_TYPE) ||
 800830c:	697b      	ldr	r3, [r7, #20]
 800830e:	f003 4340 	and.w	r3, r3, #3221225472	; 0xc0000000
                (((value & NX_IP_CLASS_A_MASK) == NX_IP_CLASS_A_TYPE) ||
 8008312:	f1b3 4f00 	cmp.w	r3, #2147483648	; 0x80000000
 8008316:	d005      	beq.n	8008324 <_nx_dhcp_extract_information+0x1f0>
                 ((value & NX_IP_CLASS_C_MASK) == NX_IP_CLASS_C_TYPE)))
 8008318:	697b      	ldr	r3, [r7, #20]
 800831a:	f003 4360 	and.w	r3, r3, #3758096384	; 0xe0000000
                 ((value & NX_IP_CLASS_B_MASK) == NX_IP_CLASS_B_TYPE) ||
 800831e:	f1b3 4f40 	cmp.w	r3, #3221225472	; 0xc0000000
 8008322:	d103      	bne.n	800832c <_nx_dhcp_extract_information+0x1f8>
            {

                /* Store the gateway/Router IP address to the Client record.  */
                interface_record -> nx_dhcp_gateway_address = value;
 8008324:	697a      	ldr	r2, [r7, #20]
 8008326:	68bb      	ldr	r3, [r7, #8]
 8008328:	611a      	str	r2, [r3, #16]
 800832a:	e001      	b.n	8008330 <_nx_dhcp_extract_information+0x1fc>
            }
            else
            {
                return(NX_DHCP_BAD_IP_ADDRESS);
 800832c:	2392      	movs	r3, #146	; 0x92
 800832e:	e01d      	b.n	800836c <_nx_dhcp_extract_information+0x238>
            }
        }
    }

     /* Check the DHCP options size.  */
     if ((length - NX_BOOTP_OFFSET_OPTIONS) > NX_DHCP_OPTIONS_BUFFER_SIZE)
 8008330:	683b      	ldr	r3, [r7, #0]
 8008332:	3bf0      	subs	r3, #240	; 0xf0
 8008334:	f5b3 7f9c 	cmp.w	r3, #312	; 0x138
 8008338:	d905      	bls.n	8008346 <_nx_dhcp_extract_information+0x212>
         interface_record -> nx_dhcp_options_size = NX_DHCP_OPTIONS_BUFFER_SIZE;
 800833a:	68bb      	ldr	r3, [r7, #8]
 800833c:	f44f 729c 	mov.w	r2, #312	; 0x138
 8008340:	f8c3 2180 	str.w	r2, [r3, #384]	; 0x180
 8008344:	e005      	b.n	8008352 <_nx_dhcp_extract_information+0x21e>
     else
         interface_record -> nx_dhcp_options_size = length - NX_BOOTP_OFFSET_OPTIONS;
 8008346:	683b      	ldr	r3, [r7, #0]
 8008348:	f1a3 02f0 	sub.w	r2, r3, #240	; 0xf0
 800834c:	68bb      	ldr	r3, [r7, #8]
 800834e:	f8c3 2180 	str.w	r2, [r3, #384]	; 0x180

     /* Copy the DHCP options into DHCP Client options buffer.  */
     memcpy(interface_record -> nx_dhcp_options_buffer, /* Use case of memcpy is verified. */
 8008352:	68bb      	ldr	r3, [r7, #8]
 8008354:	f103 0048 	add.w	r0, r3, #72	; 0x48
            &dhcp_message[NX_BOOTP_OFFSET_OPTIONS], interface_record -> nx_dhcp_options_size);
 8008358:	687b      	ldr	r3, [r7, #4]
 800835a:	f103 01f0 	add.w	r1, r3, #240	; 0xf0
     memcpy(interface_record -> nx_dhcp_options_buffer, /* Use case of memcpy is verified. */
 800835e:	68bb      	ldr	r3, [r7, #8]
 8008360:	f8d3 3180 	ldr.w	r3, [r3, #384]	; 0x180
 8008364:	461a      	mov	r2, r3
 8008366:	f017 fa61 	bl	801f82c <memcpy>

#endif  /* NX_DHCP_ENABLE_BOOTP */

    return (NX_SUCCESS);
 800836a:	2300      	movs	r3, #0
}
 800836c:	4618      	mov	r0, r3
 800836e:	3718      	adds	r7, #24
 8008370:	46bd      	mov	sp, r7
 8008372:	bd80      	pop	{r7, pc}

08008374 <_nx_dhcp_get_option_value>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
static UINT  _nx_dhcp_get_option_value(UCHAR *bootp_message, UINT option, ULONG *value, UINT length)
{
 8008374:	b580      	push	{r7, lr}
 8008376:	b088      	sub	sp, #32
 8008378:	af00      	add	r7, sp, #0
 800837a:	60f8      	str	r0, [r7, #12]
 800837c:	60b9      	str	r1, [r7, #8]
 800837e:	607a      	str	r2, [r7, #4]
 8008380:	603b      	str	r3, [r7, #0]
UCHAR *option_message;
UINT   option_length;


    /* Setup buffer pointer.  */
    option_message = &bootp_message[NX_BOOTP_OFFSET_OPTIONS];
 8008382:	68fb      	ldr	r3, [r7, #12]
 8008384:	33f0      	adds	r3, #240	; 0xf0
 8008386:	61fb      	str	r3, [r7, #28]
    option_length = length - NX_BOOTP_OFFSET_OPTIONS;
 8008388:	683b      	ldr	r3, [r7, #0]
 800838a:	3bf0      	subs	r3, #240	; 0xf0
 800838c:	61bb      	str	r3, [r7, #24]

    /* Find the option.  */
    if ((option != NX_DHCP_OPTION_PAD) && (option != NX_DHCP_OPTION_END))
 800838e:	68bb      	ldr	r3, [r7, #8]
 8008390:	2b00      	cmp	r3, #0
 8008392:	d02c      	beq.n	80083ee <_nx_dhcp_get_option_value+0x7a>
 8008394:	68bb      	ldr	r3, [r7, #8]
 8008396:	2bff      	cmp	r3, #255	; 0xff
 8008398:	d029      	beq.n	80083ee <_nx_dhcp_get_option_value+0x7a>
    {

        /* Search the buffer for the option.  */
        data =  _nx_dhcp_search_buffer(option_message, option, option_length);
 800839a:	69ba      	ldr	r2, [r7, #24]
 800839c:	68b9      	ldr	r1, [r7, #8]
 800839e:	69f8      	ldr	r0, [r7, #28]
 80083a0:	f000 f8f4 	bl	800858c <_nx_dhcp_search_buffer>
 80083a4:	6178      	str	r0, [r7, #20]

        /* Check to see if the option was found.  */
        if (data != NX_NULL)
 80083a6:	697b      	ldr	r3, [r7, #20]
 80083a8:	2b00      	cmp	r3, #0
 80083aa:	d020      	beq.n	80083ee <_nx_dhcp_get_option_value+0x7a>
        {

            /* Check for the proper size.  */
            if (*data > 4)
 80083ac:	697b      	ldr	r3, [r7, #20]
 80083ae:	781b      	ldrb	r3, [r3, #0]
 80083b0:	2b04      	cmp	r3, #4
 80083b2:	d90f      	bls.n	80083d4 <_nx_dhcp_get_option_value+0x60>
            {

                /* Check for the gateway option.  */
                if (option == NX_DHCP_OPTION_GATEWAYS)
 80083b4:	68bb      	ldr	r3, [r7, #8]
 80083b6:	2b03      	cmp	r3, #3
 80083b8:	d10a      	bne.n	80083d0 <_nx_dhcp_get_option_value+0x5c>
                {

                    /* Pickup the first gateway address.  */
                    *value =  _nx_dhcp_get_data(data + 1, 4);
 80083ba:	697b      	ldr	r3, [r7, #20]
 80083bc:	3301      	adds	r3, #1
 80083be:	2104      	movs	r1, #4
 80083c0:	4618      	mov	r0, r3
 80083c2:	f000 f92b 	bl	800861c <_nx_dhcp_get_data>
 80083c6:	4602      	mov	r2, r0
 80083c8:	687b      	ldr	r3, [r7, #4]
 80083ca:	601a      	str	r2, [r3, #0]

                    /* For now, just disregard any additional gateway addresses.  */
                    return(NX_SUCCESS);
 80083cc:	2300      	movs	r3, #0
 80083ce:	e00f      	b.n	80083f0 <_nx_dhcp_get_option_value+0x7c>
                }
                else
                {

                    /* Invalid size, return error.  */
                    return(NX_SIZE_ERROR);
 80083d0:	2309      	movs	r3, #9
 80083d2:	e00d      	b.n	80083f0 <_nx_dhcp_get_option_value+0x7c>
            }
            else
            {

                /* Get the actual value.  */
                *value = _nx_dhcp_get_data(data + 1, *data);
 80083d4:	697b      	ldr	r3, [r7, #20]
 80083d6:	1c5a      	adds	r2, r3, #1
 80083d8:	697b      	ldr	r3, [r7, #20]
 80083da:	781b      	ldrb	r3, [r3, #0]
 80083dc:	4619      	mov	r1, r3
 80083de:	4610      	mov	r0, r2
 80083e0:	f000 f91c 	bl	800861c <_nx_dhcp_get_data>
 80083e4:	4602      	mov	r2, r0
 80083e6:	687b      	ldr	r3, [r7, #4]
 80083e8:	601a      	str	r2, [r3, #0]
                return(NX_SUCCESS);  
 80083ea:	2300      	movs	r3, #0
 80083ec:	e000      	b.n	80083f0 <_nx_dhcp_get_option_value+0x7c>
            }
        }
    }

    /* Return an error if not found.  */
    return(NX_OPTION_ERROR);
 80083ee:	230a      	movs	r3, #10
}
 80083f0:	4618      	mov	r0, r3
 80083f2:	3720      	adds	r7, #32
 80083f4:	46bd      	mov	sp, r7
 80083f6:	bd80      	pop	{r7, pc}

080083f8 <_nx_dhcp_add_option_value>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
UINT  _nx_dhcp_add_option_value(UCHAR *bootp_message, UINT option, UINT size, ULONG value, UINT *index)
{
 80083f8:	b580      	push	{r7, lr}
 80083fa:	b084      	sub	sp, #16
 80083fc:	af00      	add	r7, sp, #0
 80083fe:	60f8      	str	r0, [r7, #12]
 8008400:	60b9      	str	r1, [r7, #8]
 8008402:	607a      	str	r2, [r7, #4]
 8008404:	603b      	str	r3, [r7, #0]


    /* Store the option.  */
    *(bootp_message + (*index)) = (UCHAR)option;
 8008406:	69bb      	ldr	r3, [r7, #24]
 8008408:	681b      	ldr	r3, [r3, #0]
 800840a:	68fa      	ldr	r2, [r7, #12]
 800840c:	4413      	add	r3, r2
 800840e:	68ba      	ldr	r2, [r7, #8]
 8008410:	b2d2      	uxtb	r2, r2
 8008412:	701a      	strb	r2, [r3, #0]
    (*index) ++;
 8008414:	69bb      	ldr	r3, [r7, #24]
 8008416:	681b      	ldr	r3, [r3, #0]
 8008418:	1c5a      	adds	r2, r3, #1
 800841a:	69bb      	ldr	r3, [r7, #24]
 800841c:	601a      	str	r2, [r3, #0]

    /* Store the option size.  */
    *(bootp_message + (*index)) = (UCHAR)size; 
 800841e:	69bb      	ldr	r3, [r7, #24]
 8008420:	681b      	ldr	r3, [r3, #0]
 8008422:	68fa      	ldr	r2, [r7, #12]
 8008424:	4413      	add	r3, r2
 8008426:	687a      	ldr	r2, [r7, #4]
 8008428:	b2d2      	uxtb	r2, r2
 800842a:	701a      	strb	r2, [r3, #0]
    (*index) ++;
 800842c:	69bb      	ldr	r3, [r7, #24]
 800842e:	681b      	ldr	r3, [r3, #0]
 8008430:	1c5a      	adds	r2, r3, #1
 8008432:	69bb      	ldr	r3, [r7, #24]
 8008434:	601a      	str	r2, [r3, #0]

    /* Store the option value.  */
    _nx_dhcp_store_data(bootp_message + (*index), size, value);
 8008436:	69bb      	ldr	r3, [r7, #24]
 8008438:	681b      	ldr	r3, [r3, #0]
 800843a:	68fa      	ldr	r2, [r7, #12]
 800843c:	4413      	add	r3, r2
 800843e:	683a      	ldr	r2, [r7, #0]
 8008440:	6879      	ldr	r1, [r7, #4]
 8008442:	4618      	mov	r0, r3
 8008444:	f000 f906 	bl	8008654 <_nx_dhcp_store_data>
    (*index) += size;    
 8008448:	69bb      	ldr	r3, [r7, #24]
 800844a:	681a      	ldr	r2, [r3, #0]
 800844c:	687b      	ldr	r3, [r7, #4]
 800844e:	441a      	add	r2, r3
 8008450:	69bb      	ldr	r3, [r7, #24]
 8008452:	601a      	str	r2, [r3, #0]

    /* Return a successful completion.  */
    return(NX_SUCCESS);
 8008454:	2300      	movs	r3, #0
}
 8008456:	4618      	mov	r0, r3
 8008458:	3710      	adds	r7, #16
 800845a:	46bd      	mov	sp, r7
 800845c:	bd80      	pop	{r7, pc}

0800845e <_nx_dhcp_add_option_string>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
static UINT  _nx_dhcp_add_option_string(UCHAR *bootp_message, UINT option, UINT size, UCHAR *value, UINT *index)
{                                              
 800845e:	b580      	push	{r7, lr}
 8008460:	b084      	sub	sp, #16
 8008462:	af00      	add	r7, sp, #0
 8008464:	60f8      	str	r0, [r7, #12]
 8008466:	60b9      	str	r1, [r7, #8]
 8008468:	607a      	str	r2, [r7, #4]
 800846a:	603b      	str	r3, [r7, #0]
                    
    /* Store the option.  */
    *(bootp_message + (*index)) = (UCHAR)option;
 800846c:	69bb      	ldr	r3, [r7, #24]
 800846e:	681b      	ldr	r3, [r3, #0]
 8008470:	68fa      	ldr	r2, [r7, #12]
 8008472:	4413      	add	r3, r2
 8008474:	68ba      	ldr	r2, [r7, #8]
 8008476:	b2d2      	uxtb	r2, r2
 8008478:	701a      	strb	r2, [r3, #0]
    (*index) ++;
 800847a:	69bb      	ldr	r3, [r7, #24]
 800847c:	681b      	ldr	r3, [r3, #0]
 800847e:	1c5a      	adds	r2, r3, #1
 8008480:	69bb      	ldr	r3, [r7, #24]
 8008482:	601a      	str	r2, [r3, #0]

    /* Store the option size.  */
    *(bootp_message + (*index)) = (UCHAR)size; 
 8008484:	69bb      	ldr	r3, [r7, #24]
 8008486:	681b      	ldr	r3, [r3, #0]
 8008488:	68fa      	ldr	r2, [r7, #12]
 800848a:	4413      	add	r3, r2
 800848c:	687a      	ldr	r2, [r7, #4]
 800848e:	b2d2      	uxtb	r2, r2
 8008490:	701a      	strb	r2, [r3, #0]
    (*index) ++;
 8008492:	69bb      	ldr	r3, [r7, #24]
 8008494:	681b      	ldr	r3, [r3, #0]
 8008496:	1c5a      	adds	r2, r3, #1
 8008498:	69bb      	ldr	r3, [r7, #24]
 800849a:	601a      	str	r2, [r3, #0]

    /* Store the option value.  */
    _nx_dhcp_move_string(bootp_message + (*index), value, size);
 800849c:	69bb      	ldr	r3, [r7, #24]
 800849e:	681b      	ldr	r3, [r3, #0]
 80084a0:	68fa      	ldr	r2, [r7, #12]
 80084a2:	4413      	add	r3, r2
 80084a4:	687a      	ldr	r2, [r7, #4]
 80084a6:	6839      	ldr	r1, [r7, #0]
 80084a8:	4618      	mov	r0, r3
 80084aa:	f000 f90b 	bl	80086c4 <_nx_dhcp_move_string>
    (*index) += size;    
 80084ae:	69bb      	ldr	r3, [r7, #24]
 80084b0:	681a      	ldr	r2, [r3, #0]
 80084b2:	687b      	ldr	r3, [r7, #4]
 80084b4:	441a      	add	r2, r3
 80084b6:	69bb      	ldr	r3, [r7, #24]
 80084b8:	601a      	str	r2, [r3, #0]

    /* Return a successful completion.  */
    return(NX_SUCCESS);      
 80084ba:	2300      	movs	r3, #0
}
 80084bc:	4618      	mov	r0, r3
 80084be:	3710      	adds	r7, #16
 80084c0:	46bd      	mov	sp, r7
 80084c2:	bd80      	pop	{r7, pc}

080084c4 <_nx_dhcp_add_randomize>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
static ULONG _nx_dhcp_add_randomize(ULONG timeout)
{
 80084c4:	b580      	push	{r7, lr}
 80084c6:	b084      	sub	sp, #16
 80084c8:	af00      	add	r7, sp, #0
 80084ca:	6078      	str	r0, [r7, #4]
ULONG adjustment;

    /* Uniform random number chosen from the range -1 to +1 second as recommended by RFC2131, Section4.1, Page24. */

    /* Calculate random time adjustment in timer ticks from the range 0 to NX_IP_PERIODIC_RATE * 2.  */
    adjustment = (ULONG)NX_RAND() % ((NX_IP_PERIODIC_RATE << 1) + 1);
 80084cc:	f017 fef2 	bl	80202b4 <rand>
 80084d0:	4603      	mov	r3, r0
 80084d2:	4a12      	ldr	r2, [pc, #72]	; (800851c <_nx_dhcp_add_randomize+0x58>)
 80084d4:	fba2 1203 	umull	r1, r2, r2, r3
 80084d8:	0852      	lsrs	r2, r2, #1
 80084da:	21c9      	movs	r1, #201	; 0xc9
 80084dc:	fb01 f202 	mul.w	r2, r1, r2
 80084e0:	1a9b      	subs	r3, r3, r2
 80084e2:	60fb      	str	r3, [r7, #12]

    /* Check for adjustment.  */
    if (adjustment < NX_IP_PERIODIC_RATE)
 80084e4:	68fb      	ldr	r3, [r7, #12]
 80084e6:	2b63      	cmp	r3, #99	; 0x63
 80084e8:	d80e      	bhi.n	8008508 <_nx_dhcp_add_randomize+0x44>
    {

        /* Updated timeout, minus NX_IP_PERIODIC_RATE - adjustment.  */

        /* Check for timeout.  */
        if (timeout > (NX_IP_PERIODIC_RATE - adjustment))
 80084ea:	68fb      	ldr	r3, [r7, #12]
 80084ec:	f1c3 0364 	rsb	r3, r3, #100	; 0x64
 80084f0:	687a      	ldr	r2, [r7, #4]
 80084f2:	429a      	cmp	r2, r3
 80084f4:	d905      	bls.n	8008502 <_nx_dhcp_add_randomize+0x3e>
            timeout -= (ULONG)(NX_IP_PERIODIC_RATE - adjustment);
 80084f6:	68fa      	ldr	r2, [r7, #12]
 80084f8:	687b      	ldr	r3, [r7, #4]
 80084fa:	4413      	add	r3, r2
 80084fc:	3b64      	subs	r3, #100	; 0x64
 80084fe:	607b      	str	r3, [r7, #4]
 8008500:	e007      	b.n	8008512 <_nx_dhcp_add_randomize+0x4e>
        else
            timeout = 0;
 8008502:	2300      	movs	r3, #0
 8008504:	607b      	str	r3, [r7, #4]
 8008506:	e004      	b.n	8008512 <_nx_dhcp_add_randomize+0x4e>
    }
    else
    {

        /* Updated timeout, add adjustment- NX_IP_PERIODIC_RATE.  */
        timeout += (ULONG)(adjustment - NX_IP_PERIODIC_RATE);
 8008508:	68fa      	ldr	r2, [r7, #12]
 800850a:	687b      	ldr	r3, [r7, #4]
 800850c:	4413      	add	r3, r2
 800850e:	3b64      	subs	r3, #100	; 0x64
 8008510:	607b      	str	r3, [r7, #4]
    }

    return timeout;
 8008512:	687b      	ldr	r3, [r7, #4]
}
 8008514:	4618      	mov	r0, r3
 8008516:	3710      	adds	r7, #16
 8008518:	46bd      	mov	sp, r7
 800851a:	bd80      	pop	{r7, pc}
 800851c:	028c1979 	.word	0x028c1979

08008520 <_nx_dhcp_update_timeout>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
static ULONG _nx_dhcp_update_timeout(ULONG timeout)
{
 8008520:	b480      	push	{r7}
 8008522:	b083      	sub	sp, #12
 8008524:	af00      	add	r7, sp, #0
 8008526:	6078      	str	r0, [r7, #4]

    /* Timed out, double the timeout, limited to NX_DHCP_MAX_RETRANS_TIMEOUT */
    if ((2 * timeout) >= NX_DHCP_MAX_RETRANS_TIMEOUT)
 8008528:	687b      	ldr	r3, [r7, #4]
 800852a:	005b      	lsls	r3, r3, #1
 800852c:	f5b3 5fc8 	cmp.w	r3, #6400	; 0x1900
 8008530:	d303      	bcc.n	800853a <_nx_dhcp_update_timeout+0x1a>
    {

        /* Set the timeout as NX_DHCP_MAX_RETRANS_TIMEOUT.  */
        timeout = NX_DHCP_MAX_RETRANS_TIMEOUT;  
 8008532:	f44f 53c8 	mov.w	r3, #6400	; 0x1900
 8008536:	607b      	str	r3, [r7, #4]
 8008538:	e002      	b.n	8008540 <_nx_dhcp_update_timeout+0x20>
    }
    else
    {

        /* Double timeout value.  */
        timeout = timeout * 2;
 800853a:	687b      	ldr	r3, [r7, #4]
 800853c:	005b      	lsls	r3, r3, #1
 800853e:	607b      	str	r3, [r7, #4]
    }

    /* Return the sequence timeout.  */
    return(timeout);
 8008540:	687b      	ldr	r3, [r7, #4]
}
 8008542:	4618      	mov	r0, r3
 8008544:	370c      	adds	r7, #12
 8008546:	46bd      	mov	sp, r7
 8008548:	f85d 7b04 	ldr.w	r7, [sp], #4
 800854c:	4770      	bx	lr

0800854e <_nx_dhcp_update_renewal_timeout>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
static ULONG _nx_dhcp_update_renewal_timeout(ULONG timeout)
{
 800854e:	b480      	push	{r7}
 8008550:	b083      	sub	sp, #12
 8008552:	af00      	add	r7, sp, #0
 8008554:	6078      	str	r0, [r7, #4]

    /* check if the timeout is non zero */
    if (timeout != 0)
 8008556:	687b      	ldr	r3, [r7, #4]
 8008558:	2b00      	cmp	r3, #0
 800855a:	d010      	beq.n	800857e <_nx_dhcp_update_renewal_timeout+0x30>
    {

        /* Timed out, halve the timeout, limited to NX_DHCP_MIN_RENEW_TIMEOUT or
          the remaining timeout if it is less than NX_DHCP_MIN_RENEW_TIMEOUT */
        if (timeout > NX_DHCP_MIN_RENEW_TIMEOUT)
 800855c:	687b      	ldr	r3, [r7, #4]
 800855e:	f241 7270 	movw	r2, #6000	; 0x1770
 8008562:	4293      	cmp	r3, r2
 8008564:	d90b      	bls.n	800857e <_nx_dhcp_update_renewal_timeout+0x30>
        {

            /* Timeout can still decrease, either
               force it to the minimum or halve it */
            if (timeout > (2 * NX_DHCP_MIN_RENEW_TIMEOUT ))
 8008566:	687b      	ldr	r3, [r7, #4]
 8008568:	f642 62e0 	movw	r2, #12000	; 0x2ee0
 800856c:	4293      	cmp	r3, r2
 800856e:	d903      	bls.n	8008578 <_nx_dhcp_update_renewal_timeout+0x2a>
            {

                /* Halve timeout.  */
                timeout = timeout / 2;
 8008570:	687b      	ldr	r3, [r7, #4]
 8008572:	085b      	lsrs	r3, r3, #1
 8008574:	607b      	str	r3, [r7, #4]
 8008576:	e002      	b.n	800857e <_nx_dhcp_update_renewal_timeout+0x30>
            }
            else
            {

                /* set timeout to minimum.  */
                timeout =  NX_DHCP_MIN_RENEW_TIMEOUT ;
 8008578:	f241 7370 	movw	r3, #6000	; 0x1770
 800857c:	607b      	str	r3, [r7, #4]
            }
        }
    }

    /* Return the sequence timeout.  */
    return(timeout);
 800857e:	687b      	ldr	r3, [r7, #4]
}
 8008580:	4618      	mov	r0, r3
 8008582:	370c      	adds	r7, #12
 8008584:	46bd      	mov	sp, r7
 8008586:	f85d 7b04 	ldr.w	r7, [sp], #4
 800858a:	4770      	bx	lr

0800858c <_nx_dhcp_search_buffer>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
static UCHAR  *_nx_dhcp_search_buffer(UCHAR *option_message, UINT option, UINT length)
{
 800858c:	b480      	push	{r7}
 800858e:	b089      	sub	sp, #36	; 0x24
 8008590:	af00      	add	r7, sp, #0
 8008592:	60f8      	str	r0, [r7, #12]
 8008594:	60b9      	str	r1, [r7, #8]
 8008596:	607a      	str	r2, [r7, #4]
UCHAR   *data;
UINT    i;
UINT    size;

    /* Setup buffer pointer.  */
    data = option_message;
 8008598:	68fb      	ldr	r3, [r7, #12]
 800859a:	61fb      	str	r3, [r7, #28]
    i = 0;
 800859c:	2300      	movs	r3, #0
 800859e:	61bb      	str	r3, [r7, #24]

    /* Search as long as there are valid options.   */
    while (i < length - 1)
 80085a0:	e030      	b.n	8008604 <_nx_dhcp_search_buffer+0x78>
    {

        /* Simply skip any padding */
        if (*data == NX_DHCP_OPTION_PAD)
 80085a2:	69fb      	ldr	r3, [r7, #28]
 80085a4:	781b      	ldrb	r3, [r3, #0]
 80085a6:	2b00      	cmp	r3, #0
 80085a8:	d106      	bne.n	80085b8 <_nx_dhcp_search_buffer+0x2c>
        {

            data++;
 80085aa:	69fb      	ldr	r3, [r7, #28]
 80085ac:	3301      	adds	r3, #1
 80085ae:	61fb      	str	r3, [r7, #28]
            i++;
 80085b0:	69bb      	ldr	r3, [r7, #24]
 80085b2:	3301      	adds	r3, #1
 80085b4:	61bb      	str	r3, [r7, #24]
 80085b6:	e025      	b.n	8008604 <_nx_dhcp_search_buffer+0x78>
        }

        /* On a match, return a pointer to the size.  */
        else if (*data == option)
 80085b8:	69fb      	ldr	r3, [r7, #28]
 80085ba:	781b      	ldrb	r3, [r3, #0]
 80085bc:	461a      	mov	r2, r3
 80085be:	68bb      	ldr	r3, [r7, #8]
 80085c0:	4293      	cmp	r3, r2
 80085c2:	d10f      	bne.n	80085e4 <_nx_dhcp_search_buffer+0x58>
        {

            size = *(data + 1);
 80085c4:	69fb      	ldr	r3, [r7, #28]
 80085c6:	3301      	adds	r3, #1
 80085c8:	781b      	ldrb	r3, [r3, #0]
 80085ca:	617b      	str	r3, [r7, #20]

            /* Check if the option data is in the packet.  */
            if ((i + size + 1) > length)
 80085cc:	69ba      	ldr	r2, [r7, #24]
 80085ce:	697b      	ldr	r3, [r7, #20]
 80085d0:	4413      	add	r3, r2
 80085d2:	3301      	adds	r3, #1
 80085d4:	687a      	ldr	r2, [r7, #4]
 80085d6:	429a      	cmp	r2, r3
 80085d8:	d201      	bcs.n	80085de <_nx_dhcp_search_buffer+0x52>
                return(NX_NULL);
 80085da:	2300      	movs	r3, #0
 80085dc:	e018      	b.n	8008610 <_nx_dhcp_search_buffer+0x84>

            /* Return a pointer to the option size byte.  */
            return(data + 1);
 80085de:	69fb      	ldr	r3, [r7, #28]
 80085e0:	3301      	adds	r3, #1
 80085e2:	e015      	b.n	8008610 <_nx_dhcp_search_buffer+0x84>

        /* Otherwise skip the option by adding the size to the pointer.  */
        else
        {

            size = *(++data);
 80085e4:	69fb      	ldr	r3, [r7, #28]
 80085e6:	3301      	adds	r3, #1
 80085e8:	61fb      	str	r3, [r7, #28]
 80085ea:	69fb      	ldr	r3, [r7, #28]
 80085ec:	781b      	ldrb	r3, [r3, #0]
 80085ee:	617b      	str	r3, [r7, #20]

            /* skip the data plus the size byte */
            data += size + 1;
 80085f0:	697b      	ldr	r3, [r7, #20]
 80085f2:	3301      	adds	r3, #1
 80085f4:	69fa      	ldr	r2, [r7, #28]
 80085f6:	4413      	add	r3, r2
 80085f8:	61fb      	str	r3, [r7, #28]
            i += size + 1;
 80085fa:	697a      	ldr	r2, [r7, #20]
 80085fc:	69bb      	ldr	r3, [r7, #24]
 80085fe:	4413      	add	r3, r2
 8008600:	3301      	adds	r3, #1
 8008602:	61bb      	str	r3, [r7, #24]
    while (i < length - 1)
 8008604:	687b      	ldr	r3, [r7, #4]
 8008606:	3b01      	subs	r3, #1
 8008608:	69ba      	ldr	r2, [r7, #24]
 800860a:	429a      	cmp	r2, r3
 800860c:	d3c9      	bcc.n	80085a2 <_nx_dhcp_search_buffer+0x16>
        }
    }

    /* Return NULL to indicate the option was not found.  */
    return(NX_NULL);
 800860e:	2300      	movs	r3, #0
}
 8008610:	4618      	mov	r0, r3
 8008612:	3724      	adds	r7, #36	; 0x24
 8008614:	46bd      	mov	sp, r7
 8008616:	f85d 7b04 	ldr.w	r7, [sp], #4
 800861a:	4770      	bx	lr

0800861c <_nx_dhcp_get_data>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
static ULONG  _nx_dhcp_get_data(UCHAR *data, UINT size)
{
 800861c:	b480      	push	{r7}
 800861e:	b085      	sub	sp, #20
 8008620:	af00      	add	r7, sp, #0
 8008622:	6078      	str	r0, [r7, #4]
 8008624:	6039      	str	r1, [r7, #0]

ULONG   value = 0;
 8008626:	2300      	movs	r3, #0
 8008628:	60fb      	str	r3, [r7, #12]

   
    /* Process the data retrieval request.  */
    while (size-- > 0)
 800862a:	e007      	b.n	800863c <_nx_dhcp_get_data+0x20>
    {

        /* Build return value.  */
        value = (value << 8) | *data++;
 800862c:	68fb      	ldr	r3, [r7, #12]
 800862e:	021a      	lsls	r2, r3, #8
 8008630:	687b      	ldr	r3, [r7, #4]
 8008632:	1c59      	adds	r1, r3, #1
 8008634:	6079      	str	r1, [r7, #4]
 8008636:	781b      	ldrb	r3, [r3, #0]
 8008638:	4313      	orrs	r3, r2
 800863a:	60fb      	str	r3, [r7, #12]
    while (size-- > 0)
 800863c:	683b      	ldr	r3, [r7, #0]
 800863e:	1e5a      	subs	r2, r3, #1
 8008640:	603a      	str	r2, [r7, #0]
 8008642:	2b00      	cmp	r3, #0
 8008644:	d1f2      	bne.n	800862c <_nx_dhcp_get_data+0x10>
    }

    /* Return value.  */
    return(value);
 8008646:	68fb      	ldr	r3, [r7, #12]
}
 8008648:	4618      	mov	r0, r3
 800864a:	3714      	adds	r7, #20
 800864c:	46bd      	mov	sp, r7
 800864e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8008652:	4770      	bx	lr

08008654 <_nx_dhcp_store_data>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
static VOID  _nx_dhcp_store_data(UCHAR *data, UINT size, ULONG value)
{
 8008654:	b480      	push	{r7}
 8008656:	b085      	sub	sp, #20
 8008658:	af00      	add	r7, sp, #0
 800865a:	60f8      	str	r0, [r7, #12]
 800865c:	60b9      	str	r1, [r7, #8]
 800865e:	607a      	str	r2, [r7, #4]

    /* Make sure that data is left justified.  */
    switch (size)
 8008660:	68bb      	ldr	r3, [r7, #8]
 8008662:	2b03      	cmp	r3, #3
 8008664:	d011      	beq.n	800868a <_nx_dhcp_store_data+0x36>
 8008666:	68bb      	ldr	r3, [r7, #8]
 8008668:	2b03      	cmp	r3, #3
 800866a:	d812      	bhi.n	8008692 <_nx_dhcp_store_data+0x3e>
 800866c:	68bb      	ldr	r3, [r7, #8]
 800866e:	2b01      	cmp	r3, #1
 8008670:	d003      	beq.n	800867a <_nx_dhcp_store_data+0x26>
 8008672:	68bb      	ldr	r3, [r7, #8]
 8008674:	2b02      	cmp	r3, #2
 8008676:	d004      	beq.n	8008682 <_nx_dhcp_store_data+0x2e>
      
            value <<= 8;
            break;

        default:
            break;
 8008678:	e00b      	b.n	8008692 <_nx_dhcp_store_data+0x3e>
            value <<= 24;
 800867a:	687b      	ldr	r3, [r7, #4]
 800867c:	061b      	lsls	r3, r3, #24
 800867e:	607b      	str	r3, [r7, #4]
            break;
 8008680:	e008      	b.n	8008694 <_nx_dhcp_store_data+0x40>
            value <<= 16;
 8008682:	687b      	ldr	r3, [r7, #4]
 8008684:	041b      	lsls	r3, r3, #16
 8008686:	607b      	str	r3, [r7, #4]
            break;
 8008688:	e004      	b.n	8008694 <_nx_dhcp_store_data+0x40>
            value <<= 8;
 800868a:	687b      	ldr	r3, [r7, #4]
 800868c:	021b      	lsls	r3, r3, #8
 800868e:	607b      	str	r3, [r7, #4]
            break;
 8008690:	e000      	b.n	8008694 <_nx_dhcp_store_data+0x40>
            break;
 8008692:	bf00      	nop
    }

    /* Store the value.  */
    while (size-- > 0)
 8008694:	e00a      	b.n	80086ac <_nx_dhcp_store_data+0x58>
    {

        *data = (UCHAR) ((value >> 24) & 0xff);
 8008696:	687b      	ldr	r3, [r7, #4]
 8008698:	0e1b      	lsrs	r3, r3, #24
 800869a:	b2da      	uxtb	r2, r3
 800869c:	68fb      	ldr	r3, [r7, #12]
 800869e:	701a      	strb	r2, [r3, #0]
        data++;
 80086a0:	68fb      	ldr	r3, [r7, #12]
 80086a2:	3301      	adds	r3, #1
 80086a4:	60fb      	str	r3, [r7, #12]
        value <<= 8;
 80086a6:	687b      	ldr	r3, [r7, #4]
 80086a8:	021b      	lsls	r3, r3, #8
 80086aa:	607b      	str	r3, [r7, #4]
    while (size-- > 0)
 80086ac:	68bb      	ldr	r3, [r7, #8]
 80086ae:	1e5a      	subs	r2, r3, #1
 80086b0:	60ba      	str	r2, [r7, #8]
 80086b2:	2b00      	cmp	r3, #0
 80086b4:	d1ef      	bne.n	8008696 <_nx_dhcp_store_data+0x42>
    }
}
 80086b6:	bf00      	nop
 80086b8:	bf00      	nop
 80086ba:	3714      	adds	r7, #20
 80086bc:	46bd      	mov	sp, r7
 80086be:	f85d 7b04 	ldr.w	r7, [sp], #4
 80086c2:	4770      	bx	lr

080086c4 <_nx_dhcp_move_string>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
static VOID  _nx_dhcp_move_string(UCHAR *dest, UCHAR *source, UINT size)
{
 80086c4:	b480      	push	{r7}
 80086c6:	b085      	sub	sp, #20
 80086c8:	af00      	add	r7, sp, #0
 80086ca:	60f8      	str	r0, [r7, #12]
 80086cc:	60b9      	str	r1, [r7, #8]
 80086ce:	607a      	str	r2, [r7, #4]

    /* Loop to copy all bytes.  */
    while (size-- > 0)
 80086d0:	e007      	b.n	80086e2 <_nx_dhcp_move_string+0x1e>
    {
        
        /* Copy a byte.  */
        *dest++ = *source++;
 80086d2:	68ba      	ldr	r2, [r7, #8]
 80086d4:	1c53      	adds	r3, r2, #1
 80086d6:	60bb      	str	r3, [r7, #8]
 80086d8:	68fb      	ldr	r3, [r7, #12]
 80086da:	1c59      	adds	r1, r3, #1
 80086dc:	60f9      	str	r1, [r7, #12]
 80086de:	7812      	ldrb	r2, [r2, #0]
 80086e0:	701a      	strb	r2, [r3, #0]
    while (size-- > 0)
 80086e2:	687b      	ldr	r3, [r7, #4]
 80086e4:	1e5a      	subs	r2, r3, #1
 80086e6:	607a      	str	r2, [r7, #4]
 80086e8:	2b00      	cmp	r3, #0
 80086ea:	d1f2      	bne.n	80086d2 <_nx_dhcp_move_string+0xe>
    }
}
 80086ec:	bf00      	nop
 80086ee:	bf00      	nop
 80086f0:	3714      	adds	r7, #20
 80086f2:	46bd      	mov	sp, r7
 80086f4:	f85d 7b04 	ldr.w	r7, [sp], #4
 80086f8:	4770      	bx	lr

080086fa <_nx_dhcp_interface_record_find>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
static UINT _nx_dhcp_interface_record_find(NX_DHCP *dhcp_ptr, UINT iface_index, NX_DHCP_INTERFACE_RECORD **interface_record)
{
 80086fa:	b480      	push	{r7}
 80086fc:	b087      	sub	sp, #28
 80086fe:	af00      	add	r7, sp, #0
 8008700:	60f8      	str	r0, [r7, #12]
 8008702:	60b9      	str	r1, [r7, #8]
 8008704:	607a      	str	r2, [r7, #4]

UINT i;

    /* Find which DHCP Client interface record is assigned the input interface. */
    for (i = 0; i < NX_DHCP_CLIENT_MAX_RECORDS; i++) 
 8008706:	2300      	movs	r3, #0
 8008708:	617b      	str	r3, [r7, #20]
 800870a:	e02d      	b.n	8008768 <_nx_dhcp_interface_record_find+0x6e>
    {

        /* Check if this record is valid.  */
        if (dhcp_ptr -> nx_dhcp_interface_record[i].nx_dhcp_record_valid == NX_FALSE) 
 800870c:	68fa      	ldr	r2, [r7, #12]
 800870e:	697b      	ldr	r3, [r7, #20]
 8008710:	f44f 71d8 	mov.w	r1, #432	; 0x1b0
 8008714:	fb01 f303 	mul.w	r3, r1, r3
 8008718:	441a      	add	r2, r3
 800871a:	f641 538c 	movw	r3, #7564	; 0x1d8c
 800871e:	4413      	add	r3, r2
 8008720:	781b      	ldrb	r3, [r3, #0]
 8008722:	2b00      	cmp	r3, #0
 8008724:	d01c      	beq.n	8008760 <_nx_dhcp_interface_record_find+0x66>
            continue;

        /* Check if the interface index matches.  */
        if (dhcp_ptr -> nx_dhcp_interface_record[i].nx_dhcp_interface_index == iface_index)
 8008726:	68fa      	ldr	r2, [r7, #12]
 8008728:	697b      	ldr	r3, [r7, #20]
 800872a:	f44f 71d8 	mov.w	r1, #432	; 0x1b0
 800872e:	fb01 f303 	mul.w	r3, r1, r3
 8008732:	441a      	add	r2, r3
 8008734:	f641 53a8 	movw	r3, #7592	; 0x1da8
 8008738:	4413      	add	r3, r2
 800873a:	681b      	ldr	r3, [r3, #0]
 800873c:	68ba      	ldr	r2, [r7, #8]
 800873e:	429a      	cmp	r2, r3
 8008740:	d10f      	bne.n	8008762 <_nx_dhcp_interface_record_find+0x68>
        {

            /* Yes, we found the record.  */
            *interface_record = &dhcp_ptr -> nx_dhcp_interface_record[i];
 8008742:	697b      	ldr	r3, [r7, #20]
 8008744:	f44f 72d8 	mov.w	r2, #432	; 0x1b0
 8008748:	fb03 f202 	mul.w	r2, r3, r2
 800874c:	f641 5388 	movw	r3, #7560	; 0x1d88
 8008750:	4413      	add	r3, r2
 8008752:	68fa      	ldr	r2, [r7, #12]
 8008754:	4413      	add	r3, r2
 8008756:	1d1a      	adds	r2, r3, #4
 8008758:	687b      	ldr	r3, [r7, #4]
 800875a:	601a      	str	r2, [r3, #0]

            /* Return.  */
            return (NX_SUCCESS);
 800875c:	2300      	movs	r3, #0
 800875e:	e007      	b.n	8008770 <_nx_dhcp_interface_record_find+0x76>
            continue;
 8008760:	bf00      	nop
    for (i = 0; i < NX_DHCP_CLIENT_MAX_RECORDS; i++) 
 8008762:	697b      	ldr	r3, [r7, #20]
 8008764:	3301      	adds	r3, #1
 8008766:	617b      	str	r3, [r7, #20]
 8008768:	697b      	ldr	r3, [r7, #20]
 800876a:	2b00      	cmp	r3, #0
 800876c:	d0ce      	beq.n	800870c <_nx_dhcp_interface_record_find+0x12>
        }
    }

    /* No matching record found.  */
    return (NX_DHCP_INTERFACE_NOT_ENABLED);
 800876e:	23a4      	movs	r3, #164	; 0xa4
}
 8008770:	4618      	mov	r0, r3
 8008772:	371c      	adds	r7, #28
 8008774:	46bd      	mov	sp, r7
 8008776:	f85d 7b04 	ldr.w	r7, [sp], #4
 800877a:	4770      	bx	lr

0800877c <_nx_arp_dynamic_entry_delete>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
UINT  _nx_arp_dynamic_entry_delete(NX_IP *ip_ptr, NX_ARP *arp_ptr)
{
 800877c:	b580      	push	{r7, lr}
 800877e:	b088      	sub	sp, #32
 8008780:	af00      	add	r7, sp, #0
 8008782:	6078      	str	r0, [r7, #4]
 8008784:	6039      	str	r1, [r7, #0]
TX_INTERRUPT_SAVE_AREA
NX_PACKET *packet_ptr, *next_packet_ptr;


    /* Determine if this ARP entry is already active.  */
    if (arp_ptr -> nx_arp_active_list_head)
 8008786:	683b      	ldr	r3, [r7, #0]
 8008788:	69db      	ldr	r3, [r3, #28]
 800878a:	2b00      	cmp	r3, #0
 800878c:	d050      	beq.n	8008830 <_nx_arp_dynamic_entry_delete+0xb4>
{
unsigned int posture;
#ifdef TX_PORT_USE_BASEPRI
    __asm__ volatile ("MRS  %0, BASEPRI ": "=r" (posture));
#else
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 800878e:	f3ef 8310 	mrs	r3, PRIMASK
 8008792:	613b      	str	r3, [r7, #16]
#endif
    return(posture);
 8008794:	693b      	ldr	r3, [r7, #16]

__attribute__( ( always_inline ) ) static inline unsigned int __disable_interrupts(void)
{
unsigned int int_posture;

    int_posture = __get_interrupt_posture();
 8008796:	60fb      	str	r3, [r7, #12]

#ifdef TX_PORT_USE_BASEPRI
    __set_basepri_value(TX_PORT_BASEPRI);
#else
    __asm__ volatile ("CPSID i" : : : "memory");
 8008798:	b672      	cpsid	i
#endif
    return(int_posture);
 800879a:	68fb      	ldr	r3, [r7, #12]
    {

        /* Remove this dynamic ARP entry from the associated list.  */

        /* Disable interrupts.  */
        TX_DISABLE
 800879c:	61bb      	str	r3, [r7, #24]

        /* Determine if this is the only ARP entry on the list.  */
        if (arp_ptr == arp_ptr -> nx_arp_active_next)
 800879e:	683b      	ldr	r3, [r7, #0]
 80087a0:	695b      	ldr	r3, [r3, #20]
 80087a2:	683a      	ldr	r2, [r7, #0]
 80087a4:	429a      	cmp	r2, r3
 80087a6:	d104      	bne.n	80087b2 <_nx_arp_dynamic_entry_delete+0x36>
        {

            /* Remove the entry from the list.  */
            *(arp_ptr -> nx_arp_active_list_head) =  NX_NULL;
 80087a8:	683b      	ldr	r3, [r7, #0]
 80087aa:	69db      	ldr	r3, [r3, #28]
 80087ac:	2200      	movs	r2, #0
 80087ae:	601a      	str	r2, [r3, #0]
 80087b0:	e014      	b.n	80087dc <_nx_arp_dynamic_entry_delete+0x60>
        {

            /* Remove the entry from a list of more than one entry.  */

            /* Update the list head pointer.  */
            if (*(arp_ptr -> nx_arp_active_list_head) == arp_ptr)
 80087b2:	683b      	ldr	r3, [r7, #0]
 80087b4:	69db      	ldr	r3, [r3, #28]
 80087b6:	681b      	ldr	r3, [r3, #0]
 80087b8:	683a      	ldr	r2, [r7, #0]
 80087ba:	429a      	cmp	r2, r3
 80087bc:	d104      	bne.n	80087c8 <_nx_arp_dynamic_entry_delete+0x4c>
            {
                *(arp_ptr -> nx_arp_active_list_head) =  arp_ptr -> nx_arp_active_next;
 80087be:	683b      	ldr	r3, [r7, #0]
 80087c0:	69db      	ldr	r3, [r3, #28]
 80087c2:	683a      	ldr	r2, [r7, #0]
 80087c4:	6952      	ldr	r2, [r2, #20]
 80087c6:	601a      	str	r2, [r3, #0]
            }

            /* Update the links of the adjacent ARP entries.  */
            (arp_ptr -> nx_arp_active_next) -> nx_arp_active_previous = arp_ptr -> nx_arp_active_previous;
 80087c8:	683b      	ldr	r3, [r7, #0]
 80087ca:	695b      	ldr	r3, [r3, #20]
 80087cc:	683a      	ldr	r2, [r7, #0]
 80087ce:	6992      	ldr	r2, [r2, #24]
 80087d0:	619a      	str	r2, [r3, #24]
            (arp_ptr -> nx_arp_active_previous) -> nx_arp_active_next =  arp_ptr -> nx_arp_active_next;
 80087d2:	683b      	ldr	r3, [r7, #0]
 80087d4:	699b      	ldr	r3, [r3, #24]
 80087d6:	683a      	ldr	r2, [r7, #0]
 80087d8:	6952      	ldr	r2, [r2, #20]
 80087da:	615a      	str	r2, [r3, #20]
        }

        /* No longer active, clear the active list head.  */
        arp_ptr -> nx_arp_active_list_head =  NX_NULL;
 80087dc:	683b      	ldr	r3, [r7, #0]
 80087de:	2200      	movs	r2, #0
 80087e0:	61da      	str	r2, [r3, #28]

        /* Decrease the number of active ARP entries.  */
        ip_ptr -> nx_ip_arp_dynamic_active_count--;
 80087e2:	687b      	ldr	r3, [r7, #4]
 80087e4:	f8d3 36d8 	ldr.w	r3, [r3, #1752]	; 0x6d8
 80087e8:	1e5a      	subs	r2, r3, #1
 80087ea:	687b      	ldr	r3, [r7, #4]
 80087ec:	f8c3 26d8 	str.w	r2, [r3, #1752]	; 0x6d8

        /* Pickup the queued packets head pointer.  */
        next_packet_ptr =  arp_ptr -> nx_arp_packets_waiting;
 80087f0:	683b      	ldr	r3, [r7, #0]
 80087f2:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 80087f4:	61fb      	str	r3, [r7, #28]

        /* Clear the queued packets head pointer.  */
        arp_ptr -> nx_arp_packets_waiting =  NX_NULL;
 80087f6:	683b      	ldr	r3, [r7, #0]
 80087f8:	2200      	movs	r2, #0
 80087fa:	631a      	str	r2, [r3, #48]	; 0x30
 80087fc:	69bb      	ldr	r3, [r7, #24]
 80087fe:	60bb      	str	r3, [r7, #8]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 8008800:	68bb      	ldr	r3, [r7, #8]
 8008802:	f383 8810 	msr	PRIMASK, r3
}
 8008806:	bf00      	nop

        /* Restore interrupts.  */
        TX_RESTORE

        /* Loop to remove all queued packets.  */
        while (next_packet_ptr)
 8008808:	e00f      	b.n	800882a <_nx_arp_dynamic_entry_delete+0xae>
        {

            /* Pickup the packet pointer at the head of the queue.  */
            packet_ptr =  next_packet_ptr;
 800880a:	69fb      	ldr	r3, [r7, #28]
 800880c:	617b      	str	r3, [r7, #20]

            /* Move to the next packet in the queue.  */
            next_packet_ptr =  next_packet_ptr -> nx_packet_queue_next;
 800880e:	69fb      	ldr	r3, [r7, #28]
 8008810:	69db      	ldr	r3, [r3, #28]
 8008812:	61fb      	str	r3, [r7, #28]

            /* Clear the next packet queue pointer.  */
            packet_ptr -> nx_packet_queue_next =  NX_NULL;
 8008814:	697b      	ldr	r3, [r7, #20]
 8008816:	2200      	movs	r2, #0
 8008818:	61da      	str	r2, [r3, #28]

#ifndef NX_DISABLE_IP_INFO

            /* Increment the IP send packets dropped count.  */
            ip_ptr -> nx_ip_send_packets_dropped++;
 800881a:	687b      	ldr	r3, [r7, #4]
 800881c:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 800881e:	1c5a      	adds	r2, r3, #1
 8008820:	687b      	ldr	r3, [r7, #4]
 8008822:	655a      	str	r2, [r3, #84]	; 0x54
#endif

            /* Release the packet that was queued from the previous ARP entry.  */
            _nx_packet_transmit_release(packet_ptr);
 8008824:	6978      	ldr	r0, [r7, #20]
 8008826:	f003 fea5 	bl	800c574 <_nx_packet_transmit_release>
        while (next_packet_ptr)
 800882a:	69fb      	ldr	r3, [r7, #28]
 800882c:	2b00      	cmp	r3, #0
 800882e:	d1ec      	bne.n	800880a <_nx_arp_dynamic_entry_delete+0x8e>
        }
    }

    return(NX_SUCCESS);
 8008830:	2300      	movs	r3, #0
}
 8008832:	4618      	mov	r0, r3
 8008834:	3720      	adds	r7, #32
 8008836:	46bd      	mov	sp, r7
 8008838:	bd80      	pop	{r7, pc}
	...

0800883c <_nx_arp_enable>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
UINT  _nx_arp_enable(NX_IP *ip_ptr, VOID *arp_cache_memory, ULONG arp_cache_size)
{
 800883c:	b580      	push	{r7, lr}
 800883e:	b088      	sub	sp, #32
 8008840:	af00      	add	r7, sp, #0
 8008842:	60f8      	str	r0, [r7, #12]
 8008844:	60b9      	str	r1, [r7, #8]
 8008846:	607a      	str	r2, [r7, #4]

    /* If trace is enabled, insert this event into the trace buffer.  */
    NX_TRACE_IN_LINE_INSERT(NX_TRACE_ARP_ENABLE, ip_ptr, arp_cache_memory, arp_cache_size, 0, NX_TRACE_ARP_EVENTS, 0, 0);

    /* Clear the entire ARP cache.  */
    memset((void *)arp_cache_memory, 0, arp_cache_size);
 8008848:	687a      	ldr	r2, [r7, #4]
 800884a:	2100      	movs	r1, #0
 800884c:	68b8      	ldr	r0, [r7, #8]
 800884e:	f017 f815 	bl	801f87c <memset>

    /* Pickup starting address of ARP entry array.  */
    entry_ptr =  (NX_ARP *)arp_cache_memory;
 8008852:	68bb      	ldr	r3, [r7, #8]
 8008854:	61bb      	str	r3, [r7, #24]

    /* Determine how many ARP entries will fit in this cache area.  */
    arp_entries =  arp_cache_size / sizeof(NX_ARP);
 8008856:	687b      	ldr	r3, [r7, #4]
 8008858:	4a2d      	ldr	r2, [pc, #180]	; (8008910 <_nx_arp_enable+0xd4>)
 800885a:	fba2 2303 	umull	r2, r3, r2, r3
 800885e:	091b      	lsrs	r3, r3, #4
 8008860:	617b      	str	r3, [r7, #20]

    /* Initialize the forward pointers of available ARP entries.  */
    for (i = 0; i < (arp_entries - 1); i++)
 8008862:	2300      	movs	r3, #0
 8008864:	61fb      	str	r3, [r7, #28]
 8008866:	e00a      	b.n	800887e <_nx_arp_enable+0x42>
    {
        /* Setup each entry to point to the next entry.  */
        entry_ptr -> nx_arp_pool_next =  entry_ptr + 1;
 8008868:	69bb      	ldr	r3, [r7, #24]
 800886a:	f103 0234 	add.w	r2, r3, #52	; 0x34
 800886e:	69bb      	ldr	r3, [r7, #24]
 8008870:	60da      	str	r2, [r3, #12]
        entry_ptr++;
 8008872:	69bb      	ldr	r3, [r7, #24]
 8008874:	3334      	adds	r3, #52	; 0x34
 8008876:	61bb      	str	r3, [r7, #24]
    for (i = 0; i < (arp_entries - 1); i++)
 8008878:	69fb      	ldr	r3, [r7, #28]
 800887a:	3301      	adds	r3, #1
 800887c:	61fb      	str	r3, [r7, #28]
 800887e:	697b      	ldr	r3, [r7, #20]
 8008880:	3b01      	subs	r3, #1
 8008882:	69fa      	ldr	r2, [r7, #28]
 8008884:	429a      	cmp	r2, r3
 8008886:	d3ef      	bcc.n	8008868 <_nx_arp_enable+0x2c>
    }

    /* The entry now points to the last entry in the ARP array.  Set its
       next pointer to the first entry.  */
    entry_ptr -> nx_arp_pool_next =  (NX_ARP *)arp_cache_memory;
 8008888:	69bb      	ldr	r3, [r7, #24]
 800888a:	68ba      	ldr	r2, [r7, #8]
 800888c:	60da      	str	r2, [r3, #12]

    /* Initialize the backward pointers of available ARP entries.  */
    for (i = 0; i < (arp_entries - 1); i++)
 800888e:	2300      	movs	r3, #0
 8008890:	61fb      	str	r3, [r7, #28]
 8008892:	e00a      	b.n	80088aa <_nx_arp_enable+0x6e>
    {
        /* Setup each entry to point to the previous entry.  */
        entry_ptr -> nx_arp_pool_previous =  entry_ptr - 1;
 8008894:	69bb      	ldr	r3, [r7, #24]
 8008896:	f1a3 0234 	sub.w	r2, r3, #52	; 0x34
 800889a:	69bb      	ldr	r3, [r7, #24]
 800889c:	611a      	str	r2, [r3, #16]
        entry_ptr--;
 800889e:	69bb      	ldr	r3, [r7, #24]
 80088a0:	3b34      	subs	r3, #52	; 0x34
 80088a2:	61bb      	str	r3, [r7, #24]
    for (i = 0; i < (arp_entries - 1); i++)
 80088a4:	69fb      	ldr	r3, [r7, #28]
 80088a6:	3301      	adds	r3, #1
 80088a8:	61fb      	str	r3, [r7, #28]
 80088aa:	697b      	ldr	r3, [r7, #20]
 80088ac:	3b01      	subs	r3, #1
 80088ae:	69fa      	ldr	r2, [r7, #28]
 80088b0:	429a      	cmp	r2, r3
 80088b2:	d3ef      	bcc.n	8008894 <_nx_arp_enable+0x58>
    }

    /* The entry now points to the first entry, set the previous pointer
       to the last entry.  */
    entry_ptr -> nx_arp_pool_previous =  (entry_ptr + (arp_entries - 1));
 80088b4:	697b      	ldr	r3, [r7, #20]
 80088b6:	2234      	movs	r2, #52	; 0x34
 80088b8:	fb02 f303 	mul.w	r3, r2, r3
 80088bc:	3b34      	subs	r3, #52	; 0x34
 80088be:	69ba      	ldr	r2, [r7, #24]
 80088c0:	441a      	add	r2, r3
 80088c2:	69bb      	ldr	r3, [r7, #24]
 80088c4:	611a      	str	r2, [r3, #16]
       information in the IP structure.  */

    /* Setup the list head pointers in the IP instance.  At first all ARP
       entries are associated with the dynamic ARP list.  The static ARP list
       is NULL until static ARP entry calls are made.  */
    ip_ptr -> nx_ip_arp_static_list =   NX_NULL;
 80088c6:	68fb      	ldr	r3, [r7, #12]
 80088c8:	2200      	movs	r2, #0
 80088ca:	f8c3 26d0 	str.w	r2, [r3, #1744]	; 0x6d0
    ip_ptr -> nx_ip_arp_dynamic_list =  (NX_ARP *)arp_cache_memory;
 80088ce:	68fb      	ldr	r3, [r7, #12]
 80088d0:	68ba      	ldr	r2, [r7, #8]
 80088d2:	f8c3 26d4 	str.w	r2, [r3, #1748]	; 0x6d4

    /* Store the initial ARP cache information in the IP control block.  */
    ip_ptr -> nx_ip_arp_cache_memory  =  arp_cache_memory;
 80088d6:	68fb      	ldr	r3, [r7, #12]
 80088d8:	68ba      	ldr	r2, [r7, #8]
 80088da:	f8c3 26f8 	str.w	r2, [r3, #1784]	; 0x6f8
    ip_ptr -> nx_ip_arp_total_entries =  arp_entries;
 80088de:	68fb      	ldr	r3, [r7, #12]
 80088e0:	697a      	ldr	r2, [r7, #20]
 80088e2:	f8c3 26fc 	str.w	r2, [r3, #1788]	; 0x6fc

    /* Setup the ARP periodic update routine.  */
    ip_ptr -> nx_ip_arp_periodic_update =  _nx_arp_periodic_update;
 80088e6:	68fb      	ldr	r3, [r7, #12]
 80088e8:	4a0a      	ldr	r2, [pc, #40]	; (8008914 <_nx_arp_enable+0xd8>)
 80088ea:	f8c3 26e8 	str.w	r2, [r3, #1768]	; 0x6e8

    /* Setup the ARP queue process routine.  */
    ip_ptr -> nx_ip_arp_queue_process =  _nx_arp_queue_process;
 80088ee:	68fb      	ldr	r3, [r7, #12]
 80088f0:	4a09      	ldr	r2, [pc, #36]	; (8008918 <_nx_arp_enable+0xdc>)
 80088f2:	f8c3 26ec 	str.w	r2, [r3, #1772]	; 0x6ec

    /* Setup the ARP send packet routine.  */
    ip_ptr -> nx_ip_arp_packet_send =  _nx_arp_packet_send;
 80088f6:	68fb      	ldr	r3, [r7, #12]
 80088f8:	4a08      	ldr	r2, [pc, #32]	; (800891c <_nx_arp_enable+0xe0>)
 80088fa:	f8c3 26f0 	str.w	r2, [r3, #1776]	; 0x6f0

    /* Setup the ARP allocate service request pointer.  */
    ip_ptr -> nx_ip_arp_allocate =  _nx_arp_entry_allocate;
 80088fe:	68fb      	ldr	r3, [r7, #12]
 8008900:	4a07      	ldr	r2, [pc, #28]	; (8008920 <_nx_arp_enable+0xe4>)
 8008902:	f8c3 26e4 	str.w	r2, [r3, #1764]	; 0x6e4

    /* Return successful completion.  */
    return(NX_SUCCESS);
 8008906:	2300      	movs	r3, #0
    NX_PARAMETER_NOT_USED(arp_cache_memory);
    NX_PARAMETER_NOT_USED(arp_cache_size);

    return(NX_NOT_SUPPORTED);
#endif /* !NX_DISABLE_IPV4  */
}
 8008908:	4618      	mov	r0, r3
 800890a:	3720      	adds	r7, #32
 800890c:	46bd      	mov	sp, r7
 800890e:	bd80      	pop	{r7, pc}
 8008910:	4ec4ec4f 	.word	0x4ec4ec4f
 8008914:	080090f5 	.word	0x080090f5
 8008918:	080092ef 	.word	0x080092ef
 800891c:	08008fb1 	.word	0x08008fb1
 8008920:	08008925 	.word	0x08008925

08008924 <_nx_arp_entry_allocate>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
UINT  _nx_arp_entry_allocate(NX_IP *ip_ptr, NX_ARP **arp_list_ptr, UINT is_static)
{
 8008924:	b580      	push	{r7, lr}
 8008926:	b08a      	sub	sp, #40	; 0x28
 8008928:	af00      	add	r7, sp, #0
 800892a:	60f8      	str	r0, [r7, #12]
 800892c:	60b9      	str	r1, [r7, #8]
 800892e:	607a      	str	r2, [r7, #4]
NX_ARP *arp_entry;
UINT    status;


    /* Determine if there is an ARP entry available in the dynamic list.  */
    if (ip_ptr -> nx_ip_arp_dynamic_list)
 8008930:	68fb      	ldr	r3, [r7, #12]
 8008932:	f8d3 36d4 	ldr.w	r3, [r3, #1748]	; 0x6d4
 8008936:	2b00      	cmp	r3, #0
 8008938:	f000 80b4 	beq.w	8008aa4 <_nx_arp_entry_allocate+0x180>
    {

        /* Yes there are one or more free entries.  */

        /* Pickup pointer to last used dynamic ARP entry.  */
        arp_entry =  (ip_ptr -> nx_ip_arp_dynamic_list) -> nx_arp_pool_previous;
 800893c:	68fb      	ldr	r3, [r7, #12]
 800893e:	f8d3 36d4 	ldr.w	r3, [r3, #1748]	; 0x6d4
 8008942:	691b      	ldr	r3, [r3, #16]
 8008944:	623b      	str	r3, [r7, #32]

        /* Remove from the dynamic list. */
        _nx_arp_dynamic_entry_delete(ip_ptr, arp_entry);
 8008946:	6a39      	ldr	r1, [r7, #32]
 8008948:	68f8      	ldr	r0, [r7, #12]
 800894a:	f7ff ff17 	bl	800877c <_nx_arp_dynamic_entry_delete>
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 800894e:	f3ef 8310 	mrs	r3, PRIMASK
 8008952:	61bb      	str	r3, [r7, #24]
    return(posture);
 8008954:	69bb      	ldr	r3, [r7, #24]
    int_posture = __get_interrupt_posture();
 8008956:	617b      	str	r3, [r7, #20]
    __asm__ volatile ("CPSID i" : : : "memory");
 8008958:	b672      	cpsid	i
    return(int_posture);
 800895a:	697b      	ldr	r3, [r7, #20]

        /* Disable interrupts temporarily.  */
        TX_DISABLE
 800895c:	61fb      	str	r3, [r7, #28]

        /* Link the ARP entry at the head of the IP list.  */

        /* Determine if the ARP entry is being added to an empty list.  */
        if (*arp_list_ptr)
 800895e:	68bb      	ldr	r3, [r7, #8]
 8008960:	681b      	ldr	r3, [r3, #0]
 8008962:	2b00      	cmp	r3, #0
 8008964:	d014      	beq.n	8008990 <_nx_arp_entry_allocate+0x6c>
        {

            /* Add the ARP entry to the beginning of the nonempty ARP
               list.  */
            arp_entry -> nx_arp_active_list_head =  arp_list_ptr;
 8008966:	6a3b      	ldr	r3, [r7, #32]
 8008968:	68ba      	ldr	r2, [r7, #8]
 800896a:	61da      	str	r2, [r3, #28]
            arp_entry -> nx_arp_active_next =      *arp_list_ptr;
 800896c:	68bb      	ldr	r3, [r7, #8]
 800896e:	681a      	ldr	r2, [r3, #0]
 8008970:	6a3b      	ldr	r3, [r7, #32]
 8008972:	615a      	str	r2, [r3, #20]
            arp_entry -> nx_arp_active_previous =  (*arp_list_ptr) -> nx_arp_active_previous;
 8008974:	68bb      	ldr	r3, [r7, #8]
 8008976:	681b      	ldr	r3, [r3, #0]
 8008978:	699a      	ldr	r2, [r3, #24]
 800897a:	6a3b      	ldr	r3, [r7, #32]
 800897c:	619a      	str	r2, [r3, #24]
            (arp_entry -> nx_arp_active_previous) -> nx_arp_active_next =  arp_entry;
 800897e:	6a3b      	ldr	r3, [r7, #32]
 8008980:	699b      	ldr	r3, [r3, #24]
 8008982:	6a3a      	ldr	r2, [r7, #32]
 8008984:	615a      	str	r2, [r3, #20]
            (*arp_list_ptr) -> nx_arp_active_previous =  arp_entry;
 8008986:	68bb      	ldr	r3, [r7, #8]
 8008988:	681b      	ldr	r3, [r3, #0]
 800898a:	6a3a      	ldr	r2, [r7, #32]
 800898c:	619a      	str	r2, [r3, #24]
 800898e:	e00b      	b.n	80089a8 <_nx_arp_entry_allocate+0x84>
        }
        else
        {
            /* Empty list, just put the ARP entry at the beginning.  */
            arp_entry -> nx_arp_active_list_head =  arp_list_ptr;
 8008990:	6a3b      	ldr	r3, [r7, #32]
 8008992:	68ba      	ldr	r2, [r7, #8]
 8008994:	61da      	str	r2, [r3, #28]
            arp_entry -> nx_arp_active_next =       arp_entry;
 8008996:	6a3b      	ldr	r3, [r7, #32]
 8008998:	6a3a      	ldr	r2, [r7, #32]
 800899a:	615a      	str	r2, [r3, #20]
            arp_entry -> nx_arp_active_previous =   arp_entry;
 800899c:	6a3b      	ldr	r3, [r7, #32]
 800899e:	6a3a      	ldr	r2, [r7, #32]
 80089a0:	619a      	str	r2, [r3, #24]

            /* Now setup the list head.  */
            *arp_list_ptr =  arp_entry;
 80089a2:	68bb      	ldr	r3, [r7, #8]
 80089a4:	6a3a      	ldr	r2, [r7, #32]
 80089a6:	601a      	str	r2, [r3, #0]
        }

        /* Determine if this is a static entry. */
        if (is_static == NX_TRUE)
 80089a8:	687b      	ldr	r3, [r7, #4]
 80089aa:	2b01      	cmp	r3, #1
 80089ac:	d141      	bne.n	8008a32 <_nx_arp_entry_allocate+0x10e>
        {

            /* Remove this entry from the ARP dynamic list.  */

            /* Determine if this is the only ARP entry on the dynamic list.  */
            if (arp_entry == arp_entry -> nx_arp_pool_next)
 80089ae:	6a3b      	ldr	r3, [r7, #32]
 80089b0:	68db      	ldr	r3, [r3, #12]
 80089b2:	6a3a      	ldr	r2, [r7, #32]
 80089b4:	429a      	cmp	r2, r3
 80089b6:	d104      	bne.n	80089c2 <_nx_arp_entry_allocate+0x9e>
            {

                /* Remove the sole entry from the dynamic list head.  */
                ip_ptr -> nx_ip_arp_dynamic_list =  NX_NULL;
 80089b8:	68fb      	ldr	r3, [r7, #12]
 80089ba:	2200      	movs	r2, #0
 80089bc:	f8c3 26d4 	str.w	r2, [r3, #1748]	; 0x6d4
 80089c0:	e009      	b.n	80089d6 <_nx_arp_entry_allocate+0xb2>
            {

                /* Remove the entry from a list of more than one entry.  */

                /* Update the links of the adjacent ARP dynamic pool entries.  */
                (arp_entry -> nx_arp_pool_next) -> nx_arp_pool_previous = arp_entry -> nx_arp_pool_previous;
 80089c2:	6a3b      	ldr	r3, [r7, #32]
 80089c4:	68db      	ldr	r3, [r3, #12]
 80089c6:	6a3a      	ldr	r2, [r7, #32]
 80089c8:	6912      	ldr	r2, [r2, #16]
 80089ca:	611a      	str	r2, [r3, #16]
                (arp_entry -> nx_arp_pool_previous) -> nx_arp_pool_next = arp_entry -> nx_arp_pool_next;
 80089cc:	6a3b      	ldr	r3, [r7, #32]
 80089ce:	691b      	ldr	r3, [r3, #16]
 80089d0:	6a3a      	ldr	r2, [r7, #32]
 80089d2:	68d2      	ldr	r2, [r2, #12]
 80089d4:	60da      	str	r2, [r3, #12]
            }

            /* Add the entry to the ARP static list.  */

            /* Determine if the ARP static list is empty.  */
            if (ip_ptr -> nx_ip_arp_static_list == NX_NULL)
 80089d6:	68fb      	ldr	r3, [r7, #12]
 80089d8:	f8d3 36d0 	ldr.w	r3, [r3, #1744]	; 0x6d0
 80089dc:	2b00      	cmp	r3, #0
 80089de:	d10a      	bne.n	80089f6 <_nx_arp_entry_allocate+0xd2>
            {

                /* Just place this single ARP entry on the list.  */
                arp_entry -> nx_arp_pool_next =     arp_entry;
 80089e0:	6a3b      	ldr	r3, [r7, #32]
 80089e2:	6a3a      	ldr	r2, [r7, #32]
 80089e4:	60da      	str	r2, [r3, #12]
                arp_entry -> nx_arp_pool_previous = arp_entry;
 80089e6:	6a3b      	ldr	r3, [r7, #32]
 80089e8:	6a3a      	ldr	r2, [r7, #32]
 80089ea:	611a      	str	r2, [r3, #16]
                ip_ptr -> nx_ip_arp_static_list =   arp_entry;
 80089ec:	68fb      	ldr	r3, [r7, #12]
 80089ee:	6a3a      	ldr	r2, [r7, #32]
 80089f0:	f8c3 26d0 	str.w	r2, [r3, #1744]	; 0x6d0
 80089f4:	e015      	b.n	8008a22 <_nx_arp_entry_allocate+0xfe>
            }
            else
            {

                /* Add to the end of the ARP static list.  */
                arp_entry -> nx_arp_pool_next = ip_ptr -> nx_ip_arp_static_list;
 80089f6:	68fb      	ldr	r3, [r7, #12]
 80089f8:	f8d3 26d0 	ldr.w	r2, [r3, #1744]	; 0x6d0
 80089fc:	6a3b      	ldr	r3, [r7, #32]
 80089fe:	60da      	str	r2, [r3, #12]
                arp_entry -> nx_arp_pool_previous = (ip_ptr -> nx_ip_arp_static_list) -> nx_arp_pool_previous;
 8008a00:	68fb      	ldr	r3, [r7, #12]
 8008a02:	f8d3 36d0 	ldr.w	r3, [r3, #1744]	; 0x6d0
 8008a06:	691a      	ldr	r2, [r3, #16]
 8008a08:	6a3b      	ldr	r3, [r7, #32]
 8008a0a:	611a      	str	r2, [r3, #16]
                ((ip_ptr -> nx_ip_arp_static_list) -> nx_arp_pool_previous) -> nx_arp_pool_next = arp_entry;
 8008a0c:	68fb      	ldr	r3, [r7, #12]
 8008a0e:	f8d3 36d0 	ldr.w	r3, [r3, #1744]	; 0x6d0
 8008a12:	691b      	ldr	r3, [r3, #16]
 8008a14:	6a3a      	ldr	r2, [r7, #32]
 8008a16:	60da      	str	r2, [r3, #12]
                (ip_ptr -> nx_ip_arp_static_list) -> nx_arp_pool_previous = arp_entry;
 8008a18:	68fb      	ldr	r3, [r7, #12]
 8008a1a:	f8d3 36d0 	ldr.w	r3, [r3, #1744]	; 0x6d0
 8008a1e:	6a3a      	ldr	r2, [r7, #32]
 8008a20:	611a      	str	r2, [r3, #16]
            }

#ifndef NX_DISABLE_ARP_INFO
            /* Increment the ARP static entry count.  */
            ip_ptr -> nx_ip_arp_static_entries++;
 8008a22:	68fb      	ldr	r3, [r7, #12]
 8008a24:	f8d3 3084 	ldr.w	r3, [r3, #132]	; 0x84
 8008a28:	1c5a      	adds	r2, r3, #1
 8008a2a:	68fb      	ldr	r3, [r7, #12]
 8008a2c:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84
 8008a30:	e02c      	b.n	8008a8c <_nx_arp_entry_allocate+0x168>
        }
        else  /* Allocate entry from dynamic list. */
        {

            /* Move this ARP entry to the front of the general ARP dynamic entry pool.  */
            if (arp_entry != ip_ptr -> nx_ip_arp_dynamic_list)
 8008a32:	68fb      	ldr	r3, [r7, #12]
 8008a34:	f8d3 36d4 	ldr.w	r3, [r3, #1748]	; 0x6d4
 8008a38:	6a3a      	ldr	r2, [r7, #32]
 8008a3a:	429a      	cmp	r2, r3
 8008a3c:	d01f      	beq.n	8008a7e <_nx_arp_entry_allocate+0x15a>

                /* The current ARP entry is not at the front of the list, so it
                   must be moved.  */

                /* Link up the neighbors first.  */
                (arp_entry -> nx_arp_pool_next) -> nx_arp_pool_previous = arp_entry -> nx_arp_pool_previous;
 8008a3e:	6a3b      	ldr	r3, [r7, #32]
 8008a40:	68db      	ldr	r3, [r3, #12]
 8008a42:	6a3a      	ldr	r2, [r7, #32]
 8008a44:	6912      	ldr	r2, [r2, #16]
 8008a46:	611a      	str	r2, [r3, #16]
                (arp_entry -> nx_arp_pool_previous) -> nx_arp_pool_next = arp_entry -> nx_arp_pool_next;
 8008a48:	6a3b      	ldr	r3, [r7, #32]
 8008a4a:	691b      	ldr	r3, [r3, #16]
 8008a4c:	6a3a      	ldr	r2, [r7, #32]
 8008a4e:	68d2      	ldr	r2, [r2, #12]
 8008a50:	60da      	str	r2, [r3, #12]

                /* Now link this ARP entry to the head of the list.  */
                arp_entry -> nx_arp_pool_next =  ip_ptr -> nx_ip_arp_dynamic_list;
 8008a52:	68fb      	ldr	r3, [r7, #12]
 8008a54:	f8d3 26d4 	ldr.w	r2, [r3, #1748]	; 0x6d4
 8008a58:	6a3b      	ldr	r3, [r7, #32]
 8008a5a:	60da      	str	r2, [r3, #12]
                arp_entry -> nx_arp_pool_previous =    (arp_entry -> nx_arp_pool_next) -> nx_arp_pool_previous;
 8008a5c:	6a3b      	ldr	r3, [r7, #32]
 8008a5e:	68db      	ldr	r3, [r3, #12]
 8008a60:	691a      	ldr	r2, [r3, #16]
 8008a62:	6a3b      	ldr	r3, [r7, #32]
 8008a64:	611a      	str	r2, [r3, #16]
                (arp_entry -> nx_arp_pool_previous) -> nx_arp_pool_next =  arp_entry;
 8008a66:	6a3b      	ldr	r3, [r7, #32]
 8008a68:	691b      	ldr	r3, [r3, #16]
 8008a6a:	6a3a      	ldr	r2, [r7, #32]
 8008a6c:	60da      	str	r2, [r3, #12]
                (arp_entry -> nx_arp_pool_next) -> nx_arp_pool_previous =  arp_entry;
 8008a6e:	6a3b      	ldr	r3, [r7, #32]
 8008a70:	68db      	ldr	r3, [r3, #12]
 8008a72:	6a3a      	ldr	r2, [r7, #32]
 8008a74:	611a      	str	r2, [r3, #16]

                /* Now set the list head to this ARP entry.  */
                ip_ptr -> nx_ip_arp_dynamic_list =  arp_entry;
 8008a76:	68fb      	ldr	r3, [r7, #12]
 8008a78:	6a3a      	ldr	r2, [r7, #32]
 8008a7a:	f8c3 26d4 	str.w	r2, [r3, #1748]	; 0x6d4
            }

            /* Increment the number of active dynamic entries.  */
            ip_ptr -> nx_ip_arp_dynamic_active_count++;
 8008a7e:	68fb      	ldr	r3, [r7, #12]
 8008a80:	f8d3 36d8 	ldr.w	r3, [r3, #1752]	; 0x6d8
 8008a84:	1c5a      	adds	r2, r3, #1
 8008a86:	68fb      	ldr	r3, [r7, #12]
 8008a88:	f8c3 26d8 	str.w	r2, [r3, #1752]	; 0x6d8
        }

        /* Set the entry type.  */
        arp_entry -> nx_arp_route_static = is_static;
 8008a8c:	6a3b      	ldr	r3, [r7, #32]
 8008a8e:	687a      	ldr	r2, [r7, #4]
 8008a90:	601a      	str	r2, [r3, #0]
 8008a92:	69fb      	ldr	r3, [r7, #28]
 8008a94:	613b      	str	r3, [r7, #16]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 8008a96:	693b      	ldr	r3, [r7, #16]
 8008a98:	f383 8810 	msr	PRIMASK, r3
}
 8008a9c:	bf00      	nop

        /* Restore interrupts.  */
        TX_RESTORE

        /* Setup a successful status return.  */
        status =  NX_SUCCESS;
 8008a9e:	2300      	movs	r3, #0
 8008aa0:	627b      	str	r3, [r7, #36]	; 0x24
 8008aa2:	e001      	b.n	8008aa8 <_nx_arp_entry_allocate+0x184>
    else
    {

        /* No more ARP entries are available, all the ARP entries must be
           allocated on the static list.  */
        status =  NX_NO_MORE_ENTRIES;
 8008aa4:	2317      	movs	r3, #23
 8008aa6:	627b      	str	r3, [r7, #36]	; 0x24
    }

    /* Return status to the caller.  */
    return(status);
 8008aa8:	6a7b      	ldr	r3, [r7, #36]	; 0x24
}
 8008aaa:	4618      	mov	r0, r3
 8008aac:	3728      	adds	r7, #40	; 0x28
 8008aae:	46bd      	mov	sp, r7
 8008ab0:	bd80      	pop	{r7, pc}

08008ab2 <_nx_arp_packet_deferred_receive>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
VOID  _nx_arp_packet_deferred_receive(NX_IP *ip_ptr, NX_PACKET *packet_ptr)
{
 8008ab2:	b580      	push	{r7, lr}
 8008ab4:	b088      	sub	sp, #32
 8008ab6:	af00      	add	r7, sp, #0
 8008ab8:	6078      	str	r0, [r7, #4]
 8008aba:	6039      	str	r1, [r7, #0]
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 8008abc:	f3ef 8310 	mrs	r3, PRIMASK
 8008ac0:	61bb      	str	r3, [r7, #24]
    return(posture);
 8008ac2:	69bb      	ldr	r3, [r7, #24]
    int_posture = __get_interrupt_posture();
 8008ac4:	617b      	str	r3, [r7, #20]
    __asm__ volatile ("CPSID i" : : : "memory");
 8008ac6:	b672      	cpsid	i
    return(int_posture);
 8008ac8:	697b      	ldr	r3, [r7, #20]

TX_INTERRUPT_SAVE_AREA


    /* Disable interrupts.  */
    TX_DISABLE
 8008aca:	61fb      	str	r3, [r7, #28]

    /* Add debug information. */
    NX_PACKET_DEBUG(__FILE__, __LINE__, packet_ptr);

    /* Check to see if ARP is enabled on this IP instance.  */
    if (!ip_ptr -> nx_ip_arp_queue_process)
 8008acc:	687b      	ldr	r3, [r7, #4]
 8008ace:	f8d3 36ec 	ldr.w	r3, [r3, #1772]	; 0x6ec
 8008ad2:	2b00      	cmp	r3, #0
 8008ad4:	d110      	bne.n	8008af8 <_nx_arp_packet_deferred_receive+0x46>

        /* ARP is not enabled.  */

#ifndef NX_DISABLE_ARP_INFO
        /* Increment the ARP invalid messages count...  */
        ip_ptr -> nx_ip_arp_invalid_messages++;
 8008ad6:	687b      	ldr	r3, [r7, #4]
 8008ad8:	f8d3 3080 	ldr.w	r3, [r3, #128]	; 0x80
 8008adc:	1c5a      	adds	r2, r3, #1
 8008ade:	687b      	ldr	r3, [r7, #4]
 8008ae0:	f8c3 2080 	str.w	r2, [r3, #128]	; 0x80
 8008ae4:	69fb      	ldr	r3, [r7, #28]
 8008ae6:	613b      	str	r3, [r7, #16]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 8008ae8:	693b      	ldr	r3, [r7, #16]
 8008aea:	f383 8810 	msr	PRIMASK, r3
}
 8008aee:	bf00      	nop

        /* Restore interrupts.  */
        TX_RESTORE

        /* Since ARP is not enabled, just release the packet.  */
        _nx_packet_release(packet_ptr);
 8008af0:	6838      	ldr	r0, [r7, #0]
 8008af2:	f003 fc89 	bl	800c408 <_nx_packet_release>

        /* Return to caller.  */
        return;
 8008af6:	e02f      	b.n	8008b58 <_nx_arp_packet_deferred_receive+0xa6>
    }

    /* Check to see if the ARP deferred processing queue is empty.  */
    if (ip_ptr -> nx_ip_arp_deferred_received_packet_head)
 8008af8:	687b      	ldr	r3, [r7, #4]
 8008afa:	f8d3 36dc 	ldr.w	r3, [r3, #1756]	; 0x6dc
 8008afe:	2b00      	cmp	r3, #0
 8008b00:	d011      	beq.n	8008b26 <_nx_arp_packet_deferred_receive+0x74>
    {

        /* Not empty, just place the packet at the end of the ARP deferred queue.  */
        (ip_ptr -> nx_ip_arp_deferred_received_packet_tail) -> nx_packet_queue_next =  packet_ptr;
 8008b02:	687b      	ldr	r3, [r7, #4]
 8008b04:	f8d3 36e0 	ldr.w	r3, [r3, #1760]	; 0x6e0
 8008b08:	683a      	ldr	r2, [r7, #0]
 8008b0a:	61da      	str	r2, [r3, #28]
        packet_ptr -> nx_packet_queue_next =  NX_NULL;
 8008b0c:	683b      	ldr	r3, [r7, #0]
 8008b0e:	2200      	movs	r2, #0
 8008b10:	61da      	str	r2, [r3, #28]
        ip_ptr -> nx_ip_arp_deferred_received_packet_tail =  packet_ptr;
 8008b12:	687b      	ldr	r3, [r7, #4]
 8008b14:	683a      	ldr	r2, [r7, #0]
 8008b16:	f8c3 26e0 	str.w	r2, [r3, #1760]	; 0x6e0
 8008b1a:	69fb      	ldr	r3, [r7, #28]
 8008b1c:	60fb      	str	r3, [r7, #12]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 8008b1e:	68fb      	ldr	r3, [r7, #12]
 8008b20:	f383 8810 	msr	PRIMASK, r3
}
 8008b24:	e018      	b.n	8008b58 <_nx_arp_packet_deferred_receive+0xa6>
    {

        /* Empty ARP deferred receive processing queue.  Just setup the head pointers and
           set the event flags to ensure the IP helper thread looks at the ARP deferred
           processing queue.  */
        ip_ptr -> nx_ip_arp_deferred_received_packet_head =  packet_ptr;
 8008b26:	687b      	ldr	r3, [r7, #4]
 8008b28:	683a      	ldr	r2, [r7, #0]
 8008b2a:	f8c3 26dc 	str.w	r2, [r3, #1756]	; 0x6dc
        ip_ptr -> nx_ip_arp_deferred_received_packet_tail =  packet_ptr;
 8008b2e:	687b      	ldr	r3, [r7, #4]
 8008b30:	683a      	ldr	r2, [r7, #0]
 8008b32:	f8c3 26e0 	str.w	r2, [r3, #1760]	; 0x6e0
        packet_ptr -> nx_packet_queue_next =                 NX_NULL;
 8008b36:	683b      	ldr	r3, [r7, #0]
 8008b38:	2200      	movs	r2, #0
 8008b3a:	61da      	str	r2, [r3, #28]
 8008b3c:	69fb      	ldr	r3, [r7, #28]
 8008b3e:	60bb      	str	r3, [r7, #8]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 8008b40:	68bb      	ldr	r3, [r7, #8]
 8008b42:	f383 8810 	msr	PRIMASK, r3
}
 8008b46:	bf00      	nop

        /* Restore interrupts.  */
        TX_RESTORE

        /* Wakeup IP helper thread to process the ARP deferred receive.  */
        tx_event_flags_set(&(ip_ptr -> nx_ip_events), NX_IP_ARP_REC_EVENT, TX_OR);
 8008b48:	687b      	ldr	r3, [r7, #4]
 8008b4a:	f503 7313 	add.w	r3, r3, #588	; 0x24c
 8008b4e:	2200      	movs	r2, #0
 8008b50:	2110      	movs	r1, #16
 8008b52:	4618      	mov	r0, r3
 8008b54:	f009 fcca 	bl	80124ec <_tx_event_flags_set>
    }
}
 8008b58:	3720      	adds	r7, #32
 8008b5a:	46bd      	mov	sp, r7
 8008b5c:	bd80      	pop	{r7, pc}
	...

08008b60 <_nx_arp_packet_receive>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
VOID  _nx_arp_packet_receive(NX_IP *ip_ptr, NX_PACKET *packet_ptr)
{
 8008b60:	b590      	push	{r4, r7, lr}
 8008b62:	b097      	sub	sp, #92	; 0x5c
 8008b64:	af02      	add	r7, sp, #8
 8008b66:	6078      	str	r0, [r7, #4]
 8008b68:	6039      	str	r1, [r7, #0]
ULONG         sender_physical_lsw;
ULONG         sender_ip_address;
ULONG         target_ip_address;
ULONG         message_type;
ULONG         index;
UCHAR         consumed = NX_FALSE;
 8008b6a:	2300      	movs	r3, #0
 8008b6c:	f887 304b 	strb.w	r3, [r7, #75]	; 0x4b
NX_INTERFACE *interface_ptr;


#ifndef NX_DISABLE_RX_SIZE_CHECKING
    /* Determine if the packet length is valid.  */
    if (packet_ptr -> nx_packet_length < NX_ARP_MESSAGE_SIZE)
 8008b70:	683b      	ldr	r3, [r7, #0]
 8008b72:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8008b74:	2b1b      	cmp	r3, #27
 8008b76:	d80a      	bhi.n	8008b8e <_nx_arp_packet_receive+0x2e>

        /* Invalid ARP message.  Release the packet and return.  */

#ifndef NX_DISABLE_ARP_INFO
        /* Increment the ARP invalid messages count.  */
        ip_ptr -> nx_ip_arp_invalid_messages++;
 8008b78:	687b      	ldr	r3, [r7, #4]
 8008b7a:	f8d3 3080 	ldr.w	r3, [r3, #128]	; 0x80
 8008b7e:	1c5a      	adds	r2, r3, #1
 8008b80:	687b      	ldr	r3, [r7, #4]
 8008b82:	f8c3 2080 	str.w	r2, [r3, #128]	; 0x80
#endif

        /* Invalid ARP message.  Just release the packet.  */
        _nx_packet_release(packet_ptr);
 8008b86:	6838      	ldr	r0, [r7, #0]
 8008b88:	f003 fc3e 	bl	800c408 <_nx_packet_release>

        /* Return to caller.  */
        return;
 8008b8c:	e20b      	b.n	8008fa6 <_nx_arp_packet_receive+0x446>
    }
#endif /* NX_DISABLE_RX_SIZE_CHECKING  */

    /* Setup a pointer to the ARP message.  */
    /*lint -e{927} -e{826} suppress cast of pointer to pointer, since it is necessary  */
    message_ptr =  (ULONG *)packet_ptr -> nx_packet_prepend_ptr;
 8008b8e:	683b      	ldr	r3, [r7, #0]
 8008b90:	689b      	ldr	r3, [r3, #8]
 8008b92:	643b      	str	r3, [r7, #64]	; 0x40

    /* Endian swapping logic.  If NX_LITTLE_ENDIAN is specified, these macros will
       swap the endian of the ARP message.  */
    NX_CHANGE_ULONG_ENDIAN(*(message_ptr + 1));
 8008b94:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8008b96:	3304      	adds	r3, #4
 8008b98:	681a      	ldr	r2, [r3, #0]
 8008b9a:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8008b9c:	3304      	adds	r3, #4
 8008b9e:	ba12      	rev	r2, r2
 8008ba0:	601a      	str	r2, [r3, #0]
    NX_CHANGE_ULONG_ENDIAN(*(message_ptr + 2));
 8008ba2:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8008ba4:	3308      	adds	r3, #8
 8008ba6:	681a      	ldr	r2, [r3, #0]
 8008ba8:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8008baa:	3308      	adds	r3, #8
 8008bac:	ba12      	rev	r2, r2
 8008bae:	601a      	str	r2, [r3, #0]
    NX_CHANGE_ULONG_ENDIAN(*(message_ptr + 3));
 8008bb0:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8008bb2:	330c      	adds	r3, #12
 8008bb4:	681a      	ldr	r2, [r3, #0]
 8008bb6:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8008bb8:	330c      	adds	r3, #12
 8008bba:	ba12      	rev	r2, r2
 8008bbc:	601a      	str	r2, [r3, #0]
    NX_CHANGE_ULONG_ENDIAN(*(message_ptr + 4));
 8008bbe:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8008bc0:	3310      	adds	r3, #16
 8008bc2:	681a      	ldr	r2, [r3, #0]
 8008bc4:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8008bc6:	3310      	adds	r3, #16
 8008bc8:	ba12      	rev	r2, r2
 8008bca:	601a      	str	r2, [r3, #0]
    NX_CHANGE_ULONG_ENDIAN(*(message_ptr + 5));
 8008bcc:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8008bce:	3314      	adds	r3, #20
 8008bd0:	681a      	ldr	r2, [r3, #0]
 8008bd2:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8008bd4:	3314      	adds	r3, #20
 8008bd6:	ba12      	rev	r2, r2
 8008bd8:	601a      	str	r2, [r3, #0]
    NX_CHANGE_ULONG_ENDIAN(*(message_ptr + 6));
 8008bda:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8008bdc:	3318      	adds	r3, #24
 8008bde:	681a      	ldr	r2, [r3, #0]
 8008be0:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8008be2:	3318      	adds	r3, #24
 8008be4:	ba12      	rev	r2, r2
 8008be6:	601a      	str	r2, [r3, #0]

    /* Pickup the ARP message type.  */
    message_type =  (ULONG)(*(message_ptr + 1) & 0xFFFF);
 8008be8:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8008bea:	3304      	adds	r3, #4
 8008bec:	681b      	ldr	r3, [r3, #0]
 8008bee:	b29b      	uxth	r3, r3
 8008bf0:	63fb      	str	r3, [r7, #60]	; 0x3c

    /* Determine if the ARP message type is valid.  */
    if ((message_type != NX_ARP_OPTION_REQUEST) && (message_type != NX_ARP_OPTION_RESPONSE))
 8008bf2:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8008bf4:	2b01      	cmp	r3, #1
 8008bf6:	d00d      	beq.n	8008c14 <_nx_arp_packet_receive+0xb4>
 8008bf8:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8008bfa:	2b02      	cmp	r3, #2
 8008bfc:	d00a      	beq.n	8008c14 <_nx_arp_packet_receive+0xb4>

        /* Invalid ARP message.  Release the packet and return.  */

#ifndef NX_DISABLE_ARP_INFO
        /* Increment the ARP invalid messages count.  */
        ip_ptr -> nx_ip_arp_invalid_messages++;
 8008bfe:	687b      	ldr	r3, [r7, #4]
 8008c00:	f8d3 3080 	ldr.w	r3, [r3, #128]	; 0x80
 8008c04:	1c5a      	adds	r2, r3, #1
 8008c06:	687b      	ldr	r3, [r7, #4]
 8008c08:	f8c3 2080 	str.w	r2, [r3, #128]	; 0x80
#endif

        /* Invalid ARP message.  Just release the packet.  */
        _nx_packet_release(packet_ptr);
 8008c0c:	6838      	ldr	r0, [r7, #0]
 8008c0e:	f003 fbfb 	bl	800c408 <_nx_packet_release>

        /* Return to caller.  */
        return;
 8008c12:	e1c8      	b.n	8008fa6 <_nx_arp_packet_receive+0x446>
    }

    /* Pick up the sender's physical address from the message.  */
    sender_physical_msw =  (*(message_ptr + 2) >> 16);
 8008c14:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8008c16:	3308      	adds	r3, #8
 8008c18:	681b      	ldr	r3, [r3, #0]
 8008c1a:	0c1b      	lsrs	r3, r3, #16
 8008c1c:	63bb      	str	r3, [r7, #56]	; 0x38
    sender_physical_lsw =  (*(message_ptr + 2) << 16) | (*(message_ptr + 3) >> 16);
 8008c1e:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8008c20:	3308      	adds	r3, #8
 8008c22:	681b      	ldr	r3, [r3, #0]
 8008c24:	041a      	lsls	r2, r3, #16
 8008c26:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8008c28:	330c      	adds	r3, #12
 8008c2a:	681b      	ldr	r3, [r3, #0]
 8008c2c:	0c1b      	lsrs	r3, r3, #16
 8008c2e:	4313      	orrs	r3, r2
 8008c30:	637b      	str	r3, [r7, #52]	; 0x34
    sender_ip_address =    (*(message_ptr + 3) << 16) | (*(message_ptr + 4) >> 16);
 8008c32:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8008c34:	330c      	adds	r3, #12
 8008c36:	681b      	ldr	r3, [r3, #0]
 8008c38:	041a      	lsls	r2, r3, #16
 8008c3a:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8008c3c:	3310      	adds	r3, #16
 8008c3e:	681b      	ldr	r3, [r3, #0]
 8008c40:	0c1b      	lsrs	r3, r3, #16
 8008c42:	4313      	orrs	r3, r2
 8008c44:	633b      	str	r3, [r7, #48]	; 0x30
    target_ip_address =    *(message_ptr + 6);
 8008c46:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8008c48:	699b      	ldr	r3, [r3, #24]
 8008c4a:	62fb      	str	r3, [r7, #44]	; 0x2c

    /* Does the packet have an interface assigned? */
    if (packet_ptr -> nx_packet_address.nx_packet_interface_ptr == NX_NULL)
 8008c4c:	683b      	ldr	r3, [r7, #0]
 8008c4e:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8008c50:	2b00      	cmp	r3, #0
 8008c52:	d104      	bne.n	8008c5e <_nx_arp_packet_receive+0xfe>
    {

        /* No, so default it to the primary interface. */
        packet_ptr -> nx_packet_address.nx_packet_interface_ptr = &ip_ptr -> nx_ip_interface[0];
 8008c54:	687b      	ldr	r3, [r7, #4]
 8008c56:	f503 62e4 	add.w	r2, r3, #1824	; 0x720
 8008c5a:	683b      	ldr	r3, [r7, #0]
 8008c5c:	631a      	str	r2, [r3, #48]	; 0x30
    }

    /* Pickup the interface information from the incoming packet. */
    interface_ptr = packet_ptr -> nx_packet_address.nx_packet_interface_ptr;
 8008c5e:	683b      	ldr	r3, [r7, #0]
 8008c60:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8008c62:	62bb      	str	r3, [r7, #40]	; 0x28

    /* Determine if it is an IP address conflict when IP address probing.  */
    if ((interface_ptr -> nx_interface_ip_address == 0) &&
 8008c64:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8008c66:	695b      	ldr	r3, [r3, #20]
 8008c68:	2b00      	cmp	r3, #0
 8008c6a:	d12e      	bne.n	8008cca <_nx_arp_packet_receive+0x16a>
        (interface_ptr -> nx_interface_ip_probe_address != 0) &&
 8008c6c:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8008c6e:	6c5b      	ldr	r3, [r3, #68]	; 0x44
    if ((interface_ptr -> nx_interface_ip_address == 0) &&
 8008c70:	2b00      	cmp	r3, #0
 8008c72:	d02a      	beq.n	8008cca <_nx_arp_packet_receive+0x16a>
        ((sender_ip_address == interface_ptr -> nx_interface_ip_probe_address) ||
 8008c74:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8008c76:	6c5b      	ldr	r3, [r3, #68]	; 0x44
        (interface_ptr -> nx_interface_ip_probe_address != 0) &&
 8008c78:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 8008c7a:	429a      	cmp	r2, r3
 8008c7c:	d007      	beq.n	8008c8e <_nx_arp_packet_receive+0x12e>
        ((sender_ip_address == interface_ptr -> nx_interface_ip_probe_address) ||
 8008c7e:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8008c80:	2b00      	cmp	r3, #0
 8008c82:	d122      	bne.n	8008cca <_nx_arp_packet_receive+0x16a>
         ((sender_ip_address == 0) && (target_ip_address == interface_ptr -> nx_interface_ip_probe_address))))
 8008c84:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8008c86:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 8008c88:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 8008c8a:	429a      	cmp	r2, r3
 8008c8c:	d11d      	bne.n	8008cca <_nx_arp_packet_receive+0x16a>
    {

        /* Make sure the sender physical address is not ours.  */
        if ((sender_physical_msw != interface_ptr -> nx_interface_physical_address_msw) ||
 8008c8e:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8008c90:	68db      	ldr	r3, [r3, #12]
 8008c92:	6bba      	ldr	r2, [r7, #56]	; 0x38
 8008c94:	429a      	cmp	r2, r3
 8008c96:	d104      	bne.n	8008ca2 <_nx_arp_packet_receive+0x142>
            (sender_physical_lsw != interface_ptr -> nx_interface_physical_address_lsw))
 8008c98:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8008c9a:	691b      	ldr	r3, [r3, #16]
        if ((sender_physical_msw != interface_ptr -> nx_interface_physical_address_msw) ||
 8008c9c:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 8008c9e:	429a      	cmp	r2, r3
 8008ca0:	d00f      	beq.n	8008cc2 <_nx_arp_packet_receive+0x162>
        {

            /* Determine if there is a a IP address conflict notify handler.  */
            if (interface_ptr -> nx_interface_ip_conflict_notify_handler)
 8008ca2:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8008ca4:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 8008ca6:	2b00      	cmp	r3, #0
 8008ca8:	d00b      	beq.n	8008cc2 <_nx_arp_packet_receive+0x162>
            {

                /* A IP address conflict is present, call the notification handler.  */
                (interface_ptr -> nx_interface_ip_conflict_notify_handler)(ip_ptr, interface_ptr -> nx_interface_index, interface_ptr -> nx_interface_ip_probe_address,
 8008caa:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8008cac:	6c9c      	ldr	r4, [r3, #72]	; 0x48
 8008cae:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8008cb0:	79db      	ldrb	r3, [r3, #7]
 8008cb2:	4619      	mov	r1, r3
 8008cb4:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8008cb6:	6c5a      	ldr	r2, [r3, #68]	; 0x44
 8008cb8:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8008cba:	9300      	str	r3, [sp, #0]
 8008cbc:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8008cbe:	6878      	ldr	r0, [r7, #4]
 8008cc0:	47a0      	blx	r4
                                                                           sender_physical_msw, sender_physical_lsw);
            }
        }

        /* Release the packet. */
        _nx_packet_release(packet_ptr);
 8008cc2:	6838      	ldr	r0, [r7, #0]
 8008cc4:	f003 fba0 	bl	800c408 <_nx_packet_release>

        return;
 8008cc8:	e16d      	b.n	8008fa6 <_nx_arp_packet_receive+0x446>
    }

    /* Determine if it is an address conflict packet after set the IP address.  */
    if ((sender_ip_address != 0) && (sender_ip_address == interface_ptr -> nx_interface_ip_address))
 8008cca:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8008ccc:	2b00      	cmp	r3, #0
 8008cce:	d040      	beq.n	8008d52 <_nx_arp_packet_receive+0x1f2>
 8008cd0:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8008cd2:	695b      	ldr	r3, [r3, #20]
 8008cd4:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 8008cd6:	429a      	cmp	r2, r3
 8008cd8:	d13b      	bne.n	8008d52 <_nx_arp_packet_receive+0x1f2>
    {

        /* Is it sent from other devices. */
        if ((sender_physical_msw != packet_ptr -> nx_packet_address.nx_packet_interface_ptr -> nx_interface_physical_address_msw) ||
 8008cda:	683b      	ldr	r3, [r7, #0]
 8008cdc:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8008cde:	68db      	ldr	r3, [r3, #12]
 8008ce0:	6bba      	ldr	r2, [r7, #56]	; 0x38
 8008ce2:	429a      	cmp	r2, r3
 8008ce4:	d105      	bne.n	8008cf2 <_nx_arp_packet_receive+0x192>
            (sender_physical_lsw != packet_ptr -> nx_packet_address.nx_packet_interface_ptr -> nx_interface_physical_address_lsw))
 8008ce6:	683b      	ldr	r3, [r7, #0]
 8008ce8:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8008cea:	691b      	ldr	r3, [r3, #16]
        if ((sender_physical_msw != packet_ptr -> nx_packet_address.nx_packet_interface_ptr -> nx_interface_physical_address_msw) ||
 8008cec:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 8008cee:	429a      	cmp	r2, r3
 8008cf0:	d02b      	beq.n	8008d4a <_nx_arp_packet_receive+0x1ea>
        {

            /* Yes it is.  */
            if (packet_ptr -> nx_packet_address.nx_packet_interface_ptr -> nx_interface_arp_defend_timeout == 0)
 8008cf2:	683b      	ldr	r3, [r7, #0]
 8008cf4:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8008cf6:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8008cf8:	2b00      	cmp	r3, #0
 8008cfa:	d10a      	bne.n	8008d12 <_nx_arp_packet_receive+0x1b2>
            {

                /* Set defend timeout. */
                packet_ptr -> nx_packet_address.nx_packet_interface_ptr -> nx_interface_arp_defend_timeout = NX_ARP_DEFEND_INTERVAL;
 8008cfc:	683b      	ldr	r3, [r7, #0]
 8008cfe:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8008d00:	220a      	movs	r2, #10
 8008d02:	641a      	str	r2, [r3, #64]	; 0x40

                /* Send the announcement. */
                _nx_arp_packet_send(ip_ptr, sender_ip_address, packet_ptr -> nx_packet_address.nx_packet_interface_ptr);
 8008d04:	683b      	ldr	r3, [r7, #0]
 8008d06:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8008d08:	461a      	mov	r2, r3
 8008d0a:	6b39      	ldr	r1, [r7, #48]	; 0x30
 8008d0c:	6878      	ldr	r0, [r7, #4]
 8008d0e:	f000 f94f 	bl	8008fb0 <_nx_arp_packet_send>
            }

            /* Determine if there is a a IP address conflict notify handler.  */
            if (interface_ptr -> nx_interface_ip_conflict_notify_handler)
 8008d12:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8008d14:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 8008d16:	2b00      	cmp	r3, #0
 8008d18:	d00b      	beq.n	8008d32 <_nx_arp_packet_receive+0x1d2>
            {

                /* A IP address conflict is present, call the notification handler.  */
                (interface_ptr -> nx_interface_ip_conflict_notify_handler)(ip_ptr, interface_ptr -> nx_interface_index, interface_ptr -> nx_interface_ip_probe_address,
 8008d1a:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8008d1c:	6c9c      	ldr	r4, [r3, #72]	; 0x48
 8008d1e:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8008d20:	79db      	ldrb	r3, [r3, #7]
 8008d22:	4619      	mov	r1, r3
 8008d24:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8008d26:	6c5a      	ldr	r2, [r3, #68]	; 0x44
 8008d28:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8008d2a:	9300      	str	r3, [sp, #0]
 8008d2c:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8008d2e:	6878      	ldr	r0, [r7, #4]
 8008d30:	47a0      	blx	r4

            /* This is likely in response to our previous gratuitous ARP from another entity on the
               network has the same IP address.  */

            /* Determine if there is a gratuitous ARP response handler.  */
            if (ip_ptr -> nx_ip_arp_gratuitous_response_handler)
 8008d32:	687b      	ldr	r3, [r7, #4]
 8008d34:	f8d3 36f4 	ldr.w	r3, [r3, #1780]	; 0x6f4
 8008d38:	2b00      	cmp	r3, #0
 8008d3a:	d006      	beq.n	8008d4a <_nx_arp_packet_receive+0x1ea>
            {

                /* Yes, call the gratuitous ARP response handler. Note that it is responsible
                   for releasing the packet!  */
                (ip_ptr -> nx_ip_arp_gratuitous_response_handler)(ip_ptr, packet_ptr);
 8008d3c:	687b      	ldr	r3, [r7, #4]
 8008d3e:	f8d3 36f4 	ldr.w	r3, [r3, #1780]	; 0x6f4
 8008d42:	6839      	ldr	r1, [r7, #0]
 8008d44:	6878      	ldr	r0, [r7, #4]
 8008d46:	4798      	blx	r3

                return;
 8008d48:	e12d      	b.n	8008fa6 <_nx_arp_packet_receive+0x446>
            return;
#endif /* NX_ARP_DEFEND_BY_REPLY */
        }

        /* Release the conflict packet. */
        _nx_packet_release(packet_ptr);
 8008d4a:	6838      	ldr	r0, [r7, #0]
 8008d4c:	f003 fb5c 	bl	800c408 <_nx_packet_release>

        return;
 8008d50:	e129      	b.n	8008fa6 <_nx_arp_packet_receive+0x446>
    }

    /* Determine what type of ARP message this is.  Note that ARP requests must
       also specify this IP instance's IP address.  */
    if ((message_type == NX_ARP_OPTION_REQUEST) && (target_ip_address == (packet_ptr -> nx_packet_address.nx_packet_interface_ptr -> nx_interface_ip_address)))
 8008d52:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8008d54:	2b01      	cmp	r3, #1
 8008d56:	f040 808f 	bne.w	8008e78 <_nx_arp_packet_receive+0x318>
 8008d5a:	683b      	ldr	r3, [r7, #0]
 8008d5c:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8008d5e:	695b      	ldr	r3, [r3, #20]
 8008d60:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 8008d62:	429a      	cmp	r2, r3
 8008d64:	f040 8088 	bne.w	8008e78 <_nx_arp_packet_receive+0x318>
    {

#ifndef NX_DISABLE_ARP_INFO

        /* Increment the ARP requests received count.  */
        ip_ptr -> nx_ip_arp_requests_received++;
 8008d68:	687b      	ldr	r3, [r7, #4]
 8008d6a:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 8008d6c:	1c5a      	adds	r2, r3, #1
 8008d6e:	687b      	ldr	r3, [r7, #4]
 8008d70:	671a      	str	r2, [r3, #112]	; 0x70

        /* Increment the ARP responses sent count.  */
        ip_ptr -> nx_ip_arp_responses_sent++;
 8008d72:	687b      	ldr	r3, [r7, #4]
 8008d74:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 8008d76:	1c5a      	adds	r2, r3, #1
 8008d78:	687b      	ldr	r3, [r7, #4]
 8008d7a:	675a      	str	r2, [r3, #116]	; 0x74

        /* If trace is enabled, insert this event into the trace buffer.  */
        NX_TRACE_IN_LINE_INSERT(NX_TRACE_INTERNAL_ARP_RESPONSE_SEND, ip_ptr, sender_ip_address, packet_ptr, 0, NX_TRACE_INTERNAL_EVENTS, 0, 0);

        /* Set the ARP message type to ARP response.  */
        *(message_ptr + 1) =  (*(message_ptr + 1) & 0xFFFF0000) | NX_ARP_OPTION_RESPONSE;
 8008d7c:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8008d7e:	3304      	adds	r3, #4
 8008d80:	681a      	ldr	r2, [r3, #0]
 8008d82:	4b8a      	ldr	r3, [pc, #552]	; (8008fac <_nx_arp_packet_receive+0x44c>)
 8008d84:	4013      	ands	r3, r2
 8008d86:	6c3a      	ldr	r2, [r7, #64]	; 0x40
 8008d88:	3204      	adds	r2, #4
 8008d8a:	f043 0302 	orr.w	r3, r3, #2
 8008d8e:	6013      	str	r3, [r2, #0]


        /* Now fill in the new source and destination information for the ARP response.  */
        *(message_ptr + 2) =  (ULONG)(packet_ptr -> nx_packet_address.nx_packet_interface_ptr -> nx_interface_physical_address_msw << 16) |
 8008d90:	683b      	ldr	r3, [r7, #0]
 8008d92:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8008d94:	68db      	ldr	r3, [r3, #12]
 8008d96:	0419      	lsls	r1, r3, #16
            (packet_ptr -> nx_packet_address.nx_packet_interface_ptr -> nx_interface_physical_address_lsw >> 16);
 8008d98:	683b      	ldr	r3, [r7, #0]
 8008d9a:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8008d9c:	691b      	ldr	r3, [r3, #16]
 8008d9e:	0c1a      	lsrs	r2, r3, #16
        *(message_ptr + 2) =  (ULONG)(packet_ptr -> nx_packet_address.nx_packet_interface_ptr -> nx_interface_physical_address_msw << 16) |
 8008da0:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8008da2:	3308      	adds	r3, #8
 8008da4:	430a      	orrs	r2, r1
 8008da6:	601a      	str	r2, [r3, #0]
        *(message_ptr + 3) =  (ULONG)(packet_ptr -> nx_packet_address.nx_packet_interface_ptr -> nx_interface_physical_address_lsw << 16) |
 8008da8:	683b      	ldr	r3, [r7, #0]
 8008daa:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8008dac:	691b      	ldr	r3, [r3, #16]
 8008dae:	0419      	lsls	r1, r3, #16
            (packet_ptr -> nx_packet_address.nx_packet_interface_ptr -> nx_interface_ip_address >> 16);
 8008db0:	683b      	ldr	r3, [r7, #0]
 8008db2:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8008db4:	695b      	ldr	r3, [r3, #20]
 8008db6:	0c1a      	lsrs	r2, r3, #16
        *(message_ptr + 3) =  (ULONG)(packet_ptr -> nx_packet_address.nx_packet_interface_ptr -> nx_interface_physical_address_lsw << 16) |
 8008db8:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8008dba:	330c      	adds	r3, #12
 8008dbc:	430a      	orrs	r2, r1
 8008dbe:	601a      	str	r2, [r3, #0]
        *(message_ptr + 4) =  (ULONG)(packet_ptr -> nx_packet_address.nx_packet_interface_ptr -> nx_interface_ip_address << 16) | sender_physical_msw;
 8008dc0:	683b      	ldr	r3, [r7, #0]
 8008dc2:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8008dc4:	695b      	ldr	r3, [r3, #20]
 8008dc6:	0419      	lsls	r1, r3, #16
 8008dc8:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8008dca:	3310      	adds	r3, #16
 8008dcc:	6bba      	ldr	r2, [r7, #56]	; 0x38
 8008dce:	430a      	orrs	r2, r1
 8008dd0:	601a      	str	r2, [r3, #0]
        *(message_ptr + 5) =  (ULONG)sender_physical_lsw;
 8008dd2:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8008dd4:	3314      	adds	r3, #20
 8008dd6:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 8008dd8:	601a      	str	r2, [r3, #0]
        *(message_ptr + 6) =  (ULONG)sender_ip_address;
 8008dda:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8008ddc:	3318      	adds	r3, #24
 8008dde:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 8008de0:	601a      	str	r2, [r3, #0]

        /* Endian swapping logic.  If NX_LITTLE_ENDIAN is specified, these macros will
           swap the endian of the ARP message.  */
        NX_CHANGE_ULONG_ENDIAN(*(message_ptr + 1));
 8008de2:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8008de4:	3304      	adds	r3, #4
 8008de6:	681a      	ldr	r2, [r3, #0]
 8008de8:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8008dea:	3304      	adds	r3, #4
 8008dec:	ba12      	rev	r2, r2
 8008dee:	601a      	str	r2, [r3, #0]
        NX_CHANGE_ULONG_ENDIAN(*(message_ptr + 2));
 8008df0:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8008df2:	3308      	adds	r3, #8
 8008df4:	681a      	ldr	r2, [r3, #0]
 8008df6:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8008df8:	3308      	adds	r3, #8
 8008dfa:	ba12      	rev	r2, r2
 8008dfc:	601a      	str	r2, [r3, #0]
        NX_CHANGE_ULONG_ENDIAN(*(message_ptr + 3));
 8008dfe:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8008e00:	330c      	adds	r3, #12
 8008e02:	681a      	ldr	r2, [r3, #0]
 8008e04:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8008e06:	330c      	adds	r3, #12
 8008e08:	ba12      	rev	r2, r2
 8008e0a:	601a      	str	r2, [r3, #0]
        NX_CHANGE_ULONG_ENDIAN(*(message_ptr + 4));
 8008e0c:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8008e0e:	3310      	adds	r3, #16
 8008e10:	681a      	ldr	r2, [r3, #0]
 8008e12:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8008e14:	3310      	adds	r3, #16
 8008e16:	ba12      	rev	r2, r2
 8008e18:	601a      	str	r2, [r3, #0]
        NX_CHANGE_ULONG_ENDIAN(*(message_ptr + 5));
 8008e1a:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8008e1c:	3314      	adds	r3, #20
 8008e1e:	681a      	ldr	r2, [r3, #0]
 8008e20:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8008e22:	3314      	adds	r3, #20
 8008e24:	ba12      	rev	r2, r2
 8008e26:	601a      	str	r2, [r3, #0]
        NX_CHANGE_ULONG_ENDIAN(*(message_ptr + 6));
 8008e28:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8008e2a:	3318      	adds	r3, #24
 8008e2c:	681a      	ldr	r2, [r3, #0]
 8008e2e:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8008e30:	3318      	adds	r3, #24
 8008e32:	ba12      	rev	r2, r2
 8008e34:	601a      	str	r2, [r3, #0]

        /* Make sure the packet length is set properly.  */
        packet_ptr -> nx_packet_length =  NX_ARP_MESSAGE_SIZE;
 8008e36:	683b      	ldr	r3, [r7, #0]
 8008e38:	221c      	movs	r2, #28
 8008e3a:	625a      	str	r2, [r3, #36]	; 0x24

        /* Setup the append pointer, since the received ARP packet can be padded
           with unnecessary bytes.  */
        packet_ptr -> nx_packet_append_ptr =  packet_ptr -> nx_packet_prepend_ptr + NX_ARP_MESSAGE_SIZE;
 8008e3c:	683b      	ldr	r3, [r7, #0]
 8008e3e:	689b      	ldr	r3, [r3, #8]
 8008e40:	f103 021c 	add.w	r2, r3, #28
 8008e44:	683b      	ldr	r3, [r7, #0]
 8008e46:	60da      	str	r2, [r3, #12]

        /* Send the ARP request to the driver.  */
        driver_request.nx_ip_driver_ptr =      ip_ptr;
 8008e48:	687b      	ldr	r3, [r7, #4]
 8008e4a:	623b      	str	r3, [r7, #32]
        driver_request.nx_ip_driver_command =  NX_LINK_ARP_RESPONSE_SEND;
 8008e4c:	2306      	movs	r3, #6
 8008e4e:	60bb      	str	r3, [r7, #8]
        driver_request.nx_ip_driver_packet =   packet_ptr;
 8008e50:	683b      	ldr	r3, [r7, #0]
 8008e52:	61bb      	str	r3, [r7, #24]
        driver_request.nx_ip_driver_physical_address_msw =  sender_physical_msw;
 8008e54:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8008e56:	613b      	str	r3, [r7, #16]
        driver_request.nx_ip_driver_physical_address_lsw =  sender_physical_lsw;
 8008e58:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8008e5a:	617b      	str	r3, [r7, #20]
        driver_request.nx_ip_driver_interface            =  packet_ptr -> nx_packet_address.nx_packet_interface_ptr;
 8008e5c:	683b      	ldr	r3, [r7, #0]
 8008e5e:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8008e60:	627b      	str	r3, [r7, #36]	; 0x24

        /* If trace is enabled, insert this event into the trace buffer.  */
        NX_TRACE_IN_LINE_INSERT(NX_TRACE_INTERNAL_IO_DRIVER_ARP_RESPONSE_SEND, ip_ptr, packet_ptr, packet_ptr -> nx_packet_length, 0, NX_TRACE_INTERNAL_EVENTS, 0, 0);

        /* No need to update interface.  When responding to an ARP request, use the same interface where the request was received. */
        (packet_ptr -> nx_packet_address.nx_packet_interface_ptr -> nx_interface_link_driver_entry)(&driver_request);
 8008e62:	683b      	ldr	r3, [r7, #0]
 8008e64:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8008e66:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 8008e68:	f107 0208 	add.w	r2, r7, #8
 8008e6c:	4610      	mov	r0, r2
 8008e6e:	4798      	blx	r3

        /* Set the consumed as NX_TRUE, do not need to release the packet.  */
        consumed = NX_TRUE;
 8008e70:	2301      	movs	r3, #1
 8008e72:	f887 304b 	strb.w	r3, [r7, #75]	; 0x4b
 8008e76:	e00d      	b.n	8008e94 <_nx_arp_packet_receive+0x334>
        /* We have a response to a previous ARP request or Gratuitous ARP from another network entity.  */

#ifndef NX_DISABLE_ARP_INFO

        /* Check for the message type to see which counter to increment.  */
        if (message_type == NX_ARP_OPTION_REQUEST)
 8008e78:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8008e7a:	2b01      	cmp	r3, #1
 8008e7c:	d105      	bne.n	8008e8a <_nx_arp_packet_receive+0x32a>
        {

            /* Increment the ARP requests received count.  */
            ip_ptr -> nx_ip_arp_requests_received++;
 8008e7e:	687b      	ldr	r3, [r7, #4]
 8008e80:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 8008e82:	1c5a      	adds	r2, r3, #1
 8008e84:	687b      	ldr	r3, [r7, #4]
 8008e86:	671a      	str	r2, [r3, #112]	; 0x70
 8008e88:	e004      	b.n	8008e94 <_nx_arp_packet_receive+0x334>
        }
        else
        {

            /* Increment the ARP responses received count.  */
            ip_ptr -> nx_ip_arp_responses_received++;
 8008e8a:	687b      	ldr	r3, [r7, #4]
 8008e8c:	6f9b      	ldr	r3, [r3, #120]	; 0x78
 8008e8e:	1c5a      	adds	r2, r3, #1
 8008e90:	687b      	ldr	r3, [r7, #4]
 8008e92:	679a      	str	r2, [r3, #120]	; 0x78

    /* Now we need to search through the active ARP list for the IP address
       to see if there is a matching entry.  */

    /* Calculate the hash index for the sender IP address.  */
    index =  (UINT)((sender_ip_address + (sender_ip_address >> 8)) & NX_ARP_TABLE_MASK);
 8008e94:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8008e96:	0a1a      	lsrs	r2, r3, #8
 8008e98:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8008e9a:	4413      	add	r3, r2
 8008e9c:	f003 031f 	and.w	r3, r3, #31
 8008ea0:	64fb      	str	r3, [r7, #76]	; 0x4c

    /* Pickup the first ARP entry.  */
    arp_ptr = NX_NULL;
 8008ea2:	2300      	movs	r3, #0
 8008ea4:	647b      	str	r3, [r7, #68]	; 0x44

    /* Ignore anything from any ARP packet with a zero sender IP address. */
    if (sender_ip_address != 0)
 8008ea6:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8008ea8:	2b00      	cmp	r3, #0
 8008eaa:	d03a      	beq.n	8008f22 <_nx_arp_packet_receive+0x3c2>
    {
        /* Calculate the hash index for the sender IP address.  */
        index =  (UINT)((sender_ip_address + (sender_ip_address >> 8)) & NX_ROUTE_TABLE_MASK);
 8008eac:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8008eae:	0a1a      	lsrs	r2, r3, #8
 8008eb0:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8008eb2:	4413      	add	r3, r2
 8008eb4:	f003 031f 	and.w	r3, r3, #31
 8008eb8:	64fb      	str	r3, [r7, #76]	; 0x4c

        /* Pickup the first ARP entry.  */
        arp_ptr =  ip_ptr -> nx_ip_arp_table[index];
 8008eba:	687b      	ldr	r3, [r7, #4]
 8008ebc:	6cfa      	ldr	r2, [r7, #76]	; 0x4c
 8008ebe:	f502 72ca 	add.w	r2, r2, #404	; 0x194
 8008ec2:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 8008ec6:	647b      	str	r3, [r7, #68]	; 0x44
    }

    /* Loop to look for an ARP match.  */
    while (arp_ptr)
 8008ec8:	e02b      	b.n	8008f22 <_nx_arp_packet_receive+0x3c2>
    {

        /* Check for an IP match.  */
        if (arp_ptr -> nx_arp_ip_address == sender_ip_address)
 8008eca:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8008ecc:	6a1b      	ldr	r3, [r3, #32]
 8008ece:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 8008ed0:	429a      	cmp	r2, r3
 8008ed2:	d117      	bne.n	8008f04 <_nx_arp_packet_receive+0x3a4>
                }
            }
#endif /* NX_ENABLE_ARP_MAC_CHANGE_NOTIFICATION */

            /* No need to update the static ARP entry. */
            if (arp_ptr -> nx_arp_route_static)
 8008ed4:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8008ed6:	681b      	ldr	r3, [r3, #0]
 8008ed8:	2b00      	cmp	r3, #0
 8008eda:	d126      	bne.n	8008f2a <_nx_arp_packet_receive+0x3ca>
            {
                break;
            }

            /* Save the physical address found in this ARP response.  */
            arp_ptr -> nx_arp_physical_address_msw =  sender_physical_msw;
 8008edc:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8008ede:	6bba      	ldr	r2, [r7, #56]	; 0x38
 8008ee0:	625a      	str	r2, [r3, #36]	; 0x24
            arp_ptr -> nx_arp_physical_address_lsw =  sender_physical_lsw;
 8008ee2:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8008ee4:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 8008ee6:	629a      	str	r2, [r3, #40]	; 0x28

            /* Set the update rate to the expiration rate since we now have an ARP
               response.  */
            arp_ptr -> nx_arp_entry_next_update =  NX_ARP_EXPIRATION_RATE;
 8008ee8:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8008eea:	2200      	movs	r2, #0
 8008eec:	605a      	str	r2, [r3, #4]

            /* Reset the retry counter for this ARP entry.  */
            arp_ptr -> nx_arp_retries =  0;
 8008eee:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8008ef0:	2200      	movs	r2, #0
 8008ef2:	609a      	str	r2, [r3, #8]

            /* Set the interface attached to this packet. */
            arp_ptr -> nx_arp_ip_interface = interface_ptr;
 8008ef4:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8008ef6:	6aba      	ldr	r2, [r7, #40]	; 0x28
 8008ef8:	62da      	str	r2, [r3, #44]	; 0x2c

            /* Call queue send function to send the packet queued up.  */
            _nx_arp_queue_send(ip_ptr, arp_ptr);
 8008efa:	6c79      	ldr	r1, [r7, #68]	; 0x44
 8008efc:	6878      	ldr	r0, [r7, #4]
 8008efe:	f000 fa29 	bl	8009354 <_nx_arp_queue_send>

            /* Yes, we found a match.  Get out of the loop!  */
            break;
 8008f02:	e013      	b.n	8008f2c <_nx_arp_packet_receive+0x3cc>
        }

        /* Move to the next active ARP entry.  */
        arp_ptr =  arp_ptr -> nx_arp_active_next;
 8008f04:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8008f06:	695b      	ldr	r3, [r3, #20]
 8008f08:	647b      	str	r3, [r7, #68]	; 0x44

        /* Determine if we are at the end of the ARP list.  */
        if (arp_ptr == ip_ptr -> nx_ip_arp_table[index])
 8008f0a:	687b      	ldr	r3, [r7, #4]
 8008f0c:	6cfa      	ldr	r2, [r7, #76]	; 0x4c
 8008f0e:	f502 72ca 	add.w	r2, r2, #404	; 0x194
 8008f12:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 8008f16:	6c7a      	ldr	r2, [r7, #68]	; 0x44
 8008f18:	429a      	cmp	r2, r3
 8008f1a:	d102      	bne.n	8008f22 <_nx_arp_packet_receive+0x3c2>
        {

            /* Clear the ARP pointer.  */
            arp_ptr =  NX_NULL;
 8008f1c:	2300      	movs	r3, #0
 8008f1e:	647b      	str	r3, [r7, #68]	; 0x44
            break;
 8008f20:	e004      	b.n	8008f2c <_nx_arp_packet_receive+0x3cc>
    while (arp_ptr)
 8008f22:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8008f24:	2b00      	cmp	r3, #0
 8008f26:	d1d0      	bne.n	8008eca <_nx_arp_packet_receive+0x36a>
 8008f28:	e000      	b.n	8008f2c <_nx_arp_packet_receive+0x3cc>
                break;
 8008f2a:	bf00      	nop
        }
    }

    /* Determine if we have a packet to release. */
    if (consumed == NX_FALSE)
 8008f2c:	f897 304b 	ldrb.w	r3, [r7, #75]	; 0x4b
 8008f30:	2b00      	cmp	r3, #0
 8008f32:	d102      	bne.n	8008f3a <_nx_arp_packet_receive+0x3da>
    {
        _nx_packet_release(packet_ptr);
 8008f34:	6838      	ldr	r0, [r7, #0]
 8008f36:	f003 fa67 	bl	800c408 <_nx_packet_release>
    }

#ifndef NX_DISABLE_ARP_AUTO_ENTRY

    /* Determine if anything was found.  Ignore ARP messages with a zero IP sender address.   */
    if ((arp_ptr == NX_NULL) && (sender_ip_address != 0))
 8008f3a:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8008f3c:	2b00      	cmp	r3, #0
 8008f3e:	d132      	bne.n	8008fa6 <_nx_arp_packet_receive+0x446>
 8008f40:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8008f42:	2b00      	cmp	r3, #0
 8008f44:	d02f      	beq.n	8008fa6 <_nx_arp_packet_receive+0x446>
    {

        /* Calculate the hash index for the sender IP address.  */
        index =  (UINT)((sender_ip_address + (sender_ip_address >> 8)) & NX_ARP_TABLE_MASK);
 8008f46:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8008f48:	0a1a      	lsrs	r2, r3, #8
 8008f4a:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8008f4c:	4413      	add	r3, r2
 8008f4e:	f003 031f 	and.w	r3, r3, #31
 8008f52:	64fb      	str	r3, [r7, #76]	; 0x4c

        /* Allocate a new ARP entry in advance of the need to send to the IP
           address.  */
        if (((ip_ptr -> nx_ip_arp_allocate)(ip_ptr, &(ip_ptr -> nx_ip_arp_table[index]), NX_FALSE)) == NX_SUCCESS)
 8008f54:	687b      	ldr	r3, [r7, #4]
 8008f56:	f8d3 36e4 	ldr.w	r3, [r3, #1764]	; 0x6e4
 8008f5a:	6cfa      	ldr	r2, [r7, #76]	; 0x4c
 8008f5c:	f502 72ca 	add.w	r2, r2, #404	; 0x194
 8008f60:	0092      	lsls	r2, r2, #2
 8008f62:	6879      	ldr	r1, [r7, #4]
 8008f64:	4411      	add	r1, r2
 8008f66:	2200      	movs	r2, #0
 8008f68:	6878      	ldr	r0, [r7, #4]
 8008f6a:	4798      	blx	r3
 8008f6c:	4603      	mov	r3, r0
 8008f6e:	2b00      	cmp	r3, #0
 8008f70:	d119      	bne.n	8008fa6 <_nx_arp_packet_receive+0x446>
        {

            /* Setup a pointer to the new ARP entry.  */
            arp_ptr =  (ip_ptr -> nx_ip_arp_table[index]) -> nx_arp_active_previous;
 8008f72:	687b      	ldr	r3, [r7, #4]
 8008f74:	6cfa      	ldr	r2, [r7, #76]	; 0x4c
 8008f76:	f502 72ca 	add.w	r2, r2, #404	; 0x194
 8008f7a:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 8008f7e:	699b      	ldr	r3, [r3, #24]
 8008f80:	647b      	str	r3, [r7, #68]	; 0x44

            /* Setup the IP address and clear the physical mapping.  */
            arp_ptr -> nx_arp_ip_address =            sender_ip_address;
 8008f82:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8008f84:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 8008f86:	621a      	str	r2, [r3, #32]
            arp_ptr -> nx_arp_physical_address_msw =  sender_physical_msw;
 8008f88:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8008f8a:	6bba      	ldr	r2, [r7, #56]	; 0x38
 8008f8c:	625a      	str	r2, [r3, #36]	; 0x24
            arp_ptr -> nx_arp_physical_address_lsw =  sender_physical_lsw;
 8008f8e:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8008f90:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 8008f92:	629a      	str	r2, [r3, #40]	; 0x28
            arp_ptr -> nx_arp_entry_next_update =     NX_ARP_EXPIRATION_RATE;
 8008f94:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8008f96:	2200      	movs	r2, #0
 8008f98:	605a      	str	r2, [r3, #4]
            arp_ptr -> nx_arp_retries =               0;
 8008f9a:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8008f9c:	2200      	movs	r2, #0
 8008f9e:	609a      	str	r2, [r3, #8]
            arp_ptr -> nx_arp_ip_interface         =  interface_ptr;
 8008fa0:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8008fa2:	6aba      	ldr	r2, [r7, #40]	; 0x28
 8008fa4:	62da      	str	r2, [r3, #44]	; 0x2c
        }
    }
#endif /* NX_DISABLE_ARP_AUTO_ENTRY */
}
 8008fa6:	3754      	adds	r7, #84	; 0x54
 8008fa8:	46bd      	mov	sp, r7
 8008faa:	bd90      	pop	{r4, r7, pc}
 8008fac:	ffff0000 	.word	0xffff0000

08008fb0 <_nx_arp_packet_send>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
VOID  _nx_arp_packet_send(NX_IP *ip_ptr, ULONG destination_ip, NX_INTERFACE *nx_interface)
{
 8008fb0:	b580      	push	{r7, lr}
 8008fb2:	b08e      	sub	sp, #56	; 0x38
 8008fb4:	af00      	add	r7, sp, #0
 8008fb6:	60f8      	str	r0, [r7, #12]
 8008fb8:	60b9      	str	r1, [r7, #8]
 8008fba:	607a      	str	r2, [r7, #4]
NX_PACKET   *request_ptr;
ULONG       *message_ptr;
NX_IP_DRIVER driver_request;

    /* nx_interface must not be NX_NULL. */
    NX_ASSERT(nx_interface != NX_NULL);
 8008fbc:	687b      	ldr	r3, [r7, #4]
 8008fbe:	2b00      	cmp	r3, #0
 8008fc0:	d104      	bne.n	8008fcc <_nx_arp_packet_send+0x1c>
 8008fc2:	f04f 30ff 	mov.w	r0, #4294967295
 8008fc6:	f00b fdf5 	bl	8014bb4 <_tx_thread_sleep>
 8008fca:	e7fa      	b.n	8008fc2 <_nx_arp_packet_send+0x12>
    if (_nx_packet_allocate(ip_ptr -> nx_ip_auxiliary_packet_pool, &request_ptr, (NX_PHYSICAL_HEADER + NX_ARP_MESSAGE_SIZE), NX_NO_WAIT))
    {
        if (ip_ptr -> nx_ip_auxiliary_packet_pool != ip_ptr -> nx_ip_default_packet_pool)
#endif /* NX_ENABLE_DUAL_PACKET_POOL */
        {
            if (_nx_packet_allocate(ip_ptr -> nx_ip_default_packet_pool, &request_ptr, (NX_PHYSICAL_HEADER + NX_ARP_MESSAGE_SIZE), NX_NO_WAIT))
 8008fcc:	68fb      	ldr	r3, [r7, #12]
 8008fce:	f8d3 0138 	ldr.w	r0, [r3, #312]	; 0x138
 8008fd2:	f107 0130 	add.w	r1, r7, #48	; 0x30
 8008fd6:	2300      	movs	r3, #0
 8008fd8:	222c      	movs	r2, #44	; 0x2c
 8008fda:	f002 fdb1 	bl	800bb40 <_nx_packet_allocate>
 8008fde:	4603      	mov	r3, r0
 8008fe0:	2b00      	cmp	r3, #0
 8008fe2:	f040 8081 	bne.w	80090e8 <_nx_arp_packet_send+0x138>
    /* Add debug information. */
    NX_PACKET_DEBUG(__FILE__, __LINE__, request_ptr);

    /* Stamp the packet with the outgoing interface information. */
    /*lint -e{644} suppress variable might not be initialized, since "request_ptr" was initialized in _nx_packet_allocate. */
    request_ptr -> nx_packet_address.nx_packet_interface_ptr = nx_interface;
 8008fe6:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8008fe8:	687a      	ldr	r2, [r7, #4]
 8008fea:	631a      	str	r2, [r3, #48]	; 0x30

#ifndef NX_DISABLE_ARP_INFO
    /* Increment the ARP requests sent count.  */
    ip_ptr -> nx_ip_arp_requests_sent++;
 8008fec:	68fb      	ldr	r3, [r7, #12]
 8008fee:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 8008ff0:	1c5a      	adds	r2, r3, #1
 8008ff2:	68fb      	ldr	r3, [r7, #12]
 8008ff4:	66da      	str	r2, [r3, #108]	; 0x6c
    NX_TRACE_IN_LINE_INSERT(NX_TRACE_INTERNAL_ARP_REQUEST_SEND, ip_ptr, destination_ip, request_ptr, 0, NX_TRACE_INTERNAL_EVENTS, 0, 0);

    /* Build the ARP request packet.  */

    /* Setup the size of the ARP message.  */
    request_ptr -> nx_packet_length =  NX_ARP_MESSAGE_SIZE;
 8008ff6:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8008ff8:	221c      	movs	r2, #28
 8008ffa:	625a      	str	r2, [r3, #36]	; 0x24

    /* Setup the prepend pointer.  */
    request_ptr -> nx_packet_prepend_ptr -= NX_ARP_MESSAGE_SIZE;
 8008ffc:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8008ffe:	689a      	ldr	r2, [r3, #8]
 8009000:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8009002:	3a1c      	subs	r2, #28
 8009004:	609a      	str	r2, [r3, #8]

    /* Setup the pointer to the message area.  */
    /*lint -e{927} -e{826} suppress cast of pointer to pointer, since it is necessary  */
    message_ptr =  (ULONG *)request_ptr -> nx_packet_prepend_ptr;
 8009006:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8009008:	689b      	ldr	r3, [r3, #8]
 800900a:	637b      	str	r3, [r7, #52]	; 0x34

    /* Write the Hardware type into the message.  */
    *message_ptr =      (ULONG)(NX_ARP_HARDWARE_TYPE << 16) | (NX_ARP_PROTOCOL_TYPE);
 800900c:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800900e:	f44f 3284 	mov.w	r2, #67584	; 0x10800
 8009012:	601a      	str	r2, [r3, #0]
    *(message_ptr + 1) =  (ULONG)(NX_ARP_HARDWARE_SIZE << 24) | (NX_ARP_PROTOCOL_SIZE << 16) |
 8009014:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8009016:	3304      	adds	r3, #4
 8009018:	4a35      	ldr	r2, [pc, #212]	; (80090f0 <_nx_arp_packet_send+0x140>)
 800901a:	601a      	str	r2, [r3, #0]
        NX_ARP_OPTION_REQUEST;

    /*lint -e{613} suppress possible use of null pointer, since nx_interface must not be NULL.  */
    *(message_ptr + 2) =  (ULONG)(nx_interface -> nx_interface_physical_address_msw << 16) |
 800901c:	687b      	ldr	r3, [r7, #4]
 800901e:	68db      	ldr	r3, [r3, #12]
 8009020:	0419      	lsls	r1, r3, #16
        (nx_interface -> nx_interface_physical_address_lsw >> 16);
 8009022:	687b      	ldr	r3, [r7, #4]
 8009024:	691b      	ldr	r3, [r3, #16]
 8009026:	0c1a      	lsrs	r2, r3, #16
    *(message_ptr + 2) =  (ULONG)(nx_interface -> nx_interface_physical_address_msw << 16) |
 8009028:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800902a:	3308      	adds	r3, #8
 800902c:	430a      	orrs	r2, r1
 800902e:	601a      	str	r2, [r3, #0]
    *(message_ptr + 3) =  (ULONG)(nx_interface -> nx_interface_physical_address_lsw << 16) |
 8009030:	687b      	ldr	r3, [r7, #4]
 8009032:	691b      	ldr	r3, [r3, #16]
 8009034:	0419      	lsls	r1, r3, #16
        (nx_interface -> nx_interface_ip_address >> 16);
 8009036:	687b      	ldr	r3, [r7, #4]
 8009038:	695b      	ldr	r3, [r3, #20]
 800903a:	0c1a      	lsrs	r2, r3, #16
    *(message_ptr + 3) =  (ULONG)(nx_interface -> nx_interface_physical_address_lsw << 16) |
 800903c:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800903e:	330c      	adds	r3, #12
 8009040:	430a      	orrs	r2, r1
 8009042:	601a      	str	r2, [r3, #0]
    *(message_ptr + 4) =  (ULONG)(nx_interface -> nx_interface_ip_address << 16);
 8009044:	687b      	ldr	r3, [r7, #4]
 8009046:	695a      	ldr	r2, [r3, #20]
 8009048:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800904a:	3310      	adds	r3, #16
 800904c:	0412      	lsls	r2, r2, #16
 800904e:	601a      	str	r2, [r3, #0]
    *(message_ptr + 5) =  (ULONG)0;
 8009050:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8009052:	3314      	adds	r3, #20
 8009054:	2200      	movs	r2, #0
 8009056:	601a      	str	r2, [r3, #0]
    *(message_ptr + 6) =  (ULONG)destination_ip;
 8009058:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800905a:	3318      	adds	r3, #24
 800905c:	68ba      	ldr	r2, [r7, #8]
 800905e:	601a      	str	r2, [r3, #0]

    /* Endian swapping logic.  If NX_LITTLE_ENDIAN is specified, these macros will
       swap the endian of the ARP message.  */
    NX_CHANGE_ULONG_ENDIAN(*(message_ptr));
 8009060:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8009062:	681b      	ldr	r3, [r3, #0]
 8009064:	ba1a      	rev	r2, r3
 8009066:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8009068:	601a      	str	r2, [r3, #0]
    NX_CHANGE_ULONG_ENDIAN(*(message_ptr + 1));
 800906a:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800906c:	3304      	adds	r3, #4
 800906e:	681a      	ldr	r2, [r3, #0]
 8009070:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8009072:	3304      	adds	r3, #4
 8009074:	ba12      	rev	r2, r2
 8009076:	601a      	str	r2, [r3, #0]
    NX_CHANGE_ULONG_ENDIAN(*(message_ptr + 2));
 8009078:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800907a:	3308      	adds	r3, #8
 800907c:	681a      	ldr	r2, [r3, #0]
 800907e:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8009080:	3308      	adds	r3, #8
 8009082:	ba12      	rev	r2, r2
 8009084:	601a      	str	r2, [r3, #0]
    NX_CHANGE_ULONG_ENDIAN(*(message_ptr + 3));
 8009086:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8009088:	330c      	adds	r3, #12
 800908a:	681a      	ldr	r2, [r3, #0]
 800908c:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800908e:	330c      	adds	r3, #12
 8009090:	ba12      	rev	r2, r2
 8009092:	601a      	str	r2, [r3, #0]
    NX_CHANGE_ULONG_ENDIAN(*(message_ptr + 4));
 8009094:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8009096:	3310      	adds	r3, #16
 8009098:	681a      	ldr	r2, [r3, #0]
 800909a:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800909c:	3310      	adds	r3, #16
 800909e:	ba12      	rev	r2, r2
 80090a0:	601a      	str	r2, [r3, #0]
    NX_CHANGE_ULONG_ENDIAN(*(message_ptr + 5));
 80090a2:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 80090a4:	3314      	adds	r3, #20
 80090a6:	681a      	ldr	r2, [r3, #0]
 80090a8:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 80090aa:	3314      	adds	r3, #20
 80090ac:	ba12      	rev	r2, r2
 80090ae:	601a      	str	r2, [r3, #0]
    NX_CHANGE_ULONG_ENDIAN(*(message_ptr + 6));
 80090b0:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 80090b2:	3318      	adds	r3, #24
 80090b4:	681a      	ldr	r2, [r3, #0]
 80090b6:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 80090b8:	3318      	adds	r3, #24
 80090ba:	ba12      	rev	r2, r2
 80090bc:	601a      	str	r2, [r3, #0]

    /* Set up the driver request. */
    driver_request.nx_ip_driver_ptr =                   ip_ptr;
 80090be:	68fb      	ldr	r3, [r7, #12]
 80090c0:	62bb      	str	r3, [r7, #40]	; 0x28
    driver_request.nx_ip_driver_command =               NX_LINK_ARP_SEND;
 80090c2:	2305      	movs	r3, #5
 80090c4:	613b      	str	r3, [r7, #16]
    driver_request.nx_ip_driver_packet =                request_ptr;
 80090c6:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 80090c8:	623b      	str	r3, [r7, #32]
    driver_request.nx_ip_driver_physical_address_msw =  0xFFFFUL;
 80090ca:	f64f 73ff 	movw	r3, #65535	; 0xffff
 80090ce:	61bb      	str	r3, [r7, #24]
    driver_request.nx_ip_driver_physical_address_lsw =  0xFFFFFFFFUL;
 80090d0:	f04f 33ff 	mov.w	r3, #4294967295
 80090d4:	61fb      	str	r3, [r7, #28]
    driver_request.nx_ip_driver_interface            =  nx_interface;
 80090d6:	687b      	ldr	r3, [r7, #4]
 80090d8:	62fb      	str	r3, [r7, #44]	; 0x2c
    /* Add debug information. */
    NX_PACKET_DEBUG(__FILE__, __LINE__, request_ptr);

    /* Send the ARP request to the driver.  */
    /*lint -e{613} suppress possible use of null pointer, since nx_interface must not be NULL.  */
    (nx_interface -> nx_interface_link_driver_entry)(&driver_request);
 80090da:	687b      	ldr	r3, [r7, #4]
 80090dc:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 80090de:	f107 0210 	add.w	r2, r7, #16
 80090e2:	4610      	mov	r0, r2
 80090e4:	4798      	blx	r3
 80090e6:	e000      	b.n	80090ea <_nx_arp_packet_send+0x13a>
                return;
 80090e8:	bf00      	nop
}
 80090ea:	3738      	adds	r7, #56	; 0x38
 80090ec:	46bd      	mov	sp, r7
 80090ee:	bd80      	pop	{r7, pc}
 80090f0:	06040001 	.word	0x06040001

080090f4 <_nx_arp_periodic_update>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
VOID  _nx_arp_periodic_update(NX_IP *ip_ptr)
{
 80090f4:	b580      	push	{r7, lr}
 80090f6:	b08a      	sub	sp, #40	; 0x28
 80090f8:	af00      	add	r7, sp, #0
 80090fa:	6078      	str	r0, [r7, #4]
NX_PACKET *packet_ptr;
NX_PACKET *next_packet_ptr;


    /* Pickup pointer to ARP dynamic list.  */
    arp_entry =  ip_ptr -> nx_ip_arp_dynamic_list;
 80090fc:	687b      	ldr	r3, [r7, #4]
 80090fe:	f8d3 36d4 	ldr.w	r3, [r3, #1748]	; 0x6d4
 8009102:	623b      	str	r3, [r7, #32]

    /* Loop through the active ARP entries to see if they need updating.  */
    for (i = 0; i < ip_ptr -> nx_ip_arp_dynamic_active_count; i++)
 8009104:	2300      	movs	r3, #0
 8009106:	627b      	str	r3, [r7, #36]	; 0x24
 8009108:	e0af      	b.n	800926a <_nx_arp_periodic_update+0x176>
    {

        /* Check this ARP entry to see if it need updating.  */
        if (arp_entry -> nx_arp_entry_next_update)
 800910a:	6a3b      	ldr	r3, [r7, #32]
 800910c:	685b      	ldr	r3, [r3, #4]
 800910e:	2b00      	cmp	r3, #0
 8009110:	f000 80a5 	beq.w	800925e <_nx_arp_periodic_update+0x16a>
        {

            /* Decrement the next update field.  */
            arp_entry -> nx_arp_entry_next_update--;
 8009114:	6a3b      	ldr	r3, [r7, #32]
 8009116:	685b      	ldr	r3, [r3, #4]
 8009118:	1e5a      	subs	r2, r3, #1
 800911a:	6a3b      	ldr	r3, [r7, #32]
 800911c:	605a      	str	r2, [r3, #4]

            /* Determine if an ARP expiration is present.  */
            if (!arp_entry -> nx_arp_entry_next_update)
 800911e:	6a3b      	ldr	r3, [r7, #32]
 8009120:	685b      	ldr	r3, [r3, #4]
 8009122:	2b00      	cmp	r3, #0
 8009124:	f040 809b 	bne.w	800925e <_nx_arp_periodic_update+0x16a>
            {

                /* Yes, an ARP expiration is present.   */

                /* Determine if the retry counter has been exceeded.  */
                if (arp_entry -> nx_arp_retries == NX_ARP_MAXIMUM_RETRIES)
 8009128:	6a3b      	ldr	r3, [r7, #32]
 800912a:	689b      	ldr	r3, [r3, #8]
 800912c:	2b12      	cmp	r3, #18
 800912e:	f040 8086 	bne.w	800923e <_nx_arp_periodic_update+0x14a>
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 8009132:	f3ef 8310 	mrs	r3, PRIMASK
 8009136:	613b      	str	r3, [r7, #16]
    return(posture);
 8009138:	693b      	ldr	r3, [r7, #16]
    int_posture = __get_interrupt_posture();
 800913a:	60fb      	str	r3, [r7, #12]
    __asm__ volatile ("CPSID i" : : : "memory");
 800913c:	b672      	cpsid	i
    return(int_posture);
 800913e:	68fb      	ldr	r3, [r7, #12]

                    /* The number of retries has been exceeded. The entry is removed
                       from the active list and any queued packet is released.  */

                    /* Disable interrupts.  */
                    TX_DISABLE
 8009140:	61bb      	str	r3, [r7, #24]

                    /* This ARP entry has expired, remove it from the active ARP list.  Check to make
                       sure it is still active.  */
                    if (arp_entry -> nx_arp_active_list_head)
 8009142:	6a3b      	ldr	r3, [r7, #32]
 8009144:	69db      	ldr	r3, [r3, #28]
 8009146:	2b00      	cmp	r3, #0
 8009148:	d028      	beq.n	800919c <_nx_arp_periodic_update+0xa8>
                    {

                        /* Determine if this is the only ARP entry on the list.  */
                        if (arp_entry == arp_entry -> nx_arp_active_next)
 800914a:	6a3b      	ldr	r3, [r7, #32]
 800914c:	695b      	ldr	r3, [r3, #20]
 800914e:	6a3a      	ldr	r2, [r7, #32]
 8009150:	429a      	cmp	r2, r3
 8009152:	d104      	bne.n	800915e <_nx_arp_periodic_update+0x6a>
                        {

                            /* Remove the entry from the list.  */
                            *(arp_entry -> nx_arp_active_list_head) =  NX_NULL;
 8009154:	6a3b      	ldr	r3, [r7, #32]
 8009156:	69db      	ldr	r3, [r3, #28]
 8009158:	2200      	movs	r2, #0
 800915a:	601a      	str	r2, [r3, #0]
 800915c:	e014      	b.n	8009188 <_nx_arp_periodic_update+0x94>
                        {

                            /* Remove the entry from a list of more than one entry.  */

                            /* Update the list head pointer.  */
                            if (*(arp_entry -> nx_arp_active_list_head) == arp_entry)
 800915e:	6a3b      	ldr	r3, [r7, #32]
 8009160:	69db      	ldr	r3, [r3, #28]
 8009162:	681b      	ldr	r3, [r3, #0]
 8009164:	6a3a      	ldr	r2, [r7, #32]
 8009166:	429a      	cmp	r2, r3
 8009168:	d104      	bne.n	8009174 <_nx_arp_periodic_update+0x80>
                            {
                                *(arp_entry -> nx_arp_active_list_head) =  arp_entry -> nx_arp_active_next;
 800916a:	6a3b      	ldr	r3, [r7, #32]
 800916c:	69db      	ldr	r3, [r3, #28]
 800916e:	6a3a      	ldr	r2, [r7, #32]
 8009170:	6952      	ldr	r2, [r2, #20]
 8009172:	601a      	str	r2, [r3, #0]
                            }

                            /* Update the links of the adjacent ARP entries.  */
                            (arp_entry -> nx_arp_active_next) -> nx_arp_active_previous =
 8009174:	6a3b      	ldr	r3, [r7, #32]
 8009176:	695b      	ldr	r3, [r3, #20]
                                arp_entry -> nx_arp_active_previous;
 8009178:	6a3a      	ldr	r2, [r7, #32]
 800917a:	6992      	ldr	r2, [r2, #24]
                            (arp_entry -> nx_arp_active_next) -> nx_arp_active_previous =
 800917c:	619a      	str	r2, [r3, #24]
                            (arp_entry -> nx_arp_active_previous) -> nx_arp_active_next =
 800917e:	6a3b      	ldr	r3, [r7, #32]
 8009180:	699b      	ldr	r3, [r3, #24]
                                arp_entry -> nx_arp_active_next;
 8009182:	6a3a      	ldr	r2, [r7, #32]
 8009184:	6952      	ldr	r2, [r2, #20]
                            (arp_entry -> nx_arp_active_previous) -> nx_arp_active_next =
 8009186:	615a      	str	r2, [r3, #20]
                        }

                        /* Decrease the number of active ARP entries.  */
                        ip_ptr -> nx_ip_arp_dynamic_active_count--;
 8009188:	687b      	ldr	r3, [r7, #4]
 800918a:	f8d3 36d8 	ldr.w	r3, [r3, #1752]	; 0x6d8
 800918e:	1e5a      	subs	r2, r3, #1
 8009190:	687b      	ldr	r3, [r7, #4]
 8009192:	f8c3 26d8 	str.w	r2, [r3, #1752]	; 0x6d8

                        /* Clear the active head pointer.  */
                        arp_entry -> nx_arp_active_list_head =  NX_NULL;
 8009196:	6a3b      	ldr	r3, [r7, #32]
 8009198:	2200      	movs	r2, #0
 800919a:	61da      	str	r2, [r3, #28]
                    }

                    /* Determine if this is the only ARP entry on the dynamic list.  */
                    if (arp_entry != arp_entry -> nx_arp_pool_next)
 800919c:	6a3b      	ldr	r3, [r7, #32]
 800919e:	68db      	ldr	r3, [r3, #12]
 80091a0:	6a3a      	ldr	r2, [r7, #32]
 80091a2:	429a      	cmp	r2, r3
 80091a4:	d02a      	beq.n	80091fc <_nx_arp_periodic_update+0x108>
                        /* No. Place the ARP entry at the end of the dynamic ARP pool, which is where new
                           ARP requests are allocated from.  */

                        /* Remove the entry from a list of more than one entry.  */
                        /* Update the links of the adjacent ARP dynamic pool entries.  */
                        (arp_entry -> nx_arp_pool_next) -> nx_arp_pool_previous =
 80091a6:	6a3b      	ldr	r3, [r7, #32]
 80091a8:	68db      	ldr	r3, [r3, #12]
                            arp_entry -> nx_arp_pool_previous;
 80091aa:	6a3a      	ldr	r2, [r7, #32]
 80091ac:	6912      	ldr	r2, [r2, #16]
                        (arp_entry -> nx_arp_pool_next) -> nx_arp_pool_previous =
 80091ae:	611a      	str	r2, [r3, #16]
                        (arp_entry -> nx_arp_pool_previous) -> nx_arp_pool_next =
 80091b0:	6a3b      	ldr	r3, [r7, #32]
 80091b2:	691b      	ldr	r3, [r3, #16]
                            arp_entry -> nx_arp_pool_next;
 80091b4:	6a3a      	ldr	r2, [r7, #32]
 80091b6:	68d2      	ldr	r2, [r2, #12]
                        (arp_entry -> nx_arp_pool_previous) -> nx_arp_pool_next =
 80091b8:	60da      	str	r2, [r3, #12]

                        /* Update the list head pointer.  */
                        if (ip_ptr -> nx_ip_arp_dynamic_list == arp_entry)
 80091ba:	687b      	ldr	r3, [r7, #4]
 80091bc:	f8d3 36d4 	ldr.w	r3, [r3, #1748]	; 0x6d4
 80091c0:	6a3a      	ldr	r2, [r7, #32]
 80091c2:	429a      	cmp	r2, r3
 80091c4:	d104      	bne.n	80091d0 <_nx_arp_periodic_update+0xdc>
                        {
                            ip_ptr -> nx_ip_arp_dynamic_list =  arp_entry -> nx_arp_pool_next;
 80091c6:	6a3b      	ldr	r3, [r7, #32]
 80091c8:	68da      	ldr	r2, [r3, #12]
 80091ca:	687b      	ldr	r3, [r7, #4]
 80091cc:	f8c3 26d4 	str.w	r2, [r3, #1748]	; 0x6d4
                        }


                        /* Add ARP entry to the end of the list.  */
                        arp_entry -> nx_arp_pool_next =
                            ip_ptr -> nx_ip_arp_dynamic_list;
 80091d0:	687b      	ldr	r3, [r7, #4]
 80091d2:	f8d3 26d4 	ldr.w	r2, [r3, #1748]	; 0x6d4
                        arp_entry -> nx_arp_pool_next =
 80091d6:	6a3b      	ldr	r3, [r7, #32]
 80091d8:	60da      	str	r2, [r3, #12]
                        arp_entry -> nx_arp_pool_previous =
                            (ip_ptr -> nx_ip_arp_dynamic_list) -> nx_arp_pool_previous;
 80091da:	687b      	ldr	r3, [r7, #4]
 80091dc:	f8d3 36d4 	ldr.w	r3, [r3, #1748]	; 0x6d4
 80091e0:	691a      	ldr	r2, [r3, #16]
                        arp_entry -> nx_arp_pool_previous =
 80091e2:	6a3b      	ldr	r3, [r7, #32]
 80091e4:	611a      	str	r2, [r3, #16]
                        ((ip_ptr -> nx_ip_arp_dynamic_list) -> nx_arp_pool_previous) -> nx_arp_pool_next =
 80091e6:	687b      	ldr	r3, [r7, #4]
 80091e8:	f8d3 36d4 	ldr.w	r3, [r3, #1748]	; 0x6d4
 80091ec:	691b      	ldr	r3, [r3, #16]
 80091ee:	6a3a      	ldr	r2, [r7, #32]
 80091f0:	60da      	str	r2, [r3, #12]
                            arp_entry;
                        (ip_ptr -> nx_ip_arp_dynamic_list) -> nx_arp_pool_previous =   arp_entry;
 80091f2:	687b      	ldr	r3, [r7, #4]
 80091f4:	f8d3 36d4 	ldr.w	r3, [r3, #1748]	; 0x6d4
 80091f8:	6a3a      	ldr	r2, [r7, #32]
 80091fa:	611a      	str	r2, [r3, #16]
                    }

                    /* Pickup the queued packets head pointer.  */
                    next_packet_ptr =  arp_entry -> nx_arp_packets_waiting;
 80091fc:	6a3b      	ldr	r3, [r7, #32]
 80091fe:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8009200:	61fb      	str	r3, [r7, #28]

                    /* Clear the queued packets head pointer.  */
                    arp_entry -> nx_arp_packets_waiting =  NX_NULL;
 8009202:	6a3b      	ldr	r3, [r7, #32]
 8009204:	2200      	movs	r2, #0
 8009206:	631a      	str	r2, [r3, #48]	; 0x30
 8009208:	69bb      	ldr	r3, [r7, #24]
 800920a:	60bb      	str	r3, [r7, #8]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 800920c:	68bb      	ldr	r3, [r7, #8]
 800920e:	f383 8810 	msr	PRIMASK, r3
}
 8009212:	bf00      	nop

                    /* Restore interrupts.  */
                    TX_RESTORE

                    /* Loop to remove all queued packets.  */
                    while (next_packet_ptr)
 8009214:	e00f      	b.n	8009236 <_nx_arp_periodic_update+0x142>
                    {

                        /* Pickup the packet pointer at the head of the queue.  */
                        packet_ptr =  next_packet_ptr;
 8009216:	69fb      	ldr	r3, [r7, #28]
 8009218:	617b      	str	r3, [r7, #20]

                        /* Move to the next packet in the queue.  */
                        next_packet_ptr =  next_packet_ptr -> nx_packet_queue_next;
 800921a:	69fb      	ldr	r3, [r7, #28]
 800921c:	69db      	ldr	r3, [r3, #28]
 800921e:	61fb      	str	r3, [r7, #28]

                        /* Clear the next packet queue pointer.  */
                        packet_ptr -> nx_packet_queue_next =  NX_NULL;
 8009220:	697b      	ldr	r3, [r7, #20]
 8009222:	2200      	movs	r2, #0
 8009224:	61da      	str	r2, [r3, #28]

#ifndef NX_DISABLE_IP_INFO

                        /* Increment the IP send packets dropped count.  */
                        ip_ptr -> nx_ip_send_packets_dropped++;
 8009226:	687b      	ldr	r3, [r7, #4]
 8009228:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 800922a:	1c5a      	adds	r2, r3, #1
 800922c:	687b      	ldr	r3, [r7, #4]
 800922e:	655a      	str	r2, [r3, #84]	; 0x54
#endif

                        /* Release the packet that was queued for the expired ARP entry.  */
                        _nx_packet_transmit_release(packet_ptr);
 8009230:	6978      	ldr	r0, [r7, #20]
 8009232:	f003 f99f 	bl	800c574 <_nx_packet_transmit_release>
                    while (next_packet_ptr)
 8009236:	69fb      	ldr	r3, [r7, #28]
 8009238:	2b00      	cmp	r3, #0
 800923a:	d1ec      	bne.n	8009216 <_nx_arp_periodic_update+0x122>
 800923c:	e00f      	b.n	800925e <_nx_arp_periodic_update+0x16a>
                {

                    /* We haven't yet had a response to this ARP request so send it again!  */

                    /* Increment the ARP retry counter.  */
                    arp_entry -> nx_arp_retries++;
 800923e:	6a3b      	ldr	r3, [r7, #32]
 8009240:	689b      	ldr	r3, [r3, #8]
 8009242:	1c5a      	adds	r2, r3, #1
 8009244:	6a3b      	ldr	r3, [r7, #32]
 8009246:	609a      	str	r2, [r3, #8]

                    /* Setup the ARP update rate to the maximum value again.  */
                    arp_entry -> nx_arp_entry_next_update =  NX_ARP_UPDATE_RATE;
 8009248:	6a3b      	ldr	r3, [r7, #32]
 800924a:	220a      	movs	r2, #10
 800924c:	605a      	str	r2, [r3, #4]

                    /* Send the ARP request out.  */
                    _nx_arp_packet_send(ip_ptr, arp_entry -> nx_arp_ip_address, arp_entry -> nx_arp_ip_interface);
 800924e:	6a3b      	ldr	r3, [r7, #32]
 8009250:	6a19      	ldr	r1, [r3, #32]
 8009252:	6a3b      	ldr	r3, [r7, #32]
 8009254:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8009256:	461a      	mov	r2, r3
 8009258:	6878      	ldr	r0, [r7, #4]
 800925a:	f7ff fea9 	bl	8008fb0 <_nx_arp_packet_send>
                }
            }
        }

        /* Move to the next ARP entry.  */
        arp_entry =  arp_entry -> nx_arp_pool_next;
 800925e:	6a3b      	ldr	r3, [r7, #32]
 8009260:	68db      	ldr	r3, [r3, #12]
 8009262:	623b      	str	r3, [r7, #32]
    for (i = 0; i < ip_ptr -> nx_ip_arp_dynamic_active_count; i++)
 8009264:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8009266:	3301      	adds	r3, #1
 8009268:	627b      	str	r3, [r7, #36]	; 0x24
 800926a:	687b      	ldr	r3, [r7, #4]
 800926c:	f8d3 36d8 	ldr.w	r3, [r3, #1752]	; 0x6d8
 8009270:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8009272:	429a      	cmp	r2, r3
 8009274:	f4ff af49 	bcc.w	800910a <_nx_arp_periodic_update+0x16>
    }


    /* Reduce the defend timeout of interfaces.  */
    for (i = 0; i < NX_MAX_PHYSICAL_INTERFACES; i++)
 8009278:	2300      	movs	r3, #0
 800927a:	627b      	str	r3, [r7, #36]	; 0x24
 800927c:	e02f      	b.n	80092de <_nx_arp_periodic_update+0x1ea>
    {
        if (ip_ptr -> nx_ip_interface[i].nx_interface_valid == NX_FALSE)
 800927e:	687a      	ldr	r2, [r7, #4]
 8009280:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8009282:	214c      	movs	r1, #76	; 0x4c
 8009284:	fb01 f303 	mul.w	r3, r1, r3
 8009288:	4413      	add	r3, r2
 800928a:	f203 7324 	addw	r3, r3, #1828	; 0x724
 800928e:	781b      	ldrb	r3, [r3, #0]
 8009290:	2b00      	cmp	r3, #0
 8009292:	d01e      	beq.n	80092d2 <_nx_arp_periodic_update+0x1de>
        {
            continue;
        }

        if (ip_ptr -> nx_ip_interface[i].nx_interface_arp_defend_timeout == 0)
 8009294:	687a      	ldr	r2, [r7, #4]
 8009296:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8009298:	214c      	movs	r1, #76	; 0x4c
 800929a:	fb01 f303 	mul.w	r3, r1, r3
 800929e:	4413      	add	r3, r2
 80092a0:	f503 63ec 	add.w	r3, r3, #1888	; 0x760
 80092a4:	681b      	ldr	r3, [r3, #0]
 80092a6:	2b00      	cmp	r3, #0
 80092a8:	d015      	beq.n	80092d6 <_nx_arp_periodic_update+0x1e2>
        {
            continue;
        }

        ip_ptr -> nx_ip_interface[i].nx_interface_arp_defend_timeout--;
 80092aa:	687a      	ldr	r2, [r7, #4]
 80092ac:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80092ae:	214c      	movs	r1, #76	; 0x4c
 80092b0:	fb01 f303 	mul.w	r3, r1, r3
 80092b4:	4413      	add	r3, r2
 80092b6:	f503 63ec 	add.w	r3, r3, #1888	; 0x760
 80092ba:	681b      	ldr	r3, [r3, #0]
 80092bc:	1e5a      	subs	r2, r3, #1
 80092be:	6879      	ldr	r1, [r7, #4]
 80092c0:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80092c2:	204c      	movs	r0, #76	; 0x4c
 80092c4:	fb00 f303 	mul.w	r3, r0, r3
 80092c8:	440b      	add	r3, r1
 80092ca:	f503 63ec 	add.w	r3, r3, #1888	; 0x760
 80092ce:	601a      	str	r2, [r3, #0]
 80092d0:	e002      	b.n	80092d8 <_nx_arp_periodic_update+0x1e4>
            continue;
 80092d2:	bf00      	nop
 80092d4:	e000      	b.n	80092d8 <_nx_arp_periodic_update+0x1e4>
            continue;
 80092d6:	bf00      	nop
    for (i = 0; i < NX_MAX_PHYSICAL_INTERFACES; i++)
 80092d8:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80092da:	3301      	adds	r3, #1
 80092dc:	627b      	str	r3, [r7, #36]	; 0x24
 80092de:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80092e0:	2b03      	cmp	r3, #3
 80092e2:	d9cc      	bls.n	800927e <_nx_arp_periodic_update+0x18a>
    }
}
 80092e4:	bf00      	nop
 80092e6:	bf00      	nop
 80092e8:	3728      	adds	r7, #40	; 0x28
 80092ea:	46bd      	mov	sp, r7
 80092ec:	bd80      	pop	{r7, pc}

080092ee <_nx_arp_queue_process>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
VOID  _nx_arp_queue_process(NX_IP *ip_ptr)
{
 80092ee:	b580      	push	{r7, lr}
 80092f0:	b088      	sub	sp, #32
 80092f2:	af00      	add	r7, sp, #0
 80092f4:	6078      	str	r0, [r7, #4]

NX_PACKET *packet_ptr;


    /* Loop to process all ARP deferred packet requests.  */
    while (ip_ptr -> nx_ip_arp_deferred_received_packet_head)
 80092f6:	e023      	b.n	8009340 <_nx_arp_queue_process+0x52>
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 80092f8:	f3ef 8310 	mrs	r3, PRIMASK
 80092fc:	617b      	str	r3, [r7, #20]
    return(posture);
 80092fe:	697b      	ldr	r3, [r7, #20]
    int_posture = __get_interrupt_posture();
 8009300:	613b      	str	r3, [r7, #16]
    __asm__ volatile ("CPSID i" : : : "memory");
 8009302:	b672      	cpsid	i
    return(int_posture);
 8009304:	693b      	ldr	r3, [r7, #16]
    {

        /* Remove the first packet and process it!  */

        /* Disable interrupts.  */
        TX_DISABLE
 8009306:	61fb      	str	r3, [r7, #28]

        /* Pickup the first packet.  */
        packet_ptr =  ip_ptr -> nx_ip_arp_deferred_received_packet_head;
 8009308:	687b      	ldr	r3, [r7, #4]
 800930a:	f8d3 36dc 	ldr.w	r3, [r3, #1756]	; 0x6dc
 800930e:	61bb      	str	r3, [r7, #24]

        /* Move the head pointer to the next packet.  */
        ip_ptr -> nx_ip_arp_deferred_received_packet_head =  packet_ptr -> nx_packet_queue_next;
 8009310:	69bb      	ldr	r3, [r7, #24]
 8009312:	69da      	ldr	r2, [r3, #28]
 8009314:	687b      	ldr	r3, [r7, #4]
 8009316:	f8c3 26dc 	str.w	r2, [r3, #1756]	; 0x6dc

        /* Check for end of ARP deferred processing queue.  */
        if (ip_ptr -> nx_ip_arp_deferred_received_packet_head == NX_NULL)
 800931a:	687b      	ldr	r3, [r7, #4]
 800931c:	f8d3 36dc 	ldr.w	r3, [r3, #1756]	; 0x6dc
 8009320:	2b00      	cmp	r3, #0
 8009322:	d103      	bne.n	800932c <_nx_arp_queue_process+0x3e>
        {

            /* Yes, the ARP deferred queue is empty.  Set the tail pointer to NULL.  */
            ip_ptr -> nx_ip_arp_deferred_received_packet_tail =  NX_NULL;
 8009324:	687b      	ldr	r3, [r7, #4]
 8009326:	2200      	movs	r2, #0
 8009328:	f8c3 26e0 	str.w	r2, [r3, #1760]	; 0x6e0
 800932c:	69fb      	ldr	r3, [r7, #28]
 800932e:	60fb      	str	r3, [r7, #12]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 8009330:	68fb      	ldr	r3, [r7, #12]
 8009332:	f383 8810 	msr	PRIMASK, r3
}
 8009336:	bf00      	nop

        /* Restore interrupts.  */
        TX_RESTORE

        /* Call the actual ARP packet receive function.  */
        _nx_arp_packet_receive(ip_ptr, packet_ptr);
 8009338:	69b9      	ldr	r1, [r7, #24]
 800933a:	6878      	ldr	r0, [r7, #4]
 800933c:	f7ff fc10 	bl	8008b60 <_nx_arp_packet_receive>
    while (ip_ptr -> nx_ip_arp_deferred_received_packet_head)
 8009340:	687b      	ldr	r3, [r7, #4]
 8009342:	f8d3 36dc 	ldr.w	r3, [r3, #1756]	; 0x6dc
 8009346:	2b00      	cmp	r3, #0
 8009348:	d1d6      	bne.n	80092f8 <_nx_arp_queue_process+0xa>
    }
}
 800934a:	bf00      	nop
 800934c:	bf00      	nop
 800934e:	3720      	adds	r7, #32
 8009350:	46bd      	mov	sp, r7
 8009352:	bd80      	pop	{r7, pc}

08009354 <_nx_arp_queue_send>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
VOID  _nx_arp_queue_send(NX_IP *ip_ptr, NX_ARP *arp_ptr)
{
 8009354:	b580      	push	{r7, lr}
 8009356:	b090      	sub	sp, #64	; 0x40
 8009358:	af00      	add	r7, sp, #0
 800935a:	6078      	str	r0, [r7, #4]
 800935c:	6039      	str	r1, [r7, #0]
NX_PACKET   *queued_list_head;
NX_PACKET   *packet_ptr;
NX_IP_DRIVER driver_request;

    /* Initialize the queued list head to NULL.  */
    queued_list_head =  NX_NULL;
 800935e:	2300      	movs	r3, #0
 8009360:	63fb      	str	r3, [r7, #60]	; 0x3c
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 8009362:	f3ef 8310 	mrs	r3, PRIMASK
 8009366:	633b      	str	r3, [r7, #48]	; 0x30
    return(posture);
 8009368:	6b3b      	ldr	r3, [r7, #48]	; 0x30
    int_posture = __get_interrupt_posture();
 800936a:	62fb      	str	r3, [r7, #44]	; 0x2c
    __asm__ volatile ("CPSID i" : : : "memory");
 800936c:	b672      	cpsid	i
    return(int_posture);
 800936e:	6afb      	ldr	r3, [r7, #44]	; 0x2c

    /* Determine if this ARP entry has a packet queued up for sending.  */

    /* Disable interrupts before checking.  */
    TX_DISABLE
 8009370:	63bb      	str	r3, [r7, #56]	; 0x38

    /* Look at the ARP packet queue pointer.  */
    if (arp_ptr -> nx_arp_packets_waiting)
 8009372:	683b      	ldr	r3, [r7, #0]
 8009374:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8009376:	2b00      	cmp	r3, #0
 8009378:	d005      	beq.n	8009386 <_nx_arp_queue_send+0x32>
    {

        /* Pickup the packet pointer and clear the ARP queue pointer.  */
        queued_list_head =  arp_ptr -> nx_arp_packets_waiting;
 800937a:	683b      	ldr	r3, [r7, #0]
 800937c:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800937e:	63fb      	str	r3, [r7, #60]	; 0x3c
        arp_ptr -> nx_arp_packets_waiting =  NX_NULL;
 8009380:	683b      	ldr	r3, [r7, #0]
 8009382:	2200      	movs	r2, #0
 8009384:	631a      	str	r2, [r3, #48]	; 0x30
 8009386:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8009388:	62bb      	str	r3, [r7, #40]	; 0x28
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 800938a:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800938c:	f383 8810 	msr	PRIMASK, r3
}
 8009390:	bf00      	nop

    /* Restore previous interrupt posture.  */
    TX_RESTORE

    /* Are there any packets queued to send?  */
    while (queued_list_head)
 8009392:	e04c      	b.n	800942e <_nx_arp_queue_send+0xda>
    {

        /* Pickup the first entry on the list.  */
        packet_ptr =  queued_list_head;
 8009394:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8009396:	637b      	str	r3, [r7, #52]	; 0x34

        /* Move to the next entry on the ARP packet queue.  */
        queued_list_head =  queued_list_head -> nx_packet_queue_next;
 8009398:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800939a:	69db      	ldr	r3, [r3, #28]
 800939c:	63fb      	str	r3, [r7, #60]	; 0x3c

        /* Clear the packet's queue next pointer.  */
        packet_ptr -> nx_packet_queue_next =  NX_NULL;
 800939e:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 80093a0:	2200      	movs	r2, #0
 80093a2:	61da      	str	r2, [r3, #28]

        packet_ptr -> nx_packet_address.nx_packet_interface_ptr = arp_ptr -> nx_arp_ip_interface;
 80093a4:	683b      	ldr	r3, [r7, #0]
 80093a6:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 80093a8:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 80093aa:	631a      	str	r2, [r3, #48]	; 0x30

        /* Build the driver request packet.  */
        driver_request.nx_ip_driver_physical_address_msw =  arp_ptr -> nx_arp_physical_address_msw;
 80093ac:	683b      	ldr	r3, [r7, #0]
 80093ae:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 80093b0:	613b      	str	r3, [r7, #16]
        driver_request.nx_ip_driver_physical_address_lsw =  arp_ptr -> nx_arp_physical_address_lsw;
 80093b2:	683b      	ldr	r3, [r7, #0]
 80093b4:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 80093b6:	617b      	str	r3, [r7, #20]
        driver_request.nx_ip_driver_ptr                  =  ip_ptr;
 80093b8:	687b      	ldr	r3, [r7, #4]
 80093ba:	623b      	str	r3, [r7, #32]
        driver_request.nx_ip_driver_command              =  NX_LINK_PACKET_SEND;
 80093bc:	2300      	movs	r3, #0
 80093be:	60bb      	str	r3, [r7, #8]
        driver_request.nx_ip_driver_packet               =  packet_ptr;
 80093c0:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 80093c2:	61bb      	str	r3, [r7, #24]
        driver_request.nx_ip_driver_interface            =  packet_ptr -> nx_packet_address.nx_packet_interface_ptr;
 80093c4:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 80093c6:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 80093c8:	627b      	str	r3, [r7, #36]	; 0x24

        /* Determine if fragmentation is needed.  */
        if (packet_ptr -> nx_packet_length > packet_ptr -> nx_packet_address.nx_packet_interface_ptr -> nx_interface_ip_mtu_size)
 80093ca:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 80093cc:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 80093ce:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 80093d0:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 80093d2:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 80093d4:	429a      	cmp	r2, r3
 80093d6:	d915      	bls.n	8009404 <_nx_arp_queue_send+0xb0>
        {

#ifndef NX_DISABLE_FRAGMENTATION
            /* Fragmentation is needed, call the fragment routine if available. */
            if (ip_ptr -> nx_ip_fragment_processing)
 80093d8:	687b      	ldr	r3, [r7, #4]
 80093da:	f8d3 329c 	ldr.w	r3, [r3, #668]	; 0x29c
 80093de:	2b00      	cmp	r3, #0
 80093e0:	d007      	beq.n	80093f2 <_nx_arp_queue_send+0x9e>
            {

                /* Call the IP fragment processing routine.  */
                (ip_ptr -> nx_ip_fragment_processing)(&driver_request);
 80093e2:	687b      	ldr	r3, [r7, #4]
 80093e4:	f8d3 329c 	ldr.w	r3, [r3, #668]	; 0x29c
 80093e8:	f107 0208 	add.w	r2, r7, #8
 80093ec:	4610      	mov	r0, r2
 80093ee:	4798      	blx	r3
 80093f0:	e01d      	b.n	800942e <_nx_arp_queue_send+0xda>
#endif /* NX_DISABLE_FRAGMENTATION */

#ifndef NX_DISABLE_IP_INFO

                /* Increment the IP send packets dropped count.  */
                ip_ptr -> nx_ip_send_packets_dropped++;
 80093f2:	687b      	ldr	r3, [r7, #4]
 80093f4:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 80093f6:	1c5a      	adds	r2, r3, #1
 80093f8:	687b      	ldr	r3, [r7, #4]
 80093fa:	655a      	str	r2, [r3, #84]	; 0x54
#endif

                /* Just release the packet.  */
                _nx_packet_transmit_release(packet_ptr);
 80093fc:	6b78      	ldr	r0, [r7, #52]	; 0x34
 80093fe:	f003 f8b9 	bl	800c574 <_nx_packet_transmit_release>
 8009402:	e014      	b.n	800942e <_nx_arp_queue_send+0xda>
        {

#ifndef NX_DISABLE_IP_INFO

            /* Increment the IP packet sent count.  */
            ip_ptr -> nx_ip_total_packets_sent++;
 8009404:	687b      	ldr	r3, [r7, #4]
 8009406:	695b      	ldr	r3, [r3, #20]
 8009408:	1c5a      	adds	r2, r3, #1
 800940a:	687b      	ldr	r3, [r7, #4]
 800940c:	615a      	str	r2, [r3, #20]

            /* Increment the IP bytes sent count.  */
            ip_ptr -> nx_ip_total_bytes_sent +=  packet_ptr -> nx_packet_length - (ULONG)sizeof(NX_IPV4_HEADER);
 800940e:	687b      	ldr	r3, [r7, #4]
 8009410:	699a      	ldr	r2, [r3, #24]
 8009412:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8009414:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8009416:	4413      	add	r3, r2
 8009418:	f1a3 0214 	sub.w	r2, r3, #20
 800941c:	687b      	ldr	r3, [r7, #4]
 800941e:	619a      	str	r2, [r3, #24]

            /* If trace is enabled, insert this event into the trace buffer.  */
            NX_TRACE_IN_LINE_INSERT(NX_TRACE_INTERNAL_IO_DRIVER_PACKET_SEND, ip_ptr, packet_ptr, packet_ptr -> nx_packet_length, 0, NX_TRACE_INTERNAL_EVENTS, 0, 0);

            /* Send the queued IP packet out on the network via the attached driver.  */
            (packet_ptr -> nx_packet_address.nx_packet_interface_ptr -> nx_interface_link_driver_entry)(&driver_request);
 8009420:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8009422:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8009424:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 8009426:	f107 0208 	add.w	r2, r7, #8
 800942a:	4610      	mov	r0, r2
 800942c:	4798      	blx	r3
    while (queued_list_head)
 800942e:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8009430:	2b00      	cmp	r3, #0
 8009432:	d1af      	bne.n	8009394 <_nx_arp_queue_send+0x40>
        }
    }
}
 8009434:	bf00      	nop
 8009436:	bf00      	nop
 8009438:	3740      	adds	r7, #64	; 0x40
 800943a:	46bd      	mov	sp, r7
 800943c:	bd80      	pop	{r7, pc}
	...

08009440 <_nx_icmp_enable>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
UINT  _nx_icmp_enable(NX_IP *ip_ptr)
{
 8009440:	b480      	push	{r7}
 8009442:	b083      	sub	sp, #12
 8009444:	af00      	add	r7, sp, #0
 8009446:	6078      	str	r0, [r7, #4]
#ifndef NX_DISABLE_IPV4
    /* If trace is enabled, insert this event into the trace buffer.  */
    NX_TRACE_IN_LINE_INSERT(NX_TRACE_ICMP_ENABLE, ip_ptr, 0, 0, 0, NX_TRACE_ICMP_EVENTS, 0, 0);

    /* Setup the ICMP packet queue processing routine.  */
    ip_ptr -> nx_ip_icmp_queue_process =  _nx_icmp_queue_process;
 8009448:	687b      	ldr	r3, [r7, #4]
 800944a:	4a09      	ldr	r2, [pc, #36]	; (8009470 <_nx_icmp_enable+0x30>)
 800944c:	f8c3 236c 	str.w	r2, [r3, #876]	; 0x36c

    /* Setup the ICMP packet receiving routine, thereby enabling ICMP traffic.  */
    ip_ptr -> nx_ip_icmp_packet_receive =  _nx_icmp_packet_receive;
 8009450:	687b      	ldr	r3, [r7, #4]
 8009452:	4a08      	ldr	r2, [pc, #32]	; (8009474 <_nx_icmp_enable+0x34>)
 8009454:	f8c3 2368 	str.w	r2, [r3, #872]	; 0x368

    /* Setup the ICMPv4 packet process routine */
    ip_ptr -> nx_ip_icmpv4_packet_process = _nx_icmpv4_packet_process;
 8009458:	687b      	ldr	r3, [r7, #4]
 800945a:	4a07      	ldr	r2, [pc, #28]	; (8009478 <_nx_icmp_enable+0x38>)
 800945c:	f8c3 2370 	str.w	r2, [r3, #880]	; 0x370

    /* Return a successful status!  */
    return(NX_SUCCESS);
 8009460:	2300      	movs	r3, #0
#else /* NX_DISABLE_IPV4  */
    NX_PARAMETER_NOT_USED(ip_ptr);

    return(NX_NOT_SUPPORTED);
#endif /* !NX_DISABLE_IPV4  */
}
 8009462:	4618      	mov	r0, r3
 8009464:	370c      	adds	r7, #12
 8009466:	46bd      	mov	sp, r7
 8009468:	f85d 7b04 	ldr.w	r7, [sp], #4
 800946c:	4770      	bx	lr
 800946e:	bf00      	nop
 8009470:	08009579 	.word	0x08009579
 8009474:	080094b9 	.word	0x080094b9
 8009478:	080095d7 	.word	0x080095d7

0800947c <_nx_icmp_packet_process>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
VOID  _nx_icmp_packet_process(NX_IP *ip_ptr, NX_PACKET *packet_ptr)
{
 800947c:	b580      	push	{r7, lr}
 800947e:	b082      	sub	sp, #8
 8009480:	af00      	add	r7, sp, #0
 8009482:	6078      	str	r0, [r7, #4]
 8009484:	6039      	str	r1, [r7, #0]

    /* Add debug information. */
    NX_PACKET_DEBUG(__FILE__, __LINE__, packet_ptr);

    /* FEATURE_NX_IPV6 not defined */
    if (ip_ptr -> nx_ip_icmpv4_packet_process)
 8009486:	687b      	ldr	r3, [r7, #4]
 8009488:	f8d3 3370 	ldr.w	r3, [r3, #880]	; 0x370
 800948c:	2b00      	cmp	r3, #0
 800948e:	d006      	beq.n	800949e <_nx_icmp_packet_process+0x22>
    {
        ip_ptr -> nx_ip_icmpv4_packet_process(ip_ptr, packet_ptr);
 8009490:	687b      	ldr	r3, [r7, #4]
 8009492:	f8d3 3370 	ldr.w	r3, [r3, #880]	; 0x370
 8009496:	6839      	ldr	r1, [r7, #0]
 8009498:	6878      	ldr	r0, [r7, #4]
 800949a:	4798      	blx	r3
        return;
 800949c:	e009      	b.n	80094b2 <_nx_icmp_packet_process+0x36>
    }

#ifndef NX_DISABLE_ICMP_INFO
    ip_ptr -> nx_ip_icmp_invalid_packets++;
 800949e:	687b      	ldr	r3, [r7, #4]
 80094a0:	f8d3 30ec 	ldr.w	r3, [r3, #236]	; 0xec
 80094a4:	1c5a      	adds	r2, r3, #1
 80094a6:	687b      	ldr	r3, [r7, #4]
 80094a8:	f8c3 20ec 	str.w	r2, [r3, #236]	; 0xec
#endif /* NX_DISABLE_ICMP_INFO */

    _nx_packet_release(packet_ptr);
 80094ac:	6838      	ldr	r0, [r7, #0]
 80094ae:	f002 ffab 	bl	800c408 <_nx_packet_release>
}
 80094b2:	3708      	adds	r7, #8
 80094b4:	46bd      	mov	sp, r7
 80094b6:	bd80      	pop	{r7, pc}

080094b8 <_nx_icmp_packet_receive>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
VOID  _nx_icmp_packet_receive(NX_IP *ip_ptr, NX_PACKET *packet_ptr)
{
 80094b8:	b580      	push	{r7, lr}
 80094ba:	b088      	sub	sp, #32
 80094bc:	af00      	add	r7, sp, #0
 80094be:	6078      	str	r0, [r7, #4]
 80094c0:	6039      	str	r1, [r7, #0]
    NX_PACKET_DEBUG(__FILE__, __LINE__, packet_ptr);

#ifndef NX_DISABLE_ICMP_INFO

    /* Increment the ICMP total messages received counter.  */
    ip_ptr -> nx_ip_icmp_total_messages_received++;
 80094c2:	687b      	ldr	r3, [r7, #4]
 80094c4:	f8d3 30e4 	ldr.w	r3, [r3, #228]	; 0xe4
 80094c8:	1c5a      	adds	r2, r3, #1
 80094ca:	687b      	ldr	r3, [r7, #4]
 80094cc:	f8c3 20e4 	str.w	r2, [r3, #228]	; 0xe4
#endif

#ifndef NX_DISABLE_RX_SIZE_CHECKING

    /* Check for valid packet length.  */
    if (packet_ptr -> nx_packet_length < sizeof(NX_ICMP_HEADER))
 80094d0:	683b      	ldr	r3, [r7, #0]
 80094d2:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 80094d4:	2b07      	cmp	r3, #7
 80094d6:	d80a      	bhi.n	80094ee <_nx_icmp_packet_receive+0x36>
    {

#ifndef NX_DISABLE_ICMP_INFO

        /* Increment the ICMP invalid packet error.  */
        ip_ptr -> nx_ip_icmp_invalid_packets++;
 80094d8:	687b      	ldr	r3, [r7, #4]
 80094da:	f8d3 30ec 	ldr.w	r3, [r3, #236]	; 0xec
 80094de:	1c5a      	adds	r2, r3, #1
 80094e0:	687b      	ldr	r3, [r7, #4]
 80094e2:	f8c3 20ec 	str.w	r2, [r3, #236]	; 0xec
#endif

        /* Invalid packet length, just release it.  */
        _nx_packet_release(packet_ptr);
 80094e6:	6838      	ldr	r0, [r7, #0]
 80094e8:	f002 ff8e 	bl	800c408 <_nx_packet_release>

        /* The function is complete, just return!  */
        return;
 80094ec:	e03c      	b.n	8009568 <_nx_icmp_packet_receive+0xb0>
    __asm__ volatile (" MRS  %0,IPSR ": "=r" (ipsr_value) );
 80094ee:	f3ef 8305 	mrs	r3, IPSR
 80094f2:	61bb      	str	r3, [r7, #24]
    return(ipsr_value);
 80094f4:	69ba      	ldr	r2, [r7, #24]
        return;
    }
#endif /* NX_ENABLE_ICMP_ADDRESS_CHECK  */

    /* Determine if this routine is being called from an ISR.  */
    if ((TX_THREAD_GET_SYSTEM_STATE()) || (&(ip_ptr -> nx_ip_thread) != _tx_thread_current_ptr))
 80094f6:	4b1e      	ldr	r3, [pc, #120]	; (8009570 <_nx_icmp_packet_receive+0xb8>)
 80094f8:	681b      	ldr	r3, [r3, #0]
 80094fa:	4313      	orrs	r3, r2
 80094fc:	2b00      	cmp	r3, #0
 80094fe:	d106      	bne.n	800950e <_nx_icmp_packet_receive+0x56>
 8009500:	687b      	ldr	r3, [r7, #4]
 8009502:	f503 72cc 	add.w	r2, r3, #408	; 0x198
 8009506:	4b1b      	ldr	r3, [pc, #108]	; (8009574 <_nx_icmp_packet_receive+0xbc>)
 8009508:	681b      	ldr	r3, [r3, #0]
 800950a:	429a      	cmp	r2, r3
 800950c:	d028      	beq.n	8009560 <_nx_icmp_packet_receive+0xa8>
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 800950e:	f3ef 8310 	mrs	r3, PRIMASK
 8009512:	617b      	str	r3, [r7, #20]
    return(posture);
 8009514:	697b      	ldr	r3, [r7, #20]
    int_posture = __get_interrupt_posture();
 8009516:	613b      	str	r3, [r7, #16]
    __asm__ volatile ("CPSID i" : : : "memory");
 8009518:	b672      	cpsid	i
    return(int_posture);
 800951a:	693b      	ldr	r3, [r7, #16]
        /* If system state is non-zero, we are in an ISR. If the current thread is not the IP thread,
           we need to prevent unnecessary recursion in loopback. Just place the message at the
           end of the ICMP message queue and wakeup the IP helper thread.  */

        /* Disable interrupts.  */
        TX_DISABLE
 800951c:	61fb      	str	r3, [r7, #28]

        /* Add the packet to the ICMP message queue.  */
        if (ip_ptr -> nx_ip_icmp_queue_head)
 800951e:	687b      	ldr	r3, [r7, #4]
 8009520:	f8d3 3374 	ldr.w	r3, [r3, #884]	; 0x374
 8009524:	2b00      	cmp	r3, #0
 8009526:	d005      	beq.n	8009534 <_nx_icmp_packet_receive+0x7c>
        {

            /* Link the current packet to the list head.  */
            packet_ptr -> nx_packet_queue_next =  ip_ptr -> nx_ip_icmp_queue_head;
 8009528:	687b      	ldr	r3, [r7, #4]
 800952a:	f8d3 2374 	ldr.w	r2, [r3, #884]	; 0x374
 800952e:	683b      	ldr	r3, [r7, #0]
 8009530:	61da      	str	r2, [r3, #28]
 8009532:	e002      	b.n	800953a <_nx_icmp_packet_receive+0x82>
        }
        else
        {

            /* Empty queue, add to the head of the ICMP message queue.  */
            packet_ptr -> nx_packet_queue_next =  NX_NULL;
 8009534:	683b      	ldr	r3, [r7, #0]
 8009536:	2200      	movs	r2, #0
 8009538:	61da      	str	r2, [r3, #28]
        }

        /* Update the queue head pointer.  */
        ip_ptr -> nx_ip_icmp_queue_head =  packet_ptr;
 800953a:	687b      	ldr	r3, [r7, #4]
 800953c:	683a      	ldr	r2, [r7, #0]
 800953e:	f8c3 2374 	str.w	r2, [r3, #884]	; 0x374
 8009542:	69fb      	ldr	r3, [r7, #28]
 8009544:	60fb      	str	r3, [r7, #12]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 8009546:	68fb      	ldr	r3, [r7, #12]
 8009548:	f383 8810 	msr	PRIMASK, r3
}
 800954c:	bf00      	nop

        /* Restore interrupts.  */
        TX_RESTORE

        /* Wakeup IP thread for processing one or more messages in the ICMP queue.  */
        tx_event_flags_set(&(ip_ptr -> nx_ip_events), NX_IP_ICMP_EVENT, TX_OR);
 800954e:	687b      	ldr	r3, [r7, #4]
 8009550:	f503 7313 	add.w	r3, r3, #588	; 0x24c
 8009554:	2200      	movs	r2, #0
 8009556:	2104      	movs	r1, #4
 8009558:	4618      	mov	r0, r3
 800955a:	f008 ffc7 	bl	80124ec <_tx_event_flags_set>
 800955e:	e003      	b.n	8009568 <_nx_icmp_packet_receive+0xb0>
    else
    {

        /* The IP message was deferred, so this routine is called from the IP helper
           thread and thus may call the ICMP processing directly.  */
        _nx_icmp_packet_process(ip_ptr, packet_ptr);
 8009560:	6839      	ldr	r1, [r7, #0]
 8009562:	6878      	ldr	r0, [r7, #4]
 8009564:	f7ff ff8a 	bl	800947c <_nx_icmp_packet_process>
    }
#else
    NX_PARAMETER_NOT_USED(ip_ptr);
    NX_PARAMETER_NOT_USED(packet_ptr);
#endif /* NX_DISABLE_IPV4 */
}
 8009568:	3720      	adds	r7, #32
 800956a:	46bd      	mov	sp, r7
 800956c:	bd80      	pop	{r7, pc}
 800956e:	bf00      	nop
 8009570:	24000078 	.word	0x24000078
 8009574:	24031bc4 	.word	0x24031bc4

08009578 <_nx_icmp_queue_process>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
VOID  _nx_icmp_queue_process(NX_IP *ip_ptr)
{
 8009578:	b580      	push	{r7, lr}
 800957a:	b088      	sub	sp, #32
 800957c:	af00      	add	r7, sp, #0
 800957e:	6078      	str	r0, [r7, #4]
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 8009580:	f3ef 8310 	mrs	r3, PRIMASK
 8009584:	60fb      	str	r3, [r7, #12]
    return(posture);
 8009586:	68fb      	ldr	r3, [r7, #12]
    int_posture = __get_interrupt_posture();
 8009588:	60bb      	str	r3, [r7, #8]
    __asm__ volatile ("CPSID i" : : : "memory");
 800958a:	b672      	cpsid	i
    return(int_posture);
 800958c:	68bb      	ldr	r3, [r7, #8]
NX_PACKET *queue_head;
NX_PACKET *packet_ptr;


    /* Disable interrupts.  */
    TX_DISABLE
 800958e:	61bb      	str	r3, [r7, #24]

    /* Remove the ICMP message queue from the IP structure.  */
    queue_head =  ip_ptr -> nx_ip_icmp_queue_head;
 8009590:	687b      	ldr	r3, [r7, #4]
 8009592:	f8d3 3374 	ldr.w	r3, [r3, #884]	; 0x374
 8009596:	61fb      	str	r3, [r7, #28]
    ip_ptr -> nx_ip_icmp_queue_head =  NX_NULL;
 8009598:	687b      	ldr	r3, [r7, #4]
 800959a:	2200      	movs	r2, #0
 800959c:	f8c3 2374 	str.w	r2, [r3, #884]	; 0x374
 80095a0:	69bb      	ldr	r3, [r7, #24]
 80095a2:	613b      	str	r3, [r7, #16]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 80095a4:	693b      	ldr	r3, [r7, #16]
 80095a6:	f383 8810 	msr	PRIMASK, r3
}
 80095aa:	bf00      	nop
    /* Restore interrupts.  */
    TX_RESTORE

    /* Walk through the entire ICMP message queue and process packets
       one by one.  */
    while (queue_head)
 80095ac:	e00b      	b.n	80095c6 <_nx_icmp_queue_process+0x4e>
    {

        /* Pickup the first queued ICMP message and remove it from the
           ICMP queue.  */
        packet_ptr =  queue_head;
 80095ae:	69fb      	ldr	r3, [r7, #28]
 80095b0:	617b      	str	r3, [r7, #20]
        queue_head =  queue_head -> nx_packet_queue_next;
 80095b2:	69fb      	ldr	r3, [r7, #28]
 80095b4:	69db      	ldr	r3, [r3, #28]
 80095b6:	61fb      	str	r3, [r7, #28]
        packet_ptr -> nx_packet_queue_next =  NX_NULL;
 80095b8:	697b      	ldr	r3, [r7, #20]
 80095ba:	2200      	movs	r2, #0
 80095bc:	61da      	str	r2, [r3, #28]

        /* Process the packet.  */
        _nx_icmp_packet_process(ip_ptr, packet_ptr);
 80095be:	6979      	ldr	r1, [r7, #20]
 80095c0:	6878      	ldr	r0, [r7, #4]
 80095c2:	f7ff ff5b 	bl	800947c <_nx_icmp_packet_process>
    while (queue_head)
 80095c6:	69fb      	ldr	r3, [r7, #28]
 80095c8:	2b00      	cmp	r3, #0
 80095ca:	d1f0      	bne.n	80095ae <_nx_icmp_queue_process+0x36>
    }
}
 80095cc:	bf00      	nop
 80095ce:	bf00      	nop
 80095d0:	3720      	adds	r7, #32
 80095d2:	46bd      	mov	sp, r7
 80095d4:	bd80      	pop	{r7, pc}

080095d6 <_nx_icmpv4_packet_process>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
VOID  _nx_icmpv4_packet_process(NX_IP *ip_ptr, NX_PACKET *packet_ptr)
{
 80095d6:	b580      	push	{r7, lr}
 80095d8:	b086      	sub	sp, #24
 80095da:	af02      	add	r7, sp, #8
 80095dc:	6078      	str	r0, [r7, #4]
 80095de:	6039      	str	r1, [r7, #0]
    /* Add debug information. */
    NX_PACKET_DEBUG(__FILE__, __LINE__, packet_ptr);

    /* Point to the ICMP message header.  */
    /*lint -e{927} -e{826} suppress cast of pointer to pointer, since it is necessary  */
    header_ptr =  (NX_ICMPV4_HEADER *)packet_ptr -> nx_packet_prepend_ptr;
 80095e0:	683b      	ldr	r3, [r7, #0]
 80095e2:	689b      	ldr	r3, [r3, #8]
 80095e4:	60fb      	str	r3, [r7, #12]
#endif /* defined(NX_DISABLE_ICMPV4_RX_CHECKSUM) || defined(NX_ENABLE_INTERFACE_CAPABILITY) || defined(NX_IPSEC_ENABLE) */
    {

        /* Calculate the ICMP message checksum.  */
        checksum =  _nx_ip_checksum_compute(packet_ptr, NX_IP_ICMP,
                                            (UINT)packet_ptr -> nx_packet_length,
 80095e6:	683b      	ldr	r3, [r7, #0]
 80095e8:	6a5a      	ldr	r2, [r3, #36]	; 0x24
        checksum =  _nx_ip_checksum_compute(packet_ptr, NX_IP_ICMP,
 80095ea:	2300      	movs	r3, #0
 80095ec:	9300      	str	r3, [sp, #0]
 80095ee:	2300      	movs	r3, #0
 80095f0:	f44f 3180 	mov.w	r1, #65536	; 0x10000
 80095f4:	6838      	ldr	r0, [r7, #0]
 80095f6:	f000 fb17 	bl	8009c28 <_nx_ip_checksum_compute>
 80095fa:	4603      	mov	r3, r0
 80095fc:	817b      	strh	r3, [r7, #10]
                                            /* ICMPv4 checksum does not include
                                               src/dest addresses */
                                            NX_NULL, NX_NULL);

        checksum =  ((USHORT) ~checksum) & NX_LOWER_16_MASK;
 80095fe:	897b      	ldrh	r3, [r7, #10]
 8009600:	43db      	mvns	r3, r3
 8009602:	817b      	strh	r3, [r7, #10]

        /* Determine if the checksum is valid.  */
        if (checksum)
 8009604:	897b      	ldrh	r3, [r7, #10]
 8009606:	2b00      	cmp	r3, #0
 8009608:	d011      	beq.n	800962e <_nx_icmpv4_packet_process+0x58>
        {

#ifndef NX_DISABLE_ICMP_INFO

            /* Increment the ICMP invalid packet error.  */
            ip_ptr -> nx_ip_icmp_invalid_packets++;
 800960a:	687b      	ldr	r3, [r7, #4]
 800960c:	f8d3 30ec 	ldr.w	r3, [r3, #236]	; 0xec
 8009610:	1c5a      	adds	r2, r3, #1
 8009612:	687b      	ldr	r3, [r7, #4]
 8009614:	f8c3 20ec 	str.w	r2, [r3, #236]	; 0xec

            /* Increment the ICMP checksum error count.  */
            ip_ptr -> nx_ip_icmp_checksum_errors++;
 8009618:	687b      	ldr	r3, [r7, #4]
 800961a:	f8d3 30e8 	ldr.w	r3, [r3, #232]	; 0xe8
 800961e:	1c5a      	adds	r2, r3, #1
 8009620:	687b      	ldr	r3, [r7, #4]
 8009622:	f8c3 20e8 	str.w	r2, [r3, #232]	; 0xe8
#endif

            /* Nope, the checksum is invalid.  Toss this ICMP packet out.  */
            _nx_packet_release(packet_ptr);
 8009626:	6838      	ldr	r0, [r7, #0]
 8009628:	f002 feee 	bl	800c408 <_nx_packet_release>
            return;
 800962c:	e01b      	b.n	8009666 <_nx_icmpv4_packet_process+0x90>
        }
    }

    /* Determine the message type and call the appropriate handler.  */
    if (header_ptr -> nx_icmpv4_header_type == NX_ICMP_ECHO_REPLY_TYPE)
 800962e:	68fb      	ldr	r3, [r7, #12]
 8009630:	781b      	ldrb	r3, [r3, #0]
 8009632:	2b00      	cmp	r3, #0
 8009634:	d104      	bne.n	8009640 <_nx_icmpv4_packet_process+0x6a>
    {
        _nx_icmpv4_process_echo_reply(ip_ptr, packet_ptr);
 8009636:	6839      	ldr	r1, [r7, #0]
 8009638:	6878      	ldr	r0, [r7, #4]
 800963a:	f000 f817 	bl	800966c <_nx_icmpv4_process_echo_reply>
 800963e:	e012      	b.n	8009666 <_nx_icmpv4_packet_process+0x90>
    }
    else if (header_ptr -> nx_icmpv4_header_type == NX_ICMP_ECHO_REQUEST_TYPE)
 8009640:	68fb      	ldr	r3, [r7, #12]
 8009642:	781b      	ldrb	r3, [r3, #0]
 8009644:	2b08      	cmp	r3, #8
 8009646:	d104      	bne.n	8009652 <_nx_icmpv4_packet_process+0x7c>
    {
        _nx_icmpv4_process_echo_request(ip_ptr, packet_ptr);
 8009648:	6839      	ldr	r1, [r7, #0]
 800964a:	6878      	ldr	r0, [r7, #4]
 800964c:	f000 f8cc 	bl	80097e8 <_nx_icmpv4_process_echo_request>
 8009650:	e009      	b.n	8009666 <_nx_icmpv4_packet_process+0x90>
    {

#ifndef NX_DISABLE_ICMP_INFO

        /* Increment the ICMP unhandled message count.  */
        ip_ptr -> nx_ip_icmp_unhandled_messages++;
 8009652:	687b      	ldr	r3, [r7, #4]
 8009654:	f8d3 30f0 	ldr.w	r3, [r3, #240]	; 0xf0
 8009658:	1c5a      	adds	r2, r3, #1
 800965a:	687b      	ldr	r3, [r7, #4]
 800965c:	f8c3 20f0 	str.w	r2, [r3, #240]	; 0xf0
        /* If trace is enabled, insert this event into the trace buffer.  */
        NX_TRACE_IN_LINE_INSERT(NX_TRACE_INTERNAL_ICMP_RECEIVE, ip_ptr, ip_header_ptr -> nx_ip_header_source_ip, packet_ptr, 0, NX_TRACE_INTERNAL_EVENTS, 0, 0);
#endif /* TX_ENABLE_EVENT_TRACE  */

        /* Unhandled ICMP message, just release it.  */
        _nx_packet_release(packet_ptr);
 8009660:	6838      	ldr	r0, [r7, #0]
 8009662:	f002 fed1 	bl	800c408 <_nx_packet_release>
    }
}
 8009666:	3710      	adds	r7, #16
 8009668:	46bd      	mov	sp, r7
 800966a:	bd80      	pop	{r7, pc}

0800966c <_nx_icmpv4_process_echo_reply>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
VOID  _nx_icmpv4_process_echo_reply(NX_IP *ip_ptr, NX_PACKET *packet_ptr)
{
 800966c:	b580      	push	{r7, lr}
 800966e:	b090      	sub	sp, #64	; 0x40
 8009670:	af00      	add	r7, sp, #0
 8009672:	6078      	str	r0, [r7, #4]
 8009674:	6039      	str	r1, [r7, #0]
    NX_PACKET_DEBUG(__FILE__, __LINE__, packet_ptr);


    /* Point to the ICMP message header.  */
    /*lint -e{927} -e{826} suppress cast of pointer to pointer, since it is necessary  */
    echo_ptr =  (NX_ICMPV4_ECHO *)packet_ptr -> nx_packet_prepend_ptr;
 8009676:	683b      	ldr	r3, [r7, #0]
 8009678:	689b      	ldr	r3, [r3, #8]
 800967a:	637b      	str	r3, [r7, #52]	; 0x34

#ifndef NX_DISABLE_ICMP_INFO

    /* Increment the ICMP responses received count.  */
    ip_ptr -> nx_ip_ping_responses_received++;
 800967c:	687b      	ldr	r3, [r7, #4]
 800967e:	f8d3 3100 	ldr.w	r3, [r3, #256]	; 0x100
 8009682:	1c5a      	adds	r2, r3, #1
 8009684:	687b      	ldr	r3, [r7, #4]
 8009686:	f8c3 2100 	str.w	r2, [r3, #256]	; 0x100
#endif

    /* Pickup sequence number.  */
    sequence_num = echo_ptr -> nx_icmpv4_echo_sequence_num;
 800968a:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800968c:	88db      	ldrh	r3, [r3, #6]
 800968e:	867b      	strh	r3, [r7, #50]	; 0x32

    /* Convert to host byte order, if little endian taget. */
    NX_CHANGE_USHORT_ENDIAN(sequence_num);
 8009690:	8e7b      	ldrh	r3, [r7, #50]	; 0x32
 8009692:	ba5b      	rev16	r3, r3
 8009694:	867b      	strh	r3, [r7, #50]	; 0x32
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 8009696:	f3ef 8310 	mrs	r3, PRIMASK
 800969a:	627b      	str	r3, [r7, #36]	; 0x24
    return(posture);
 800969c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    int_posture = __get_interrupt_posture();
 800969e:	623b      	str	r3, [r7, #32]
    __asm__ volatile ("CPSID i" : : : "memory");
 80096a0:	b672      	cpsid	i
    return(int_posture);
 80096a2:	6a3b      	ldr	r3, [r7, #32]

    /* Disable interrupts.  */
    TX_DISABLE
 80096a4:	62fb      	str	r3, [r7, #44]	; 0x2c

    /* Pickup the head pointer and the suspended count.  */
    thread_ptr =  ip_ptr -> nx_ip_icmp_ping_suspension_list;
 80096a6:	687b      	ldr	r3, [r7, #4]
 80096a8:	f8d3 3378 	ldr.w	r3, [r3, #888]	; 0x378
 80096ac:	63fb      	str	r3, [r7, #60]	; 0x3c
    suspended =   ip_ptr -> nx_ip_icmp_ping_suspended_count;
 80096ae:	687b      	ldr	r3, [r7, #4]
 80096b0:	f8d3 337c 	ldr.w	r3, [r3, #892]	; 0x37c
 80096b4:	63bb      	str	r3, [r7, #56]	; 0x38

    /* Temporarily disable preemption.  */
    _tx_thread_preempt_disable++;
 80096b6:	4b4b      	ldr	r3, [pc, #300]	; (80097e4 <_nx_icmpv4_process_echo_reply+0x178>)
 80096b8:	681b      	ldr	r3, [r3, #0]
 80096ba:	3301      	adds	r3, #1
 80096bc:	4a49      	ldr	r2, [pc, #292]	; (80097e4 <_nx_icmpv4_process_echo_reply+0x178>)
 80096be:	6013      	str	r3, [r2, #0]
 80096c0:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 80096c2:	62bb      	str	r3, [r7, #40]	; 0x28
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 80096c4:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80096c6:	f383 8810 	msr	PRIMASK, r3
}
 80096ca:	bf00      	nop
    /* Restore interrupts.  */
    TX_RESTORE

    /* Search through the suspended threads waiting for a ECHO (ping) response
       in an attempt to find a matching sequence number.  */
    while (suspended--)
 80096cc:	e05e      	b.n	800978c <_nx_icmpv4_process_echo_reply+0x120>
    {

        /* Determine if the sequence number matches a suspended thread.  */
        if ((USHORT)(thread_ptr ->  tx_thread_suspend_info) == sequence_num)
 80096ce:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 80096d0:	6f9b      	ldr	r3, [r3, #120]	; 0x78
 80096d2:	b29b      	uxth	r3, r3
 80096d4:	8e7a      	ldrh	r2, [r7, #50]	; 0x32
 80096d6:	429a      	cmp	r2, r3
 80096d8:	d155      	bne.n	8009786 <_nx_icmpv4_process_echo_reply+0x11a>
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 80096da:	f3ef 8310 	mrs	r3, PRIMASK
 80096de:	61fb      	str	r3, [r7, #28]
    return(posture);
 80096e0:	69fb      	ldr	r3, [r7, #28]
    int_posture = __get_interrupt_posture();
 80096e2:	61bb      	str	r3, [r7, #24]
    __asm__ volatile ("CPSID i" : : : "memory");
 80096e4:	b672      	cpsid	i
    return(int_posture);
 80096e6:	69bb      	ldr	r3, [r7, #24]
        {

            /* Disable interrupts.  */
            TX_DISABLE
 80096e8:	62fb      	str	r3, [r7, #44]	; 0x2c

            /* See if this is the only suspended thread on the list.  */
            if (thread_ptr == thread_ptr -> tx_thread_suspended_next)
 80096ea:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 80096ec:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 80096ee:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 80096f0:	429a      	cmp	r2, r3
 80096f2:	d104      	bne.n	80096fe <_nx_icmpv4_process_echo_reply+0x92>
            {

                /* Yes, the only suspended thread.  */

                /* Update the head pointer.  */
                ip_ptr -> nx_ip_icmp_ping_suspension_list =  NX_NULL;
 80096f4:	687b      	ldr	r3, [r7, #4]
 80096f6:	2200      	movs	r2, #0
 80096f8:	f8c3 2378 	str.w	r2, [r3, #888]	; 0x378
 80096fc:	e014      	b.n	8009728 <_nx_icmpv4_process_echo_reply+0xbc>
            {

                /* At least one more thread is on the same expiration list.  */

                /* Update the list head pointer.  */
                if (ip_ptr -> nx_ip_icmp_ping_suspension_list == thread_ptr)
 80096fe:	687b      	ldr	r3, [r7, #4]
 8009700:	f8d3 3378 	ldr.w	r3, [r3, #888]	; 0x378
 8009704:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 8009706:	429a      	cmp	r2, r3
 8009708:	d104      	bne.n	8009714 <_nx_icmpv4_process_echo_reply+0xa8>
                {
                    ip_ptr -> nx_ip_icmp_ping_suspension_list =  thread_ptr -> tx_thread_suspended_next;
 800970a:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800970c:	6f1a      	ldr	r2, [r3, #112]	; 0x70
 800970e:	687b      	ldr	r3, [r7, #4]
 8009710:	f8c3 2378 	str.w	r2, [r3, #888]	; 0x378
                }

                /* Update the links of the adjacent threads.  */
                (thread_ptr -> tx_thread_suspended_next) -> tx_thread_suspended_previous =
 8009714:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8009716:	6f1b      	ldr	r3, [r3, #112]	; 0x70
                    thread_ptr -> tx_thread_suspended_previous;
 8009718:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 800971a:	6f52      	ldr	r2, [r2, #116]	; 0x74
                (thread_ptr -> tx_thread_suspended_next) -> tx_thread_suspended_previous =
 800971c:	675a      	str	r2, [r3, #116]	; 0x74
                (thread_ptr -> tx_thread_suspended_previous) -> tx_thread_suspended_next =
 800971e:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8009720:	6f5b      	ldr	r3, [r3, #116]	; 0x74
                    thread_ptr -> tx_thread_suspended_next;
 8009722:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 8009724:	6f12      	ldr	r2, [r2, #112]	; 0x70
                (thread_ptr -> tx_thread_suspended_previous) -> tx_thread_suspended_next =
 8009726:	671a      	str	r2, [r3, #112]	; 0x70
            }

            /* Decrement the suspension count.  */
            ip_ptr -> nx_ip_icmp_ping_suspended_count--;
 8009728:	687b      	ldr	r3, [r7, #4]
 800972a:	f8d3 337c 	ldr.w	r3, [r3, #892]	; 0x37c
 800972e:	1e5a      	subs	r2, r3, #1
 8009730:	687b      	ldr	r3, [r7, #4]
 8009732:	f8c3 237c 	str.w	r2, [r3, #892]	; 0x37c

            /* Prepare for resumption of the first thread.  */

            /* Clear cleanup routine to avoid timeout.  */
            thread_ptr -> tx_thread_suspend_cleanup =  TX_NULL;
 8009736:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8009738:	2200      	movs	r2, #0
 800973a:	669a      	str	r2, [r3, #104]	; 0x68

            /* Temporarily disable preemption.  */
            _tx_thread_preempt_disable++;
 800973c:	4b29      	ldr	r3, [pc, #164]	; (80097e4 <_nx_icmpv4_process_echo_reply+0x178>)
 800973e:	681b      	ldr	r3, [r3, #0]
 8009740:	3301      	adds	r3, #1
 8009742:	4a28      	ldr	r2, [pc, #160]	; (80097e4 <_nx_icmpv4_process_echo_reply+0x178>)
 8009744:	6013      	str	r3, [r2, #0]
 8009746:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8009748:	617b      	str	r3, [r7, #20]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 800974a:	697b      	ldr	r3, [r7, #20]
 800974c:	f383 8810 	msr	PRIMASK, r3
}
 8009750:	bf00      	nop
            /* Restore interrupts.  */
            TX_RESTORE

            /* Adjust this packet to remove the ICMP header that is still in front of
               the response message.  */
            packet_ptr -> nx_packet_length      = packet_ptr -> nx_packet_length - (ULONG)sizeof(NX_ICMPV4_ECHO);
 8009752:	683b      	ldr	r3, [r7, #0]
 8009754:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8009756:	f1a3 0208 	sub.w	r2, r3, #8
 800975a:	683b      	ldr	r3, [r7, #0]
 800975c:	625a      	str	r2, [r3, #36]	; 0x24
            packet_ptr -> nx_packet_prepend_ptr = packet_ptr -> nx_packet_prepend_ptr + sizeof(NX_ICMPV4_ECHO);
 800975e:	683b      	ldr	r3, [r7, #0]
 8009760:	689b      	ldr	r3, [r3, #8]
 8009762:	f103 0208 	add.w	r2, r3, #8
 8009766:	683b      	ldr	r3, [r7, #0]
 8009768:	609a      	str	r2, [r3, #8]

            /* Return this block pointer to the suspended thread waiting for
               a block.  */
            *((NX_PACKET **)thread_ptr -> tx_thread_additional_suspend_info) =  packet_ptr;
 800976a:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800976c:	6fdb      	ldr	r3, [r3, #124]	; 0x7c
 800976e:	683a      	ldr	r2, [r7, #0]
 8009770:	601a      	str	r2, [r3, #0]

            /* Clear packet pointer so we don't try to release it below.  */
            packet_ptr =  NX_NULL;
 8009772:	2300      	movs	r3, #0
 8009774:	603b      	str	r3, [r7, #0]

            /* Put return status into the thread control block.  */
            thread_ptr -> tx_thread_suspend_status =  NX_SUCCESS;
 8009776:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8009778:	2200      	movs	r2, #0
 800977a:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84

            /* Resume thread.  */
            _tx_thread_system_resume(thread_ptr);
 800977e:	6bf8      	ldr	r0, [r7, #60]	; 0x3c
 8009780:	f00b fad2 	bl	8014d28 <_tx_thread_system_resume>

            /* Get out of the loop.  */
            break;
 8009784:	e007      	b.n	8009796 <_nx_icmpv4_process_echo_reply+0x12a>
        }
        else
        {
            /* Just move to the next suspended thread.  */
            thread_ptr =  thread_ptr -> tx_thread_suspended_next;
 8009786:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8009788:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 800978a:	63fb      	str	r3, [r7, #60]	; 0x3c
    while (suspended--)
 800978c:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800978e:	1e5a      	subs	r2, r3, #1
 8009790:	63ba      	str	r2, [r7, #56]	; 0x38
 8009792:	2b00      	cmp	r3, #0
 8009794:	d19b      	bne.n	80096ce <_nx_icmpv4_process_echo_reply+0x62>
        }
    }

    /* Determine if no match was made and we just have to release the packet.  */
    if (packet_ptr)
 8009796:	683b      	ldr	r3, [r7, #0]
 8009798:	2b00      	cmp	r3, #0
 800979a:	d009      	beq.n	80097b0 <_nx_icmpv4_process_echo_reply+0x144>
    {

#ifndef NX_DISABLE_ICMP_INFO

        /* Increment the ICMP invalid packet error. */
        ip_ptr -> nx_ip_icmp_invalid_packets++;
 800979c:	687b      	ldr	r3, [r7, #4]
 800979e:	f8d3 30ec 	ldr.w	r3, [r3, #236]	; 0xec
 80097a2:	1c5a      	adds	r2, r3, #1
 80097a4:	687b      	ldr	r3, [r7, #4]
 80097a6:	f8c3 20ec 	str.w	r2, [r3, #236]	; 0xec
#endif /* NX_DISABLE_ICMP_INFO */

        /* Yes, just release the packet.  */
        _nx_packet_release(packet_ptr);
 80097aa:	6838      	ldr	r0, [r7, #0]
 80097ac:	f002 fe2c 	bl	800c408 <_nx_packet_release>
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 80097b0:	f3ef 8310 	mrs	r3, PRIMASK
 80097b4:	60fb      	str	r3, [r7, #12]
    return(posture);
 80097b6:	68fb      	ldr	r3, [r7, #12]
    int_posture = __get_interrupt_posture();
 80097b8:	60bb      	str	r3, [r7, #8]
    __asm__ volatile ("CPSID i" : : : "memory");
 80097ba:	b672      	cpsid	i
    return(int_posture);
 80097bc:	68bb      	ldr	r3, [r7, #8]
    }

    /* Disable interrupts.  */
    TX_DISABLE
 80097be:	62fb      	str	r3, [r7, #44]	; 0x2c

    /* Release preemption disable.  */
    _tx_thread_preempt_disable--;
 80097c0:	4b08      	ldr	r3, [pc, #32]	; (80097e4 <_nx_icmpv4_process_echo_reply+0x178>)
 80097c2:	681b      	ldr	r3, [r3, #0]
 80097c4:	3b01      	subs	r3, #1
 80097c6:	4a07      	ldr	r2, [pc, #28]	; (80097e4 <_nx_icmpv4_process_echo_reply+0x178>)
 80097c8:	6013      	str	r3, [r2, #0]
 80097ca:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 80097cc:	613b      	str	r3, [r7, #16]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 80097ce:	693b      	ldr	r3, [r7, #16]
 80097d0:	f383 8810 	msr	PRIMASK, r3
}
 80097d4:	bf00      	nop

    /* Restore interrupts.  */
    TX_RESTORE

    /* Check for preemption.  */
    _tx_thread_system_preempt_check();
 80097d6:	f00b fa6d 	bl	8014cb4 <_tx_thread_system_preempt_check>
}
 80097da:	bf00      	nop
 80097dc:	3740      	adds	r7, #64	; 0x40
 80097de:	46bd      	mov	sp, r7
 80097e0:	bd80      	pop	{r7, pc}
 80097e2:	bf00      	nop
 80097e4:	24031c5c 	.word	0x24031c5c

080097e8 <_nx_icmpv4_process_echo_request>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
VOID  _nx_icmpv4_process_echo_request(NX_IP *ip_ptr, NX_PACKET *packet_ptr)
{
 80097e8:	b580      	push	{r7, lr}
 80097ea:	b08c      	sub	sp, #48	; 0x30
 80097ec:	af04      	add	r7, sp, #16
 80097ee:	6078      	str	r0, [r7, #4]
 80097f0:	6039      	str	r1, [r7, #0]
ULONG             old_m;
#if defined(NX_DISABLE_ICMPV4_TX_CHECKSUM) || defined(NX_ENABLE_INTERFACE_CAPABILITY) || defined(NX_IPSEC_ENABLE)
ULONG             compute_checksum = 1;
#endif /* defined(NX_DISABLE_ICMPV4_TX_CHECKSUM) || defined(NX_ENABLE_INTERFACE_CAPABILITY) || defined(NX_IPSEC_ENABLE) */
NX_IPV4_HEADER   *ipv4_header;
ULONG             next_hop_address = NX_NULL;
 80097f2:	2300      	movs	r3, #0
 80097f4:	60fb      	str	r3, [r7, #12]
    NX_PACKET_DEBUG(__FILE__, __LINE__, packet_ptr);


    /* Point to the ICMP message header.  */
    /*lint -e{927} -e{826} suppress cast of pointer to pointer, since it is necessary  */
    header_ptr =  (NX_ICMPV4_HEADER *)packet_ptr -> nx_packet_prepend_ptr;
 80097f6:	683b      	ldr	r3, [r7, #0]
 80097f8:	689b      	ldr	r3, [r3, #8]
 80097fa:	61fb      	str	r3, [r7, #28]

    /* Pickup the return IP address.  */
    /*lint -e{927} -e{826} suppress cast of pointer to pointer, since it is necessary  */
    ipv4_header = (NX_IPV4_HEADER *)packet_ptr -> nx_packet_ip_header;
 80097fc:	683b      	ldr	r3, [r7, #0]
 80097fe:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8009800:	61bb      	str	r3, [r7, #24]

#ifndef NX_DISABLE_ICMP_INFO
    /* Increment the ICMP pings received count.  */
    ip_ptr -> nx_ip_pings_received++;
 8009802:	687b      	ldr	r3, [r7, #4]
 8009804:	f8d3 3104 	ldr.w	r3, [r3, #260]	; 0x104
 8009808:	1c5a      	adds	r2, r3, #1
 800980a:	687b      	ldr	r3, [r7, #4]
 800980c:	f8c3 2104 	str.w	r2, [r3, #260]	; 0x104
#endif

    /* Change the type to Echo Reply and send back the message to the caller.  */
    header_ptr -> nx_icmpv4_header_type = NX_ICMP_ECHO_REPLY_TYPE;
 8009810:	69fb      	ldr	r3, [r7, #28]
 8009812:	2200      	movs	r2, #0
 8009814:	701a      	strb	r2, [r3, #0]
           m'  - new value of a 16-bit field
           HC' = ~(C + (-m) + m')
           = ~(~HC + ~m + m') */

        /* Endian swapping logic.  */
        NX_CHANGE_USHORT_ENDIAN(header_ptr -> nx_icmpv4_header_checksum);
 8009816:	69fb      	ldr	r3, [r7, #28]
 8009818:	885b      	ldrh	r3, [r3, #2]
 800981a:	ba5b      	rev16	r3, r3
 800981c:	b29a      	uxth	r2, r3
 800981e:	69fb      	ldr	r3, [r7, #28]
 8009820:	805a      	strh	r2, [r3, #2]

        /* Get the old checksum (HC) in header. */
        checksum = header_ptr -> nx_icmpv4_header_checksum;
 8009822:	69fb      	ldr	r3, [r7, #28]
 8009824:	885b      	ldrh	r3, [r3, #2]
 8009826:	617b      	str	r3, [r7, #20]

        /* Get the old type(m). */
        old_m = (ULONG)(NX_ICMP_ECHO_REQUEST_TYPE << 8);
 8009828:	f44f 6300 	mov.w	r3, #2048	; 0x800
 800982c:	613b      	str	r3, [r7, #16]

        /* Update the checksum, get the new checksum(HC'). */
        /* The m' is value of echo reply type. It is zero so can be ignored. */
        checksum = ((~checksum) & 0xFFFF) + ((~old_m) & 0xFFFF);
 800982e:	697b      	ldr	r3, [r7, #20]
 8009830:	43db      	mvns	r3, r3
 8009832:	b29a      	uxth	r2, r3
 8009834:	693b      	ldr	r3, [r7, #16]
 8009836:	43db      	mvns	r3, r3
 8009838:	b29b      	uxth	r3, r3
 800983a:	4413      	add	r3, r2
 800983c:	617b      	str	r3, [r7, #20]

        /* Fold a 4-byte value into a two byte value */
        checksum = (checksum >> 16) + (checksum & 0xFFFF);
 800983e:	697b      	ldr	r3, [r7, #20]
 8009840:	0c1a      	lsrs	r2, r3, #16
 8009842:	697b      	ldr	r3, [r7, #20]
 8009844:	b29b      	uxth	r3, r3
 8009846:	4413      	add	r3, r2
 8009848:	617b      	str	r3, [r7, #20]

        /* Do it again in case previous operation generates an overflow */
        checksum = (checksum >> 16) + (checksum & 0xFFFF);
 800984a:	697b      	ldr	r3, [r7, #20]
 800984c:	0c1a      	lsrs	r2, r3, #16
 800984e:	697b      	ldr	r3, [r7, #20]
 8009850:	b29b      	uxth	r3, r3
 8009852:	4413      	add	r3, r2
 8009854:	617b      	str	r3, [r7, #20]

        /* Store the checksum.  */
        header_ptr -> nx_icmpv4_header_checksum = (~checksum & NX_LOWER_16_MASK);
 8009856:	697b      	ldr	r3, [r7, #20]
 8009858:	b29b      	uxth	r3, r3
 800985a:	43db      	mvns	r3, r3
 800985c:	b29a      	uxth	r2, r3
 800985e:	69fb      	ldr	r3, [r7, #28]
 8009860:	805a      	strh	r2, [r3, #2]

        /* If NX_LITTLE_ENDIAN is defined, the header need to be swapped back
           for output (network byte order).  */
        NX_CHANGE_USHORT_ENDIAN(header_ptr -> nx_icmpv4_header_checksum);
 8009862:	69fb      	ldr	r3, [r7, #28]
 8009864:	885b      	ldrh	r3, [r3, #2]
 8009866:	ba5b      	rev16	r3, r3
 8009868:	b29a      	uxth	r2, r3
 800986a:	69fb      	ldr	r3, [r7, #28]
 800986c:	805a      	strh	r2, [r3, #2]
#endif /* NX_ENABLE_INTERFACE_CAPABILITY */
    }
#endif

    /* Figure out the best interface to send the ICMP packet on. */
    _nx_ip_route_find(ip_ptr, ipv4_header -> nx_ip_header_source_ip,
 800986e:	69bb      	ldr	r3, [r7, #24]
 8009870:	68d9      	ldr	r1, [r3, #12]
                      &packet_ptr -> nx_packet_address.nx_packet_interface_ptr,
 8009872:	683b      	ldr	r3, [r7, #0]
 8009874:	f103 0230 	add.w	r2, r3, #48	; 0x30
    _nx_ip_route_find(ip_ptr, ipv4_header -> nx_ip_header_source_ip,
 8009878:	f107 030c 	add.w	r3, r7, #12
 800987c:	6878      	ldr	r0, [r7, #4]
 800987e:	f001 fac9 	bl	800ae14 <_nx_ip_route_find>
    /* If trace is enabled, insert this event into the trace buffer.  */
    NX_TRACE_IN_LINE_INSERT(NX_TRACE_INTERNAL_ICMP_RECEIVE, ip_ptr, ipv4_header -> nx_ip_header_source_ip, packet_ptr, 0, NX_TRACE_INTERNAL_EVENTS, 0, 0);

#ifndef NX_DISABLE_ICMP_INFO
    /* Increment the ICMP pings responded to count.  */
    ip_ptr -> nx_ip_pings_responded_to++;
 8009882:	687b      	ldr	r3, [r7, #4]
 8009884:	f8d3 3108 	ldr.w	r3, [r3, #264]	; 0x108
 8009888:	1c5a      	adds	r2, r3, #1
 800988a:	687b      	ldr	r3, [r7, #4]
 800988c:	f8c3 2108 	str.w	r2, [r3, #264]	; 0x108
#endif

    /* Send the ICMP packet to the IP component.  */
    /*lint -e{644} suppress variable might not be initialized, since "next_hop_address" was initialized in _nx_ip_route_find. */
    _nx_ip_packet_send(ip_ptr, packet_ptr, ipv4_header -> nx_ip_header_source_ip,
 8009890:	69bb      	ldr	r3, [r7, #24]
 8009892:	68da      	ldr	r2, [r3, #12]
 8009894:	68fb      	ldr	r3, [r7, #12]
 8009896:	9303      	str	r3, [sp, #12]
 8009898:	2300      	movs	r3, #0
 800989a:	9302      	str	r3, [sp, #8]
 800989c:	f44f 3380 	mov.w	r3, #65536	; 0x10000
 80098a0:	9301      	str	r3, [sp, #4]
 80098a2:	2380      	movs	r3, #128	; 0x80
 80098a4:	9300      	str	r3, [sp, #0]
 80098a6:	2300      	movs	r3, #0
 80098a8:	6839      	ldr	r1, [r7, #0]
 80098aa:	6878      	ldr	r0, [r7, #4]
 80098ac:	f001 fa40 	bl	800ad30 <_nx_ip_packet_send>
                       NX_IP_NORMAL, NX_IP_TIME_TO_LIVE, NX_IP_ICMP, NX_FRAGMENT_OKAY, next_hop_address);
}
 80098b0:	bf00      	nop
 80098b2:	3720      	adds	r7, #32
 80098b4:	46bd      	mov	sp, r7
 80098b6:	bd80      	pop	{r7, pc}

080098b8 <_nx_icmpv4_send_error_message>:
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
VOID _nx_icmpv4_send_error_message(NX_IP *ip_ptr, NX_PACKET *offending_packet,
                                   ULONG word1, ULONG error_pointer)
{
 80098b8:	b580      	push	{r7, lr}
 80098ba:	b094      	sub	sp, #80	; 0x50
 80098bc:	af04      	add	r7, sp, #16
 80098be:	60f8      	str	r0, [r7, #12]
 80098c0:	60b9      	str	r1, [r7, #8]
 80098c2:	607a      	str	r2, [r7, #4]
 80098c4:	603b      	str	r3, [r7, #0]
NX_ICMPV4_ERROR *icmpv4_error;
NX_IPV4_HEADER  *ip_header_ptr;
UINT             ip_header_size;
UINT             bytes_to_copy, i;
ULONG            src_ip;
ULONG            next_hop_address = NX_NULL;
 80098c6:	2300      	movs	r3, #0
 80098c8:	613b      	str	r3, [r7, #16]

    /* Add debug information. */
    NX_PACKET_DEBUG(__FILE__, __LINE__, offending_packet);

    /* Do not send ICMPv4 error message if ICMPv4 is not enabled. */
    if (ip_ptr -> nx_ip_icmpv4_packet_process == NX_NULL)
 80098ca:	68fb      	ldr	r3, [r7, #12]
 80098cc:	f8d3 3370 	ldr.w	r3, [r3, #880]	; 0x370
 80098d0:	2b00      	cmp	r3, #0
 80098d2:	f000 8100 	beq.w	8009ad6 <_nx_icmpv4_send_error_message+0x21e>
        return;
    }

    /* Find out the source and destination IP addresses of the offending packet. */
    /*lint -e{927} -e{826} suppress cast of pointer to pointer, since it is necessary  */
    ip_header_ptr = (NX_IPV4_HEADER *)(offending_packet -> nx_packet_ip_header);
 80098d6:	68bb      	ldr	r3, [r7, #8]
 80098d8:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 80098da:	62fb      	str	r3, [r7, #44]	; 0x2c
    src_ip = ip_header_ptr -> nx_ip_header_source_ip;
 80098dc:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 80098de:	68db      	ldr	r3, [r3, #12]
 80098e0:	62bb      	str	r3, [r7, #40]	; 0x28

    /* Get the incoming interface. */
    if_ptr = offending_packet -> nx_packet_address.nx_packet_interface_ptr;
 80098e2:	68bb      	ldr	r3, [r7, #8]
 80098e4:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 80098e6:	627b      	str	r3, [r7, #36]	; 0x24

    /* An ICMP error message MUST NOT be sent as the result of receiving:
       RFC1122, Section3.2.2, Page39.  */

    /* A datagram destined to an IP broadcast or IP multicast address.  */
    if ((ip_header_ptr -> nx_ip_header_destination_ip == NX_IP_LIMITED_BROADCAST) ||
 80098e8:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 80098ea:	691b      	ldr	r3, [r3, #16]
 80098ec:	f1b3 3fff 	cmp.w	r3, #4294967295
 80098f0:	f000 80f3 	beq.w	8009ada <_nx_icmpv4_send_error_message+0x222>
        ((ip_header_ptr -> nx_ip_header_destination_ip & NX_IP_CLASS_D_MASK) == NX_IP_CLASS_D_TYPE))
 80098f4:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 80098f6:	691b      	ldr	r3, [r3, #16]
 80098f8:	f003 4370 	and.w	r3, r3, #4026531840	; 0xf0000000
    if ((ip_header_ptr -> nx_ip_header_destination_ip == NX_IP_LIMITED_BROADCAST) ||
 80098fc:	f1b3 4f60 	cmp.w	r3, #3758096384	; 0xe0000000
 8009900:	f000 80eb 	beq.w	8009ada <_nx_icmpv4_send_error_message+0x222>
    {
        return;
    }

    /* A datagram sent as a link-layer broadcast.  */
    if (((ip_header_ptr -> nx_ip_header_destination_ip & if_ptr -> nx_interface_ip_network_mask) ==
 8009904:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8009906:	691a      	ldr	r2, [r3, #16]
 8009908:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800990a:	699b      	ldr	r3, [r3, #24]
 800990c:	401a      	ands	r2, r3
         if_ptr -> nx_interface_ip_network) &&
 800990e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8009910:	69db      	ldr	r3, [r3, #28]
    if (((ip_header_ptr -> nx_ip_header_destination_ip & if_ptr -> nx_interface_ip_network_mask) ==
 8009912:	429a      	cmp	r2, r3
 8009914:	d10b      	bne.n	800992e <_nx_icmpv4_send_error_message+0x76>
        ((ip_header_ptr -> nx_ip_header_destination_ip & ~(if_ptr -> nx_interface_ip_network_mask)) ==
 8009916:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8009918:	691a      	ldr	r2, [r3, #16]
 800991a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800991c:	699b      	ldr	r3, [r3, #24]
 800991e:	43db      	mvns	r3, r3
 8009920:	401a      	ands	r2, r3
         ~(if_ptr -> nx_interface_ip_network_mask)))
 8009922:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8009924:	699b      	ldr	r3, [r3, #24]
 8009926:	43db      	mvns	r3, r3
         if_ptr -> nx_interface_ip_network) &&
 8009928:	429a      	cmp	r2, r3
 800992a:	f000 80d8 	beq.w	8009ade <_nx_icmpv4_send_error_message+0x226>
    {
        return;
    }

    /* A non-initial fragment.  */
    if (ip_header_ptr -> nx_ip_header_word_1 & NX_IP_OFFSET_MASK)
 800992e:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8009930:	685b      	ldr	r3, [r3, #4]
 8009932:	f3c3 030c 	ubfx	r3, r3, #0, #13
 8009936:	2b00      	cmp	r3, #0
 8009938:	f040 80d3 	bne.w	8009ae2 <_nx_icmpv4_send_error_message+0x22a>
    }

    /* A datagram whose source address does not define a single host,
       e.g., a zero address, a loopback address, a broadcast address,
       a multicast address, or a Class E address.  */
    if ((ip_header_ptr -> nx_ip_header_source_ip == 0) ||
 800993c:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800993e:	68db      	ldr	r3, [r3, #12]
 8009940:	2b00      	cmp	r3, #0
 8009942:	f000 80d0 	beq.w	8009ae6 <_nx_icmpv4_send_error_message+0x22e>
        ((ip_header_ptr -> nx_ip_header_source_ip >= NX_IP_LOOPBACK_FIRST) &&
 8009946:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8009948:	68db      	ldr	r3, [r3, #12]
    if ((ip_header_ptr -> nx_ip_header_source_ip == 0) ||
 800994a:	f1b3 4ffe 	cmp.w	r3, #2130706432	; 0x7f000000
 800994e:	d304      	bcc.n	800995a <_nx_icmpv4_send_error_message+0xa2>
         (ip_header_ptr -> nx_ip_header_source_ip <= NX_IP_LOOPBACK_LAST)) ||
 8009950:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8009952:	68db      	ldr	r3, [r3, #12]
        ((ip_header_ptr -> nx_ip_header_source_ip >= NX_IP_LOOPBACK_FIRST) &&
 8009954:	2b00      	cmp	r3, #0
 8009956:	f280 80c6 	bge.w	8009ae6 <_nx_icmpv4_send_error_message+0x22e>
        (ip_header_ptr -> nx_ip_header_source_ip == NX_IP_LIMITED_BROADCAST) ||
 800995a:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800995c:	68db      	ldr	r3, [r3, #12]
         (ip_header_ptr -> nx_ip_header_source_ip <= NX_IP_LOOPBACK_LAST)) ||
 800995e:	f1b3 3fff 	cmp.w	r3, #4294967295
 8009962:	f000 80c0 	beq.w	8009ae6 <_nx_icmpv4_send_error_message+0x22e>
        ((ip_header_ptr -> nx_ip_header_source_ip & NX_IP_CLASS_D_MASK) == NX_IP_CLASS_D_TYPE))
 8009966:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8009968:	68db      	ldr	r3, [r3, #12]
 800996a:	f003 4370 	and.w	r3, r3, #4026531840	; 0xf0000000
        (ip_header_ptr -> nx_ip_header_source_ip == NX_IP_LIMITED_BROADCAST) ||
 800996e:	f1b3 4f60 	cmp.w	r3, #3758096384	; 0xe0000000
 8009972:	f000 80b8 	beq.w	8009ae6 <_nx_icmpv4_send_error_message+0x22e>
    {
        return;
    }

    /* Allocate a packet to build the ICMPv4 error message in.  */
    if (_nx_packet_allocate(ip_ptr -> nx_ip_default_packet_pool, &pkt_ptr, NX_IPv4_ICMP_PACKET, NX_NO_WAIT))
 8009976:	68fb      	ldr	r3, [r7, #12]
 8009978:	f8d3 0138 	ldr.w	r0, [r3, #312]	; 0x138
 800997c:	f107 0114 	add.w	r1, r7, #20
 8009980:	2300      	movs	r3, #0
 8009982:	2224      	movs	r2, #36	; 0x24
 8009984:	f002 f8dc 	bl	800bb40 <_nx_packet_allocate>
 8009988:	4603      	mov	r3, r0
 800998a:	2b00      	cmp	r3, #0
 800998c:	f040 80ad 	bne.w	8009aea <_nx_icmpv4_send_error_message+0x232>
    /* Add debug information. */
    NX_PACKET_DEBUG(__FILE__, __LINE__, pkt_ptr);

    /* Mark the packet as IPv4. */
    /*lint -e{644} suppress variable might not be initialized, since "pkt_ptr" was initialized in _nx_packet_allocate. */
    pkt_ptr -> nx_packet_ip_version = NX_IP_VERSION_V4;
 8009990:	697b      	ldr	r3, [r7, #20]
 8009992:	2204      	movs	r2, #4
 8009994:	f883 202c 	strb.w	r2, [r3, #44]	; 0x2c

    /* Size of the message is ICMPv4 */
    /*lint -e{927} -e{826} suppress cast of pointer to pointer, since it is necessary  */
    icmpv4_error = (NX_ICMPV4_ERROR *)(pkt_ptr -> nx_packet_prepend_ptr);
 8009998:	697b      	ldr	r3, [r7, #20]
 800999a:	689b      	ldr	r3, [r3, #8]
 800999c:	623b      	str	r3, [r7, #32]
    icmpv4_error -> nx_icmpv4_error_header.nx_icmpv4_header_type = (UCHAR)((word1 >> 24) & 0xFF);
 800999e:	687b      	ldr	r3, [r7, #4]
 80099a0:	0e1b      	lsrs	r3, r3, #24
 80099a2:	b2da      	uxtb	r2, r3
 80099a4:	6a3b      	ldr	r3, [r7, #32]
 80099a6:	701a      	strb	r2, [r3, #0]
    icmpv4_error -> nx_icmpv4_error_header.nx_icmpv4_header_code = (UCHAR)((word1 >> 16) & 0xFF);
 80099a8:	687b      	ldr	r3, [r7, #4]
 80099aa:	0c1b      	lsrs	r3, r3, #16
 80099ac:	b2da      	uxtb	r2, r3
 80099ae:	6a3b      	ldr	r3, [r7, #32]
 80099b0:	705a      	strb	r2, [r3, #1]
    icmpv4_error -> nx_icmpv4_error_header.nx_icmpv4_header_checksum = 0;
 80099b2:	6a3b      	ldr	r3, [r7, #32]
 80099b4:	2200      	movs	r2, #0
 80099b6:	805a      	strh	r2, [r3, #2]
    icmpv4_error -> nx_icmpv4_error_pointer = (error_pointer << 24);
 80099b8:	683b      	ldr	r3, [r7, #0]
 80099ba:	061a      	lsls	r2, r3, #24
 80099bc:	6a3b      	ldr	r3, [r7, #32]
 80099be:	605a      	str	r2, [r3, #4]

    /* Change to network byte order. */
    NX_CHANGE_ULONG_ENDIAN(icmpv4_error -> nx_icmpv4_error_pointer);
 80099c0:	6a3b      	ldr	r3, [r7, #32]
 80099c2:	685b      	ldr	r3, [r3, #4]
 80099c4:	ba1a      	rev	r2, r3
 80099c6:	6a3b      	ldr	r3, [r7, #32]
 80099c8:	605a      	str	r2, [r3, #4]

    /* IP Header + 64 bits (64 bits = 2 ULONGs) of Data Datagram.  */
    ip_header_size = ((ip_header_ptr -> nx_ip_header_word_0 & 0x0F000000) >> 24);
 80099ca:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 80099cc:	681b      	ldr	r3, [r3, #0]
 80099ce:	0e1b      	lsrs	r3, r3, #24
 80099d0:	f003 030f 	and.w	r3, r3, #15
 80099d4:	61fb      	str	r3, [r7, #28]
    bytes_to_copy = (UINT)((ip_header_size + 2) * sizeof(ULONG));
 80099d6:	69fb      	ldr	r3, [r7, #28]
 80099d8:	3302      	adds	r3, #2
 80099da:	009b      	lsls	r3, r3, #2
 80099dc:	63fb      	str	r3, [r7, #60]	; 0x3c

    /* Set the packet length and pointers.  The length will be increased to include
       the IPv4 header in the IP send function.  The Prepend function will be similarly
       updated in the IP send function. */
    pkt_ptr -> nx_packet_length = bytes_to_copy + (ULONG)sizeof(NX_ICMPV4_ERROR);
 80099de:	697b      	ldr	r3, [r7, #20]
 80099e0:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 80099e2:	3208      	adds	r2, #8
 80099e4:	625a      	str	r2, [r3, #36]	; 0x24
    pkt_ptr -> nx_packet_append_ptr = pkt_ptr -> nx_packet_prepend_ptr + pkt_ptr -> nx_packet_length;
 80099e6:	697b      	ldr	r3, [r7, #20]
 80099e8:	6899      	ldr	r1, [r3, #8]
 80099ea:	697b      	ldr	r3, [r7, #20]
 80099ec:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 80099ee:	697b      	ldr	r3, [r7, #20]
 80099f0:	440a      	add	r2, r1
 80099f2:	60da      	str	r2, [r3, #12]

    /*lint -e{927} -e{826} suppress cast of pointer to pointer, since it is necessary  */
    src_packet  = (ULONG *)(offending_packet -> nx_packet_ip_header);
 80099f4:	68bb      	ldr	r3, [r7, #8]
 80099f6:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 80099f8:	637b      	str	r3, [r7, #52]	; 0x34

    /*lint -e{923} suppress cast between pointer and ULONG, since it is necessary  */
    dest_packet = (ULONG *)NX_UCHAR_POINTER_ADD(icmpv4_error, sizeof(NX_ICMPV4_ERROR));
 80099fa:	6a3b      	ldr	r3, [r7, #32]
 80099fc:	3308      	adds	r3, #8
 80099fe:	633b      	str	r3, [r7, #48]	; 0x30

    /* Endian swap the incoming IPv4 normal header to network byte order. */
    for (i = 0; i < NX_IP_NORMAL_LENGTH; i++)
 8009a00:	2300      	movs	r3, #0
 8009a02:	63bb      	str	r3, [r7, #56]	; 0x38
 8009a04:	e00a      	b.n	8009a1c <_nx_icmpv4_send_error_message+0x164>
    {
        NX_CHANGE_ULONG_ENDIAN(*src_packet);
 8009a06:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8009a08:	681b      	ldr	r3, [r3, #0]
 8009a0a:	ba1a      	rev	r2, r3
 8009a0c:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8009a0e:	601a      	str	r2, [r3, #0]
        src_packet++;
 8009a10:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8009a12:	3304      	adds	r3, #4
 8009a14:	637b      	str	r3, [r7, #52]	; 0x34
    for (i = 0; i < NX_IP_NORMAL_LENGTH; i++)
 8009a16:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8009a18:	3301      	adds	r3, #1
 8009a1a:	63bb      	str	r3, [r7, #56]	; 0x38
 8009a1c:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8009a1e:	2b04      	cmp	r3, #4
 8009a20:	d9f1      	bls.n	8009a06 <_nx_icmpv4_send_error_message+0x14e>
    }

    /* Reset the packet pointer to the received packet IP header. */
    /*lint -e{927} -e{826} suppress cast of pointer to pointer, since it is necessary  */
    src_packet  = (ULONG *)(offending_packet -> nx_packet_ip_header);
 8009a22:	68bb      	ldr	r3, [r7, #8]
 8009a24:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8009a26:	637b      	str	r3, [r7, #52]	; 0x34

    /* Copy the data from the received packet to the ICMPv4 error packet. */
    for (; bytes_to_copy > 0; bytes_to_copy -= 4)
 8009a28:	e00a      	b.n	8009a40 <_nx_icmpv4_send_error_message+0x188>
    {

        *dest_packet++ = *src_packet++;
 8009a2a:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 8009a2c:	1d13      	adds	r3, r2, #4
 8009a2e:	637b      	str	r3, [r7, #52]	; 0x34
 8009a30:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8009a32:	1d19      	adds	r1, r3, #4
 8009a34:	6339      	str	r1, [r7, #48]	; 0x30
 8009a36:	6812      	ldr	r2, [r2, #0]
 8009a38:	601a      	str	r2, [r3, #0]
    for (; bytes_to_copy > 0; bytes_to_copy -= 4)
 8009a3a:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8009a3c:	3b04      	subs	r3, #4
 8009a3e:	63fb      	str	r3, [r7, #60]	; 0x3c
 8009a40:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8009a42:	2b00      	cmp	r3, #0
 8009a44:	d1f1      	bne.n	8009a2a <_nx_icmpv4_send_error_message+0x172>
    }

    /* Get the IP header pointer.  */
    /*lint -e{927} -e{826} suppress cast of pointer to pointer, since it is necessary  */
    src_packet  = (ULONG *)(offending_packet -> nx_packet_ip_header);
 8009a46:	68bb      	ldr	r3, [r7, #8]
 8009a48:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8009a4a:	637b      	str	r3, [r7, #52]	; 0x34

    /* Endian swap the IPv4 normal header back to host byte order. */
    for (i = 0; i < NX_IP_NORMAL_LENGTH; i++)
 8009a4c:	2300      	movs	r3, #0
 8009a4e:	63bb      	str	r3, [r7, #56]	; 0x38
 8009a50:	e00a      	b.n	8009a68 <_nx_icmpv4_send_error_message+0x1b0>
    {
        NX_CHANGE_ULONG_ENDIAN(*src_packet);
 8009a52:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8009a54:	681b      	ldr	r3, [r3, #0]
 8009a56:	ba1a      	rev	r2, r3
 8009a58:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8009a5a:	601a      	str	r2, [r3, #0]
        src_packet++;
 8009a5c:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8009a5e:	3304      	adds	r3, #4
 8009a60:	637b      	str	r3, [r7, #52]	; 0x34
    for (i = 0; i < NX_IP_NORMAL_LENGTH; i++)
 8009a62:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8009a64:	3301      	adds	r3, #1
 8009a66:	63bb      	str	r3, [r7, #56]	; 0x38
 8009a68:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8009a6a:	2b04      	cmp	r3, #4
 8009a6c:	d9f1      	bls.n	8009a52 <_nx_icmpv4_send_error_message+0x19a>
    }

    /* Use the corresponding interface address as sender's address. */
    pkt_ptr -> nx_packet_address.nx_packet_interface_ptr = offending_packet -> nx_packet_address.nx_packet_interface_ptr;
 8009a6e:	697b      	ldr	r3, [r7, #20]
 8009a70:	68ba      	ldr	r2, [r7, #8]
 8009a72:	6b12      	ldr	r2, [r2, #48]	; 0x30
 8009a74:	631a      	str	r2, [r3, #48]	; 0x30

    /* Figure out the best interface to send the ICMP packet on. */
    _nx_ip_route_find(ip_ptr, src_ip,
                      &pkt_ptr -> nx_packet_address.nx_packet_interface_ptr,
 8009a76:	697b      	ldr	r3, [r7, #20]
 8009a78:	f103 0230 	add.w	r2, r3, #48	; 0x30
    _nx_ip_route_find(ip_ptr, src_ip,
 8009a7c:	f107 0310 	add.w	r3, r7, #16
 8009a80:	6ab9      	ldr	r1, [r7, #40]	; 0x28
 8009a82:	68f8      	ldr	r0, [r7, #12]
 8009a84:	f001 f9c6 	bl	800ae14 <_nx_ip_route_find>
    if (compute_checksum)
#endif /* defined(NX_DISABLE_ICMPV4_TX_CHECKSUM) || defined(NX_ENABLE_INTERFACE_CAPABILITY) || defined(NX_IPSEC_ENABLE) */
    {

        /* Compute the checksum of the ICMP packet.  */
        checksum = _nx_ip_checksum_compute(pkt_ptr, NX_IP_ICMP,
 8009a88:	6978      	ldr	r0, [r7, #20]
                                           (UINT)pkt_ptr -> nx_packet_length,
 8009a8a:	697b      	ldr	r3, [r7, #20]
 8009a8c:	6a5a      	ldr	r2, [r3, #36]	; 0x24
        checksum = _nx_ip_checksum_compute(pkt_ptr, NX_IP_ICMP,
 8009a8e:	2300      	movs	r3, #0
 8009a90:	9300      	str	r3, [sp, #0]
 8009a92:	2300      	movs	r3, #0
 8009a94:	f44f 3180 	mov.w	r1, #65536	; 0x10000
 8009a98:	f000 f8c6 	bl	8009c28 <_nx_ip_checksum_compute>
 8009a9c:	4603      	mov	r3, r0
 8009a9e:	837b      	strh	r3, [r7, #26]
                                           /* ICMPV4 checksum does not include
                                              src/dest addresses */
                                           NX_NULL, NX_NULL);

        icmpv4_error -> nx_icmpv4_error_header.nx_icmpv4_header_checksum = (USHORT)(~checksum);
 8009aa0:	8b7b      	ldrh	r3, [r7, #26]
 8009aa2:	43db      	mvns	r3, r3
 8009aa4:	b29a      	uxth	r2, r3
 8009aa6:	6a3b      	ldr	r3, [r7, #32]
 8009aa8:	805a      	strh	r2, [r3, #2]

        /* Swap to network byte order. */
        NX_CHANGE_USHORT_ENDIAN(icmpv4_error -> nx_icmpv4_error_header.nx_icmpv4_header_checksum);
 8009aaa:	6a3b      	ldr	r3, [r7, #32]
 8009aac:	885b      	ldrh	r3, [r3, #2]
 8009aae:	ba5b      	rev16	r3, r3
 8009ab0:	b29a      	uxth	r2, r3
 8009ab2:	6a3b      	ldr	r3, [r7, #32]
 8009ab4:	805a      	strh	r2, [r3, #2]
    }
#endif /* NX_ENABLE_INTERFACE_CAPABILITY */

    /* Send the ICMP packet to the IP component. The time to live is set to 255.  */
    /*lint -e{644} suppress variable might not be initialized, since "next_hop_address" was initialized in _nx_ip_route_find. */
    _nx_ip_packet_send(ip_ptr, pkt_ptr, src_ip,
 8009ab6:	6979      	ldr	r1, [r7, #20]
 8009ab8:	693b      	ldr	r3, [r7, #16]
 8009aba:	9303      	str	r3, [sp, #12]
 8009abc:	2300      	movs	r3, #0
 8009abe:	9302      	str	r3, [sp, #8]
 8009ac0:	f44f 3380 	mov.w	r3, #65536	; 0x10000
 8009ac4:	9301      	str	r3, [sp, #4]
 8009ac6:	23ff      	movs	r3, #255	; 0xff
 8009ac8:	9300      	str	r3, [sp, #0]
 8009aca:	2300      	movs	r3, #0
 8009acc:	6aba      	ldr	r2, [r7, #40]	; 0x28
 8009ace:	68f8      	ldr	r0, [r7, #12]
 8009ad0:	f001 f92e 	bl	800ad30 <_nx_ip_packet_send>
                       NX_IP_NORMAL, 255, NX_IP_ICMP, NX_FRAGMENT_OKAY, next_hop_address);

    return;
 8009ad4:	e00a      	b.n	8009aec <_nx_icmpv4_send_error_message+0x234>
        return;
 8009ad6:	bf00      	nop
 8009ad8:	e008      	b.n	8009aec <_nx_icmpv4_send_error_message+0x234>
        return;
 8009ada:	bf00      	nop
 8009adc:	e006      	b.n	8009aec <_nx_icmpv4_send_error_message+0x234>
        return;
 8009ade:	bf00      	nop
 8009ae0:	e004      	b.n	8009aec <_nx_icmpv4_send_error_message+0x234>
        return;
 8009ae2:	bf00      	nop
 8009ae4:	e002      	b.n	8009aec <_nx_icmpv4_send_error_message+0x234>
        return;
 8009ae6:	bf00      	nop
 8009ae8:	e000      	b.n	8009aec <_nx_icmpv4_send_error_message+0x234>
        return;
 8009aea:	bf00      	nop
}
 8009aec:	3740      	adds	r7, #64	; 0x40
 8009aee:	46bd      	mov	sp, r7
 8009af0:	bd80      	pop	{r7, pc}
	...

08009af4 <_nx_igmp_multicast_check>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
UINT  _nx_igmp_multicast_check(NX_IP *ip_ptr, ULONG group, NX_INTERFACE *nx_interface)
{
 8009af4:	b480      	push	{r7}
 8009af6:	b087      	sub	sp, #28
 8009af8:	af00      	add	r7, sp, #0
 8009afa:	60f8      	str	r0, [r7, #12]
 8009afc:	60b9      	str	r1, [r7, #8]
 8009afe:	607a      	str	r2, [r7, #4]

UINT i;

    /* Check for "all hosts" group.  We always assume all hosts membership.  */
    /*lint -e{835} -e{845} suppress operating on zero. */
    if (group ==  NX_ALL_HOSTS_ADDRESS)
 8009b00:	68bb      	ldr	r3, [r7, #8]
 8009b02:	4a18      	ldr	r2, [pc, #96]	; (8009b64 <_nx_igmp_multicast_check+0x70>)
 8009b04:	4293      	cmp	r3, r2
 8009b06:	d101      	bne.n	8009b0c <_nx_igmp_multicast_check+0x18>
    {
        return(NX_TRUE);
 8009b08:	2301      	movs	r3, #1
 8009b0a:	e025      	b.n	8009b58 <_nx_igmp_multicast_check+0x64>
    }

    /* Loop through the IP multicast join list to find the matching group that is being
       responded to by another host on this same network.  */

    for (i = 0; i < NX_MAX_MULTICAST_GROUPS; i++)
 8009b0c:	2300      	movs	r3, #0
 8009b0e:	617b      	str	r3, [r7, #20]
 8009b10:	e01e      	b.n	8009b50 <_nx_igmp_multicast_check+0x5c>
    {

        /* Check for a match.  */
        if ((ip_ptr -> nx_ipv4_multicast_entry[i].nx_ipv4_multicast_join_list == group) &&
 8009b12:	68f9      	ldr	r1, [r7, #12]
 8009b14:	697a      	ldr	r2, [r7, #20]
 8009b16:	4613      	mov	r3, r2
 8009b18:	009b      	lsls	r3, r3, #2
 8009b1a:	4413      	add	r3, r2
 8009b1c:	009b      	lsls	r3, r3, #2
 8009b1e:	440b      	add	r3, r1
 8009b20:	f503 7331 	add.w	r3, r3, #708	; 0x2c4
 8009b24:	681b      	ldr	r3, [r3, #0]
 8009b26:	68ba      	ldr	r2, [r7, #8]
 8009b28:	429a      	cmp	r2, r3
 8009b2a:	d10e      	bne.n	8009b4a <_nx_igmp_multicast_check+0x56>
            (nx_interface == ip_ptr -> nx_ipv4_multicast_entry[i].nx_ipv4_multicast_join_interface_list))
 8009b2c:	68f9      	ldr	r1, [r7, #12]
 8009b2e:	697a      	ldr	r2, [r7, #20]
 8009b30:	4613      	mov	r3, r2
 8009b32:	009b      	lsls	r3, r3, #2
 8009b34:	4413      	add	r3, r2
 8009b36:	009b      	lsls	r3, r3, #2
 8009b38:	440b      	add	r3, r1
 8009b3a:	f503 7332 	add.w	r3, r3, #712	; 0x2c8
 8009b3e:	681b      	ldr	r3, [r3, #0]
        if ((ip_ptr -> nx_ipv4_multicast_entry[i].nx_ipv4_multicast_join_list == group) &&
 8009b40:	687a      	ldr	r2, [r7, #4]
 8009b42:	429a      	cmp	r2, r3
 8009b44:	d101      	bne.n	8009b4a <_nx_igmp_multicast_check+0x56>
        {
            return(NX_TRUE);
 8009b46:	2301      	movs	r3, #1
 8009b48:	e006      	b.n	8009b58 <_nx_igmp_multicast_check+0x64>
    for (i = 0; i < NX_MAX_MULTICAST_GROUPS; i++)
 8009b4a:	697b      	ldr	r3, [r7, #20]
 8009b4c:	3301      	adds	r3, #1
 8009b4e:	617b      	str	r3, [r7, #20]
 8009b50:	697b      	ldr	r3, [r7, #20]
 8009b52:	2b06      	cmp	r3, #6
 8009b54:	d9dd      	bls.n	8009b12 <_nx_igmp_multicast_check+0x1e>
        }
    }

    /* Otherwise, we have searched the entire list, return false.  */
    return(NX_FALSE);
 8009b56:	2300      	movs	r3, #0
}
 8009b58:	4618      	mov	r0, r3
 8009b5a:	371c      	adds	r7, #28
 8009b5c:	46bd      	mov	sp, r7
 8009b5e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8009b62:	4770      	bx	lr
 8009b64:	e0000001 	.word	0xe0000001

08009b68 <_nx_ip_address_change_notify>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
UINT  _nx_ip_address_change_notify(NX_IP *ip_ptr, VOID (*ip_address_change_notify)(NX_IP *, VOID *), VOID *additional_info)
{
 8009b68:	b580      	push	{r7, lr}
 8009b6a:	b088      	sub	sp, #32
 8009b6c:	af00      	add	r7, sp, #0
 8009b6e:	60f8      	str	r0, [r7, #12]
 8009b70:	60b9      	str	r1, [r7, #8]
 8009b72:	607a      	str	r2, [r7, #4]

    /* If trace is enabled, insert this event into the trace buffer.  */
    NX_TRACE_IN_LINE_INSERT(NX_TRACE_IP_ADDRESS_CHANGE_NOTIFY, ip_ptr, ip_address_change_notify, additional_info, 0, NX_TRACE_IP_EVENTS, 0, 0);

    /* Get mutex protection.  */
    tx_mutex_get(&(ip_ptr -> nx_ip_protection), TX_WAIT_FOREVER);
 8009b74:	68fb      	ldr	r3, [r7, #12]
 8009b76:	f503 739e 	add.w	r3, r3, #316	; 0x13c
 8009b7a:	f04f 31ff 	mov.w	r1, #4294967295
 8009b7e:	4618      	mov	r0, r3
 8009b80:	f009 f8f8 	bl	8012d74 <_tx_mutex_get>
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 8009b84:	f3ef 8310 	mrs	r3, PRIMASK
 8009b88:	617b      	str	r3, [r7, #20]
    return(posture);
 8009b8a:	697b      	ldr	r3, [r7, #20]
    int_posture = __get_interrupt_posture();
 8009b8c:	613b      	str	r3, [r7, #16]
    __asm__ volatile ("CPSID i" : : : "memory");
 8009b8e:	b672      	cpsid	i
    return(int_posture);
 8009b90:	693b      	ldr	r3, [r7, #16]

    /* Disable interrupts.  */
    TX_DISABLE
 8009b92:	61fb      	str	r3, [r7, #28]

    /* Setup the IP address change callback function and the additional information pointers. */
    ip_ptr -> nx_ip_address_change_notify =                  ip_address_change_notify;
 8009b94:	68fb      	ldr	r3, [r7, #12]
 8009b96:	68ba      	ldr	r2, [r7, #8]
 8009b98:	f8c3 22bc 	str.w	r2, [r3, #700]	; 0x2bc
    ip_ptr -> nx_ip_address_change_notify_additional_info =  additional_info;
 8009b9c:	68fb      	ldr	r3, [r7, #12]
 8009b9e:	687a      	ldr	r2, [r7, #4]
 8009ba0:	f8c3 22c0 	str.w	r2, [r3, #704]	; 0x2c0
 8009ba4:	69fb      	ldr	r3, [r7, #28]
 8009ba6:	61bb      	str	r3, [r7, #24]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 8009ba8:	69bb      	ldr	r3, [r7, #24]
 8009baa:	f383 8810 	msr	PRIMASK, r3
}
 8009bae:	bf00      	nop

    /* Restore interrupts.  */
    TX_RESTORE

    /* Release mutex protection.  */
    tx_mutex_put(&(ip_ptr -> nx_ip_protection));
 8009bb0:	68fb      	ldr	r3, [r7, #12]
 8009bb2:	f503 739e 	add.w	r3, r3, #316	; 0x13c
 8009bb6:	4618      	mov	r0, r3
 8009bb8:	f009 fb54 	bl	8013264 <_tx_mutex_put>

    /* Return completion status.  */
    return(NX_SUCCESS);
 8009bbc:	2300      	movs	r3, #0
    NX_PARAMETER_NOT_USED(ip_address_change_notify);
    NX_PARAMETER_NOT_USED(additional_info);

    return(NX_NOT_SUPPORTED);
#endif /* !NX_DISABLE_IPV4  */
}
 8009bbe:	4618      	mov	r0, r3
 8009bc0:	3720      	adds	r7, #32
 8009bc2:	46bd      	mov	sp, r7
 8009bc4:	bd80      	pop	{r7, pc}

08009bc6 <_nx_ip_address_get>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
UINT  _nx_ip_address_get(NX_IP *ip_ptr, ULONG *ip_address, ULONG *network_mask)
{
 8009bc6:	b580      	push	{r7, lr}
 8009bc8:	b088      	sub	sp, #32
 8009bca:	af00      	add	r7, sp, #0
 8009bcc:	60f8      	str	r0, [r7, #12]
 8009bce:	60b9      	str	r1, [r7, #8]
 8009bd0:	607a      	str	r2, [r7, #4]

#ifndef NX_DISABLE_IPV4
TX_INTERRUPT_SAVE_AREA

    /* Get mutex protection.  */
    tx_mutex_get(&(ip_ptr -> nx_ip_protection), TX_WAIT_FOREVER);
 8009bd2:	68fb      	ldr	r3, [r7, #12]
 8009bd4:	f503 739e 	add.w	r3, r3, #316	; 0x13c
 8009bd8:	f04f 31ff 	mov.w	r1, #4294967295
 8009bdc:	4618      	mov	r0, r3
 8009bde:	f009 f8c9 	bl	8012d74 <_tx_mutex_get>
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 8009be2:	f3ef 8310 	mrs	r3, PRIMASK
 8009be6:	617b      	str	r3, [r7, #20]
    return(posture);
 8009be8:	697b      	ldr	r3, [r7, #20]
    int_posture = __get_interrupt_posture();
 8009bea:	613b      	str	r3, [r7, #16]
    __asm__ volatile ("CPSID i" : : : "memory");
 8009bec:	b672      	cpsid	i
    return(int_posture);
 8009bee:	693b      	ldr	r3, [r7, #16]

    /* Disable interrupts.  */
    TX_DISABLE
 8009bf0:	61fb      	str	r3, [r7, #28]

    /* Pickup the IP address and the network mask.  This service assumes
       the operation on the primary interface. */
    *ip_address =    ip_ptr -> nx_ip_interface[0].nx_interface_ip_address;
 8009bf2:	68fb      	ldr	r3, [r7, #12]
 8009bf4:	f8d3 2734 	ldr.w	r2, [r3, #1844]	; 0x734
 8009bf8:	68bb      	ldr	r3, [r7, #8]
 8009bfa:	601a      	str	r2, [r3, #0]
    *network_mask =  ip_ptr -> nx_ip_interface[0].nx_interface_ip_network_mask;
 8009bfc:	68fb      	ldr	r3, [r7, #12]
 8009bfe:	f8d3 2738 	ldr.w	r2, [r3, #1848]	; 0x738
 8009c02:	687b      	ldr	r3, [r7, #4]
 8009c04:	601a      	str	r2, [r3, #0]
 8009c06:	69fb      	ldr	r3, [r7, #28]
 8009c08:	61bb      	str	r3, [r7, #24]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 8009c0a:	69bb      	ldr	r3, [r7, #24]
 8009c0c:	f383 8810 	msr	PRIMASK, r3
}
 8009c10:	bf00      	nop

    /* Restore interrupts.  */
    TX_RESTORE

    /* Release mutex protection.  */
    tx_mutex_put(&(ip_ptr -> nx_ip_protection));
 8009c12:	68fb      	ldr	r3, [r7, #12]
 8009c14:	f503 739e 	add.w	r3, r3, #316	; 0x13c
 8009c18:	4618      	mov	r0, r3
 8009c1a:	f009 fb23 	bl	8013264 <_tx_mutex_put>
    /* If trace is enabled, insert this event into the trace buffer.  */
    NX_TRACE_IN_LINE_INSERT(NX_TRACE_IP_ADDRESS_GET, ip_ptr, ip_ptr -> nx_ip_interface[0].nx_interface_ip_address,
                            ip_ptr -> nx_ip_interface[0].nx_interface_ip_network_mask, 0, NX_TRACE_IP_EVENTS, 0, 0);

    /* Return completion status.  */
    return(NX_SUCCESS);
 8009c1e:	2300      	movs	r3, #0
    NX_PARAMETER_NOT_USED(ip_address);
    NX_PARAMETER_NOT_USED(network_mask);

    return(NX_NOT_SUPPORTED);
#endif /* !NX_DISABLE_IPV4  */
}
 8009c20:	4618      	mov	r0, r3
 8009c22:	3720      	adds	r7, #32
 8009c24:	46bd      	mov	sp, r7
 8009c26:	bd80      	pop	{r7, pc}

08009c28 <_nx_ip_checksum_compute>:
/*                                                                        */
/**************************************************************************/
USHORT  _nx_ip_checksum_compute(NX_PACKET *packet_ptr, ULONG protocol,
                                UINT data_length, ULONG *src_ip_addr,
                                ULONG *dest_ip_addr)
{
 8009c28:	b580      	push	{r7, lr}
 8009c2a:	b08e      	sub	sp, #56	; 0x38
 8009c2c:	af00      	add	r7, sp, #0
 8009c2e:	60f8      	str	r0, [r7, #12]
 8009c30:	60b9      	str	r1, [r7, #8]
 8009c32:	607a      	str	r2, [r7, #4]
 8009c34:	603b      	str	r3, [r7, #0]

ULONG      checksum = 0;
 8009c36:	2300      	movs	r3, #0
 8009c38:	637b      	str	r3, [r7, #52]	; 0x34
UINT       i;
#endif

    /* For computing TCP/UDP/ICMPv6, we need to include the pseudo header.
       The ICMPv4 checksum does not cover the pseudo header. */
    if ((protocol == NX_PROTOCOL_UDP) ||
 8009c3a:	68bb      	ldr	r3, [r7, #8]
 8009c3c:	2b11      	cmp	r3, #17
 8009c3e:	d002      	beq.n	8009c46 <_nx_ip_checksum_compute+0x1e>
 8009c40:	68bb      	ldr	r3, [r7, #8]
 8009c42:	2b06      	cmp	r3, #6
 8009c44:	d141      	bne.n	8009cca <_nx_ip_checksum_compute+0xa2>
        (protocol == NX_PROTOCOL_TCP))
    {

    USHORT *src_ip_short, *dest_ip_short;

        checksum = protocol;
 8009c46:	68bb      	ldr	r3, [r7, #8]
 8009c48:	637b      	str	r3, [r7, #52]	; 0x34

        /* The addresses must not be null.  */
        NX_ASSERT((src_ip_addr != NX_NULL) && (dest_ip_addr != NX_NULL));
 8009c4a:	683b      	ldr	r3, [r7, #0]
 8009c4c:	2b00      	cmp	r3, #0
 8009c4e:	d002      	beq.n	8009c56 <_nx_ip_checksum_compute+0x2e>
 8009c50:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8009c52:	2b00      	cmp	r3, #0
 8009c54:	d104      	bne.n	8009c60 <_nx_ip_checksum_compute+0x38>
 8009c56:	f04f 30ff 	mov.w	r0, #4294967295
 8009c5a:	f00a ffab 	bl	8014bb4 <_tx_thread_sleep>
 8009c5e:	e7fa      	b.n	8009c56 <_nx_ip_checksum_compute+0x2e>

        /*lint -e{929} -e{740} suppress cast of pointer to pointer, since it is necessary  */
        src_ip_short = (USHORT *)src_ip_addr;
 8009c60:	683b      	ldr	r3, [r7, #0]
 8009c62:	623b      	str	r3, [r7, #32]

        /*lint -e{929} -e{740} suppress cast of pointer to pointer, since it is necessary  */
        dest_ip_short = (USHORT *)dest_ip_addr;
 8009c64:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8009c66:	61fb      	str	r3, [r7, #28]


        checksum += src_ip_short[0];
 8009c68:	6a3b      	ldr	r3, [r7, #32]
 8009c6a:	881b      	ldrh	r3, [r3, #0]
 8009c6c:	461a      	mov	r2, r3
 8009c6e:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8009c70:	4413      	add	r3, r2
 8009c72:	637b      	str	r3, [r7, #52]	; 0x34
        checksum += src_ip_short[1];
 8009c74:	6a3b      	ldr	r3, [r7, #32]
 8009c76:	3302      	adds	r3, #2
 8009c78:	881b      	ldrh	r3, [r3, #0]
 8009c7a:	461a      	mov	r2, r3
 8009c7c:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8009c7e:	4413      	add	r3, r2
 8009c80:	637b      	str	r3, [r7, #52]	; 0x34
        checksum += dest_ip_short[0];
 8009c82:	69fb      	ldr	r3, [r7, #28]
 8009c84:	881b      	ldrh	r3, [r3, #0]
 8009c86:	461a      	mov	r2, r3
 8009c88:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8009c8a:	4413      	add	r3, r2
 8009c8c:	637b      	str	r3, [r7, #52]	; 0x34
        checksum += dest_ip_short[1];
 8009c8e:	69fb      	ldr	r3, [r7, #28]
 8009c90:	3302      	adds	r3, #2
 8009c92:	881b      	ldrh	r3, [r3, #0]
 8009c94:	461a      	mov	r2, r3
 8009c96:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8009c98:	4413      	add	r3, r2
 8009c9a:	637b      	str	r3, [r7, #52]	; 0x34
            }
        }
#endif /* FEATURE_NX_IPV6 */

        /* Take care of data length */
        checksum += data_length;
 8009c9c:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 8009c9e:	687b      	ldr	r3, [r7, #4]
 8009ca0:	4413      	add	r3, r2
 8009ca2:	637b      	str	r3, [r7, #52]	; 0x34

        /* Fold a 4-byte value into a two byte value */
        checksum = (checksum >> 16) + (checksum & 0xFFFF);
 8009ca4:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8009ca6:	0c1a      	lsrs	r2, r3, #16
 8009ca8:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8009caa:	b29b      	uxth	r3, r3
 8009cac:	4413      	add	r3, r2
 8009cae:	637b      	str	r3, [r7, #52]	; 0x34

        /* Do it again in case previous operation generates an overflow */
        checksum = (checksum >> 16) + (checksum & 0xFFFF);
 8009cb0:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8009cb2:	0c1a      	lsrs	r2, r3, #16
 8009cb4:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8009cb6:	b29b      	uxth	r3, r3
 8009cb8:	4413      	add	r3, r2
 8009cba:	637b      	str	r3, [r7, #52]	; 0x34

        /* Convert to network byte order. */
        tmp = (USHORT)checksum;
 8009cbc:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8009cbe:	837b      	strh	r3, [r7, #26]
        NX_CHANGE_USHORT_ENDIAN(tmp);
 8009cc0:	8b7b      	ldrh	r3, [r7, #26]
 8009cc2:	ba5b      	rev16	r3, r3
 8009cc4:	837b      	strh	r3, [r7, #26]
        checksum = tmp;
 8009cc6:	8b7b      	ldrh	r3, [r7, #26]
 8009cc8:	637b      	str	r3, [r7, #52]	; 0x34

    /* Now we need to go through the payloads */

    /* Setup the pointer to the start of the packet.  */
    /*lint -e{927} -e{826} suppress cast of pointer to pointer, since it is necessary  */
    long_ptr =  (ULONG *)packet_ptr -> nx_packet_prepend_ptr;
 8009cca:	68fb      	ldr	r3, [r7, #12]
 8009ccc:	689b      	ldr	r3, [r3, #8]
 8009cce:	62fb      	str	r3, [r7, #44]	; 0x2c

    /* Initialize the current packet to the input packet pointer.  */
    current_packet =  packet_ptr;
 8009cd0:	68fb      	ldr	r3, [r7, #12]
 8009cd2:	62bb      	str	r3, [r7, #40]	; 0x28

#ifndef NX_DISABLE_PACKET_CHAIN
    /* Loop the packet. */
    while (current_packet)
 8009cd4:	e058      	b.n	8009d88 <_nx_ip_checksum_compute+0x160>
    {

        /* Calculate current packet size. */
        /*lint -e{946} -e{947} suppress pointer subtraction, since it is necessary. */
        packet_size = (ULONG)(current_packet -> nx_packet_append_ptr - current_packet -> nx_packet_prepend_ptr);
 8009cd6:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8009cd8:	68da      	ldr	r2, [r3, #12]
 8009cda:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8009cdc:	689b      	ldr	r3, [r3, #8]
 8009cde:	1ad3      	subs	r3, r2, r3
 8009ce0:	617b      	str	r3, [r7, #20]

        /* Calculate the end address in this packet. */
        if (data_length > (UINT)packet_size)
 8009ce2:	687a      	ldr	r2, [r7, #4]
 8009ce4:	697b      	ldr	r3, [r7, #20]
 8009ce6:	429a      	cmp	r2, r3
 8009ce8:	d905      	bls.n	8009cf6 <_nx_ip_checksum_compute+0xce>
        {

            /*lint -e{927} -e{923} -e{826} suppress cast of pointer to pointer, since it is necessary  */
            end_ptr = ((ALIGN_TYPE)current_packet -> nx_packet_append_ptr) & (ALIGN_TYPE)(~3);
 8009cea:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8009cec:	68db      	ldr	r3, [r3, #12]
 8009cee:	f023 0303 	bic.w	r3, r3, #3
 8009cf2:	627b      	str	r3, [r7, #36]	; 0x24
 8009cf4:	e006      	b.n	8009d04 <_nx_ip_checksum_compute+0xdc>
        }
        else
        {
#endif /* NX_DISABLE_PACKET_CHAIN */
            /*lint -e{927} -e{826} suppress cast of pointer to pointer, since it is necessary  */
            end_ptr = (ALIGN_TYPE)current_packet -> nx_packet_prepend_ptr + data_length - 3;
 8009cf6:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8009cf8:	689b      	ldr	r3, [r3, #8]
 8009cfa:	461a      	mov	r2, r3
 8009cfc:	687b      	ldr	r3, [r7, #4]
 8009cfe:	4413      	add	r3, r2
 8009d00:	3b03      	subs	r3, #3
 8009d02:	627b      	str	r3, [r7, #36]	; 0x24
        }
#endif /* NX_DISABLE_PACKET_CHAIN */

        /* Set the start address in this packet. */
        /*lint -e{927} -e{826} suppress cast of pointer to pointer, since it is necessary  */
        long_ptr = (ULONG *)current_packet -> nx_packet_prepend_ptr;
 8009d04:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8009d06:	689b      	ldr	r3, [r3, #8]
 8009d08:	62fb      	str	r3, [r7, #44]	; 0x2c

        /*lint -e{946} suppress pointer subtraction, since it is necessary. */
        if ((ALIGN_TYPE)long_ptr < end_ptr)
 8009d0a:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8009d0c:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8009d0e:	429a      	cmp	r2, r3
 8009d10:	d91c      	bls.n	8009d4c <_nx_ip_checksum_compute+0x124>
        {

            /* Calculate the data_length. */
            /*lint -e{923} suppress cast of pointer to ULONG.  */
            data_length -= (UINT)(((end_ptr + 3) & (ALIGN_TYPE)(~3llu)) - (ALIGN_TYPE)long_ptr);
 8009d12:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 8009d14:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8009d16:	3303      	adds	r3, #3
 8009d18:	f023 0303 	bic.w	r3, r3, #3
 8009d1c:	1ad3      	subs	r3, r2, r3
 8009d1e:	687a      	ldr	r2, [r7, #4]
 8009d20:	4413      	add	r3, r2
 8009d22:	607b      	str	r3, [r7, #4]

            /* Loop to calculate the packet's checksum.  */
            /*lint -e{946} suppress pointer subtraction, since it is necessary. */
            while ((ALIGN_TYPE)long_ptr < end_ptr)
 8009d24:	e00e      	b.n	8009d44 <_nx_ip_checksum_compute+0x11c>
            {
                checksum += (*long_ptr & NX_LOWER_16_MASK);
 8009d26:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8009d28:	681b      	ldr	r3, [r3, #0]
 8009d2a:	b29b      	uxth	r3, r3
 8009d2c:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 8009d2e:	4413      	add	r3, r2
 8009d30:	637b      	str	r3, [r7, #52]	; 0x34
                checksum += (*long_ptr >> NX_SHIFT_BY_16);
 8009d32:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8009d34:	681b      	ldr	r3, [r3, #0]
 8009d36:	0c1b      	lsrs	r3, r3, #16
 8009d38:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 8009d3a:	4413      	add	r3, r2
 8009d3c:	637b      	str	r3, [r7, #52]	; 0x34
                long_ptr++;
 8009d3e:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8009d40:	3304      	adds	r3, #4
 8009d42:	62fb      	str	r3, [r7, #44]	; 0x2c
            while ((ALIGN_TYPE)long_ptr < end_ptr)
 8009d44:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8009d46:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8009d48:	429a      	cmp	r2, r3
 8009d4a:	d8ec      	bhi.n	8009d26 <_nx_ip_checksum_compute+0xfe>
            }
        }
#ifndef NX_DISABLE_PACKET_CHAIN

        /* Determine if we are at the end of the current packet.  */
        if ((data_length > 0) && (current_packet -> nx_packet_next))
 8009d4c:	687b      	ldr	r3, [r7, #4]
 8009d4e:	2b00      	cmp	r3, #0
 8009d50:	d018      	beq.n	8009d84 <_nx_ip_checksum_compute+0x15c>
 8009d52:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8009d54:	685b      	ldr	r3, [r3, #4]
 8009d56:	2b00      	cmp	r3, #0
 8009d58:	d014      	beq.n	8009d84 <_nx_ip_checksum_compute+0x15c>
        {

            /* Is append_ptr two bytes aligned but not four bytes aligned? */
            /*lint -e{923} suppress cast of pointer to ULONG.  */
            if ((((ALIGN_TYPE)current_packet -> nx_packet_append_ptr) & 3) == 2)
 8009d5a:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8009d5c:	68db      	ldr	r3, [r3, #12]
 8009d5e:	f003 0303 	and.w	r3, r3, #3
 8009d62:	2b02      	cmp	r3, #2
 8009d64:	d10a      	bne.n	8009d7c <_nx_ip_checksum_compute+0x154>
            {

                /* Yes it is. Process the last two bytes in chaining packets. */
                /*lint -e{929} -e{740} suppress cast of pointer to pointer, since it is necessary  */
                short_ptr = (USHORT *)long_ptr;
 8009d66:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8009d68:	633b      	str	r3, [r7, #48]	; 0x30

                /*lint -e{929} -e{740} suppress cast of pointer to pointer, since it is necessary  */
                checksum += *short_ptr;
 8009d6a:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8009d6c:	881b      	ldrh	r3, [r3, #0]
 8009d6e:	461a      	mov	r2, r3
 8009d70:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8009d72:	4413      	add	r3, r2
 8009d74:	637b      	str	r3, [r7, #52]	; 0x34
                data_length -= 2;
 8009d76:	687b      	ldr	r3, [r7, #4]
 8009d78:	3b02      	subs	r3, #2
 8009d7a:	607b      	str	r3, [r7, #4]
            }

            /* We have crossed the packet boundary.  Move to the next packet
               structure.  */
            current_packet =  current_packet -> nx_packet_next;
 8009d7c:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8009d7e:	685b      	ldr	r3, [r3, #4]
 8009d80:	62bb      	str	r3, [r7, #40]	; 0x28
 8009d82:	e001      	b.n	8009d88 <_nx_ip_checksum_compute+0x160>
        }
        else
        {

            /* End the loop.  */
            current_packet = NX_NULL;
 8009d84:	2300      	movs	r3, #0
 8009d86:	62bb      	str	r3, [r7, #40]	; 0x28
    while (current_packet)
 8009d88:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8009d8a:	2b00      	cmp	r3, #0
 8009d8c:	d1a3      	bne.n	8009cd6 <_nx_ip_checksum_compute+0xae>
        }
    }
#endif /* NX_DISABLE_PACKET_CHAIN */

    /* Determine if there is only one byte left. */
    if (data_length)
 8009d8e:	687b      	ldr	r3, [r7, #4]
 8009d90:	2b00      	cmp	r3, #0
 8009d92:	d01f      	beq.n	8009dd4 <_nx_ip_checksum_compute+0x1ac>
    {

        /* Set the short_ptr. */
        short_ptr = (USHORT *)(long_ptr);
 8009d94:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8009d96:	633b      	str	r3, [r7, #48]	; 0x30

        /* Check the data length.  */
        if (data_length == 1)
 8009d98:	687b      	ldr	r3, [r7, #4]
 8009d9a:	2b01      	cmp	r3, #1
 8009d9c:	d104      	bne.n	8009da8 <_nx_ip_checksum_compute+0x180>
        {
            *((UCHAR *)short_ptr + 1) = 0;
 8009d9e:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8009da0:	3301      	adds	r3, #1
 8009da2:	2200      	movs	r2, #0
 8009da4:	701a      	strb	r2, [r3, #0]
 8009da6:	e00f      	b.n	8009dc8 <_nx_ip_checksum_compute+0x1a0>
        }
        else if (data_length == 3)
 8009da8:	687b      	ldr	r3, [r7, #4]
 8009daa:	2b03      	cmp	r3, #3
 8009dac:	d10c      	bne.n	8009dc8 <_nx_ip_checksum_compute+0x1a0>
        {
            checksum += *short_ptr;
 8009dae:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8009db0:	881b      	ldrh	r3, [r3, #0]
 8009db2:	461a      	mov	r2, r3
 8009db4:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8009db6:	4413      	add	r3, r2
 8009db8:	637b      	str	r3, [r7, #52]	; 0x34
            short_ptr++;
 8009dba:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8009dbc:	3302      	adds	r3, #2
 8009dbe:	633b      	str	r3, [r7, #48]	; 0x30

            *((UCHAR *)short_ptr + 1) = 0;
 8009dc0:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8009dc2:	3301      	adds	r3, #1
 8009dc4:	2200      	movs	r2, #0
 8009dc6:	701a      	strb	r2, [r3, #0]
        }

        checksum += *short_ptr;
 8009dc8:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8009dca:	881b      	ldrh	r3, [r3, #0]
 8009dcc:	461a      	mov	r2, r3
 8009dce:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8009dd0:	4413      	add	r3, r2
 8009dd2:	637b      	str	r3, [r7, #52]	; 0x34
    }

    /* Fold a 4-byte value into a two byte value */
    checksum = (checksum >> 16) + (checksum & 0xFFFF);
 8009dd4:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8009dd6:	0c1a      	lsrs	r2, r3, #16
 8009dd8:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8009dda:	b29b      	uxth	r3, r3
 8009ddc:	4413      	add	r3, r2
 8009dde:	637b      	str	r3, [r7, #52]	; 0x34

    /* Do it again in case previous operation generates an overflow */
    checksum = (checksum >> 16) + (checksum & 0xFFFF);
 8009de0:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8009de2:	0c1a      	lsrs	r2, r3, #16
 8009de4:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8009de6:	b29b      	uxth	r3, r3
 8009de8:	4413      	add	r3, r2
 8009dea:	637b      	str	r3, [r7, #52]	; 0x34

    /* Convert to host byte order. */
    tmp = (USHORT)checksum;
 8009dec:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8009dee:	837b      	strh	r3, [r7, #26]
    NX_CHANGE_USHORT_ENDIAN(tmp);
 8009df0:	8b7b      	ldrh	r3, [r7, #26]
 8009df2:	ba5b      	rev16	r3, r3
 8009df4:	837b      	strh	r3, [r7, #26]

    /* Return the computed checksum.  */
    return(tmp);
 8009df6:	8b7b      	ldrh	r3, [r7, #26]
}
 8009df8:	4618      	mov	r0, r3
 8009dfa:	3738      	adds	r7, #56	; 0x38
 8009dfc:	46bd      	mov	sp, r7
 8009dfe:	bd80      	pop	{r7, pc}

08009e00 <_nx_ip_create>:
/*                                                                        */
/**************************************************************************/
UINT  _nx_ip_create(NX_IP *ip_ptr, CHAR *name, ULONG ip_address, ULONG network_mask,
                    NX_PACKET_POOL *default_pool, VOID (*ip_link_driver)(struct NX_IP_DRIVER_STRUCT *),
                    VOID *memory_ptr, ULONG memory_size, UINT priority)
{
 8009e00:	b580      	push	{r7, lr}
 8009e02:	b092      	sub	sp, #72	; 0x48
 8009e04:	af06      	add	r7, sp, #24
 8009e06:	60f8      	str	r0, [r7, #12]
 8009e08:	60b9      	str	r1, [r7, #8]
 8009e0a:	607a      	str	r2, [r7, #4]
 8009e0c:	603b      	str	r3, [r7, #0]

TX_INTERRUPT_SAVE_AREA

NX_IP     *tail_ptr;
UINT       i;
UINT       old_threshold = 0;
 8009e0e:	2300      	movs	r3, #0
 8009e10:	613b      	str	r3, [r7, #16]
    NX_PARAMETER_NOT_USED(ip_address);
    NX_PARAMETER_NOT_USED(network_mask);
#endif /* NX_DISABLE_IPV4 */

    /* Reference the version ID and option words to ensure they are linked in.  */
    if (((ULONG)_nx_system_build_options_1 | (ULONG)_nx_system_build_options_2 | (ULONG)_nx_system_build_options_3 |
 8009e12:	4b87      	ldr	r3, [pc, #540]	; (800a030 <_nx_ip_create+0x230>)
 8009e14:	681a      	ldr	r2, [r3, #0]
 8009e16:	4b87      	ldr	r3, [pc, #540]	; (800a034 <_nx_ip_create+0x234>)
 8009e18:	681b      	ldr	r3, [r3, #0]
 8009e1a:	431a      	orrs	r2, r3
 8009e1c:	4b86      	ldr	r3, [pc, #536]	; (800a038 <_nx_ip_create+0x238>)
 8009e1e:	681b      	ldr	r3, [r3, #0]
 8009e20:	431a      	orrs	r2, r3
         (ULONG)_nx_system_build_options_4 | (ULONG)_nx_system_build_options_5 | (ULONG)_nx_version_id[0]) == 0)
 8009e22:	4b86      	ldr	r3, [pc, #536]	; (800a03c <_nx_ip_create+0x23c>)
 8009e24:	681b      	ldr	r3, [r3, #0]
    if (((ULONG)_nx_system_build_options_1 | (ULONG)_nx_system_build_options_2 | (ULONG)_nx_system_build_options_3 |
 8009e26:	431a      	orrs	r2, r3
         (ULONG)_nx_system_build_options_4 | (ULONG)_nx_system_build_options_5 | (ULONG)_nx_version_id[0]) == 0)
 8009e28:	4b85      	ldr	r3, [pc, #532]	; (800a040 <_nx_ip_create+0x240>)
 8009e2a:	681b      	ldr	r3, [r3, #0]
 8009e2c:	4313      	orrs	r3, r2
 8009e2e:	4a85      	ldr	r2, [pc, #532]	; (800a044 <_nx_ip_create+0x244>)
 8009e30:	7812      	ldrb	r2, [r2, #0]
 8009e32:	4313      	orrs	r3, r2
    if (((ULONG)_nx_system_build_options_1 | (ULONG)_nx_system_build_options_2 | (ULONG)_nx_system_build_options_3 |
 8009e34:	2b00      	cmp	r3, #0
 8009e36:	d101      	bne.n	8009e3c <_nx_ip_create+0x3c>
    {

        /* We should never get here!  */
        return(NX_NOT_IMPLEMENTED);
 8009e38:	234a      	movs	r3, #74	; 0x4a
 8009e3a:	e0f5      	b.n	800a028 <_nx_ip_create+0x228>
    }

    /* Initialize the IP control block to zero.  */
    memset((void *)ip_ptr, 0, sizeof(NX_IP));
 8009e3c:	f640 02a4 	movw	r2, #2212	; 0x8a4
 8009e40:	2100      	movs	r1, #0
 8009e42:	68f8      	ldr	r0, [r7, #12]
 8009e44:	f015 fd1a 	bl	801f87c <memset>

    /* Configure the primary interface. */
    ip_ptr -> nx_ip_interface[0].nx_interface_valid = 1;
 8009e48:	68fb      	ldr	r3, [r7, #12]
 8009e4a:	2201      	movs	r2, #1
 8009e4c:	f883 2724 	strb.w	r2, [r3, #1828]	; 0x724

#ifndef NX_DISABLE_IPV4
    /* Save the IP address.  */
    ip_ptr -> nx_ip_interface[0].nx_interface_ip_address =   ip_address;
 8009e50:	68fb      	ldr	r3, [r7, #12]
 8009e52:	687a      	ldr	r2, [r7, #4]
 8009e54:	f8c3 2734 	str.w	r2, [r3, #1844]	; 0x734

    /* Save the network mask.  */
    ip_ptr -> nx_ip_interface[0].nx_interface_ip_network_mask =  network_mask;
 8009e58:	68fb      	ldr	r3, [r7, #12]
 8009e5a:	683a      	ldr	r2, [r7, #0]
 8009e5c:	f8c3 2738 	str.w	r2, [r3, #1848]	; 0x738

    /* Derive the network bits of this IP address.  */
    ip_ptr -> nx_ip_interface[0].nx_interface_ip_network =  ip_address & network_mask;
 8009e60:	687a      	ldr	r2, [r7, #4]
 8009e62:	683b      	ldr	r3, [r7, #0]
 8009e64:	401a      	ands	r2, r3
 8009e66:	68fb      	ldr	r3, [r7, #12]
 8009e68:	f8c3 273c 	str.w	r2, [r3, #1852]	; 0x73c

    /* Initialize the ARP defend timeout.  */
    ip_ptr -> nx_ip_interface[0].nx_interface_arp_defend_timeout = 0;
 8009e6c:	68fb      	ldr	r3, [r7, #12]
 8009e6e:	2200      	movs	r2, #0
 8009e70:	f8c3 2760 	str.w	r2, [r3, #1888]	; 0x760
#endif /* !NX_DISABLE_IPV4  */

    /* Setup the link driver address.  */
    ip_ptr -> nx_ip_interface[0].nx_interface_link_driver_entry =  ip_link_driver;
 8009e74:	68fb      	ldr	r3, [r7, #12]
 8009e76:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 8009e78:	f8c3 275c 	str.w	r2, [r3, #1884]	; 0x75c

    /* Set the device interface name to "PRI". */
    /*lint -e{927} -e{826} suppress cast of pointer to pointer, since it is necessary  */
    ip_ptr -> nx_ip_interface[0].nx_interface_name = (CHAR *)"PRI";
 8009e7c:	68fb      	ldr	r3, [r7, #12]
 8009e7e:	4a72      	ldr	r2, [pc, #456]	; (800a048 <_nx_ip_create+0x248>)
 8009e80:	f8c3 2720 	str.w	r2, [r3, #1824]	; 0x720

    /* Set index of each interface. */
    for (i = 0; i < NX_MAX_IP_INTERFACES; i++)
 8009e84:	2300      	movs	r3, #0
 8009e86:	62fb      	str	r3, [r7, #44]	; 0x2c
 8009e88:	e00e      	b.n	8009ea8 <_nx_ip_create+0xa8>
    {
        ip_ptr -> nx_ip_interface[i].nx_interface_index = (UCHAR)i;
 8009e8a:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8009e8c:	b2d8      	uxtb	r0, r3
 8009e8e:	68fa      	ldr	r2, [r7, #12]
 8009e90:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8009e92:	214c      	movs	r1, #76	; 0x4c
 8009e94:	fb01 f303 	mul.w	r3, r1, r3
 8009e98:	4413      	add	r3, r2
 8009e9a:	f203 7327 	addw	r3, r3, #1831	; 0x727
 8009e9e:	4602      	mov	r2, r0
 8009ea0:	701a      	strb	r2, [r3, #0]
    for (i = 0; i < NX_MAX_IP_INTERFACES; i++)
 8009ea2:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8009ea4:	3301      	adds	r3, #1
 8009ea6:	62fb      	str	r3, [r7, #44]	; 0x2c
 8009ea8:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8009eaa:	2b04      	cmp	r3, #4
 8009eac:	d9ed      	bls.n	8009e8a <_nx_ip_create+0x8a>

#ifndef NX_DISABLE_LOOPBACK_INTERFACE

    /* Set the Loopback interface name. */
    /*lint -e{927} -e{826} suppress cast of pointer to pointer, since it is necessary  */
    ip_ptr -> nx_ip_interface[NX_LOOPBACK_INTERFACE].nx_interface_name = (CHAR *)"Internal IP Loopback";
 8009eae:	68fb      	ldr	r3, [r7, #12]
 8009eb0:	4a66      	ldr	r2, [pc, #408]	; (800a04c <_nx_ip_create+0x24c>)
 8009eb2:	f8c3 2850 	str.w	r2, [r3, #2128]	; 0x850


    /* Mark the loopback interface as valid. */
    ip_ptr -> nx_ip_interface[NX_LOOPBACK_INTERFACE].nx_interface_valid = 1;
 8009eb6:	68fb      	ldr	r3, [r7, #12]
 8009eb8:	2201      	movs	r2, #1
 8009eba:	f883 2854 	strb.w	r2, [r3, #2132]	; 0x854

#ifndef NX_DISABLE_IPV4
    /* Set the loopback interface address. */
    ip_ptr -> nx_ip_interface[NX_LOOPBACK_INTERFACE].nx_interface_ip_address = 0x7F000001;
 8009ebe:	68fb      	ldr	r3, [r7, #12]
 8009ec0:	4a63      	ldr	r2, [pc, #396]	; (800a050 <_nx_ip_create+0x250>)
 8009ec2:	f8c3 2864 	str.w	r2, [r3, #2148]	; 0x864
    ip_ptr -> nx_ip_interface[NX_LOOPBACK_INTERFACE].nx_interface_ip_network_mask = 0xFF000000;
 8009ec6:	68fb      	ldr	r3, [r7, #12]
 8009ec8:	f04f 427f 	mov.w	r2, #4278190080	; 0xff000000
 8009ecc:	f8c3 2868 	str.w	r2, [r3, #2152]	; 0x868
    ip_ptr -> nx_ip_interface[NX_LOOPBACK_INTERFACE].nx_interface_ip_network = 0x7F000000;
 8009ed0:	68fb      	ldr	r3, [r7, #12]
 8009ed2:	f04f 42fe 	mov.w	r2, #2130706432	; 0x7f000000
 8009ed6:	f8c3 286c 	str.w	r2, [r3, #2156]	; 0x86c
#endif /* !NX_DISABLE_IPV4  */

    /* Loopback interface is a special case. Therefore no dedicated link driver needed. */
    ip_ptr -> nx_ip_interface[NX_LOOPBACK_INTERFACE].nx_interface_link_driver_entry = NX_NULL;
 8009eda:	68fb      	ldr	r3, [r7, #12]
 8009edc:	2200      	movs	r2, #0
 8009ede:	f8c3 288c 	str.w	r2, [r3, #2188]	; 0x88c

    /* Loopback interface does not need IP/MAC address mapping. */
    ip_ptr -> nx_ip_interface[NX_LOOPBACK_INTERFACE].nx_interface_address_mapping_needed = 0;
 8009ee2:	68fb      	ldr	r3, [r7, #12]
 8009ee4:	2200      	movs	r2, #0
 8009ee6:	f883 2855 	strb.w	r2, [r3, #2133]	; 0x855

    /* There is actually no MTU limit for the loopback interface. */
    ip_ptr -> nx_ip_interface[NX_LOOPBACK_INTERFACE].nx_interface_ip_mtu_size = 65535;
 8009eea:	68fb      	ldr	r3, [r7, #12]
 8009eec:	f64f 72ff 	movw	r2, #65535	; 0xffff
 8009ef0:	f8c3 2874 	str.w	r2, [r3, #2164]	; 0x874

    /* Mark the loopback interface as LINK UP */
    ip_ptr -> nx_ip_interface[NX_LOOPBACK_INTERFACE].nx_interface_link_up = 1;
 8009ef4:	68fb      	ldr	r3, [r7, #12]
 8009ef6:	2201      	movs	r2, #1
 8009ef8:	f883 2856 	strb.w	r2, [r3, #2134]	; 0x856
#endif /* NX_ENABLE_INTERFACE_CAPABILITY */

#endif /* !NX_DISABLE_LOOPBACK_INTERFACE */

    /* Save the supplied IP name.  */
    ip_ptr -> nx_ip_name =  name;
 8009efc:	68fb      	ldr	r3, [r7, #12]
 8009efe:	68ba      	ldr	r2, [r7, #8]
 8009f00:	605a      	str	r2, [r3, #4]

    /* Set the initial IP packet ID.  */
    ip_ptr -> nx_ip_packet_id =  NX_INIT_PACKET_ID;
 8009f02:	68fb      	ldr	r3, [r7, #12]
 8009f04:	2201      	movs	r2, #1
 8009f06:	f8c3 2134 	str.w	r2, [r3, #308]	; 0x134

    /* Setup the default packet pool for this IP instance.  */
    ip_ptr -> nx_ip_default_packet_pool =  default_pool;
 8009f0a:	68fb      	ldr	r3, [r7, #12]
 8009f0c:	6bba      	ldr	r2, [r7, #56]	; 0x38
 8009f0e:	f8c3 2138 	str.w	r2, [r3, #312]	; 0x138
    /* Setup the auxiliary packet pool for this IP instance. By default it pointers to default pool. */
    ip_ptr -> nx_ip_auxiliary_packet_pool = default_pool;
#endif /* NX_ENABLE_DUAL_PACKET_POOL */

    /* Create the internal IP protection mutex.  */
    tx_mutex_create(&(ip_ptr -> nx_ip_protection), name, TX_NO_INHERIT);
 8009f12:	68fb      	ldr	r3, [r7, #12]
 8009f14:	f503 739e 	add.w	r3, r3, #316	; 0x13c
 8009f18:	2200      	movs	r2, #0
 8009f1a:	68b9      	ldr	r1, [r7, #8]
 8009f1c:	4618      	mov	r0, r3
 8009f1e:	f008 fe25 	bl	8012b6c <_tx_mutex_create>

    /* Create the internal IP event flag object.  */
    tx_event_flags_create(&(ip_ptr -> nx_ip_events), name);
 8009f22:	68fb      	ldr	r3, [r7, #12]
 8009f24:	f503 7313 	add.w	r3, r3, #588	; 0x24c
 8009f28:	68b9      	ldr	r1, [r7, #8]
 8009f2a:	4618      	mov	r0, r3
 8009f2c:	f008 f9ae 	bl	801228c <_tx_event_flags_create>

    /* Pickup current thread pointer.  */
    current_thread =  tx_thread_identify();
 8009f30:	f00a fc60 	bl	80147f4 <_tx_thread_identify>
 8009f34:	62b8      	str	r0, [r7, #40]	; 0x28

    /* Disable preemption temporarily.  */
    if (current_thread)
 8009f36:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8009f38:	2b00      	cmp	r3, #0
 8009f3a:	d006      	beq.n	8009f4a <_nx_ip_create+0x14a>
    {
        tx_thread_preemption_change(current_thread, priority, &old_threshold);
 8009f3c:	f107 0310 	add.w	r3, r7, #16
 8009f40:	461a      	mov	r2, r3
 8009f42:	6cb9      	ldr	r1, [r7, #72]	; 0x48
 8009f44:	6ab8      	ldr	r0, [r7, #40]	; 0x28
 8009f46:	f00a fcaf 	bl	80148a8 <_tx_thread_preemption_change>
    }

    /* Create the internal IP thread for handling more processing intensive
       duties.  */
    /*lint -e{923} suppress cast of pointer to ULONG.  */
    tx_thread_create(&(ip_ptr -> nx_ip_thread), name, _nx_ip_thread_entry, (ULONG)(ALIGN_TYPE)(ip_ptr),
 8009f4a:	68fb      	ldr	r3, [r7, #12]
 8009f4c:	f503 70cc 	add.w	r0, r3, #408	; 0x198
 8009f50:	68fa      	ldr	r2, [r7, #12]
 8009f52:	2301      	movs	r3, #1
 8009f54:	9305      	str	r3, [sp, #20]
 8009f56:	2301      	movs	r3, #1
 8009f58:	9304      	str	r3, [sp, #16]
 8009f5a:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 8009f5c:	9303      	str	r3, [sp, #12]
 8009f5e:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 8009f60:	9302      	str	r3, [sp, #8]
 8009f62:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8009f64:	9301      	str	r3, [sp, #4]
 8009f66:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8009f68:	9300      	str	r3, [sp, #0]
 8009f6a:	4613      	mov	r3, r2
 8009f6c:	4a39      	ldr	r2, [pc, #228]	; (800a054 <_nx_ip_create+0x254>)
 8009f6e:	68b9      	ldr	r1, [r7, #8]
 8009f70:	f00a faf0 	bl	8014554 <_tx_thread_create>

    NX_THREAD_EXTENSION_PTR_SET(&(ip_ptr -> nx_ip_thread), ip_ptr)

    /* Create the periodic timer for this IP instance.  */
    /*lint -e{923} suppress cast of pointer to ULONG.  */
    tx_timer_create(&(ip_ptr -> nx_ip_periodic_timer), name,
 8009f74:	68fb      	ldr	r3, [r7, #12]
 8009f76:	f503 701c 	add.w	r0, r3, #624	; 0x270
 8009f7a:	68fb      	ldr	r3, [r7, #12]
 8009f7c:	2201      	movs	r2, #1
 8009f7e:	9202      	str	r2, [sp, #8]
 8009f80:	2264      	movs	r2, #100	; 0x64
 8009f82:	9201      	str	r2, [sp, #4]
 8009f84:	2264      	movs	r2, #100	; 0x64
 8009f86:	9200      	str	r2, [sp, #0]
 8009f88:	4a33      	ldr	r2, [pc, #204]	; (800a058 <_nx_ip_create+0x258>)
 8009f8a:	68b9      	ldr	r1, [r7, #8]
 8009f8c:	f00b fb1e 	bl	80155cc <_tx_timer_create>
    /* If trace is enabled, insert this event into the trace buffer.  */
    NX_TRACE_IN_LINE_INSERT(NX_TRACE_IP_CREATE, ip_ptr, ip_address, network_mask, default_pool, NX_TRACE_IP_EVENTS, 0, 0);

#ifndef NX_DISABLE_IPV4
    /* Install IPv4 packet receive processing function pointer */
    ip_ptr -> nx_ipv4_packet_receive = _nx_ipv4_packet_receive;
 8009f90:	68fb      	ldr	r3, [r7, #12]
 8009f92:	4a32      	ldr	r2, [pc, #200]	; (800a05c <_nx_ip_create+0x25c>)
 8009f94:	f8c3 289c 	str.w	r2, [r3, #2204]	; 0x89c
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 8009f98:	f3ef 8310 	mrs	r3, PRIMASK
 8009f9c:	61fb      	str	r3, [r7, #28]
    return(posture);
 8009f9e:	69fb      	ldr	r3, [r7, #28]
    int_posture = __get_interrupt_posture();
 8009fa0:	61bb      	str	r3, [r7, #24]
    __asm__ volatile ("CPSID i" : : : "memory");
 8009fa2:	b672      	cpsid	i
    return(int_posture);
 8009fa4:	69bb      	ldr	r3, [r7, #24]
#endif

    /* Otherwise, the IP initialization was successful.  Place the
       IP control block on the list of created IP instances.  */
    TX_DISABLE
 8009fa6:	627b      	str	r3, [r7, #36]	; 0x24

    /* Load the IP ID field in the IP control block.  */
    ip_ptr -> nx_ip_id =  NX_IP_ID;
 8009fa8:	68fb      	ldr	r3, [r7, #12]
 8009faa:	4a2d      	ldr	r2, [pc, #180]	; (800a060 <_nx_ip_create+0x260>)
 8009fac:	601a      	str	r2, [r3, #0]

    /* Place the new IP control block on the list of created IPs.  First,
       check for an empty list.  */
    if (_nx_ip_created_ptr)
 8009fae:	4b2d      	ldr	r3, [pc, #180]	; (800a064 <_nx_ip_create+0x264>)
 8009fb0:	681b      	ldr	r3, [r3, #0]
 8009fb2:	2b00      	cmp	r3, #0
 8009fb4:	d017      	beq.n	8009fe6 <_nx_ip_create+0x1e6>
    {

        /* Pickup tail pointer.  */
        tail_ptr =  _nx_ip_created_ptr -> nx_ip_created_previous;
 8009fb6:	4b2b      	ldr	r3, [pc, #172]	; (800a064 <_nx_ip_create+0x264>)
 8009fb8:	681b      	ldr	r3, [r3, #0]
 8009fba:	f8d3 3714 	ldr.w	r3, [r3, #1812]	; 0x714
 8009fbe:	623b      	str	r3, [r7, #32]

        /* Place the new IP control block in the list.  */
        _nx_ip_created_ptr -> nx_ip_created_previous =  ip_ptr;
 8009fc0:	4b28      	ldr	r3, [pc, #160]	; (800a064 <_nx_ip_create+0x264>)
 8009fc2:	681b      	ldr	r3, [r3, #0]
 8009fc4:	68fa      	ldr	r2, [r7, #12]
 8009fc6:	f8c3 2714 	str.w	r2, [r3, #1812]	; 0x714
        tail_ptr -> nx_ip_created_next =  ip_ptr;
 8009fca:	6a3b      	ldr	r3, [r7, #32]
 8009fcc:	68fa      	ldr	r2, [r7, #12]
 8009fce:	f8c3 2710 	str.w	r2, [r3, #1808]	; 0x710

        /* Setup this IP's created links.  */
        ip_ptr -> nx_ip_created_previous =  tail_ptr;
 8009fd2:	68fb      	ldr	r3, [r7, #12]
 8009fd4:	6a3a      	ldr	r2, [r7, #32]
 8009fd6:	f8c3 2714 	str.w	r2, [r3, #1812]	; 0x714
        ip_ptr -> nx_ip_created_next =      _nx_ip_created_ptr;
 8009fda:	4b22      	ldr	r3, [pc, #136]	; (800a064 <_nx_ip_create+0x264>)
 8009fdc:	681a      	ldr	r2, [r3, #0]
 8009fde:	68fb      	ldr	r3, [r7, #12]
 8009fe0:	f8c3 2710 	str.w	r2, [r3, #1808]	; 0x710
 8009fe4:	e00a      	b.n	8009ffc <_nx_ip_create+0x1fc>
    }
    else
    {

        /* The created IP list is empty.  Add IP control block to empty list.  */
        _nx_ip_created_ptr =                ip_ptr;
 8009fe6:	4a1f      	ldr	r2, [pc, #124]	; (800a064 <_nx_ip_create+0x264>)
 8009fe8:	68fb      	ldr	r3, [r7, #12]
 8009fea:	6013      	str	r3, [r2, #0]
        ip_ptr -> nx_ip_created_next =      ip_ptr;
 8009fec:	68fb      	ldr	r3, [r7, #12]
 8009fee:	68fa      	ldr	r2, [r7, #12]
 8009ff0:	f8c3 2710 	str.w	r2, [r3, #1808]	; 0x710
        ip_ptr -> nx_ip_created_previous =  ip_ptr;
 8009ff4:	68fb      	ldr	r3, [r7, #12]
 8009ff6:	68fa      	ldr	r2, [r7, #12]
 8009ff8:	f8c3 2714 	str.w	r2, [r3, #1812]	; 0x714
    }

    /* Increment the created IP counter.  */
    _nx_ip_created_count++;
 8009ffc:	4b1a      	ldr	r3, [pc, #104]	; (800a068 <_nx_ip_create+0x268>)
 8009ffe:	681b      	ldr	r3, [r3, #0]
 800a000:	3301      	adds	r3, #1
 800a002:	4a19      	ldr	r2, [pc, #100]	; (800a068 <_nx_ip_create+0x268>)
 800a004:	6013      	str	r3, [r2, #0]
 800a006:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800a008:	617b      	str	r3, [r7, #20]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 800a00a:	697b      	ldr	r3, [r7, #20]
 800a00c:	f383 8810 	msr	PRIMASK, r3
}
 800a010:	bf00      	nop

    /* Restore previous interrupt posture.  */
    TX_RESTORE

    /* Restore preemption.  */
    if (current_thread)
 800a012:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800a014:	2b00      	cmp	r3, #0
 800a016:	d006      	beq.n	800a026 <_nx_ip_create+0x226>
    {

        /*lint -e{644} suppress variable might not be initialized, since "old_threshold" was initialized in previous tx_thread_preemption_change call. */
        tx_thread_preemption_change(current_thread, old_threshold, &old_threshold);
 800a018:	693b      	ldr	r3, [r7, #16]
 800a01a:	f107 0210 	add.w	r2, r7, #16
 800a01e:	4619      	mov	r1, r3
 800a020:	6ab8      	ldr	r0, [r7, #40]	; 0x28
 800a022:	f00a fc41 	bl	80148a8 <_tx_thread_preemption_change>
    }

    /* Return success to the caller.  */
    return(NX_SUCCESS);
 800a026:	2300      	movs	r3, #0
}
 800a028:	4618      	mov	r0, r3
 800a02a:	3730      	adds	r7, #48	; 0x30
 800a02c:	46bd      	mov	sp, r7
 800a02e:	bd80      	pop	{r7, pc}
 800a030:	24000b18 	.word	0x24000b18
 800a034:	24000b1c 	.word	0x24000b1c
 800a038:	24000b20 	.word	0x24000b20
 800a03c:	24000b24 	.word	0x24000b24
 800a040:	24000b28 	.word	0x24000b28
 800a044:	24000014 	.word	0x24000014
 800a048:	08021e18 	.word	0x08021e18
 800a04c:	08021e1c 	.word	0x08021e1c
 800a050:	7f000001 	.word	0x7f000001
 800a054:	0800b105 	.word	0x0800b105
 800a058:	0800adf1 	.word	0x0800adf1
 800a05c:	0800b695 	.word	0x0800b695
 800a060:	49502020 	.word	0x49502020
 800a064:	24000b08 	.word	0x24000b08
 800a068:	24000b0c 	.word	0x24000b0c

0800a06c <_nx_ip_deferred_link_status_process>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
VOID _nx_ip_deferred_link_status_process(NX_IP *ip_ptr)
{
 800a06c:	b580      	push	{r7, lr}
 800a06e:	b08c      	sub	sp, #48	; 0x30
 800a070:	af00      	add	r7, sp, #0
 800a072:	6078      	str	r0, [r7, #4]

UINT         i;
NX_IP_DRIVER driver_request;
ULONG        link_up;

    if (ip_ptr -> nx_ip_link_status_change_callback == NX_NULL)
 800a074:	687b      	ldr	r3, [r7, #4]
 800a076:	f8d3 38a0 	ldr.w	r3, [r3, #2208]	; 0x8a0
 800a07a:	2b00      	cmp	r3, #0
 800a07c:	d04d      	beq.n	800a11a <_nx_ip_deferred_link_status_process+0xae>

        /* Callback function is not set. */
        return;
    }

    for (i = 0; i < NX_MAX_PHYSICAL_INTERFACES; i++)
 800a07e:	2300      	movs	r3, #0
 800a080:	62fb      	str	r3, [r7, #44]	; 0x2c
 800a082:	e046      	b.n	800a112 <_nx_ip_deferred_link_status_process+0xa6>
    {
        if ((ip_ptr -> nx_ip_interface[i].nx_interface_valid) &&
 800a084:	687a      	ldr	r2, [r7, #4]
 800a086:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800a088:	214c      	movs	r1, #76	; 0x4c
 800a08a:	fb01 f303 	mul.w	r3, r1, r3
 800a08e:	4413      	add	r3, r2
 800a090:	f203 7324 	addw	r3, r3, #1828	; 0x724
 800a094:	781b      	ldrb	r3, [r3, #0]
 800a096:	2b00      	cmp	r3, #0
 800a098:	d038      	beq.n	800a10c <_nx_ip_deferred_link_status_process+0xa0>
            (ip_ptr -> nx_ip_interface[i].nx_interface_link_status_change))
 800a09a:	687a      	ldr	r2, [r7, #4]
 800a09c:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800a09e:	214c      	movs	r1, #76	; 0x4c
 800a0a0:	fb01 f303 	mul.w	r3, r1, r3
 800a0a4:	4413      	add	r3, r2
 800a0a6:	f503 63e5 	add.w	r3, r3, #1832	; 0x728
 800a0aa:	781b      	ldrb	r3, [r3, #0]
        if ((ip_ptr -> nx_ip_interface[i].nx_interface_valid) &&
 800a0ac:	2b00      	cmp	r3, #0
 800a0ae:	d02d      	beq.n	800a10c <_nx_ip_deferred_link_status_process+0xa0>
        {

            /* Reset the flag. */
            ip_ptr -> nx_ip_interface[i].nx_interface_link_status_change = NX_FALSE;
 800a0b0:	687a      	ldr	r2, [r7, #4]
 800a0b2:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800a0b4:	214c      	movs	r1, #76	; 0x4c
 800a0b6:	fb01 f303 	mul.w	r3, r1, r3
 800a0ba:	4413      	add	r3, r2
 800a0bc:	f503 63e5 	add.w	r3, r3, #1832	; 0x728
 800a0c0:	2200      	movs	r2, #0
 800a0c2:	701a      	strb	r2, [r3, #0]

            driver_request.nx_ip_driver_ptr       = ip_ptr;
 800a0c4:	687b      	ldr	r3, [r7, #4]
 800a0c6:	627b      	str	r3, [r7, #36]	; 0x24
            driver_request.nx_ip_driver_command   = NX_LINK_GET_STATUS;
 800a0c8:	230a      	movs	r3, #10
 800a0ca:	60fb      	str	r3, [r7, #12]
            driver_request.nx_ip_driver_interface = &(ip_ptr -> nx_ip_interface[i]);
 800a0cc:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800a0ce:	224c      	movs	r2, #76	; 0x4c
 800a0d0:	fb02 f303 	mul.w	r3, r2, r3
 800a0d4:	f503 63e4 	add.w	r3, r3, #1824	; 0x720
 800a0d8:	687a      	ldr	r2, [r7, #4]
 800a0da:	4413      	add	r3, r2
 800a0dc:	62bb      	str	r3, [r7, #40]	; 0x28
            driver_request.nx_ip_driver_return_ptr = &link_up;
 800a0de:	f107 0308 	add.w	r3, r7, #8
 800a0e2:	623b      	str	r3, [r7, #32]

            (ip_ptr -> nx_ip_interface[i].nx_interface_link_driver_entry)(&driver_request);
 800a0e4:	687a      	ldr	r2, [r7, #4]
 800a0e6:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800a0e8:	214c      	movs	r1, #76	; 0x4c
 800a0ea:	fb01 f303 	mul.w	r3, r1, r3
 800a0ee:	4413      	add	r3, r2
 800a0f0:	f203 735c 	addw	r3, r3, #1884	; 0x75c
 800a0f4:	681b      	ldr	r3, [r3, #0]
 800a0f6:	f107 020c 	add.w	r2, r7, #12
 800a0fa:	4610      	mov	r0, r2
 800a0fc:	4798      	blx	r3

            /* Invoke the callback function. */
            /*lint -e{644} suppress variable might not be initialized, since "link_up" was initialized in nx_interface_link_driver_entry. */
            ip_ptr -> nx_ip_link_status_change_callback(ip_ptr, i, link_up);
 800a0fe:	687b      	ldr	r3, [r7, #4]
 800a100:	f8d3 38a0 	ldr.w	r3, [r3, #2208]	; 0x8a0
 800a104:	68ba      	ldr	r2, [r7, #8]
 800a106:	6af9      	ldr	r1, [r7, #44]	; 0x2c
 800a108:	6878      	ldr	r0, [r7, #4]
 800a10a:	4798      	blx	r3
    for (i = 0; i < NX_MAX_PHYSICAL_INTERFACES; i++)
 800a10c:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800a10e:	3301      	adds	r3, #1
 800a110:	62fb      	str	r3, [r7, #44]	; 0x2c
 800a112:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800a114:	2b03      	cmp	r3, #3
 800a116:	d9b5      	bls.n	800a084 <_nx_ip_deferred_link_status_process+0x18>
 800a118:	e000      	b.n	800a11c <_nx_ip_deferred_link_status_process+0xb0>
        return;
 800a11a:	bf00      	nop
        }
    }
}
 800a11c:	3730      	adds	r7, #48	; 0x30
 800a11e:	46bd      	mov	sp, r7
 800a120:	bd80      	pop	{r7, pc}
	...

0800a124 <_nx_ip_dispatch_process>:
/*                                            destination header check,   */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
UINT _nx_ip_dispatch_process(NX_IP *ip_ptr, NX_PACKET *packet_ptr, UINT protocol)
{
 800a124:	b580      	push	{r7, lr}
 800a126:	b086      	sub	sp, #24
 800a128:	af00      	add	r7, sp, #0
 800a12a:	60f8      	str	r0, [r7, #12]
 800a12c:	60b9      	str	r1, [r7, #8]
 800a12e:	607a      	str	r2, [r7, #4]
#endif /* FEATURE_NX_IPV6 */
#endif /* NX_IPSEC_ENABLE */


    /* Initialize local variables. */
    drop_packet = 0;
 800a130:	2300      	movs	r3, #0
 800a132:	617b      	str	r3, [r7, #20]
    next_option_offset = (UINT)sizeof(NX_IPV6_HEADER);
    incoming_addr = packet_ptr -> nx_packet_address.nx_packet_ipv6_address_ptr;
#endif /* FEATURE_NX_IPV6 */

    /* Parse all options in the packet till we're done or an error is encountered. */
    while (!drop_packet)
 800a134:	e09a      	b.n	800a26c <_nx_ip_dispatch_process+0x148>

#if defined(FEATURE_NX_IPV6) && !defined(NX_DISABLE_ICMPV6_ERROR_MESSAGE)
        /* Set a local variable for convenience. */
        nx_packet_option_offset = packet_ptr -> nx_packet_option_offset;
#endif /* defined(FEATURE_NX_IPV6) && !defined(NX_DISABLE_ICMPV6_ERROR_MESSAGE) */
        switch (protocol)
 800a136:	687b      	ldr	r3, [r7, #4]
 800a138:	2b32      	cmp	r3, #50	; 0x32
 800a13a:	d005      	beq.n	800a148 <_nx_ip_dispatch_process+0x24>
 800a13c:	687b      	ldr	r3, [r7, #4]
 800a13e:	2b33      	cmp	r3, #51	; 0x33
 800a140:	d104      	bne.n	800a14c <_nx_ip_dispatch_process+0x28>
                /* Continue processing the packet if status = NX_IPSEC_PKT_CONT */
            }
#else /* NX_IPSEC_ENABLE */

            /* Drop this packet if IPsec module is not present. */
            drop_packet = 1;
 800a142:	2301      	movs	r3, #1
 800a144:	617b      	str	r3, [r7, #20]
#endif /* NX_IPSEC_ENABLE */

            break;
 800a146:	e07d      	b.n	800a244 <_nx_ip_dispatch_process+0x120>
            }
            break;

#else /* NX_IPSEC_ENABLE */
            /* Drop this packet if IPsec module is not present. */
            return(1);
 800a148:	2301      	movs	r3, #1
 800a14a:	e094      	b.n	800a276 <_nx_ip_dispatch_process+0x152>
                    return(NX_INVALID_PACKET);
                }
            }
#endif /* NX_IPSEC_ENABLE */

            if (protocol == NX_PROTOCOL_TCP)
 800a14c:	687b      	ldr	r3, [r7, #4]
 800a14e:	2b06      	cmp	r3, #6
 800a150:	d10f      	bne.n	800a172 <_nx_ip_dispatch_process+0x4e>
                     (incoming_addr -> nxd_ipv6_address_state == NX_IPV6_ADDR_STATE_VALID)))
                {
#endif /* FEATURE_NX_IPV6 */

                    /* Check that the host is enabled for TCP. */
                    if (ip_ptr -> nx_ip_tcp_packet_receive)
 800a152:	68fb      	ldr	r3, [r7, #12]
 800a154:	f8d3 3494 	ldr.w	r3, [r3, #1172]	; 0x494
 800a158:	2b00      	cmp	r3, #0
 800a15a:	d007      	beq.n	800a16c <_nx_ip_dispatch_process+0x48>
                    {

                        /* Dispatch the packet to the TCP packet handler. */
                        (ip_ptr -> nx_ip_tcp_packet_receive)(ip_ptr, packet_ptr);
 800a15c:	68fb      	ldr	r3, [r7, #12]
 800a15e:	f8d3 3494 	ldr.w	r3, [r3, #1172]	; 0x494
 800a162:	68b9      	ldr	r1, [r7, #8]
 800a164:	68f8      	ldr	r0, [r7, #12]
 800a166:	4798      	blx	r3

                        /* No need to free the packet as it is consumed by TCP packet receive.  */
                        return(0);
 800a168:	2300      	movs	r3, #0
 800a16a:	e084      	b.n	800a276 <_nx_ip_dispatch_process+0x152>
#ifdef FEATURE_NX_IPV6
                }
#endif /* FEATURE_NX_IPV6 */

                /* TCP is not enabled.  Drop the packet. */
                drop_packet = 1;
 800a16c:	2301      	movs	r3, #1
 800a16e:	617b      	str	r3, [r7, #20]
#endif /* NX_DISABLE_IP_INFO */


                drop_packet = 1;
            }
            break;
 800a170:	e067      	b.n	800a242 <_nx_ip_dispatch_process+0x11e>
            else if ((packet_ptr -> nx_packet_ip_version == NX_IP_VERSION_V4) &&
 800a172:	68bb      	ldr	r3, [r7, #8]
 800a174:	f893 302c 	ldrb.w	r3, [r3, #44]	; 0x2c
 800a178:	2b04      	cmp	r3, #4
 800a17a:	d112      	bne.n	800a1a2 <_nx_ip_dispatch_process+0x7e>
 800a17c:	687b      	ldr	r3, [r7, #4]
 800a17e:	2b01      	cmp	r3, #1
 800a180:	d10f      	bne.n	800a1a2 <_nx_ip_dispatch_process+0x7e>
                if (ip_ptr -> nx_ip_icmp_packet_receive != NX_NULL)
 800a182:	68fb      	ldr	r3, [r7, #12]
 800a184:	f8d3 3368 	ldr.w	r3, [r3, #872]	; 0x368
 800a188:	2b00      	cmp	r3, #0
 800a18a:	d007      	beq.n	800a19c <_nx_ip_dispatch_process+0x78>
                    ip_ptr -> nx_ip_icmp_packet_receive(ip_ptr, packet_ptr);
 800a18c:	68fb      	ldr	r3, [r7, #12]
 800a18e:	f8d3 3368 	ldr.w	r3, [r3, #872]	; 0x368
 800a192:	68b9      	ldr	r1, [r7, #8]
 800a194:	68f8      	ldr	r0, [r7, #12]
 800a196:	4798      	blx	r3
                    return(0);
 800a198:	2300      	movs	r3, #0
 800a19a:	e06c      	b.n	800a276 <_nx_ip_dispatch_process+0x152>
                drop_packet = 1;
 800a19c:	2301      	movs	r3, #1
 800a19e:	617b      	str	r3, [r7, #20]
 800a1a0:	e04f      	b.n	800a242 <_nx_ip_dispatch_process+0x11e>
            else if ((packet_ptr -> nx_packet_ip_version == NX_IP_VERSION_V4) &&
 800a1a2:	68bb      	ldr	r3, [r7, #8]
 800a1a4:	f893 302c 	ldrb.w	r3, [r3, #44]	; 0x2c
 800a1a8:	2b04      	cmp	r3, #4
 800a1aa:	d112      	bne.n	800a1d2 <_nx_ip_dispatch_process+0xae>
 800a1ac:	687b      	ldr	r3, [r7, #4]
 800a1ae:	2b02      	cmp	r3, #2
 800a1b0:	d10f      	bne.n	800a1d2 <_nx_ip_dispatch_process+0xae>
                if (ip_ptr -> nx_ip_igmp_packet_receive != NX_NULL)
 800a1b2:	68fb      	ldr	r3, [r7, #12]
 800a1b4:	f8d3 3354 	ldr.w	r3, [r3, #852]	; 0x354
 800a1b8:	2b00      	cmp	r3, #0
 800a1ba:	d007      	beq.n	800a1cc <_nx_ip_dispatch_process+0xa8>
                    ip_ptr -> nx_ip_igmp_packet_receive(ip_ptr, packet_ptr);
 800a1bc:	68fb      	ldr	r3, [r7, #12]
 800a1be:	f8d3 3354 	ldr.w	r3, [r3, #852]	; 0x354
 800a1c2:	68b9      	ldr	r1, [r7, #8]
 800a1c4:	68f8      	ldr	r0, [r7, #12]
 800a1c6:	4798      	blx	r3
                    return(0);
 800a1c8:	2300      	movs	r3, #0
 800a1ca:	e054      	b.n	800a276 <_nx_ip_dispatch_process+0x152>
                drop_packet = 1;
 800a1cc:	2301      	movs	r3, #1
 800a1ce:	617b      	str	r3, [r7, #20]
 800a1d0:	e037      	b.n	800a242 <_nx_ip_dispatch_process+0x11e>
            else if (protocol == NX_PROTOCOL_UDP)
 800a1d2:	687b      	ldr	r3, [r7, #4]
 800a1d4:	2b11      	cmp	r3, #17
 800a1d6:	d10f      	bne.n	800a1f8 <_nx_ip_dispatch_process+0xd4>
                    if (ip_ptr -> nx_ip_udp_packet_receive)
 800a1d8:	68fb      	ldr	r3, [r7, #12]
 800a1da:	f8d3 3408 	ldr.w	r3, [r3, #1032]	; 0x408
 800a1de:	2b00      	cmp	r3, #0
 800a1e0:	d007      	beq.n	800a1f2 <_nx_ip_dispatch_process+0xce>
                        (ip_ptr -> nx_ip_udp_packet_receive)(ip_ptr, packet_ptr);
 800a1e2:	68fb      	ldr	r3, [r7, #12]
 800a1e4:	f8d3 3408 	ldr.w	r3, [r3, #1032]	; 0x408
 800a1e8:	68b9      	ldr	r1, [r7, #8]
 800a1ea:	68f8      	ldr	r0, [r7, #12]
 800a1ec:	4798      	blx	r3
                        return(0);
 800a1ee:	2300      	movs	r3, #0
 800a1f0:	e041      	b.n	800a276 <_nx_ip_dispatch_process+0x152>
                drop_packet = 1;
 800a1f2:	2301      	movs	r3, #1
 800a1f4:	617b      	str	r3, [r7, #20]
            break;
 800a1f6:	e024      	b.n	800a242 <_nx_ip_dispatch_process+0x11e>
                if (ip_ptr -> nx_ip_raw_ip_processing)
 800a1f8:	68fb      	ldr	r3, [r7, #12]
 800a1fa:	f8d3 317c 	ldr.w	r3, [r3, #380]	; 0x17c
 800a1fe:	2b00      	cmp	r3, #0
 800a200:	d00c      	beq.n	800a21c <_nx_ip_dispatch_process+0xf8>
                    if ((ip_ptr -> nx_ip_raw_ip_processing)(ip_ptr, protocol << 16, packet_ptr) == NX_SUCCESS)
 800a202:	68fb      	ldr	r3, [r7, #12]
 800a204:	f8d3 317c 	ldr.w	r3, [r3, #380]	; 0x17c
 800a208:	687a      	ldr	r2, [r7, #4]
 800a20a:	0411      	lsls	r1, r2, #16
 800a20c:	68ba      	ldr	r2, [r7, #8]
 800a20e:	68f8      	ldr	r0, [r7, #12]
 800a210:	4798      	blx	r3
 800a212:	4603      	mov	r3, r0
 800a214:	2b00      	cmp	r3, #0
 800a216:	d101      	bne.n	800a21c <_nx_ip_dispatch_process+0xf8>
                        return(0);
 800a218:	2300      	movs	r3, #0
 800a21a:	e02c      	b.n	800a276 <_nx_ip_dispatch_process+0x152>
                if (packet_ptr -> nx_packet_ip_version == NX_IP_VERSION_V4)
 800a21c:	68bb      	ldr	r3, [r7, #8]
 800a21e:	f893 302c 	ldrb.w	r3, [r3, #44]	; 0x2c
 800a222:	2b04      	cmp	r3, #4
 800a224:	d105      	bne.n	800a232 <_nx_ip_dispatch_process+0x10e>
                    NX_ICMPV4_SEND_DEST_UNREACHABLE(ip_ptr, packet_ptr, NX_ICMP_PROTOCOL_UNREACH_CODE);
 800a226:	2300      	movs	r3, #0
 800a228:	4a15      	ldr	r2, [pc, #84]	; (800a280 <_nx_ip_dispatch_process+0x15c>)
 800a22a:	68b9      	ldr	r1, [r7, #8]
 800a22c:	68f8      	ldr	r0, [r7, #12]
 800a22e:	f7ff fb43 	bl	80098b8 <_nx_icmpv4_send_error_message>
                ip_ptr -> nx_ip_unknown_protocols_received++;
 800a232:	68fb      	ldr	r3, [r7, #12]
 800a234:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 800a236:	1c5a      	adds	r2, r3, #1
 800a238:	68fb      	ldr	r3, [r7, #12]
 800a23a:	641a      	str	r2, [r3, #64]	; 0x40
                drop_packet = 1;
 800a23c:	2301      	movs	r3, #1
 800a23e:	617b      	str	r3, [r7, #20]
            break;
 800a240:	e7ff      	b.n	800a242 <_nx_ip_dispatch_process+0x11e>
 800a242:	bf00      	nop
        }


        /* If the previous header is processed without errors, move on to the next optional
           header. */
        if (!drop_packet)
 800a244:	697b      	ldr	r3, [r7, #20]
 800a246:	2b00      	cmp	r3, #0
 800a248:	d010      	beq.n	800a26c <_nx_ip_dispatch_process+0x148>
        else
        {
#ifndef NX_DISABLE_IP_INFO

            /* Decrement the number of packets delivered.  */
            ip_ptr -> nx_ip_total_packets_delivered--;
 800a24a:	68fb      	ldr	r3, [r7, #12]
 800a24c:	6a1b      	ldr	r3, [r3, #32]
 800a24e:	1e5a      	subs	r2, r3, #1
 800a250:	68fb      	ldr	r3, [r7, #12]
 800a252:	621a      	str	r2, [r3, #32]

            /* Decrement the IP packet bytes received (not including the header).  */
            ip_ptr -> nx_ip_total_bytes_received -=  packet_ptr -> nx_packet_length;
 800a254:	68fb      	ldr	r3, [r7, #12]
 800a256:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 800a258:	68bb      	ldr	r3, [r7, #8]
 800a25a:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800a25c:	1ad2      	subs	r2, r2, r3
 800a25e:	68fb      	ldr	r3, [r7, #12]
 800a260:	625a      	str	r2, [r3, #36]	; 0x24

            /* Increment the IP receive packets dropped count.  */
            ip_ptr -> nx_ip_receive_packets_dropped++;
 800a262:	68fb      	ldr	r3, [r7, #12]
 800a264:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 800a266:	1c5a      	adds	r2, r3, #1
 800a268:	68fb      	ldr	r3, [r7, #12]
 800a26a:	64da      	str	r2, [r3, #76]	; 0x4c
    while (!drop_packet)
 800a26c:	697b      	ldr	r3, [r7, #20]
 800a26e:	2b00      	cmp	r3, #0
 800a270:	f43f af61 	beq.w	800a136 <_nx_ip_dispatch_process+0x12>
#endif /* NX_DISABLE_IP_INFO */
        }
    }

    return(drop_packet);
 800a274:	697b      	ldr	r3, [r7, #20]
}
 800a276:	4618      	mov	r0, r3
 800a278:	3718      	adds	r7, #24
 800a27a:	46bd      	mov	sp, r7
 800a27c:	bd80      	pop	{r7, pc}
 800a27e:	bf00      	nop
 800a280:	03020000 	.word	0x03020000

0800a284 <_nx_ip_driver_packet_send>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
VOID  _nx_ip_driver_packet_send(NX_IP *ip_ptr, NX_PACKET *packet_ptr, ULONG destination_ip, ULONG fragment, ULONG next_hop_address)
{
 800a284:	b580      	push	{r7, lr}
 800a286:	b09e      	sub	sp, #120	; 0x78
 800a288:	af00      	add	r7, sp, #0
 800a28a:	60f8      	str	r0, [r7, #12]
 800a28c:	60b9      	str	r1, [r7, #8]
 800a28e:	607a      	str	r2, [r7, #4]
 800a290:	603b      	str	r3, [r7, #0]
TX_INTERRUPT_SAVE_AREA
NX_IP_DRIVER driver_request;
UINT         index;
ULONG        network_mask;
ULONG        network;
UCHAR        loopback = NX_FALSE;
 800a292:	2300      	movs	r3, #0
 800a294:	f887 3073 	strb.w	r3, [r7, #115]	; 0x73

    /* Add debug information. */
    NX_PACKET_DEBUG(__FILE__, __LINE__, packet_ptr);

    /* Initialize the driver request. */
    driver_request.nx_ip_driver_ptr =                   ip_ptr;
 800a298:	68fb      	ldr	r3, [r7, #12]
 800a29a:	633b      	str	r3, [r7, #48]	; 0x30
    driver_request.nx_ip_driver_packet =                packet_ptr;
 800a29c:	68bb      	ldr	r3, [r7, #8]
 800a29e:	62bb      	str	r3, [r7, #40]	; 0x28
    driver_request.nx_ip_driver_interface =             packet_ptr -> nx_packet_address.nx_packet_interface_ptr;
 800a2a0:	68bb      	ldr	r3, [r7, #8]
 800a2a2:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800a2a4:	637b      	str	r3, [r7, #52]	; 0x34
    driver_request.nx_ip_driver_command =               NX_LINK_PACKET_SEND;
 800a2a6:	2300      	movs	r3, #0
 800a2a8:	61bb      	str	r3, [r7, #24]

    /* Determine if physical mapping is needed by the link driver.  */
    if (packet_ptr -> nx_packet_address.nx_packet_interface_ptr -> nx_interface_address_mapping_needed)
 800a2aa:	68bb      	ldr	r3, [r7, #8]
 800a2ac:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800a2ae:	795b      	ldrb	r3, [r3, #5]
 800a2b0:	2b00      	cmp	r3, #0
 800a2b2:	f000 8174 	beq.w	800a59e <_nx_ip_driver_packet_send+0x31a>
    {

        /* Get the network and network mask.*/
        network_mask = packet_ptr -> nx_packet_address.nx_packet_interface_ptr -> nx_interface_ip_network_mask;
 800a2b6:	68bb      	ldr	r3, [r7, #8]
 800a2b8:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800a2ba:	699b      	ldr	r3, [r3, #24]
 800a2bc:	65fb      	str	r3, [r7, #92]	; 0x5c
        network = packet_ptr -> nx_packet_address.nx_packet_interface_ptr -> nx_interface_ip_network;
 800a2be:	68bb      	ldr	r3, [r7, #8]
 800a2c0:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800a2c2:	69db      	ldr	r3, [r3, #28]
 800a2c4:	65bb      	str	r3, [r7, #88]	; 0x58

        /* Determine if an IP limited or directed broadcast is requested.  */
        if ((destination_ip == NX_IP_LIMITED_BROADCAST) ||
 800a2c6:	687b      	ldr	r3, [r7, #4]
 800a2c8:	f1b3 3fff 	cmp.w	r3, #4294967295
 800a2cc:	d00d      	beq.n	800a2ea <_nx_ip_driver_packet_send+0x66>
            (((destination_ip & network_mask) == network) &&
 800a2ce:	687a      	ldr	r2, [r7, #4]
 800a2d0:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 800a2d2:	4013      	ands	r3, r2
        if ((destination_ip == NX_IP_LIMITED_BROADCAST) ||
 800a2d4:	6dba      	ldr	r2, [r7, #88]	; 0x58
 800a2d6:	429a      	cmp	r2, r3
 800a2d8:	d110      	bne.n	800a2fc <_nx_ip_driver_packet_send+0x78>
             ((destination_ip & ~network_mask) == ~network_mask)))
 800a2da:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 800a2dc:	43da      	mvns	r2, r3
 800a2de:	687b      	ldr	r3, [r7, #4]
 800a2e0:	401a      	ands	r2, r3
 800a2e2:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 800a2e4:	43db      	mvns	r3, r3
            (((destination_ip & network_mask) == network) &&
 800a2e6:	429a      	cmp	r2, r3
 800a2e8:	d108      	bne.n	800a2fc <_nx_ip_driver_packet_send+0x78>
        {

            /* Build the driver request.  */
            driver_request.nx_ip_driver_command =               NX_LINK_PACKET_BROADCAST;
 800a2ea:	2304      	movs	r3, #4
 800a2ec:	61bb      	str	r3, [r7, #24]
            driver_request.nx_ip_driver_physical_address_msw =  0xFFFFUL;
 800a2ee:	f64f 73ff 	movw	r3, #65535	; 0xffff
 800a2f2:	623b      	str	r3, [r7, #32]
            driver_request.nx_ip_driver_physical_address_lsw =  0xFFFFFFFFUL;
 800a2f4:	f04f 33ff 	mov.w	r3, #4294967295
 800a2f8:	627b      	str	r3, [r7, #36]	; 0x24
 800a2fa:	e162      	b.n	800a5c2 <_nx_ip_driver_packet_send+0x33e>
        }
        /* Determine if we have a loopback address.  */
        else if (destination_ip == packet_ptr -> nx_packet_address.nx_packet_interface_ptr -> nx_interface_ip_address)
 800a2fc:	68bb      	ldr	r3, [r7, #8]
 800a2fe:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800a300:	695b      	ldr	r3, [r3, #20]
 800a302:	687a      	ldr	r2, [r7, #4]
 800a304:	429a      	cmp	r2, r3
 800a306:	d105      	bne.n	800a314 <_nx_ip_driver_packet_send+0x90>
        {
            loopback = NX_TRUE;
 800a308:	2301      	movs	r3, #1
 800a30a:	f887 3073 	strb.w	r3, [r7, #115]	; 0x73
            driver_request.nx_ip_driver_interface = NX_NULL;
 800a30e:	2300      	movs	r3, #0
 800a310:	637b      	str	r3, [r7, #52]	; 0x34
 800a312:	e156      	b.n	800a5c2 <_nx_ip_driver_packet_send+0x33e>
        }
        /* Determine if we have a class D multicast address.  */
        else if ((destination_ip & NX_IP_CLASS_D_MASK) == NX_IP_CLASS_D_TYPE)
 800a314:	687b      	ldr	r3, [r7, #4]
 800a316:	f003 4370 	and.w	r3, r3, #4026531840	; 0xf0000000
 800a31a:	f1b3 4f60 	cmp.w	r3, #3758096384	; 0xe0000000
 800a31e:	d133      	bne.n	800a388 <_nx_ip_driver_packet_send+0x104>

            /* Yes, we have a class D multicast address.  Derive the physical mapping from
               the class D address.  */

            /* Determine if the group address has been joined in this IP instance.  */
            index =  0;
 800a320:	2300      	movs	r3, #0
 800a322:	677b      	str	r3, [r7, #116]	; 0x74
            while (index < NX_MAX_MULTICAST_GROUPS)
 800a324:	e00f      	b.n	800a346 <_nx_ip_driver_packet_send+0xc2>
            {

                /* Determine if the destination address matches the requested address.  */
                if (ip_ptr -> nx_ipv4_multicast_entry[index].nx_ipv4_multicast_join_list == destination_ip)
 800a326:	68f9      	ldr	r1, [r7, #12]
 800a328:	6f7a      	ldr	r2, [r7, #116]	; 0x74
 800a32a:	4613      	mov	r3, r2
 800a32c:	009b      	lsls	r3, r3, #2
 800a32e:	4413      	add	r3, r2
 800a330:	009b      	lsls	r3, r3, #2
 800a332:	440b      	add	r3, r1
 800a334:	f503 7331 	add.w	r3, r3, #708	; 0x2c4
 800a338:	681b      	ldr	r3, [r3, #0]
 800a33a:	687a      	ldr	r2, [r7, #4]
 800a33c:	429a      	cmp	r2, r3
 800a33e:	d006      	beq.n	800a34e <_nx_ip_driver_packet_send+0xca>
                    /* Yes, break the loop!  */
                    break;
                }

                /* Increment the join list index.  */
                index++;
 800a340:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 800a342:	3301      	adds	r3, #1
 800a344:	677b      	str	r3, [r7, #116]	; 0x74
            while (index < NX_MAX_MULTICAST_GROUPS)
 800a346:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 800a348:	2b06      	cmp	r3, #6
 800a34a:	d9ec      	bls.n	800a326 <_nx_ip_driver_packet_send+0xa2>
 800a34c:	e000      	b.n	800a350 <_nx_ip_driver_packet_send+0xcc>
                    break;
 800a34e:	bf00      	nop
            }

            /* Determine if the group was joined by this IP instance.  */
            if (index < NX_MAX_MULTICAST_GROUPS)
 800a350:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 800a352:	2b06      	cmp	r3, #6
 800a354:	d80e      	bhi.n	800a374 <_nx_ip_driver_packet_send+0xf0>
            {

                /* Determine if the group has loopback enabled.  */
                if (ip_ptr -> nx_ipv4_multicast_entry[index].nx_ipv4_multicast_loopback_enable)
 800a356:	68f9      	ldr	r1, [r7, #12]
 800a358:	6f7a      	ldr	r2, [r7, #116]	; 0x74
 800a35a:	4613      	mov	r3, r2
 800a35c:	009b      	lsls	r3, r3, #2
 800a35e:	4413      	add	r3, r2
 800a360:	009b      	lsls	r3, r3, #2
 800a362:	440b      	add	r3, r1
 800a364:	f503 7335 	add.w	r3, r3, #724	; 0x2d4
 800a368:	681b      	ldr	r3, [r3, #0]
 800a36a:	2b00      	cmp	r3, #0
 800a36c:	d002      	beq.n	800a374 <_nx_ip_driver_packet_send+0xf0>
                {
                    loopback = NX_TRUE;
 800a36e:	2301      	movs	r3, #1
 800a370:	f887 3073 	strb.w	r3, [r7, #115]	; 0x73
                }
            }

            /* Build the driver request. Derive the physical mapping from
               the class D address.  */
            driver_request.nx_ip_driver_physical_address_msw =  NX_IP_MULTICAST_UPPER;
 800a374:	f44f 7380 	mov.w	r3, #256	; 0x100
 800a378:	623b      	str	r3, [r7, #32]
            driver_request.nx_ip_driver_physical_address_lsw =  NX_IP_MULTICAST_LOWER | (destination_ip & NX_IP_MULTICAST_MASK);
 800a37a:	687b      	ldr	r3, [r7, #4]
 800a37c:	f3c3 0316 	ubfx	r3, r3, #0, #23
 800a380:	f043 43bc 	orr.w	r3, r3, #1577058304	; 0x5e000000
 800a384:	627b      	str	r3, [r7, #36]	; 0x24
 800a386:	e11c      	b.n	800a5c2 <_nx_ip_driver_packet_send+0x33e>

            NX_PARAMETER_NOT_USED(fragment);
            /* Look into the ARP Routing Table to derive the physical address.  */

            /* If we get here, the packet destination is a unicast address.  */
            destination_ip = next_hop_address;
 800a388:	f8d7 3080 	ldr.w	r3, [r7, #128]	; 0x80
 800a38c:	607b      	str	r3, [r7, #4]

            /* Calculate the hash index for the destination IP address.  */
            index =  (UINT)((destination_ip + (destination_ip >> 8)) & NX_ARP_TABLE_MASK);
 800a38e:	687b      	ldr	r3, [r7, #4]
 800a390:	0a1a      	lsrs	r2, r3, #8
 800a392:	687b      	ldr	r3, [r7, #4]
 800a394:	4413      	add	r3, r2
 800a396:	f003 031f 	and.w	r3, r3, #31
 800a39a:	677b      	str	r3, [r7, #116]	; 0x74

            /* Determine if there is an entry for this IP address.  */
            arp_ptr =  ip_ptr -> nx_ip_arp_table[index];
 800a39c:	68fb      	ldr	r3, [r7, #12]
 800a39e:	6f7a      	ldr	r2, [r7, #116]	; 0x74
 800a3a0:	f502 72ca 	add.w	r2, r2, #404	; 0x194
 800a3a4:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 800a3a8:	66fb      	str	r3, [r7, #108]	; 0x6c

            /* Loop to look for an ARP match.  */
            while (arp_ptr)
 800a3aa:	e013      	b.n	800a3d4 <_nx_ip_driver_packet_send+0x150>
            {

                /* Determine if this arp entry matches the destination IP address.  */
                if (arp_ptr -> nx_arp_ip_address == destination_ip)
 800a3ac:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 800a3ae:	6a1b      	ldr	r3, [r3, #32]
 800a3b0:	687a      	ldr	r2, [r7, #4]
 800a3b2:	429a      	cmp	r2, r3
 800a3b4:	d012      	beq.n	800a3dc <_nx_ip_driver_packet_send+0x158>
                    /* Yes, we found a match.  Get out of the loop!  */
                    break;
                }

                /* Move to the next active ARP entry.  */
                arp_ptr =  arp_ptr -> nx_arp_active_next;
 800a3b6:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 800a3b8:	695b      	ldr	r3, [r3, #20]
 800a3ba:	66fb      	str	r3, [r7, #108]	; 0x6c

                /* Determine if we are at the end of the ARP list.  */
                if (arp_ptr == ip_ptr -> nx_ip_arp_table[index])
 800a3bc:	68fb      	ldr	r3, [r7, #12]
 800a3be:	6f7a      	ldr	r2, [r7, #116]	; 0x74
 800a3c0:	f502 72ca 	add.w	r2, r2, #404	; 0x194
 800a3c4:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 800a3c8:	6efa      	ldr	r2, [r7, #108]	; 0x6c
 800a3ca:	429a      	cmp	r2, r3
 800a3cc:	d102      	bne.n	800a3d4 <_nx_ip_driver_packet_send+0x150>
                {
                    /* Clear the ARP pointer.  */
                    arp_ptr =  NX_NULL;
 800a3ce:	2300      	movs	r3, #0
 800a3d0:	66fb      	str	r3, [r7, #108]	; 0x6c
                    break;
 800a3d2:	e004      	b.n	800a3de <_nx_ip_driver_packet_send+0x15a>
            while (arp_ptr)
 800a3d4:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 800a3d6:	2b00      	cmp	r3, #0
 800a3d8:	d1e8      	bne.n	800a3ac <_nx_ip_driver_packet_send+0x128>
 800a3da:	e000      	b.n	800a3de <_nx_ip_driver_packet_send+0x15a>
                    break;
 800a3dc:	bf00      	nop
                }
            }

            /* Determine if we actually found a matching and effective ARP entry.  */
            if ((arp_ptr) && (arp_ptr -> nx_arp_physical_address_msw | arp_ptr -> nx_arp_physical_address_lsw))
 800a3de:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 800a3e0:	2b00      	cmp	r3, #0
 800a3e2:	d022      	beq.n	800a42a <_nx_ip_driver_packet_send+0x1a6>
 800a3e4:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 800a3e6:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 800a3e8:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 800a3ea:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 800a3ec:	4313      	orrs	r3, r2
 800a3ee:	2b00      	cmp	r3, #0
 800a3f0:	d01b      	beq.n	800a42a <_nx_ip_driver_packet_send+0x1a6>
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 800a3f2:	f3ef 8310 	mrs	r3, PRIMASK
 800a3f6:	64fb      	str	r3, [r7, #76]	; 0x4c
    return(posture);
 800a3f8:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
    int_posture = __get_interrupt_posture();
 800a3fa:	64bb      	str	r3, [r7, #72]	; 0x48
    __asm__ volatile ("CPSID i" : : : "memory");
 800a3fc:	b672      	cpsid	i
    return(int_posture);
 800a3fe:	6cbb      	ldr	r3, [r7, #72]	; 0x48
            {

                /* Disable interrupts temporarily.  */
                TX_DISABLE
 800a400:	657b      	str	r3, [r7, #84]	; 0x54

                /* Yes, we have a physical mapping.  Copy the physical address into the driver
                   request structure.  */
                driver_request.nx_ip_driver_physical_address_msw =  arp_ptr -> nx_arp_physical_address_msw;
 800a402:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 800a404:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800a406:	623b      	str	r3, [r7, #32]
                driver_request.nx_ip_driver_physical_address_lsw =  arp_ptr -> nx_arp_physical_address_lsw;
 800a408:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 800a40a:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 800a40c:	627b      	str	r3, [r7, #36]	; 0x24

                /* Move this ARP entry to the head of the list.  */
                ip_ptr -> nx_ip_arp_table[index] =  arp_ptr;
 800a40e:	68fb      	ldr	r3, [r7, #12]
 800a410:	6f7a      	ldr	r2, [r7, #116]	; 0x74
 800a412:	f502 72ca 	add.w	r2, r2, #404	; 0x194
 800a416:	6ef9      	ldr	r1, [r7, #108]	; 0x6c
 800a418:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
 800a41c:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 800a41e:	653b      	str	r3, [r7, #80]	; 0x50
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 800a420:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 800a422:	f383 8810 	msr	PRIMASK, r3
}
 800a426:	bf00      	nop

                /* Restore interrupts.  */
                TX_RESTORE
 800a428:	e0cb      	b.n	800a5c2 <_nx_ip_driver_packet_send+0x33e>
            }
            else
            {

                /* Determine if fragmentation is needed before queue the packet on the ARP waiting queue.  */
                if (packet_ptr -> nx_packet_length > packet_ptr -> nx_packet_address.nx_packet_interface_ptr -> nx_interface_ip_mtu_size)
 800a42a:	68bb      	ldr	r3, [r7, #8]
 800a42c:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 800a42e:	68bb      	ldr	r3, [r7, #8]
 800a430:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800a432:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800a434:	429a      	cmp	r2, r3
 800a436:	d910      	bls.n	800a45a <_nx_ip_driver_packet_send+0x1d6>
                {

#ifndef NX_DISABLE_FRAGMENTATION
                    /* Check the DF bit flag.  */
                    if ((ip_ptr -> nx_ip_fragment_processing == NX_NULL) || (fragment != NX_FRAGMENT_OKAY))
 800a438:	68fb      	ldr	r3, [r7, #12]
 800a43a:	f8d3 329c 	ldr.w	r3, [r3, #668]	; 0x29c
 800a43e:	2b00      	cmp	r3, #0
 800a440:	d002      	beq.n	800a448 <_nx_ip_driver_packet_send+0x1c4>
 800a442:	683b      	ldr	r3, [r7, #0]
 800a444:	2b00      	cmp	r3, #0
 800a446:	d008      	beq.n	800a45a <_nx_ip_driver_packet_send+0x1d6>
                    {

#ifndef NX_DISABLE_IP_INFO

                        /* Increment the IP send packets dropped count.  */
                        ip_ptr -> nx_ip_send_packets_dropped++;
 800a448:	68fb      	ldr	r3, [r7, #12]
 800a44a:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 800a44c:	1c5a      	adds	r2, r3, #1
 800a44e:	68fb      	ldr	r3, [r7, #12]
 800a450:	655a      	str	r2, [r3, #84]	; 0x54
#endif
                        /* Just release the packet.  */
                        _nx_packet_transmit_release(packet_ptr);
 800a452:	68b8      	ldr	r0, [r7, #8]
 800a454:	f002 f88e 	bl	800c574 <_nx_packet_transmit_release>

                        /* Return... nothing more can be done!  */
                        return;
 800a458:	e12a      	b.n	800a6b0 <_nx_ip_driver_packet_send+0x42c>
                    }
                }

                /* Determine if we actually found a matching ARP entry.  */
                if (arp_ptr)
 800a45a:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 800a45c:	2b00      	cmp	r3, #0
 800a45e:	d052      	beq.n	800a506 <_nx_ip_driver_packet_send+0x282>
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 800a460:	f3ef 8310 	mrs	r3, PRIMASK
 800a464:	647b      	str	r3, [r7, #68]	; 0x44
    return(posture);
 800a466:	6c7b      	ldr	r3, [r7, #68]	; 0x44
    int_posture = __get_interrupt_posture();
 800a468:	643b      	str	r3, [r7, #64]	; 0x40
    __asm__ volatile ("CPSID i" : : : "memory");
 800a46a:	b672      	cpsid	i
    return(int_posture);
 800a46c:	6c3b      	ldr	r3, [r7, #64]	; 0x40
                {

                    /* Yes, we have an existing ARP mapping entry.  */

                    /* Disable interrupts temporarily.  */
                    TX_DISABLE
 800a46e:	657b      	str	r3, [r7, #84]	; 0x54

                    /* Ensure the current packet's queue next pointer to NULL.  */
                    packet_ptr -> nx_packet_queue_next =  NX_NULL;
 800a470:	68bb      	ldr	r3, [r7, #8]
 800a472:	2200      	movs	r2, #0
 800a474:	61da      	str	r2, [r3, #28]

                    /* Determine if the queue is empty.  */
                    if (arp_ptr -> nx_arp_packets_waiting == NX_NULL)
 800a476:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 800a478:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800a47a:	2b00      	cmp	r3, #0
 800a47c:	d109      	bne.n	800a492 <_nx_ip_driver_packet_send+0x20e>
                    {

                        /* Yes, we have an empty ARP packet queue.  Simply place the
                           packet at the head of the list.  */
                        arp_ptr -> nx_arp_packets_waiting =  packet_ptr;
 800a47e:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 800a480:	68ba      	ldr	r2, [r7, #8]
 800a482:	631a      	str	r2, [r3, #48]	; 0x30
 800a484:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 800a486:	63fb      	str	r3, [r7, #60]	; 0x3c
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 800a488:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800a48a:	f383 8810 	msr	PRIMASK, r3
}
 800a48e:	bf00      	nop
                    /* Call ARP send to send an ARP request.  */
                    (ip_ptr -> nx_ip_arp_packet_send)(ip_ptr, destination_ip, packet_ptr -> nx_packet_address.nx_packet_interface_ptr);
                }

                /* Just return!  */
                return;
 800a490:	e10d      	b.n	800a6ae <_nx_ip_driver_packet_send+0x42a>
                        last_packet =  arp_ptr -> nx_arp_packets_waiting;
 800a492:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 800a494:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800a496:	66bb      	str	r3, [r7, #104]	; 0x68
                        queued_count = 1;
 800a498:	2301      	movs	r3, #1
 800a49a:	663b      	str	r3, [r7, #96]	; 0x60
                        while (last_packet -> nx_packet_queue_next)
 800a49c:	e005      	b.n	800a4aa <_nx_ip_driver_packet_send+0x226>
                            queued_count++;
 800a49e:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 800a4a0:	3301      	adds	r3, #1
 800a4a2:	663b      	str	r3, [r7, #96]	; 0x60
                            last_packet =  last_packet -> nx_packet_queue_next;
 800a4a4:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 800a4a6:	69db      	ldr	r3, [r3, #28]
 800a4a8:	66bb      	str	r3, [r7, #104]	; 0x68
                        while (last_packet -> nx_packet_queue_next)
 800a4aa:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 800a4ac:	69db      	ldr	r3, [r3, #28]
 800a4ae:	2b00      	cmp	r3, #0
 800a4b0:	d1f5      	bne.n	800a49e <_nx_ip_driver_packet_send+0x21a>
                        last_packet -> nx_packet_queue_next =  packet_ptr;
 800a4b2:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 800a4b4:	68ba      	ldr	r2, [r7, #8]
 800a4b6:	61da      	str	r2, [r3, #28]
                        remove_packet =  NX_NULL;
 800a4b8:	2300      	movs	r3, #0
 800a4ba:	667b      	str	r3, [r7, #100]	; 0x64
                        if (queued_count >= NX_ARP_MAX_QUEUE_DEPTH)
 800a4bc:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 800a4be:	2b03      	cmp	r3, #3
 800a4c0:	d913      	bls.n	800a4ea <_nx_ip_driver_packet_send+0x266>
                            remove_packet =  arp_ptr -> nx_arp_packets_waiting;
 800a4c2:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 800a4c4:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800a4c6:	667b      	str	r3, [r7, #100]	; 0x64
                            arp_ptr -> nx_arp_packets_waiting =  remove_packet -> nx_packet_queue_next;
 800a4c8:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 800a4ca:	69da      	ldr	r2, [r3, #28]
 800a4cc:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 800a4ce:	631a      	str	r2, [r3, #48]	; 0x30
                            remove_packet -> nx_packet_queue_next =  NX_NULL;
 800a4d0:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 800a4d2:	2200      	movs	r2, #0
 800a4d4:	61da      	str	r2, [r3, #28]
                            ip_ptr -> nx_ip_transmit_resource_errors++;
 800a4d6:	68fb      	ldr	r3, [r7, #12]
 800a4d8:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 800a4da:	1c5a      	adds	r2, r3, #1
 800a4dc:	68fb      	ldr	r3, [r7, #12]
 800a4de:	645a      	str	r2, [r3, #68]	; 0x44
                            ip_ptr -> nx_ip_send_packets_dropped++;
 800a4e0:	68fb      	ldr	r3, [r7, #12]
 800a4e2:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 800a4e4:	1c5a      	adds	r2, r3, #1
 800a4e6:	68fb      	ldr	r3, [r7, #12]
 800a4e8:	655a      	str	r2, [r3, #84]	; 0x54
 800a4ea:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 800a4ec:	63bb      	str	r3, [r7, #56]	; 0x38
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 800a4ee:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800a4f0:	f383 8810 	msr	PRIMASK, r3
}
 800a4f4:	bf00      	nop
                        if (remove_packet)
 800a4f6:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 800a4f8:	2b00      	cmp	r3, #0
 800a4fa:	f000 80d8 	beq.w	800a6ae <_nx_ip_driver_packet_send+0x42a>
                            _nx_packet_transmit_release(remove_packet);
 800a4fe:	6e78      	ldr	r0, [r7, #100]	; 0x64
 800a500:	f002 f838 	bl	800c574 <_nx_packet_transmit_release>
                return;
 800a504:	e0d3      	b.n	800a6ae <_nx_ip_driver_packet_send+0x42a>
                    if ((!ip_ptr -> nx_ip_arp_allocate) ||
 800a506:	68fb      	ldr	r3, [r7, #12]
 800a508:	f8d3 36e4 	ldr.w	r3, [r3, #1764]	; 0x6e4
 800a50c:	2b00      	cmp	r3, #0
 800a50e:	d00e      	beq.n	800a52e <_nx_ip_driver_packet_send+0x2aa>
                        ((ip_ptr -> nx_ip_arp_allocate)(ip_ptr, &(ip_ptr -> nx_ip_arp_table[index]), NX_FALSE)))
 800a510:	68fb      	ldr	r3, [r7, #12]
 800a512:	f8d3 36e4 	ldr.w	r3, [r3, #1764]	; 0x6e4
 800a516:	6f7a      	ldr	r2, [r7, #116]	; 0x74
 800a518:	f502 72ca 	add.w	r2, r2, #404	; 0x194
 800a51c:	0092      	lsls	r2, r2, #2
 800a51e:	68f9      	ldr	r1, [r7, #12]
 800a520:	4411      	add	r1, r2
 800a522:	2200      	movs	r2, #0
 800a524:	68f8      	ldr	r0, [r7, #12]
 800a526:	4798      	blx	r3
 800a528:	4603      	mov	r3, r0
                    if ((!ip_ptr -> nx_ip_arp_allocate) ||
 800a52a:	2b00      	cmp	r3, #0
 800a52c:	d00d      	beq.n	800a54a <_nx_ip_driver_packet_send+0x2c6>
                        ip_ptr -> nx_ip_transmit_resource_errors++;
 800a52e:	68fb      	ldr	r3, [r7, #12]
 800a530:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 800a532:	1c5a      	adds	r2, r3, #1
 800a534:	68fb      	ldr	r3, [r7, #12]
 800a536:	645a      	str	r2, [r3, #68]	; 0x44
                        ip_ptr -> nx_ip_send_packets_dropped++;
 800a538:	68fb      	ldr	r3, [r7, #12]
 800a53a:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 800a53c:	1c5a      	adds	r2, r3, #1
 800a53e:	68fb      	ldr	r3, [r7, #12]
 800a540:	655a      	str	r2, [r3, #84]	; 0x54
                        _nx_packet_transmit_release(packet_ptr);
 800a542:	68b8      	ldr	r0, [r7, #8]
 800a544:	f002 f816 	bl	800c574 <_nx_packet_transmit_release>
                        return;
 800a548:	e0b2      	b.n	800a6b0 <_nx_ip_driver_packet_send+0x42c>
                    arp_ptr =  (ip_ptr -> nx_ip_arp_table[index]) -> nx_arp_active_previous;
 800a54a:	68fb      	ldr	r3, [r7, #12]
 800a54c:	6f7a      	ldr	r2, [r7, #116]	; 0x74
 800a54e:	f502 72ca 	add.w	r2, r2, #404	; 0x194
 800a552:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 800a556:	699b      	ldr	r3, [r3, #24]
 800a558:	66fb      	str	r3, [r7, #108]	; 0x6c
                    arp_ptr -> nx_arp_ip_address =            destination_ip;
 800a55a:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 800a55c:	687a      	ldr	r2, [r7, #4]
 800a55e:	621a      	str	r2, [r3, #32]
                    arp_ptr -> nx_arp_physical_address_msw =  0;
 800a560:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 800a562:	2200      	movs	r2, #0
 800a564:	625a      	str	r2, [r3, #36]	; 0x24
                    arp_ptr -> nx_arp_physical_address_lsw =  0;
 800a566:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 800a568:	2200      	movs	r2, #0
 800a56a:	629a      	str	r2, [r3, #40]	; 0x28
                    arp_ptr -> nx_arp_entry_next_update =     NX_ARP_UPDATE_RATE;
 800a56c:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 800a56e:	220a      	movs	r2, #10
 800a570:	605a      	str	r2, [r3, #4]
                    arp_ptr -> nx_arp_retries =               0;
 800a572:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 800a574:	2200      	movs	r2, #0
 800a576:	609a      	str	r2, [r3, #8]
                    arp_ptr -> nx_arp_ip_interface =          packet_ptr -> nx_packet_address.nx_packet_interface_ptr;
 800a578:	68bb      	ldr	r3, [r7, #8]
 800a57a:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 800a57c:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 800a57e:	62da      	str	r2, [r3, #44]	; 0x2c
                    packet_ptr -> nx_packet_queue_next =  NX_NULL;
 800a580:	68bb      	ldr	r3, [r7, #8]
 800a582:	2200      	movs	r2, #0
 800a584:	61da      	str	r2, [r3, #28]
                    arp_ptr -> nx_arp_packets_waiting =  packet_ptr;
 800a586:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 800a588:	68ba      	ldr	r2, [r7, #8]
 800a58a:	631a      	str	r2, [r3, #48]	; 0x30
                    (ip_ptr -> nx_ip_arp_packet_send)(ip_ptr, destination_ip, packet_ptr -> nx_packet_address.nx_packet_interface_ptr);
 800a58c:	68fb      	ldr	r3, [r7, #12]
 800a58e:	f8d3 36f0 	ldr.w	r3, [r3, #1776]	; 0x6f0
 800a592:	68ba      	ldr	r2, [r7, #8]
 800a594:	6b12      	ldr	r2, [r2, #48]	; 0x30
 800a596:	6879      	ldr	r1, [r7, #4]
 800a598:	68f8      	ldr	r0, [r7, #12]
 800a59a:	4798      	blx	r3
                return;
 800a59c:	e087      	b.n	800a6ae <_nx_ip_driver_packet_send+0x42a>
    {

        /* This IP instance does not require any IP-to-physical mapping.  */

        /* Determine if we have a loopback address.  */
        if ((((destination_ip >= NX_IP_LOOPBACK_FIRST) &&
 800a59e:	687b      	ldr	r3, [r7, #4]
 800a5a0:	f1b3 4ffe 	cmp.w	r3, #2130706432	; 0x7f000000
 800a5a4:	d302      	bcc.n	800a5ac <_nx_ip_driver_packet_send+0x328>
              (destination_ip <= NX_IP_LOOPBACK_LAST))) ||
 800a5a6:	687b      	ldr	r3, [r7, #4]
        if ((((destination_ip >= NX_IP_LOOPBACK_FIRST) &&
 800a5a8:	2b00      	cmp	r3, #0
 800a5aa:	da05      	bge.n	800a5b8 <_nx_ip_driver_packet_send+0x334>
            (destination_ip == packet_ptr -> nx_packet_address.nx_packet_interface_ptr -> nx_interface_ip_address))
 800a5ac:	68bb      	ldr	r3, [r7, #8]
 800a5ae:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800a5b0:	695b      	ldr	r3, [r3, #20]
              (destination_ip <= NX_IP_LOOPBACK_LAST))) ||
 800a5b2:	687a      	ldr	r2, [r7, #4]
 800a5b4:	429a      	cmp	r2, r3
 800a5b6:	d104      	bne.n	800a5c2 <_nx_ip_driver_packet_send+0x33e>
        {

            /* Yes, we have an internal loopback address.  */
            loopback = NX_TRUE;
 800a5b8:	2301      	movs	r3, #1
 800a5ba:	f887 3073 	strb.w	r3, [r7, #115]	; 0x73
            driver_request.nx_ip_driver_interface = NX_NULL;
 800a5be:	2300      	movs	r3, #0
 800a5c0:	637b      	str	r3, [r7, #52]	; 0x34
        }
    }

    /* Check whether the packet should be loop back. */
    if (loopback == NX_TRUE)
 800a5c2:	f897 3073 	ldrb.w	r3, [r7, #115]	; 0x73
 800a5c6:	2b01      	cmp	r3, #1
 800a5c8:	d129      	bne.n	800a61e <_nx_ip_driver_packet_send+0x39a>
    {

        /* Copy the packet so it can be enqueued properly by the receive
           processing.  */
        if (_nx_packet_copy(packet_ptr, &packet_copy, ip_ptr -> nx_ip_default_packet_pool, NX_NO_WAIT) == NX_SUCCESS)
 800a5ca:	68fb      	ldr	r3, [r7, #12]
 800a5cc:	f8d3 2138 	ldr.w	r2, [r3, #312]	; 0x138
 800a5d0:	f107 0114 	add.w	r1, r7, #20
 800a5d4:	2300      	movs	r3, #0
 800a5d6:	68b8      	ldr	r0, [r7, #8]
 800a5d8:	f001 fb7a 	bl	800bcd0 <_nx_packet_copy>
 800a5dc:	4603      	mov	r3, r0
 800a5de:	2b00      	cmp	r3, #0
 800a5e0:	d113      	bne.n	800a60a <_nx_ip_driver_packet_send+0x386>
#endif /* NX_ENABLE_INTERFACE_CAPABILITY */

#ifndef NX_DISABLE_IP_INFO

            /* Increment the IP packet sent count.  */
            ip_ptr -> nx_ip_total_packets_sent++;
 800a5e2:	68fb      	ldr	r3, [r7, #12]
 800a5e4:	695b      	ldr	r3, [r3, #20]
 800a5e6:	1c5a      	adds	r2, r3, #1
 800a5e8:	68fb      	ldr	r3, [r7, #12]
 800a5ea:	615a      	str	r2, [r3, #20]

            /* Increment the IP bytes sent count.  */
            ip_ptr -> nx_ip_total_bytes_sent +=  packet_ptr -> nx_packet_length - (ULONG)sizeof(NX_IPV4_HEADER);
 800a5ec:	68fb      	ldr	r3, [r7, #12]
 800a5ee:	699a      	ldr	r2, [r3, #24]
 800a5f0:	68bb      	ldr	r3, [r7, #8]
 800a5f2:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800a5f4:	4413      	add	r3, r2
 800a5f6:	f1a3 0214 	sub.w	r2, r3, #20
 800a5fa:	68fb      	ldr	r3, [r7, #12]
 800a5fc:	619a      	str	r2, [r3, #24]
            /*lint --e{644} suppress variable might not be initialized, since "packet_copy" was initialized as long as return value is NX_SUCCESS. */
            NX_PACKET_DEBUG(__FILE__, __LINE__, packet_copy);

            /* Send the packet to this IP's receive processing like it came in from the
               driver.  */
            _nx_ip_packet_deferred_receive(ip_ptr, packet_copy);
 800a5fe:	697b      	ldr	r3, [r7, #20]
 800a600:	4619      	mov	r1, r3
 800a602:	68f8      	ldr	r0, [r7, #12]
 800a604:	f000 fb10 	bl	800ac28 <_nx_ip_packet_deferred_receive>
 800a608:	e009      	b.n	800a61e <_nx_ip_driver_packet_send+0x39a>
#ifndef NX_DISABLE_IP_INFO
        else
        {

            /* Increment the IP send packets dropped count.  */
            ip_ptr -> nx_ip_send_packets_dropped++;
 800a60a:	68fb      	ldr	r3, [r7, #12]
 800a60c:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 800a60e:	1c5a      	adds	r2, r3, #1
 800a610:	68fb      	ldr	r3, [r7, #12]
 800a612:	655a      	str	r2, [r3, #84]	; 0x54

            /* Increment the IP transmit resource error count.  */
            ip_ptr -> nx_ip_transmit_resource_errors++;
 800a614:	68fb      	ldr	r3, [r7, #12]
 800a616:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 800a618:	1c5a      	adds	r2, r3, #1
 800a61a:	68fb      	ldr	r3, [r7, #12]
 800a61c:	645a      	str	r2, [r3, #68]	; 0x44
        }
#endif
    }

    /* Check whether the packet should be sent through driver. */
    if (driver_request.nx_ip_driver_interface)
 800a61e:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800a620:	2b00      	cmp	r3, #0
 800a622:	d040      	beq.n	800a6a6 <_nx_ip_driver_packet_send+0x422>
    {

        /* Determine if fragmentation is needed.  */
        if (packet_ptr -> nx_packet_length > packet_ptr -> nx_packet_address.nx_packet_interface_ptr -> nx_interface_ip_mtu_size)
 800a624:	68bb      	ldr	r3, [r7, #8]
 800a626:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 800a628:	68bb      	ldr	r3, [r7, #8]
 800a62a:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800a62c:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800a62e:	429a      	cmp	r2, r3
 800a630:	d919      	bls.n	800a666 <_nx_ip_driver_packet_send+0x3e2>
        {

#ifndef NX_DISABLE_FRAGMENTATION
            /* Check the DF bit flag.  */
            if ((ip_ptr -> nx_ip_fragment_processing) && (fragment != NX_DONT_FRAGMENT))
 800a632:	68fb      	ldr	r3, [r7, #12]
 800a634:	f8d3 329c 	ldr.w	r3, [r3, #668]	; 0x29c
 800a638:	2b00      	cmp	r3, #0
 800a63a:	d00b      	beq.n	800a654 <_nx_ip_driver_packet_send+0x3d0>
 800a63c:	683b      	ldr	r3, [r7, #0]
 800a63e:	f5b3 4f80 	cmp.w	r3, #16384	; 0x4000
 800a642:	d007      	beq.n	800a654 <_nx_ip_driver_packet_send+0x3d0>
            {

                /* Fragmentation is needed, call the IP fragment processing routine.  */
                (ip_ptr -> nx_ip_fragment_processing)(&driver_request);
 800a644:	68fb      	ldr	r3, [r7, #12]
 800a646:	f8d3 329c 	ldr.w	r3, [r3, #668]	; 0x29c
 800a64a:	f107 0218 	add.w	r2, r7, #24
 800a64e:	4610      	mov	r0, r2
 800a650:	4798      	blx	r3
                /* Just release the packet.  */
                _nx_packet_transmit_release(packet_ptr);
            }

            /* In either case, this packet send is complete, just return.  */
            return;
 800a652:	e02d      	b.n	800a6b0 <_nx_ip_driver_packet_send+0x42c>
                ip_ptr -> nx_ip_send_packets_dropped++;
 800a654:	68fb      	ldr	r3, [r7, #12]
 800a656:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 800a658:	1c5a      	adds	r2, r3, #1
 800a65a:	68fb      	ldr	r3, [r7, #12]
 800a65c:	655a      	str	r2, [r3, #84]	; 0x54
                _nx_packet_transmit_release(packet_ptr);
 800a65e:	68b8      	ldr	r0, [r7, #8]
 800a660:	f001 ff88 	bl	800c574 <_nx_packet_transmit_release>
            return;
 800a664:	e024      	b.n	800a6b0 <_nx_ip_driver_packet_send+0x42c>
        }

#ifndef NX_DISABLE_IP_INFO

        /* Increment the IP packet sent count.  */
        ip_ptr -> nx_ip_total_packets_sent++;
 800a666:	68fb      	ldr	r3, [r7, #12]
 800a668:	695b      	ldr	r3, [r3, #20]
 800a66a:	1c5a      	adds	r2, r3, #1
 800a66c:	68fb      	ldr	r3, [r7, #12]
 800a66e:	615a      	str	r2, [r3, #20]

        /* Increment the IP bytes sent count.  */
        ip_ptr -> nx_ip_total_bytes_sent +=  packet_ptr -> nx_packet_length - (ULONG)sizeof(NX_IPV4_HEADER);
 800a670:	68fb      	ldr	r3, [r7, #12]
 800a672:	699a      	ldr	r2, [r3, #24]
 800a674:	68bb      	ldr	r3, [r7, #8]
 800a676:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800a678:	4413      	add	r3, r2
 800a67a:	f1a3 0214 	sub.w	r2, r3, #20
 800a67e:	68fb      	ldr	r3, [r7, #12]
 800a680:	619a      	str	r2, [r3, #24]

        /* Add debug information. */
        NX_PACKET_DEBUG(__FILE__, __LINE__, packet_ptr);

        /* Driver entry must not be NULL. */
        NX_ASSERT(packet_ptr -> nx_packet_address.nx_packet_interface_ptr -> nx_interface_link_driver_entry != NX_NULL);
 800a682:	68bb      	ldr	r3, [r7, #8]
 800a684:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800a686:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 800a688:	2b00      	cmp	r3, #0
 800a68a:	d104      	bne.n	800a696 <_nx_ip_driver_packet_send+0x412>
 800a68c:	f04f 30ff 	mov.w	r0, #4294967295
 800a690:	f00a fa90 	bl	8014bb4 <_tx_thread_sleep>
 800a694:	e7fa      	b.n	800a68c <_nx_ip_driver_packet_send+0x408>

        /* Broadcast packet.  */
        (packet_ptr -> nx_packet_address.nx_packet_interface_ptr -> nx_interface_link_driver_entry)(&driver_request);
 800a696:	68bb      	ldr	r3, [r7, #8]
 800a698:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800a69a:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 800a69c:	f107 0218 	add.w	r2, r7, #24
 800a6a0:	4610      	mov	r0, r2
 800a6a2:	4798      	blx	r3
 800a6a4:	e004      	b.n	800a6b0 <_nx_ip_driver_packet_send+0x42c>
    }
    else
    {

        /* Release the transmit packet.  */
        _nx_packet_transmit_release(packet_ptr);
 800a6a6:	68b8      	ldr	r0, [r7, #8]
 800a6a8:	f001 ff64 	bl	800c574 <_nx_packet_transmit_release>
 800a6ac:	e000      	b.n	800a6b0 <_nx_ip_driver_packet_send+0x42c>
                return;
 800a6ae:	bf00      	nop
    }
}
 800a6b0:	3778      	adds	r7, #120	; 0x78
 800a6b2:	46bd      	mov	sp, r7
 800a6b4:	bd80      	pop	{r7, pc}

0800a6b6 <_nx_ip_fast_periodic_timer_entry>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
static VOID  _nx_ip_fast_periodic_timer_entry(ULONG ip_address)
{
 800a6b6:	b580      	push	{r7, lr}
 800a6b8:	b084      	sub	sp, #16
 800a6ba:	af00      	add	r7, sp, #0
 800a6bc:	6078      	str	r0, [r7, #4]

NX_IP *ip_ptr;


    /* Setup IP pointer.  */
    NX_TIMER_EXTENSION_PTR_GET(ip_ptr, NX_IP, ip_address)
 800a6be:	687b      	ldr	r3, [r7, #4]
 800a6c0:	60fb      	str	r3, [r7, #12]

    /* Wakeup this IP's helper thread.  */
    tx_event_flags_set(&(ip_ptr -> nx_ip_events), NX_IP_FAST_EVENT, TX_OR);
 800a6c2:	68fb      	ldr	r3, [r7, #12]
 800a6c4:	f503 7313 	add.w	r3, r3, #588	; 0x24c
 800a6c8:	2200      	movs	r2, #0
 800a6ca:	f44f 7180 	mov.w	r1, #256	; 0x100
 800a6ce:	4618      	mov	r0, r3
 800a6d0:	f007 ff0c 	bl	80124ec <_tx_event_flags_set>
}
 800a6d4:	bf00      	nop
 800a6d6:	3710      	adds	r7, #16
 800a6d8:	46bd      	mov	sp, r7
 800a6da:	bd80      	pop	{r7, pc}

0800a6dc <_nx_ip_fast_periodic_timer_create>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
VOID _nx_ip_fast_periodic_timer_create(NX_IP *ip_ptr)
{
 800a6dc:	b580      	push	{r7, lr}
 800a6de:	b088      	sub	sp, #32
 800a6e0:	af04      	add	r7, sp, #16
 800a6e2:	6078      	str	r0, [r7, #4]

ULONG _nx_ip_fast_timer_rate;

    if (ip_ptr -> nx_ip_fast_periodic_timer_created)
 800a6e4:	687b      	ldr	r3, [r7, #4]
 800a6e6:	f8d3 3620 	ldr.w	r3, [r3, #1568]	; 0x620
 800a6ea:	2b00      	cmp	r3, #0
 800a6ec:	d116      	bne.n	800a71c <_nx_ip_fast_periodic_timer_create+0x40>
    {
        return;
    }

    _nx_ip_fast_timer_rate =  (NX_IP_PERIODIC_RATE + (NX_IP_FAST_TIMER_RATE - 1)) / NX_IP_FAST_TIMER_RATE;
 800a6ee:	230a      	movs	r3, #10
 800a6f0:	60fb      	str	r3, [r7, #12]

    /* Create the fast TCP timer.  */
    /*lint -e{923} suppress cast of pointer to ULONG.  */
    tx_timer_create(&(ip_ptr -> nx_ip_fast_periodic_timer), ip_ptr -> nx_ip_name,
 800a6f2:	687b      	ldr	r3, [r7, #4]
 800a6f4:	f203 6024 	addw	r0, r3, #1572	; 0x624
 800a6f8:	687b      	ldr	r3, [r7, #4]
 800a6fa:	6859      	ldr	r1, [r3, #4]
 800a6fc:	687a      	ldr	r2, [r7, #4]
 800a6fe:	2301      	movs	r3, #1
 800a700:	9302      	str	r3, [sp, #8]
 800a702:	68fb      	ldr	r3, [r7, #12]
 800a704:	9301      	str	r3, [sp, #4]
 800a706:	68fb      	ldr	r3, [r7, #12]
 800a708:	9300      	str	r3, [sp, #0]
 800a70a:	4613      	mov	r3, r2
 800a70c:	4a05      	ldr	r2, [pc, #20]	; (800a724 <_nx_ip_fast_periodic_timer_create+0x48>)
 800a70e:	f00a ff5d 	bl	80155cc <_tx_timer_create>
                    _nx_ip_fast_timer_rate, _nx_ip_fast_timer_rate, TX_AUTO_ACTIVATE);

    NX_TIMER_EXTENSION_PTR_SET(&(ip_ptr -> nx_ip_fast_periodic_timer), ip_ptr)

    /* Set the flag to indicate that the fast timer has been created. */
    ip_ptr -> nx_ip_fast_periodic_timer_created = 1;
 800a712:	687b      	ldr	r3, [r7, #4]
 800a714:	2201      	movs	r2, #1
 800a716:	f8c3 2620 	str.w	r2, [r3, #1568]	; 0x620
 800a71a:	e000      	b.n	800a71e <_nx_ip_fast_periodic_timer_create+0x42>
        return;
 800a71c:	bf00      	nop
}
 800a71e:	3710      	adds	r7, #16
 800a720:	46bd      	mov	sp, r7
 800a722:	bd80      	pop	{r7, pc}
 800a724:	0800a6b7 	.word	0x0800a6b7

0800a728 <_nx_ip_gateway_address_clear>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
UINT  _nx_ip_gateway_address_clear(NX_IP *ip_ptr)
{
 800a728:	b580      	push	{r7, lr}
 800a72a:	b086      	sub	sp, #24
 800a72c:	af00      	add	r7, sp, #0
 800a72e:	6078      	str	r0, [r7, #4]

    /* If trace is enabled, insert this event into the trace buffer.  */
    NX_TRACE_IN_LINE_INSERT(NX_TRACE_IP_GATEWAY_ADDRESS_SET, ip_ptr, 0, 0, 0, NX_TRACE_IP_EVENTS, 0, 0);

    /* Obtain the IP internal mutex so the Gateway IP address can be cleared.  */
    tx_mutex_get(&(ip_ptr -> nx_ip_protection), TX_WAIT_FOREVER);
 800a730:	687b      	ldr	r3, [r7, #4]
 800a732:	f503 739e 	add.w	r3, r3, #316	; 0x13c
 800a736:	f04f 31ff 	mov.w	r1, #4294967295
 800a73a:	4618      	mov	r0, r3
 800a73c:	f008 fb1a 	bl	8012d74 <_tx_mutex_get>
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 800a740:	f3ef 8310 	mrs	r3, PRIMASK
 800a744:	60fb      	str	r3, [r7, #12]
    return(posture);
 800a746:	68fb      	ldr	r3, [r7, #12]
    int_posture = __get_interrupt_posture();
 800a748:	60bb      	str	r3, [r7, #8]
    __asm__ volatile ("CPSID i" : : : "memory");
 800a74a:	b672      	cpsid	i
    return(int_posture);
 800a74c:	68bb      	ldr	r3, [r7, #8]

    /* Disable interrupts.  */
    TX_DISABLE
 800a74e:	617b      	str	r3, [r7, #20]

    /* Clear the Gateway IP address.  */
    ip_ptr -> nx_ip_gateway_address =  0;
 800a750:	687b      	ldr	r3, [r7, #4]
 800a752:	2200      	movs	r2, #0
 800a754:	609a      	str	r2, [r3, #8]

    ip_ptr -> nx_ip_gateway_interface = NX_NULL;
 800a756:	687b      	ldr	r3, [r7, #4]
 800a758:	2200      	movs	r2, #0
 800a75a:	60da      	str	r2, [r3, #12]
 800a75c:	697b      	ldr	r3, [r7, #20]
 800a75e:	613b      	str	r3, [r7, #16]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 800a760:	693b      	ldr	r3, [r7, #16]
 800a762:	f383 8810 	msr	PRIMASK, r3
}
 800a766:	bf00      	nop

    /* Restore interrupts.  */
    TX_RESTORE

    /* Release the protection mutex.  */
    tx_mutex_put(&(ip_ptr -> nx_ip_protection));
 800a768:	687b      	ldr	r3, [r7, #4]
 800a76a:	f503 739e 	add.w	r3, r3, #316	; 0x13c
 800a76e:	4618      	mov	r0, r3
 800a770:	f008 fd78 	bl	8013264 <_tx_mutex_put>

    /* Return completion status.  */
    return(NX_SUCCESS);
 800a774:	2300      	movs	r3, #0
#else /* NX_DISABLE_IPV4  */
    NX_PARAMETER_NOT_USED(ip_ptr);

    return(NX_NOT_SUPPORTED);
#endif /* !NX_DISABLE_IPV4  */
}
 800a776:	4618      	mov	r0, r3
 800a778:	3718      	adds	r7, #24
 800a77a:	46bd      	mov	sp, r7
 800a77c:	bd80      	pop	{r7, pc}

0800a77e <_nx_ip_gateway_address_get>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
UINT  _nx_ip_gateway_address_get(NX_IP *ip_ptr, ULONG *ip_address)
{
 800a77e:	b580      	push	{r7, lr}
 800a780:	b084      	sub	sp, #16
 800a782:	af00      	add	r7, sp, #0
 800a784:	6078      	str	r0, [r7, #4]
 800a786:	6039      	str	r1, [r7, #0]
UINT status;


    /* Initialize the return value to be NX_NOT_FOUND.  If the gateway address
       is set, the return value changes to NX_SUCCESS. */
    status = NX_NOT_FOUND;
 800a788:	234e      	movs	r3, #78	; 0x4e
 800a78a:	60fb      	str	r3, [r7, #12]

    /* Obtain the IP internal mutex to get the Gateway IP address.  */
    tx_mutex_get(&(ip_ptr -> nx_ip_protection), TX_WAIT_FOREVER);
 800a78c:	687b      	ldr	r3, [r7, #4]
 800a78e:	f503 739e 	add.w	r3, r3, #316	; 0x13c
 800a792:	f04f 31ff 	mov.w	r1, #4294967295
 800a796:	4618      	mov	r0, r3
 800a798:	f008 faec 	bl	8012d74 <_tx_mutex_get>

    if (ip_ptr -> nx_ip_gateway_address)
 800a79c:	687b      	ldr	r3, [r7, #4]
 800a79e:	689b      	ldr	r3, [r3, #8]
 800a7a0:	2b00      	cmp	r3, #0
 800a7a2:	d005      	beq.n	800a7b0 <_nx_ip_gateway_address_get+0x32>
    {

        /* Setup the Gateway IP address.  */
        *ip_address = ip_ptr -> nx_ip_gateway_address;
 800a7a4:	687b      	ldr	r3, [r7, #4]
 800a7a6:	689a      	ldr	r2, [r3, #8]
 800a7a8:	683b      	ldr	r3, [r7, #0]
 800a7aa:	601a      	str	r2, [r3, #0]

        status = NX_SUCCESS;
 800a7ac:	2300      	movs	r3, #0
 800a7ae:	60fb      	str	r3, [r7, #12]
    }

    /* Release the protection mutex.  */
    tx_mutex_put(&(ip_ptr -> nx_ip_protection));
 800a7b0:	687b      	ldr	r3, [r7, #4]
 800a7b2:	f503 739e 	add.w	r3, r3, #316	; 0x13c
 800a7b6:	4618      	mov	r0, r3
 800a7b8:	f008 fd54 	bl	8013264 <_tx_mutex_put>

    /* Return completion status.  */
    return(status);
 800a7bc:	68fb      	ldr	r3, [r7, #12]
    NX_PARAMETER_NOT_USED(ip_ptr);
    NX_PARAMETER_NOT_USED(ip_address);

    return(NX_NOT_SUPPORTED);
#endif /* !NX_DISABLE_IPV4  */
}
 800a7be:	4618      	mov	r0, r3
 800a7c0:	3710      	adds	r7, #16
 800a7c2:	46bd      	mov	sp, r7
 800a7c4:	bd80      	pop	{r7, pc}

0800a7c6 <_nx_ip_gateway_address_set>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
UINT  _nx_ip_gateway_address_set(NX_IP *ip_ptr, ULONG ip_address)
{
 800a7c6:	b580      	push	{r7, lr}
 800a7c8:	b088      	sub	sp, #32
 800a7ca:	af00      	add	r7, sp, #0
 800a7cc:	6078      	str	r0, [r7, #4]
 800a7ce:	6039      	str	r1, [r7, #0]

#ifndef NX_DISABLE_IPV4
INT           i;
TX_INTERRUPT_SAVE_AREA

NX_INTERFACE *ip_interface_ptr = NX_NULL;
 800a7d0:	2300      	movs	r3, #0
 800a7d2:	61bb      	str	r3, [r7, #24]

    /* If trace is enabled, insert this event into the trace buffer.  */
    NX_TRACE_IN_LINE_INSERT(NX_TRACE_IP_GATEWAY_ADDRESS_SET, ip_ptr, ip_address, 0, 0, NX_TRACE_IP_EVENTS, 0, 0);

    /* Obtain the IP internal mutex so the Gateway IP address can be setup.  */
    tx_mutex_get(&(ip_ptr -> nx_ip_protection), TX_WAIT_FOREVER);
 800a7d4:	687b      	ldr	r3, [r7, #4]
 800a7d6:	f503 739e 	add.w	r3, r3, #316	; 0x13c
 800a7da:	f04f 31ff 	mov.w	r1, #4294967295
 800a7de:	4618      	mov	r0, r3
 800a7e0:	f008 fac8 	bl	8012d74 <_tx_mutex_get>

    /* Loop through all the interfaces to find the one for the input gateway address. */
    for (i = 0; i < NX_MAX_PHYSICAL_INTERFACES; i++)
 800a7e4:	2300      	movs	r3, #0
 800a7e6:	61fb      	str	r3, [r7, #28]
 800a7e8:	e02d      	b.n	800a846 <_nx_ip_gateway_address_set+0x80>
    {

        /* Must be a valid interface. Match the network subnet of the interface and input address. */
        if ((ip_ptr -> nx_ip_interface[i].nx_interface_valid) &&
 800a7ea:	687a      	ldr	r2, [r7, #4]
 800a7ec:	69fb      	ldr	r3, [r7, #28]
 800a7ee:	214c      	movs	r1, #76	; 0x4c
 800a7f0:	fb01 f303 	mul.w	r3, r1, r3
 800a7f4:	4413      	add	r3, r2
 800a7f6:	f203 7324 	addw	r3, r3, #1828	; 0x724
 800a7fa:	781b      	ldrb	r3, [r3, #0]
 800a7fc:	2b00      	cmp	r3, #0
 800a7fe:	d01f      	beq.n	800a840 <_nx_ip_gateway_address_set+0x7a>
            ((ip_address & (ip_ptr -> nx_ip_interface[i].nx_interface_ip_network_mask)) ==
 800a800:	687a      	ldr	r2, [r7, #4]
 800a802:	69fb      	ldr	r3, [r7, #28]
 800a804:	214c      	movs	r1, #76	; 0x4c
 800a806:	fb01 f303 	mul.w	r3, r1, r3
 800a80a:	4413      	add	r3, r2
 800a80c:	f503 63e7 	add.w	r3, r3, #1848	; 0x738
 800a810:	681a      	ldr	r2, [r3, #0]
 800a812:	683b      	ldr	r3, [r7, #0]
 800a814:	401a      	ands	r2, r3
             ip_ptr -> nx_ip_interface[i].nx_interface_ip_network))
 800a816:	6879      	ldr	r1, [r7, #4]
 800a818:	69fb      	ldr	r3, [r7, #28]
 800a81a:	204c      	movs	r0, #76	; 0x4c
 800a81c:	fb00 f303 	mul.w	r3, r0, r3
 800a820:	440b      	add	r3, r1
 800a822:	f203 733c 	addw	r3, r3, #1852	; 0x73c
 800a826:	681b      	ldr	r3, [r3, #0]
        if ((ip_ptr -> nx_ip_interface[i].nx_interface_valid) &&
 800a828:	429a      	cmp	r2, r3
 800a82a:	d109      	bne.n	800a840 <_nx_ip_gateway_address_set+0x7a>
        {

            /* This is the interface for the gateway.  */
            ip_interface_ptr = &(ip_ptr -> nx_ip_interface[i]);
 800a82c:	69fb      	ldr	r3, [r7, #28]
 800a82e:	224c      	movs	r2, #76	; 0x4c
 800a830:	fb02 f303 	mul.w	r3, r2, r3
 800a834:	f503 63e4 	add.w	r3, r3, #1824	; 0x720
 800a838:	687a      	ldr	r2, [r7, #4]
 800a83a:	4413      	add	r3, r2
 800a83c:	61bb      	str	r3, [r7, #24]

            /* Break out of the search. */
            break;
 800a83e:	e005      	b.n	800a84c <_nx_ip_gateway_address_set+0x86>
    for (i = 0; i < NX_MAX_PHYSICAL_INTERFACES; i++)
 800a840:	69fb      	ldr	r3, [r7, #28]
 800a842:	3301      	adds	r3, #1
 800a844:	61fb      	str	r3, [r7, #28]
 800a846:	69fb      	ldr	r3, [r7, #28]
 800a848:	2b03      	cmp	r3, #3
 800a84a:	ddce      	ble.n	800a7ea <_nx_ip_gateway_address_set+0x24>
        }
    }

    /* Check if we found an interface. */
    if (ip_interface_ptr == NX_NULL)
 800a84c:	69bb      	ldr	r3, [r7, #24]
 800a84e:	2b00      	cmp	r3, #0
 800a850:	d107      	bne.n	800a862 <_nx_ip_gateway_address_set+0x9c>
    {

        /* None found. Unlock the mutex, and return the error status. */
        tx_mutex_put(&(ip_ptr -> nx_ip_protection));
 800a852:	687b      	ldr	r3, [r7, #4]
 800a854:	f503 739e 	add.w	r3, r3, #316	; 0x13c
 800a858:	4618      	mov	r0, r3
 800a85a:	f008 fd03 	bl	8013264 <_tx_mutex_put>

        return(NX_IP_ADDRESS_ERROR);
 800a85e:	2321      	movs	r3, #33	; 0x21
 800a860:	e01a      	b.n	800a898 <_nx_ip_gateway_address_set+0xd2>
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 800a862:	f3ef 8310 	mrs	r3, PRIMASK
 800a866:	60fb      	str	r3, [r7, #12]
    return(posture);
 800a868:	68fb      	ldr	r3, [r7, #12]
    int_posture = __get_interrupt_posture();
 800a86a:	60bb      	str	r3, [r7, #8]
    __asm__ volatile ("CPSID i" : : : "memory");
 800a86c:	b672      	cpsid	i
    return(int_posture);
 800a86e:	68bb      	ldr	r3, [r7, #8]
    }

    /* Disable interrupts.  */
    TX_DISABLE
 800a870:	617b      	str	r3, [r7, #20]

    /* Setup the Gateway IP address.  */
    ip_ptr -> nx_ip_gateway_address =  ip_address;
 800a872:	687b      	ldr	r3, [r7, #4]
 800a874:	683a      	ldr	r2, [r7, #0]
 800a876:	609a      	str	r2, [r3, #8]

    ip_ptr -> nx_ip_gateway_interface = ip_interface_ptr;
 800a878:	687b      	ldr	r3, [r7, #4]
 800a87a:	69ba      	ldr	r2, [r7, #24]
 800a87c:	60da      	str	r2, [r3, #12]
 800a87e:	697b      	ldr	r3, [r7, #20]
 800a880:	613b      	str	r3, [r7, #16]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 800a882:	693b      	ldr	r3, [r7, #16]
 800a884:	f383 8810 	msr	PRIMASK, r3
}
 800a888:	bf00      	nop

    /* Restore interrupts.  */
    TX_RESTORE

    /* Release the protection mutex.  */
    tx_mutex_put(&(ip_ptr -> nx_ip_protection));
 800a88a:	687b      	ldr	r3, [r7, #4]
 800a88c:	f503 739e 	add.w	r3, r3, #316	; 0x13c
 800a890:	4618      	mov	r0, r3
 800a892:	f008 fce7 	bl	8013264 <_tx_mutex_put>

    /* Return completion status.  */
    return(NX_SUCCESS);
 800a896:	2300      	movs	r3, #0
    NX_PARAMETER_NOT_USED(ip_ptr);
    NX_PARAMETER_NOT_USED(ip_address);

    return(NX_NOT_SUPPORTED);
#endif /* !NX_DISABLE_IPV4  */
}
 800a898:	4618      	mov	r0, r3
 800a89a:	3720      	adds	r7, #32
 800a89c:	46bd      	mov	sp, r7
 800a89e:	bd80      	pop	{r7, pc}

0800a8a0 <_nx_ip_header_add>:
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
UINT  _nx_ip_header_add(NX_IP *ip_ptr, NX_PACKET *packet_ptr, ULONG destination_ip,
                        ULONG type_of_service, ULONG time_to_live,  ULONG protocol, ULONG fragment)
{
 800a8a0:	b580      	push	{r7, lr}
 800a8a2:	b08a      	sub	sp, #40	; 0x28
 800a8a4:	af02      	add	r7, sp, #8
 800a8a6:	60f8      	str	r0, [r7, #12]
 800a8a8:	60b9      	str	r1, [r7, #8]
 800a8aa:	607a      	str	r2, [r7, #4]
 800a8ac:	603b      	str	r3, [r7, #0]
ULONG           router_alert = 0;
 800a8ae:	2300      	movs	r3, #0
 800a8b0:	61fb      	str	r3, [r7, #28]
#endif /* defined(NX_DISABLE_IP_TX_CHECKSUM) || defined(NX_ENABLE_INTERFACE_CAPABILITY) || defined(NX_IPSEC_ENABLE) */
ULONG           val;

#ifndef NX_DISABLE_IGMPV2
    /* Check IGMPv2 protocol. */
    if ((protocol == NX_IP_IGMP) && (ip_ptr -> nx_ip_igmp_router_version == NX_IGMP_HOST_VERSION_2))
 800a8b2:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800a8b4:	f5b3 3f00 	cmp.w	r3, #131072	; 0x20000
 800a8b8:	d106      	bne.n	800a8c8 <_nx_ip_header_add+0x28>
 800a8ba:	68fb      	ldr	r3, [r7, #12]
 800a8bc:	f8d3 3120 	ldr.w	r3, [r3, #288]	; 0x120
 800a8c0:	2b02      	cmp	r3, #2
 800a8c2:	d101      	bne.n	800a8c8 <_nx_ip_header_add+0x28>
    {
        router_alert = 4;
 800a8c4:	2304      	movs	r3, #4
 800a8c6:	61fb      	str	r3, [r7, #28]
    }
#endif

    /* Prepend the IP header to the packet.  First, make room for the IP header.  */
    packet_ptr -> nx_packet_prepend_ptr =  (packet_ptr -> nx_packet_prepend_ptr - sizeof(NX_IPV4_HEADER)) - router_alert;
 800a8c8:	68bb      	ldr	r3, [r7, #8]
 800a8ca:	689a      	ldr	r2, [r3, #8]
 800a8cc:	69f9      	ldr	r1, [r7, #28]
 800a8ce:	f06f 0313 	mvn.w	r3, #19
 800a8d2:	1a5b      	subs	r3, r3, r1
 800a8d4:	441a      	add	r2, r3
 800a8d6:	68bb      	ldr	r3, [r7, #8]
 800a8d8:	609a      	str	r2, [r3, #8]

    /* Increase the packet length.  */
    packet_ptr -> nx_packet_length =  packet_ptr -> nx_packet_length + (ULONG)sizeof(NX_IPV4_HEADER) + router_alert;
 800a8da:	68bb      	ldr	r3, [r7, #8]
 800a8dc:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 800a8de:	69fb      	ldr	r3, [r7, #28]
 800a8e0:	4413      	add	r3, r2
 800a8e2:	f103 0214 	add.w	r2, r3, #20
 800a8e6:	68bb      	ldr	r3, [r7, #8]
 800a8e8:	625a      	str	r2, [r3, #36]	; 0x24

    /* Assert prepend pointer is no less than data start pointer.  */
    /*lint -e{946} suppress pointer subtraction, since it is necessary. */
    NX_ASSERT(packet_ptr -> nx_packet_prepend_ptr >= packet_ptr -> nx_packet_data_start);
 800a8ea:	68bb      	ldr	r3, [r7, #8]
 800a8ec:	689a      	ldr	r2, [r3, #8]
 800a8ee:	68bb      	ldr	r3, [r7, #8]
 800a8f0:	691b      	ldr	r3, [r3, #16]
 800a8f2:	429a      	cmp	r2, r3
 800a8f4:	d204      	bcs.n	800a900 <_nx_ip_header_add+0x60>
 800a8f6:	f04f 30ff 	mov.w	r0, #4294967295
 800a8fa:	f00a f95b 	bl	8014bb4 <_tx_thread_sleep>
 800a8fe:	e7fa      	b.n	800a8f6 <_nx_ip_header_add+0x56>

    /* Setup the IP header pointer.  */
    /*lint -e{927} -e{826} suppress cast of pointer to pointer, since it is necessary  */
    ip_header_ptr =  (NX_IPV4_HEADER *)packet_ptr -> nx_packet_prepend_ptr;
 800a900:	68bb      	ldr	r3, [r7, #8]
 800a902:	689b      	ldr	r3, [r3, #8]
 800a904:	61bb      	str	r3, [r7, #24]
    packet_ptr -> nx_packet_ip_header = packet_ptr -> nx_packet_prepend_ptr;
 800a906:	68bb      	ldr	r3, [r7, #8]
 800a908:	689a      	ldr	r2, [r3, #8]
 800a90a:	68bb      	ldr	r3, [r7, #8]
 800a90c:	635a      	str	r2, [r3, #52]	; 0x34
    packet_ptr -> nx_packet_ip_header_length = (UCHAR)(packet_ptr -> nx_packet_ip_header_length +
 800a90e:	68bb      	ldr	r3, [r7, #8]
 800a910:	f893 202e 	ldrb.w	r2, [r3, #46]	; 0x2e
                                                       sizeof(NX_IPV4_HEADER) + router_alert);
 800a914:	69fb      	ldr	r3, [r7, #28]
 800a916:	b2db      	uxtb	r3, r3
 800a918:	4413      	add	r3, r2
 800a91a:	b2db      	uxtb	r3, r3
    packet_ptr -> nx_packet_ip_header_length = (UCHAR)(packet_ptr -> nx_packet_ip_header_length +
 800a91c:	3314      	adds	r3, #20
 800a91e:	b2da      	uxtb	r2, r3
 800a920:	68bb      	ldr	r3, [r7, #8]
 800a922:	f883 202e 	strb.w	r2, [r3, #46]	; 0x2e

    /* Determine if this is an identical copy for TCP retransmission.
       RFC1122, Section3.2.1.5, Page32-33. RFC1122, Section4.2.2.15, Page90-91.  */
    if (packet_ptr -> nx_packet_identical_copy == NX_TRUE)
 800a926:	68bb      	ldr	r3, [r7, #8]
 800a928:	f893 302d 	ldrb.w	r3, [r3, #45]	; 0x2d
 800a92c:	2b01      	cmp	r3, #1
 800a92e:	d101      	bne.n	800a934 <_nx_ip_header_add+0x94>
    {

        /* Yes, this an identical copy for TCP retransmission.
           The IP header has been added, return.  */
        return(NX_SUCCESS);
 800a930:	2300      	movs	r3, #0
 800a932:	e078      	b.n	800aa26 <_nx_ip_header_add+0x186>
    }

    /* Build the IP header.  */

#ifndef NX_DISABLE_IGMPV2
    if (router_alert)
 800a934:	69fb      	ldr	r3, [r7, #28]
 800a936:	2b00      	cmp	r3, #0
 800a938:	d009      	beq.n	800a94e <_nx_ip_header_add+0xae>

        /* Build the first 32-bit word of the IP header.  */
        ip_header_ptr -> nx_ip_header_word_0 =  (ULONG)((NX_IP_VERSION_V4 << 28) |
                                                        (NX_IP_HEADER_LENGTH_ENCODE_6 << 24) |
                                                        type_of_service |
                                                        (0xFFFF & packet_ptr -> nx_packet_length));
 800a93a:	68bb      	ldr	r3, [r7, #8]
 800a93c:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800a93e:	b29a      	uxth	r2, r3
        ip_header_ptr -> nx_ip_header_word_0 =  (ULONG)((NX_IP_VERSION_V4 << 28) |
 800a940:	683b      	ldr	r3, [r7, #0]
 800a942:	4313      	orrs	r3, r2
 800a944:	f043 428c 	orr.w	r2, r3, #1174405120	; 0x46000000
 800a948:	69bb      	ldr	r3, [r7, #24]
 800a94a:	601a      	str	r2, [r3, #0]
 800a94c:	e008      	b.n	800a960 <_nx_ip_header_add+0xc0>
    else
#endif
    {

        /* Build the first 32-bit word of the IP header.  */
        ip_header_ptr -> nx_ip_header_word_0 =  (NX_IP_VERSION | type_of_service | (0xFFFF & packet_ptr -> nx_packet_length));
 800a94e:	68bb      	ldr	r3, [r7, #8]
 800a950:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800a952:	b29a      	uxth	r2, r3
 800a954:	683b      	ldr	r3, [r7, #0]
 800a956:	4313      	orrs	r3, r2
 800a958:	f043 428a 	orr.w	r2, r3, #1157627904	; 0x45000000
 800a95c:	69bb      	ldr	r3, [r7, #24]
 800a95e:	601a      	str	r2, [r3, #0]
    }

    /* Build the second 32-bit word of the IP header.  */
    ip_header_ptr -> nx_ip_header_word_1 =  (ip_ptr -> nx_ip_packet_id++ << NX_SHIFT_BY_16) | fragment;
 800a960:	68fb      	ldr	r3, [r7, #12]
 800a962:	f8d3 3134 	ldr.w	r3, [r3, #308]	; 0x134
 800a966:	1c59      	adds	r1, r3, #1
 800a968:	68fa      	ldr	r2, [r7, #12]
 800a96a:	f8c2 1134 	str.w	r1, [r2, #308]	; 0x134
 800a96e:	041a      	lsls	r2, r3, #16
 800a970:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800a972:	431a      	orrs	r2, r3
 800a974:	69bb      	ldr	r3, [r7, #24]
 800a976:	605a      	str	r2, [r3, #4]

    /* Build the third 32-bit word of the IP header.  */
    ip_header_ptr -> nx_ip_header_word_2 =  ((time_to_live << NX_IP_TIME_TO_LIVE_SHIFT) | protocol);
 800a978:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800a97a:	061a      	lsls	r2, r3, #24
 800a97c:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800a97e:	431a      	orrs	r2, r3
 800a980:	69bb      	ldr	r3, [r7, #24]
 800a982:	609a      	str	r2, [r3, #8]

    /* Place the source IP address in the IP header.  */
    ip_header_ptr -> nx_ip_header_source_ip =  packet_ptr -> nx_packet_ip_interface -> nx_interface_ip_address;
 800a984:	68bb      	ldr	r3, [r7, #8]
 800a986:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800a988:	695a      	ldr	r2, [r3, #20]
 800a98a:	69bb      	ldr	r3, [r7, #24]
 800a98c:	60da      	str	r2, [r3, #12]

    /* Place the destination IP address in the IP header.  */
    ip_header_ptr -> nx_ip_header_destination_ip =  destination_ip;
 800a98e:	69bb      	ldr	r3, [r7, #24]
 800a990:	687a      	ldr	r2, [r7, #4]
 800a992:	611a      	str	r2, [r3, #16]

#ifndef NX_DISABLE_IGMPV2
    if (router_alert)
 800a994:	69fb      	ldr	r3, [r7, #28]
 800a996:	2b00      	cmp	r3, #0
 800a998:	d004      	beq.n	800a9a4 <_nx_ip_header_add+0x104>
    {

        /* Append Router Alert Option. */
        /*lint -e{927} -e{826} suppress cast of pointer to pointer, since it is necessary  */
        *((ULONG *)(packet_ptr -> nx_packet_prepend_ptr + sizeof(NX_IPV4_HEADER))) = (NX_IP_OPTION_COPY_FLAG |
 800a99a:	68bb      	ldr	r3, [r7, #8]
 800a99c:	689b      	ldr	r3, [r3, #8]
 800a99e:	3314      	adds	r3, #20
 800a9a0:	4a23      	ldr	r2, [pc, #140]	; (800aa30 <_nx_ip_header_add+0x190>)
 800a9a2:	601a      	str	r2, [r3, #0]
    }
#endif

    /* Endian swapping logic.  If NX_LITTLE_ENDIAN is specified, these macros will
       swap the endian of the IP header.  */
    NX_CHANGE_ULONG_ENDIAN(ip_header_ptr -> nx_ip_header_word_0);
 800a9a4:	69bb      	ldr	r3, [r7, #24]
 800a9a6:	681b      	ldr	r3, [r3, #0]
 800a9a8:	ba1a      	rev	r2, r3
 800a9aa:	69bb      	ldr	r3, [r7, #24]
 800a9ac:	601a      	str	r2, [r3, #0]
    NX_CHANGE_ULONG_ENDIAN(ip_header_ptr -> nx_ip_header_word_1);
 800a9ae:	69bb      	ldr	r3, [r7, #24]
 800a9b0:	685b      	ldr	r3, [r3, #4]
 800a9b2:	ba1a      	rev	r2, r3
 800a9b4:	69bb      	ldr	r3, [r7, #24]
 800a9b6:	605a      	str	r2, [r3, #4]
    NX_CHANGE_ULONG_ENDIAN(ip_header_ptr -> nx_ip_header_word_2);
 800a9b8:	69bb      	ldr	r3, [r7, #24]
 800a9ba:	689b      	ldr	r3, [r3, #8]
 800a9bc:	ba1a      	rev	r2, r3
 800a9be:	69bb      	ldr	r3, [r7, #24]
 800a9c0:	609a      	str	r2, [r3, #8]
    NX_CHANGE_ULONG_ENDIAN(ip_header_ptr -> nx_ip_header_source_ip);
 800a9c2:	69bb      	ldr	r3, [r7, #24]
 800a9c4:	68db      	ldr	r3, [r3, #12]
 800a9c6:	ba1a      	rev	r2, r3
 800a9c8:	69bb      	ldr	r3, [r7, #24]
 800a9ca:	60da      	str	r2, [r3, #12]
    NX_CHANGE_ULONG_ENDIAN(ip_header_ptr -> nx_ip_header_destination_ip);
 800a9cc:	69bb      	ldr	r3, [r7, #24]
 800a9ce:	691b      	ldr	r3, [r3, #16]
 800a9d0:	ba1a      	rev	r2, r3
 800a9d2:	69bb      	ldr	r3, [r7, #24]
 800a9d4:	611a      	str	r2, [r3, #16]
#ifndef NX_DISABLE_IGMPV2
    if (router_alert)
 800a9d6:	69fb      	ldr	r3, [r7, #28]
 800a9d8:	2b00      	cmp	r3, #0
 800a9da:	d008      	beq.n	800a9ee <_nx_ip_header_add+0x14e>
    {

        /*lint -e{927} -e{826} suppress cast of pointer to pointer, since it is necessary  */
        NX_CHANGE_ULONG_ENDIAN(*((ULONG *)(packet_ptr -> nx_packet_prepend_ptr + sizeof(NX_IPV4_HEADER))));
 800a9dc:	68bb      	ldr	r3, [r7, #8]
 800a9de:	689b      	ldr	r3, [r3, #8]
 800a9e0:	3314      	adds	r3, #20
 800a9e2:	681a      	ldr	r2, [r3, #0]
 800a9e4:	68bb      	ldr	r3, [r7, #8]
 800a9e6:	689b      	ldr	r3, [r3, #8]
 800a9e8:	3314      	adds	r3, #20
 800a9ea:	ba12      	rev	r2, r2
 800a9ec:	601a      	str	r2, [r3, #0]
    if (compute_checksum)
#endif /* defined(NX_DISABLE_IP_TX_CHECKSUM) || defined(NX_ENABLE_INTERFACE_CAPABILITY) || defined(NX_IPSEC_ENABLE) */
    {
        checksum = _nx_ip_checksum_compute(packet_ptr, NX_IP_VERSION_V4,
                                           /* Length is the size of IP header, including options */
                                           (UINT)(20 + router_alert),
 800a9ee:	69fb      	ldr	r3, [r7, #28]
 800a9f0:	f103 0214 	add.w	r2, r3, #20
        checksum = _nx_ip_checksum_compute(packet_ptr, NX_IP_VERSION_V4,
 800a9f4:	2300      	movs	r3, #0
 800a9f6:	9300      	str	r3, [sp, #0]
 800a9f8:	2300      	movs	r3, #0
 800a9fa:	2104      	movs	r1, #4
 800a9fc:	68b8      	ldr	r0, [r7, #8]
 800a9fe:	f7ff f913 	bl	8009c28 <_nx_ip_checksum_compute>
 800aa02:	4603      	mov	r3, r0
 800aa04:	617b      	str	r3, [r7, #20]
                                           /* IPv4 header checksum does not use src/dest addresses */
                                           NULL, NULL);

        val = (ULONG)(~checksum);
 800aa06:	697b      	ldr	r3, [r7, #20]
 800aa08:	43db      	mvns	r3, r3
 800aa0a:	613b      	str	r3, [r7, #16]
        val = val & NX_LOWER_16_MASK;
 800aa0c:	693b      	ldr	r3, [r7, #16]
 800aa0e:	b29b      	uxth	r3, r3
 800aa10:	613b      	str	r3, [r7, #16]

        /* Convert to network byte order. */
        NX_CHANGE_ULONG_ENDIAN(val);
 800aa12:	693b      	ldr	r3, [r7, #16]
 800aa14:	ba1b      	rev	r3, r3
 800aa16:	613b      	str	r3, [r7, #16]

        /* Now store the checksum in the IP header.  */
        ip_header_ptr -> nx_ip_header_word_2 =  ip_header_ptr -> nx_ip_header_word_2 | val;
 800aa18:	69bb      	ldr	r3, [r7, #24]
 800aa1a:	689a      	ldr	r2, [r3, #8]
 800aa1c:	693b      	ldr	r3, [r7, #16]
 800aa1e:	431a      	orrs	r2, r3
 800aa20:	69bb      	ldr	r3, [r7, #24]
 800aa22:	609a      	str	r2, [r3, #8]
        packet_ptr -> nx_packet_interface_capability_flag |= NX_INTERFACE_CAPABILITY_IPV4_TX_CHECKSUM;
    }
#endif /* NX_ENABLE_INTERFACE_CAPABILITY */

    /* Return...  */
    return(NX_SUCCESS);
 800aa24:	2300      	movs	r3, #0
}
 800aa26:	4618      	mov	r0, r3
 800aa28:	3720      	adds	r7, #32
 800aa2a:	46bd      	mov	sp, r7
 800aa2c:	bd80      	pop	{r7, pc}
 800aa2e:	bf00      	nop
 800aa30:	94040000 	.word	0x94040000

0800aa34 <_nx_ip_initialize>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
VOID  _nx_ip_initialize(VOID)
{
 800aa34:	b480      	push	{r7}
 800aa36:	af00      	add	r7, sp, #0

    /* Initialize the created IP instance variables.  */
    _nx_ip_created_ptr =     NX_NULL;
 800aa38:	4b05      	ldr	r3, [pc, #20]	; (800aa50 <_nx_ip_initialize+0x1c>)
 800aa3a:	2200      	movs	r2, #0
 800aa3c:	601a      	str	r2, [r3, #0]
    _nx_ip_created_count =   0;
 800aa3e:	4b05      	ldr	r3, [pc, #20]	; (800aa54 <_nx_ip_initialize+0x20>)
 800aa40:	2200      	movs	r2, #0
 800aa42:	601a      	str	r2, [r3, #0]
}
 800aa44:	bf00      	nop
 800aa46:	46bd      	mov	sp, r7
 800aa48:	f85d 7b04 	ldr.w	r7, [sp], #4
 800aa4c:	4770      	bx	lr
 800aa4e:	bf00      	nop
 800aa50:	24000b08 	.word	0x24000b08
 800aa54:	24000b0c 	.word	0x24000b0c

0800aa58 <_nx_ip_interface_address_get>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
UINT  _nx_ip_interface_address_get(NX_IP *ip_ptr, UINT interface_index, ULONG *ip_address, ULONG *network_mask)
{
 800aa58:	b580      	push	{r7, lr}
 800aa5a:	b088      	sub	sp, #32
 800aa5c:	af00      	add	r7, sp, #0
 800aa5e:	60f8      	str	r0, [r7, #12]
 800aa60:	60b9      	str	r1, [r7, #8]
 800aa62:	607a      	str	r2, [r7, #4]
 800aa64:	603b      	str	r3, [r7, #0]
                            ip_ptr -> nx_ip_interface[interface_index].nx_interface_ip_network_mask, 0, NX_TRACE_IP_EVENTS, 0, 0);



    /* Get mutex protection.  */
    tx_mutex_get(&(ip_ptr -> nx_ip_protection), TX_WAIT_FOREVER);
 800aa66:	68fb      	ldr	r3, [r7, #12]
 800aa68:	f503 739e 	add.w	r3, r3, #316	; 0x13c
 800aa6c:	f04f 31ff 	mov.w	r1, #4294967295
 800aa70:	4618      	mov	r0, r3
 800aa72:	f008 f97f 	bl	8012d74 <_tx_mutex_get>
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 800aa76:	f3ef 8310 	mrs	r3, PRIMASK
 800aa7a:	617b      	str	r3, [r7, #20]
    return(posture);
 800aa7c:	697b      	ldr	r3, [r7, #20]
    int_posture = __get_interrupt_posture();
 800aa7e:	613b      	str	r3, [r7, #16]
    __asm__ volatile ("CPSID i" : : : "memory");
 800aa80:	b672      	cpsid	i
    return(int_posture);
 800aa82:	693b      	ldr	r3, [r7, #16]

    /* Disable interrupts.  */
    TX_DISABLE
 800aa84:	61fb      	str	r3, [r7, #28]


    /* Pickup the IP address and the network mask. */
    *ip_address =    ip_ptr -> nx_ip_interface[interface_index].nx_interface_ip_address;
 800aa86:	68fa      	ldr	r2, [r7, #12]
 800aa88:	68bb      	ldr	r3, [r7, #8]
 800aa8a:	214c      	movs	r1, #76	; 0x4c
 800aa8c:	fb01 f303 	mul.w	r3, r1, r3
 800aa90:	4413      	add	r3, r2
 800aa92:	f203 7334 	addw	r3, r3, #1844	; 0x734
 800aa96:	681a      	ldr	r2, [r3, #0]
 800aa98:	687b      	ldr	r3, [r7, #4]
 800aa9a:	601a      	str	r2, [r3, #0]
    *network_mask =  ip_ptr -> nx_ip_interface[interface_index].nx_interface_ip_network_mask;
 800aa9c:	68fa      	ldr	r2, [r7, #12]
 800aa9e:	68bb      	ldr	r3, [r7, #8]
 800aaa0:	214c      	movs	r1, #76	; 0x4c
 800aaa2:	fb01 f303 	mul.w	r3, r1, r3
 800aaa6:	4413      	add	r3, r2
 800aaa8:	f503 63e7 	add.w	r3, r3, #1848	; 0x738
 800aaac:	681a      	ldr	r2, [r3, #0]
 800aaae:	683b      	ldr	r3, [r7, #0]
 800aab0:	601a      	str	r2, [r3, #0]
 800aab2:	69fb      	ldr	r3, [r7, #28]
 800aab4:	61bb      	str	r3, [r7, #24]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 800aab6:	69bb      	ldr	r3, [r7, #24]
 800aab8:	f383 8810 	msr	PRIMASK, r3
}
 800aabc:	bf00      	nop

    /* Restore interrupts.  */
    TX_RESTORE

    /* Release mutex protection.  */
    tx_mutex_put(&(ip_ptr -> nx_ip_protection));
 800aabe:	68fb      	ldr	r3, [r7, #12]
 800aac0:	f503 739e 	add.w	r3, r3, #316	; 0x13c
 800aac4:	4618      	mov	r0, r3
 800aac6:	f008 fbcd 	bl	8013264 <_tx_mutex_put>

    /* Return completion status.  */
    return(NX_SUCCESS);
 800aaca:	2300      	movs	r3, #0
    NX_PARAMETER_NOT_USED(ip_address);
    NX_PARAMETER_NOT_USED(network_mask);

    return(NX_NOT_SUPPORTED);
#endif /* !NX_DISABLE_IPV4  */
}
 800aacc:	4618      	mov	r0, r3
 800aace:	3720      	adds	r7, #32
 800aad0:	46bd      	mov	sp, r7
 800aad2:	bd80      	pop	{r7, pc}

0800aad4 <_nx_ip_interface_address_mapping_configure>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
UINT  _nx_ip_interface_address_mapping_configure(NX_IP *ip_ptr, UINT interface_index, UINT mapping_needed)
{
 800aad4:	b580      	push	{r7, lr}
 800aad6:	b084      	sub	sp, #16
 800aad8:	af00      	add	r7, sp, #0
 800aada:	60f8      	str	r0, [r7, #12]
 800aadc:	60b9      	str	r1, [r7, #8]
 800aade:	607a      	str	r2, [r7, #4]

    /* Get mutex protection.  */
    tx_mutex_get(&(ip_ptr -> nx_ip_protection), TX_WAIT_FOREVER);
 800aae0:	68fb      	ldr	r3, [r7, #12]
 800aae2:	f503 739e 	add.w	r3, r3, #316	; 0x13c
 800aae6:	f04f 31ff 	mov.w	r1, #4294967295
 800aaea:	4618      	mov	r0, r3
 800aaec:	f008 f942 	bl	8012d74 <_tx_mutex_get>

    /* Set mapping needed. */
    ip_ptr -> nx_ip_interface[interface_index].nx_interface_address_mapping_needed = (UCHAR)mapping_needed;
 800aaf0:	687b      	ldr	r3, [r7, #4]
 800aaf2:	b2d8      	uxtb	r0, r3
 800aaf4:	68fa      	ldr	r2, [r7, #12]
 800aaf6:	68bb      	ldr	r3, [r7, #8]
 800aaf8:	214c      	movs	r1, #76	; 0x4c
 800aafa:	fb01 f303 	mul.w	r3, r1, r3
 800aafe:	4413      	add	r3, r2
 800ab00:	f203 7325 	addw	r3, r3, #1829	; 0x725
 800ab04:	4602      	mov	r2, r0
 800ab06:	701a      	strb	r2, [r3, #0]

    /* Release mutex protection.  */
    tx_mutex_put(&(ip_ptr -> nx_ip_protection));
 800ab08:	68fb      	ldr	r3, [r7, #12]
 800ab0a:	f503 739e 	add.w	r3, r3, #316	; 0x13c
 800ab0e:	4618      	mov	r0, r3
 800ab10:	f008 fba8 	bl	8013264 <_tx_mutex_put>

    /* Return completion status.  */
    return(NX_SUCCESS);
 800ab14:	2300      	movs	r3, #0
}
 800ab16:	4618      	mov	r0, r3
 800ab18:	3710      	adds	r7, #16
 800ab1a:	46bd      	mov	sp, r7
 800ab1c:	bd80      	pop	{r7, pc}

0800ab1e <_nx_ip_interface_address_set>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
UINT  _nx_ip_interface_address_set(NX_IP *ip_ptr, UINT interface_index, ULONG ip_address, ULONG network_mask)
{
 800ab1e:	b580      	push	{r7, lr}
 800ab20:	b08c      	sub	sp, #48	; 0x30
 800ab22:	af00      	add	r7, sp, #0
 800ab24:	60f8      	str	r0, [r7, #12]
 800ab26:	60b9      	str	r1, [r7, #8]
 800ab28:	607a      	str	r2, [r7, #4]
 800ab2a:	603b      	str	r3, [r7, #0]
    /* If trace is enabled, insert this event into the trace buffer.  */
    NX_TRACE_IN_LINE_INSERT(NX_TRACE_IP_ADDRESS_SET, ip_ptr, ip_address, network_mask, 0, NX_TRACE_IP_EVENTS, 0, 0);


    /* Get mutex protection.  */
    tx_mutex_get(&(ip_ptr -> nx_ip_protection), TX_WAIT_FOREVER);
 800ab2c:	68fb      	ldr	r3, [r7, #12]
 800ab2e:	f503 739e 	add.w	r3, r3, #316	; 0x13c
 800ab32:	f04f 31ff 	mov.w	r1, #4294967295
 800ab36:	4618      	mov	r0, r3
 800ab38:	f008 f91c 	bl	8012d74 <_tx_mutex_get>
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 800ab3c:	f3ef 8310 	mrs	r3, PRIMASK
 800ab40:	617b      	str	r3, [r7, #20]
    return(posture);
 800ab42:	697b      	ldr	r3, [r7, #20]
    int_posture = __get_interrupt_posture();
 800ab44:	613b      	str	r3, [r7, #16]
    __asm__ volatile ("CPSID i" : : : "memory");
 800ab46:	b672      	cpsid	i
    return(int_posture);
 800ab48:	693b      	ldr	r3, [r7, #16]

    /* Disable interrupts.  */
    TX_DISABLE
 800ab4a:	62fb      	str	r3, [r7, #44]	; 0x2c

    /* Save previous IP address and network mask.  */
    previous_ip_address =    ip_ptr -> nx_ip_interface[interface_index].nx_interface_ip_address;
 800ab4c:	68fa      	ldr	r2, [r7, #12]
 800ab4e:	68bb      	ldr	r3, [r7, #8]
 800ab50:	214c      	movs	r1, #76	; 0x4c
 800ab52:	fb01 f303 	mul.w	r3, r1, r3
 800ab56:	4413      	add	r3, r2
 800ab58:	f203 7334 	addw	r3, r3, #1844	; 0x734
 800ab5c:	681b      	ldr	r3, [r3, #0]
 800ab5e:	62bb      	str	r3, [r7, #40]	; 0x28
    previous_network_mask =  ip_ptr -> nx_ip_interface[interface_index].nx_interface_ip_network_mask;
 800ab60:	68fa      	ldr	r2, [r7, #12]
 800ab62:	68bb      	ldr	r3, [r7, #8]
 800ab64:	214c      	movs	r1, #76	; 0x4c
 800ab66:	fb01 f303 	mul.w	r3, r1, r3
 800ab6a:	4413      	add	r3, r2
 800ab6c:	f503 63e7 	add.w	r3, r3, #1848	; 0x738
 800ab70:	681b      	ldr	r3, [r3, #0]
 800ab72:	627b      	str	r3, [r7, #36]	; 0x24

    /* Pickup the current notification callback and additional information pointers.  */
    address_change_notify =  ip_ptr -> nx_ip_address_change_notify;
 800ab74:	68fb      	ldr	r3, [r7, #12]
 800ab76:	f8d3 32bc 	ldr.w	r3, [r3, #700]	; 0x2bc
 800ab7a:	623b      	str	r3, [r7, #32]
    additional_info =        ip_ptr -> nx_ip_address_change_notify_additional_info;
 800ab7c:	68fb      	ldr	r3, [r7, #12]
 800ab7e:	f8d3 32c0 	ldr.w	r3, [r3, #704]	; 0x2c0
 800ab82:	61fb      	str	r3, [r7, #28]

    /* Setup the IP address and the network mask. */
    ip_ptr -> nx_ip_interface[interface_index].nx_interface_ip_address      =  ip_address;
 800ab84:	68fa      	ldr	r2, [r7, #12]
 800ab86:	68bb      	ldr	r3, [r7, #8]
 800ab88:	214c      	movs	r1, #76	; 0x4c
 800ab8a:	fb01 f303 	mul.w	r3, r1, r3
 800ab8e:	4413      	add	r3, r2
 800ab90:	f203 7334 	addw	r3, r3, #1844	; 0x734
 800ab94:	687a      	ldr	r2, [r7, #4]
 800ab96:	601a      	str	r2, [r3, #0]
    ip_ptr -> nx_ip_interface[interface_index].nx_interface_ip_network_mask =  network_mask;
 800ab98:	68fa      	ldr	r2, [r7, #12]
 800ab9a:	68bb      	ldr	r3, [r7, #8]
 800ab9c:	214c      	movs	r1, #76	; 0x4c
 800ab9e:	fb01 f303 	mul.w	r3, r1, r3
 800aba2:	4413      	add	r3, r2
 800aba4:	f503 63e7 	add.w	r3, r3, #1848	; 0x738
 800aba8:	683a      	ldr	r2, [r7, #0]
 800abaa:	601a      	str	r2, [r3, #0]
    ip_ptr -> nx_ip_interface[interface_index].nx_interface_ip_network      =  ip_address & network_mask;
 800abac:	687a      	ldr	r2, [r7, #4]
 800abae:	683b      	ldr	r3, [r7, #0]
 800abb0:	401a      	ands	r2, r3
 800abb2:	68f9      	ldr	r1, [r7, #12]
 800abb4:	68bb      	ldr	r3, [r7, #8]
 800abb6:	204c      	movs	r0, #76	; 0x4c
 800abb8:	fb00 f303 	mul.w	r3, r0, r3
 800abbc:	440b      	add	r3, r1
 800abbe:	f203 733c 	addw	r3, r3, #1852	; 0x73c
 800abc2:	601a      	str	r2, [r3, #0]

    /* Ensure the RARP function is disabled.  */
    ip_ptr -> nx_ip_rarp_periodic_update =  NX_NULL;
 800abc4:	68fb      	ldr	r3, [r7, #12]
 800abc6:	2200      	movs	r2, #0
 800abc8:	f8c3 2700 	str.w	r2, [r3, #1792]	; 0x700
    ip_ptr -> nx_ip_rarp_queue_process =    NX_NULL;
 800abcc:	68fb      	ldr	r3, [r7, #12]
 800abce:	2200      	movs	r2, #0
 800abd0:	f8c3 2704 	str.w	r2, [r3, #1796]	; 0x704
 800abd4:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800abd6:	61bb      	str	r3, [r7, #24]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 800abd8:	69bb      	ldr	r3, [r7, #24]
 800abda:	f383 8810 	msr	PRIMASK, r3
}
 800abde:	bf00      	nop

    /* Restore interrupts.  */
    TX_RESTORE

    /* Release mutex protection.  */
    tx_mutex_put(&(ip_ptr -> nx_ip_protection));
 800abe0:	68fb      	ldr	r3, [r7, #12]
 800abe2:	f503 739e 	add.w	r3, r3, #316	; 0x13c
 800abe6:	4618      	mov	r0, r3
 800abe8:	f008 fb3c 	bl	8013264 <_tx_mutex_put>

    /* Determine if the application should be notified of the IP address and/or
       network mask change.  */
    if ((address_change_notify) &&
 800abec:	6a3b      	ldr	r3, [r7, #32]
 800abee:	2b00      	cmp	r3, #0
 800abf0:	d00b      	beq.n	800ac0a <_nx_ip_interface_address_set+0xec>
 800abf2:	687a      	ldr	r2, [r7, #4]
 800abf4:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800abf6:	429a      	cmp	r2, r3
 800abf8:	d103      	bne.n	800ac02 <_nx_ip_interface_address_set+0xe4>
        ((ip_address != previous_ip_address) || (network_mask != previous_network_mask)))
 800abfa:	683a      	ldr	r2, [r7, #0]
 800abfc:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800abfe:	429a      	cmp	r2, r3
 800ac00:	d003      	beq.n	800ac0a <_nx_ip_interface_address_set+0xec>
    {

        /* Yes, call the application's IP address change notify function.  */
        (address_change_notify)(ip_ptr, additional_info);
 800ac02:	6a3b      	ldr	r3, [r7, #32]
 800ac04:	69f9      	ldr	r1, [r7, #28]
 800ac06:	68f8      	ldr	r0, [r7, #12]
 800ac08:	4798      	blx	r3
    }

    /* Initialize the ARP defend timeout.  */
    ip_ptr -> nx_ip_interface[interface_index].nx_interface_arp_defend_timeout = 0;
 800ac0a:	68fa      	ldr	r2, [r7, #12]
 800ac0c:	68bb      	ldr	r3, [r7, #8]
 800ac0e:	214c      	movs	r1, #76	; 0x4c
 800ac10:	fb01 f303 	mul.w	r3, r1, r3
 800ac14:	4413      	add	r3, r2
 800ac16:	f503 63ec 	add.w	r3, r3, #1888	; 0x760
 800ac1a:	2200      	movs	r2, #0
 800ac1c:	601a      	str	r2, [r3, #0]

    /* Return completion status.  */
    return(NX_SUCCESS);
 800ac1e:	2300      	movs	r3, #0
    NX_PARAMETER_NOT_USED(ip_address);
    NX_PARAMETER_NOT_USED(network_mask);

    return(NX_NOT_SUPPORTED);
#endif /* !NX_DISABLE_IPV4  */
}
 800ac20:	4618      	mov	r0, r3
 800ac22:	3730      	adds	r7, #48	; 0x30
 800ac24:	46bd      	mov	sp, r7
 800ac26:	bd80      	pop	{r7, pc}

0800ac28 <_nx_ip_packet_deferred_receive>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
VOID  _nx_ip_packet_deferred_receive(NX_IP *ip_ptr, NX_PACKET *packet_ptr)
{
 800ac28:	b580      	push	{r7, lr}
 800ac2a:	b088      	sub	sp, #32
 800ac2c:	af00      	add	r7, sp, #0
 800ac2e:	6078      	str	r0, [r7, #4]
 800ac30:	6039      	str	r1, [r7, #0]
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 800ac32:	f3ef 8310 	mrs	r3, PRIMASK
 800ac36:	61bb      	str	r3, [r7, #24]
    return(posture);
 800ac38:	69bb      	ldr	r3, [r7, #24]
    int_posture = __get_interrupt_posture();
 800ac3a:	617b      	str	r3, [r7, #20]
    __asm__ volatile ("CPSID i" : : : "memory");
 800ac3c:	b672      	cpsid	i
    return(int_posture);
 800ac3e:	697b      	ldr	r3, [r7, #20]

TX_INTERRUPT_SAVE_AREA


    /* Disable interrupts.  */
    TX_DISABLE
 800ac40:	61fb      	str	r3, [r7, #28]

    /* Add debug information. */
    NX_PACKET_DEBUG(__FILE__, __LINE__, packet_ptr);

    /* Check to see if the deferred processing queue is empty.  */
    if (ip_ptr -> nx_ip_deferred_received_packet_head)
 800ac42:	687b      	ldr	r3, [r7, #4]
 800ac44:	f8d3 3174 	ldr.w	r3, [r3, #372]	; 0x174
 800ac48:	2b00      	cmp	r3, #0
 800ac4a:	d011      	beq.n	800ac70 <_nx_ip_packet_deferred_receive+0x48>
    {

        /* Not empty, just place the packet at the end of the queue.  */
        (ip_ptr -> nx_ip_deferred_received_packet_tail) -> nx_packet_queue_next =  packet_ptr;
 800ac4c:	687b      	ldr	r3, [r7, #4]
 800ac4e:	f8d3 3178 	ldr.w	r3, [r3, #376]	; 0x178
 800ac52:	683a      	ldr	r2, [r7, #0]
 800ac54:	61da      	str	r2, [r3, #28]
        packet_ptr -> nx_packet_queue_next =  NX_NULL;
 800ac56:	683b      	ldr	r3, [r7, #0]
 800ac58:	2200      	movs	r2, #0
 800ac5a:	61da      	str	r2, [r3, #28]
        ip_ptr -> nx_ip_deferred_received_packet_tail =  packet_ptr;
 800ac5c:	687b      	ldr	r3, [r7, #4]
 800ac5e:	683a      	ldr	r2, [r7, #0]
 800ac60:	f8c3 2178 	str.w	r2, [r3, #376]	; 0x178
 800ac64:	69fb      	ldr	r3, [r7, #28]
 800ac66:	613b      	str	r3, [r7, #16]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 800ac68:	693b      	ldr	r3, [r7, #16]
 800ac6a:	f383 8810 	msr	PRIMASK, r3
}
 800ac6e:	e019      	b.n	800aca4 <_nx_ip_packet_deferred_receive+0x7c>
    {

        /* Empty deferred receive processing queue.  Just setup the head pointers and
           set the event flags to ensure the IP helper thread looks at the deferred processing
           queue.  */
        ip_ptr -> nx_ip_deferred_received_packet_head =  packet_ptr;
 800ac70:	687b      	ldr	r3, [r7, #4]
 800ac72:	683a      	ldr	r2, [r7, #0]
 800ac74:	f8c3 2174 	str.w	r2, [r3, #372]	; 0x174
        ip_ptr -> nx_ip_deferred_received_packet_tail =  packet_ptr;
 800ac78:	687b      	ldr	r3, [r7, #4]
 800ac7a:	683a      	ldr	r2, [r7, #0]
 800ac7c:	f8c3 2178 	str.w	r2, [r3, #376]	; 0x178
        packet_ptr -> nx_packet_queue_next =             NX_NULL;
 800ac80:	683b      	ldr	r3, [r7, #0]
 800ac82:	2200      	movs	r2, #0
 800ac84:	61da      	str	r2, [r3, #28]
 800ac86:	69fb      	ldr	r3, [r7, #28]
 800ac88:	60fb      	str	r3, [r7, #12]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 800ac8a:	68fb      	ldr	r3, [r7, #12]
 800ac8c:	f383 8810 	msr	PRIMASK, r3
}
 800ac90:	bf00      	nop

        /* Restore interrupts.  */
        TX_RESTORE

        /* Wakeup IP helper thread to process the IP deferred receive.  */
        tx_event_flags_set(&(ip_ptr -> nx_ip_events), NX_IP_RECEIVE_EVENT, TX_OR);
 800ac92:	687b      	ldr	r3, [r7, #4]
 800ac94:	f503 7313 	add.w	r3, r3, #588	; 0x24c
 800ac98:	2200      	movs	r2, #0
 800ac9a:	2108      	movs	r1, #8
 800ac9c:	4618      	mov	r0, r3
 800ac9e:	f007 fc25 	bl	80124ec <_tx_event_flags_set>
    }
}
 800aca2:	bf00      	nop
 800aca4:	bf00      	nop
 800aca6:	3720      	adds	r7, #32
 800aca8:	46bd      	mov	sp, r7
 800acaa:	bd80      	pop	{r7, pc}

0800acac <_nx_ip_packet_receive>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
VOID  _nx_ip_packet_receive(NX_IP *ip_ptr, NX_PACKET *packet_ptr)
{
 800acac:	b580      	push	{r7, lr}
 800acae:	b084      	sub	sp, #16
 800acb0:	af00      	add	r7, sp, #0
 800acb2:	6078      	str	r0, [r7, #4]
 800acb4:	6039      	str	r1, [r7, #0]
UCHAR version_byte;


#ifndef NX_DISABLE_IP_INFO
    /* Increment the IP packet count.  */
    ip_ptr -> nx_ip_total_packets_received++;
 800acb6:	687b      	ldr	r3, [r7, #4]
 800acb8:	69db      	ldr	r3, [r3, #28]
 800acba:	1c5a      	adds	r2, r3, #1
 800acbc:	687b      	ldr	r3, [r7, #4]
 800acbe:	61da      	str	r2, [r3, #28]
    /* Add debug information. */
    NX_PACKET_DEBUG(__FILE__, __LINE__, packet_ptr);

    /* If packet_ptr -> nx_packet_interface_ptr is not set, stamp the packet with interface[0].
       Legacy Ethernet drivers do not stamp incoming packets. */
    if (packet_ptr -> nx_packet_address.nx_packet_interface_ptr == NX_NULL)
 800acc0:	683b      	ldr	r3, [r7, #0]
 800acc2:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800acc4:	2b00      	cmp	r3, #0
 800acc6:	d104      	bne.n	800acd2 <_nx_ip_packet_receive+0x26>
    {
        packet_ptr -> nx_packet_address.nx_packet_interface_ptr = &(ip_ptr -> nx_ip_interface[0]);
 800acc8:	687b      	ldr	r3, [r7, #4]
 800acca:	f503 62e4 	add.w	r2, r3, #1824	; 0x720
 800acce:	683b      	ldr	r3, [r7, #0]
 800acd0:	631a      	str	r2, [r3, #48]	; 0x30
    }

    /* It's assumed that the IP link driver has positioned the top pointer in the
       packet to the start of the IP address... so that's where we will start.  */
    version_byte =  *(packet_ptr -> nx_packet_prepend_ptr);
 800acd2:	683b      	ldr	r3, [r7, #0]
 800acd4:	689b      	ldr	r3, [r3, #8]
 800acd6:	781b      	ldrb	r3, [r3, #0]
 800acd8:	73fb      	strb	r3, [r7, #15]

    /* Check the version number */
    ip_version = (version_byte >> 4);
 800acda:	7bfb      	ldrb	r3, [r7, #15]
 800acdc:	091b      	lsrs	r3, r3, #4
 800acde:	73bb      	strb	r3, [r7, #14]

    packet_ptr -> nx_packet_ip_version = ip_version;
 800ace0:	683b      	ldr	r3, [r7, #0]
 800ace2:	7bba      	ldrb	r2, [r7, #14]
 800ace4:	f883 202c 	strb.w	r2, [r3, #44]	; 0x2c

    packet_ptr -> nx_packet_ip_header = packet_ptr -> nx_packet_prepend_ptr;
 800ace8:	683b      	ldr	r3, [r7, #0]
 800acea:	689a      	ldr	r2, [r3, #8]
 800acec:	683b      	ldr	r3, [r7, #0]
 800acee:	635a      	str	r2, [r3, #52]	; 0x34
#endif /* NX_ENABLE_IP_PACKET_FILTER */

#ifndef NX_DISABLE_IPV4

    /* Process the packet according to IP version. */
    if (ip_version == NX_IP_VERSION_V4 && ip_ptr -> nx_ipv4_packet_receive)
 800acf0:	7bbb      	ldrb	r3, [r7, #14]
 800acf2:	2b04      	cmp	r3, #4
 800acf4:	d10b      	bne.n	800ad0e <_nx_ip_packet_receive+0x62>
 800acf6:	687b      	ldr	r3, [r7, #4]
 800acf8:	f8d3 389c 	ldr.w	r3, [r3, #2204]	; 0x89c
 800acfc:	2b00      	cmp	r3, #0
 800acfe:	d006      	beq.n	800ad0e <_nx_ip_packet_receive+0x62>
    {

        /* Call the IPv4 packet handler. */
        (ip_ptr -> nx_ipv4_packet_receive)(ip_ptr, packet_ptr);
 800ad00:	687b      	ldr	r3, [r7, #4]
 800ad02:	f8d3 389c 	ldr.w	r3, [r3, #2204]	; 0x89c
 800ad06:	6839      	ldr	r1, [r7, #0]
 800ad08:	6878      	ldr	r0, [r7, #4]
 800ad0a:	4798      	blx	r3
        return;
 800ad0c:	e00d      	b.n	800ad2a <_nx_ip_packet_receive+0x7e>
        not defined.  In this case, the packet is reclaimed. */

#ifndef NX_DISABLE_IP_INFO

    /* Increment the IP invalid packet error.  */
    ip_ptr -> nx_ip_invalid_packets++;
 800ad0e:	687b      	ldr	r3, [r7, #4]
 800ad10:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 800ad12:	1c5a      	adds	r2, r3, #1
 800ad14:	687b      	ldr	r3, [r7, #4]
 800ad16:	635a      	str	r2, [r3, #52]	; 0x34

    /* Increment the IP receive packets dropped count.  */
    ip_ptr -> nx_ip_receive_packets_dropped++;
 800ad18:	687b      	ldr	r3, [r7, #4]
 800ad1a:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 800ad1c:	1c5a      	adds	r2, r3, #1
 800ad1e:	687b      	ldr	r3, [r7, #4]
 800ad20:	64da      	str	r2, [r3, #76]	; 0x4c
#endif

    _nx_packet_release(packet_ptr);
 800ad22:	6838      	ldr	r0, [r7, #0]
 800ad24:	f001 fb70 	bl	800c408 <_nx_packet_release>

    return;
 800ad28:	bf00      	nop
}
 800ad2a:	3710      	adds	r7, #16
 800ad2c:	46bd      	mov	sp, r7
 800ad2e:	bd80      	pop	{r7, pc}

0800ad30 <_nx_ip_packet_send>:
/*                                                                        */
/**************************************************************************/
VOID  _nx_ip_packet_send(NX_IP *ip_ptr, NX_PACKET *packet_ptr,
                         ULONG destination_ip, ULONG type_of_service, ULONG time_to_live,
                         ULONG protocol, ULONG fragment, ULONG next_hop_address)
{
 800ad30:	b580      	push	{r7, lr}
 800ad32:	b088      	sub	sp, #32
 800ad34:	af04      	add	r7, sp, #16
 800ad36:	60f8      	str	r0, [r7, #12]
 800ad38:	60b9      	str	r1, [r7, #8]
 800ad3a:	607a      	str	r2, [r7, #4]
 800ad3c:	603b      	str	r3, [r7, #0]
    NX_PACKET_DEBUG(__FILE__, __LINE__, packet_ptr);

#ifndef NX_DISABLE_IP_INFO

    /* Increment the total send requests counter.  */
    ip_ptr -> nx_ip_total_packet_send_requests++;
 800ad3e:	68fb      	ldr	r3, [r7, #12]
 800ad40:	691b      	ldr	r3, [r3, #16]
 800ad42:	1c5a      	adds	r2, r3, #1
 800ad44:	68fb      	ldr	r3, [r7, #12]
 800ad46:	611a      	str	r2, [r3, #16]
#endif

    /* Make sure the packet interface is set. */
    if (packet_ptr -> nx_packet_address.nx_packet_interface_ptr == NX_NULL)
 800ad48:	68bb      	ldr	r3, [r7, #8]
 800ad4a:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800ad4c:	2b00      	cmp	r3, #0
 800ad4e:	d114      	bne.n	800ad7a <_nx_ip_packet_send+0x4a>
    {

#ifndef NX_DISABLE_IP_INFO

        /* Increment the IP invalid packet error.  */
        ip_ptr -> nx_ip_invalid_transmit_packets++;
 800ad50:	68fb      	ldr	r3, [r7, #12]
 800ad52:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 800ad54:	1c5a      	adds	r2, r3, #1
 800ad56:	68fb      	ldr	r3, [r7, #12]
 800ad58:	639a      	str	r2, [r3, #56]	; 0x38
#endif /* !NX_DISABLE_IP_INFO */

        /* Prepend the IP header to the packet.  First, make room for the IP header.  */
        packet_ptr -> nx_packet_prepend_ptr =  packet_ptr -> nx_packet_prepend_ptr - sizeof(NX_IPV4_HEADER);
 800ad5a:	68bb      	ldr	r3, [r7, #8]
 800ad5c:	689b      	ldr	r3, [r3, #8]
 800ad5e:	f1a3 0214 	sub.w	r2, r3, #20
 800ad62:	68bb      	ldr	r3, [r7, #8]
 800ad64:	609a      	str	r2, [r3, #8]

        /* Increase the packet length.  */
        packet_ptr -> nx_packet_length =  packet_ptr -> nx_packet_length + (ULONG)sizeof(NX_IPV4_HEADER);
 800ad66:	68bb      	ldr	r3, [r7, #8]
 800ad68:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800ad6a:	f103 0214 	add.w	r2, r3, #20
 800ad6e:	68bb      	ldr	r3, [r7, #8]
 800ad70:	625a      	str	r2, [r3, #36]	; 0x24

        /* Release the packet.  */
        _nx_packet_transmit_release(packet_ptr);
 800ad72:	68b8      	ldr	r0, [r7, #8]
 800ad74:	f001 fbfe 	bl	800c574 <_nx_packet_transmit_release>

        /* Return... nothing more can be done!  */
        return;
 800ad78:	e037      	b.n	800adea <_nx_ip_packet_send+0xba>
    if (!is_hw_processed)
#endif /* NX_IPSEC_ENABLE  */
    {

        /* Add the IP Header to the packet.  */
        _nx_ip_header_add(ip_ptr, packet_ptr, destination_ip, type_of_service, time_to_live, protocol, fragment);
 800ad7a:	6a3b      	ldr	r3, [r7, #32]
 800ad7c:	9302      	str	r3, [sp, #8]
 800ad7e:	69fb      	ldr	r3, [r7, #28]
 800ad80:	9301      	str	r3, [sp, #4]
 800ad82:	69bb      	ldr	r3, [r7, #24]
 800ad84:	9300      	str	r3, [sp, #0]
 800ad86:	683b      	ldr	r3, [r7, #0]
 800ad88:	687a      	ldr	r2, [r7, #4]
 800ad8a:	68b9      	ldr	r1, [r7, #8]
 800ad8c:	68f8      	ldr	r0, [r7, #12]
 800ad8e:	f7ff fd87 	bl	800a8a0 <_nx_ip_header_add>
    }

#endif

    /* If the next hop address is null, indicates the specified interface is unreached.  */
    if (next_hop_address == 0)
 800ad92:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800ad94:	2b00      	cmp	r3, #0
 800ad96:	d120      	bne.n	800adda <_nx_ip_packet_send+0xaa>
    {

        /* Check whether the forward feature is enabled.  */
        if (ip_ptr -> nx_ip_forward_packet_process)
 800ad98:	68fb      	ldr	r3, [r7, #12]
 800ad9a:	f8d3 3130 	ldr.w	r3, [r3, #304]	; 0x130
 800ad9e:	2b00      	cmp	r3, #0
 800ada0:	d00b      	beq.n	800adba <_nx_ip_packet_send+0x8a>
        {

            /* Initialize the interface.  */
            packet_ptr -> nx_packet_address.nx_packet_interface_ptr = NX_NULL;
 800ada2:	68bb      	ldr	r3, [r7, #8]
 800ada4:	2200      	movs	r2, #0
 800ada6:	631a      	str	r2, [r3, #48]	; 0x30

            /* Figure out the best interface to send the packet on. */
            _nx_ip_route_find(ip_ptr, destination_ip, &packet_ptr -> nx_packet_address.nx_packet_interface_ptr, &next_hop_address);
 800ada8:	68bb      	ldr	r3, [r7, #8]
 800adaa:	f103 0230 	add.w	r2, r3, #48	; 0x30
 800adae:	f107 0324 	add.w	r3, r7, #36	; 0x24
 800adb2:	6879      	ldr	r1, [r7, #4]
 800adb4:	68f8      	ldr	r0, [r7, #12]
 800adb6:	f000 f82d 	bl	800ae14 <_nx_ip_route_find>
        }

        /* Make sure the packet interface and next hop address are set. */
        /*lint -e{644} suppress variable might not be initialized, since "next_hop_address" was initialized in _nx_ip_route_find. */
        if ((packet_ptr -> nx_packet_address.nx_packet_interface_ptr == NX_NULL) || (next_hop_address == 0))
 800adba:	68bb      	ldr	r3, [r7, #8]
 800adbc:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800adbe:	2b00      	cmp	r3, #0
 800adc0:	d002      	beq.n	800adc8 <_nx_ip_packet_send+0x98>
 800adc2:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800adc4:	2b00      	cmp	r3, #0
 800adc6:	d108      	bne.n	800adda <_nx_ip_packet_send+0xaa>
        {

#ifndef NX_DISABLE_IP_INFO

            /* Increment the IP invalid packet error.  */
            ip_ptr -> nx_ip_invalid_transmit_packets++;
 800adc8:	68fb      	ldr	r3, [r7, #12]
 800adca:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 800adcc:	1c5a      	adds	r2, r3, #1
 800adce:	68fb      	ldr	r3, [r7, #12]
 800add0:	639a      	str	r2, [r3, #56]	; 0x38
#endif /* !NX_DISABLE_IP_INFO */

            /* Release the packet.  */
            _nx_packet_transmit_release(packet_ptr);
 800add2:	68b8      	ldr	r0, [r7, #8]
 800add4:	f001 fbce 	bl	800c574 <_nx_packet_transmit_release>

            /* Return... nothing more can be done!  */
            return;
 800add8:	e007      	b.n	800adea <_nx_ip_packet_send+0xba>
        }
    }

    /* Directly send the packet.  */
    _nx_ip_driver_packet_send(ip_ptr, packet_ptr, destination_ip, fragment, next_hop_address);
 800adda:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800addc:	9300      	str	r3, [sp, #0]
 800adde:	6a3b      	ldr	r3, [r7, #32]
 800ade0:	687a      	ldr	r2, [r7, #4]
 800ade2:	68b9      	ldr	r1, [r7, #8]
 800ade4:	68f8      	ldr	r0, [r7, #12]
 800ade6:	f7ff fa4d 	bl	800a284 <_nx_ip_driver_packet_send>
}
 800adea:	3710      	adds	r7, #16
 800adec:	46bd      	mov	sp, r7
 800adee:	bd80      	pop	{r7, pc}

0800adf0 <_nx_ip_periodic_timer_entry>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
VOID  _nx_ip_periodic_timer_entry(ULONG ip_address)
{
 800adf0:	b580      	push	{r7, lr}
 800adf2:	b084      	sub	sp, #16
 800adf4:	af00      	add	r7, sp, #0
 800adf6:	6078      	str	r0, [r7, #4]

NX_IP *ip_ptr;


    /* Setup IP pointer.  */
    NX_TIMER_EXTENSION_PTR_GET(ip_ptr, NX_IP, ip_address)
 800adf8:	687b      	ldr	r3, [r7, #4]
 800adfa:	60fb      	str	r3, [r7, #12]

    /* Wakeup this IP's helper thread.  */
    tx_event_flags_set(&(ip_ptr -> nx_ip_events), NX_IP_PERIODIC_EVENT, TX_OR);
 800adfc:	68fb      	ldr	r3, [r7, #12]
 800adfe:	f503 7313 	add.w	r3, r3, #588	; 0x24c
 800ae02:	2200      	movs	r2, #0
 800ae04:	2101      	movs	r1, #1
 800ae06:	4618      	mov	r0, r3
 800ae08:	f007 fb70 	bl	80124ec <_tx_event_flags_set>
}
 800ae0c:	bf00      	nop
 800ae0e:	3710      	adds	r7, #16
 800ae10:	46bd      	mov	sp, r7
 800ae12:	bd80      	pop	{r7, pc}

0800ae14 <_nx_ip_route_find>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
ULONG  _nx_ip_route_find(NX_IP *ip_ptr, ULONG destination_address, NX_INTERFACE **ip_interface_ptr, ULONG *next_hop_address)
{
 800ae14:	b480      	push	{r7}
 800ae16:	b087      	sub	sp, #28
 800ae18:	af00      	add	r7, sp, #0
 800ae1a:	60f8      	str	r0, [r7, #12]
 800ae1c:	60b9      	str	r1, [r7, #8]
 800ae1e:	607a      	str	r2, [r7, #4]
 800ae20:	603b      	str	r3, [r7, #0]

NX_INTERFACE *interface_ptr;
ULONG         i;

    /* Initialize the next hop address. */
    *next_hop_address = 0;
 800ae22:	683b      	ldr	r3, [r7, #0]
 800ae24:	2200      	movs	r2, #0
 800ae26:	601a      	str	r2, [r3, #0]

    /* Determine if the destination_address is multicast or directed broadcast. */
    if (((destination_address & NX_IP_CLASS_D_MASK) == NX_IP_CLASS_D_TYPE) ||
 800ae28:	68bb      	ldr	r3, [r7, #8]
 800ae2a:	f003 4370 	and.w	r3, r3, #4026531840	; 0xf0000000
 800ae2e:	f1b3 4f60 	cmp.w	r3, #3758096384	; 0xe0000000
 800ae32:	d003      	beq.n	800ae3c <_nx_ip_route_find+0x28>
 800ae34:	68bb      	ldr	r3, [r7, #8]
 800ae36:	f1b3 3fff 	cmp.w	r3, #4294967295
 800ae3a:	d130      	bne.n	800ae9e <_nx_ip_route_find+0x8a>
        (destination_address  == NX_IP_LIMITED_BROADCAST))
    {

        *next_hop_address = destination_address;
 800ae3c:	683b      	ldr	r3, [r7, #0]
 800ae3e:	68ba      	ldr	r2, [r7, #8]
 800ae40:	601a      	str	r2, [r3, #0]

        /* If the caller did not set the ip_interface value, find a link enabled 
           interface, starting with the primary interface, for transmission.  */
        if (*ip_interface_ptr == NX_NULL)
 800ae42:	687b      	ldr	r3, [r7, #4]
 800ae44:	681b      	ldr	r3, [r3, #0]
 800ae46:	2b00      	cmp	r3, #0
 800ae48:	d120      	bne.n	800ae8c <_nx_ip_route_find+0x78>
        {

            /* Find an interface whose link is up. */
            for (i = 0; i < NX_MAX_PHYSICAL_INTERFACES; i++)
 800ae4a:	2300      	movs	r3, #0
 800ae4c:	617b      	str	r3, [r7, #20]
 800ae4e:	e019      	b.n	800ae84 <_nx_ip_route_find+0x70>
            {

                if (ip_ptr -> nx_ip_interface[i].nx_interface_link_up)
 800ae50:	68fa      	ldr	r2, [r7, #12]
 800ae52:	697b      	ldr	r3, [r7, #20]
 800ae54:	214c      	movs	r1, #76	; 0x4c
 800ae56:	fb01 f303 	mul.w	r3, r1, r3
 800ae5a:	4413      	add	r3, r2
 800ae5c:	f203 7326 	addw	r3, r3, #1830	; 0x726
 800ae60:	781b      	ldrb	r3, [r3, #0]
 800ae62:	2b00      	cmp	r3, #0
 800ae64:	d00b      	beq.n	800ae7e <_nx_ip_route_find+0x6a>
                {
                    *ip_interface_ptr = &(ip_ptr -> nx_ip_interface[i]);
 800ae66:	697b      	ldr	r3, [r7, #20]
 800ae68:	224c      	movs	r2, #76	; 0x4c
 800ae6a:	fb02 f303 	mul.w	r3, r2, r3
 800ae6e:	f503 63e4 	add.w	r3, r3, #1824	; 0x720
 800ae72:	68fa      	ldr	r2, [r7, #12]
 800ae74:	441a      	add	r2, r3
 800ae76:	687b      	ldr	r3, [r7, #4]
 800ae78:	601a      	str	r2, [r3, #0]
                    return(NX_SUCCESS);
 800ae7a:	2300      	movs	r3, #0
 800ae7c:	e137      	b.n	800b0ee <_nx_ip_route_find+0x2da>
            for (i = 0; i < NX_MAX_PHYSICAL_INTERFACES; i++)
 800ae7e:	697b      	ldr	r3, [r7, #20]
 800ae80:	3301      	adds	r3, #1
 800ae82:	617b      	str	r3, [r7, #20]
 800ae84:	697b      	ldr	r3, [r7, #20]
 800ae86:	2b03      	cmp	r3, #3
 800ae88:	d9e2      	bls.n	800ae50 <_nx_ip_route_find+0x3c>
 800ae8a:	e006      	b.n	800ae9a <_nx_ip_route_find+0x86>
                }
            }
        }
        /* If the specified interface is up, return success. */
        else if ((*ip_interface_ptr) -> nx_interface_link_up)
 800ae8c:	687b      	ldr	r3, [r7, #4]
 800ae8e:	681b      	ldr	r3, [r3, #0]
 800ae90:	799b      	ldrb	r3, [r3, #6]
 800ae92:	2b00      	cmp	r3, #0
 800ae94:	d001      	beq.n	800ae9a <_nx_ip_route_find+0x86>
        {
            return(NX_SUCCESS);
 800ae96:	2300      	movs	r3, #0
 800ae98:	e129      	b.n	800b0ee <_nx_ip_route_find+0x2da>
        }

        /* No available interface. */
        return(NX_IP_ADDRESS_ERROR);
 800ae9a:	2321      	movs	r3, #33	; 0x21
 800ae9c:	e127      	b.n	800b0ee <_nx_ip_route_find+0x2da>
    }

    /* Search through the interfaces associated with the IP instance,
       check if the the destination address is one of the local interface addresses. */
    for (i = 0; i < NX_MAX_PHYSICAL_INTERFACES; i++)
 800ae9e:	2300      	movs	r3, #0
 800aea0:	617b      	str	r3, [r7, #20]
 800aea2:	e029      	b.n	800aef8 <_nx_ip_route_find+0xe4>
    {

        /* Use a local variable for convenience. */
        interface_ptr = &(ip_ptr -> nx_ip_interface[i]);
 800aea4:	697b      	ldr	r3, [r7, #20]
 800aea6:	224c      	movs	r2, #76	; 0x4c
 800aea8:	fb02 f303 	mul.w	r3, r2, r3
 800aeac:	f503 63e4 	add.w	r3, r3, #1824	; 0x720
 800aeb0:	68fa      	ldr	r2, [r7, #12]
 800aeb2:	4413      	add	r3, r2
 800aeb4:	613b      	str	r3, [r7, #16]

        /* Check for a valid interface that maps onto the same network domain as the destination address. */
        if ((interface_ptr -> nx_interface_valid) &&
 800aeb6:	693b      	ldr	r3, [r7, #16]
 800aeb8:	791b      	ldrb	r3, [r3, #4]
 800aeba:	2b00      	cmp	r3, #0
 800aebc:	d019      	beq.n	800aef2 <_nx_ip_route_find+0xde>
            (interface_ptr -> nx_interface_link_up) &&
 800aebe:	693b      	ldr	r3, [r7, #16]
 800aec0:	799b      	ldrb	r3, [r3, #6]
        if ((interface_ptr -> nx_interface_valid) &&
 800aec2:	2b00      	cmp	r3, #0
 800aec4:	d015      	beq.n	800aef2 <_nx_ip_route_find+0xde>
            (interface_ptr -> nx_interface_ip_address == destination_address) &&
 800aec6:	693b      	ldr	r3, [r7, #16]
 800aec8:	695b      	ldr	r3, [r3, #20]
            (interface_ptr -> nx_interface_link_up) &&
 800aeca:	68ba      	ldr	r2, [r7, #8]
 800aecc:	429a      	cmp	r2, r3
 800aece:	d110      	bne.n	800aef2 <_nx_ip_route_find+0xde>
            ((*ip_interface_ptr == NX_NULL) ||
 800aed0:	687b      	ldr	r3, [r7, #4]
 800aed2:	681b      	ldr	r3, [r3, #0]
            (interface_ptr -> nx_interface_ip_address == destination_address) &&
 800aed4:	2b00      	cmp	r3, #0
 800aed6:	d004      	beq.n	800aee2 <_nx_ip_route_find+0xce>
             (*ip_interface_ptr == interface_ptr)))
 800aed8:	687b      	ldr	r3, [r7, #4]
 800aeda:	681b      	ldr	r3, [r3, #0]
            ((*ip_interface_ptr == NX_NULL) ||
 800aedc:	693a      	ldr	r2, [r7, #16]
 800aede:	429a      	cmp	r2, r3
 800aee0:	d107      	bne.n	800aef2 <_nx_ip_route_find+0xde>
        {

            /* Yes, use the entry information for interface and next hop. */
            *ip_interface_ptr = interface_ptr;
 800aee2:	687b      	ldr	r3, [r7, #4]
 800aee4:	693a      	ldr	r2, [r7, #16]
 800aee6:	601a      	str	r2, [r3, #0]
            *next_hop_address = destination_address;
 800aee8:	683b      	ldr	r3, [r7, #0]
 800aeea:	68ba      	ldr	r2, [r7, #8]
 800aeec:	601a      	str	r2, [r3, #0]
            return(NX_SUCCESS);
 800aeee:	2300      	movs	r3, #0
 800aef0:	e0fd      	b.n	800b0ee <_nx_ip_route_find+0x2da>
    for (i = 0; i < NX_MAX_PHYSICAL_INTERFACES; i++)
 800aef2:	697b      	ldr	r3, [r7, #20]
 800aef4:	3301      	adds	r3, #1
 800aef6:	617b      	str	r3, [r7, #20]
 800aef8:	697b      	ldr	r3, [r7, #20]
 800aefa:	2b03      	cmp	r3, #3
 800aefc:	d9d2      	bls.n	800aea4 <_nx_ip_route_find+0x90>

#endif /* NX_ENABLE_IP_STATIC_ROUTING */

    /* Search through the interfaces associated with the IP instance,
       check if the entry exists. */
    for (i = 0; i < NX_MAX_IP_INTERFACES; i++)
 800aefe:	2300      	movs	r3, #0
 800af00:	617b      	str	r3, [r7, #20]
 800af02:	e035      	b.n	800af70 <_nx_ip_route_find+0x15c>
    {

        /* Use a local variable for convenience. */
        interface_ptr = &(ip_ptr -> nx_ip_interface[i]);
 800af04:	697b      	ldr	r3, [r7, #20]
 800af06:	224c      	movs	r2, #76	; 0x4c
 800af08:	fb02 f303 	mul.w	r3, r2, r3
 800af0c:	f503 63e4 	add.w	r3, r3, #1824	; 0x720
 800af10:	68fa      	ldr	r2, [r7, #12]
 800af12:	4413      	add	r3, r2
 800af14:	613b      	str	r3, [r7, #16]

        /* Check for a valid interface that maps onto the same network domain as the destination address. */
        if ((interface_ptr -> nx_interface_valid) &&
 800af16:	693b      	ldr	r3, [r7, #16]
 800af18:	791b      	ldrb	r3, [r3, #4]
 800af1a:	2b00      	cmp	r3, #0
 800af1c:	d025      	beq.n	800af6a <_nx_ip_route_find+0x156>
            (interface_ptr -> nx_interface_link_up) &&
 800af1e:	693b      	ldr	r3, [r7, #16]
 800af20:	799b      	ldrb	r3, [r3, #6]
        if ((interface_ptr -> nx_interface_valid) &&
 800af22:	2b00      	cmp	r3, #0
 800af24:	d021      	beq.n	800af6a <_nx_ip_route_find+0x156>
            ((interface_ptr -> nx_interface_ip_network_mask & destination_address) == interface_ptr -> nx_interface_ip_network))
 800af26:	693b      	ldr	r3, [r7, #16]
 800af28:	699a      	ldr	r2, [r3, #24]
 800af2a:	68bb      	ldr	r3, [r7, #8]
 800af2c:	401a      	ands	r2, r3
 800af2e:	693b      	ldr	r3, [r7, #16]
 800af30:	69db      	ldr	r3, [r3, #28]
            (interface_ptr -> nx_interface_link_up) &&
 800af32:	429a      	cmp	r2, r3
 800af34:	d119      	bne.n	800af6a <_nx_ip_route_find+0x156>
        {

            /* Yes, use the entry information for interface and next hop. */
            if (*ip_interface_ptr == NX_NULL)
 800af36:	687b      	ldr	r3, [r7, #4]
 800af38:	681b      	ldr	r3, [r3, #0]
 800af3a:	2b00      	cmp	r3, #0
 800af3c:	d103      	bne.n	800af46 <_nx_ip_route_find+0x132>
            {
                *ip_interface_ptr = interface_ptr;
 800af3e:	687b      	ldr	r3, [r7, #4]
 800af40:	693a      	ldr	r2, [r7, #16]
 800af42:	601a      	str	r2, [r3, #0]
 800af44:	e00b      	b.n	800af5e <_nx_ip_route_find+0x14a>
            }
            /* Match loopback interface.  */
            /* Suppress constant value, since "NX_MAX_IP_INTERFACES" can be redefined. */
#if (NX_MAX_IP_INTERFACES == (NX_MAX_PHYSICAL_INTERFACES + 1))
            else if (i == NX_MAX_PHYSICAL_INTERFACES)
 800af46:	697b      	ldr	r3, [r7, #20]
 800af48:	2b04      	cmp	r3, #4
 800af4a:	d103      	bne.n	800af54 <_nx_ip_route_find+0x140>
            {
                *ip_interface_ptr = interface_ptr;
 800af4c:	687b      	ldr	r3, [r7, #4]
 800af4e:	693a      	ldr	r2, [r7, #16]
 800af50:	601a      	str	r2, [r3, #0]
 800af52:	e004      	b.n	800af5e <_nx_ip_route_find+0x14a>
            }
#endif
            else if (*ip_interface_ptr != interface_ptr)
 800af54:	687b      	ldr	r3, [r7, #4]
 800af56:	681b      	ldr	r3, [r3, #0]
 800af58:	693a      	ldr	r2, [r7, #16]
 800af5a:	429a      	cmp	r2, r3
 800af5c:	d104      	bne.n	800af68 <_nx_ip_route_find+0x154>
            {
                continue;
            }

            *next_hop_address = destination_address;
 800af5e:	683b      	ldr	r3, [r7, #0]
 800af60:	68ba      	ldr	r2, [r7, #8]
 800af62:	601a      	str	r2, [r3, #0]

            return(NX_SUCCESS);
 800af64:	2300      	movs	r3, #0
 800af66:	e0c2      	b.n	800b0ee <_nx_ip_route_find+0x2da>
                continue;
 800af68:	bf00      	nop
    for (i = 0; i < NX_MAX_IP_INTERFACES; i++)
 800af6a:	697b      	ldr	r3, [r7, #20]
 800af6c:	3301      	adds	r3, #1
 800af6e:	617b      	str	r3, [r7, #20]
 800af70:	697b      	ldr	r3, [r7, #20]
 800af72:	2b04      	cmp	r3, #4
 800af74:	d9c6      	bls.n	800af04 <_nx_ip_route_find+0xf0>
        }
    }

    /* Search the interfaces for IPv4 Link-Local Address according to RFC3927, section2.6.  */
    /* Determine if destination addrss is link-local address(169.254/16 Hexadecimal:0xA9FE0000).  */
    if ((destination_address & 0xFFFF0000) == 0xA9FE0000)
 800af76:	68ba      	ldr	r2, [r7, #8]
 800af78:	4b60      	ldr	r3, [pc, #384]	; (800b0fc <_nx_ip_route_find+0x2e8>)
 800af7a:	4013      	ands	r3, r2
 800af7c:	4a60      	ldr	r2, [pc, #384]	; (800b100 <_nx_ip_route_find+0x2ec>)
 800af7e:	4293      	cmp	r3, r2
 800af80:	d140      	bne.n	800b004 <_nx_ip_route_find+0x1f0>
    {

        /* Yes, check if the interface is set.  */
        if (*ip_interface_ptr)
 800af82:	687b      	ldr	r3, [r7, #4]
 800af84:	681b      	ldr	r3, [r3, #0]
 800af86:	2b00      	cmp	r3, #0
 800af88:	d00e      	beq.n	800afa8 <_nx_ip_route_find+0x194>
        {

            /* Determine if the interface is valid.  */
            if (((*ip_interface_ptr) -> nx_interface_valid) &&
 800af8a:	687b      	ldr	r3, [r7, #4]
 800af8c:	681b      	ldr	r3, [r3, #0]
 800af8e:	791b      	ldrb	r3, [r3, #4]
 800af90:	2b00      	cmp	r3, #0
 800af92:	d037      	beq.n	800b004 <_nx_ip_route_find+0x1f0>
                ((*ip_interface_ptr) -> nx_interface_link_up))
 800af94:	687b      	ldr	r3, [r7, #4]
 800af96:	681b      	ldr	r3, [r3, #0]
 800af98:	799b      	ldrb	r3, [r3, #6]
            if (((*ip_interface_ptr) -> nx_interface_valid) &&
 800af9a:	2b00      	cmp	r3, #0
 800af9c:	d032      	beq.n	800b004 <_nx_ip_route_find+0x1f0>
            {

                /* Set the next hop address.  */
                *next_hop_address = destination_address;
 800af9e:	683b      	ldr	r3, [r7, #0]
 800afa0:	68ba      	ldr	r2, [r7, #8]
 800afa2:	601a      	str	r2, [r3, #0]

                return(NX_SUCCESS);
 800afa4:	2300      	movs	r3, #0
 800afa6:	e0a2      	b.n	800b0ee <_nx_ip_route_find+0x2da>
        }
        else
        {

            /* Search through the interfaces associated with the IP instance, set the inteface as first valid interface.  */
            for (i = 0; i < NX_MAX_IP_INTERFACES; i++)
 800afa8:	2300      	movs	r3, #0
 800afaa:	617b      	str	r3, [r7, #20]
 800afac:	e027      	b.n	800affe <_nx_ip_route_find+0x1ea>
            {

                /* Check for a valid interface that the address is link-local address.  */
                if ((ip_ptr -> nx_ip_interface[i].nx_interface_valid) &&
 800afae:	68fa      	ldr	r2, [r7, #12]
 800afb0:	697b      	ldr	r3, [r7, #20]
 800afb2:	214c      	movs	r1, #76	; 0x4c
 800afb4:	fb01 f303 	mul.w	r3, r1, r3
 800afb8:	4413      	add	r3, r2
 800afba:	f203 7324 	addw	r3, r3, #1828	; 0x724
 800afbe:	781b      	ldrb	r3, [r3, #0]
 800afc0:	2b00      	cmp	r3, #0
 800afc2:	d019      	beq.n	800aff8 <_nx_ip_route_find+0x1e4>
                    (ip_ptr -> nx_ip_interface[i].nx_interface_link_up))
 800afc4:	68fa      	ldr	r2, [r7, #12]
 800afc6:	697b      	ldr	r3, [r7, #20]
 800afc8:	214c      	movs	r1, #76	; 0x4c
 800afca:	fb01 f303 	mul.w	r3, r1, r3
 800afce:	4413      	add	r3, r2
 800afd0:	f203 7326 	addw	r3, r3, #1830	; 0x726
 800afd4:	781b      	ldrb	r3, [r3, #0]
                if ((ip_ptr -> nx_ip_interface[i].nx_interface_valid) &&
 800afd6:	2b00      	cmp	r3, #0
 800afd8:	d00e      	beq.n	800aff8 <_nx_ip_route_find+0x1e4>
                {

                    /* Yes, use the entry information for interface and next hop. */
                    *ip_interface_ptr = &(ip_ptr -> nx_ip_interface[i]);
 800afda:	697b      	ldr	r3, [r7, #20]
 800afdc:	224c      	movs	r2, #76	; 0x4c
 800afde:	fb02 f303 	mul.w	r3, r2, r3
 800afe2:	f503 63e4 	add.w	r3, r3, #1824	; 0x720
 800afe6:	68fa      	ldr	r2, [r7, #12]
 800afe8:	441a      	add	r2, r3
 800afea:	687b      	ldr	r3, [r7, #4]
 800afec:	601a      	str	r2, [r3, #0]
                    *next_hop_address = destination_address;
 800afee:	683b      	ldr	r3, [r7, #0]
 800aff0:	68ba      	ldr	r2, [r7, #8]
 800aff2:	601a      	str	r2, [r3, #0]

                    return(NX_SUCCESS);
 800aff4:	2300      	movs	r3, #0
 800aff6:	e07a      	b.n	800b0ee <_nx_ip_route_find+0x2da>
            for (i = 0; i < NX_MAX_IP_INTERFACES; i++)
 800aff8:	697b      	ldr	r3, [r7, #20]
 800affa:	3301      	adds	r3, #1
 800affc:	617b      	str	r3, [r7, #20]
 800affe:	697b      	ldr	r3, [r7, #20]
 800b000:	2b04      	cmp	r3, #4
 800b002:	d9d4      	bls.n	800afae <_nx_ip_route_find+0x19a>
            }
        }
    }

    /* Does the IP instance have a gateway? */
    if ((ip_ptr -> nx_ip_gateway_address) &&
 800b004:	68fb      	ldr	r3, [r7, #12]
 800b006:	689b      	ldr	r3, [r3, #8]
 800b008:	2b00      	cmp	r3, #0
 800b00a:	d02b      	beq.n	800b064 <_nx_ip_route_find+0x250>
        (ip_ptr -> nx_ip_gateway_interface) &&
 800b00c:	68fb      	ldr	r3, [r7, #12]
 800b00e:	68db      	ldr	r3, [r3, #12]
    if ((ip_ptr -> nx_ip_gateway_address) &&
 800b010:	2b00      	cmp	r3, #0
 800b012:	d027      	beq.n	800b064 <_nx_ip_route_find+0x250>
        (ip_ptr -> nx_ip_gateway_interface -> nx_interface_link_up))
 800b014:	68fb      	ldr	r3, [r7, #12]
 800b016:	68db      	ldr	r3, [r3, #12]
 800b018:	799b      	ldrb	r3, [r3, #6]
        (ip_ptr -> nx_ip_gateway_interface) &&
 800b01a:	2b00      	cmp	r3, #0
 800b01c:	d022      	beq.n	800b064 <_nx_ip_route_find+0x250>
    {

        /* Get the interface. */
        interface_ptr = ip_ptr -> nx_ip_gateway_interface;
 800b01e:	68fb      	ldr	r3, [r7, #12]
 800b020:	68db      	ldr	r3, [r3, #12]
 800b022:	613b      	str	r3, [r7, #16]

        /* Yes, is gateway address still reachable? */
        if (interface_ptr -> nx_interface_ip_network !=
 800b024:	693b      	ldr	r3, [r7, #16]
 800b026:	69da      	ldr	r2, [r3, #28]
            (ip_ptr -> nx_ip_gateway_address &
 800b028:	68fb      	ldr	r3, [r7, #12]
 800b02a:	6899      	ldr	r1, [r3, #8]
             interface_ptr -> nx_interface_ip_network_mask))
 800b02c:	693b      	ldr	r3, [r7, #16]
 800b02e:	699b      	ldr	r3, [r3, #24]
            (ip_ptr -> nx_ip_gateway_address &
 800b030:	400b      	ands	r3, r1
        if (interface_ptr -> nx_interface_ip_network !=
 800b032:	429a      	cmp	r2, r3
 800b034:	d001      	beq.n	800b03a <_nx_ip_route_find+0x226>
        {
            return(NX_IP_ADDRESS_ERROR);
 800b036:	2321      	movs	r3, #33	; 0x21
 800b038:	e059      	b.n	800b0ee <_nx_ip_route_find+0x2da>
        }

        /* Use the gateway as default. */
        if (*ip_interface_ptr == NX_NULL)
 800b03a:	687b      	ldr	r3, [r7, #4]
 800b03c:	681b      	ldr	r3, [r3, #0]
 800b03e:	2b00      	cmp	r3, #0
 800b040:	d103      	bne.n	800b04a <_nx_ip_route_find+0x236>
        {
            *ip_interface_ptr = interface_ptr;
 800b042:	687b      	ldr	r3, [r7, #4]
 800b044:	693a      	ldr	r2, [r7, #16]
 800b046:	601a      	str	r2, [r3, #0]
 800b048:	e006      	b.n	800b058 <_nx_ip_route_find+0x244>
        }
        else if (*ip_interface_ptr != interface_ptr)
 800b04a:	687b      	ldr	r3, [r7, #4]
 800b04c:	681b      	ldr	r3, [r3, #0]
 800b04e:	693a      	ldr	r2, [r7, #16]
 800b050:	429a      	cmp	r2, r3
 800b052:	d001      	beq.n	800b058 <_nx_ip_route_find+0x244>
        {
            return(NX_IP_ADDRESS_ERROR);
 800b054:	2321      	movs	r3, #33	; 0x21
 800b056:	e04a      	b.n	800b0ee <_nx_ip_route_find+0x2da>
        }

        *next_hop_address = ip_ptr -> nx_ip_gateway_address;
 800b058:	68fb      	ldr	r3, [r7, #12]
 800b05a:	689a      	ldr	r2, [r3, #8]
 800b05c:	683b      	ldr	r3, [r7, #0]
 800b05e:	601a      	str	r2, [r3, #0]

        return(NX_SUCCESS);
 800b060:	2300      	movs	r3, #0
 800b062:	e044      	b.n	800b0ee <_nx_ip_route_find+0x2da>
    }

    /* Determine if source addrss is link-local address(169.254/16 Hexadecimal:0xA9FE0000).  */
    if (*ip_interface_ptr)
 800b064:	687b      	ldr	r3, [r7, #4]
 800b066:	681b      	ldr	r3, [r3, #0]
 800b068:	2b00      	cmp	r3, #0
 800b06a:	d016      	beq.n	800b09a <_nx_ip_route_find+0x286>
    {

        /* Determine if the interface is valid and the address of interface is link-local address.  */
        if (((*ip_interface_ptr) -> nx_interface_valid) &&
 800b06c:	687b      	ldr	r3, [r7, #4]
 800b06e:	681b      	ldr	r3, [r3, #0]
 800b070:	791b      	ldrb	r3, [r3, #4]
 800b072:	2b00      	cmp	r3, #0
 800b074:	d03a      	beq.n	800b0ec <_nx_ip_route_find+0x2d8>
            ((*ip_interface_ptr) -> nx_interface_link_up) &&
 800b076:	687b      	ldr	r3, [r7, #4]
 800b078:	681b      	ldr	r3, [r3, #0]
 800b07a:	799b      	ldrb	r3, [r3, #6]
        if (((*ip_interface_ptr) -> nx_interface_valid) &&
 800b07c:	2b00      	cmp	r3, #0
 800b07e:	d035      	beq.n	800b0ec <_nx_ip_route_find+0x2d8>
            (((*ip_interface_ptr) -> nx_interface_ip_address & 0xFFFF0000) == 0xA9FE0000))
 800b080:	687b      	ldr	r3, [r7, #4]
 800b082:	681b      	ldr	r3, [r3, #0]
 800b084:	695a      	ldr	r2, [r3, #20]
 800b086:	4b1d      	ldr	r3, [pc, #116]	; (800b0fc <_nx_ip_route_find+0x2e8>)
 800b088:	4013      	ands	r3, r2
            ((*ip_interface_ptr) -> nx_interface_link_up) &&
 800b08a:	4a1d      	ldr	r2, [pc, #116]	; (800b100 <_nx_ip_route_find+0x2ec>)
 800b08c:	4293      	cmp	r3, r2
 800b08e:	d12d      	bne.n	800b0ec <_nx_ip_route_find+0x2d8>
        {

            /* Set the next hop address.  */
            *next_hop_address = destination_address;
 800b090:	683b      	ldr	r3, [r7, #0]
 800b092:	68ba      	ldr	r2, [r7, #8]
 800b094:	601a      	str	r2, [r3, #0]

            return(NX_SUCCESS);
 800b096:	2300      	movs	r3, #0
 800b098:	e029      	b.n	800b0ee <_nx_ip_route_find+0x2da>
    else
    {

        /* Search through the interfaces associated with the IP instance,
           check if interface is valid and the address of interface is link-local address. */
        for (i = 0; i < NX_MAX_IP_INTERFACES; i++)
 800b09a:	2300      	movs	r3, #0
 800b09c:	617b      	str	r3, [r7, #20]
 800b09e:	e022      	b.n	800b0e6 <_nx_ip_route_find+0x2d2>
        {

            /* Use a local variable for convenience. */
            interface_ptr = &(ip_ptr -> nx_ip_interface[i]);
 800b0a0:	697b      	ldr	r3, [r7, #20]
 800b0a2:	224c      	movs	r2, #76	; 0x4c
 800b0a4:	fb02 f303 	mul.w	r3, r2, r3
 800b0a8:	f503 63e4 	add.w	r3, r3, #1824	; 0x720
 800b0ac:	68fa      	ldr	r2, [r7, #12]
 800b0ae:	4413      	add	r3, r2
 800b0b0:	613b      	str	r3, [r7, #16]

            /* Check for a valid interface that the address is link-local address.  */
            if ((interface_ptr -> nx_interface_valid) &&
 800b0b2:	693b      	ldr	r3, [r7, #16]
 800b0b4:	791b      	ldrb	r3, [r3, #4]
 800b0b6:	2b00      	cmp	r3, #0
 800b0b8:	d012      	beq.n	800b0e0 <_nx_ip_route_find+0x2cc>
                (interface_ptr -> nx_interface_link_up) &&
 800b0ba:	693b      	ldr	r3, [r7, #16]
 800b0bc:	799b      	ldrb	r3, [r3, #6]
            if ((interface_ptr -> nx_interface_valid) &&
 800b0be:	2b00      	cmp	r3, #0
 800b0c0:	d00e      	beq.n	800b0e0 <_nx_ip_route_find+0x2cc>
                ((interface_ptr -> nx_interface_ip_address & 0xFFFF0000) == 0xA9FE0000))
 800b0c2:	693b      	ldr	r3, [r7, #16]
 800b0c4:	695a      	ldr	r2, [r3, #20]
 800b0c6:	4b0d      	ldr	r3, [pc, #52]	; (800b0fc <_nx_ip_route_find+0x2e8>)
 800b0c8:	4013      	ands	r3, r2
                (interface_ptr -> nx_interface_link_up) &&
 800b0ca:	4a0d      	ldr	r2, [pc, #52]	; (800b100 <_nx_ip_route_find+0x2ec>)
 800b0cc:	4293      	cmp	r3, r2
 800b0ce:	d107      	bne.n	800b0e0 <_nx_ip_route_find+0x2cc>
            {

                /* Yes, use the entry information for interface and next hop. */
                *ip_interface_ptr = interface_ptr;
 800b0d0:	687b      	ldr	r3, [r7, #4]
 800b0d2:	693a      	ldr	r2, [r7, #16]
 800b0d4:	601a      	str	r2, [r3, #0]
                *next_hop_address = destination_address;
 800b0d6:	683b      	ldr	r3, [r7, #0]
 800b0d8:	68ba      	ldr	r2, [r7, #8]
 800b0da:	601a      	str	r2, [r3, #0]

                return(NX_SUCCESS);
 800b0dc:	2300      	movs	r3, #0
 800b0de:	e006      	b.n	800b0ee <_nx_ip_route_find+0x2da>
        for (i = 0; i < NX_MAX_IP_INTERFACES; i++)
 800b0e0:	697b      	ldr	r3, [r7, #20]
 800b0e2:	3301      	adds	r3, #1
 800b0e4:	617b      	str	r3, [r7, #20]
 800b0e6:	697b      	ldr	r3, [r7, #20]
 800b0e8:	2b04      	cmp	r3, #4
 800b0ea:	d9d9      	bls.n	800b0a0 <_nx_ip_route_find+0x28c>
        }
    }

    /* Cannot find a proper way to transmit this packet.
       Return the error status. */
    return(NX_IP_ADDRESS_ERROR);
 800b0ec:	2321      	movs	r3, #33	; 0x21
}
 800b0ee:	4618      	mov	r0, r3
 800b0f0:	371c      	adds	r7, #28
 800b0f2:	46bd      	mov	sp, r7
 800b0f4:	f85d 7b04 	ldr.w	r7, [sp], #4
 800b0f8:	4770      	bx	lr
 800b0fa:	bf00      	nop
 800b0fc:	ffff0000 	.word	0xffff0000
 800b100:	a9fe0000 	.word	0xa9fe0000

0800b104 <_nx_ip_thread_entry>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
VOID  _nx_ip_thread_entry(ULONG ip_ptr_value)
{
 800b104:	b580      	push	{r7, lr}
 800b106:	b096      	sub	sp, #88	; 0x58
 800b108:	af02      	add	r7, sp, #8
 800b10a:	6078      	str	r0, [r7, #4]
NXD_IPV6_ADDRESS *interface_ipv6_address;
#endif /* FEATURE_NX_IPV6 */


    /* Setup IP pointer.  */
    NX_THREAD_EXTENSION_PTR_GET(ip_ptr, NX_IP, ip_ptr_value)
 800b10c:	687b      	ldr	r3, [r7, #4]
 800b10e:	647b      	str	r3, [r7, #68]	; 0x44

    /* Obtain the IP internal mutex before calling the driver.  */
    tx_mutex_get(&(ip_ptr -> nx_ip_protection), TX_WAIT_FOREVER);
 800b110:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 800b112:	f503 739e 	add.w	r3, r3, #316	; 0x13c
 800b116:	f04f 31ff 	mov.w	r1, #4294967295
 800b11a:	4618      	mov	r0, r3
 800b11c:	f007 fe2a 	bl	8012d74 <_tx_mutex_get>

    /* Set the IP initialization done flag to true.  */
    ip_ptr -> nx_ip_initialize_done =  NX_TRUE;
 800b120:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 800b122:	2201      	movs	r2, #1
 800b124:	f8c3 2170 	str.w	r2, [r3, #368]	; 0x170

    /* Loop through all physical interfaces to initialize and enable the hardware. */
    for (i = 0; i < NX_MAX_PHYSICAL_INTERFACES; i++)
 800b128:	2300      	movs	r3, #0
 800b12a:	64fb      	str	r3, [r7, #76]	; 0x4c
 800b12c:	e05e      	b.n	800b1ec <_nx_ip_thread_entry+0xe8>
    {

        /* Is this a valid interface with a link driver associated with it? */
        if ((ip_ptr -> nx_ip_interface[i].nx_interface_valid) && (ip_ptr -> nx_ip_interface[i].nx_interface_link_driver_entry))
 800b12e:	6c7a      	ldr	r2, [r7, #68]	; 0x44
 800b130:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800b132:	214c      	movs	r1, #76	; 0x4c
 800b134:	fb01 f303 	mul.w	r3, r1, r3
 800b138:	4413      	add	r3, r2
 800b13a:	f203 7324 	addw	r3, r3, #1828	; 0x724
 800b13e:	781b      	ldrb	r3, [r3, #0]
 800b140:	2b00      	cmp	r3, #0
 800b142:	d050      	beq.n	800b1e6 <_nx_ip_thread_entry+0xe2>
 800b144:	6c7a      	ldr	r2, [r7, #68]	; 0x44
 800b146:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800b148:	214c      	movs	r1, #76	; 0x4c
 800b14a:	fb01 f303 	mul.w	r3, r1, r3
 800b14e:	4413      	add	r3, r2
 800b150:	f203 735c 	addw	r3, r3, #1884	; 0x75c
 800b154:	681b      	ldr	r3, [r3, #0]
 800b156:	2b00      	cmp	r3, #0
 800b158:	d045      	beq.n	800b1e6 <_nx_ip_thread_entry+0xe2>
            /* Clear capability flag first.  */
            ip_ptr -> nx_ip_interface[i].nx_interface_capability_flag = 0;
#endif /* NX_ENABLE_INTERFACE_CAPABILITY */


            ip_ptr -> nx_ip_interface[i].nx_interface_link_up = NX_TRUE;
 800b15a:	6c7a      	ldr	r2, [r7, #68]	; 0x44
 800b15c:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800b15e:	214c      	movs	r1, #76	; 0x4c
 800b160:	fb01 f303 	mul.w	r3, r1, r3
 800b164:	4413      	add	r3, r2
 800b166:	f203 7326 	addw	r3, r3, #1830	; 0x726
 800b16a:	2201      	movs	r2, #1
 800b16c:	701a      	strb	r2, [r3, #0]

            /* Yes; attach the interface to the device. */
            driver_request.nx_ip_driver_ptr        =  ip_ptr;
 800b16e:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 800b170:	62bb      	str	r3, [r7, #40]	; 0x28
            driver_request.nx_ip_driver_command    =  NX_LINK_INTERFACE_ATTACH;
 800b172:	2313      	movs	r3, #19
 800b174:	613b      	str	r3, [r7, #16]
            driver_request.nx_ip_driver_interface  = &(ip_ptr -> nx_ip_interface[i]);
 800b176:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800b178:	224c      	movs	r2, #76	; 0x4c
 800b17a:	fb02 f303 	mul.w	r3, r2, r3
 800b17e:	f503 63e4 	add.w	r3, r3, #1824	; 0x720
 800b182:	6c7a      	ldr	r2, [r7, #68]	; 0x44
 800b184:	4413      	add	r3, r2
 800b186:	62fb      	str	r3, [r7, #44]	; 0x2c
            (ip_ptr -> nx_ip_interface[i].nx_interface_link_driver_entry)(&driver_request);
 800b188:	6c7a      	ldr	r2, [r7, #68]	; 0x44
 800b18a:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800b18c:	214c      	movs	r1, #76	; 0x4c
 800b18e:	fb01 f303 	mul.w	r3, r1, r3
 800b192:	4413      	add	r3, r2
 800b194:	f203 735c 	addw	r3, r3, #1884	; 0x75c
 800b198:	681b      	ldr	r3, [r3, #0]
 800b19a:	f107 0210 	add.w	r2, r7, #16
 800b19e:	4610      	mov	r0, r2
 800b1a0:	4798      	blx	r3
            /* Call the link driver to initialize the hardware. Among other
               responsibilities, the driver is required to provide the
               Maximum Transfer Unit (MTU) for the physical layer. The MTU
               should represent the actual physical layer transfer size
               less the physical layer headers and trailers.  */
            driver_request.nx_ip_driver_ptr =      ip_ptr;
 800b1a2:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 800b1a4:	62bb      	str	r3, [r7, #40]	; 0x28
            driver_request.nx_ip_driver_command =  NX_LINK_INITIALIZE;
 800b1a6:	2301      	movs	r3, #1
 800b1a8:	613b      	str	r3, [r7, #16]
               When an IP instance is created, the first interface (nx_ip_interface[0]) is configured using parameters
               provided in the IP create call.

               When IP thread runs, it invokes the first interface link driver for link initialization.
             */
            (ip_ptr -> nx_ip_interface[i].nx_interface_link_driver_entry)(&driver_request);
 800b1aa:	6c7a      	ldr	r2, [r7, #68]	; 0x44
 800b1ac:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800b1ae:	214c      	movs	r1, #76	; 0x4c
 800b1b0:	fb01 f303 	mul.w	r3, r1, r3
 800b1b4:	4413      	add	r3, r2
 800b1b6:	f203 735c 	addw	r3, r3, #1884	; 0x75c
 800b1ba:	681b      	ldr	r3, [r3, #0]
 800b1bc:	f107 0210 	add.w	r2, r7, #16
 800b1c0:	4610      	mov	r0, r2
 800b1c2:	4798      	blx	r3

            /* Call the link driver again to enable the interface.  */
            driver_request.nx_ip_driver_ptr =      ip_ptr;
 800b1c4:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 800b1c6:	62bb      	str	r3, [r7, #40]	; 0x28
            driver_request.nx_ip_driver_command =  NX_LINK_ENABLE;
 800b1c8:	2302      	movs	r3, #2
 800b1ca:	613b      	str	r3, [r7, #16]

            /* If trace is enabled, insert this event into the trace buffer.  */
            NX_TRACE_IN_LINE_INSERT(NX_TRACE_INTERNAL_IO_DRIVER_LINK_ENABLE, ip_ptr, 0, 0, 0, NX_TRACE_INTERNAL_EVENTS, 0, 0);

            (ip_ptr -> nx_ip_interface[i].nx_interface_link_driver_entry)(&driver_request);
 800b1cc:	6c7a      	ldr	r2, [r7, #68]	; 0x44
 800b1ce:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800b1d0:	214c      	movs	r1, #76	; 0x4c
 800b1d2:	fb01 f303 	mul.w	r3, r1, r3
 800b1d6:	4413      	add	r3, r2
 800b1d8:	f203 735c 	addw	r3, r3, #1884	; 0x75c
 800b1dc:	681b      	ldr	r3, [r3, #0]
 800b1de:	f107 0210 	add.w	r2, r7, #16
 800b1e2:	4610      	mov	r0, r2
 800b1e4:	4798      	blx	r3
    for (i = 0; i < NX_MAX_PHYSICAL_INTERFACES; i++)
 800b1e6:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800b1e8:	3301      	adds	r3, #1
 800b1ea:	64fb      	str	r3, [r7, #76]	; 0x4c
 800b1ec:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800b1ee:	2b03      	cmp	r3, #3
 800b1f0:	d99d      	bls.n	800b12e <_nx_ip_thread_entry+0x2a>
    /* Loop to process events for this IP instance.  */
    for (;;)
    {

        /* Release the IP internal mutex.  */
        tx_mutex_put(&(ip_ptr -> nx_ip_protection));
 800b1f2:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 800b1f4:	f503 739e 	add.w	r3, r3, #316	; 0x13c
 800b1f8:	4618      	mov	r0, r3
 800b1fa:	f008 f833 	bl	8013264 <_tx_mutex_put>

        /* Pickup IP event flags.  */
        tx_event_flags_get(&(ip_ptr -> nx_ip_events), NX_IP_ALL_EVENTS, TX_OR_CLEAR, &ip_events, TX_WAIT_FOREVER);
 800b1fe:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 800b200:	f503 7013 	add.w	r0, r3, #588	; 0x24c
 800b204:	f107 030c 	add.w	r3, r7, #12
 800b208:	f04f 32ff 	mov.w	r2, #4294967295
 800b20c:	9200      	str	r2, [sp, #0]
 800b20e:	2201      	movs	r2, #1
 800b210:	f04f 31ff 	mov.w	r1, #4294967295
 800b214:	f007 f888 	bl	8012328 <_tx_event_flags_get>

        /* Obtain the IP internal mutex before processing the IP event.  */
        tx_mutex_get(&(ip_ptr -> nx_ip_protection), TX_WAIT_FOREVER);
 800b218:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 800b21a:	f503 739e 	add.w	r3, r3, #316	; 0x13c
 800b21e:	f04f 31ff 	mov.w	r1, #4294967295
 800b222:	4618      	mov	r0, r3
 800b224:	f007 fda6 	bl	8012d74 <_tx_mutex_get>
        }
#endif

        /* Check for an IP receive packet event.  */
        /*lint -e{644} suppress variable might not be initialized, since "ip_events" was initialized by tx_event_flags_get. */
        if (ip_events & NX_IP_RECEIVE_EVENT)
 800b228:	68fb      	ldr	r3, [r7, #12]
 800b22a:	f003 0308 	and.w	r3, r3, #8
 800b22e:	2b00      	cmp	r3, #0
 800b230:	d031      	beq.n	800b296 <_nx_ip_thread_entry+0x192>
        {

            /* Loop to process all deferred packet requests.  */
            while (ip_ptr -> nx_ip_deferred_received_packet_head)
 800b232:	e023      	b.n	800b27c <_nx_ip_thread_entry+0x178>
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 800b234:	f3ef 8310 	mrs	r3, PRIMASK
 800b238:	63bb      	str	r3, [r7, #56]	; 0x38
    return(posture);
 800b23a:	6bbb      	ldr	r3, [r7, #56]	; 0x38
    int_posture = __get_interrupt_posture();
 800b23c:	637b      	str	r3, [r7, #52]	; 0x34
    __asm__ volatile ("CPSID i" : : : "memory");
 800b23e:	b672      	cpsid	i
    return(int_posture);
 800b240:	6b7b      	ldr	r3, [r7, #52]	; 0x34
            {

                /* Remove the first packet and process it!  */

                /* Disable interrupts.  */
                TX_DISABLE
 800b242:	643b      	str	r3, [r7, #64]	; 0x40

                /* Pickup the first packet.  */
                packet_ptr =  ip_ptr -> nx_ip_deferred_received_packet_head;
 800b244:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 800b246:	f8d3 3174 	ldr.w	r3, [r3, #372]	; 0x174
 800b24a:	63fb      	str	r3, [r7, #60]	; 0x3c

                /* Move the head pointer to the next packet.  */
                ip_ptr -> nx_ip_deferred_received_packet_head =  packet_ptr -> nx_packet_queue_next;
 800b24c:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800b24e:	69da      	ldr	r2, [r3, #28]
 800b250:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 800b252:	f8c3 2174 	str.w	r2, [r3, #372]	; 0x174

                /* Check for end of deferred processing queue.  */
                if (ip_ptr -> nx_ip_deferred_received_packet_head == NX_NULL)
 800b256:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 800b258:	f8d3 3174 	ldr.w	r3, [r3, #372]	; 0x174
 800b25c:	2b00      	cmp	r3, #0
 800b25e:	d103      	bne.n	800b268 <_nx_ip_thread_entry+0x164>
                {

                    /* Yes, the queue is empty.  Set the tail pointer to NULL.  */
                    ip_ptr -> nx_ip_deferred_received_packet_tail =  NX_NULL;
 800b260:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 800b262:	2200      	movs	r2, #0
 800b264:	f8c3 2178 	str.w	r2, [r3, #376]	; 0x178
 800b268:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 800b26a:	633b      	str	r3, [r7, #48]	; 0x30
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 800b26c:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800b26e:	f383 8810 	msr	PRIMASK, r3
}
 800b272:	bf00      	nop

                /* Restore interrupts.  */
                TX_RESTORE

                /* Call the actual IP packet receive function.  */
                _nx_ip_packet_receive(ip_ptr, packet_ptr);
 800b274:	6bf9      	ldr	r1, [r7, #60]	; 0x3c
 800b276:	6c78      	ldr	r0, [r7, #68]	; 0x44
 800b278:	f7ff fd18 	bl	800acac <_nx_ip_packet_receive>
            while (ip_ptr -> nx_ip_deferred_received_packet_head)
 800b27c:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 800b27e:	f8d3 3174 	ldr.w	r3, [r3, #372]	; 0x174
 800b282:	2b00      	cmp	r3, #0
 800b284:	d1d6      	bne.n	800b234 <_nx_ip_thread_entry+0x130>
            }

            /* Determine if there is anything else to do in the loop.  */
            ip_events =  ip_events & ~(NX_IP_RECEIVE_EVENT);
 800b286:	68fb      	ldr	r3, [r7, #12]
 800b288:	f023 0308 	bic.w	r3, r3, #8
 800b28c:	60fb      	str	r3, [r7, #12]
            if (!ip_events)
 800b28e:	68fb      	ldr	r3, [r7, #12]
 800b290:	2b00      	cmp	r3, #0
 800b292:	f000 812b 	beq.w	800b4ec <_nx_ip_thread_entry+0x3e8>
                continue;
            }
        }

        /* Check for a TCP message event.  */
        if (ip_events & NX_IP_TCP_EVENT)
 800b296:	68fb      	ldr	r3, [r7, #12]
 800b298:	f003 0380 	and.w	r3, r3, #128	; 0x80
 800b29c:	2b00      	cmp	r3, #0
 800b29e:	d00c      	beq.n	800b2ba <_nx_ip_thread_entry+0x1b6>
        {

            /* Process the TCP packet queue.  */
            (ip_ptr -> nx_ip_tcp_queue_process)(ip_ptr);
 800b2a0:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 800b2a2:	f8d3 34a0 	ldr.w	r3, [r3, #1184]	; 0x4a0
 800b2a6:	6c78      	ldr	r0, [r7, #68]	; 0x44
 800b2a8:	4798      	blx	r3

            /* Determine if there is anything else to do in the loop.  */
            ip_events =  ip_events & ~(NX_IP_TCP_EVENT);
 800b2aa:	68fb      	ldr	r3, [r7, #12]
 800b2ac:	f023 0380 	bic.w	r3, r3, #128	; 0x80
 800b2b0:	60fb      	str	r3, [r7, #12]
            if (!ip_events)
 800b2b2:	68fb      	ldr	r3, [r7, #12]
 800b2b4:	2b00      	cmp	r3, #0
 800b2b6:	f000 811b 	beq.w	800b4f0 <_nx_ip_thread_entry+0x3ec>
                continue;
            }
        }

        /* Check for a fast TCP event.  */
        if (ip_events & NX_IP_FAST_EVENT)
 800b2ba:	68fb      	ldr	r3, [r7, #12]
 800b2bc:	f403 7380 	and.w	r3, r3, #256	; 0x100
 800b2c0:	2b00      	cmp	r3, #0
 800b2c2:	d011      	beq.n	800b2e8 <_nx_ip_thread_entry+0x1e4>
            }

#endif /* FEATURE_NX_IPV6 */

            /* Process the fast TCP processing.  */
            if (ip_ptr -> nx_ip_tcp_fast_periodic_processing)
 800b2c4:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 800b2c6:	f8d3 349c 	ldr.w	r3, [r3, #1180]	; 0x49c
 800b2ca:	2b00      	cmp	r3, #0
 800b2cc:	d004      	beq.n	800b2d8 <_nx_ip_thread_entry+0x1d4>
            {
                (ip_ptr -> nx_ip_tcp_fast_periodic_processing)(ip_ptr);
 800b2ce:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 800b2d0:	f8d3 349c 	ldr.w	r3, [r3, #1180]	; 0x49c
 800b2d4:	6c78      	ldr	r0, [r7, #68]	; 0x44
 800b2d6:	4798      	blx	r3
            }

            /* Determine if there is anything else to do in the loop.  */
            ip_events =  ip_events & ~(NX_IP_FAST_EVENT);
 800b2d8:	68fb      	ldr	r3, [r7, #12]
 800b2da:	f423 7380 	bic.w	r3, r3, #256	; 0x100
 800b2de:	60fb      	str	r3, [r7, #12]
            if (!ip_events)
 800b2e0:	68fb      	ldr	r3, [r7, #12]
 800b2e2:	2b00      	cmp	r3, #0
 800b2e4:	f000 8106 	beq.w	800b4f4 <_nx_ip_thread_entry+0x3f0>
                continue;
            }
        }

        /* Check for a periodic events.  */
        if (ip_events & NX_IP_PERIODIC_EVENT)
 800b2e8:	68fb      	ldr	r3, [r7, #12]
 800b2ea:	f003 0301 	and.w	r3, r3, #1
 800b2ee:	2b00      	cmp	r3, #0
 800b2f0:	d039      	beq.n	800b366 <_nx_ip_thread_entry+0x262>
        {

#ifndef NX_DISABLE_IPV4
            /* Process the ARP periodic update, if ARP has been enabled.  */
            if (ip_ptr -> nx_ip_arp_periodic_update)
 800b2f2:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 800b2f4:	f8d3 36e8 	ldr.w	r3, [r3, #1768]	; 0x6e8
 800b2f8:	2b00      	cmp	r3, #0
 800b2fa:	d004      	beq.n	800b306 <_nx_ip_thread_entry+0x202>
            {
                (ip_ptr -> nx_ip_arp_periodic_update)(ip_ptr);
 800b2fc:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 800b2fe:	f8d3 36e8 	ldr.w	r3, [r3, #1768]	; 0x6e8
 800b302:	6c78      	ldr	r0, [r7, #68]	; 0x44
 800b304:	4798      	blx	r3
            }

            /* Process the RARP periodic update, if RARP has been enabled.  */
            if (ip_ptr -> nx_ip_rarp_periodic_update)
 800b306:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 800b308:	f8d3 3700 	ldr.w	r3, [r3, #1792]	; 0x700
 800b30c:	2b00      	cmp	r3, #0
 800b30e:	d004      	beq.n	800b31a <_nx_ip_thread_entry+0x216>
            {
                (ip_ptr -> nx_ip_rarp_periodic_update)(ip_ptr);
 800b310:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 800b312:	f8d3 3700 	ldr.w	r3, [r3, #1792]	; 0x700
 800b316:	6c78      	ldr	r0, [r7, #68]	; 0x44
 800b318:	4798      	blx	r3
            }

            /* Process IGMP periodic events, if IGMP has been enabled.  */
            if (ip_ptr -> nx_ip_igmp_periodic_processing)
 800b31a:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 800b31c:	f8d3 3358 	ldr.w	r3, [r3, #856]	; 0x358
 800b320:	2b00      	cmp	r3, #0
 800b322:	d004      	beq.n	800b32e <_nx_ip_thread_entry+0x22a>
            {
                (ip_ptr -> nx_ip_igmp_periodic_processing)(ip_ptr);
 800b324:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 800b326:	f8d3 3358 	ldr.w	r3, [r3, #856]	; 0x358
 800b32a:	6c78      	ldr	r0, [r7, #68]	; 0x44
 800b32c:	4798      	blx	r3
            }
#endif /* !NX_DISABLE_IPV4  */

            /* Process IP fragmentation timeouts, if IP fragmenting has been
               enabled.  */
            if (ip_ptr -> nx_ip_fragment_timeout_check)
 800b32e:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 800b330:	f8d3 32a4 	ldr.w	r3, [r3, #676]	; 0x2a4
 800b334:	2b00      	cmp	r3, #0
 800b336:	d004      	beq.n	800b342 <_nx_ip_thread_entry+0x23e>
            {
                (ip_ptr -> nx_ip_fragment_timeout_check)(ip_ptr);
 800b338:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 800b33a:	f8d3 32a4 	ldr.w	r3, [r3, #676]	; 0x2a4
 800b33e:	6c78      	ldr	r0, [r7, #68]	; 0x44
 800b340:	4798      	blx	r3
            }

            /* Process TCP periodic events, if TCP has been enabled.  */
            if (ip_ptr -> nx_ip_tcp_periodic_processing)
 800b342:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 800b344:	f8d3 3498 	ldr.w	r3, [r3, #1176]	; 0x498
 800b348:	2b00      	cmp	r3, #0
 800b34a:	d004      	beq.n	800b356 <_nx_ip_thread_entry+0x252>
            {
                (ip_ptr -> nx_ip_tcp_periodic_processing)(ip_ptr);
 800b34c:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 800b34e:	f8d3 3498 	ldr.w	r3, [r3, #1176]	; 0x498
 800b352:	6c78      	ldr	r0, [r7, #68]	; 0x44
 800b354:	4798      	blx	r3
            }
#endif /* NX_ENABLE_IPV6_PATH_MTU_DISCOVERY */

#endif /* FEATURE_NX_IPV6 */
            /* Determine if there is anything else to do in the loop.  */
            ip_events =  ip_events & ~(NX_IP_PERIODIC_EVENT);
 800b356:	68fb      	ldr	r3, [r7, #12]
 800b358:	f023 0301 	bic.w	r3, r3, #1
 800b35c:	60fb      	str	r3, [r7, #12]
            if (!ip_events)
 800b35e:	68fb      	ldr	r3, [r7, #12]
 800b360:	2b00      	cmp	r3, #0
 800b362:	f000 80c9 	beq.w	800b4f8 <_nx_ip_thread_entry+0x3f4>
        }
#endif /* NX_IPSEC_ENABLE */

#ifndef NX_DISABLE_IPV4
        /* Check for an ARP receive packet event.  */
        if ((ip_events & NX_IP_ARP_REC_EVENT) && (ip_ptr -> nx_ip_arp_queue_process))
 800b366:	68fb      	ldr	r3, [r7, #12]
 800b368:	f003 0310 	and.w	r3, r3, #16
 800b36c:	2b00      	cmp	r3, #0
 800b36e:	d009      	beq.n	800b384 <_nx_ip_thread_entry+0x280>
 800b370:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 800b372:	f8d3 36ec 	ldr.w	r3, [r3, #1772]	; 0x6ec
 800b376:	2b00      	cmp	r3, #0
 800b378:	d004      	beq.n	800b384 <_nx_ip_thread_entry+0x280>
        {

            /* Process the ARP queue.  */
            (ip_ptr -> nx_ip_arp_queue_process)(ip_ptr);
 800b37a:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 800b37c:	f8d3 36ec 	ldr.w	r3, [r3, #1772]	; 0x6ec
 800b380:	6c78      	ldr	r0, [r7, #68]	; 0x44
 800b382:	4798      	blx	r3
        }

        /* Check for an RARP receive packet event.  */
        if ((ip_events & NX_IP_RARP_REC_EVENT) && (ip_ptr -> nx_ip_rarp_queue_process))
 800b384:	68fb      	ldr	r3, [r7, #12]
 800b386:	f003 0320 	and.w	r3, r3, #32
 800b38a:	2b00      	cmp	r3, #0
 800b38c:	d009      	beq.n	800b3a2 <_nx_ip_thread_entry+0x29e>
 800b38e:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 800b390:	f8d3 3704 	ldr.w	r3, [r3, #1796]	; 0x704
 800b394:	2b00      	cmp	r3, #0
 800b396:	d004      	beq.n	800b3a2 <_nx_ip_thread_entry+0x29e>
        {

            /* Process the RARP queue.  */
            (ip_ptr -> nx_ip_rarp_queue_process)(ip_ptr);
 800b398:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 800b39a:	f8d3 3704 	ldr.w	r3, [r3, #1796]	; 0x704
 800b39e:	6c78      	ldr	r0, [r7, #68]	; 0x44
 800b3a0:	4798      	blx	r3
        }

        /* Check for an IGMP message event.  */
        if (ip_events & NX_IP_IGMP_EVENT)
 800b3a2:	68fb      	ldr	r3, [r7, #12]
 800b3a4:	f003 0340 	and.w	r3, r3, #64	; 0x40
 800b3a8:	2b00      	cmp	r3, #0
 800b3aa:	d004      	beq.n	800b3b6 <_nx_ip_thread_entry+0x2b2>
        {

            /* Process the ICMP packet queue.  */
            (ip_ptr -> nx_ip_igmp_queue_process)(ip_ptr);
 800b3ac:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 800b3ae:	f8d3 335c 	ldr.w	r3, [r3, #860]	; 0x35c
 800b3b2:	6c78      	ldr	r0, [r7, #68]	; 0x44
 800b3b4:	4798      	blx	r3
        }

        /* Check for an IGMP enable event.  */
        if (ip_events & NX_IP_IGMP_ENABLE_EVENT)
 800b3b6:	68fb      	ldr	r3, [r7, #12]
 800b3b8:	f403 6380 	and.w	r3, r3, #1024	; 0x400
 800b3bc:	2b00      	cmp	r3, #0
 800b3be:	d032      	beq.n	800b426 <_nx_ip_thread_entry+0x322>
        {

            /* Call the associated driver for this IP instance to register the "all hosts"
               multicast address.  */
            for (i = 0; i < NX_MAX_PHYSICAL_INTERFACES; i++)
 800b3c0:	2300      	movs	r3, #0
 800b3c2:	64fb      	str	r3, [r7, #76]	; 0x4c
 800b3c4:	e02c      	b.n	800b420 <_nx_ip_thread_entry+0x31c>
            {
                /* Enable the hardware for IGMP for all valid interfaces. */
                if (ip_ptr -> nx_ip_interface[i].nx_interface_valid)
 800b3c6:	6c7a      	ldr	r2, [r7, #68]	; 0x44
 800b3c8:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800b3ca:	214c      	movs	r1, #76	; 0x4c
 800b3cc:	fb01 f303 	mul.w	r3, r1, r3
 800b3d0:	4413      	add	r3, r2
 800b3d2:	f203 7324 	addw	r3, r3, #1828	; 0x724
 800b3d6:	781b      	ldrb	r3, [r3, #0]
 800b3d8:	2b00      	cmp	r3, #0
 800b3da:	d01e      	beq.n	800b41a <_nx_ip_thread_entry+0x316>
                {
                    driver_request.nx_ip_driver_ptr =                    ip_ptr;
 800b3dc:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 800b3de:	62bb      	str	r3, [r7, #40]	; 0x28
                    driver_request.nx_ip_driver_command =                NX_LINK_MULTICAST_JOIN;
 800b3e0:	2308      	movs	r3, #8
 800b3e2:	613b      	str	r3, [r7, #16]
                    driver_request.nx_ip_driver_physical_address_msw =   NX_IP_MULTICAST_UPPER;
 800b3e4:	f44f 7380 	mov.w	r3, #256	; 0x100
 800b3e8:	61bb      	str	r3, [r7, #24]
                    /*lint -e{835} -e{845} suppress operating on zero. */
                    driver_request.nx_ip_driver_physical_address_lsw =   NX_IP_MULTICAST_LOWER | (NX_ALL_HOSTS_ADDRESS & NX_IP_MULTICAST_MASK);
 800b3ea:	4b44      	ldr	r3, [pc, #272]	; (800b4fc <_nx_ip_thread_entry+0x3f8>)
 800b3ec:	61fb      	str	r3, [r7, #28]
                    driver_request.nx_ip_driver_interface            =   &(ip_ptr -> nx_ip_interface[i]);
 800b3ee:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800b3f0:	224c      	movs	r2, #76	; 0x4c
 800b3f2:	fb02 f303 	mul.w	r3, r2, r3
 800b3f6:	f503 63e4 	add.w	r3, r3, #1824	; 0x720
 800b3fa:	6c7a      	ldr	r2, [r7, #68]	; 0x44
 800b3fc:	4413      	add	r3, r2
 800b3fe:	62fb      	str	r3, [r7, #44]	; 0x2c

                    /* If trace is enabled, insert this event into the trace buffer.  */
                    NX_TRACE_IN_LINE_INSERT(NX_TRACE_INTERNAL_IO_DRIVER_MULTICAST_JOIN, ip_ptr, 0, 0, 0, NX_TRACE_INTERNAL_EVENTS, 0, 0);

                    (ip_ptr -> nx_ip_interface[i].nx_interface_link_driver_entry)(&driver_request);
 800b400:	6c7a      	ldr	r2, [r7, #68]	; 0x44
 800b402:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800b404:	214c      	movs	r1, #76	; 0x4c
 800b406:	fb01 f303 	mul.w	r3, r1, r3
 800b40a:	4413      	add	r3, r2
 800b40c:	f203 735c 	addw	r3, r3, #1884	; 0x75c
 800b410:	681b      	ldr	r3, [r3, #0]
 800b412:	f107 0210 	add.w	r2, r7, #16
 800b416:	4610      	mov	r0, r2
 800b418:	4798      	blx	r3
            for (i = 0; i < NX_MAX_PHYSICAL_INTERFACES; i++)
 800b41a:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800b41c:	3301      	adds	r3, #1
 800b41e:	64fb      	str	r3, [r7, #76]	; 0x4c
 800b420:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800b422:	2b03      	cmp	r3, #3
 800b424:	d9cf      	bls.n	800b3c6 <_nx_ip_thread_entry+0x2c2>
            }
        }
#endif /* !NX_DISABLE_IPV4  */

        /* Check for an IP unfragment event.  */
        if (ip_events & NX_IP_UNFRAG_EVENT)
 800b426:	68fb      	ldr	r3, [r7, #12]
 800b428:	f003 0302 	and.w	r3, r3, #2
 800b42c:	2b00      	cmp	r3, #0
 800b42e:	d009      	beq.n	800b444 <_nx_ip_thread_entry+0x340>
        {

            /* Process the IP fragment reassemble, if fragment has been enabled.  */
            if (ip_ptr -> nx_ip_fragment_assembly)
 800b430:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 800b432:	f8d3 32a0 	ldr.w	r3, [r3, #672]	; 0x2a0
 800b436:	2b00      	cmp	r3, #0
 800b438:	d004      	beq.n	800b444 <_nx_ip_thread_entry+0x340>
            {
                (ip_ptr -> nx_ip_fragment_assembly)(ip_ptr);
 800b43a:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 800b43c:	f8d3 32a0 	ldr.w	r3, [r3, #672]	; 0x2a0
 800b440:	6c78      	ldr	r0, [r7, #68]	; 0x44
 800b442:	4798      	blx	r3
            }
        }

#ifndef NX_DISABLE_IPV4
        /* Check for an ICMP message event.  */
        if (ip_events & NX_IP_ICMP_EVENT)
 800b444:	68fb      	ldr	r3, [r7, #12]
 800b446:	f003 0304 	and.w	r3, r3, #4
 800b44a:	2b00      	cmp	r3, #0
 800b44c:	d004      	beq.n	800b458 <_nx_ip_thread_entry+0x354>
        {

            /* Process the ICMP packet queue.  */
            (ip_ptr -> nx_ip_icmp_queue_process)(ip_ptr);
 800b44e:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 800b450:	f8d3 336c 	ldr.w	r3, [r3, #876]	; 0x36c
 800b454:	6c78      	ldr	r0, [r7, #68]	; 0x44
 800b456:	4798      	blx	r3
        }
#endif /* NX_DISABLE_IPV4 */

        /* Check for a deferred processing request from the driver.  */
        if (ip_events & NX_IP_DRIVER_DEFERRED_EVENT)
 800b458:	68fb      	ldr	r3, [r7, #12]
 800b45a:	f403 6300 	and.w	r3, r3, #2048	; 0x800
 800b45e:	2b00      	cmp	r3, #0
 800b460:	d030      	beq.n	800b4c4 <_nx_ip_thread_entry+0x3c0>
        {

            /* Go through each valid interface. */
            for (index = 0; index < NX_MAX_PHYSICAL_INTERFACES; index++)
 800b462:	2300      	movs	r3, #0
 800b464:	64bb      	str	r3, [r7, #72]	; 0x48
 800b466:	e02a      	b.n	800b4be <_nx_ip_thread_entry+0x3ba>
            {
                if (ip_ptr -> nx_ip_interface[index].nx_interface_valid)
 800b468:	6c7a      	ldr	r2, [r7, #68]	; 0x44
 800b46a:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 800b46c:	214c      	movs	r1, #76	; 0x4c
 800b46e:	fb01 f303 	mul.w	r3, r1, r3
 800b472:	4413      	add	r3, r2
 800b474:	f203 7324 	addw	r3, r3, #1828	; 0x724
 800b478:	781b      	ldrb	r3, [r3, #0]
 800b47a:	2b00      	cmp	r3, #0
 800b47c:	d01c      	beq.n	800b4b8 <_nx_ip_thread_entry+0x3b4>
                {

                    /* Yes, there is a deferred processing event from the driver. The only valid information
                       fields are the IP pointer and the command.  */
                    driver_request.nx_ip_driver_ptr =        ip_ptr;
 800b47e:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 800b480:	62bb      	str	r3, [r7, #40]	; 0x28
                    driver_request.nx_ip_driver_command =    NX_LINK_DEFERRED_PROCESSING;
 800b482:	2312      	movs	r3, #18
 800b484:	613b      	str	r3, [r7, #16]
                    driver_request.nx_ip_driver_interface  = &(ip_ptr -> nx_ip_interface[index]);
 800b486:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 800b488:	224c      	movs	r2, #76	; 0x4c
 800b48a:	fb02 f303 	mul.w	r3, r2, r3
 800b48e:	f503 63e4 	add.w	r3, r3, #1824	; 0x720
 800b492:	6c7a      	ldr	r2, [r7, #68]	; 0x44
 800b494:	4413      	add	r3, r2
 800b496:	62fb      	str	r3, [r7, #44]	; 0x2c
                    driver_request.nx_ip_driver_return_ptr = &foo;
 800b498:	f107 0308 	add.w	r3, r7, #8
 800b49c:	627b      	str	r3, [r7, #36]	; 0x24

                    (ip_ptr -> nx_ip_interface[index].nx_interface_link_driver_entry)(&driver_request);
 800b49e:	6c7a      	ldr	r2, [r7, #68]	; 0x44
 800b4a0:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 800b4a2:	214c      	movs	r1, #76	; 0x4c
 800b4a4:	fb01 f303 	mul.w	r3, r1, r3
 800b4a8:	4413      	add	r3, r2
 800b4aa:	f203 735c 	addw	r3, r3, #1884	; 0x75c
 800b4ae:	681b      	ldr	r3, [r3, #0]
 800b4b0:	f107 0210 	add.w	r2, r7, #16
 800b4b4:	4610      	mov	r0, r2
 800b4b6:	4798      	blx	r3
            for (index = 0; index < NX_MAX_PHYSICAL_INTERFACES; index++)
 800b4b8:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 800b4ba:	3301      	adds	r3, #1
 800b4bc:	64bb      	str	r3, [r7, #72]	; 0x48
 800b4be:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 800b4c0:	2b03      	cmp	r3, #3
 800b4c2:	d9d1      	bls.n	800b468 <_nx_ip_thread_entry+0x364>
                }
            }
        }

        /* Check for a deferred TCP cleanup processing request from the driver.  */
        if (ip_events & NX_IP_TCP_CLEANUP_DEFERRED)
 800b4c4:	68fb      	ldr	r3, [r7, #12]
 800b4c6:	f403 5380 	and.w	r3, r3, #4096	; 0x1000
 800b4ca:	2b00      	cmp	r3, #0
 800b4cc:	d004      	beq.n	800b4d8 <_nx_ip_thread_entry+0x3d4>
        {

            /* Yes, there is a deferred cleanup processing event. Call the TCP deferred cleanup
               processing function.  */
            (ip_ptr -> nx_tcp_deferred_cleanup_check)(ip_ptr);
 800b4ce:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 800b4d0:	f8d3 371c 	ldr.w	r3, [r3, #1820]	; 0x71c
 800b4d4:	6c78      	ldr	r0, [r7, #68]	; 0x44
 800b4d6:	4798      	blx	r3
        }

        /* Check for a link status change request from the driver.  */
        if (ip_events & NX_IP_LINK_STATUS_EVENT)
 800b4d8:	68fb      	ldr	r3, [r7, #12]
 800b4da:	f403 4380 	and.w	r3, r3, #16384	; 0x4000
 800b4de:	2b00      	cmp	r3, #0
 800b4e0:	f43f ae87 	beq.w	800b1f2 <_nx_ip_thread_entry+0xee>
        {

            /* Yes, there is a link status change  event. Call the deferred link status processing function. */
            _nx_ip_deferred_link_status_process(ip_ptr);
 800b4e4:	6c78      	ldr	r0, [r7, #68]	; 0x44
 800b4e6:	f7fe fdc1 	bl	800a06c <_nx_ip_deferred_link_status_process>
 800b4ea:	e682      	b.n	800b1f2 <_nx_ip_thread_entry+0xee>
                continue;
 800b4ec:	bf00      	nop
 800b4ee:	e680      	b.n	800b1f2 <_nx_ip_thread_entry+0xee>
                continue;
 800b4f0:	bf00      	nop
 800b4f2:	e67e      	b.n	800b1f2 <_nx_ip_thread_entry+0xee>
                continue;
 800b4f4:	bf00      	nop
 800b4f6:	e67c      	b.n	800b1f2 <_nx_ip_thread_entry+0xee>
                continue;
 800b4f8:	bf00      	nop
        tx_mutex_put(&(ip_ptr -> nx_ip_protection));
 800b4fa:	e67a      	b.n	800b1f2 <_nx_ip_thread_entry+0xee>
 800b4fc:	5e000001 	.word	0x5e000001

0800b500 <_nx_ipv4_option_process>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
UINT  _nx_ipv4_option_process(NX_IP *ip_ptr, NX_PACKET *packet_ptr)
{
 800b500:	b580      	push	{r7, lr}
 800b502:	b08a      	sub	sp, #40	; 0x28
 800b504:	af00      	add	r7, sp, #0
 800b506:	6078      	str	r0, [r7, #4]
 800b508:	6039      	str	r1, [r7, #0]

NX_IPV4_HEADER *ip_header_ptr;
UCHAR          *option_ptr;
ULONG           ip_option_length;
#ifndef NX_DISABLE_ICMPV4_ERROR_MESSAGE
ULONG           ip_normal_length = 20;
 800b50a:	2314      	movs	r3, #20
 800b50c:	61bb      	str	r3, [r7, #24]
#endif /* NX_DISABLE_ICMPV4_ERROR_MESSAGE */
UINT            index = 0;
 800b50e:	2300      	movs	r3, #0
 800b510:	623b      	str	r3, [r7, #32]
UCHAR           op_type;
UCHAR           op_length;
UCHAR           op_timestamp_offset;
UCHAR           op_timestamp_overflow;
UCHAR           op_timestamp_flags;
UINT            op_timestamp_counter = 0;
 800b512:	2300      	movs	r3, #0
 800b514:	61fb      	str	r3, [r7, #28]

    /* Set the IPv4 header and IPv4 option pointer.  */
    /*lint -e{927} -e{826} suppress cast of pointer to pointer, since it is necessary  */
    ip_header_ptr = (NX_IPV4_HEADER *)(packet_ptr -> nx_packet_prepend_ptr);
 800b516:	683b      	ldr	r3, [r7, #0]
 800b518:	689b      	ldr	r3, [r3, #8]
 800b51a:	617b      	str	r3, [r7, #20]
    option_ptr = packet_ptr -> nx_packet_prepend_ptr + sizeof(NX_IPV4_HEADER);
 800b51c:	683b      	ldr	r3, [r7, #0]
 800b51e:	689b      	ldr	r3, [r3, #8]
 800b520:	3314      	adds	r3, #20
 800b522:	627b      	str	r3, [r7, #36]	; 0x24

    /* Calculate the IPv4 option length.  */
    ip_option_length = ((((ip_header_ptr -> nx_ip_header_word_0 & NX_IP_LENGTH_MASK) >> 24) - NX_IP_NORMAL_LENGTH) & 0xFF) * (ULONG)sizeof(ULONG);
 800b524:	697b      	ldr	r3, [r7, #20]
 800b526:	681b      	ldr	r3, [r3, #0]
 800b528:	0e1b      	lsrs	r3, r3, #24
 800b52a:	f003 030f 	and.w	r3, r3, #15
 800b52e:	3b05      	subs	r3, #5
 800b530:	b2db      	uxtb	r3, r3
 800b532:	009b      	lsls	r3, r3, #2
 800b534:	613b      	str	r3, [r7, #16]

    /* Loop to process the IPv4 option.  */
    while (index < ip_option_length)
 800b536:	e0a3      	b.n	800b680 <_nx_ipv4_option_process+0x180>
    {

        /* Get the option type.  */
        op_type = *option_ptr;
 800b538:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800b53a:	781b      	ldrb	r3, [r3, #0]
 800b53c:	73fb      	strb	r3, [r7, #15]

        /* Process the option type. */
        switch (op_type)
 800b53e:	7bfb      	ldrb	r3, [r7, #15]
 800b540:	2b44      	cmp	r3, #68	; 0x44
 800b542:	d010      	beq.n	800b566 <_nx_ipv4_option_process+0x66>
 800b544:	2b44      	cmp	r3, #68	; 0x44
 800b546:	f300 8082 	bgt.w	800b64e <_nx_ipv4_option_process+0x14e>
 800b54a:	2b00      	cmp	r3, #0
 800b54c:	d002      	beq.n	800b554 <_nx_ipv4_option_process+0x54>
 800b54e:	2b01      	cmp	r3, #1
 800b550:	d002      	beq.n	800b558 <_nx_ipv4_option_process+0x58>
                return(NX_FALSE);
            }
            break;
        }
        default:
            break;
 800b552:	e07c      	b.n	800b64e <_nx_ipv4_option_process+0x14e>
            return(NX_TRUE);
 800b554:	2301      	movs	r3, #1
 800b556:	e099      	b.n	800b68c <_nx_ipv4_option_process+0x18c>
            option_ptr++;
 800b558:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800b55a:	3301      	adds	r3, #1
 800b55c:	627b      	str	r3, [r7, #36]	; 0x24
            index++;
 800b55e:	6a3b      	ldr	r3, [r7, #32]
 800b560:	3301      	adds	r3, #1
 800b562:	623b      	str	r3, [r7, #32]
            continue;
 800b564:	e08c      	b.n	800b680 <_nx_ipv4_option_process+0x180>
            op_timestamp_counter++;
 800b566:	69fb      	ldr	r3, [r7, #28]
 800b568:	3301      	adds	r3, #1
 800b56a:	61fb      	str	r3, [r7, #28]
            if (op_timestamp_counter > 1)
 800b56c:	69fb      	ldr	r3, [r7, #28]
 800b56e:	2b01      	cmp	r3, #1
 800b570:	d90b      	bls.n	800b58a <_nx_ipv4_option_process+0x8a>
                NX_ICMPV4_SEND_PARAMETER_PROBLEM(ip_ptr, packet_ptr, NX_ICMP_ZERO_CODE, (ip_normal_length + index + 2));
 800b572:	69ba      	ldr	r2, [r7, #24]
 800b574:	6a3b      	ldr	r3, [r7, #32]
 800b576:	4413      	add	r3, r2
 800b578:	3302      	adds	r3, #2
 800b57a:	f04f 6240 	mov.w	r2, #201326592	; 0xc000000
 800b57e:	6839      	ldr	r1, [r7, #0]
 800b580:	6878      	ldr	r0, [r7, #4]
 800b582:	f7fe f999 	bl	80098b8 <_nx_icmpv4_send_error_message>
                return(NX_FALSE);
 800b586:	2300      	movs	r3, #0
 800b588:	e080      	b.n	800b68c <_nx_ipv4_option_process+0x18c>
            op_length = *(option_ptr + 1);
 800b58a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800b58c:	785b      	ldrb	r3, [r3, #1]
 800b58e:	73bb      	strb	r3, [r7, #14]
            op_timestamp_offset = *(option_ptr + 2);
 800b590:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800b592:	789b      	ldrb	r3, [r3, #2]
 800b594:	737b      	strb	r3, [r7, #13]
            op_timestamp_overflow = (*(option_ptr + 3)) >> 4;
 800b596:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800b598:	3303      	adds	r3, #3
 800b59a:	781b      	ldrb	r3, [r3, #0]
 800b59c:	091b      	lsrs	r3, r3, #4
 800b59e:	733b      	strb	r3, [r7, #12]
            op_timestamp_flags = (*(option_ptr + 3)) & 0xF;
 800b5a0:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800b5a2:	3303      	adds	r3, #3
 800b5a4:	781b      	ldrb	r3, [r3, #0]
 800b5a6:	f003 030f 	and.w	r3, r3, #15
 800b5aa:	72fb      	strb	r3, [r7, #11]
            if ((op_length < 8) || (op_length > 40) || ((op_length % 4) != 0))
 800b5ac:	7bbb      	ldrb	r3, [r7, #14]
 800b5ae:	2b07      	cmp	r3, #7
 800b5b0:	d908      	bls.n	800b5c4 <_nx_ipv4_option_process+0xc4>
 800b5b2:	7bbb      	ldrb	r3, [r7, #14]
 800b5b4:	2b28      	cmp	r3, #40	; 0x28
 800b5b6:	d805      	bhi.n	800b5c4 <_nx_ipv4_option_process+0xc4>
 800b5b8:	7bbb      	ldrb	r3, [r7, #14]
 800b5ba:	f003 0303 	and.w	r3, r3, #3
 800b5be:	b2db      	uxtb	r3, r3
 800b5c0:	2b00      	cmp	r3, #0
 800b5c2:	d00b      	beq.n	800b5dc <_nx_ipv4_option_process+0xdc>
                NX_ICMPV4_SEND_PARAMETER_PROBLEM(ip_ptr, packet_ptr, NX_ICMP_ZERO_CODE, (ip_normal_length + index + 2));
 800b5c4:	69ba      	ldr	r2, [r7, #24]
 800b5c6:	6a3b      	ldr	r3, [r7, #32]
 800b5c8:	4413      	add	r3, r2
 800b5ca:	3302      	adds	r3, #2
 800b5cc:	f04f 6240 	mov.w	r2, #201326592	; 0xc000000
 800b5d0:	6839      	ldr	r1, [r7, #0]
 800b5d2:	6878      	ldr	r0, [r7, #4]
 800b5d4:	f7fe f970 	bl	80098b8 <_nx_icmpv4_send_error_message>
                return(NX_FALSE);
 800b5d8:	2300      	movs	r3, #0
 800b5da:	e057      	b.n	800b68c <_nx_ipv4_option_process+0x18c>
            if ((op_timestamp_offset < 5) || ((op_timestamp_offset % 2) == 0))
 800b5dc:	7b7b      	ldrb	r3, [r7, #13]
 800b5de:	2b04      	cmp	r3, #4
 800b5e0:	d905      	bls.n	800b5ee <_nx_ipv4_option_process+0xee>
 800b5e2:	7b7b      	ldrb	r3, [r7, #13]
 800b5e4:	f003 0301 	and.w	r3, r3, #1
 800b5e8:	b2db      	uxtb	r3, r3
 800b5ea:	2b00      	cmp	r3, #0
 800b5ec:	d10b      	bne.n	800b606 <_nx_ipv4_option_process+0x106>
                NX_ICMPV4_SEND_PARAMETER_PROBLEM(ip_ptr, packet_ptr, NX_ICMP_ZERO_CODE, (ip_normal_length + index + 3));
 800b5ee:	69ba      	ldr	r2, [r7, #24]
 800b5f0:	6a3b      	ldr	r3, [r7, #32]
 800b5f2:	4413      	add	r3, r2
 800b5f4:	3303      	adds	r3, #3
 800b5f6:	f04f 6240 	mov.w	r2, #201326592	; 0xc000000
 800b5fa:	6839      	ldr	r1, [r7, #0]
 800b5fc:	6878      	ldr	r0, [r7, #4]
 800b5fe:	f7fe f95b 	bl	80098b8 <_nx_icmpv4_send_error_message>
                return(NX_FALSE);
 800b602:	2300      	movs	r3, #0
 800b604:	e042      	b.n	800b68c <_nx_ipv4_option_process+0x18c>
            if (op_timestamp_overflow == 15)
 800b606:	7b3b      	ldrb	r3, [r7, #12]
 800b608:	2b0f      	cmp	r3, #15
 800b60a:	d10b      	bne.n	800b624 <_nx_ipv4_option_process+0x124>
                NX_ICMPV4_SEND_PARAMETER_PROBLEM(ip_ptr, packet_ptr, NX_ICMP_ZERO_CODE, (ip_normal_length + index + 4));
 800b60c:	69ba      	ldr	r2, [r7, #24]
 800b60e:	6a3b      	ldr	r3, [r7, #32]
 800b610:	4413      	add	r3, r2
 800b612:	3304      	adds	r3, #4
 800b614:	f04f 6240 	mov.w	r2, #201326592	; 0xc000000
 800b618:	6839      	ldr	r1, [r7, #0]
 800b61a:	6878      	ldr	r0, [r7, #4]
 800b61c:	f7fe f94c 	bl	80098b8 <_nx_icmpv4_send_error_message>
                return(NX_FALSE);
 800b620:	2300      	movs	r3, #0
 800b622:	e033      	b.n	800b68c <_nx_ipv4_option_process+0x18c>
            if ((op_timestamp_flags != 0) && (op_timestamp_flags != 1) && (op_timestamp_flags != 3))
 800b624:	7afb      	ldrb	r3, [r7, #11]
 800b626:	2b00      	cmp	r3, #0
 800b628:	d013      	beq.n	800b652 <_nx_ipv4_option_process+0x152>
 800b62a:	7afb      	ldrb	r3, [r7, #11]
 800b62c:	2b01      	cmp	r3, #1
 800b62e:	d010      	beq.n	800b652 <_nx_ipv4_option_process+0x152>
 800b630:	7afb      	ldrb	r3, [r7, #11]
 800b632:	2b03      	cmp	r3, #3
 800b634:	d00d      	beq.n	800b652 <_nx_ipv4_option_process+0x152>
                NX_ICMPV4_SEND_PARAMETER_PROBLEM(ip_ptr, packet_ptr, NX_ICMP_ZERO_CODE, (ip_normal_length + index + 4));
 800b636:	69ba      	ldr	r2, [r7, #24]
 800b638:	6a3b      	ldr	r3, [r7, #32]
 800b63a:	4413      	add	r3, r2
 800b63c:	3304      	adds	r3, #4
 800b63e:	f04f 6240 	mov.w	r2, #201326592	; 0xc000000
 800b642:	6839      	ldr	r1, [r7, #0]
 800b644:	6878      	ldr	r0, [r7, #4]
 800b646:	f7fe f937 	bl	80098b8 <_nx_icmpv4_send_error_message>
                return(NX_FALSE);
 800b64a:	2300      	movs	r3, #0
 800b64c:	e01e      	b.n	800b68c <_nx_ipv4_option_process+0x18c>
            break;
 800b64e:	bf00      	nop
 800b650:	e000      	b.n	800b654 <_nx_ipv4_option_process+0x154>
            break;
 800b652:	bf00      	nop
        }

        /* Get the option length.  */
        op_length = *(option_ptr + 1);
 800b654:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800b656:	785b      	ldrb	r3, [r3, #1]
 800b658:	73bb      	strb	r3, [r7, #14]

        /* Check for invalid option length.
           RFC 791: The option-length octet counts the option-type octet and the 
           option-length octet as well as the option-data octets.  */
        if ((op_length < 2) || ((index + op_length) > ip_option_length))
 800b65a:	7bbb      	ldrb	r3, [r7, #14]
 800b65c:	2b01      	cmp	r3, #1
 800b65e:	d905      	bls.n	800b66c <_nx_ipv4_option_process+0x16c>
 800b660:	7bba      	ldrb	r2, [r7, #14]
 800b662:	6a3b      	ldr	r3, [r7, #32]
 800b664:	4413      	add	r3, r2
 800b666:	693a      	ldr	r2, [r7, #16]
 800b668:	429a      	cmp	r2, r3
 800b66a:	d201      	bcs.n	800b670 <_nx_ipv4_option_process+0x170>
        {
            return(NX_FALSE);
 800b66c:	2300      	movs	r3, #0
 800b66e:	e00d      	b.n	800b68c <_nx_ipv4_option_process+0x18c>
        }

        /* Move to the next top level option. */
        option_ptr += op_length;
 800b670:	7bbb      	ldrb	r3, [r7, #14]
 800b672:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 800b674:	4413      	add	r3, r2
 800b676:	627b      	str	r3, [r7, #36]	; 0x24

        /* Update the index.  */
        index += op_length;
 800b678:	7bbb      	ldrb	r3, [r7, #14]
 800b67a:	6a3a      	ldr	r2, [r7, #32]
 800b67c:	4413      	add	r3, r2
 800b67e:	623b      	str	r3, [r7, #32]
    while (index < ip_option_length)
 800b680:	6a3a      	ldr	r2, [r7, #32]
 800b682:	693b      	ldr	r3, [r7, #16]
 800b684:	429a      	cmp	r2, r3
 800b686:	f4ff af57 	bcc.w	800b538 <_nx_ipv4_option_process+0x38>
    }

    /* Return NX_TRUE.  */
    return(NX_TRUE);
 800b68a:	2301      	movs	r3, #1
}
 800b68c:	4618      	mov	r0, r3
 800b68e:	3728      	adds	r7, #40	; 0x28
 800b690:	46bd      	mov	sp, r7
 800b692:	bd80      	pop	{r7, pc}

0800b694 <_nx_ipv4_packet_receive>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
VOID  _nx_ipv4_packet_receive(NX_IP *ip_ptr, NX_PACKET *packet_ptr)
{
 800b694:	b580      	push	{r7, lr}
 800b696:	b096      	sub	sp, #88	; 0x58
 800b698:	af02      	add	r7, sp, #8
 800b69a:	6078      	str	r0, [r7, #4]
 800b69c:	6039      	str	r1, [r7, #0]
#endif /* NX_DISABLE_IP_RX_CHECKSUM */

    /* It's assumed that the IP link driver has positioned the top pointer in the
       packet to the start of the IP address... so that's where we will start.  */
    /*lint -e{927} -e{826} suppress cast of pointer to pointer, since it is necessary  */
    ip_header_ptr = (NX_IPV4_HEADER *)packet_ptr -> nx_packet_prepend_ptr;
 800b69e:	683b      	ldr	r3, [r7, #0]
 800b6a0:	689b      	ldr	r3, [r3, #8]
 800b6a2:	64bb      	str	r3, [r7, #72]	; 0x48
    /* If trace is enabled, insert this event into the trace buffer.  */
    NX_TRACE_IN_LINE_INSERT(NX_TRACE_INTERNAL_IP_RECEIVE, ip_ptr, ip_header_ptr -> nx_ip_header_source_ip, packet_ptr, packet_ptr -> nx_packet_length, NX_TRACE_INTERNAL_EVENTS, 0, 0);


    /* Pick up the first word in the IP header. */
    val = ip_header_ptr -> nx_ip_header_word_0;
 800b6a4:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 800b6a6:	681b      	ldr	r3, [r3, #0]
 800b6a8:	643b      	str	r3, [r7, #64]	; 0x40

    /* Convert to host byte order. */
    NX_CHANGE_ULONG_ENDIAN(val);
 800b6aa:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 800b6ac:	ba1b      	rev	r3, r3
 800b6ae:	643b      	str	r3, [r7, #64]	; 0x40

    /* Obtain packet length. */
    pkt_length = val & NX_LOWER_16_MASK;
 800b6b0:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 800b6b2:	b29b      	uxth	r3, r3
 800b6b4:	63fb      	str	r3, [r7, #60]	; 0x3c

    /* Make sure the IP length matches the packet length.  Some Ethernet devices
       add padding to small packets, which results in a discrepancy between the
       packet length and the IP header length.  */
    if (packet_ptr -> nx_packet_length != pkt_length)
 800b6b6:	683b      	ldr	r3, [r7, #0]
 800b6b8:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800b6ba:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 800b6bc:	429a      	cmp	r2, r3
 800b6be:	d066      	beq.n	800b78e <_nx_ipv4_packet_receive+0xfa>
    {

        /* Determine if the packet length is less than the size reported in the IP header.  */
        if (packet_ptr -> nx_packet_length < pkt_length)
 800b6c0:	683b      	ldr	r3, [r7, #0]
 800b6c2:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800b6c4:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 800b6c6:	429a      	cmp	r2, r3
 800b6c8:	d90d      	bls.n	800b6e6 <_nx_ipv4_packet_receive+0x52>
            /* Packet is too small!  */

#ifndef NX_DISABLE_IP_INFO

            /* Increment the IP invalid packet error.  */
            ip_ptr -> nx_ip_invalid_packets++;
 800b6ca:	687b      	ldr	r3, [r7, #4]
 800b6cc:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 800b6ce:	1c5a      	adds	r2, r3, #1
 800b6d0:	687b      	ldr	r3, [r7, #4]
 800b6d2:	635a      	str	r2, [r3, #52]	; 0x34

            /* Increment the IP receive packets dropped count.  */
            ip_ptr -> nx_ip_receive_packets_dropped++;
 800b6d4:	687b      	ldr	r3, [r7, #4]
 800b6d6:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 800b6d8:	1c5a      	adds	r2, r3, #1
 800b6da:	687b      	ldr	r3, [r7, #4]
 800b6dc:	64da      	str	r2, [r3, #76]	; 0x4c
#endif

            /* Invalid packet length, just release it.  */
            _nx_packet_release(packet_ptr);
 800b6de:	6838      	ldr	r0, [r7, #0]
 800b6e0:	f000 fe92 	bl	800c408 <_nx_packet_release>

            /* The function is complete, just return!  */
            return;
 800b6e4:	e228      	b.n	800bb38 <_nx_ipv4_packet_receive+0x4a4>
        }

        /* Calculate the difference in the length.  */
        delta =  packet_ptr -> nx_packet_length - pkt_length;
 800b6e6:	683b      	ldr	r3, [r7, #0]
 800b6e8:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 800b6ea:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800b6ec:	1ad3      	subs	r3, r2, r3
 800b6ee:	647b      	str	r3, [r7, #68]	; 0x44

        /* Adjust the packet length.  */
        packet_ptr -> nx_packet_length =  packet_ptr -> nx_packet_length - delta;
 800b6f0:	683b      	ldr	r3, [r7, #0]
 800b6f2:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 800b6f4:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 800b6f6:	1ad2      	subs	r2, r2, r3
 800b6f8:	683b      	ldr	r3, [r7, #0]
 800b6fa:	625a      	str	r2, [r3, #36]	; 0x24

        /* Adjust the append pointer.  */

#ifndef NX_DISABLE_PACKET_CHAIN
        /* Loop to process adjustment that spans multiple packets.  */
        while (delta)
 800b6fc:	e044      	b.n	800b788 <_nx_ipv4_packet_receive+0xf4>
        {

            /* Determine if the packet is chained (or still chained after the adjustment).  */
            if (packet_ptr -> nx_packet_last == NX_NULL)
 800b6fe:	683b      	ldr	r3, [r7, #0]
 800b700:	699b      	ldr	r3, [r3, #24]
 800b702:	2b00      	cmp	r3, #0
 800b704:	d107      	bne.n	800b716 <_nx_ipv4_packet_receive+0x82>
            {

                /* No, packet is not chained, simply adjust the append pointer in the packet.  */
                packet_ptr -> nx_packet_append_ptr =  packet_ptr -> nx_packet_append_ptr - delta;
 800b706:	683b      	ldr	r3, [r7, #0]
 800b708:	68da      	ldr	r2, [r3, #12]
 800b70a:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 800b70c:	425b      	negs	r3, r3
 800b70e:	441a      	add	r2, r3
 800b710:	683b      	ldr	r3, [r7, #0]
 800b712:	60da      	str	r2, [r3, #12]

                /* Break out of the loop, since the adjustment is complete.  */
                break;
 800b714:	e03b      	b.n	800b78e <_nx_ipv4_packet_receive+0xfa>
            }

            /* Pickup the pointer to the last packet.  */
            last_packet =  packet_ptr -> nx_packet_last;
 800b716:	683b      	ldr	r3, [r7, #0]
 800b718:	699b      	ldr	r3, [r3, #24]
 800b71a:	63bb      	str	r3, [r7, #56]	; 0x38

            /* Determine if the amount to adjust is less than the payload in the last packet.  */
            /*lint -e{946} -e{947} suppress pointer subtraction, since it is necessary. */
            if (((ULONG)(last_packet -> nx_packet_append_ptr - last_packet -> nx_packet_prepend_ptr)) > delta)
 800b71c:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800b71e:	68da      	ldr	r2, [r3, #12]
 800b720:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800b722:	689b      	ldr	r3, [r3, #8]
 800b724:	1ad3      	subs	r3, r2, r3
 800b726:	461a      	mov	r2, r3
 800b728:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 800b72a:	4293      	cmp	r3, r2
 800b72c:	d207      	bcs.n	800b73e <_nx_ipv4_packet_receive+0xaa>
            {

                /* Yes, simply adjust the append pointer of the last packet in the chain.  */
                /*lint -e{946} -e{947} suppress pointer subtraction, since it is necessary. */
                last_packet -> nx_packet_append_ptr =  last_packet -> nx_packet_append_ptr - delta;
 800b72e:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800b730:	68da      	ldr	r2, [r3, #12]
 800b732:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 800b734:	425b      	negs	r3, r3
 800b736:	441a      	add	r2, r3
 800b738:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800b73a:	60da      	str	r2, [r3, #12]

                /* Get out of the loop, since the adjustment is complete.  */
                break;
 800b73c:	e027      	b.n	800b78e <_nx_ipv4_packet_receive+0xfa>
            }
            else
            {

                /* Adjust the delta by the amount in the last packet.  */
                delta =  delta - ((ULONG)(last_packet -> nx_packet_append_ptr - last_packet -> nx_packet_prepend_ptr));
 800b73e:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800b740:	68da      	ldr	r2, [r3, #12]
 800b742:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800b744:	689b      	ldr	r3, [r3, #8]
 800b746:	1ad3      	subs	r3, r2, r3
 800b748:	461a      	mov	r2, r3
 800b74a:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 800b74c:	1a9b      	subs	r3, r3, r2
 800b74e:	647b      	str	r3, [r7, #68]	; 0x44

                /* Find the packet before the last packet.  */
                before_last_packet =  packet_ptr;
 800b750:	683b      	ldr	r3, [r7, #0]
 800b752:	64fb      	str	r3, [r7, #76]	; 0x4c
                while (before_last_packet -> nx_packet_next != last_packet)
 800b754:	e002      	b.n	800b75c <_nx_ipv4_packet_receive+0xc8>
                {

                    /* Move to the next packet in the chain.  */
                    before_last_packet =  before_last_packet -> nx_packet_next;
 800b756:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800b758:	685b      	ldr	r3, [r3, #4]
 800b75a:	64fb      	str	r3, [r7, #76]	; 0x4c
                while (before_last_packet -> nx_packet_next != last_packet)
 800b75c:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800b75e:	685b      	ldr	r3, [r3, #4]
 800b760:	6bba      	ldr	r2, [r7, #56]	; 0x38
 800b762:	429a      	cmp	r2, r3
 800b764:	d1f7      	bne.n	800b756 <_nx_ipv4_packet_receive+0xc2>

                /* At this point, we need to release the last packet and adjust the other packet
                   pointers.  */

                /* Ensure the next packet pointer is NULL in what is now the last packet.  */
                before_last_packet -> nx_packet_next =  NX_NULL;
 800b766:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800b768:	2200      	movs	r2, #0
 800b76a:	605a      	str	r2, [r3, #4]

                /* Determine if the packet is still chained.  */
                if (packet_ptr != before_last_packet)
 800b76c:	683a      	ldr	r2, [r7, #0]
 800b76e:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800b770:	429a      	cmp	r2, r3
 800b772:	d003      	beq.n	800b77c <_nx_ipv4_packet_receive+0xe8>
                {

                    /* Yes, the packet is still chained, setup the last packet pointer.  */
                    packet_ptr -> nx_packet_last =  before_last_packet;
 800b774:	683b      	ldr	r3, [r7, #0]
 800b776:	6cfa      	ldr	r2, [r7, #76]	; 0x4c
 800b778:	619a      	str	r2, [r3, #24]
 800b77a:	e002      	b.n	800b782 <_nx_ipv4_packet_receive+0xee>
                }
                else
                {

                    /* The packet is no longer chained, set the last packet pointer to NULL.  */
                    packet_ptr -> nx_packet_last =  NX_NULL;
 800b77c:	683b      	ldr	r3, [r7, #0]
 800b77e:	2200      	movs	r2, #0
 800b780:	619a      	str	r2, [r3, #24]
                }

                /* Release the last packet.   */
                _nx_packet_release(last_packet);
 800b782:	6bb8      	ldr	r0, [r7, #56]	; 0x38
 800b784:	f000 fe40 	bl	800c408 <_nx_packet_release>
        while (delta)
 800b788:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 800b78a:	2b00      	cmp	r3, #0
 800b78c:	d1b7      	bne.n	800b6fe <_nx_ipv4_packet_receive+0x6a>
        packet_ptr -> nx_packet_append_ptr =  packet_ptr -> nx_packet_append_ptr - delta;
#endif /* NX_DISABLE_PACKET_CHAIN */
    }

    /* Get the incoming interface. */
    if_ptr = packet_ptr -> nx_packet_address.nx_packet_interface_ptr;
 800b78e:	683b      	ldr	r3, [r7, #0]
 800b790:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800b792:	637b      	str	r3, [r7, #52]	; 0x34

    /* Obtain IP header length. */
    ip_header_length =  (val & NX_IP_LENGTH_MASK) >> 24;
 800b794:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 800b796:	0e1b      	lsrs	r3, r3, #24
 800b798:	f003 030f 	and.w	r3, r3, #15
 800b79c:	633b      	str	r3, [r7, #48]	; 0x30
    /* Check for minimal packet length. The check is done after the endian swapping
       since the compiler may possibly be able to optimize the lookup of
       "nx_packet_length" and therefore reduce the amount of work performing these
       size checks. The endian logic is okay since packets must always have
       payloads greater than the IP header in size.  */
    if ((packet_ptr -> nx_packet_length <= (ip_header_length << 2)) ||
 800b79e:	683b      	ldr	r3, [r7, #0]
 800b7a0:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 800b7a2:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800b7a4:	009b      	lsls	r3, r3, #2
 800b7a6:	429a      	cmp	r2, r3
 800b7a8:	d902      	bls.n	800b7b0 <_nx_ipv4_packet_receive+0x11c>
 800b7aa:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800b7ac:	2b04      	cmp	r3, #4
 800b7ae:	d80d      	bhi.n	800b7cc <_nx_ipv4_packet_receive+0x138>
        /* Packet is too small!  */

#ifndef NX_DISABLE_IP_INFO

        /* Increment the IP invalid packet error.  */
        ip_ptr -> nx_ip_invalid_packets++;
 800b7b0:	687b      	ldr	r3, [r7, #4]
 800b7b2:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 800b7b4:	1c5a      	adds	r2, r3, #1
 800b7b6:	687b      	ldr	r3, [r7, #4]
 800b7b8:	635a      	str	r2, [r3, #52]	; 0x34

        /* Increment the IP receive packets dropped count.  */
        ip_ptr -> nx_ip_receive_packets_dropped++;
 800b7ba:	687b      	ldr	r3, [r7, #4]
 800b7bc:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 800b7be:	1c5a      	adds	r2, r3, #1
 800b7c0:	687b      	ldr	r3, [r7, #4]
 800b7c2:	64da      	str	r2, [r3, #76]	; 0x4c
#endif

        /* Invalid packet length, just release it.  */
        _nx_packet_release(packet_ptr);
 800b7c4:	6838      	ldr	r0, [r7, #0]
 800b7c6:	f000 fe1f 	bl	800c408 <_nx_packet_release>

        /* The function is complete, just return!  */
        return;
 800b7ca:	e1b5      	b.n	800bb38 <_nx_ipv4_packet_receive+0x4a4>
    {


        checksum = _nx_ip_checksum_compute(packet_ptr, NX_IP_VERSION_V4,
                                           /* length is the size of IP header, including options */
                                           (UINT)(ip_header_length << 2),
 800b7cc:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800b7ce:	009a      	lsls	r2, r3, #2
        checksum = _nx_ip_checksum_compute(packet_ptr, NX_IP_VERSION_V4,
 800b7d0:	2300      	movs	r3, #0
 800b7d2:	9300      	str	r3, [sp, #0]
 800b7d4:	2300      	movs	r3, #0
 800b7d6:	2104      	movs	r1, #4
 800b7d8:	6838      	ldr	r0, [r7, #0]
 800b7da:	f7fe fa25 	bl	8009c28 <_nx_ip_checksum_compute>
 800b7de:	4603      	mov	r3, r0
 800b7e0:	62fb      	str	r3, [r7, #44]	; 0x2c
                                           /* IPv4 header checksum doesn't care src/dest addresses */
                                           NULL, NULL);
        checksum =  ~checksum & NX_LOWER_16_MASK;
 800b7e2:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800b7e4:	43db      	mvns	r3, r3
 800b7e6:	b29b      	uxth	r3, r3
 800b7e8:	62fb      	str	r3, [r7, #44]	; 0x2c

        /* Check the checksum again.  */
        if (checksum)
 800b7ea:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800b7ec:	2b00      	cmp	r3, #0
 800b7ee:	d012      	beq.n	800b816 <_nx_ipv4_packet_receive+0x182>
        {

#ifndef NX_DISABLE_IP_INFO

            /* Increment the IP invalid packet error.  */
            ip_ptr -> nx_ip_invalid_packets++;
 800b7f0:	687b      	ldr	r3, [r7, #4]
 800b7f2:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 800b7f4:	1c5a      	adds	r2, r3, #1
 800b7f6:	687b      	ldr	r3, [r7, #4]
 800b7f8:	635a      	str	r2, [r3, #52]	; 0x34

            /* Increment the IP checksum error.  */
            ip_ptr -> nx_ip_receive_checksum_errors++;
 800b7fa:	687b      	ldr	r3, [r7, #4]
 800b7fc:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 800b7fe:	1c5a      	adds	r2, r3, #1
 800b800:	687b      	ldr	r3, [r7, #4]
 800b802:	651a      	str	r2, [r3, #80]	; 0x50

            /* Increment the IP receive packets dropped count.  */
            ip_ptr -> nx_ip_receive_packets_dropped++;
 800b804:	687b      	ldr	r3, [r7, #4]
 800b806:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 800b808:	1c5a      	adds	r2, r3, #1
 800b80a:	687b      	ldr	r3, [r7, #4]
 800b80c:	64da      	str	r2, [r3, #76]	; 0x4c
#endif

            /* Checksum error, just release it.  */
            _nx_packet_release(packet_ptr);
 800b80e:	6838      	ldr	r0, [r7, #0]
 800b810:	f000 fdfa 	bl	800c408 <_nx_packet_release>

            /* The function is complete, just return!  */
            return;
 800b814:	e190      	b.n	800bb38 <_nx_ipv4_packet_receive+0x4a4>
    /* IP receive checksum processing is disabled... just check for and remove if
       necessary the IP option words.  */

    /* Endian swapping logic.  If NX_LITTLE_ENDIAN is specified, these macros will
       swap the endian of the IP header.  */
    NX_CHANGE_ULONG_ENDIAN(ip_header_ptr -> nx_ip_header_word_0);
 800b816:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 800b818:	681b      	ldr	r3, [r3, #0]
 800b81a:	ba1a      	rev	r2, r3
 800b81c:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 800b81e:	601a      	str	r2, [r3, #0]
    NX_CHANGE_ULONG_ENDIAN(ip_header_ptr -> nx_ip_header_word_1);
 800b820:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 800b822:	685b      	ldr	r3, [r3, #4]
 800b824:	ba1a      	rev	r2, r3
 800b826:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 800b828:	605a      	str	r2, [r3, #4]
    NX_CHANGE_ULONG_ENDIAN(ip_header_ptr -> nx_ip_header_word_2);
 800b82a:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 800b82c:	689b      	ldr	r3, [r3, #8]
 800b82e:	ba1a      	rev	r2, r3
 800b830:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 800b832:	609a      	str	r2, [r3, #8]
    NX_CHANGE_ULONG_ENDIAN(ip_header_ptr -> nx_ip_header_source_ip);
 800b834:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 800b836:	68db      	ldr	r3, [r3, #12]
 800b838:	ba1a      	rev	r2, r3
 800b83a:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 800b83c:	60da      	str	r2, [r3, #12]
    NX_CHANGE_ULONG_ENDIAN(ip_header_ptr -> nx_ip_header_destination_ip);
 800b83e:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 800b840:	691b      	ldr	r3, [r3, #16]
 800b842:	ba1a      	rev	r2, r3
 800b844:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 800b846:	611a      	str	r2, [r3, #16]
    }
#endif /* NX_ENABLE_SOURCE_ADDRESS_CHECK */

    /* Determine if there are options in the IP header that make the length greater
       than the default length.  */
    if (ip_header_length > NX_IP_NORMAL_LENGTH)
 800b848:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800b84a:	2b05      	cmp	r3, #5
 800b84c:	d949      	bls.n	800b8e2 <_nx_ipv4_packet_receive+0x24e>
    {

        /* Process the IPv4 option.  */
        option_processed = _nx_ipv4_option_process(ip_ptr, packet_ptr);
 800b84e:	6839      	ldr	r1, [r7, #0]
 800b850:	6878      	ldr	r0, [r7, #4]
 800b852:	f7ff fe55 	bl	800b500 <_nx_ipv4_option_process>
 800b856:	62b8      	str	r0, [r7, #40]	; 0x28

        /* Check the status.  */
        if (option_processed == NX_FALSE)
 800b858:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800b85a:	2b00      	cmp	r3, #0
 800b85c:	d108      	bne.n	800b870 <_nx_ipv4_packet_receive+0x1dc>
        {

#ifndef NX_DISABLE_IP_INFO

            /* Increment the IP receive packets dropped count.  */
            ip_ptr -> nx_ip_receive_packets_dropped++;
 800b85e:	687b      	ldr	r3, [r7, #4]
 800b860:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 800b862:	1c5a      	adds	r2, r3, #1
 800b864:	687b      	ldr	r3, [r7, #4]
 800b866:	64da      	str	r2, [r3, #76]	; 0x4c
#endif

            /* IPv4 option error, toss the packet!  */
            _nx_packet_release(packet_ptr);
 800b868:	6838      	ldr	r0, [r7, #0]
 800b86a:	f000 fdcd 	bl	800c408 <_nx_packet_release>

            /* In all cases, receive processing is finished.  Return to caller.  */
            return;
 800b86e:	e163      	b.n	800bb38 <_nx_ipv4_packet_receive+0x4a4>
        }

        /* Setup a pointer to the last option word.  */
        word_ptr = ((ULONG *)((VOID *)ip_header_ptr)) + ip_header_length - 1;
 800b870:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 800b872:	f06f 4340 	mvn.w	r3, #3221225472	; 0xc0000000
 800b876:	4413      	add	r3, r2
 800b878:	009b      	lsls	r3, r3, #2
 800b87a:	6cba      	ldr	r2, [r7, #72]	; 0x48
 800b87c:	4413      	add	r3, r2
 800b87e:	627b      	str	r3, [r7, #36]	; 0x24

        /* Remove the option words prior to handling the IP header.  */
        *word_ptr-- = ip_header_ptr -> nx_ip_header_destination_ip;
 800b880:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800b882:	1f1a      	subs	r2, r3, #4
 800b884:	627a      	str	r2, [r7, #36]	; 0x24
 800b886:	6cba      	ldr	r2, [r7, #72]	; 0x48
 800b888:	6912      	ldr	r2, [r2, #16]
 800b88a:	601a      	str	r2, [r3, #0]
        *word_ptr-- = ip_header_ptr -> nx_ip_header_source_ip;
 800b88c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800b88e:	1f1a      	subs	r2, r3, #4
 800b890:	627a      	str	r2, [r7, #36]	; 0x24
 800b892:	6cba      	ldr	r2, [r7, #72]	; 0x48
 800b894:	68d2      	ldr	r2, [r2, #12]
 800b896:	601a      	str	r2, [r3, #0]
        *word_ptr-- = ip_header_ptr -> nx_ip_header_word_2;
 800b898:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800b89a:	1f1a      	subs	r2, r3, #4
 800b89c:	627a      	str	r2, [r7, #36]	; 0x24
 800b89e:	6cba      	ldr	r2, [r7, #72]	; 0x48
 800b8a0:	6892      	ldr	r2, [r2, #8]
 800b8a2:	601a      	str	r2, [r3, #0]
        *word_ptr-- = ip_header_ptr -> nx_ip_header_word_1;
 800b8a4:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800b8a6:	1f1a      	subs	r2, r3, #4
 800b8a8:	627a      	str	r2, [r7, #36]	; 0x24
 800b8aa:	6cba      	ldr	r2, [r7, #72]	; 0x48
 800b8ac:	6852      	ldr	r2, [r2, #4]
 800b8ae:	601a      	str	r2, [r3, #0]
        *word_ptr = (ULONG)(((ip_header_ptr -> nx_ip_header_word_0) & (~NX_IP_LENGTH_MASK)) | NX_IP_VERSION);
 800b8b0:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 800b8b2:	681b      	ldr	r3, [r3, #0]
 800b8b4:	f023 439e 	bic.w	r3, r3, #1325400064	; 0x4f000000
 800b8b8:	f043 428a 	orr.w	r2, r3, #1157627904	; 0x45000000
 800b8bc:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800b8be:	601a      	str	r2, [r3, #0]

        /* Update the ip_header_ptr and the packet and the packet prepend pointer, ip header pointer and length.  */
        /*lint -e{929} -e{740} -e{826} suppress cast from pointer to pointer, since it is necessary  */
        ip_header_ptr =  (NX_IPV4_HEADER *)word_ptr;
 800b8c0:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800b8c2:	64bb      	str	r3, [r7, #72]	; 0x48

        /*lint -e{928} suppress cast from pointer to pointer, since it is necessary  */
        packet_ptr -> nx_packet_prepend_ptr = (UCHAR *)word_ptr;
 800b8c4:	683b      	ldr	r3, [r7, #0]
 800b8c6:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 800b8c8:	609a      	str	r2, [r3, #8]
        packet_ptr -> nx_packet_ip_header = packet_ptr -> nx_packet_prepend_ptr;
 800b8ca:	683b      	ldr	r3, [r7, #0]
 800b8cc:	689a      	ldr	r2, [r3, #8]
 800b8ce:	683b      	ldr	r3, [r7, #0]
 800b8d0:	635a      	str	r2, [r3, #52]	; 0x34
        packet_ptr -> nx_packet_length = packet_ptr -> nx_packet_length - ((ip_header_length -  NX_IP_NORMAL_LENGTH) * (ULONG)sizeof(ULONG));
 800b8d2:	683b      	ldr	r3, [r7, #0]
 800b8d4:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 800b8d6:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800b8d8:	3b05      	subs	r3, #5
 800b8da:	009b      	lsls	r3, r3, #2
 800b8dc:	1ad2      	subs	r2, r2, r3
 800b8de:	683b      	ldr	r3, [r7, #0]
 800b8e0:	625a      	str	r2, [r3, #36]	; 0x24
    }
#endif

    /* Determine if the IP datagram is for this IP address or a broadcast IP on this
       network.  */
    if ((ip_header_ptr -> nx_ip_header_destination_ip == if_ptr -> nx_interface_ip_address) ||
 800b8e2:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 800b8e4:	691a      	ldr	r2, [r3, #16]
 800b8e6:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800b8e8:	695b      	ldr	r3, [r3, #20]
 800b8ea:	429a      	cmp	r2, r3
 800b8ec:	d02f      	beq.n	800b94e <_nx_ipv4_packet_receive+0x2ba>

        /* Check for incoming IP address of zero.  Incoming IP address of zero should
           be received regardless of our current IP address.  */
        (ip_header_ptr -> nx_ip_header_destination_ip == 0) ||
 800b8ee:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 800b8f0:	691b      	ldr	r3, [r3, #16]
    if ((ip_header_ptr -> nx_ip_header_destination_ip == if_ptr -> nx_interface_ip_address) ||
 800b8f2:	2b00      	cmp	r3, #0
 800b8f4:	d02b      	beq.n	800b94e <_nx_ipv4_packet_receive+0x2ba>

        /* Check for IP broadcast.  */
        (((ip_header_ptr -> nx_ip_header_destination_ip & if_ptr -> nx_interface_ip_network_mask) ==
 800b8f6:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 800b8f8:	691a      	ldr	r2, [r3, #16]
 800b8fa:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800b8fc:	699b      	ldr	r3, [r3, #24]
 800b8fe:	401a      	ands	r2, r3
          if_ptr -> nx_interface_ip_network) &&
 800b900:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800b902:	69db      	ldr	r3, [r3, #28]
        (ip_header_ptr -> nx_ip_header_destination_ip == 0) ||
 800b904:	429a      	cmp	r2, r3
 800b906:	d10a      	bne.n	800b91e <_nx_ipv4_packet_receive+0x28a>
         ((ip_header_ptr -> nx_ip_header_destination_ip & ~(if_ptr -> nx_interface_ip_network_mask)) ==
 800b908:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 800b90a:	691a      	ldr	r2, [r3, #16]
 800b90c:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800b90e:	699b      	ldr	r3, [r3, #24]
 800b910:	43db      	mvns	r3, r3
 800b912:	401a      	ands	r2, r3
          ~(if_ptr -> nx_interface_ip_network_mask))) ||
 800b914:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800b916:	699b      	ldr	r3, [r3, #24]
 800b918:	43db      	mvns	r3, r3
          if_ptr -> nx_interface_ip_network) &&
 800b91a:	429a      	cmp	r2, r3
 800b91c:	d017      	beq.n	800b94e <_nx_ipv4_packet_receive+0x2ba>

        /* Check for limited broadcast.  */
        (ip_header_ptr -> nx_ip_header_destination_ip == NX_IP_LIMITED_BROADCAST) ||
 800b91e:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 800b920:	691b      	ldr	r3, [r3, #16]
          ~(if_ptr -> nx_interface_ip_network_mask))) ||
 800b922:	f1b3 3fff 	cmp.w	r3, #4294967295
 800b926:	d012      	beq.n	800b94e <_nx_ipv4_packet_receive+0x2ba>

        /* Check for loopback address.  */
        ((ip_header_ptr -> nx_ip_header_destination_ip >= NX_IP_LOOPBACK_FIRST) &&
 800b928:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 800b92a:	691b      	ldr	r3, [r3, #16]
        (ip_header_ptr -> nx_ip_header_destination_ip == NX_IP_LIMITED_BROADCAST) ||
 800b92c:	f1b3 4ffe 	cmp.w	r3, #2130706432	; 0x7f000000
 800b930:	d303      	bcc.n	800b93a <_nx_ipv4_packet_receive+0x2a6>
         (ip_header_ptr -> nx_ip_header_destination_ip <= NX_IP_LOOPBACK_LAST)) ||
 800b932:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 800b934:	691b      	ldr	r3, [r3, #16]
        ((ip_header_ptr -> nx_ip_header_destination_ip >= NX_IP_LOOPBACK_FIRST) &&
 800b936:	2b00      	cmp	r3, #0
 800b938:	da09      	bge.n	800b94e <_nx_ipv4_packet_receive+0x2ba>

        /* Check for valid Multicast address.  */
        (_nx_igmp_multicast_check(ip_ptr, ip_header_ptr -> nx_ip_header_destination_ip, if_ptr)))
 800b93a:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 800b93c:	691b      	ldr	r3, [r3, #16]
 800b93e:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 800b940:	4619      	mov	r1, r3
 800b942:	6878      	ldr	r0, [r7, #4]
 800b944:	f7fe f8d6 	bl	8009af4 <_nx_igmp_multicast_check>
 800b948:	4603      	mov	r3, r0
         (ip_header_ptr -> nx_ip_header_destination_ip <= NX_IP_LOOPBACK_LAST)) ||
 800b94a:	2b00      	cmp	r3, #0
 800b94c:	d076      	beq.n	800ba3c <_nx_ipv4_packet_receive+0x3a8>
    {

        /* Determine if this packet is fragmented.  If so, place it on the deferred processing
           queue.  The input packet will then be processed by an IP system thread.  */
        if (ip_header_ptr -> nx_ip_header_word_1 & NX_IP_FRAGMENT_MASK)
 800b94e:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 800b950:	685b      	ldr	r3, [r3, #4]
 800b952:	f3c3 030d 	ubfx	r3, r3, #0, #14
 800b956:	2b00      	cmp	r3, #0
 800b958:	d046      	beq.n	800b9e8 <_nx_ipv4_packet_receive+0x354>
        {

#ifndef NX_DISABLE_IP_INFO

            /* Increment the IP receive fragments count.  */
            ip_ptr -> nx_ip_total_fragments_received++;
 800b95a:	687b      	ldr	r3, [r7, #4]
 800b95c:	6e9b      	ldr	r3, [r3, #104]	; 0x68
 800b95e:	1c5a      	adds	r2, r3, #1
 800b960:	687b      	ldr	r3, [r7, #4]
 800b962:	669a      	str	r2, [r3, #104]	; 0x68
#ifdef NX_ENABLE_LOW_WATERMARK
            if (ip_ptr -> nx_ip_fragment_assembly &&
                (packet_ptr -> nx_packet_pool_owner -> nx_packet_pool_available >=
                 packet_ptr -> nx_packet_pool_owner -> nx_packet_pool_low_watermark))
#else
            if (ip_ptr -> nx_ip_fragment_assembly)
 800b964:	687b      	ldr	r3, [r7, #4]
 800b966:	f8d3 32a0 	ldr.w	r3, [r3, #672]	; 0x2a0
 800b96a:	2b00      	cmp	r3, #0
 800b96c:	d033      	beq.n	800b9d6 <_nx_ipv4_packet_receive+0x342>
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 800b96e:	f3ef 8310 	mrs	r3, PRIMASK
 800b972:	613b      	str	r3, [r7, #16]
    return(posture);
 800b974:	693b      	ldr	r3, [r7, #16]
    int_posture = __get_interrupt_posture();
 800b976:	60fb      	str	r3, [r7, #12]
    __asm__ volatile ("CPSID i" : : : "memory");
 800b978:	b672      	cpsid	i
    return(int_posture);
 800b97a:	68fb      	ldr	r3, [r7, #12]

                /* Yes, fragmenting is available.  Place the packet on the incoming
                   fragment queue.  */

                /* Disable interrupts.  */
                TX_DISABLE
 800b97c:	617b      	str	r3, [r7, #20]

                /* Determine if the queue is empty.  */
                if (ip_ptr -> nx_ip_received_fragment_head)
 800b97e:	687b      	ldr	r3, [r7, #4]
 800b980:	f8d3 32ac 	ldr.w	r3, [r3, #684]	; 0x2ac
 800b984:	2b00      	cmp	r3, #0
 800b986:	d00c      	beq.n	800b9a2 <_nx_ipv4_packet_receive+0x30e>
                {

                    /* Reassembly queue is not empty, add this packet to the end of
                       the queue.  */
                    (ip_ptr -> nx_ip_received_fragment_tail) -> nx_packet_queue_next =  packet_ptr;
 800b988:	687b      	ldr	r3, [r7, #4]
 800b98a:	f8d3 32b0 	ldr.w	r3, [r3, #688]	; 0x2b0
 800b98e:	683a      	ldr	r2, [r7, #0]
 800b990:	61da      	str	r2, [r3, #28]
                    packet_ptr -> nx_packet_queue_next =  NX_NULL;
 800b992:	683b      	ldr	r3, [r7, #0]
 800b994:	2200      	movs	r2, #0
 800b996:	61da      	str	r2, [r3, #28]
                    ip_ptr -> nx_ip_received_fragment_tail =  packet_ptr;
 800b998:	687b      	ldr	r3, [r7, #4]
 800b99a:	683a      	ldr	r2, [r7, #0]
 800b99c:	f8c3 22b0 	str.w	r2, [r3, #688]	; 0x2b0
 800b9a0:	e00a      	b.n	800b9b8 <_nx_ipv4_packet_receive+0x324>
                else
                {

                    /* Reassembly queue is empty.  Just setup the head and tail pointers
                       to point to this packet.  */
                    ip_ptr -> nx_ip_received_fragment_head =  packet_ptr;
 800b9a2:	687b      	ldr	r3, [r7, #4]
 800b9a4:	683a      	ldr	r2, [r7, #0]
 800b9a6:	f8c3 22ac 	str.w	r2, [r3, #684]	; 0x2ac
                    ip_ptr -> nx_ip_received_fragment_tail =  packet_ptr;
 800b9aa:	687b      	ldr	r3, [r7, #4]
 800b9ac:	683a      	ldr	r2, [r7, #0]
 800b9ae:	f8c3 22b0 	str.w	r2, [r3, #688]	; 0x2b0
                    packet_ptr -> nx_packet_queue_next =      NX_NULL;
 800b9b2:	683b      	ldr	r3, [r7, #0]
 800b9b4:	2200      	movs	r2, #0
 800b9b6:	61da      	str	r2, [r3, #28]
 800b9b8:	697b      	ldr	r3, [r7, #20]
 800b9ba:	60bb      	str	r3, [r7, #8]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 800b9bc:	68bb      	ldr	r3, [r7, #8]
 800b9be:	f383 8810 	msr	PRIMASK, r3
}
 800b9c2:	bf00      	nop
                /* Restore interrupts.  */
                TX_RESTORE

#ifndef NX_FRAGMENT_IMMEDIATE_ASSEMBLY
                /* Wakeup IP helper thread to process the IP fragment re-assembly.  */
                tx_event_flags_set(&(ip_ptr -> nx_ip_events), NX_IP_UNFRAG_EVENT, TX_OR);
 800b9c4:	687b      	ldr	r3, [r7, #4]
 800b9c6:	f503 7313 	add.w	r3, r3, #588	; 0x24c
 800b9ca:	2200      	movs	r2, #0
 800b9cc:	2102      	movs	r1, #2
 800b9ce:	4618      	mov	r0, r3
 800b9d0:	f006 fd8c 	bl	80124ec <_tx_event_flags_set>
                /* Fragmentation has not been enabled, toss the packet!  */
                _nx_packet_release(packet_ptr);
            }

            /* In all cases, receive processing is finished.  Return to caller.  */
            return;
 800b9d4:	e0b0      	b.n	800bb38 <_nx_ipv4_packet_receive+0x4a4>
                ip_ptr -> nx_ip_receive_packets_dropped++;
 800b9d6:	687b      	ldr	r3, [r7, #4]
 800b9d8:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 800b9da:	1c5a      	adds	r2, r3, #1
 800b9dc:	687b      	ldr	r3, [r7, #4]
 800b9de:	64da      	str	r2, [r3, #76]	; 0x4c
                _nx_packet_release(packet_ptr);
 800b9e0:	6838      	ldr	r0, [r7, #0]
 800b9e2:	f000 fd11 	bl	800c408 <_nx_packet_release>
            return;
 800b9e6:	e0a7      	b.n	800bb38 <_nx_ipv4_packet_receive+0x4a4>
        }

        /* Determine what protocol the current IP datagram is.  */
        protocol =  (ip_header_ptr -> nx_ip_header_word_2 >> 16) & 0xFF;
 800b9e8:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 800b9ea:	689b      	ldr	r3, [r3, #8]
 800b9ec:	0c1b      	lsrs	r3, r3, #16
 800b9ee:	b2db      	uxtb	r3, r3
 800b9f0:	623b      	str	r3, [r7, #32]

        /* Remove the IP header from the packet.  */
        packet_ptr -> nx_packet_prepend_ptr =  packet_ptr -> nx_packet_prepend_ptr + sizeof(NX_IPV4_HEADER);
 800b9f2:	683b      	ldr	r3, [r7, #0]
 800b9f4:	689b      	ldr	r3, [r3, #8]
 800b9f6:	f103 0214 	add.w	r2, r3, #20
 800b9fa:	683b      	ldr	r3, [r7, #0]
 800b9fc:	609a      	str	r2, [r3, #8]

        /* Adjust the length.  */
        packet_ptr -> nx_packet_length =  packet_ptr -> nx_packet_length - (ULONG)sizeof(NX_IPV4_HEADER);
 800b9fe:	683b      	ldr	r3, [r7, #0]
 800ba00:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800ba02:	f1a3 0214 	sub.w	r2, r3, #20
 800ba06:	683b      	ldr	r3, [r7, #0]
 800ba08:	625a      	str	r2, [r3, #36]	; 0x24

#ifndef NX_DISABLE_IP_INFO

        /* Increment the number of packets delivered.  */
        ip_ptr -> nx_ip_total_packets_delivered++;
 800ba0a:	687b      	ldr	r3, [r7, #4]
 800ba0c:	6a1b      	ldr	r3, [r3, #32]
 800ba0e:	1c5a      	adds	r2, r3, #1
 800ba10:	687b      	ldr	r3, [r7, #4]
 800ba12:	621a      	str	r2, [r3, #32]

        /* Increment the IP packet bytes received (not including the header).  */
        ip_ptr -> nx_ip_total_bytes_received +=  packet_ptr -> nx_packet_length;
 800ba14:	687b      	ldr	r3, [r7, #4]
 800ba16:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 800ba18:	683b      	ldr	r3, [r7, #0]
 800ba1a:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800ba1c:	441a      	add	r2, r3
 800ba1e:	687b      	ldr	r3, [r7, #4]
 800ba20:	625a      	str	r2, [r3, #36]	; 0x24
#endif
        if (_nx_ip_dispatch_process(ip_ptr, packet_ptr, (UINT)protocol))
 800ba22:	6a3a      	ldr	r2, [r7, #32]
 800ba24:	6839      	ldr	r1, [r7, #0]
 800ba26:	6878      	ldr	r0, [r7, #4]
 800ba28:	f7fe fb7c 	bl	800a124 <_nx_ip_dispatch_process>
 800ba2c:	4603      	mov	r3, r0
 800ba2e:	2b00      	cmp	r3, #0
 800ba30:	f000 8082 	beq.w	800bb38 <_nx_ipv4_packet_receive+0x4a4>
        {
            _nx_packet_release(packet_ptr);
 800ba34:	6838      	ldr	r0, [r7, #0]
 800ba36:	f000 fce7 	bl	800c408 <_nx_packet_release>
        if (_nx_ip_dispatch_process(ip_ptr, packet_ptr, (UINT)protocol))
 800ba3a:	e07d      	b.n	800bb38 <_nx_ipv4_packet_receive+0x4a4>
    }
    /* Try to receive the DHCP message before release this packet.
       NetX should receive the unicast DHCP message when interface IP address is zero.  */

    /* Check if this IP interface has IP address.  */
    else if (if_ptr -> nx_interface_ip_address == 0)
 800ba3c:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800ba3e:	695b      	ldr	r3, [r3, #20]
 800ba40:	2b00      	cmp	r3, #0
 800ba42:	d15a      	bne.n	800bafa <_nx_ipv4_packet_receive+0x466>
    {

        /* Determine what protocol the current IP datagram is.  */
        protocol =  ip_header_ptr -> nx_ip_header_word_2 & NX_IP_PROTOCOL_MASK;
 800ba44:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 800ba46:	689b      	ldr	r3, [r3, #8]
 800ba48:	f403 037f 	and.w	r3, r3, #16711680	; 0xff0000
 800ba4c:	623b      	str	r3, [r7, #32]

        /* Check if this packet is UDP message.  */
        if (protocol == NX_IP_UDP)
 800ba4e:	6a3b      	ldr	r3, [r7, #32]
 800ba50:	f5b3 1f88 	cmp.w	r3, #1114112	; 0x110000
 800ba54:	d137      	bne.n	800bac6 <_nx_ipv4_packet_receive+0x432>
        {

            /* Remove the IP header from the packet.  */
            packet_ptr -> nx_packet_prepend_ptr =  packet_ptr -> nx_packet_prepend_ptr + sizeof(NX_IPV4_HEADER);
 800ba56:	683b      	ldr	r3, [r7, #0]
 800ba58:	689b      	ldr	r3, [r3, #8]
 800ba5a:	f103 0214 	add.w	r2, r3, #20
 800ba5e:	683b      	ldr	r3, [r7, #0]
 800ba60:	609a      	str	r2, [r3, #8]

            /* Adjust the length.  */
            packet_ptr -> nx_packet_length =  packet_ptr -> nx_packet_length - (ULONG)sizeof(NX_IPV4_HEADER);
 800ba62:	683b      	ldr	r3, [r7, #0]
 800ba64:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800ba66:	f1a3 0214 	sub.w	r2, r3, #20
 800ba6a:	683b      	ldr	r3, [r7, #0]
 800ba6c:	625a      	str	r2, [r3, #36]	; 0x24

#ifndef NX_DISABLE_IP_INFO

            /* Increment the number of packets delivered.  */
            ip_ptr -> nx_ip_total_packets_delivered++;
 800ba6e:	687b      	ldr	r3, [r7, #4]
 800ba70:	6a1b      	ldr	r3, [r3, #32]
 800ba72:	1c5a      	adds	r2, r3, #1
 800ba74:	687b      	ldr	r3, [r7, #4]
 800ba76:	621a      	str	r2, [r3, #32]

            /* Increment the IP packet bytes received (not including the header).  */
            ip_ptr -> nx_ip_total_bytes_received +=  packet_ptr -> nx_packet_length;
 800ba78:	687b      	ldr	r3, [r7, #4]
 800ba7a:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 800ba7c:	683b      	ldr	r3, [r7, #0]
 800ba7e:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800ba80:	441a      	add	r2, r3
 800ba82:	687b      	ldr	r3, [r7, #4]
 800ba84:	625a      	str	r2, [r3, #36]	; 0x24
#endif

            /* Pickup the pointer to the head of the UDP packet.  */
            /*lint -e{927} -e{826} suppress cast of pointer to pointer, since it is necessary  */
            udp_header_ptr =  (NX_UDP_HEADER *)packet_ptr -> nx_packet_prepend_ptr;
 800ba86:	683b      	ldr	r3, [r7, #0]
 800ba88:	689b      	ldr	r3, [r3, #8]
 800ba8a:	61fb      	str	r3, [r7, #28]

            /* Endian swapping logic.  If NX_LITTLE_ENDIAN is specified, these macros will
               swap the endian of the UDP header.  */
            NX_CHANGE_ULONG_ENDIAN(udp_header_ptr -> nx_udp_header_word_0);
 800ba8c:	69fb      	ldr	r3, [r7, #28]
 800ba8e:	681b      	ldr	r3, [r3, #0]
 800ba90:	ba1a      	rev	r2, r3
 800ba92:	69fb      	ldr	r3, [r7, #28]
 800ba94:	601a      	str	r2, [r3, #0]

            /* Pickup the destination UDP port.  */
            dest_port =  (UINT)(udp_header_ptr -> nx_udp_header_word_0 & NX_LOWER_16_MASK);
 800ba96:	69fb      	ldr	r3, [r7, #28]
 800ba98:	681b      	ldr	r3, [r3, #0]
 800ba9a:	b29b      	uxth	r3, r3
 800ba9c:	61bb      	str	r3, [r7, #24]

            /* Endian swapping logic.  If NX_LITTLE_ENDIAN is specified, these macros will
               swap the endian of the UDP header.  */
            NX_CHANGE_ULONG_ENDIAN(udp_header_ptr -> nx_udp_header_word_0);
 800ba9e:	69fb      	ldr	r3, [r7, #28]
 800baa0:	681b      	ldr	r3, [r3, #0]
 800baa2:	ba1a      	rev	r2, r3
 800baa4:	69fb      	ldr	r3, [r7, #28]
 800baa6:	601a      	str	r2, [r3, #0]

            /* Check if this packet is DHCP message.  */
            if (dest_port == 68)
 800baa8:	69bb      	ldr	r3, [r7, #24]
 800baaa:	2b44      	cmp	r3, #68	; 0x44
 800baac:	d10b      	bne.n	800bac6 <_nx_ipv4_packet_receive+0x432>
            {
                if (ip_ptr -> nx_ip_udp_packet_receive)
 800baae:	687b      	ldr	r3, [r7, #4]
 800bab0:	f8d3 3408 	ldr.w	r3, [r3, #1032]	; 0x408
 800bab4:	2b00      	cmp	r3, #0
 800bab6:	d006      	beq.n	800bac6 <_nx_ipv4_packet_receive+0x432>
                {

                    /* Yes, dispatch it to the appropriate UDP handler if present.  */
                    (ip_ptr -> nx_ip_udp_packet_receive)(ip_ptr, packet_ptr);
 800bab8:	687b      	ldr	r3, [r7, #4]
 800baba:	f8d3 3408 	ldr.w	r3, [r3, #1032]	; 0x408
 800babe:	6839      	ldr	r1, [r7, #0]
 800bac0:	6878      	ldr	r0, [r7, #4]
 800bac2:	4798      	blx	r3

                    return;
 800bac4:	e038      	b.n	800bb38 <_nx_ipv4_packet_receive+0x4a4>
        }

#ifndef NX_DISABLE_IP_INFO

        /* Decrement the number of packets delivered.  */
        ip_ptr -> nx_ip_total_packets_delivered--;
 800bac6:	687b      	ldr	r3, [r7, #4]
 800bac8:	6a1b      	ldr	r3, [r3, #32]
 800baca:	1e5a      	subs	r2, r3, #1
 800bacc:	687b      	ldr	r3, [r7, #4]
 800bace:	621a      	str	r2, [r3, #32]

        /* Decrement the IP packet bytes received (not including the header).  */
        ip_ptr -> nx_ip_total_bytes_received -=  packet_ptr -> nx_packet_length;
 800bad0:	687b      	ldr	r3, [r7, #4]
 800bad2:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 800bad4:	683b      	ldr	r3, [r7, #0]
 800bad6:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800bad8:	1ad2      	subs	r2, r2, r3
 800bada:	687b      	ldr	r3, [r7, #4]
 800badc:	625a      	str	r2, [r3, #36]	; 0x24

        /* Increment the IP invalid address error.  */
        ip_ptr -> nx_ip_invalid_receive_address++;
 800bade:	687b      	ldr	r3, [r7, #4]
 800bae0:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 800bae2:	1c5a      	adds	r2, r3, #1
 800bae4:	687b      	ldr	r3, [r7, #4]
 800bae6:	63da      	str	r2, [r3, #60]	; 0x3c

        /* Increment the IP receive packets dropped count.  */
        ip_ptr -> nx_ip_receive_packets_dropped++;
 800bae8:	687b      	ldr	r3, [r7, #4]
 800baea:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 800baec:	1c5a      	adds	r2, r3, #1
 800baee:	687b      	ldr	r3, [r7, #4]
 800baf0:	64da      	str	r2, [r3, #76]	; 0x4c
#endif

        /* Toss the IP packet since we don't know what to do with it!  */
        _nx_packet_release(packet_ptr);
 800baf2:	6838      	ldr	r0, [r7, #0]
 800baf4:	f000 fc88 	bl	800c408 <_nx_packet_release>

        /* Return to caller.  */
        return;
 800baf8:	e01e      	b.n	800bb38 <_nx_ipv4_packet_receive+0x4a4>
    }
    else if (ip_ptr -> nx_ip_forward_packet_process)
 800bafa:	687b      	ldr	r3, [r7, #4]
 800bafc:	f8d3 3130 	ldr.w	r3, [r3, #304]	; 0x130
 800bb00:	2b00      	cmp	r3, #0
 800bb02:	d00b      	beq.n	800bb1c <_nx_ipv4_packet_receive+0x488>
    {

#ifndef NX_DISABLE_IP_INFO

        /* Increment the IP packets forwarded counter.  */
        ip_ptr -> nx_ip_packets_forwarded++;
 800bb04:	687b      	ldr	r3, [r7, #4]
 800bb06:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 800bb08:	1c5a      	adds	r2, r3, #1
 800bb0a:	687b      	ldr	r3, [r7, #4]
 800bb0c:	629a      	str	r2, [r3, #40]	; 0x28
#endif

        /* The packet is not for this IP instance so call the
           forward IP packet processing routine.  */
        (ip_ptr -> nx_ip_forward_packet_process)(ip_ptr, packet_ptr);
 800bb0e:	687b      	ldr	r3, [r7, #4]
 800bb10:	f8d3 3130 	ldr.w	r3, [r3, #304]	; 0x130
 800bb14:	6839      	ldr	r1, [r7, #0]
 800bb16:	6878      	ldr	r0, [r7, #4]
 800bb18:	4798      	blx	r3
 800bb1a:	e00d      	b.n	800bb38 <_nx_ipv4_packet_receive+0x4a4>
    {

#ifndef NX_DISABLE_IP_INFO

        /* Increment the IP invalid address error.  */
        ip_ptr -> nx_ip_invalid_receive_address++;
 800bb1c:	687b      	ldr	r3, [r7, #4]
 800bb1e:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 800bb20:	1c5a      	adds	r2, r3, #1
 800bb22:	687b      	ldr	r3, [r7, #4]
 800bb24:	63da      	str	r2, [r3, #60]	; 0x3c

        /* Increment the IP receive packets dropped count.  */
        ip_ptr -> nx_ip_receive_packets_dropped++;
 800bb26:	687b      	ldr	r3, [r7, #4]
 800bb28:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 800bb2a:	1c5a      	adds	r2, r3, #1
 800bb2c:	687b      	ldr	r3, [r7, #4]
 800bb2e:	64da      	str	r2, [r3, #76]	; 0x4c
#endif

        /* Toss the IP packet since we don't know what to do with it!  */
        _nx_packet_release(packet_ptr);
 800bb30:	6838      	ldr	r0, [r7, #0]
 800bb32:	f000 fc69 	bl	800c408 <_nx_packet_release>

        /* Return to caller.  */
        return;
 800bb36:	bf00      	nop
    }
}
 800bb38:	3750      	adds	r7, #80	; 0x50
 800bb3a:	46bd      	mov	sp, r7
 800bb3c:	bd80      	pop	{r7, pc}
	...

0800bb40 <_nx_packet_allocate>:
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
UINT  _nx_packet_allocate(NX_PACKET_POOL *pool_ptr,  NX_PACKET **packet_ptr,
                          ULONG packet_type, ULONG wait_option)
{
 800bb40:	b580      	push	{r7, lr}
 800bb42:	b08c      	sub	sp, #48	; 0x30
 800bb44:	af00      	add	r7, sp, #0
 800bb46:	60f8      	str	r0, [r7, #12]
 800bb48:	60b9      	str	r1, [r7, #8]
 800bb4a:	607a      	str	r2, [r7, #4]
 800bb4c:	603b      	str	r3, [r7, #0]
TX_TRACE_BUFFER_ENTRY *trace_event;
ULONG                  trace_timestamp;
#endif

    /* Make sure the packet_type does not go beyond nx_packet_data_end. */
    if (pool_ptr -> nx_packet_pool_payload_size < packet_type)
 800bb4e:	68fb      	ldr	r3, [r7, #12]
 800bb50:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 800bb52:	687a      	ldr	r2, [r7, #4]
 800bb54:	429a      	cmp	r2, r3
 800bb56:	d901      	bls.n	800bb5c <_nx_packet_allocate+0x1c>
    {
        return(NX_INVALID_PARAMETERS);
 800bb58:	234d      	movs	r3, #77	; 0x4d
 800bb5a:	e0ae      	b.n	800bcba <_nx_packet_allocate+0x17a>
    }

    /* Set the return pointer to NULL initially.  */
    *packet_ptr =   NX_NULL;
 800bb5c:	68bb      	ldr	r3, [r7, #8]
 800bb5e:	2200      	movs	r2, #0
 800bb60:	601a      	str	r2, [r3, #0]
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 800bb62:	f3ef 8310 	mrs	r3, PRIMASK
 800bb66:	61fb      	str	r3, [r7, #28]
    return(posture);
 800bb68:	69fb      	ldr	r3, [r7, #28]
    int_posture = __get_interrupt_posture();
 800bb6a:	61bb      	str	r3, [r7, #24]
    __asm__ volatile ("CPSID i" : : : "memory");
 800bb6c:	b672      	cpsid	i
    return(int_posture);
 800bb6e:	69bb      	ldr	r3, [r7, #24]

    /* If trace is enabled, insert this event into the trace buffer.  */
    NX_TRACE_IN_LINE_INSERT(NX_TRACE_PACKET_ALLOCATE, pool_ptr, 0, packet_type, pool_ptr -> nx_packet_pool_available, NX_TRACE_PACKET_EVENTS, &trace_event, &trace_timestamp);

    /* Disable interrupts to get a packet from the pool.  */
    TX_DISABLE
 800bb70:	62bb      	str	r3, [r7, #40]	; 0x28

    /* Determine if there is an available packet.  */
    if (pool_ptr -> nx_packet_pool_available)
 800bb72:	68fb      	ldr	r3, [r7, #12]
 800bb74:	689b      	ldr	r3, [r3, #8]
 800bb76:	2b00      	cmp	r3, #0
 800bb78:	d03a      	beq.n	800bbf0 <_nx_packet_allocate+0xb0>
    {

        /* Yes, a packet is available.  Decrement the available count.  */
        pool_ptr -> nx_packet_pool_available--;
 800bb7a:	68fb      	ldr	r3, [r7, #12]
 800bb7c:	689b      	ldr	r3, [r3, #8]
 800bb7e:	1e5a      	subs	r2, r3, #1
 800bb80:	68fb      	ldr	r3, [r7, #12]
 800bb82:	609a      	str	r2, [r3, #8]

        /* Pickup the current packet pointer.  */
        work_ptr =  pool_ptr -> nx_packet_pool_available_list;
 800bb84:	68fb      	ldr	r3, [r7, #12]
 800bb86:	69db      	ldr	r3, [r3, #28]
 800bb88:	623b      	str	r3, [r7, #32]

        /* Modify the available list to point at the next packet in the pool. */
        pool_ptr -> nx_packet_pool_available_list =  work_ptr -> nx_packet_queue_next;
 800bb8a:	6a3b      	ldr	r3, [r7, #32]
 800bb8c:	69da      	ldr	r2, [r3, #28]
 800bb8e:	68fb      	ldr	r3, [r7, #12]
 800bb90:	61da      	str	r2, [r3, #28]

        /* Setup various fields for this packet.  */
        work_ptr -> nx_packet_queue_next =   NX_NULL;
 800bb92:	6a3b      	ldr	r3, [r7, #32]
 800bb94:	2200      	movs	r2, #0
 800bb96:	61da      	str	r2, [r3, #28]
#ifndef NX_DISABLE_PACKET_CHAIN
        work_ptr -> nx_packet_next =         NX_NULL;
 800bb98:	6a3b      	ldr	r3, [r7, #32]
 800bb9a:	2200      	movs	r2, #0
 800bb9c:	605a      	str	r2, [r3, #4]
        work_ptr -> nx_packet_last =         NX_NULL;
 800bb9e:	6a3b      	ldr	r3, [r7, #32]
 800bba0:	2200      	movs	r2, #0
 800bba2:	619a      	str	r2, [r3, #24]
#endif /* NX_DISABLE_PACKET_CHAIN */
        work_ptr -> nx_packet_length =       0;
 800bba4:	6a3b      	ldr	r3, [r7, #32]
 800bba6:	2200      	movs	r2, #0
 800bba8:	625a      	str	r2, [r3, #36]	; 0x24
        work_ptr -> nx_packet_prepend_ptr =  work_ptr -> nx_packet_data_start + packet_type;
 800bbaa:	6a3b      	ldr	r3, [r7, #32]
 800bbac:	691a      	ldr	r2, [r3, #16]
 800bbae:	687b      	ldr	r3, [r7, #4]
 800bbb0:	441a      	add	r2, r3
 800bbb2:	6a3b      	ldr	r3, [r7, #32]
 800bbb4:	609a      	str	r2, [r3, #8]
        work_ptr -> nx_packet_append_ptr =   work_ptr -> nx_packet_prepend_ptr;
 800bbb6:	6a3b      	ldr	r3, [r7, #32]
 800bbb8:	689a      	ldr	r2, [r3, #8]
 800bbba:	6a3b      	ldr	r3, [r7, #32]
 800bbbc:	60da      	str	r2, [r3, #12]
        work_ptr -> nx_packet_address.nx_packet_interface_ptr = NX_NULL;
 800bbbe:	6a3b      	ldr	r3, [r7, #32]
 800bbc0:	2200      	movs	r2, #0
 800bbc2:	631a      	str	r2, [r3, #48]	; 0x30
#ifdef NX_ENABLE_INTERFACE_CAPABILITY
        work_ptr -> nx_packet_interface_capability_flag = 0;
#endif /* NX_ENABLE_INTERFACE_CAPABILITY */
        /* Set the TCP queue to the value that indicates it has been allocated.  */
        /*lint -e{923} suppress cast of ULONG to pointer.  */
        work_ptr -> nx_packet_union_next.nx_packet_tcp_queue_next =  (NX_PACKET *)NX_PACKET_ALLOCATED;
 800bbc4:	6a3b      	ldr	r3, [r7, #32]
 800bbc6:	f04f 32aa 	mov.w	r2, #2863311530	; 0xaaaaaaaa
 800bbca:	621a      	str	r2, [r3, #32]
        work_ptr -> nx_packet_ipsec_sa_ptr = NX_NULL;
#endif /* NX_IPSEC_ENABLE */

#ifndef NX_DISABLE_IPV4
        /* Initialize the IP version field */
        work_ptr -> nx_packet_ip_version = NX_IP_VERSION_V4;
 800bbcc:	6a3b      	ldr	r3, [r7, #32]
 800bbce:	2204      	movs	r2, #4
 800bbd0:	f883 202c 	strb.w	r2, [r3, #44]	; 0x2c
#endif /* !NX_DISABLE_IPV4  */

        /* Initialize the IP identification flag.  */
        work_ptr -> nx_packet_identical_copy = NX_FALSE;
 800bbd4:	6a3b      	ldr	r3, [r7, #32]
 800bbd6:	2200      	movs	r2, #0
 800bbd8:	f883 202d 	strb.w	r2, [r3, #45]	; 0x2d

        /* Initialize the IP header length. */
        work_ptr -> nx_packet_ip_header_length = 0;
 800bbdc:	6a3b      	ldr	r3, [r7, #32]
 800bbde:	2200      	movs	r2, #0
 800bbe0:	f883 202e 	strb.w	r2, [r3, #46]	; 0x2e
#ifdef NX_ENABLE_THREAD
        work_ptr -> nx_packet_type = 0;
#endif /* NX_ENABLE_THREAD  */

        /* Place the new packet pointer in the return destination.  */
        *packet_ptr =  work_ptr;
 800bbe4:	68bb      	ldr	r3, [r7, #8]
 800bbe6:	6a3a      	ldr	r2, [r7, #32]
 800bbe8:	601a      	str	r2, [r3, #0]

        /* Set status to success.  */
        status =  NX_SUCCESS;
 800bbea:	2300      	movs	r3, #0
 800bbec:	62fb      	str	r3, [r7, #44]	; 0x2c
 800bbee:	e05d      	b.n	800bcac <_nx_packet_allocate+0x16c>
    else
    {

#ifndef NX_DISABLE_PACKET_INFO
        /* Increment the packet pool empty request count.  */
        pool_ptr -> nx_packet_pool_empty_requests++;
 800bbf0:	68fb      	ldr	r3, [r7, #12]
 800bbf2:	691b      	ldr	r3, [r3, #16]
 800bbf4:	1c5a      	adds	r2, r3, #1
 800bbf6:	68fb      	ldr	r3, [r7, #12]
 800bbf8:	611a      	str	r2, [r3, #16]
#endif

        /* Determine if the request specifies suspension.  */
        if (wait_option)
 800bbfa:	683b      	ldr	r3, [r7, #0]
 800bbfc:	2b00      	cmp	r3, #0
 800bbfe:	d053      	beq.n	800bca8 <_nx_packet_allocate+0x168>

            /* Prepare for suspension of this thread.  */

#ifndef NX_DISABLE_PACKET_INFO
            /* Increment the packet pool empty request suspension count.  */
            pool_ptr -> nx_packet_pool_empty_suspensions++;
 800bc00:	68fb      	ldr	r3, [r7, #12]
 800bc02:	695b      	ldr	r3, [r3, #20]
 800bc04:	1c5a      	adds	r2, r3, #1
 800bc06:	68fb      	ldr	r3, [r7, #12]
 800bc08:	615a      	str	r2, [r3, #20]
#endif

            /* Pickup thread pointer.  */
            thread_ptr =  _tx_thread_current_ptr;
 800bc0a:	4b2e      	ldr	r3, [pc, #184]	; (800bcc4 <_nx_packet_allocate+0x184>)
 800bc0c:	681b      	ldr	r3, [r3, #0]
 800bc0e:	627b      	str	r3, [r7, #36]	; 0x24

            /* Setup cleanup routine pointer.  */
            thread_ptr -> tx_thread_suspend_cleanup =  _nx_packet_pool_cleanup;
 800bc10:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800bc12:	4a2d      	ldr	r2, [pc, #180]	; (800bcc8 <_nx_packet_allocate+0x188>)
 800bc14:	669a      	str	r2, [r3, #104]	; 0x68

            /* Setup cleanup information, i.e. this pool control
               block.  */
            thread_ptr -> tx_thread_suspend_control_block =  (void *)pool_ptr;
 800bc16:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800bc18:	68fa      	ldr	r2, [r7, #12]
 800bc1a:	66da      	str	r2, [r3, #108]	; 0x6c

            /* Save the return packet pointer address as well.  */
            thread_ptr -> tx_thread_additional_suspend_info =  (void *)packet_ptr;
 800bc1c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800bc1e:	68ba      	ldr	r2, [r7, #8]
 800bc20:	67da      	str	r2, [r3, #124]	; 0x7c

            /* Save the packet type (or prepend offset) so this can be added
               after a new packet becomes available.  */
            thread_ptr -> tx_thread_suspend_info =  packet_type;
 800bc22:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800bc24:	687a      	ldr	r2, [r7, #4]
 800bc26:	679a      	str	r2, [r3, #120]	; 0x78

            /* Setup suspension list.  */
            if (pool_ptr -> nx_packet_pool_suspension_list)
 800bc28:	68fb      	ldr	r3, [r7, #12]
 800bc2a:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800bc2c:	2b00      	cmp	r3, #0
 800bc2e:	d012      	beq.n	800bc56 <_nx_packet_allocate+0x116>
            {

                /* This list is not NULL, add current thread to the end. */
                thread_ptr -> tx_thread_suspended_next =
                    pool_ptr -> nx_packet_pool_suspension_list;
 800bc30:	68fb      	ldr	r3, [r7, #12]
 800bc32:	6ada      	ldr	r2, [r3, #44]	; 0x2c
                thread_ptr -> tx_thread_suspended_next =
 800bc34:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800bc36:	671a      	str	r2, [r3, #112]	; 0x70
                thread_ptr -> tx_thread_suspended_previous =
                    (pool_ptr -> nx_packet_pool_suspension_list) -> tx_thread_suspended_previous;
 800bc38:	68fb      	ldr	r3, [r7, #12]
 800bc3a:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800bc3c:	6f5a      	ldr	r2, [r3, #116]	; 0x74
                thread_ptr -> tx_thread_suspended_previous =
 800bc3e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800bc40:	675a      	str	r2, [r3, #116]	; 0x74
                ((pool_ptr -> nx_packet_pool_suspension_list) -> tx_thread_suspended_previous) -> tx_thread_suspended_next =
 800bc42:	68fb      	ldr	r3, [r7, #12]
 800bc44:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800bc46:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 800bc48:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 800bc4a:	671a      	str	r2, [r3, #112]	; 0x70
                    thread_ptr;
                (pool_ptr -> nx_packet_pool_suspension_list) -> tx_thread_suspended_previous =   thread_ptr;
 800bc4c:	68fb      	ldr	r3, [r7, #12]
 800bc4e:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800bc50:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 800bc52:	675a      	str	r2, [r3, #116]	; 0x74
 800bc54:	e008      	b.n	800bc68 <_nx_packet_allocate+0x128>
            else
            {

                /* No other threads are suspended.  Setup the head pointer and
                   just setup this threads pointers to itself.  */
                pool_ptr -> nx_packet_pool_suspension_list =  thread_ptr;
 800bc56:	68fb      	ldr	r3, [r7, #12]
 800bc58:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 800bc5a:	62da      	str	r2, [r3, #44]	; 0x2c
                thread_ptr -> tx_thread_suspended_next =            thread_ptr;
 800bc5c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800bc5e:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 800bc60:	671a      	str	r2, [r3, #112]	; 0x70
                thread_ptr -> tx_thread_suspended_previous =        thread_ptr;
 800bc62:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800bc64:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 800bc66:	675a      	str	r2, [r3, #116]	; 0x74
            }

            /* Increment the suspended thread count.  */
            pool_ptr -> nx_packet_pool_suspended_count++;
 800bc68:	68fb      	ldr	r3, [r7, #12]
 800bc6a:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800bc6c:	1c5a      	adds	r2, r3, #1
 800bc6e:	68fb      	ldr	r3, [r7, #12]
 800bc70:	631a      	str	r2, [r3, #48]	; 0x30

            /* Set the state to suspended.  */
            thread_ptr -> tx_thread_state =  TX_TCP_IP;
 800bc72:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800bc74:	220c      	movs	r2, #12
 800bc76:	631a      	str	r2, [r3, #48]	; 0x30

            /* Set the suspending flag.  */
            thread_ptr -> tx_thread_suspending =  TX_TRUE;
 800bc78:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800bc7a:	2201      	movs	r2, #1
 800bc7c:	639a      	str	r2, [r3, #56]	; 0x38

            /* Temporarily disable preemption.  */
            _tx_thread_preempt_disable++;
 800bc7e:	4b13      	ldr	r3, [pc, #76]	; (800bccc <_nx_packet_allocate+0x18c>)
 800bc80:	681b      	ldr	r3, [r3, #0]
 800bc82:	3301      	adds	r3, #1
 800bc84:	4a11      	ldr	r2, [pc, #68]	; (800bccc <_nx_packet_allocate+0x18c>)
 800bc86:	6013      	str	r3, [r2, #0]

            /* Save the timeout value.  */
            thread_ptr -> tx_thread_timer.tx_timer_internal_remaining_ticks =  wait_option;
 800bc88:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800bc8a:	683a      	ldr	r2, [r7, #0]
 800bc8c:	64da      	str	r2, [r3, #76]	; 0x4c
 800bc8e:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800bc90:	617b      	str	r3, [r7, #20]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 800bc92:	697b      	ldr	r3, [r7, #20]
 800bc94:	f383 8810 	msr	PRIMASK, r3
}
 800bc98:	bf00      	nop

            /* Restore interrupts.  */
            TX_RESTORE

            /* Call actual thread suspension routine.  */
            _tx_thread_system_suspend(thread_ptr);
 800bc9a:	6a78      	ldr	r0, [r7, #36]	; 0x24
 800bc9c:	f009 f944 	bl	8014f28 <_tx_thread_system_suspend>
                NX_PACKET_DEBUG(__FILE__, __LINE__, *packet_ptr);
            }
#endif /* NX_ENABLE_PACKET_DEBUG_INFO */

            /* Return the completion status.  */
            return(thread_ptr -> tx_thread_suspend_status);
 800bca0:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800bca2:	f8d3 3084 	ldr.w	r3, [r3, #132]	; 0x84
 800bca6:	e008      	b.n	800bcba <_nx_packet_allocate+0x17a>
        }
        else
        {

            /* Immediate return, return error completion.  */
            status =  NX_NO_PACKET;
 800bca8:	2301      	movs	r3, #1
 800bcaa:	62fb      	str	r3, [r7, #44]	; 0x2c
 800bcac:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800bcae:	613b      	str	r3, [r7, #16]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 800bcb0:	693b      	ldr	r3, [r7, #16]
 800bcb2:	f383 8810 	msr	PRIMASK, r3
}
 800bcb6:	bf00      	nop

    /* Update the trace event with the status.  */
    NX_TRACE_EVENT_UPDATE(trace_event, trace_timestamp, NX_TRACE_PACKET_ALLOCATE, 0, *packet_ptr, 0, 0);

    /* Return completion status.  */
    return(status);
 800bcb8:	6afb      	ldr	r3, [r7, #44]	; 0x2c
}
 800bcba:	4618      	mov	r0, r3
 800bcbc:	3730      	adds	r7, #48	; 0x30
 800bcbe:	46bd      	mov	sp, r7
 800bcc0:	bd80      	pop	{r7, pc}
 800bcc2:	bf00      	nop
 800bcc4:	24031bc4 	.word	0x24031bc4
 800bcc8:	0800c069 	.word	0x0800c069
 800bccc:	24031c5c 	.word	0x24031c5c

0800bcd0 <_nx_packet_copy>:
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
UINT  _nx_packet_copy(NX_PACKET *packet_ptr, NX_PACKET **new_packet_ptr,
                      NX_PACKET_POOL *pool_ptr, ULONG wait_option)
{
 800bcd0:	b580      	push	{r7, lr}
 800bcd2:	b08e      	sub	sp, #56	; 0x38
 800bcd4:	af02      	add	r7, sp, #8
 800bcd6:	60f8      	str	r0, [r7, #12]
 800bcd8:	60b9      	str	r1, [r7, #8]
 800bcda:	607a      	str	r2, [r7, #4]
 800bcdc:	603b      	str	r3, [r7, #0]
ULONG                  trace_timestamp;
#endif


    /* Default the return packet pointer to NULL.  */
    *new_packet_ptr =  NX_NULL;
 800bcde:	68bb      	ldr	r3, [r7, #8]
 800bce0:	2200      	movs	r2, #0
 800bce2:	601a      	str	r2, [r3, #0]

    /* Default the first packet to TRUE.  */
    first_packet = NX_TRUE;
 800bce4:	2301      	movs	r3, #1
 800bce6:	62bb      	str	r3, [r7, #40]	; 0x28

    /* If trace is enabled, insert this event into the trace buffer.  */
    NX_TRACE_IN_LINE_INSERT(NX_TRACE_PACKET_COPY, packet_ptr, 0, pool_ptr, wait_option, NX_TRACE_PACKET_EVENTS, &trace_event, &trace_timestamp);

    /* Determine if there is anything to copy.  */
    if (packet_ptr -> nx_packet_length == 0)
 800bce8:	68fb      	ldr	r3, [r7, #12]
 800bcea:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800bcec:	2b00      	cmp	r3, #0
 800bcee:	d101      	bne.n	800bcf4 <_nx_packet_copy+0x24>
    {

        /* Empty source packet, return an error.  */
        return(NX_INVALID_PACKET);
 800bcf0:	2312      	movs	r3, #18
 800bcf2:	e075      	b.n	800bde0 <_nx_packet_copy+0x110>
    }

    /* Allocate a new packet from the default packet pool supplied.  */
    /*lint -e{946} -e{947} suppress pointer subtraction, since it is necessary. */
    status =  _nx_packet_allocate(pool_ptr, &work_ptr, 0, wait_option);
 800bcf4:	f107 0114 	add.w	r1, r7, #20
 800bcf8:	683b      	ldr	r3, [r7, #0]
 800bcfa:	2200      	movs	r2, #0
 800bcfc:	6878      	ldr	r0, [r7, #4]
 800bcfe:	f7ff ff1f 	bl	800bb40 <_nx_packet_allocate>
 800bd02:	62f8      	str	r0, [r7, #44]	; 0x2c

    /* Determine if the packet was not allocated.  */
    if (status != NX_SUCCESS)
 800bd04:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800bd06:	2b00      	cmp	r3, #0
 800bd08:	d001      	beq.n	800bd0e <_nx_packet_copy+0x3e>
    {

        /* Return the error code from the packet allocate routine.  */
        return(status);
 800bd0a:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800bd0c:	e068      	b.n	800bde0 <_nx_packet_copy+0x110>
    }

    /* Copy the packet interface information. */
    /*lint -e{644} suppress variable might not be initialized, since "work_ptr" was initialized by _nx_packet_allocate. */
    work_ptr -> nx_packet_address.nx_packet_interface_ptr = packet_ptr -> nx_packet_address.nx_packet_interface_ptr;
 800bd0e:	697b      	ldr	r3, [r7, #20]
 800bd10:	68fa      	ldr	r2, [r7, #12]
 800bd12:	6b12      	ldr	r2, [r2, #48]	; 0x30
 800bd14:	631a      	str	r2, [r3, #48]	; 0x30
#ifdef NX_IPSEC_ENABLE
    work_ptr -> nx_packet_ipsec_sa_ptr = packet_ptr -> nx_packet_ipsec_sa_ptr;
#endif /* NX_IPSEC_ENABLE */

    /* Save the source packet pointer.  */
    source_ptr =  packet_ptr;
 800bd16:	68fb      	ldr	r3, [r7, #12]
 800bd18:	627b      	str	r3, [r7, #36]	; 0x24
    do
    {
#endif /* NX_DISABLE_PACKET_CHAIN */

        /* Check if it is the first packet.  */
        if (first_packet == NX_TRUE)
 800bd1a:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800bd1c:	2b01      	cmp	r3, #1
 800bd1e:	d110      	bne.n	800bd42 <_nx_packet_copy+0x72>

            /* Yes, it is, copied the data beginning at data starting position.  */

            /* Calculate this packet's data size.  */
            /*lint -e{946} -e{947} suppress pointer subtraction, since it is necessary. */
            size =  (ULONG)(packet_ptr -> nx_packet_append_ptr - packet_ptr -> nx_packet_data_start);
 800bd20:	68fb      	ldr	r3, [r7, #12]
 800bd22:	68da      	ldr	r2, [r3, #12]
 800bd24:	68fb      	ldr	r3, [r7, #12]
 800bd26:	691b      	ldr	r3, [r3, #16]
 800bd28:	1ad3      	subs	r3, r2, r3
 800bd2a:	623b      	str	r3, [r7, #32]

            /* Copy the data from the source packet into the new packet using
               the data append feature.  */
            status =  _nx_packet_data_append(work_ptr, packet_ptr -> nx_packet_data_start, size, pool_ptr, wait_option);
 800bd2c:	6978      	ldr	r0, [r7, #20]
 800bd2e:	68fb      	ldr	r3, [r7, #12]
 800bd30:	6919      	ldr	r1, [r3, #16]
 800bd32:	683b      	ldr	r3, [r7, #0]
 800bd34:	9300      	str	r3, [sp, #0]
 800bd36:	687b      	ldr	r3, [r7, #4]
 800bd38:	6a3a      	ldr	r2, [r7, #32]
 800bd3a:	f000 f855 	bl	800bde8 <_nx_packet_data_append>
 800bd3e:	62f8      	str	r0, [r7, #44]	; 0x2c
 800bd40:	e00f      	b.n	800bd62 <_nx_packet_copy+0x92>
        else
        {

            /* Calculate this packet's data size.  */
            /*lint -e{946} -e{947} suppress pointer subtraction, since it is necessary. */
            size =  (ULONG)(packet_ptr -> nx_packet_append_ptr - packet_ptr -> nx_packet_prepend_ptr);
 800bd42:	68fb      	ldr	r3, [r7, #12]
 800bd44:	68da      	ldr	r2, [r3, #12]
 800bd46:	68fb      	ldr	r3, [r7, #12]
 800bd48:	689b      	ldr	r3, [r3, #8]
 800bd4a:	1ad3      	subs	r3, r2, r3
 800bd4c:	623b      	str	r3, [r7, #32]

            /* Copy the data from the source packet into the new packet using
               the data append feature.  */
            status =  _nx_packet_data_append(work_ptr, packet_ptr -> nx_packet_prepend_ptr, size, pool_ptr, wait_option);
 800bd4e:	6978      	ldr	r0, [r7, #20]
 800bd50:	68fb      	ldr	r3, [r7, #12]
 800bd52:	6899      	ldr	r1, [r3, #8]
 800bd54:	683b      	ldr	r3, [r7, #0]
 800bd56:	9300      	str	r3, [sp, #0]
 800bd58:	687b      	ldr	r3, [r7, #4]
 800bd5a:	6a3a      	ldr	r2, [r7, #32]
 800bd5c:	f000 f844 	bl	800bde8 <_nx_packet_data_append>
 800bd60:	62f8      	str	r0, [r7, #44]	; 0x2c
        }

        /* Determine if there was an error in the data append.  */
        if (status != NX_SUCCESS)
 800bd62:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800bd64:	2b00      	cmp	r3, #0
 800bd66:	d005      	beq.n	800bd74 <_nx_packet_copy+0xa4>
        {

            /* An error is present, release the new packet.  */
            _nx_packet_release(work_ptr);
 800bd68:	697b      	ldr	r3, [r7, #20]
 800bd6a:	4618      	mov	r0, r3
 800bd6c:	f000 fb4c 	bl	800c408 <_nx_packet_release>

            /* Return the error code from the packet data append service.  */
            return(status);
 800bd70:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800bd72:	e035      	b.n	800bde0 <_nx_packet_copy+0x110>
        }

#ifndef NX_DISABLE_PACKET_CHAIN
        /* Move to the next packet in the packet chain.  */
        packet_ptr =  packet_ptr -> nx_packet_next;
 800bd74:	68fb      	ldr	r3, [r7, #12]
 800bd76:	685b      	ldr	r3, [r3, #4]
 800bd78:	60fb      	str	r3, [r7, #12]

        /* Set the first packet to FALSE.  */
        first_packet = NX_FALSE;
 800bd7a:	2300      	movs	r3, #0
 800bd7c:	62bb      	str	r3, [r7, #40]	; 0x28
    } while (packet_ptr);
 800bd7e:	68fb      	ldr	r3, [r7, #12]
 800bd80:	2b00      	cmp	r3, #0
 800bd82:	d1ca      	bne.n	800bd1a <_nx_packet_copy+0x4a>
#endif /* NX_DISABLE_PACKET_CHAIN */

    /* Adjust the prepend pointer and data length.  */
    /*lint --e{946} --e{947} --e{732} suppress pointer subtraction, since it is necessary. */
    data_prepend_offset = (UINT)(source_ptr -> nx_packet_prepend_ptr - source_ptr -> nx_packet_data_start);
 800bd84:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800bd86:	689a      	ldr	r2, [r3, #8]
 800bd88:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800bd8a:	691b      	ldr	r3, [r3, #16]
 800bd8c:	1ad3      	subs	r3, r2, r3
 800bd8e:	61fb      	str	r3, [r7, #28]
    work_ptr -> nx_packet_prepend_ptr = work_ptr -> nx_packet_data_start + data_prepend_offset;
 800bd90:	697b      	ldr	r3, [r7, #20]
 800bd92:	6919      	ldr	r1, [r3, #16]
 800bd94:	697b      	ldr	r3, [r7, #20]
 800bd96:	69fa      	ldr	r2, [r7, #28]
 800bd98:	440a      	add	r2, r1
 800bd9a:	609a      	str	r2, [r3, #8]
    work_ptr -> nx_packet_length =  work_ptr -> nx_packet_length - data_prepend_offset;
 800bd9c:	697b      	ldr	r3, [r7, #20]
 800bd9e:	6a59      	ldr	r1, [r3, #36]	; 0x24
 800bda0:	697b      	ldr	r3, [r7, #20]
 800bda2:	69fa      	ldr	r2, [r7, #28]
 800bda4:	1a8a      	subs	r2, r1, r2
 800bda6:	625a      	str	r2, [r3, #36]	; 0x24

    /* Set the ip_header information. */
    ip_header_offset = (UINT)(source_ptr -> nx_packet_ip_header - source_ptr -> nx_packet_data_start);
 800bda8:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800bdaa:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 800bdac:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800bdae:	691b      	ldr	r3, [r3, #16]
 800bdb0:	1ad3      	subs	r3, r2, r3
 800bdb2:	61bb      	str	r3, [r7, #24]
    work_ptr -> nx_packet_ip_header = work_ptr -> nx_packet_data_start + ip_header_offset;
 800bdb4:	697b      	ldr	r3, [r7, #20]
 800bdb6:	6919      	ldr	r1, [r3, #16]
 800bdb8:	697b      	ldr	r3, [r7, #20]
 800bdba:	69ba      	ldr	r2, [r7, #24]
 800bdbc:	440a      	add	r2, r1
 800bdbe:	635a      	str	r2, [r3, #52]	; 0x34

    /* Determine if the packet copy was successful.  */
    if (source_ptr -> nx_packet_length != work_ptr -> nx_packet_length)
 800bdc0:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800bdc2:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 800bdc4:	697b      	ldr	r3, [r7, #20]
 800bdc6:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800bdc8:	429a      	cmp	r2, r3
 800bdca:	d005      	beq.n	800bdd8 <_nx_packet_copy+0x108>
    {

        /* An error is present, release the new packet.  */
        _nx_packet_release(work_ptr);
 800bdcc:	697b      	ldr	r3, [r7, #20]
 800bdce:	4618      	mov	r0, r3
 800bdd0:	f000 fb1a 	bl	800c408 <_nx_packet_release>

        /* Return an error code.  */
        return(NX_INVALID_PACKET);
 800bdd4:	2312      	movs	r3, #18
 800bdd6:	e003      	b.n	800bde0 <_nx_packet_copy+0x110>
    }
    else
    {

        /* Everything is okay, return the new packet pointer.  */
        *new_packet_ptr =  work_ptr;
 800bdd8:	697a      	ldr	r2, [r7, #20]
 800bdda:	68bb      	ldr	r3, [r7, #8]
 800bddc:	601a      	str	r2, [r3, #0]

        /* Update the trace event with the status.  */
        NX_TRACE_EVENT_UPDATE(trace_event, trace_timestamp, NX_TRACE_PACKET_COPY, 0, work_ptr, 0, 0);

        /* Return success status.  */
        return(NX_SUCCESS);
 800bdde:	2300      	movs	r3, #0
    }
}
 800bde0:	4618      	mov	r0, r3
 800bde2:	3730      	adds	r7, #48	; 0x30
 800bde4:	46bd      	mov	sp, r7
 800bde6:	bd80      	pop	{r7, pc}

0800bde8 <_nx_packet_data_append>:
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
UINT  _nx_packet_data_append(NX_PACKET *packet_ptr, VOID *data_start, ULONG data_size,
                             NX_PACKET_POOL *pool_ptr, ULONG wait_option)
{
 800bde8:	b580      	push	{r7, lr}
 800bdea:	b08c      	sub	sp, #48	; 0x30
 800bdec:	af00      	add	r7, sp, #0
 800bdee:	60f8      	str	r0, [r7, #12]
 800bdf0:	60b9      	str	r1, [r7, #8]
 800bdf2:	607a      	str	r2, [r7, #4]
 800bdf4:	603b      	str	r3, [r7, #0]

#ifndef NX_DISABLE_PACKET_CHAIN
UINT       status;                 /* Return status              */
NX_PACKET *new_list_ptr;           /* Head of new list pointer   */
NX_PACKET *last_packet =  NX_NULL; /* Last supplied packet       */
 800bdf6:	2300      	movs	r3, #0
 800bdf8:	62bb      	str	r3, [r7, #40]	; 0x28
    /* If trace is enabled, insert this event into the trace buffer.  */
    NX_TRACE_IN_LINE_INSERT(NX_TRACE_PACKET_DATA_APPEND, packet_ptr, data_start, data_size, pool_ptr, NX_TRACE_PACKET_EVENTS, 0, 0);

#ifndef NX_DISABLE_PACKET_CHAIN
    /* Calculate the number of bytes available at the end of the supplied packet.  */
    if (packet_ptr -> nx_packet_last)
 800bdfa:	68fb      	ldr	r3, [r7, #12]
 800bdfc:	699b      	ldr	r3, [r3, #24]
 800bdfe:	2b00      	cmp	r3, #0
 800be00:	d016      	beq.n	800be30 <_nx_packet_data_append+0x48>
    {

        /* More than one packet.  Walk the packet chain starting at the last packet
           to calculate the remaining bytes.  */
        available_bytes =  0;
 800be02:	2300      	movs	r3, #0
 800be04:	627b      	str	r3, [r7, #36]	; 0x24
        work_ptr =  packet_ptr -> nx_packet_last;
 800be06:	68fb      	ldr	r3, [r7, #12]
 800be08:	699b      	ldr	r3, [r3, #24]
 800be0a:	617b      	str	r3, [r7, #20]

            /* Calculate the available bytes in this packet.  */
            /*lint -e{946} -e{947} suppress pointer subtraction, since it is necessary. */
            /*lint -e{737} suppress loss of sign, since nx_packet_data_end is assumed to be larger than nx_packet_append_ptr. */
            available_bytes =  available_bytes +
                (ULONG)(work_ptr -> nx_packet_data_end - work_ptr -> nx_packet_append_ptr);
 800be0c:	697b      	ldr	r3, [r7, #20]
 800be0e:	695a      	ldr	r2, [r3, #20]
 800be10:	697b      	ldr	r3, [r7, #20]
 800be12:	68db      	ldr	r3, [r3, #12]
 800be14:	1ad3      	subs	r3, r2, r3
 800be16:	461a      	mov	r2, r3
            available_bytes =  available_bytes +
 800be18:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800be1a:	4413      	add	r3, r2
 800be1c:	627b      	str	r3, [r7, #36]	; 0x24

            /* Remember the last packet.  */
            last_packet =  work_ptr;
 800be1e:	697b      	ldr	r3, [r7, #20]
 800be20:	62bb      	str	r3, [r7, #40]	; 0x28

            /* Move to the next packet.   There typically won't be another packet, but just in
               case the logic is here for it!  */
            work_ptr =  work_ptr -> nx_packet_next;
 800be22:	697b      	ldr	r3, [r7, #20]
 800be24:	685b      	ldr	r3, [r3, #4]
 800be26:	617b      	str	r3, [r7, #20]
        } while (work_ptr);
 800be28:	697b      	ldr	r3, [r7, #20]
 800be2a:	2b00      	cmp	r3, #0
 800be2c:	d1ee      	bne.n	800be0c <_nx_packet_data_append+0x24>
 800be2e:	e005      	b.n	800be3c <_nx_packet_data_append+0x54>
#endif /* NX_DISABLE_PACKET_CHAIN */
    {

        /* Just calculate the number of bytes available in the first packet.  */
        /*lint -e{946} -e{947} suppress pointer subtraction, since it is necessary. */
        available_bytes =  (ULONG)(packet_ptr -> nx_packet_data_end - packet_ptr -> nx_packet_append_ptr);
 800be30:	68fb      	ldr	r3, [r7, #12]
 800be32:	695a      	ldr	r2, [r3, #20]
 800be34:	68fb      	ldr	r3, [r7, #12]
 800be36:	68db      	ldr	r3, [r3, #12]
 800be38:	1ad3      	subs	r3, r2, r3
 800be3a:	627b      	str	r3, [r7, #36]	; 0x24
    }

    /* Determine if any new packets are required to satisfy this request. */
    if (available_bytes < data_size)
 800be3c:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 800be3e:	687b      	ldr	r3, [r7, #4]
 800be40:	429a      	cmp	r2, r3
 800be42:	d247      	bcs.n	800bed4 <_nx_packet_data_append+0xec>
    {

#ifndef NX_DISABLE_PACKET_CHAIN
        /* Setup a temporary head pointer.  */
        new_list_ptr =  NX_NULL;
 800be44:	2300      	movs	r3, #0
 800be46:	62fb      	str	r3, [r7, #44]	; 0x2c

        /* Loop to pickup enough packets to complete the append request.  */
        while (available_bytes < data_size)
 800be48:	e033      	b.n	800beb2 <_nx_packet_data_append+0xca>
        {

            /* Allocate a new packet.  */
            status =  _nx_packet_allocate(pool_ptr, &work_ptr, 0, wait_option);
 800be4a:	f107 0114 	add.w	r1, r7, #20
 800be4e:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800be50:	2200      	movs	r2, #0
 800be52:	6838      	ldr	r0, [r7, #0]
 800be54:	f7ff fe74 	bl	800bb40 <_nx_packet_allocate>
 800be58:	61b8      	str	r0, [r7, #24]

            /* Determine if an error is present.  */
            if (status)
 800be5a:	69bb      	ldr	r3, [r7, #24]
 800be5c:	2b00      	cmp	r3, #0
 800be5e:	d007      	beq.n	800be70 <_nx_packet_data_append+0x88>
            {

                /* Yes, an error is present.   */

                /* First release any packets that have been allocated so far.  */
                if (new_list_ptr)
 800be60:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800be62:	2b00      	cmp	r3, #0
 800be64:	d002      	beq.n	800be6c <_nx_packet_data_append+0x84>
                {
                    _nx_packet_release(new_list_ptr);
 800be66:	6af8      	ldr	r0, [r7, #44]	; 0x2c
 800be68:	f000 face 	bl	800c408 <_nx_packet_release>
                }

                /* Return the error status to the caller of this service.  */
                return(status);
 800be6c:	69bb      	ldr	r3, [r7, #24]
 800be6e:	e078      	b.n	800bf62 <_nx_packet_data_append+0x17a>

            /* Add debug information. */
            NX_PACKET_DEBUG(__FILE__, __LINE__, work_ptr);

            /* No error is present.  Link the new packet to the temporary list being built.  */
            if (new_list_ptr)
 800be70:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800be72:	2b00      	cmp	r3, #0
 800be74:	d012      	beq.n	800be9c <_nx_packet_data_append+0xb4>
            {

                /* Determine if there is already more than one packet on the list.  */
                if (new_list_ptr -> nx_packet_last)
 800be76:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800be78:	699b      	ldr	r3, [r3, #24]
 800be7a:	2b00      	cmp	r3, #0
 800be7c:	d007      	beq.n	800be8e <_nx_packet_data_append+0xa6>
                {

                    /* Yes, link up the last packet to the new packet and update the
                       last pointer.  */
                    /*lint -e{644} suppress variable might not be initialized, since "work_ptr" was initialized in _nx_packet_allocate. */
                    (new_list_ptr -> nx_packet_last) -> nx_packet_next =  work_ptr;
 800be7e:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800be80:	699b      	ldr	r3, [r3, #24]
 800be82:	697a      	ldr	r2, [r7, #20]
 800be84:	605a      	str	r2, [r3, #4]
                    new_list_ptr -> nx_packet_last =  work_ptr;
 800be86:	697a      	ldr	r2, [r7, #20]
 800be88:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800be8a:	619a      	str	r2, [r3, #24]
 800be8c:	e008      	b.n	800bea0 <_nx_packet_data_append+0xb8>
                else
                {

                    /* Second packet allocated.  Just setup the last and next in the
                       head pointer.  */
                    new_list_ptr -> nx_packet_last =  work_ptr;
 800be8e:	697a      	ldr	r2, [r7, #20]
 800be90:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800be92:	619a      	str	r2, [r3, #24]
                    new_list_ptr -> nx_packet_next =  work_ptr;
 800be94:	697a      	ldr	r2, [r7, #20]
 800be96:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800be98:	605a      	str	r2, [r3, #4]
 800be9a:	e001      	b.n	800bea0 <_nx_packet_data_append+0xb8>
            }
            else
            {

                /* Just setup the temporary list head.  */
                new_list_ptr =  work_ptr;
 800be9c:	697b      	ldr	r3, [r7, #20]
 800be9e:	62fb      	str	r3, [r7, #44]	; 0x2c
               is in the new packet.  */
            /*lint -e{946} -e{947} suppress pointer subtraction, since it is necessary. */
            /*lint -e{737} suppress loss of sign, since nx_packet_data_end is assumed to be larger than nx_packet_append_ptr. */
            /*lint -e{613} suppress possible use of null pointer, since "work_ptr" was set in _nx_packet_allocate. */
            available_bytes =  available_bytes +
                (ULONG)(work_ptr -> nx_packet_data_end - work_ptr -> nx_packet_append_ptr);
 800bea0:	697b      	ldr	r3, [r7, #20]
 800bea2:	695a      	ldr	r2, [r3, #20]
 800bea4:	697b      	ldr	r3, [r7, #20]
 800bea6:	68db      	ldr	r3, [r3, #12]
 800bea8:	1ad3      	subs	r3, r2, r3
 800beaa:	461a      	mov	r2, r3
            available_bytes =  available_bytes +
 800beac:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800beae:	4413      	add	r3, r2
 800beb0:	627b      	str	r3, [r7, #36]	; 0x24
        while (available_bytes < data_size)
 800beb2:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 800beb4:	687b      	ldr	r3, [r7, #4]
 800beb6:	429a      	cmp	r2, r3
 800beb8:	d3c7      	bcc.n	800be4a <_nx_packet_data_append+0x62>
        }

        /* At this point, all the necessary packets have been allocated and are present
           on the temporary list.  We need to link this new list to the end of the supplied
           packet.  */
        if (last_packet)
 800beba:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800bebc:	2b00      	cmp	r3, #0
 800bebe:	d003      	beq.n	800bec8 <_nx_packet_data_append+0xe0>
        {

            /* Already more than one packet.  Add the new packet list to the end.  */
            last_packet -> nx_packet_next =  new_list_ptr;
 800bec0:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800bec2:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 800bec4:	605a      	str	r2, [r3, #4]
 800bec6:	e002      	b.n	800bece <_nx_packet_data_append+0xe6>
        }
        else
        {

            /* Link the new packet list to the head packet.  */
            packet_ptr -> nx_packet_next =  new_list_ptr;
 800bec8:	68fb      	ldr	r3, [r7, #12]
 800beca:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 800becc:	605a      	str	r2, [r3, #4]
        }

        /* Clear the last packet that was used to maintain the new list.  */
        /*lint -e{613} suppress possible use of null pointer, since "new_list_ptr" was set in previous loop. */
        new_list_ptr -> nx_packet_last =  NX_NULL;
 800bece:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800bed0:	2200      	movs	r2, #0
 800bed2:	619a      	str	r2, [r3, #24]
        return(NX_SIZE_ERROR);
#endif /* NX_DISABLE_PACKET_CHAIN */
    }

    /* Setup the new data length in the packet.  */
    packet_ptr -> nx_packet_length =   packet_ptr -> nx_packet_length + data_size;
 800bed4:	68fb      	ldr	r3, [r7, #12]
 800bed6:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 800bed8:	687b      	ldr	r3, [r7, #4]
 800beda:	441a      	add	r2, r3
 800bedc:	68fb      	ldr	r3, [r7, #12]
 800bede:	625a      	str	r2, [r3, #36]	; 0x24

    /* Now copy the supplied data buffer at the end of the packet.  */
    source_ptr =  (UCHAR *)data_start;
 800bee0:	68bb      	ldr	r3, [r7, #8]
 800bee2:	61fb      	str	r3, [r7, #28]
#ifndef NX_DISABLE_PACKET_CHAIN
    if (packet_ptr -> nx_packet_last)
 800bee4:	68fb      	ldr	r3, [r7, #12]
 800bee6:	699b      	ldr	r3, [r3, #24]
 800bee8:	2b00      	cmp	r3, #0
 800beea:	d003      	beq.n	800bef4 <_nx_packet_data_append+0x10c>
    {
        work_ptr =    packet_ptr -> nx_packet_last;
 800beec:	68fb      	ldr	r3, [r7, #12]
 800beee:	699b      	ldr	r3, [r3, #24]
 800bef0:	617b      	str	r3, [r7, #20]
 800bef2:	e032      	b.n	800bf5a <_nx_packet_data_append+0x172>
    }
    else
    {
#endif /* NX_DISABLE_PACKET_CHAIN */
        work_ptr =    packet_ptr;
 800bef4:	68fb      	ldr	r3, [r7, #12]
 800bef6:	617b      	str	r3, [r7, #20]
#ifndef NX_DISABLE_PACKET_CHAIN
    }
    while (data_size)
 800bef8:	e02f      	b.n	800bf5a <_nx_packet_data_append+0x172>
    {

        /* Determine the amount of memory to copy.  */
        /*lint -e{946} -e{947} suppress pointer subtraction, since it is necessary. */
        if (data_size < (ULONG)(work_ptr -> nx_packet_data_end - work_ptr -> nx_packet_append_ptr))
 800befa:	697b      	ldr	r3, [r7, #20]
 800befc:	695a      	ldr	r2, [r3, #20]
 800befe:	697b      	ldr	r3, [r7, #20]
 800bf00:	68db      	ldr	r3, [r3, #12]
 800bf02:	1ad3      	subs	r3, r2, r3
 800bf04:	461a      	mov	r2, r3
 800bf06:	687b      	ldr	r3, [r7, #4]
 800bf08:	4293      	cmp	r3, r2
 800bf0a:	d202      	bcs.n	800bf12 <_nx_packet_data_append+0x12a>
        {
            copy_size =  data_size;
 800bf0c:	687b      	ldr	r3, [r7, #4]
 800bf0e:	623b      	str	r3, [r7, #32]
 800bf10:	e005      	b.n	800bf1e <_nx_packet_data_append+0x136>
        }
        else
        {

            /*lint -e{946} -e{947} suppress pointer subtraction, since it is necessary. */
            copy_size =  (ULONG)(work_ptr -> nx_packet_data_end - work_ptr -> nx_packet_append_ptr);
 800bf12:	697b      	ldr	r3, [r7, #20]
 800bf14:	695a      	ldr	r2, [r3, #20]
 800bf16:	697b      	ldr	r3, [r7, #20]
 800bf18:	68db      	ldr	r3, [r3, #12]
 800bf1a:	1ad3      	subs	r3, r2, r3
 800bf1c:	623b      	str	r3, [r7, #32]
#else
        copy_size = data_size;
#endif /* NX_DISABLE_PACKET_CHAIN */

        /* Copy the data into the current packet buffer.  */
        memcpy(work_ptr -> nx_packet_append_ptr, source_ptr, copy_size); /* Use case of memcpy is verified. */
 800bf1e:	697b      	ldr	r3, [r7, #20]
 800bf20:	68db      	ldr	r3, [r3, #12]
 800bf22:	6a3a      	ldr	r2, [r7, #32]
 800bf24:	69f9      	ldr	r1, [r7, #28]
 800bf26:	4618      	mov	r0, r3
 800bf28:	f013 fc80 	bl	801f82c <memcpy>

        /* Adjust the remaining data size.  */
        data_size =  data_size - copy_size;
 800bf2c:	687a      	ldr	r2, [r7, #4]
 800bf2e:	6a3b      	ldr	r3, [r7, #32]
 800bf30:	1ad3      	subs	r3, r2, r3
 800bf32:	607b      	str	r3, [r7, #4]

        /* Update this packets append pointer.  */
        work_ptr -> nx_packet_append_ptr =  work_ptr -> nx_packet_append_ptr + copy_size;
 800bf34:	697b      	ldr	r3, [r7, #20]
 800bf36:	68d9      	ldr	r1, [r3, #12]
 800bf38:	697b      	ldr	r3, [r7, #20]
 800bf3a:	6a3a      	ldr	r2, [r7, #32]
 800bf3c:	440a      	add	r2, r1
 800bf3e:	60da      	str	r2, [r3, #12]

#ifndef NX_DISABLE_PACKET_CHAIN
        /* Any more data left to append?  */
        if (data_size)
 800bf40:	687b      	ldr	r3, [r7, #4]
 800bf42:	2b00      	cmp	r3, #0
 800bf44:	d009      	beq.n	800bf5a <_nx_packet_data_append+0x172>
        {

            /* Yes, there is more to move.  Update the source pointer, move the work pointer
               to the next packet in the chain and update the last packet pointer.  */
            source_ptr =  source_ptr + copy_size;
 800bf46:	69fa      	ldr	r2, [r7, #28]
 800bf48:	6a3b      	ldr	r3, [r7, #32]
 800bf4a:	4413      	add	r3, r2
 800bf4c:	61fb      	str	r3, [r7, #28]
            work_ptr =  work_ptr -> nx_packet_next;
 800bf4e:	697b      	ldr	r3, [r7, #20]
 800bf50:	685b      	ldr	r3, [r3, #4]
 800bf52:	617b      	str	r3, [r7, #20]
            packet_ptr -> nx_packet_last =  work_ptr;
 800bf54:	697a      	ldr	r2, [r7, #20]
 800bf56:	68fb      	ldr	r3, [r7, #12]
 800bf58:	619a      	str	r2, [r3, #24]
    while (data_size)
 800bf5a:	687b      	ldr	r3, [r7, #4]
 800bf5c:	2b00      	cmp	r3, #0
 800bf5e:	d1cc      	bne.n	800befa <_nx_packet_data_append+0x112>

    /* Add debug information. */
    NX_PACKET_DEBUG(__FILE__, __LINE__, packet_ptr);

    /* Return successful status.  */
    return(NX_SUCCESS);
 800bf60:	2300      	movs	r3, #0
}
 800bf62:	4618      	mov	r0, r3
 800bf64:	3730      	adds	r7, #48	; 0x30
 800bf66:	46bd      	mov	sp, r7
 800bf68:	bd80      	pop	{r7, pc}

0800bf6a <_nx_packet_data_extract_offset>:
/*                                            verified memcpy use cases,  */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
UINT  _nx_packet_data_extract_offset(NX_PACKET *packet_ptr, ULONG offset, VOID *buffer_start, ULONG buffer_length, ULONG *bytes_copied)
{
 800bf6a:	b580      	push	{r7, lr}
 800bf6c:	b08c      	sub	sp, #48	; 0x30
 800bf6e:	af00      	add	r7, sp, #0
 800bf70:	60f8      	str	r0, [r7, #12]
 800bf72:	60b9      	str	r1, [r7, #8]
 800bf74:	607a      	str	r2, [r7, #4]
 800bf76:	603b      	str	r3, [r7, #0]
#endif /* NX_DISABLE_PACKET_CHAIN */
ULONG      bytes_to_copy;
NX_PACKET *working_packet_ptr;


    working_packet_ptr =  packet_ptr;
 800bf78:	68fb      	ldr	r3, [r7, #12]
 800bf7a:	61bb      	str	r3, [r7, #24]

    /* Check for an invalid offset or packet length.  */
    if (offset >= working_packet_ptr -> nx_packet_length)
 800bf7c:	69bb      	ldr	r3, [r7, #24]
 800bf7e:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800bf80:	68ba      	ldr	r2, [r7, #8]
 800bf82:	429a      	cmp	r2, r3
 800bf84:	d309      	bcc.n	800bf9a <_nx_packet_data_extract_offset+0x30>
    {

        /* Note: A zero offset with a packet of zero length is ok. */
        if (offset == 0)
 800bf86:	68bb      	ldr	r3, [r7, #8]
 800bf88:	2b00      	cmp	r3, #0
 800bf8a:	d104      	bne.n	800bf96 <_nx_packet_data_extract_offset+0x2c>
        {

            *bytes_copied = 0;
 800bf8c:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800bf8e:	2200      	movs	r2, #0
 800bf90:	601a      	str	r2, [r3, #0]
            return(NX_SUCCESS);
 800bf92:	2300      	movs	r3, #0
 800bf94:	e064      	b.n	800c060 <_nx_packet_data_extract_offset+0xf6>
        }

        /* Otherwise, this is an invalid offset or packet length. */
        return(NX_PACKET_OFFSET_ERROR);
 800bf96:	2353      	movs	r3, #83	; 0x53
 800bf98:	e062      	b.n	800c060 <_nx_packet_data_extract_offset+0xf6>
    }


    /* Initialize the source pointer to NULL.  */
    source_ptr =  NX_NULL;
 800bf9a:	2300      	movs	r3, #0
 800bf9c:	62bb      	str	r3, [r7, #40]	; 0x28

    /* Traverse packet chain to offset.  */
    offset_bytes =  offset;
 800bf9e:	68bb      	ldr	r3, [r7, #8]
 800bfa0:	623b      	str	r3, [r7, #32]
#ifndef NX_DISABLE_PACKET_CHAIN
    while (working_packet_ptr)
 800bfa2:	e016      	b.n	800bfd2 <_nx_packet_data_extract_offset+0x68>
    {

        /*lint -e{946} -e{947} suppress pointer subtraction, since it is necessary. */
        packet_fragment_length =  (ULONG)((working_packet_ptr -> nx_packet_append_ptr - working_packet_ptr -> nx_packet_prepend_ptr));
 800bfa4:	69bb      	ldr	r3, [r7, #24]
 800bfa6:	68da      	ldr	r2, [r3, #12]
 800bfa8:	69bb      	ldr	r3, [r7, #24]
 800bfaa:	689b      	ldr	r3, [r3, #8]
 800bfac:	1ad3      	subs	r3, r2, r3
 800bfae:	617b      	str	r3, [r7, #20]

        /* Determine if we are at the offset location fragment in the packet chain  */
        if (packet_fragment_length > offset_bytes)
 800bfb0:	697a      	ldr	r2, [r7, #20]
 800bfb2:	6a3b      	ldr	r3, [r7, #32]
 800bfb4:	429a      	cmp	r2, r3
 800bfb6:	d905      	bls.n	800bfc4 <_nx_packet_data_extract_offset+0x5a>
        {

            /* Setup loop to copy from this packet.  */
            source_ptr =  working_packet_ptr -> nx_packet_prepend_ptr + offset_bytes;
 800bfb8:	69bb      	ldr	r3, [r7, #24]
 800bfba:	689a      	ldr	r2, [r3, #8]
 800bfbc:	6a3b      	ldr	r3, [r7, #32]
 800bfbe:	4413      	add	r3, r2
 800bfc0:	62bb      	str	r3, [r7, #40]	; 0x28

            /* Yes, get out of this  loop.  */
            break;
 800bfc2:	e009      	b.n	800bfd8 <_nx_packet_data_extract_offset+0x6e>
        }


        /* Decrement the remaining offset bytes*/
        offset_bytes = offset_bytes - packet_fragment_length;
 800bfc4:	6a3a      	ldr	r2, [r7, #32]
 800bfc6:	697b      	ldr	r3, [r7, #20]
 800bfc8:	1ad3      	subs	r3, r2, r3
 800bfca:	623b      	str	r3, [r7, #32]

        /* Move to next packet.  */
        working_packet_ptr =  working_packet_ptr -> nx_packet_next;
 800bfcc:	69bb      	ldr	r3, [r7, #24]
 800bfce:	685b      	ldr	r3, [r3, #4]
 800bfd0:	61bb      	str	r3, [r7, #24]
    while (working_packet_ptr)
 800bfd2:	69bb      	ldr	r3, [r7, #24]
 800bfd4:	2b00      	cmp	r3, #0
 800bfd6:	d1e5      	bne.n	800bfa4 <_nx_packet_data_extract_offset+0x3a>
    source_ptr =  working_packet_ptr -> nx_packet_prepend_ptr + offset_bytes;

#endif /* NX_DISABLE_PACKET_CHAIN */

    /* Check for a valid source pointer.  */
    if (source_ptr == NX_NULL)
 800bfd8:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800bfda:	2b00      	cmp	r3, #0
 800bfdc:	d101      	bne.n	800bfe2 <_nx_packet_data_extract_offset+0x78>
    {
        return(NX_PACKET_OFFSET_ERROR);
 800bfde:	2353      	movs	r3, #83	; 0x53
 800bfe0:	e03e      	b.n	800c060 <_nx_packet_data_extract_offset+0xf6>
    }

    /* Setup the destination pointer.  */
    destination_ptr =  buffer_start;
 800bfe2:	687b      	ldr	r3, [r7, #4]
 800bfe4:	627b      	str	r3, [r7, #36]	; 0x24
    bytes_to_copy =   (packet_ptr -> nx_packet_length - offset);
 800bfe6:	68fb      	ldr	r3, [r7, #12]
 800bfe8:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 800bfea:	68bb      	ldr	r3, [r7, #8]
 800bfec:	1ad3      	subs	r3, r2, r3
 800bfee:	61fb      	str	r3, [r7, #28]

    /* Pickup the amount of bytes to copy.  */
    if (bytes_to_copy < buffer_length)
 800bff0:	69fa      	ldr	r2, [r7, #28]
 800bff2:	683b      	ldr	r3, [r7, #0]
 800bff4:	429a      	cmp	r2, r3
 800bff6:	d205      	bcs.n	800c004 <_nx_packet_data_extract_offset+0x9a>
    {
        *bytes_copied =  bytes_to_copy;     /* the amount of bytes returned to the caller */
 800bff8:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800bffa:	69fa      	ldr	r2, [r7, #28]
 800bffc:	601a      	str	r2, [r3, #0]
        remaining_bytes =  bytes_to_copy;   /* for use in the copy loop */
 800bffe:	69fb      	ldr	r3, [r7, #28]
 800c000:	62fb      	str	r3, [r7, #44]	; 0x2c
 800c002:	e026      	b.n	800c052 <_nx_packet_data_extract_offset+0xe8>
    }
    else
    {
        *bytes_copied =  buffer_length;
 800c004:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800c006:	683a      	ldr	r2, [r7, #0]
 800c008:	601a      	str	r2, [r3, #0]
        remaining_bytes =  buffer_length;
 800c00a:	683b      	ldr	r3, [r7, #0]
 800c00c:	62fb      	str	r3, [r7, #44]	; 0x2c
    }

#ifndef NX_DISABLE_PACKET_CHAIN
    /* Loop to copy bytes from packet(s).  */
    while (working_packet_ptr && remaining_bytes)
 800c00e:	e020      	b.n	800c052 <_nx_packet_data_extract_offset+0xe8>
    {
#endif /* NX_DISABLE_PACKET_CHAIN */

        /* Calculate bytes to copy.  */
        /*lint -e{946} -e{947} suppress pointer subtraction, since it is necessary. */
        bytes_to_copy = (ULONG)(working_packet_ptr -> nx_packet_append_ptr - source_ptr);
 800c010:	69bb      	ldr	r3, [r7, #24]
 800c012:	68da      	ldr	r2, [r3, #12]
 800c014:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800c016:	1ad3      	subs	r3, r2, r3
 800c018:	61fb      	str	r3, [r7, #28]
        if (remaining_bytes < bytes_to_copy)
 800c01a:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 800c01c:	69fb      	ldr	r3, [r7, #28]
 800c01e:	429a      	cmp	r2, r3
 800c020:	d201      	bcs.n	800c026 <_nx_packet_data_extract_offset+0xbc>
        {
            bytes_to_copy = remaining_bytes;
 800c022:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800c024:	61fb      	str	r3, [r7, #28]
        }

        /* Copy data from this packet.  */
        memcpy(destination_ptr, source_ptr, bytes_to_copy); /* Use case of memcpy is verified. */
 800c026:	69fa      	ldr	r2, [r7, #28]
 800c028:	6ab9      	ldr	r1, [r7, #40]	; 0x28
 800c02a:	6a78      	ldr	r0, [r7, #36]	; 0x24
 800c02c:	f013 fbfe 	bl	801f82c <memcpy>

        /* Update the pointers. */
        destination_ptr += bytes_to_copy;
 800c030:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 800c032:	69fb      	ldr	r3, [r7, #28]
 800c034:	4413      	add	r3, r2
 800c036:	627b      	str	r3, [r7, #36]	; 0x24
        remaining_bytes -= bytes_to_copy;
 800c038:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 800c03a:	69fb      	ldr	r3, [r7, #28]
 800c03c:	1ad3      	subs	r3, r2, r3
 800c03e:	62fb      	str	r3, [r7, #44]	; 0x2c

#ifndef NX_DISABLE_PACKET_CHAIN
        /* Move to next packet.  */
        working_packet_ptr =  working_packet_ptr -> nx_packet_next;
 800c040:	69bb      	ldr	r3, [r7, #24]
 800c042:	685b      	ldr	r3, [r3, #4]
 800c044:	61bb      	str	r3, [r7, #24]

        /* Check for a next packet.  */
        if (working_packet_ptr)
 800c046:	69bb      	ldr	r3, [r7, #24]
 800c048:	2b00      	cmp	r3, #0
 800c04a:	d002      	beq.n	800c052 <_nx_packet_data_extract_offset+0xe8>
        {

            /* Setup new source pointer.  */
            source_ptr = working_packet_ptr -> nx_packet_prepend_ptr;
 800c04c:	69bb      	ldr	r3, [r7, #24]
 800c04e:	689b      	ldr	r3, [r3, #8]
 800c050:	62bb      	str	r3, [r7, #40]	; 0x28
    while (working_packet_ptr && remaining_bytes)
 800c052:	69bb      	ldr	r3, [r7, #24]
 800c054:	2b00      	cmp	r3, #0
 800c056:	d002      	beq.n	800c05e <_nx_packet_data_extract_offset+0xf4>
 800c058:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800c05a:	2b00      	cmp	r3, #0
 800c05c:	d1d8      	bne.n	800c010 <_nx_packet_data_extract_offset+0xa6>

    /* If trace is enabled, insert this event into the trace buffer.  */
    NX_TRACE_IN_LINE_INSERT(NX_TRACE_PACKET_DATA_EXTRACT_OFFSET, packet_ptr, buffer_length, *bytes_copied, 0, NX_TRACE_PACKET_EVENTS, 0, 0);

    /* Return successful completion.  */
    return(NX_SUCCESS);
 800c05e:	2300      	movs	r3, #0
}
 800c060:	4618      	mov	r0, r3
 800c062:	3730      	adds	r7, #48	; 0x30
 800c064:	46bd      	mov	sp, r7
 800c066:	bd80      	pop	{r7, pc}

0800c068 <_nx_packet_pool_cleanup>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
VOID  _nx_packet_pool_cleanup(TX_THREAD *thread_ptr NX_CLEANUP_PARAMETER)
{
 800c068:	b580      	push	{r7, lr}
 800c06a:	b088      	sub	sp, #32
 800c06c:	af00      	add	r7, sp, #0
 800c06e:	6078      	str	r0, [r7, #4]
 800c070:	6039      	str	r1, [r7, #0]
NX_PACKET_POOL *pool_ptr;   /* Working packet pool pointer  */

    NX_CLEANUP_EXTENSION

    /* Setup pointer to packet pool control block.  */
    pool_ptr =  (NX_PACKET_POOL *)thread_ptr -> tx_thread_suspend_control_block;
 800c072:	687b      	ldr	r3, [r7, #4]
 800c074:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 800c076:	61fb      	str	r3, [r7, #28]
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 800c078:	f3ef 8310 	mrs	r3, PRIMASK
 800c07c:	617b      	str	r3, [r7, #20]
    return(posture);
 800c07e:	697b      	ldr	r3, [r7, #20]
    int_posture = __get_interrupt_posture();
 800c080:	613b      	str	r3, [r7, #16]
    __asm__ volatile ("CPSID i" : : : "memory");
 800c082:	b672      	cpsid	i
    return(int_posture);
 800c084:	693b      	ldr	r3, [r7, #16]

    /* Disable interrupts to remove the suspended thread from the packet pool.  */
    TX_DISABLE
 800c086:	61bb      	str	r3, [r7, #24]

    /* Determine if the cleanup is still required.  */
    if ((thread_ptr -> tx_thread_suspend_cleanup) && (pool_ptr) &&
 800c088:	687b      	ldr	r3, [r7, #4]
 800c08a:	6e9b      	ldr	r3, [r3, #104]	; 0x68
 800c08c:	2b00      	cmp	r3, #0
 800c08e:	d042      	beq.n	800c116 <_nx_packet_pool_cleanup+0xae>
 800c090:	69fb      	ldr	r3, [r7, #28]
 800c092:	2b00      	cmp	r3, #0
 800c094:	d03f      	beq.n	800c116 <_nx_packet_pool_cleanup+0xae>
        (pool_ptr -> nx_packet_pool_id == NX_PACKET_POOL_ID))
 800c096:	69fb      	ldr	r3, [r7, #28]
 800c098:	681b      	ldr	r3, [r3, #0]
    if ((thread_ptr -> tx_thread_suspend_cleanup) && (pool_ptr) &&
 800c09a:	4a23      	ldr	r2, [pc, #140]	; (800c128 <_nx_packet_pool_cleanup+0xc0>)
 800c09c:	4293      	cmp	r3, r2
 800c09e:	d13a      	bne.n	800c116 <_nx_packet_pool_cleanup+0xae>
    {

        /* Yes, we still have thread suspension!  */

        /* Clear the suspension cleanup flag.  */
        thread_ptr -> tx_thread_suspend_cleanup =  TX_NULL;
 800c0a0:	687b      	ldr	r3, [r7, #4]
 800c0a2:	2200      	movs	r2, #0
 800c0a4:	669a      	str	r2, [r3, #104]	; 0x68

        /* Remove the suspended thread from the list.  */

        /* See if this is the only suspended thread on the list.  */
        if (thread_ptr == thread_ptr -> tx_thread_suspended_next)
 800c0a6:	687b      	ldr	r3, [r7, #4]
 800c0a8:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 800c0aa:	687a      	ldr	r2, [r7, #4]
 800c0ac:	429a      	cmp	r2, r3
 800c0ae:	d103      	bne.n	800c0b8 <_nx_packet_pool_cleanup+0x50>
        {

            /* Yes, the only suspended thread.  */

            /* Update the head pointer.  */
            pool_ptr -> nx_packet_pool_suspension_list =  TX_NULL;
 800c0b0:	69fb      	ldr	r3, [r7, #28]
 800c0b2:	2200      	movs	r2, #0
 800c0b4:	62da      	str	r2, [r3, #44]	; 0x2c
 800c0b6:	e012      	b.n	800c0de <_nx_packet_pool_cleanup+0x76>
        {

            /* At least one more thread is on the same suspension list.  */

            /* Update the list head pointer if necessary.  */
            if (pool_ptr -> nx_packet_pool_suspension_list == thread_ptr)
 800c0b8:	69fb      	ldr	r3, [r7, #28]
 800c0ba:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800c0bc:	687a      	ldr	r2, [r7, #4]
 800c0be:	429a      	cmp	r2, r3
 800c0c0:	d103      	bne.n	800c0ca <_nx_packet_pool_cleanup+0x62>
            {
                pool_ptr -> nx_packet_pool_suspension_list =  thread_ptr -> tx_thread_suspended_next;
 800c0c2:	687b      	ldr	r3, [r7, #4]
 800c0c4:	6f1a      	ldr	r2, [r3, #112]	; 0x70
 800c0c6:	69fb      	ldr	r3, [r7, #28]
 800c0c8:	62da      	str	r2, [r3, #44]	; 0x2c
            }

            /* Update the links of the adjacent threads.  */
            (thread_ptr -> tx_thread_suspended_next) -> tx_thread_suspended_previous =
 800c0ca:	687b      	ldr	r3, [r7, #4]
 800c0cc:	6f1b      	ldr	r3, [r3, #112]	; 0x70
                thread_ptr -> tx_thread_suspended_previous;
 800c0ce:	687a      	ldr	r2, [r7, #4]
 800c0d0:	6f52      	ldr	r2, [r2, #116]	; 0x74
            (thread_ptr -> tx_thread_suspended_next) -> tx_thread_suspended_previous =
 800c0d2:	675a      	str	r2, [r3, #116]	; 0x74
            (thread_ptr -> tx_thread_suspended_previous) -> tx_thread_suspended_next =
 800c0d4:	687b      	ldr	r3, [r7, #4]
 800c0d6:	6f5b      	ldr	r3, [r3, #116]	; 0x74
                thread_ptr -> tx_thread_suspended_next;
 800c0d8:	687a      	ldr	r2, [r7, #4]
 800c0da:	6f12      	ldr	r2, [r2, #112]	; 0x70
            (thread_ptr -> tx_thread_suspended_previous) -> tx_thread_suspended_next =
 800c0dc:	671a      	str	r2, [r3, #112]	; 0x70
        }

        /* Decrement the suspension count.  */
        pool_ptr -> nx_packet_pool_suspended_count--;
 800c0de:	69fb      	ldr	r3, [r7, #28]
 800c0e0:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800c0e2:	1e5a      	subs	r2, r3, #1
 800c0e4:	69fb      	ldr	r3, [r7, #28]
 800c0e6:	631a      	str	r2, [r3, #48]	; 0x30

        /* Now we need to determine if this cleanup is from a terminate, timeout,
           or from a wait abort.  */
        if (thread_ptr -> tx_thread_state == TX_TCP_IP)
 800c0e8:	687b      	ldr	r3, [r7, #4]
 800c0ea:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800c0ec:	2b0c      	cmp	r3, #12
 800c0ee:	d112      	bne.n	800c116 <_nx_packet_pool_cleanup+0xae>

            /* Thread still suspended on the packet pool.  Setup return error status and
               resume the thread.  */

            /* Setup return status.  */
            thread_ptr -> tx_thread_suspend_status =  NX_NO_PACKET;
 800c0f0:	687b      	ldr	r3, [r7, #4]
 800c0f2:	2201      	movs	r2, #1
 800c0f4:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84

            /* Temporarily disable preemption.  */
            _tx_thread_preempt_disable++;
 800c0f8:	4b0c      	ldr	r3, [pc, #48]	; (800c12c <_nx_packet_pool_cleanup+0xc4>)
 800c0fa:	681b      	ldr	r3, [r3, #0]
 800c0fc:	3301      	adds	r3, #1
 800c0fe:	4a0b      	ldr	r2, [pc, #44]	; (800c12c <_nx_packet_pool_cleanup+0xc4>)
 800c100:	6013      	str	r3, [r2, #0]
 800c102:	69bb      	ldr	r3, [r7, #24]
 800c104:	60fb      	str	r3, [r7, #12]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 800c106:	68fb      	ldr	r3, [r7, #12]
 800c108:	f383 8810 	msr	PRIMASK, r3
}
 800c10c:	bf00      	nop
            TX_RESTORE

            /* Resume the thread!  Check for preemption even though we are executing
               from the system timer thread right now which normally executes at the
               highest priority.  */
            _tx_thread_system_resume(thread_ptr);
 800c10e:	6878      	ldr	r0, [r7, #4]
 800c110:	f008 fe0a 	bl	8014d28 <_tx_thread_system_resume>

            /* Finished, just return.  */
            return;
 800c114:	e005      	b.n	800c122 <_nx_packet_pool_cleanup+0xba>
 800c116:	69bb      	ldr	r3, [r7, #24]
 800c118:	60bb      	str	r3, [r7, #8]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 800c11a:	68bb      	ldr	r3, [r7, #8]
 800c11c:	f383 8810 	msr	PRIMASK, r3
}
 800c120:	bf00      	nop
        }
    }

    /* Restore interrupts.  */
    TX_RESTORE
}
 800c122:	3720      	adds	r7, #32
 800c124:	46bd      	mov	sp, r7
 800c126:	bd80      	pop	{r7, pc}
 800c128:	5041434b 	.word	0x5041434b
 800c12c:	24031c5c 	.word	0x24031c5c

0800c130 <_nx_packet_pool_create>:
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
UINT  _nx_packet_pool_create(NX_PACKET_POOL *pool_ptr, CHAR *name_ptr, ULONG payload_size,
                             VOID *pool_start, ULONG pool_size)
{
 800c130:	b580      	push	{r7, lr}
 800c132:	b092      	sub	sp, #72	; 0x48
 800c134:	af00      	add	r7, sp, #0
 800c136:	60f8      	str	r0, [r7, #12]
 800c138:	60b9      	str	r1, [r7, #8]
 800c13a:	607a      	str	r2, [r7, #4]
 800c13c:	603b      	str	r3, [r7, #0]
CHAR           *payload_address;       /* Address of the first payload*/
VOID           *rounded_pool_start;    /* Rounded stating address     */


    /* Save the original payload size.  */
    original_payload_size =  payload_size;
 800c13e:	687b      	ldr	r3, [r7, #4]
 800c140:	63bb      	str	r3, [r7, #56]	; 0x38

    /* Align the starting address to four bytes. */
    /*lint -e{923} suppress cast between ULONG and pointer.  */
    rounded_pool_start = (VOID *)((((ALIGN_TYPE)pool_start + NX_PACKET_ALIGNMENT  - 1) / NX_PACKET_ALIGNMENT) * NX_PACKET_ALIGNMENT);
 800c142:	683b      	ldr	r3, [r7, #0]
 800c144:	3303      	adds	r3, #3
 800c146:	f023 0303 	bic.w	r3, r3, #3
 800c14a:	637b      	str	r3, [r7, #52]	; 0x34

    /* Round the pool size down to something that is evenly divisible by alignment.  */
    /*lint -e{923} suppress cast between ULONG and pointer.  */
    pool_size = (ULONG)(((pool_size - ((ALIGN_TYPE)rounded_pool_start - (ALIGN_TYPE)pool_start)) / NX_PACKET_ALIGNMENT) * NX_PACKET_ALIGNMENT);
 800c14c:	683a      	ldr	r2, [r7, #0]
 800c14e:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800c150:	1ad2      	subs	r2, r2, r3
 800c152:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 800c154:	4413      	add	r3, r2
 800c156:	f023 0303 	bic.w	r3, r3, #3
 800c15a:	653b      	str	r3, [r7, #80]	; 0x50

    /* Set the pool starting address. */
    pool_start = rounded_pool_start;
 800c15c:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800c15e:	603b      	str	r3, [r7, #0]

    /* Calculate the address of payload. */
    /*lint -e{923} suppress cast between ULONG and pointer.  */
    payload_address = (CHAR *)((ALIGN_TYPE)rounded_pool_start + sizeof(NX_PACKET));
 800c160:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800c162:	3338      	adds	r3, #56	; 0x38
 800c164:	633b      	str	r3, [r7, #48]	; 0x30

    /* Align the address of payload. */
    /*lint -e{923} suppress cast between ULONG and pointer.  */
    payload_address = (CHAR *)((((ALIGN_TYPE)payload_address + NX_PACKET_ALIGNMENT  - 1) / NX_PACKET_ALIGNMENT) * NX_PACKET_ALIGNMENT);
 800c166:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800c168:	3303      	adds	r3, #3
 800c16a:	f023 0303 	bic.w	r3, r3, #3
 800c16e:	633b      	str	r3, [r7, #48]	; 0x30

    /* Calculate the header size. */
    /*lint -e{923} suppress cast between ULONG and pointer.  */
    header_size = (ULONG)((ALIGN_TYPE)payload_address - (ALIGN_TYPE)rounded_pool_start);
 800c170:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 800c172:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800c174:	1ad3      	subs	r3, r2, r3
 800c176:	62fb      	str	r3, [r7, #44]	; 0x2c

    /* Round the packet size up to something that helps guarantee proper alignment for header and payload.  */
    payload_size = (ULONG)(((header_size + payload_size + NX_PACKET_ALIGNMENT  - 1) / NX_PACKET_ALIGNMENT) * NX_PACKET_ALIGNMENT - header_size);
 800c178:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 800c17a:	687b      	ldr	r3, [r7, #4]
 800c17c:	4413      	add	r3, r2
 800c17e:	3303      	adds	r3, #3
 800c180:	f023 0203 	bic.w	r2, r3, #3
 800c184:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800c186:	1ad3      	subs	r3, r2, r3
 800c188:	607b      	str	r3, [r7, #4]

    /* Clear pool fields. */
    memset(pool_ptr, 0, sizeof(NX_PACKET_POOL));
 800c18a:	223c      	movs	r2, #60	; 0x3c
 800c18c:	2100      	movs	r1, #0
 800c18e:	68f8      	ldr	r0, [r7, #12]
 800c190:	f013 fb74 	bl	801f87c <memset>

    /* Setup the basic packet pool fields.  */
    pool_ptr -> nx_packet_pool_name =             name_ptr;
 800c194:	68fb      	ldr	r3, [r7, #12]
 800c196:	68ba      	ldr	r2, [r7, #8]
 800c198:	605a      	str	r2, [r3, #4]
    pool_ptr -> nx_packet_pool_suspension_list =  TX_NULL;
 800c19a:	68fb      	ldr	r3, [r7, #12]
 800c19c:	2200      	movs	r2, #0
 800c19e:	62da      	str	r2, [r3, #44]	; 0x2c
    pool_ptr -> nx_packet_pool_suspended_count =  0;
 800c1a0:	68fb      	ldr	r3, [r7, #12]
 800c1a2:	2200      	movs	r2, #0
 800c1a4:	631a      	str	r2, [r3, #48]	; 0x30
    pool_ptr -> nx_packet_pool_start =            (CHAR *)pool_start;
 800c1a6:	68fb      	ldr	r3, [r7, #12]
 800c1a8:	683a      	ldr	r2, [r7, #0]
 800c1aa:	621a      	str	r2, [r3, #32]
    pool_ptr -> nx_packet_pool_size =             pool_size;
 800c1ac:	68fb      	ldr	r3, [r7, #12]
 800c1ae:	6d3a      	ldr	r2, [r7, #80]	; 0x50
 800c1b0:	625a      	str	r2, [r3, #36]	; 0x24
    pool_ptr -> nx_packet_pool_payload_size =     original_payload_size;
 800c1b2:	68fb      	ldr	r3, [r7, #12]
 800c1b4:	6bba      	ldr	r2, [r7, #56]	; 0x38
 800c1b6:	629a      	str	r2, [r3, #40]	; 0x28

    /* Calculate the end of the pool's memory area.  */
    end_of_pool =  ((CHAR *)pool_start) + pool_size;
 800c1b8:	683a      	ldr	r2, [r7, #0]
 800c1ba:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 800c1bc:	4413      	add	r3, r2
 800c1be:	62bb      	str	r3, [r7, #40]	; 0x28

    /* Walk through the pool area, setting up the available packet list.  */
    packets =            0;
 800c1c0:	2300      	movs	r3, #0
 800c1c2:	647b      	str	r3, [r7, #68]	; 0x44
    packet_ptr =         (CHAR *)rounded_pool_start;
 800c1c4:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800c1c6:	643b      	str	r3, [r7, #64]	; 0x40
    next_packet_ptr =    packet_ptr + (payload_size + header_size);
 800c1c8:	687a      	ldr	r2, [r7, #4]
 800c1ca:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800c1cc:	4413      	add	r3, r2
 800c1ce:	6c3a      	ldr	r2, [r7, #64]	; 0x40
 800c1d0:	4413      	add	r3, r2
 800c1d2:	63fb      	str	r3, [r7, #60]	; 0x3c

    /*lint -e{946} suppress pointer subtraction, since it is necessary. */
    while (next_packet_ptr <= end_of_pool)
 800c1d4:	e023      	b.n	800c21e <_nx_packet_pool_create+0xee>
    {

        /* Yes, we have another packet.  Increment the packet count.  */
        packets++;
 800c1d6:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 800c1d8:	3301      	adds	r3, #1
 800c1da:	647b      	str	r3, [r7, #68]	; 0x44

        /* Setup the link to the next packet.  */
        /*lint -e{929} -e{740} -e{826} suppress cast of pointer to pointer, since it is necessary  */
        ((NX_PACKET *)packet_ptr) -> nx_packet_queue_next =  (NX_PACKET *)next_packet_ptr;
 800c1dc:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 800c1de:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 800c1e0:	61da      	str	r2, [r3, #28]

        /* Remember that this packet pool is the owner.  */
        /*lint -e{929} -e{740} -e{826} suppress cast of pointer to pointer, since it is necessary  */
        ((NX_PACKET *)packet_ptr) -> nx_packet_pool_owner =  pool_ptr;
 800c1e2:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 800c1e4:	68fa      	ldr	r2, [r7, #12]
 800c1e6:	601a      	str	r2, [r3, #0]

#ifndef NX_DISABLE_PACKET_CHAIN
        /* Clear the next packet pointer.  */
        /*lint -e{929} -e{740} -e{826} suppress cast of pointer to pointer, since it is necessary  */
        ((NX_PACKET *)packet_ptr) -> nx_packet_next =  (NX_PACKET *)NX_NULL;
 800c1e8:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 800c1ea:	2200      	movs	r2, #0
 800c1ec:	605a      	str	r2, [r3, #4]
#endif /* NX_DISABLE_PACKET_CHAIN */

        /* Mark the packet as free.  */
        /*lint -e{929} -e{923} -e{740} -e{826} suppress cast of pointer to pointer, since it is necessary  */
        ((NX_PACKET *)packet_ptr) -> nx_packet_union_next.nx_packet_tcp_queue_next =  (NX_PACKET *)NX_PACKET_FREE;
 800c1ee:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 800c1f0:	f04f 32ff 	mov.w	r2, #4294967295
 800c1f4:	621a      	str	r2, [r3, #32]

        /* Setup the packet data pointers.  */
        /*lint -e{929} -e{928} -e{740} -e{826} suppress cast of pointer to pointer, since it is necessary  */
        ((NX_PACKET *)packet_ptr) -> nx_packet_data_start =  (UCHAR *)(packet_ptr + header_size);
 800c1f6:	6c3a      	ldr	r2, [r7, #64]	; 0x40
 800c1f8:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800c1fa:	441a      	add	r2, r3
 800c1fc:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 800c1fe:	611a      	str	r2, [r3, #16]

        /*lint -e{929} -e{928} -e{740} -e{826} suppress cast of pointer to pointer, since it is necessary  */
        ((NX_PACKET *)packet_ptr) -> nx_packet_data_end =    (UCHAR *)(packet_ptr + header_size + original_payload_size);
 800c200:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 800c202:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800c204:	4413      	add	r3, r2
 800c206:	6c3a      	ldr	r2, [r7, #64]	; 0x40
 800c208:	441a      	add	r2, r3
 800c20a:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 800c20c:	615a      	str	r2, [r3, #20]

        /* Add debug information. */
        NX_PACKET_DEBUG(__FILE__, __LINE__, (NX_PACKET *)packet_ptr);

        /* Advance to the next packet.  */
        packet_ptr =   next_packet_ptr;
 800c20e:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800c210:	643b      	str	r3, [r7, #64]	; 0x40

        /* Update the next packet pointer.  */
        next_packet_ptr =  packet_ptr + (payload_size + header_size);
 800c212:	687a      	ldr	r2, [r7, #4]
 800c214:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800c216:	4413      	add	r3, r2
 800c218:	6c3a      	ldr	r2, [r7, #64]	; 0x40
 800c21a:	4413      	add	r3, r2
 800c21c:	63fb      	str	r3, [r7, #60]	; 0x3c
    while (next_packet_ptr <= end_of_pool)
 800c21e:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 800c220:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800c222:	429a      	cmp	r2, r3
 800c224:	d9d7      	bls.n	800c1d6 <_nx_packet_pool_create+0xa6>
    }

    /* Backup to the last packet in the pool.  */
    packet_ptr =  packet_ptr - (payload_size + header_size);
 800c226:	687a      	ldr	r2, [r7, #4]
 800c228:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800c22a:	4413      	add	r3, r2
 800c22c:	425b      	negs	r3, r3
 800c22e:	6c3a      	ldr	r2, [r7, #64]	; 0x40
 800c230:	4413      	add	r3, r2
 800c232:	643b      	str	r3, [r7, #64]	; 0x40

    /* Set the last packet's forward pointer to NULL.  */
    /*lint -e{929} -e{740} -e{826} suppress cast of pointer to pointer, since it is necessary  */
    ((NX_PACKET *)packet_ptr) -> nx_packet_queue_next =  NX_NULL;
 800c234:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 800c236:	2200      	movs	r2, #0
 800c238:	61da      	str	r2, [r3, #28]

    /* Save the remaining information in the pool control packet.  */
    pool_ptr -> nx_packet_pool_available =  packets;
 800c23a:	68fb      	ldr	r3, [r7, #12]
 800c23c:	6c7a      	ldr	r2, [r7, #68]	; 0x44
 800c23e:	609a      	str	r2, [r3, #8]
    pool_ptr -> nx_packet_pool_total =      packets;
 800c240:	68fb      	ldr	r3, [r7, #12]
 800c242:	6c7a      	ldr	r2, [r7, #68]	; 0x44
 800c244:	60da      	str	r2, [r3, #12]

    /* Set the packet pool available list.  */
    pool_ptr -> nx_packet_pool_available_list =  (NX_PACKET *)pool_start;
 800c246:	68fb      	ldr	r3, [r7, #12]
 800c248:	683a      	ldr	r2, [r7, #0]
 800c24a:	61da      	str	r2, [r3, #28]
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 800c24c:	f3ef 8310 	mrs	r3, PRIMASK
 800c250:	61fb      	str	r3, [r7, #28]
    return(posture);
 800c252:	69fb      	ldr	r3, [r7, #28]
    int_posture = __get_interrupt_posture();
 800c254:	61bb      	str	r3, [r7, #24]
    __asm__ volatile ("CPSID i" : : : "memory");
 800c256:	b672      	cpsid	i
    return(int_posture);
 800c258:	69bb      	ldr	r3, [r7, #24]

    /* If trace is enabled, insert this event into the trace buffer.  */
    NX_TRACE_IN_LINE_INSERT(NX_TRACE_PACKET_POOL_CREATE, pool_ptr, payload_size, pool_start, pool_size, NX_TRACE_PACKET_EVENTS, 0, 0);

    /* Disable interrupts to place the packet pool on the created list.  */
    TX_DISABLE
 800c25a:	627b      	str	r3, [r7, #36]	; 0x24

    /* Setup the packet pool ID to make it valid.  */
    pool_ptr -> nx_packet_pool_id =  NX_PACKET_POOL_ID;
 800c25c:	68fb      	ldr	r3, [r7, #12]
 800c25e:	4a19      	ldr	r2, [pc, #100]	; (800c2c4 <_nx_packet_pool_create+0x194>)
 800c260:	601a      	str	r2, [r3, #0]

    /* Place the packet pool on the list of created packet pools.  First,
       check for an empty list.  */
    if (_nx_packet_pool_created_ptr)
 800c262:	4b19      	ldr	r3, [pc, #100]	; (800c2c8 <_nx_packet_pool_create+0x198>)
 800c264:	681b      	ldr	r3, [r3, #0]
 800c266:	2b00      	cmp	r3, #0
 800c268:	d012      	beq.n	800c290 <_nx_packet_pool_create+0x160>
    {

        /* Pickup tail pointer.  */
        tail_ptr =  _nx_packet_pool_created_ptr -> nx_packet_pool_created_previous;
 800c26a:	4b17      	ldr	r3, [pc, #92]	; (800c2c8 <_nx_packet_pool_create+0x198>)
 800c26c:	681b      	ldr	r3, [r3, #0]
 800c26e:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 800c270:	623b      	str	r3, [r7, #32]

        /* Place the new packet pool in the list.  */
        _nx_packet_pool_created_ptr -> nx_packet_pool_created_previous =  pool_ptr;
 800c272:	4b15      	ldr	r3, [pc, #84]	; (800c2c8 <_nx_packet_pool_create+0x198>)
 800c274:	681b      	ldr	r3, [r3, #0]
 800c276:	68fa      	ldr	r2, [r7, #12]
 800c278:	639a      	str	r2, [r3, #56]	; 0x38
        tail_ptr -> nx_packet_pool_created_next =  pool_ptr;
 800c27a:	6a3b      	ldr	r3, [r7, #32]
 800c27c:	68fa      	ldr	r2, [r7, #12]
 800c27e:	635a      	str	r2, [r3, #52]	; 0x34

        /* Setup this packet pool's created links.  */
        pool_ptr -> nx_packet_pool_created_previous =  tail_ptr;
 800c280:	68fb      	ldr	r3, [r7, #12]
 800c282:	6a3a      	ldr	r2, [r7, #32]
 800c284:	639a      	str	r2, [r3, #56]	; 0x38
        pool_ptr -> nx_packet_pool_created_next =      _nx_packet_pool_created_ptr;
 800c286:	4b10      	ldr	r3, [pc, #64]	; (800c2c8 <_nx_packet_pool_create+0x198>)
 800c288:	681a      	ldr	r2, [r3, #0]
 800c28a:	68fb      	ldr	r3, [r7, #12]
 800c28c:	635a      	str	r2, [r3, #52]	; 0x34
 800c28e:	e008      	b.n	800c2a2 <_nx_packet_pool_create+0x172>
    }
    else
    {

        /* The created packet pool list is empty.  Add packet pool to empty list.  */
        _nx_packet_pool_created_ptr =                  pool_ptr;
 800c290:	4a0d      	ldr	r2, [pc, #52]	; (800c2c8 <_nx_packet_pool_create+0x198>)
 800c292:	68fb      	ldr	r3, [r7, #12]
 800c294:	6013      	str	r3, [r2, #0]
        pool_ptr -> nx_packet_pool_created_next =      pool_ptr;
 800c296:	68fb      	ldr	r3, [r7, #12]
 800c298:	68fa      	ldr	r2, [r7, #12]
 800c29a:	635a      	str	r2, [r3, #52]	; 0x34
        pool_ptr -> nx_packet_pool_created_previous =  pool_ptr;
 800c29c:	68fb      	ldr	r3, [r7, #12]
 800c29e:	68fa      	ldr	r2, [r7, #12]
 800c2a0:	639a      	str	r2, [r3, #56]	; 0x38
    }

    /* Increment the number of packet pools created.  */
    _nx_packet_pool_created_count++;
 800c2a2:	4b0a      	ldr	r3, [pc, #40]	; (800c2cc <_nx_packet_pool_create+0x19c>)
 800c2a4:	681b      	ldr	r3, [r3, #0]
 800c2a6:	3301      	adds	r3, #1
 800c2a8:	4a08      	ldr	r2, [pc, #32]	; (800c2cc <_nx_packet_pool_create+0x19c>)
 800c2aa:	6013      	str	r3, [r2, #0]
 800c2ac:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800c2ae:	617b      	str	r3, [r7, #20]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 800c2b0:	697b      	ldr	r3, [r7, #20]
 800c2b2:	f383 8810 	msr	PRIMASK, r3
}
 800c2b6:	bf00      	nop

    /* Restore interrupts.  */
    TX_RESTORE

    /* Return NX_SUCCESS.  */
    return(NX_SUCCESS);
 800c2b8:	2300      	movs	r3, #0
}
 800c2ba:	4618      	mov	r0, r3
 800c2bc:	3748      	adds	r7, #72	; 0x48
 800c2be:	46bd      	mov	sp, r7
 800c2c0:	bd80      	pop	{r7, pc}
 800c2c2:	bf00      	nop
 800c2c4:	5041434b 	.word	0x5041434b
 800c2c8:	24000b10 	.word	0x24000b10
 800c2cc:	24000b14 	.word	0x24000b14

0800c2d0 <_nx_packet_pool_delete>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
UINT  _nx_packet_pool_delete(NX_PACKET_POOL *pool_ptr)
{
 800c2d0:	b580      	push	{r7, lr}
 800c2d2:	b08e      	sub	sp, #56	; 0x38
 800c2d4:	af00      	add	r7, sp, #0
 800c2d6:	6078      	str	r0, [r7, #4]
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 800c2d8:	f3ef 8310 	mrs	r3, PRIMASK
 800c2dc:	62fb      	str	r3, [r7, #44]	; 0x2c
    return(posture);
 800c2de:	6afb      	ldr	r3, [r7, #44]	; 0x2c
    int_posture = __get_interrupt_posture();
 800c2e0:	62bb      	str	r3, [r7, #40]	; 0x28
    __asm__ volatile ("CPSID i" : : : "memory");
 800c2e2:	b672      	cpsid	i
    return(int_posture);
 800c2e4:	6abb      	ldr	r3, [r7, #40]	; 0x28

TX_THREAD *thread_ptr;      /* Working thread pointer  */


    /* Disable interrupts to remove the packet pool from the created list.  */
    TX_DISABLE
 800c2e6:	633b      	str	r3, [r7, #48]	; 0x30

    /* Decrement the number of packet pools created.  */
    _nx_packet_pool_created_count--;
 800c2e8:	4b3b      	ldr	r3, [pc, #236]	; (800c3d8 <_nx_packet_pool_delete+0x108>)
 800c2ea:	681b      	ldr	r3, [r3, #0]
 800c2ec:	3b01      	subs	r3, #1
 800c2ee:	4a3a      	ldr	r2, [pc, #232]	; (800c3d8 <_nx_packet_pool_delete+0x108>)
 800c2f0:	6013      	str	r3, [r2, #0]

    /* Clear the packet pool ID to make it invalid.  */
    pool_ptr -> nx_packet_pool_id =  0;
 800c2f2:	687b      	ldr	r3, [r7, #4]
 800c2f4:	2200      	movs	r2, #0
 800c2f6:	601a      	str	r2, [r3, #0]

    /* See if the packet pool only one on the list.  */
    if (pool_ptr == pool_ptr -> nx_packet_pool_created_next)
 800c2f8:	687b      	ldr	r3, [r7, #4]
 800c2fa:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 800c2fc:	687a      	ldr	r2, [r7, #4]
 800c2fe:	429a      	cmp	r2, r3
 800c300:	d103      	bne.n	800c30a <_nx_packet_pool_delete+0x3a>
    {

        /* Only created packet pool, just set the created list to NULL.  */
        _nx_packet_pool_created_ptr =  NX_NULL;
 800c302:	4b36      	ldr	r3, [pc, #216]	; (800c3dc <_nx_packet_pool_delete+0x10c>)
 800c304:	2200      	movs	r2, #0
 800c306:	601a      	str	r2, [r3, #0]
 800c308:	e012      	b.n	800c330 <_nx_packet_pool_delete+0x60>
    }
    else
    {

        /* Link-up the neighbors.  */
        (pool_ptr -> nx_packet_pool_created_next) -> nx_packet_pool_created_previous =
 800c30a:	687b      	ldr	r3, [r7, #4]
 800c30c:	6b5b      	ldr	r3, [r3, #52]	; 0x34
            pool_ptr -> nx_packet_pool_created_previous;
 800c30e:	687a      	ldr	r2, [r7, #4]
 800c310:	6b92      	ldr	r2, [r2, #56]	; 0x38
        (pool_ptr -> nx_packet_pool_created_next) -> nx_packet_pool_created_previous =
 800c312:	639a      	str	r2, [r3, #56]	; 0x38
        (pool_ptr -> nx_packet_pool_created_previous) -> nx_packet_pool_created_next =
 800c314:	687b      	ldr	r3, [r7, #4]
 800c316:	6b9b      	ldr	r3, [r3, #56]	; 0x38
            pool_ptr -> nx_packet_pool_created_next;
 800c318:	687a      	ldr	r2, [r7, #4]
 800c31a:	6b52      	ldr	r2, [r2, #52]	; 0x34
        (pool_ptr -> nx_packet_pool_created_previous) -> nx_packet_pool_created_next =
 800c31c:	635a      	str	r2, [r3, #52]	; 0x34

        /* See if we have to update the created list head pointer.  */
        if (_nx_packet_pool_created_ptr == pool_ptr)
 800c31e:	4b2f      	ldr	r3, [pc, #188]	; (800c3dc <_nx_packet_pool_delete+0x10c>)
 800c320:	681b      	ldr	r3, [r3, #0]
 800c322:	687a      	ldr	r2, [r7, #4]
 800c324:	429a      	cmp	r2, r3
 800c326:	d103      	bne.n	800c330 <_nx_packet_pool_delete+0x60>
        {

            /* Yes, move the head pointer to the next link. */
            _nx_packet_pool_created_ptr =  pool_ptr -> nx_packet_pool_created_next;
 800c328:	687b      	ldr	r3, [r7, #4]
 800c32a:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 800c32c:	4a2b      	ldr	r2, [pc, #172]	; (800c3dc <_nx_packet_pool_delete+0x10c>)
 800c32e:	6013      	str	r3, [r2, #0]
        }
    }

    /* Temporarily disable preemption.  */
    _tx_thread_preempt_disable++;
 800c330:	4b2b      	ldr	r3, [pc, #172]	; (800c3e0 <_nx_packet_pool_delete+0x110>)
 800c332:	681b      	ldr	r3, [r3, #0]
 800c334:	3301      	adds	r3, #1
 800c336:	4a2a      	ldr	r2, [pc, #168]	; (800c3e0 <_nx_packet_pool_delete+0x110>)
 800c338:	6013      	str	r3, [r2, #0]
 800c33a:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800c33c:	627b      	str	r3, [r7, #36]	; 0x24
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 800c33e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800c340:	f383 8810 	msr	PRIMASK, r3
}
 800c344:	bf00      	nop
    /* Restore interrupts.  */
    TX_RESTORE

    /* Walk through the packet pool suspension list to resume any and all
       threads suspended on this packet pool.  */
    thread_ptr =  pool_ptr -> nx_packet_pool_suspension_list;
 800c346:	687b      	ldr	r3, [r7, #4]
 800c348:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800c34a:	637b      	str	r3, [r7, #52]	; 0x34
    while (pool_ptr -> nx_packet_pool_suspended_count)
 800c34c:	e026      	b.n	800c39c <_nx_packet_pool_delete+0xcc>
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 800c34e:	f3ef 8310 	mrs	r3, PRIMASK
 800c352:	61fb      	str	r3, [r7, #28]
    return(posture);
 800c354:	69fb      	ldr	r3, [r7, #28]
    int_posture = __get_interrupt_posture();
 800c356:	61bb      	str	r3, [r7, #24]
    __asm__ volatile ("CPSID i" : : : "memory");
 800c358:	b672      	cpsid	i
    return(int_posture);
 800c35a:	69bb      	ldr	r3, [r7, #24]
    {
        /* Lockout interrupts.  */
        TX_DISABLE
 800c35c:	633b      	str	r3, [r7, #48]	; 0x30

        /* Clear the cleanup pointer, this prevents the timeout from doing
           anything.  */
        thread_ptr -> tx_thread_suspend_cleanup =  TX_NULL;
 800c35e:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800c360:	2200      	movs	r2, #0
 800c362:	669a      	str	r2, [r3, #104]	; 0x68

        /* Temporarily disable preemption again.  */
        _tx_thread_preempt_disable++;
 800c364:	4b1e      	ldr	r3, [pc, #120]	; (800c3e0 <_nx_packet_pool_delete+0x110>)
 800c366:	681b      	ldr	r3, [r3, #0]
 800c368:	3301      	adds	r3, #1
 800c36a:	4a1d      	ldr	r2, [pc, #116]	; (800c3e0 <_nx_packet_pool_delete+0x110>)
 800c36c:	6013      	str	r3, [r2, #0]
 800c36e:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800c370:	623b      	str	r3, [r7, #32]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 800c372:	6a3b      	ldr	r3, [r7, #32]
 800c374:	f383 8810 	msr	PRIMASK, r3
}
 800c378:	bf00      	nop

        /* Restore interrupts.  */
        TX_RESTORE

        /* Set the return status in the thread to NX_POOL_DELETED.  */
        thread_ptr -> tx_thread_suspend_status =  NX_POOL_DELETED;
 800c37a:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800c37c:	2230      	movs	r2, #48	; 0x30
 800c37e:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84

        /* Move the thread pointer ahead.  */
        thread_ptr =  thread_ptr -> tx_thread_suspended_next;
 800c382:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800c384:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 800c386:	637b      	str	r3, [r7, #52]	; 0x34

        /* Resume the thread.  */
        _tx_thread_system_resume(thread_ptr -> tx_thread_suspended_previous);
 800c388:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800c38a:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 800c38c:	4618      	mov	r0, r3
 800c38e:	f008 fccb 	bl	8014d28 <_tx_thread_system_resume>

        /* Decrease the suspended count.  */
        pool_ptr -> nx_packet_pool_suspended_count--;
 800c392:	687b      	ldr	r3, [r7, #4]
 800c394:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800c396:	1e5a      	subs	r2, r3, #1
 800c398:	687b      	ldr	r3, [r7, #4]
 800c39a:	631a      	str	r2, [r3, #48]	; 0x30
    while (pool_ptr -> nx_packet_pool_suspended_count)
 800c39c:	687b      	ldr	r3, [r7, #4]
 800c39e:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800c3a0:	2b00      	cmp	r3, #0
 800c3a2:	d1d4      	bne.n	800c34e <_nx_packet_pool_delete+0x7e>
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 800c3a4:	f3ef 8310 	mrs	r3, PRIMASK
 800c3a8:	613b      	str	r3, [r7, #16]
    return(posture);
 800c3aa:	693b      	ldr	r3, [r7, #16]
    int_posture = __get_interrupt_posture();
 800c3ac:	60fb      	str	r3, [r7, #12]
    __asm__ volatile ("CPSID i" : : : "memory");
 800c3ae:	b672      	cpsid	i
    return(int_posture);
 800c3b0:	68fb      	ldr	r3, [r7, #12]
    }

    /* Disable interrupts.  */
    TX_DISABLE
 800c3b2:	633b      	str	r3, [r7, #48]	; 0x30

    /* Release previous preempt disable.  */
    _tx_thread_preempt_disable--;
 800c3b4:	4b0a      	ldr	r3, [pc, #40]	; (800c3e0 <_nx_packet_pool_delete+0x110>)
 800c3b6:	681b      	ldr	r3, [r3, #0]
 800c3b8:	3b01      	subs	r3, #1
 800c3ba:	4a09      	ldr	r2, [pc, #36]	; (800c3e0 <_nx_packet_pool_delete+0x110>)
 800c3bc:	6013      	str	r3, [r2, #0]
 800c3be:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800c3c0:	617b      	str	r3, [r7, #20]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 800c3c2:	697b      	ldr	r3, [r7, #20]
 800c3c4:	f383 8810 	msr	PRIMASK, r3
}
 800c3c8:	bf00      	nop

    /* If trace is enabled, unregister this object.  */
    NX_TRACE_OBJECT_UNREGISTER(pool_ptr);

    /* Check for preemption.  */
    _tx_thread_system_preempt_check();
 800c3ca:	f008 fc73 	bl	8014cb4 <_tx_thread_system_preempt_check>

    /* Return NX_SUCCESS.  */
    return(NX_SUCCESS);
 800c3ce:	2300      	movs	r3, #0
}
 800c3d0:	4618      	mov	r0, r3
 800c3d2:	3738      	adds	r7, #56	; 0x38
 800c3d4:	46bd      	mov	sp, r7
 800c3d6:	bd80      	pop	{r7, pc}
 800c3d8:	24000b14 	.word	0x24000b14
 800c3dc:	24000b10 	.word	0x24000b10
 800c3e0:	24031c5c 	.word	0x24031c5c

0800c3e4 <_nx_packet_pool_initialize>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
VOID    _nx_packet_pool_initialize(VOID)
{
 800c3e4:	b480      	push	{r7}
 800c3e6:	af00      	add	r7, sp, #0

    /* Initialize the head pointer of the created packet pools list and the
       number of packet pools created.  */
    _nx_packet_pool_created_ptr =        NX_NULL;
 800c3e8:	4b05      	ldr	r3, [pc, #20]	; (800c400 <_nx_packet_pool_initialize+0x1c>)
 800c3ea:	2200      	movs	r2, #0
 800c3ec:	601a      	str	r2, [r3, #0]
    _nx_packet_pool_created_count =      0;
 800c3ee:	4b05      	ldr	r3, [pc, #20]	; (800c404 <_nx_packet_pool_initialize+0x20>)
 800c3f0:	2200      	movs	r2, #0
 800c3f2:	601a      	str	r2, [r3, #0]
}
 800c3f4:	bf00      	nop
 800c3f6:	46bd      	mov	sp, r7
 800c3f8:	f85d 7b04 	ldr.w	r7, [sp], #4
 800c3fc:	4770      	bx	lr
 800c3fe:	bf00      	nop
 800c400:	24000b10 	.word	0x24000b10
 800c404:	24000b14 	.word	0x24000b14

0800c408 <_nx_packet_release>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
UINT  _nx_packet_release(NX_PACKET *packet_ptr)
{
 800c408:	b580      	push	{r7, lr}
 800c40a:	b08a      	sub	sp, #40	; 0x28
 800c40c:	af00      	add	r7, sp, #0
 800c40e:	6078      	str	r0, [r7, #4]
    NX_TRACE_IN_LINE_INSERT(NX_TRACE_PACKET_RELEASE, packet_ptr, packet_ptr -> nx_packet_union_next.nx_packet_tcp_queue_next, (packet_ptr -> nx_packet_pool_owner) -> nx_packet_pool_available, 0, NX_TRACE_PACKET_EVENTS, 0, 0);

#ifndef NX_DISABLE_PACKET_CHAIN
    /* Loop to free all packets chained together, not assuming they are
       from the same pool.  */
    while (packet_ptr)
 800c410:	e0a2      	b.n	800c558 <_nx_packet_release+0x150>
    {
#endif /* NX_DISABLE_PACKET_CHAIN */

        /* Check to see if the packet is releasable.  */
        /*lint -e{923} suppress cast of ULONG to pointer.  */
        if (packet_ptr -> nx_packet_union_next.nx_packet_tcp_queue_next != ((NX_PACKET *)NX_PACKET_ALLOCATED))
 800c412:	687b      	ldr	r3, [r7, #4]
 800c414:	6a1b      	ldr	r3, [r3, #32]
 800c416:	f1b3 3faa 	cmp.w	r3, #2863311530	; 0xaaaaaaaa
 800c41a:	d011      	beq.n	800c440 <_nx_packet_release+0x38>
        {

#ifndef NX_DISABLE_PACKET_INFO
            /* Pickup the pool pointer.  */
            pool_ptr =  packet_ptr -> nx_packet_pool_owner;
 800c41c:	687b      	ldr	r3, [r7, #4]
 800c41e:	681b      	ldr	r3, [r3, #0]
 800c420:	61fb      	str	r3, [r7, #28]

            /* Check for a good pool pointer...  error must be the packet!  */
            if ((pool_ptr) && (pool_ptr -> nx_packet_pool_id == NX_PACKET_POOL_ID))
 800c422:	69fb      	ldr	r3, [r7, #28]
 800c424:	2b00      	cmp	r3, #0
 800c426:	d009      	beq.n	800c43c <_nx_packet_release+0x34>
 800c428:	69fb      	ldr	r3, [r7, #28]
 800c42a:	681b      	ldr	r3, [r3, #0]
 800c42c:	4a4f      	ldr	r2, [pc, #316]	; (800c56c <_nx_packet_release+0x164>)
 800c42e:	4293      	cmp	r3, r2
 800c430:	d104      	bne.n	800c43c <_nx_packet_release+0x34>
            {

                /* Increment the packet pool invalid release error count.  */
                pool_ptr -> nx_packet_pool_invalid_releases++;
 800c432:	69fb      	ldr	r3, [r7, #28]
 800c434:	699b      	ldr	r3, [r3, #24]
 800c436:	1c5a      	adds	r2, r3, #1
 800c438:	69fb      	ldr	r3, [r7, #28]
 800c43a:	619a      	str	r2, [r3, #24]
            }
#endif

            /* Return an error indicating the packet could not be released.  */
            return(NX_PTR_ERROR);
 800c43c:	2307      	movs	r3, #7
 800c43e:	e090      	b.n	800c562 <_nx_packet_release+0x15a>
        }
        /* End of packet check.  */

#ifndef NX_DISABLE_PACKET_CHAIN
        /* Pickup the next packet. */
        next_packet =  packet_ptr -> nx_packet_next;
 800c440:	687b      	ldr	r3, [r7, #4]
 800c442:	685b      	ldr	r3, [r3, #4]
 800c444:	627b      	str	r3, [r7, #36]	; 0x24
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 800c446:	f3ef 8310 	mrs	r3, PRIMASK
 800c44a:	617b      	str	r3, [r7, #20]
    return(posture);
 800c44c:	697b      	ldr	r3, [r7, #20]
    int_posture = __get_interrupt_posture();
 800c44e:	613b      	str	r3, [r7, #16]
    __asm__ volatile ("CPSID i" : : : "memory");
 800c450:	b672      	cpsid	i
    return(int_posture);
 800c452:	693b      	ldr	r3, [r7, #16]

        /* Add debug information. */
        NX_PACKET_DEBUG(__FILE__, __LINE__, packet_ptr);

        /* Disable interrupts to put this packet back in the packet pool.  */
        TX_DISABLE
 800c454:	623b      	str	r3, [r7, #32]

        /* Pickup the pool pointer.  */
        pool_ptr =  packet_ptr -> nx_packet_pool_owner;
 800c456:	687b      	ldr	r3, [r7, #4]
 800c458:	681b      	ldr	r3, [r3, #0]
 800c45a:	61fb      	str	r3, [r7, #28]

        /* Determine if there are any threads suspended on the block pool.  */
        thread_ptr =  pool_ptr -> nx_packet_pool_suspension_list;
 800c45c:	69fb      	ldr	r3, [r7, #28]
 800c45e:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800c460:	61bb      	str	r3, [r7, #24]
        if (thread_ptr)
 800c462:	69bb      	ldr	r3, [r7, #24]
 800c464:	2b00      	cmp	r3, #0
 800c466:	d05f      	beq.n	800c528 <_nx_packet_release+0x120>
        {

            /* Remove the suspended thread from the list.  */

            /* See if this is the only suspended thread on the list.  */
            if (thread_ptr == thread_ptr -> tx_thread_suspended_next)
 800c468:	69bb      	ldr	r3, [r7, #24]
 800c46a:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 800c46c:	69ba      	ldr	r2, [r7, #24]
 800c46e:	429a      	cmp	r2, r3
 800c470:	d103      	bne.n	800c47a <_nx_packet_release+0x72>
            {

                /* Yes, the only suspended thread.  */

                /* Update the head pointer.  */
                pool_ptr -> nx_packet_pool_suspension_list =  NX_NULL;
 800c472:	69fb      	ldr	r3, [r7, #28]
 800c474:	2200      	movs	r2, #0
 800c476:	62da      	str	r2, [r3, #44]	; 0x2c
 800c478:	e00d      	b.n	800c496 <_nx_packet_release+0x8e>
            {

                /* At least one more thread is on the same expiration list.  */

                /* Update the list head pointer.  */
                pool_ptr -> nx_packet_pool_suspension_list =  thread_ptr -> tx_thread_suspended_next;
 800c47a:	69bb      	ldr	r3, [r7, #24]
 800c47c:	6f1a      	ldr	r2, [r3, #112]	; 0x70
 800c47e:	69fb      	ldr	r3, [r7, #28]
 800c480:	62da      	str	r2, [r3, #44]	; 0x2c

                /* Update the links of the adjacent threads.  */
                (thread_ptr -> tx_thread_suspended_next) -> tx_thread_suspended_previous =
 800c482:	69bb      	ldr	r3, [r7, #24]
 800c484:	6f1b      	ldr	r3, [r3, #112]	; 0x70
                    thread_ptr -> tx_thread_suspended_previous;
 800c486:	69ba      	ldr	r2, [r7, #24]
 800c488:	6f52      	ldr	r2, [r2, #116]	; 0x74
                (thread_ptr -> tx_thread_suspended_next) -> tx_thread_suspended_previous =
 800c48a:	675a      	str	r2, [r3, #116]	; 0x74
                (thread_ptr -> tx_thread_suspended_previous) -> tx_thread_suspended_next =
 800c48c:	69bb      	ldr	r3, [r7, #24]
 800c48e:	6f5b      	ldr	r3, [r3, #116]	; 0x74
                    thread_ptr -> tx_thread_suspended_next;
 800c490:	69ba      	ldr	r2, [r7, #24]
 800c492:	6f12      	ldr	r2, [r2, #112]	; 0x70
                (thread_ptr -> tx_thread_suspended_previous) -> tx_thread_suspended_next =
 800c494:	671a      	str	r2, [r3, #112]	; 0x70
            }

            /* Decrement the suspension count.  */
            pool_ptr -> nx_packet_pool_suspended_count--;
 800c496:	69fb      	ldr	r3, [r7, #28]
 800c498:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800c49a:	1e5a      	subs	r2, r3, #1
 800c49c:	69fb      	ldr	r3, [r7, #28]
 800c49e:	631a      	str	r2, [r3, #48]	; 0x30

            /* Prepare for resumption of the first thread.  */

            /* Clear cleanup routine to avoid timeout.  */
            thread_ptr -> tx_thread_suspend_cleanup =  TX_NULL;
 800c4a0:	69bb      	ldr	r3, [r7, #24]
 800c4a2:	2200      	movs	r2, #0
 800c4a4:	669a      	str	r2, [r3, #104]	; 0x68

            /* Temporarily disable preemption.  */
            _tx_thread_preempt_disable++;
 800c4a6:	4b32      	ldr	r3, [pc, #200]	; (800c570 <_nx_packet_release+0x168>)
 800c4a8:	681b      	ldr	r3, [r3, #0]
 800c4aa:	3301      	adds	r3, #1
 800c4ac:	4a30      	ldr	r2, [pc, #192]	; (800c570 <_nx_packet_release+0x168>)
 800c4ae:	6013      	str	r3, [r2, #0]
 800c4b0:	6a3b      	ldr	r3, [r7, #32]
 800c4b2:	60fb      	str	r3, [r7, #12]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 800c4b4:	68fb      	ldr	r3, [r7, #12]
 800c4b6:	f383 8810 	msr	PRIMASK, r3
}
 800c4ba:	bf00      	nop

            /* Restore interrupts.  */
            TX_RESTORE

            /* Adjust this packet to look just like a new packet.  */
            packet_ptr -> nx_packet_queue_next  =  NX_NULL;
 800c4bc:	687b      	ldr	r3, [r7, #4]
 800c4be:	2200      	movs	r2, #0
 800c4c0:	61da      	str	r2, [r3, #28]
#ifndef NX_DISABLE_PACKET_CHAIN
            packet_ptr -> nx_packet_next        =  NX_NULL;
 800c4c2:	687b      	ldr	r3, [r7, #4]
 800c4c4:	2200      	movs	r2, #0
 800c4c6:	605a      	str	r2, [r3, #4]
            packet_ptr -> nx_packet_last        =  NX_NULL;
 800c4c8:	687b      	ldr	r3, [r7, #4]
 800c4ca:	2200      	movs	r2, #0
 800c4cc:	619a      	str	r2, [r3, #24]
#endif /* NX_DISABLE_PACKET_CHAIN */
            packet_ptr -> nx_packet_length      =  0;
 800c4ce:	687b      	ldr	r3, [r7, #4]
 800c4d0:	2200      	movs	r2, #0
 800c4d2:	625a      	str	r2, [r3, #36]	; 0x24
            packet_ptr -> nx_packet_prepend_ptr =  packet_ptr -> nx_packet_data_start + (thread_ptr -> tx_thread_suspend_info);
 800c4d4:	687b      	ldr	r3, [r7, #4]
 800c4d6:	691a      	ldr	r2, [r3, #16]
 800c4d8:	69bb      	ldr	r3, [r7, #24]
 800c4da:	6f9b      	ldr	r3, [r3, #120]	; 0x78
 800c4dc:	441a      	add	r2, r3
 800c4de:	687b      	ldr	r3, [r7, #4]
 800c4e0:	609a      	str	r2, [r3, #8]
            packet_ptr -> nx_packet_append_ptr  =  packet_ptr -> nx_packet_prepend_ptr;
 800c4e2:	687b      	ldr	r3, [r7, #4]
 800c4e4:	689a      	ldr	r2, [r3, #8]
 800c4e6:	687b      	ldr	r3, [r7, #4]
 800c4e8:	60da      	str	r2, [r3, #12]
            packet_ptr -> nx_packet_address.nx_packet_interface_ptr = NX_NULL;
 800c4ea:	687b      	ldr	r3, [r7, #4]
 800c4ec:	2200      	movs	r2, #0
 800c4ee:	631a      	str	r2, [r3, #48]	; 0x30
#ifdef NX_ENABLE_INTERFACE_CAPABILITY
            packet_ptr -> nx_packet_interface_capability_flag = 0;
#endif /* NX_ENABLE_INTERFACE_CAPABILITY */
            /* Set the TCP queue to the value that indicates it has been allocated.  */
            /*lint -e{923} suppress cast of ULONG to pointer.  */
            packet_ptr -> nx_packet_union_next.nx_packet_tcp_queue_next =  (NX_PACKET *)NX_PACKET_ALLOCATED;
 800c4f0:	687b      	ldr	r3, [r7, #4]
 800c4f2:	f04f 32aa 	mov.w	r2, #2863311530	; 0xaaaaaaaa
 800c4f6:	621a      	str	r2, [r3, #32]
            /* Clear the ipsec state. */
            packet_ptr -> nx_packet_ipsec_state = 0;
#endif /* NX_IPSEC_ENABLE */

            /* Clear the IP version.  */
            packet_ptr -> nx_packet_ip_version  =  0;
 800c4f8:	687b      	ldr	r3, [r7, #4]
 800c4fa:	2200      	movs	r2, #0
 800c4fc:	f883 202c 	strb.w	r2, [r3, #44]	; 0x2c

            /* Clear the IP identification flag.  */
            packet_ptr -> nx_packet_identical_copy = NX_FALSE;
 800c500:	687b      	ldr	r3, [r7, #4]
 800c502:	2200      	movs	r2, #0
 800c504:	f883 202d 	strb.w	r2, [r3, #45]	; 0x2d

            /* Initialize the IP header length. */
            packet_ptr -> nx_packet_ip_header_length = 0;
 800c508:	687b      	ldr	r3, [r7, #4]
 800c50a:	2200      	movs	r2, #0
 800c50c:	f883 202e 	strb.w	r2, [r3, #46]	; 0x2e

            /* Return this block pointer to the suspended thread waiting for
               a block.  */
            *((NX_PACKET **)thread_ptr -> tx_thread_additional_suspend_info) =  packet_ptr;
 800c510:	69bb      	ldr	r3, [r7, #24]
 800c512:	6fdb      	ldr	r3, [r3, #124]	; 0x7c
 800c514:	687a      	ldr	r2, [r7, #4]
 800c516:	601a      	str	r2, [r3, #0]

            /* Put return status into the thread control block.  */
            thread_ptr -> tx_thread_suspend_status =  NX_SUCCESS;
 800c518:	69bb      	ldr	r3, [r7, #24]
 800c51a:	2200      	movs	r2, #0
 800c51c:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84

            /* Resume thread.  */
            _tx_thread_system_resume(thread_ptr);
 800c520:	69b8      	ldr	r0, [r7, #24]
 800c522:	f008 fc01 	bl	8014d28 <_tx_thread_system_resume>
 800c526:	e015      	b.n	800c554 <_nx_packet_release+0x14c>

            /* No thread is suspended for a memory block.  */

            /* Mark the packet as free.  */
            /*lint -e{923} suppress cast of ULONG to pointer.  */
            packet_ptr -> nx_packet_union_next.nx_packet_tcp_queue_next =  (NX_PACKET *)NX_PACKET_FREE;
 800c528:	687b      	ldr	r3, [r7, #4]
 800c52a:	f04f 32ff 	mov.w	r2, #4294967295
 800c52e:	621a      	str	r2, [r3, #32]

            /* Put the packet back in the available list.  */
            packet_ptr -> nx_packet_queue_next =  pool_ptr -> nx_packet_pool_available_list;
 800c530:	69fb      	ldr	r3, [r7, #28]
 800c532:	69da      	ldr	r2, [r3, #28]
 800c534:	687b      	ldr	r3, [r7, #4]
 800c536:	61da      	str	r2, [r3, #28]

            /* Adjust the head pointer.  */
            pool_ptr -> nx_packet_pool_available_list =  packet_ptr;
 800c538:	69fb      	ldr	r3, [r7, #28]
 800c53a:	687a      	ldr	r2, [r7, #4]
 800c53c:	61da      	str	r2, [r3, #28]

            /* Increment the count of available blocks.  */
            pool_ptr -> nx_packet_pool_available++;
 800c53e:	69fb      	ldr	r3, [r7, #28]
 800c540:	689b      	ldr	r3, [r3, #8]
 800c542:	1c5a      	adds	r2, r3, #1
 800c544:	69fb      	ldr	r3, [r7, #28]
 800c546:	609a      	str	r2, [r3, #8]
 800c548:	6a3b      	ldr	r3, [r7, #32]
 800c54a:	60bb      	str	r3, [r7, #8]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 800c54c:	68bb      	ldr	r3, [r7, #8]
 800c54e:	f383 8810 	msr	PRIMASK, r3
}
 800c552:	bf00      	nop
            TX_RESTORE
        }

#ifndef NX_DISABLE_PACKET_CHAIN
        /* Move to the next packet in the list.  */
        packet_ptr =  next_packet;
 800c554:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800c556:	607b      	str	r3, [r7, #4]
    while (packet_ptr)
 800c558:	687b      	ldr	r3, [r7, #4]
 800c55a:	2b00      	cmp	r3, #0
 800c55c:	f47f af59 	bne.w	800c412 <_nx_packet_release+0xa>
    }
#endif /* NX_DISABLE_PACKET_CHAIN */

    /* Return completion status.  */
    return(NX_SUCCESS);
 800c560:	2300      	movs	r3, #0
}
 800c562:	4618      	mov	r0, r3
 800c564:	3728      	adds	r7, #40	; 0x28
 800c566:	46bd      	mov	sp, r7
 800c568:	bd80      	pop	{r7, pc}
 800c56a:	bf00      	nop
 800c56c:	5041434b 	.word	0x5041434b
 800c570:	24031c5c 	.word	0x24031c5c

0800c574 <_nx_packet_transmit_release>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
UINT  _nx_packet_transmit_release(NX_PACKET *packet_ptr)
{
 800c574:	b580      	push	{r7, lr}
 800c576:	b088      	sub	sp, #32
 800c578:	af00      	add	r7, sp, #0
 800c57a:	6078      	str	r0, [r7, #4]
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 800c57c:	f3ef 8310 	mrs	r3, PRIMASK
 800c580:	617b      	str	r3, [r7, #20]
    return(posture);
 800c582:	697b      	ldr	r3, [r7, #20]
    int_posture = __get_interrupt_posture();
 800c584:	613b      	str	r3, [r7, #16]
    __asm__ volatile ("CPSID i" : : : "memory");
 800c586:	b672      	cpsid	i
    return(int_posture);
 800c588:	693b      	ldr	r3, [r7, #16]

    /* If trace is enabled, insert this event into the trace buffer.  */
    NX_TRACE_IN_LINE_INSERT(NX_TRACE_PACKET_TRANSMIT_RELEASE, packet_ptr, packet_ptr -> nx_packet_union_next.nx_packet_tcp_queue_next, (packet_ptr -> nx_packet_pool_owner) -> nx_packet_pool_available, 0, NX_TRACE_PACKET_EVENTS, 0, 0);

    /* Disable interrupts temporarily.  */
    TX_DISABLE
 800c58a:	61bb      	str	r3, [r7, #24]
    NX_PACKET_DEBUG(__FILE__, __LINE__, packet_ptr);

    /* Determine if the packet is a queued TCP data packet.  Such packets cannot be released
       immediately, since they may need to be resent.  */
    /*lint -e{923} suppress cast of ULONG to pointer.  */
    if ((packet_ptr -> nx_packet_union_next.nx_packet_tcp_queue_next != ((NX_PACKET *)NX_PACKET_ALLOCATED)) &&
 800c58c:	687b      	ldr	r3, [r7, #4]
 800c58e:	6a1b      	ldr	r3, [r3, #32]
 800c590:	f1b3 3faa 	cmp.w	r3, #2863311530	; 0xaaaaaaaa
 800c594:	d025      	beq.n	800c5e2 <_nx_packet_transmit_release+0x6e>
        (packet_ptr -> nx_packet_union_next.nx_packet_tcp_queue_next != ((NX_PACKET *)NX_PACKET_FREE)))
 800c596:	687b      	ldr	r3, [r7, #4]
 800c598:	6a1b      	ldr	r3, [r3, #32]
    if ((packet_ptr -> nx_packet_union_next.nx_packet_tcp_queue_next != ((NX_PACKET *)NX_PACKET_ALLOCATED)) &&
 800c59a:	f1b3 3fff 	cmp.w	r3, #4294967295
 800c59e:	d020      	beq.n	800c5e2 <_nx_packet_transmit_release+0x6e>
    {

        /* Yes, this is indeed a TCP packet.  Just mark this with the NX_DRIVER_TX_DONE
           value to let the TCP layer know it is no longer queued up.  */
        /*lint -e{923} suppress cast of ULONG to pointer.  */
        packet_ptr -> nx_packet_queue_next =  (NX_PACKET *)NX_DRIVER_TX_DONE;
 800c5a0:	687b      	ldr	r3, [r7, #4]
 800c5a2:	f04f 32dd 	mov.w	r2, #3722304989	; 0xdddddddd
 800c5a6:	61da      	str	r2, [r3, #28]

        /* Remove the IP header and adjust the length.  */
        packet_ptr -> nx_packet_prepend_ptr += packet_ptr -> nx_packet_ip_header_length;
 800c5a8:	687b      	ldr	r3, [r7, #4]
 800c5aa:	689b      	ldr	r3, [r3, #8]
 800c5ac:	687a      	ldr	r2, [r7, #4]
 800c5ae:	f892 202e 	ldrb.w	r2, [r2, #46]	; 0x2e
 800c5b2:	441a      	add	r2, r3
 800c5b4:	687b      	ldr	r3, [r7, #4]
 800c5b6:	609a      	str	r2, [r3, #8]
        packet_ptr -> nx_packet_length -= packet_ptr -> nx_packet_ip_header_length;
 800c5b8:	687b      	ldr	r3, [r7, #4]
 800c5ba:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800c5bc:	687a      	ldr	r2, [r7, #4]
 800c5be:	f892 202e 	ldrb.w	r2, [r2, #46]	; 0x2e
 800c5c2:	1a9a      	subs	r2, r3, r2
 800c5c4:	687b      	ldr	r3, [r7, #4]
 800c5c6:	625a      	str	r2, [r3, #36]	; 0x24

        /* Reset the IP header length. */
        packet_ptr -> nx_packet_ip_header_length = 0;
 800c5c8:	687b      	ldr	r3, [r7, #4]
 800c5ca:	2200      	movs	r2, #0
 800c5cc:	f883 202e 	strb.w	r2, [r3, #46]	; 0x2e
 800c5d0:	69bb      	ldr	r3, [r7, #24]
 800c5d2:	60fb      	str	r3, [r7, #12]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 800c5d4:	68fb      	ldr	r3, [r7, #12]
 800c5d6:	f383 8810 	msr	PRIMASK, r3
}
 800c5da:	bf00      	nop

        /* Restore interrupts.  */
        TX_RESTORE

        /* Return success.  */
        status =  NX_SUCCESS;
 800c5dc:	2300      	movs	r3, #0
 800c5de:	61fb      	str	r3, [r7, #28]
 800c5e0:	e009      	b.n	800c5f6 <_nx_packet_transmit_release+0x82>
 800c5e2:	69bb      	ldr	r3, [r7, #24]
 800c5e4:	60bb      	str	r3, [r7, #8]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 800c5e6:	68bb      	ldr	r3, [r7, #8]
 800c5e8:	f383 8810 	msr	PRIMASK, r3
}
 800c5ec:	bf00      	nop

        /* Restore interrupts.  */
        TX_RESTORE

        /* Call the actual packet release function.  */
        status =  _nx_packet_release(packet_ptr);
 800c5ee:	6878      	ldr	r0, [r7, #4]
 800c5f0:	f7ff ff0a 	bl	800c408 <_nx_packet_release>
 800c5f4:	61f8      	str	r0, [r7, #28]
    }

    /* Return completion status.  */
    return(status);
 800c5f6:	69fb      	ldr	r3, [r7, #28]
}
 800c5f8:	4618      	mov	r0, r3
 800c5fa:	3720      	adds	r7, #32
 800c5fc:	46bd      	mov	sp, r7
 800c5fe:	bd80      	pop	{r7, pc}

0800c600 <_nx_rarp_packet_deferred_receive>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
VOID  _nx_rarp_packet_deferred_receive(NX_IP *ip_ptr, NX_PACKET *packet_ptr)
{
 800c600:	b580      	push	{r7, lr}
 800c602:	b088      	sub	sp, #32
 800c604:	af00      	add	r7, sp, #0
 800c606:	6078      	str	r0, [r7, #4]
 800c608:	6039      	str	r1, [r7, #0]
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 800c60a:	f3ef 8310 	mrs	r3, PRIMASK
 800c60e:	61bb      	str	r3, [r7, #24]
    return(posture);
 800c610:	69bb      	ldr	r3, [r7, #24]
    int_posture = __get_interrupt_posture();
 800c612:	617b      	str	r3, [r7, #20]
    __asm__ volatile ("CPSID i" : : : "memory");
 800c614:	b672      	cpsid	i
    return(int_posture);
 800c616:	697b      	ldr	r3, [r7, #20]

TX_INTERRUPT_SAVE_AREA


    /* Disable interrupts.  */
    TX_DISABLE
 800c618:	61fb      	str	r3, [r7, #28]

    /* Add debug information. */
    NX_PACKET_DEBUG(__FILE__, __LINE__, packet_ptr);

    /* Check to see if RARP is enabled on this IP instance.  */
    if (!ip_ptr -> nx_ip_rarp_queue_process)
 800c61a:	687b      	ldr	r3, [r7, #4]
 800c61c:	f8d3 3704 	ldr.w	r3, [r3, #1796]	; 0x704
 800c620:	2b00      	cmp	r3, #0
 800c622:	d110      	bne.n	800c646 <_nx_rarp_packet_deferred_receive+0x46>

        /* RARP is not enabled.  */

#ifndef NX_DISABLE_RARP_INFO
        /* Increment the RARP invalid messages count...  */
        ip_ptr -> nx_ip_rarp_invalid_messages++;
 800c624:	687b      	ldr	r3, [r7, #4]
 800c626:	f8d3 312c 	ldr.w	r3, [r3, #300]	; 0x12c
 800c62a:	1c5a      	adds	r2, r3, #1
 800c62c:	687b      	ldr	r3, [r7, #4]
 800c62e:	f8c3 212c 	str.w	r2, [r3, #300]	; 0x12c
 800c632:	69fb      	ldr	r3, [r7, #28]
 800c634:	613b      	str	r3, [r7, #16]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 800c636:	693b      	ldr	r3, [r7, #16]
 800c638:	f383 8810 	msr	PRIMASK, r3
}
 800c63c:	bf00      	nop

        /* Restore interrupts.  */
        TX_RESTORE

        /* Since RARP is not enabled, just release the packet.  */
        _nx_packet_release(packet_ptr);
 800c63e:	6838      	ldr	r0, [r7, #0]
 800c640:	f7ff fee2 	bl	800c408 <_nx_packet_release>

        /* Return to caller.  */
        return;
 800c644:	e02f      	b.n	800c6a6 <_nx_rarp_packet_deferred_receive+0xa6>
    }

    /* Check to see if the RARP deferred processing queue is empty.  */
    if (ip_ptr -> nx_ip_rarp_deferred_received_packet_head)
 800c646:	687b      	ldr	r3, [r7, #4]
 800c648:	f8d3 3708 	ldr.w	r3, [r3, #1800]	; 0x708
 800c64c:	2b00      	cmp	r3, #0
 800c64e:	d011      	beq.n	800c674 <_nx_rarp_packet_deferred_receive+0x74>
    {

        /* Not empty, just place the packet at the end of the RARP deferred queue.  */
        (ip_ptr -> nx_ip_rarp_deferred_received_packet_tail) -> nx_packet_queue_next =  packet_ptr;
 800c650:	687b      	ldr	r3, [r7, #4]
 800c652:	f8d3 370c 	ldr.w	r3, [r3, #1804]	; 0x70c
 800c656:	683a      	ldr	r2, [r7, #0]
 800c658:	61da      	str	r2, [r3, #28]
        packet_ptr -> nx_packet_queue_next =  NX_NULL;
 800c65a:	683b      	ldr	r3, [r7, #0]
 800c65c:	2200      	movs	r2, #0
 800c65e:	61da      	str	r2, [r3, #28]
        ip_ptr -> nx_ip_rarp_deferred_received_packet_tail =  packet_ptr;
 800c660:	687b      	ldr	r3, [r7, #4]
 800c662:	683a      	ldr	r2, [r7, #0]
 800c664:	f8c3 270c 	str.w	r2, [r3, #1804]	; 0x70c
 800c668:	69fb      	ldr	r3, [r7, #28]
 800c66a:	60fb      	str	r3, [r7, #12]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 800c66c:	68fb      	ldr	r3, [r7, #12]
 800c66e:	f383 8810 	msr	PRIMASK, r3
}
 800c672:	e018      	b.n	800c6a6 <_nx_rarp_packet_deferred_receive+0xa6>
    {

        /* Empty RARP deferred receive processing queue.  Just setup the head pointers and
           set the event flags to ensure the IP helper thread looks at the RARP deferred
           processing queue.  */
        ip_ptr -> nx_ip_rarp_deferred_received_packet_head =  packet_ptr;
 800c674:	687b      	ldr	r3, [r7, #4]
 800c676:	683a      	ldr	r2, [r7, #0]
 800c678:	f8c3 2708 	str.w	r2, [r3, #1800]	; 0x708
        ip_ptr -> nx_ip_rarp_deferred_received_packet_tail =  packet_ptr;
 800c67c:	687b      	ldr	r3, [r7, #4]
 800c67e:	683a      	ldr	r2, [r7, #0]
 800c680:	f8c3 270c 	str.w	r2, [r3, #1804]	; 0x70c
        packet_ptr -> nx_packet_queue_next =                  NX_NULL;
 800c684:	683b      	ldr	r3, [r7, #0]
 800c686:	2200      	movs	r2, #0
 800c688:	61da      	str	r2, [r3, #28]
 800c68a:	69fb      	ldr	r3, [r7, #28]
 800c68c:	60bb      	str	r3, [r7, #8]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 800c68e:	68bb      	ldr	r3, [r7, #8]
 800c690:	f383 8810 	msr	PRIMASK, r3
}
 800c694:	bf00      	nop

        /* Restore interrupts.  */
        TX_RESTORE

        /* Wakeup IP helper thread to process the RARP deferred receive.  */
        tx_event_flags_set(&(ip_ptr -> nx_ip_events), NX_IP_RARP_REC_EVENT, TX_OR);
 800c696:	687b      	ldr	r3, [r7, #4]
 800c698:	f503 7313 	add.w	r3, r3, #588	; 0x24c
 800c69c:	2200      	movs	r2, #0
 800c69e:	2120      	movs	r1, #32
 800c6a0:	4618      	mov	r0, r3
 800c6a2:	f005 ff23 	bl	80124ec <_tx_event_flags_set>
    }
}
 800c6a6:	3720      	adds	r7, #32
 800c6a8:	46bd      	mov	sp, r7
 800c6aa:	bd80      	pop	{r7, pc}

0800c6ac <_nx_system_initialize>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
VOID  _nx_system_initialize(VOID)
{
 800c6ac:	b580      	push	{r7, lr}
 800c6ae:	af00      	add	r7, sp, #0

    /* Check whether or not system has been initialized? */
    if (_nx_system_build_options_1 | _nx_system_build_options_2 |
 800c6b0:	4b38      	ldr	r3, [pc, #224]	; (800c794 <_nx_system_initialize+0xe8>)
 800c6b2:	681a      	ldr	r2, [r3, #0]
 800c6b4:	4b38      	ldr	r3, [pc, #224]	; (800c798 <_nx_system_initialize+0xec>)
 800c6b6:	681b      	ldr	r3, [r3, #0]
 800c6b8:	431a      	orrs	r2, r3
 800c6ba:	4b38      	ldr	r3, [pc, #224]	; (800c79c <_nx_system_initialize+0xf0>)
 800c6bc:	681b      	ldr	r3, [r3, #0]
 800c6be:	431a      	orrs	r2, r3
        _nx_system_build_options_3 | _nx_system_build_options_4 | _nx_system_build_options_5)
 800c6c0:	4b37      	ldr	r3, [pc, #220]	; (800c7a0 <_nx_system_initialize+0xf4>)
 800c6c2:	681b      	ldr	r3, [r3, #0]
 800c6c4:	431a      	orrs	r2, r3
 800c6c6:	4b37      	ldr	r3, [pc, #220]	; (800c7a4 <_nx_system_initialize+0xf8>)
 800c6c8:	681b      	ldr	r3, [r3, #0]
 800c6ca:	4313      	orrs	r3, r2
    if (_nx_system_build_options_1 | _nx_system_build_options_2 |
 800c6cc:	2b00      	cmp	r3, #0
 800c6ce:	d15e      	bne.n	800c78e <_nx_system_initialize+0xe2>

    /* If trace is enabled, insert this event into the trace buffer.  */
    NX_TRACE_IN_LINE_INSERT(NX_TRACE_SYSTEM_INITIALIZE, 0, 0, 0, 0, NX_TRACE_INTERNAL_EVENTS, 0, 0);

    /* Call the packet pool initialization component for NetX.  */
    _nx_packet_pool_initialize();
 800c6d0:	f7ff fe88 	bl	800c3e4 <_nx_packet_pool_initialize>

    /* Call the IP component initialization.  */
    _nx_ip_initialize();
 800c6d4:	f7fe f9ae 	bl	800aa34 <_nx_ip_initialize>

    /* Call the TCP component initialization.  */
    /*lint -e{522} suppress lack of side-effects.  */
    _nx_tcp_initialize();
 800c6d8:	f000 fc12 	bl	800cf00 <_nx_tcp_initialize>

    /* Setup the build options variables.  */
    _nx_system_build_options_1 = 0
 800c6dc:	4b2d      	ldr	r3, [pc, #180]	; (800c794 <_nx_system_initialize+0xe8>)
 800c6de:	f04f 4200 	mov.w	r2, #2147483648	; 0x80000000
 800c6e2:	601a      	str	r2, [r3, #0]

    /* Add the retry shift value to the options.  */
#if (NX_TCP_RETRY_SHIFT > 0xF)
    _nx_system_build_options_1 |=  0xF;
#else
    _nx_system_build_options_1 |=  NX_TCP_RETRY_SHIFT;
 800c6e4:	4b2b      	ldr	r3, [pc, #172]	; (800c794 <_nx_system_initialize+0xe8>)
 800c6e6:	681b      	ldr	r3, [r3, #0]
 800c6e8:	4a2a      	ldr	r2, [pc, #168]	; (800c794 <_nx_system_initialize+0xe8>)
 800c6ea:	6013      	str	r3, [r2, #0]
#endif

#if (NX_IP_PERIODIC_RATE > 0xFFFFUL)
    _nx_system_build_options_2 =  ((ULONG)0xFFFF0000);
#else
    _nx_system_build_options_2 =  ((ULONG)NX_IP_PERIODIC_RATE) << 16;
 800c6ec:	4b2a      	ldr	r3, [pc, #168]	; (800c798 <_nx_system_initialize+0xec>)
 800c6ee:	f44f 02c8 	mov.w	r2, #6553600	; 0x640000
 800c6f2:	601a      	str	r2, [r3, #0]
#endif

#if (NX_ARP_EXPIRATION_RATE > 0xFF)
    _nx_system_build_options_2 |=  ((ULONG)0xFF) << 8;
#else
    _nx_system_build_options_2 |=  ((ULONG)NX_ARP_EXPIRATION_RATE) << 8;
 800c6f4:	4b28      	ldr	r3, [pc, #160]	; (800c798 <_nx_system_initialize+0xec>)
 800c6f6:	681b      	ldr	r3, [r3, #0]
 800c6f8:	4a27      	ldr	r2, [pc, #156]	; (800c798 <_nx_system_initialize+0xec>)
 800c6fa:	6013      	str	r3, [r2, #0]
#endif
#if (NX_ARP_UPDATE_RATE > 0xFF)
    _nx_system_build_options_2 |=  ((ULONG)0xFF);
#else
    _nx_system_build_options_2 |=  ((ULONG)NX_ARP_UPDATE_RATE);
 800c6fc:	4b26      	ldr	r3, [pc, #152]	; (800c798 <_nx_system_initialize+0xec>)
 800c6fe:	681b      	ldr	r3, [r3, #0]
 800c700:	f043 030a 	orr.w	r3, r3, #10
 800c704:	4a24      	ldr	r2, [pc, #144]	; (800c798 <_nx_system_initialize+0xec>)
 800c706:	6013      	str	r3, [r2, #0]

    /* Setup third option word.  */
#if (NX_TCP_ACK_TIMER_RATE > 0xFF)
    _nx_system_build_options_3 =  ((ULONG)0xFF000000);
#else
    _nx_system_build_options_3 =  ((ULONG)NX_TCP_ACK_TIMER_RATE) << 24;
 800c708:	4b24      	ldr	r3, [pc, #144]	; (800c79c <_nx_system_initialize+0xf0>)
 800c70a:	f04f 62a0 	mov.w	r2, #83886080	; 0x5000000
 800c70e:	601a      	str	r2, [r3, #0]
#endif
#if (NX_TCP_FAST_TIMER_RATE > 0xFF)
    _nx_system_build_options_3 |=  ((ULONG)0xFF) << 16;
#else
    _nx_system_build_options_3 |=  ((ULONG)NX_TCP_FAST_TIMER_RATE) << 16;
 800c710:	4b22      	ldr	r3, [pc, #136]	; (800c79c <_nx_system_initialize+0xf0>)
 800c712:	681b      	ldr	r3, [r3, #0]
 800c714:	f443 2320 	orr.w	r3, r3, #655360	; 0xa0000
 800c718:	4a20      	ldr	r2, [pc, #128]	; (800c79c <_nx_system_initialize+0xf0>)
 800c71a:	6013      	str	r3, [r2, #0]
#endif
#if (NX_TCP_TRANSMIT_TIMER_RATE > 0xFF)
    _nx_system_build_options_3 |=  ((ULONG)0xFF) << 8;
#else
    _nx_system_build_options_3 |=  ((ULONG)NX_TCP_TRANSMIT_TIMER_RATE) << 8;
 800c71c:	4b1f      	ldr	r3, [pc, #124]	; (800c79c <_nx_system_initialize+0xf0>)
 800c71e:	681b      	ldr	r3, [r3, #0]
 800c720:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 800c724:	4a1d      	ldr	r2, [pc, #116]	; (800c79c <_nx_system_initialize+0xf0>)
 800c726:	6013      	str	r3, [r2, #0]
#endif
#if (NX_TCP_KEEPALIVE_RETRY > 0xFF)
    _nx_system_build_options_3 |=  ((ULONG)0xFF);
#else
    _nx_system_build_options_3 |=  ((ULONG)NX_TCP_KEEPALIVE_RETRY);
 800c728:	4b1c      	ldr	r3, [pc, #112]	; (800c79c <_nx_system_initialize+0xf0>)
 800c72a:	681b      	ldr	r3, [r3, #0]
 800c72c:	f043 034b 	orr.w	r3, r3, #75	; 0x4b
 800c730:	4a1a      	ldr	r2, [pc, #104]	; (800c79c <_nx_system_initialize+0xf0>)
 800c732:	6013      	str	r3, [r2, #0]

    /* Setup the fourth option word.  */
#if (NX_TCP_KEEPALIVE_INITIAL > 0xFFFFUL)
    _nx_system_build_options_4 =  ((ULONG)0xFFFF0000);
#else
    _nx_system_build_options_4 =  ((ULONG)NX_TCP_KEEPALIVE_INITIAL) << 16;
 800c734:	4b1a      	ldr	r3, [pc, #104]	; (800c7a0 <_nx_system_initialize+0xf4>)
 800c736:	f04f 52e1 	mov.w	r2, #471859200	; 0x1c200000
 800c73a:	601a      	str	r2, [r3, #0]
#endif
#if (NX_ARP_MAXIMUM_RETRIES > 0xFF)
    _nx_system_build_options_4 |=  ((ULONG)0xFF) << 8;
#else
    _nx_system_build_options_4 |=  ((ULONG)NX_ARP_MAXIMUM_RETRIES) << 8;
 800c73c:	4b18      	ldr	r3, [pc, #96]	; (800c7a0 <_nx_system_initialize+0xf4>)
 800c73e:	681b      	ldr	r3, [r3, #0]
 800c740:	f443 5390 	orr.w	r3, r3, #4608	; 0x1200
 800c744:	4a16      	ldr	r2, [pc, #88]	; (800c7a0 <_nx_system_initialize+0xf4>)
 800c746:	6013      	str	r3, [r2, #0]
#endif
#if (NX_ARP_MAX_QUEUE_DEPTH > 0xF)
    _nx_system_build_options_4 |=  ((ULONG)0xF) << 4;
#else
    _nx_system_build_options_4 |=  ((ULONG)NX_ARP_MAX_QUEUE_DEPTH) << 4;
 800c748:	4b15      	ldr	r3, [pc, #84]	; (800c7a0 <_nx_system_initialize+0xf4>)
 800c74a:	681b      	ldr	r3, [r3, #0]
 800c74c:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 800c750:	4a13      	ldr	r2, [pc, #76]	; (800c7a0 <_nx_system_initialize+0xf4>)
 800c752:	6013      	str	r3, [r2, #0]
#endif
#if (NX_TCP_KEEPALIVE_RETRIES > 0xF)
    _nx_system_build_options_4 |=  ((ULONG)0xF);
#else
    _nx_system_build_options_4 |=  ((ULONG)NX_TCP_KEEPALIVE_RETRIES);
 800c754:	4b12      	ldr	r3, [pc, #72]	; (800c7a0 <_nx_system_initialize+0xf4>)
 800c756:	681b      	ldr	r3, [r3, #0]
 800c758:	f043 030a 	orr.w	r3, r3, #10
 800c75c:	4a10      	ldr	r2, [pc, #64]	; (800c7a0 <_nx_system_initialize+0xf4>)
 800c75e:	6013      	str	r3, [r2, #0]

    /* Setup the fifth option word.  */
#if (NX_MAX_MULTICAST_GROUPS > 0xFF)
    _nx_system_build_options_5 =  ((ULONG)0xFF000000);
#else
    _nx_system_build_options_5 =  ((ULONG)NX_MAX_MULTICAST_GROUPS) << 24;
 800c760:	4b10      	ldr	r3, [pc, #64]	; (800c7a4 <_nx_system_initialize+0xf8>)
 800c762:	f04f 62e0 	mov.w	r2, #117440512	; 0x7000000
 800c766:	601a      	str	r2, [r3, #0]
#endif
#if (NX_MAX_LISTEN_REQUESTS > 0xFF)
    _nx_system_build_options_5 |=  ((ULONG)0xFF) << 16;
#else
    _nx_system_build_options_5 |=  ((ULONG)NX_MAX_LISTEN_REQUESTS) << 16;
 800c768:	4b0e      	ldr	r3, [pc, #56]	; (800c7a4 <_nx_system_initialize+0xf8>)
 800c76a:	681b      	ldr	r3, [r3, #0]
 800c76c:	f443 2320 	orr.w	r3, r3, #655360	; 0xa0000
 800c770:	4a0c      	ldr	r2, [pc, #48]	; (800c7a4 <_nx_system_initialize+0xf8>)
 800c772:	6013      	str	r3, [r2, #0]
#endif
#if (NX_TCP_MAXIMUM_RETRIES > 0xFF)
    _nx_system_build_options_5 |=  ((ULONG)0xFF) << 8;
#else
    _nx_system_build_options_5 |=  ((ULONG)NX_TCP_MAXIMUM_RETRIES) << 8;
 800c774:	4b0b      	ldr	r3, [pc, #44]	; (800c7a4 <_nx_system_initialize+0xf8>)
 800c776:	681b      	ldr	r3, [r3, #0]
 800c778:	f443 6320 	orr.w	r3, r3, #2560	; 0xa00
 800c77c:	4a09      	ldr	r2, [pc, #36]	; (800c7a4 <_nx_system_initialize+0xf8>)
 800c77e:	6013      	str	r3, [r2, #0]
#endif
#if (NX_TCP_MAXIMUM_TX_QUEUE > 0xFF)
    _nx_system_build_options_5 |=  ((ULONG)0xFF);
#else
    _nx_system_build_options_5 |=  ((ULONG)NX_TCP_MAXIMUM_TX_QUEUE);
 800c780:	4b08      	ldr	r3, [pc, #32]	; (800c7a4 <_nx_system_initialize+0xf8>)
 800c782:	681b      	ldr	r3, [r3, #0]
 800c784:	f043 0314 	orr.w	r3, r3, #20
 800c788:	4a06      	ldr	r2, [pc, #24]	; (800c7a4 <_nx_system_initialize+0xf8>)
 800c78a:	6013      	str	r3, [r2, #0]
 800c78c:	e000      	b.n	800c790 <_nx_system_initialize+0xe4>
        return;
 800c78e:	bf00      	nop
#endif
}
 800c790:	bd80      	pop	{r7, pc}
 800c792:	bf00      	nop
 800c794:	24000b18 	.word	0x24000b18
 800c798:	24000b1c 	.word	0x24000b1c
 800c79c:	24000b20 	.word	0x24000b20
 800c7a0:	24000b24 	.word	0x24000b24
 800c7a4:	24000b28 	.word	0x24000b28

0800c7a8 <_nx_tcp_cleanup_deferred>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
VOID  _nx_tcp_cleanup_deferred(TX_THREAD *thread_ptr NX_CLEANUP_PARAMETER)
{
 800c7a8:	b480      	push	{r7}
 800c7aa:	b083      	sub	sp, #12
 800c7ac:	af00      	add	r7, sp, #0
 800c7ae:	6078      	str	r0, [r7, #4]
 800c7b0:	6039      	str	r1, [r7, #0]
    NX_PARAMETER_NOT_USED(thread_ptr);

    NX_CLEANUP_EXTENSION
    /* This function is never called... so do nothing!  */
}
 800c7b2:	bf00      	nop
 800c7b4:	370c      	adds	r7, #12
 800c7b6:	46bd      	mov	sp, r7
 800c7b8:	f85d 7b04 	ldr.w	r7, [sp], #4
 800c7bc:	4770      	bx	lr
	...

0800c7c0 <_nx_tcp_client_bind_cleanup>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
VOID  _nx_tcp_client_bind_cleanup(TX_THREAD *thread_ptr NX_CLEANUP_PARAMETER)
{
 800c7c0:	b580      	push	{r7, lr}
 800c7c2:	b08e      	sub	sp, #56	; 0x38
 800c7c4:	af00      	add	r7, sp, #0
 800c7c6:	6078      	str	r0, [r7, #4]
 800c7c8:	6039      	str	r1, [r7, #0]
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 800c7ca:	f3ef 8310 	mrs	r3, PRIMASK
 800c7ce:	627b      	str	r3, [r7, #36]	; 0x24
    return(posture);
 800c7d0:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    int_posture = __get_interrupt_posture();
 800c7d2:	623b      	str	r3, [r7, #32]
    __asm__ volatile ("CPSID i" : : : "memory");
 800c7d4:	b672      	cpsid	i
    return(int_posture);
 800c7d6:	6a3b      	ldr	r3, [r7, #32]
NX_TCP_SOCKET *owning_socket_ptr; /* Socket owning the port  */

    NX_CLEANUP_EXTENSION

    /* Disable interrupts to remove the suspended thread from the TCP socket.  */
    TX_DISABLE
 800c7d8:	637b      	str	r3, [r7, #52]	; 0x34

    /* Setup pointer to TCP socket control block.  */
    socket_ptr =  (NX_TCP_SOCKET *)thread_ptr -> tx_thread_suspend_control_block;
 800c7da:	687b      	ldr	r3, [r7, #4]
 800c7dc:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 800c7de:	633b      	str	r3, [r7, #48]	; 0x30

    /* Determine if the socket pointer is valid.  */
    if ((!socket_ptr) || (socket_ptr -> nx_tcp_socket_id != NX_TCP_ID))
 800c7e0:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800c7e2:	2b00      	cmp	r3, #0
 800c7e4:	d004      	beq.n	800c7f0 <_nx_tcp_client_bind_cleanup+0x30>
 800c7e6:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800c7e8:	681b      	ldr	r3, [r3, #0]
 800c7ea:	4a42      	ldr	r2, [pc, #264]	; (800c8f4 <_nx_tcp_client_bind_cleanup+0x134>)
 800c7ec:	4293      	cmp	r3, r2
 800c7ee:	d006      	beq.n	800c7fe <_nx_tcp_client_bind_cleanup+0x3e>
 800c7f0:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800c7f2:	61fb      	str	r3, [r7, #28]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 800c7f4:	69fb      	ldr	r3, [r7, #28]
 800c7f6:	f383 8810 	msr	PRIMASK, r3
}
 800c7fa:	bf00      	nop
    {

        /* Restore interrupts.  */
        TX_RESTORE

        return;
 800c7fc:	e077      	b.n	800c8ee <_nx_tcp_client_bind_cleanup+0x12e>
    }

    /* Determine if the cleanup is still required.  */
    if (!(thread_ptr -> tx_thread_suspend_cleanup))
 800c7fe:	687b      	ldr	r3, [r7, #4]
 800c800:	6e9b      	ldr	r3, [r3, #104]	; 0x68
 800c802:	2b00      	cmp	r3, #0
 800c804:	d106      	bne.n	800c814 <_nx_tcp_client_bind_cleanup+0x54>
 800c806:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800c808:	61bb      	str	r3, [r7, #24]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 800c80a:	69bb      	ldr	r3, [r7, #24]
 800c80c:	f383 8810 	msr	PRIMASK, r3
}
 800c810:	bf00      	nop
    {

        /* Restore interrupts.  */
        TX_RESTORE

        return;
 800c812:	e06c      	b.n	800c8ee <_nx_tcp_client_bind_cleanup+0x12e>
    __asm__ volatile (" MRS  %0,IPSR ": "=r" (ipsr_value) );
 800c814:	f3ef 8305 	mrs	r3, IPSR
 800c818:	617b      	str	r3, [r7, #20]
    return(ipsr_value);
 800c81a:	697a      	ldr	r2, [r7, #20]
    }

    /* Determine if the caller is an ISR or the system timer thread.  */
#ifndef TX_TIMER_PROCESS_IN_ISR
    if ((TX_THREAD_GET_SYSTEM_STATE()) || (_tx_thread_current_ptr == &_tx_timer_thread))
 800c81c:	4b36      	ldr	r3, [pc, #216]	; (800c8f8 <_nx_tcp_client_bind_cleanup+0x138>)
 800c81e:	681b      	ldr	r3, [r3, #0]
 800c820:	4313      	orrs	r3, r2
 800c822:	2b00      	cmp	r3, #0
 800c824:	d104      	bne.n	800c830 <_nx_tcp_client_bind_cleanup+0x70>
 800c826:	4b35      	ldr	r3, [pc, #212]	; (800c8fc <_nx_tcp_client_bind_cleanup+0x13c>)
 800c828:	681b      	ldr	r3, [r3, #0]
 800c82a:	4a35      	ldr	r2, [pc, #212]	; (800c900 <_nx_tcp_client_bind_cleanup+0x140>)
 800c82c:	4293      	cmp	r3, r2
 800c82e:	d116      	bne.n	800c85e <_nx_tcp_client_bind_cleanup+0x9e>
    {

        /* Yes, defer the processing to the NetX IP thread.  */

        /* Yes, change the suspend cleanup routine to indicate the cleanup is deferred.  */
        thread_ptr -> tx_thread_suspend_cleanup =  _nx_tcp_cleanup_deferred;
 800c830:	687b      	ldr	r3, [r7, #4]
 800c832:	4a34      	ldr	r2, [pc, #208]	; (800c904 <_nx_tcp_client_bind_cleanup+0x144>)
 800c834:	669a      	str	r2, [r3, #104]	; 0x68

        /* Pickup the IP pointer.  */
        ip_ptr =  socket_ptr -> nx_tcp_socket_ip_ptr;
 800c836:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800c838:	f8d3 30a0 	ldr.w	r3, [r3, #160]	; 0xa0
 800c83c:	62bb      	str	r3, [r7, #40]	; 0x28
 800c83e:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800c840:	613b      	str	r3, [r7, #16]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 800c842:	693b      	ldr	r3, [r7, #16]
 800c844:	f383 8810 	msr	PRIMASK, r3
}
 800c848:	bf00      	nop

        /* Restore interrupts.  */
        TX_RESTORE

        /* Set the deferred cleanup flag for the IP thread.  */
        tx_event_flags_set(&(ip_ptr -> nx_ip_events), NX_IP_TCP_CLEANUP_DEFERRED, TX_OR);
 800c84a:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800c84c:	f503 7313 	add.w	r3, r3, #588	; 0x24c
 800c850:	2200      	movs	r2, #0
 800c852:	f44f 5180 	mov.w	r1, #4096	; 0x1000
 800c856:	4618      	mov	r0, r3
 800c858:	f005 fe48 	bl	80124ec <_tx_event_flags_set>

        /* Return to caller.  */
        return;
 800c85c:	e047      	b.n	800c8ee <_nx_tcp_client_bind_cleanup+0x12e>
    {

        /* Yes, we still have thread suspension!  */

        /* Clear the socket bind in progress flag.  */
        socket_ptr -> nx_tcp_socket_bind_in_progress =  NX_NULL;
 800c85e:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800c860:	2200      	movs	r2, #0
 800c862:	f8c3 20e8 	str.w	r2, [r3, #232]	; 0xe8

        /* Clear the suspension cleanup flag.  */
        thread_ptr -> tx_thread_suspend_cleanup =  TX_NULL;
 800c866:	687b      	ldr	r3, [r7, #4]
 800c868:	2200      	movs	r2, #0
 800c86a:	669a      	str	r2, [r3, #104]	; 0x68

        /* Pickup the socket owning the port. This pointer was
           saved in the bind processing prior to suspension.  */
        owning_socket_ptr =  socket_ptr -> nx_tcp_socket_bound_previous;
 800c86c:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800c86e:	f8d3 30e4 	ldr.w	r3, [r3, #228]	; 0xe4
 800c872:	62fb      	str	r3, [r7, #44]	; 0x2c

        /* Remove the suspended thread from the list.  */

        /* See if this is the only suspended thread on the list.  */
        if (thread_ptr == thread_ptr -> tx_thread_suspended_next)
 800c874:	687b      	ldr	r3, [r7, #4]
 800c876:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 800c878:	687a      	ldr	r2, [r7, #4]
 800c87a:	429a      	cmp	r2, r3
 800c87c:	d104      	bne.n	800c888 <_nx_tcp_client_bind_cleanup+0xc8>
        {

            /* Yes, the only suspended thread.  */

            /* Update the head pointer.  */
            owning_socket_ptr -> nx_tcp_socket_bind_suspension_list =  NX_NULL;
 800c87e:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800c880:	2200      	movs	r2, #0
 800c882:	f8c3 2104 	str.w	r2, [r3, #260]	; 0x104
 800c886:	e00e      	b.n	800c8a6 <_nx_tcp_client_bind_cleanup+0xe6>
        {

            /* At least one more thread is on the same suspension list.  */

            /* Update the list head pointer.  */
            owning_socket_ptr -> nx_tcp_socket_bind_suspension_list =  thread_ptr -> tx_thread_suspended_next;
 800c888:	687b      	ldr	r3, [r7, #4]
 800c88a:	6f1a      	ldr	r2, [r3, #112]	; 0x70
 800c88c:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800c88e:	f8c3 2104 	str.w	r2, [r3, #260]	; 0x104

            /* Update the links of the adjacent threads.  */
            (thread_ptr -> tx_thread_suspended_next) -> tx_thread_suspended_previous =
 800c892:	687b      	ldr	r3, [r7, #4]
 800c894:	6f1b      	ldr	r3, [r3, #112]	; 0x70
                thread_ptr -> tx_thread_suspended_previous;
 800c896:	687a      	ldr	r2, [r7, #4]
 800c898:	6f52      	ldr	r2, [r2, #116]	; 0x74
            (thread_ptr -> tx_thread_suspended_next) -> tx_thread_suspended_previous =
 800c89a:	675a      	str	r2, [r3, #116]	; 0x74
            (thread_ptr -> tx_thread_suspended_previous) -> tx_thread_suspended_next =
 800c89c:	687b      	ldr	r3, [r7, #4]
 800c89e:	6f5b      	ldr	r3, [r3, #116]	; 0x74
                thread_ptr -> tx_thread_suspended_next;
 800c8a0:	687a      	ldr	r2, [r7, #4]
 800c8a2:	6f12      	ldr	r2, [r2, #112]	; 0x70
            (thread_ptr -> tx_thread_suspended_previous) -> tx_thread_suspended_next =
 800c8a4:	671a      	str	r2, [r3, #112]	; 0x70
        }

        /* Decrement the suspension count.  */
        owning_socket_ptr -> nx_tcp_socket_bind_suspended_count--;
 800c8a6:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800c8a8:	f8d3 3108 	ldr.w	r3, [r3, #264]	; 0x108
 800c8ac:	1e5a      	subs	r2, r3, #1
 800c8ae:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800c8b0:	f8c3 2108 	str.w	r2, [r3, #264]	; 0x108

        /* Now we need to determine if this cleanup is from a terminate, timeout,
           or from a wait abort.  */
        if (thread_ptr -> tx_thread_state == TX_TCP_IP)
 800c8b4:	687b      	ldr	r3, [r7, #4]
 800c8b6:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800c8b8:	2b0c      	cmp	r3, #12
 800c8ba:	d112      	bne.n	800c8e2 <_nx_tcp_client_bind_cleanup+0x122>

            /* Thread still suspended on the TCP socket.  Setup return error status and
               resume the thread.  */

            /* Setup return status.  */
            thread_ptr -> tx_thread_suspend_status =  NX_PORT_UNAVAILABLE;
 800c8bc:	687b      	ldr	r3, [r7, #4]
 800c8be:	2223      	movs	r2, #35	; 0x23
 800c8c0:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84

            /* Temporarily disable preemption.  */
            _tx_thread_preempt_disable++;
 800c8c4:	4b10      	ldr	r3, [pc, #64]	; (800c908 <_nx_tcp_client_bind_cleanup+0x148>)
 800c8c6:	681b      	ldr	r3, [r3, #0]
 800c8c8:	3301      	adds	r3, #1
 800c8ca:	4a0f      	ldr	r2, [pc, #60]	; (800c908 <_nx_tcp_client_bind_cleanup+0x148>)
 800c8cc:	6013      	str	r3, [r2, #0]
 800c8ce:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800c8d0:	60fb      	str	r3, [r7, #12]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 800c8d2:	68fb      	ldr	r3, [r7, #12]
 800c8d4:	f383 8810 	msr	PRIMASK, r3
}
 800c8d8:	bf00      	nop
            TX_RESTORE

            /* Resume the thread!  Check for preemption even though we are executing
               from the system timer thread right now which normally executes at the
               highest priority.  */
            _tx_thread_system_resume(thread_ptr);
 800c8da:	6878      	ldr	r0, [r7, #4]
 800c8dc:	f008 fa24 	bl	8014d28 <_tx_thread_system_resume>

            /* Finished, just return.  */
            return;
 800c8e0:	e005      	b.n	800c8ee <_nx_tcp_client_bind_cleanup+0x12e>
 800c8e2:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800c8e4:	60bb      	str	r3, [r7, #8]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 800c8e6:	68bb      	ldr	r3, [r7, #8]
 800c8e8:	f383 8810 	msr	PRIMASK, r3
}
 800c8ec:	bf00      	nop
        }
    }

    /* Restore interrupts.  */
    TX_RESTORE
}
 800c8ee:	3738      	adds	r7, #56	; 0x38
 800c8f0:	46bd      	mov	sp, r7
 800c8f2:	bd80      	pop	{r7, pc}
 800c8f4:	54435020 	.word	0x54435020
 800c8f8:	24000078 	.word	0x24000078
 800c8fc:	24031bc4 	.word	0x24031bc4
 800c900:	24031d0c 	.word	0x24031d0c
 800c904:	0800c7a9 	.word	0x0800c7a9
 800c908:	24031c5c 	.word	0x24031c5c

0800c90c <_nx_tcp_connect_cleanup>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
VOID  _nx_tcp_connect_cleanup(TX_THREAD *thread_ptr NX_CLEANUP_PARAMETER)
{
 800c90c:	b580      	push	{r7, lr}
 800c90e:	b08e      	sub	sp, #56	; 0x38
 800c910:	af00      	add	r7, sp, #0
 800c912:	6078      	str	r0, [r7, #4]
 800c914:	6039      	str	r1, [r7, #0]
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 800c916:	f3ef 8310 	mrs	r3, PRIMASK
 800c91a:	62bb      	str	r3, [r7, #40]	; 0x28
    return(posture);
 800c91c:	6abb      	ldr	r3, [r7, #40]	; 0x28
    int_posture = __get_interrupt_posture();
 800c91e:	627b      	str	r3, [r7, #36]	; 0x24
    __asm__ volatile ("CPSID i" : : : "memory");
 800c920:	b672      	cpsid	i
    return(int_posture);
 800c922:	6a7b      	ldr	r3, [r7, #36]	; 0x24
NX_TCP_SOCKET *socket_ptr;  /* Working socket pointer  */

    NX_CLEANUP_EXTENSION

    /* Disable interrupts.  */
    TX_DISABLE
 800c924:	637b      	str	r3, [r7, #52]	; 0x34

    /* Setup pointer to TCP socket control block.  */
    socket_ptr =  (NX_TCP_SOCKET *)thread_ptr -> tx_thread_suspend_control_block;
 800c926:	687b      	ldr	r3, [r7, #4]
 800c928:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 800c92a:	633b      	str	r3, [r7, #48]	; 0x30

    /* Determine if the socket pointer is valid.  */
    if ((!socket_ptr) || (socket_ptr -> nx_tcp_socket_id != NX_TCP_ID))
 800c92c:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800c92e:	2b00      	cmp	r3, #0
 800c930:	d004      	beq.n	800c93c <_nx_tcp_connect_cleanup+0x30>
 800c932:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800c934:	681b      	ldr	r3, [r3, #0]
 800c936:	4a3a      	ldr	r2, [pc, #232]	; (800ca20 <_nx_tcp_connect_cleanup+0x114>)
 800c938:	4293      	cmp	r3, r2
 800c93a:	d006      	beq.n	800c94a <_nx_tcp_connect_cleanup+0x3e>
 800c93c:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800c93e:	623b      	str	r3, [r7, #32]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 800c940:	6a3b      	ldr	r3, [r7, #32]
 800c942:	f383 8810 	msr	PRIMASK, r3
}
 800c946:	bf00      	nop
    {

        /* Restore interrupts.  */
        TX_RESTORE

        return;
 800c948:	e067      	b.n	800ca1a <_nx_tcp_connect_cleanup+0x10e>
    }

    /* Determine if the cleanup is still required.  */
    if (!(thread_ptr -> tx_thread_suspend_cleanup))
 800c94a:	687b      	ldr	r3, [r7, #4]
 800c94c:	6e9b      	ldr	r3, [r3, #104]	; 0x68
 800c94e:	2b00      	cmp	r3, #0
 800c950:	d106      	bne.n	800c960 <_nx_tcp_connect_cleanup+0x54>
 800c952:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800c954:	61fb      	str	r3, [r7, #28]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 800c956:	69fb      	ldr	r3, [r7, #28]
 800c958:	f383 8810 	msr	PRIMASK, r3
}
 800c95c:	bf00      	nop
    {

        /* Restore interrupts.  */
        TX_RESTORE

        return;
 800c95e:	e05c      	b.n	800ca1a <_nx_tcp_connect_cleanup+0x10e>
    }

    /* Pickup the IP pointer.  */
    ip_ptr =  socket_ptr -> nx_tcp_socket_ip_ptr;
 800c960:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800c962:	f8d3 30a0 	ldr.w	r3, [r3, #160]	; 0xa0
 800c966:	62fb      	str	r3, [r7, #44]	; 0x2c
    __asm__ volatile (" MRS  %0,IPSR ": "=r" (ipsr_value) );
 800c968:	f3ef 8305 	mrs	r3, IPSR
 800c96c:	61bb      	str	r3, [r7, #24]
    return(ipsr_value);
 800c96e:	69ba      	ldr	r2, [r7, #24]

    /* Determine if the caller is an ISR or the system timer thread.  */
#ifndef TX_TIMER_PROCESS_IN_ISR
    if ((TX_THREAD_GET_SYSTEM_STATE()) || (_tx_thread_current_ptr == &_tx_timer_thread))
 800c970:	4b2c      	ldr	r3, [pc, #176]	; (800ca24 <_nx_tcp_connect_cleanup+0x118>)
 800c972:	681b      	ldr	r3, [r3, #0]
 800c974:	4313      	orrs	r3, r2
 800c976:	2b00      	cmp	r3, #0
 800c978:	d104      	bne.n	800c984 <_nx_tcp_connect_cleanup+0x78>
 800c97a:	4b2b      	ldr	r3, [pc, #172]	; (800ca28 <_nx_tcp_connect_cleanup+0x11c>)
 800c97c:	681b      	ldr	r3, [r3, #0]
 800c97e:	4a2b      	ldr	r2, [pc, #172]	; (800ca2c <_nx_tcp_connect_cleanup+0x120>)
 800c980:	4293      	cmp	r3, r2
 800c982:	d112      	bne.n	800c9aa <_nx_tcp_connect_cleanup+0x9e>
    {

        /* Yes, defer the processing to the NetX IP thread.  */

        /* Yes, change the suspend cleanup routine to indicate the cleanup is deferred.  */
        thread_ptr -> tx_thread_suspend_cleanup =  _nx_tcp_cleanup_deferred;
 800c984:	687b      	ldr	r3, [r7, #4]
 800c986:	4a2a      	ldr	r2, [pc, #168]	; (800ca30 <_nx_tcp_connect_cleanup+0x124>)
 800c988:	669a      	str	r2, [r3, #104]	; 0x68
 800c98a:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800c98c:	617b      	str	r3, [r7, #20]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 800c98e:	697b      	ldr	r3, [r7, #20]
 800c990:	f383 8810 	msr	PRIMASK, r3
}
 800c994:	bf00      	nop

        /* Restore interrupts.  */
        TX_RESTORE

        /* Set the deferred cleanup flag for the IP thread.  */
        tx_event_flags_set(&(ip_ptr -> nx_ip_events), NX_IP_TCP_CLEANUP_DEFERRED, TX_OR);
 800c996:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800c998:	f503 7313 	add.w	r3, r3, #588	; 0x24c
 800c99c:	2200      	movs	r2, #0
 800c99e:	f44f 5180 	mov.w	r1, #4096	; 0x1000
 800c9a2:	4618      	mov	r0, r3
 800c9a4:	f005 fda2 	bl	80124ec <_tx_event_flags_set>

        /* Return to caller.  */
        return;
 800c9a8:	e037      	b.n	800ca1a <_nx_tcp_connect_cleanup+0x10e>
    {

        /* Yes, we still have thread suspension!  */

        /* Clear the suspension cleanup flag.  */
        thread_ptr -> tx_thread_suspend_cleanup =  TX_NULL;
 800c9aa:	687b      	ldr	r3, [r7, #4]
 800c9ac:	2200      	movs	r2, #0
 800c9ae:	669a      	str	r2, [r3, #104]	; 0x68

        /* Clear the suspension pointer.   */
        socket_ptr -> nx_tcp_socket_connect_suspended_thread =  NX_NULL;
 800c9b0:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800c9b2:	2200      	movs	r2, #0
 800c9b4:	f8c3 20fc 	str.w	r2, [r3, #252]	; 0xfc

        /* Clear the timeout.  */
        socket_ptr -> nx_tcp_socket_timeout =  0;
 800c9b8:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800c9ba:	2200      	movs	r2, #0
 800c9bc:	f8c3 20cc 	str.w	r2, [r3, #204]	; 0xcc

        /* Return to the proper socket state.  */
        if (socket_ptr -> nx_tcp_socket_client_type)
 800c9c0:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800c9c2:	689b      	ldr	r3, [r3, #8]
 800c9c4:	2b00      	cmp	r3, #0
 800c9c6:	d003      	beq.n	800c9d0 <_nx_tcp_connect_cleanup+0xc4>

            /* If trace is enabled, insert this event into the trace buffer.  */
            NX_TRACE_IN_LINE_INSERT(NX_TRACE_INTERNAL_TCP_STATE_CHANGE, ip_ptr, socket_ptr, socket_ptr -> nx_tcp_socket_state, NX_TCP_CLOSED, NX_TRACE_INTERNAL_EVENTS, 0, 0);

            /* Client socket, return to a CLOSED state.  */
            socket_ptr -> nx_tcp_socket_state =  NX_TCP_CLOSED;
 800c9c8:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800c9ca:	2201      	movs	r2, #1
 800c9cc:	639a      	str	r2, [r3, #56]	; 0x38
 800c9ce:	e007      	b.n	800c9e0 <_nx_tcp_connect_cleanup+0xd4>

            /* If trace is enabled, insert this event into the trace buffer.  */
            NX_TRACE_IN_LINE_INSERT(NX_TRACE_INTERNAL_TCP_STATE_CHANGE, ip_ptr, socket_ptr, socket_ptr -> nx_tcp_socket_state, NX_TCP_LISTEN_STATE, NX_TRACE_INTERNAL_EVENTS, 0, 0);

            /* Server socket, return to LISTEN state.  */
            socket_ptr -> nx_tcp_socket_state =  NX_TCP_LISTEN_STATE;
 800c9d0:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800c9d2:	2202      	movs	r2, #2
 800c9d4:	639a      	str	r2, [r3, #56]	; 0x38

            /* Move back the acknowledgment number just in case there is a retry.  */
            socket_ptr -> nx_tcp_socket_rx_sequence--;
 800c9d6:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800c9d8:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 800c9da:	1e5a      	subs	r2, r3, #1
 800c9dc:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800c9de:	641a      	str	r2, [r3, #64]	; 0x40
        }

        /* Now we need to determine if this cleanup is from a terminate, timeout,
           or from a wait abort.  */
        if (thread_ptr -> tx_thread_state == TX_TCP_IP)
 800c9e0:	687b      	ldr	r3, [r7, #4]
 800c9e2:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800c9e4:	2b0c      	cmp	r3, #12
 800c9e6:	d112      	bne.n	800ca0e <_nx_tcp_connect_cleanup+0x102>

            /* Thread still suspended on the TCP socket.  Setup return error status and
               resume the thread.  */

            /* Setup return status.  */
            thread_ptr -> tx_thread_suspend_status =  NX_NOT_CONNECTED;
 800c9e8:	687b      	ldr	r3, [r7, #4]
 800c9ea:	2238      	movs	r2, #56	; 0x38
 800c9ec:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84

            /* Temporarily disable preemption.  */
            _tx_thread_preempt_disable++;
 800c9f0:	4b10      	ldr	r3, [pc, #64]	; (800ca34 <_nx_tcp_connect_cleanup+0x128>)
 800c9f2:	681b      	ldr	r3, [r3, #0]
 800c9f4:	3301      	adds	r3, #1
 800c9f6:	4a0f      	ldr	r2, [pc, #60]	; (800ca34 <_nx_tcp_connect_cleanup+0x128>)
 800c9f8:	6013      	str	r3, [r2, #0]
 800c9fa:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800c9fc:	613b      	str	r3, [r7, #16]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 800c9fe:	693b      	ldr	r3, [r7, #16]
 800ca00:	f383 8810 	msr	PRIMASK, r3
}
 800ca04:	bf00      	nop
            TX_RESTORE

            /* Resume the thread!  Check for preemption even though we are executing
               from the system timer thread right now which normally executes at the
               highest priority.  */
            _tx_thread_system_resume(thread_ptr);
 800ca06:	6878      	ldr	r0, [r7, #4]
 800ca08:	f008 f98e 	bl	8014d28 <_tx_thread_system_resume>

            /* Finished, just return.  */
            return;
 800ca0c:	e005      	b.n	800ca1a <_nx_tcp_connect_cleanup+0x10e>
 800ca0e:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800ca10:	60fb      	str	r3, [r7, #12]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 800ca12:	68fb      	ldr	r3, [r7, #12]
 800ca14:	f383 8810 	msr	PRIMASK, r3
}
 800ca18:	bf00      	nop
        }
    }

    /* Restore interrupts.  */
    TX_RESTORE
}
 800ca1a:	3738      	adds	r7, #56	; 0x38
 800ca1c:	46bd      	mov	sp, r7
 800ca1e:	bd80      	pop	{r7, pc}
 800ca20:	54435020 	.word	0x54435020
 800ca24:	24000078 	.word	0x24000078
 800ca28:	24031bc4 	.word	0x24031bc4
 800ca2c:	24031d0c 	.word	0x24031d0c
 800ca30:	0800c7a9 	.word	0x0800c7a9
 800ca34:	24031c5c 	.word	0x24031c5c

0800ca38 <_nx_tcp_deferred_cleanup_check>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
VOID  _nx_tcp_deferred_cleanup_check(NX_IP *ip_ptr)
{
 800ca38:	b580      	push	{r7, lr}
 800ca3a:	b086      	sub	sp, #24
 800ca3c:	af00      	add	r7, sp, #0
 800ca3e:	6078      	str	r0, [r7, #4]
NX_TCP_SOCKET *socket_ptr;
TX_THREAD     *thread_ptr;


    /* Pickup the first socket and the created count.  */
    socket_ptr =       ip_ptr -> nx_ip_tcp_created_sockets_ptr;
 800ca40:	687b      	ldr	r3, [r7, #4]
 800ca42:	f8d3 348c 	ldr.w	r3, [r3, #1164]	; 0x48c
 800ca46:	60fb      	str	r3, [r7, #12]
    created_sockets =  ip_ptr -> nx_ip_tcp_created_sockets_count;
 800ca48:	687b      	ldr	r3, [r7, #4]
 800ca4a:	f8d3 3490 	ldr.w	r3, [r3, #1168]	; 0x490
 800ca4e:	617b      	str	r3, [r7, #20]

    /* Loop through all created TCP sockets on the IP instance.  */
    while (created_sockets--)
 800ca50:	e07a      	b.n	800cb48 <_nx_tcp_deferred_cleanup_check+0x110>
    {

        /* Check the socket for deferred bind cleanup.  */
        suspended_threads =  socket_ptr -> nx_tcp_socket_bind_suspended_count;
 800ca52:	68fb      	ldr	r3, [r7, #12]
 800ca54:	f8d3 3108 	ldr.w	r3, [r3, #264]	; 0x108
 800ca58:	613b      	str	r3, [r7, #16]
        if (suspended_threads)
 800ca5a:	693b      	ldr	r3, [r7, #16]
 800ca5c:	2b00      	cmp	r3, #0
 800ca5e:	d015      	beq.n	800ca8c <_nx_tcp_deferred_cleanup_check+0x54>
        {

            /* Pickup the socket pointer.  */
            thread_ptr =  socket_ptr -> nx_tcp_socket_bind_suspension_list;
 800ca60:	68fb      	ldr	r3, [r7, #12]
 800ca62:	f8d3 3104 	ldr.w	r3, [r3, #260]	; 0x104
 800ca66:	60bb      	str	r3, [r7, #8]
               is a timeout.  */
            do
            {

                /* Determine if this thread has deferred the timeout processing.  */
                if (thread_ptr -> tx_thread_suspend_cleanup == _nx_tcp_cleanup_deferred)
 800ca68:	68bb      	ldr	r3, [r7, #8]
 800ca6a:	6e9b      	ldr	r3, [r3, #104]	; 0x68
 800ca6c:	4a3c      	ldr	r2, [pc, #240]	; (800cb60 <_nx_tcp_deferred_cleanup_check+0x128>)
 800ca6e:	4293      	cmp	r3, r2
 800ca70:	d103      	bne.n	800ca7a <_nx_tcp_deferred_cleanup_check+0x42>
                {

                    /* Yes, call the cleanup routine again!  */
                    _nx_tcp_client_bind_cleanup(thread_ptr NX_CLEANUP_ARGUMENT);
 800ca72:	2100      	movs	r1, #0
 800ca74:	68b8      	ldr	r0, [r7, #8]
 800ca76:	f7ff fea3 	bl	800c7c0 <_nx_tcp_client_bind_cleanup>
                }

                /* Move to next suspended thread.  */
                thread_ptr =  thread_ptr -> tx_thread_suspended_next;
 800ca7a:	68bb      	ldr	r3, [r7, #8]
 800ca7c:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 800ca7e:	60bb      	str	r3, [r7, #8]
            } while (--suspended_threads);
 800ca80:	693b      	ldr	r3, [r7, #16]
 800ca82:	3b01      	subs	r3, #1
 800ca84:	613b      	str	r3, [r7, #16]
 800ca86:	693b      	ldr	r3, [r7, #16]
 800ca88:	2b00      	cmp	r3, #0
 800ca8a:	d1ed      	bne.n	800ca68 <_nx_tcp_deferred_cleanup_check+0x30>
        }

        /* Check the socket for deferred connect cleanup.  */
        thread_ptr =  socket_ptr -> nx_tcp_socket_connect_suspended_thread;
 800ca8c:	68fb      	ldr	r3, [r7, #12]
 800ca8e:	f8d3 30fc 	ldr.w	r3, [r3, #252]	; 0xfc
 800ca92:	60bb      	str	r3, [r7, #8]
        if (thread_ptr)
 800ca94:	68bb      	ldr	r3, [r7, #8]
 800ca96:	2b00      	cmp	r3, #0
 800ca98:	d008      	beq.n	800caac <_nx_tcp_deferred_cleanup_check+0x74>
        {

            /* Determine if this thread has deferred the timeout processing.  */
            if (thread_ptr -> tx_thread_suspend_cleanup == _nx_tcp_cleanup_deferred)
 800ca9a:	68bb      	ldr	r3, [r7, #8]
 800ca9c:	6e9b      	ldr	r3, [r3, #104]	; 0x68
 800ca9e:	4a30      	ldr	r2, [pc, #192]	; (800cb60 <_nx_tcp_deferred_cleanup_check+0x128>)
 800caa0:	4293      	cmp	r3, r2
 800caa2:	d103      	bne.n	800caac <_nx_tcp_deferred_cleanup_check+0x74>
            {

                /* Yes, call the cleanup routine again!  */
                _nx_tcp_connect_cleanup(thread_ptr NX_CLEANUP_ARGUMENT);
 800caa4:	2100      	movs	r1, #0
 800caa6:	68b8      	ldr	r0, [r7, #8]
 800caa8:	f7ff ff30 	bl	800c90c <_nx_tcp_connect_cleanup>
            }
        }

        /* Check the socket for deferred disconnect cleanup.  */
        thread_ptr =  socket_ptr -> nx_tcp_socket_disconnect_suspended_thread;
 800caac:	68fb      	ldr	r3, [r7, #12]
 800caae:	f8d3 3100 	ldr.w	r3, [r3, #256]	; 0x100
 800cab2:	60bb      	str	r3, [r7, #8]
        if (thread_ptr)
 800cab4:	68bb      	ldr	r3, [r7, #8]
 800cab6:	2b00      	cmp	r3, #0
 800cab8:	d008      	beq.n	800cacc <_nx_tcp_deferred_cleanup_check+0x94>
        {

            /* Determine if this thread has deferred the timeout processing.  */
            if (thread_ptr -> tx_thread_suspend_cleanup == _nx_tcp_cleanup_deferred)
 800caba:	68bb      	ldr	r3, [r7, #8]
 800cabc:	6e9b      	ldr	r3, [r3, #104]	; 0x68
 800cabe:	4a28      	ldr	r2, [pc, #160]	; (800cb60 <_nx_tcp_deferred_cleanup_check+0x128>)
 800cac0:	4293      	cmp	r3, r2
 800cac2:	d103      	bne.n	800cacc <_nx_tcp_deferred_cleanup_check+0x94>
            {

                /* Yes, call the cleanup routine again!  */
                _nx_tcp_disconnect_cleanup(thread_ptr NX_CLEANUP_ARGUMENT);
 800cac4:	2100      	movs	r1, #0
 800cac6:	68b8      	ldr	r0, [r7, #8]
 800cac8:	f000 f84c 	bl	800cb64 <_nx_tcp_disconnect_cleanup>
            }
        }

        /* Check the socket for deferred receive cleanup.  */
        suspended_threads =  socket_ptr -> nx_tcp_socket_receive_suspended_count;
 800cacc:	68fb      	ldr	r3, [r7, #12]
 800cace:	f8d3 30f0 	ldr.w	r3, [r3, #240]	; 0xf0
 800cad2:	613b      	str	r3, [r7, #16]
        if (suspended_threads)
 800cad4:	693b      	ldr	r3, [r7, #16]
 800cad6:	2b00      	cmp	r3, #0
 800cad8:	d015      	beq.n	800cb06 <_nx_tcp_deferred_cleanup_check+0xce>
        {

            /* Pickup the socket pointer.  */
            thread_ptr =  socket_ptr -> nx_tcp_socket_receive_suspension_list;
 800cada:	68fb      	ldr	r3, [r7, #12]
 800cadc:	f8d3 30ec 	ldr.w	r3, [r3, #236]	; 0xec
 800cae0:	60bb      	str	r3, [r7, #8]
               is a timeout.  */
            do
            {

                /* Determine if this thread has deferred the timeout processing.  */
                if (thread_ptr -> tx_thread_suspend_cleanup == _nx_tcp_cleanup_deferred)
 800cae2:	68bb      	ldr	r3, [r7, #8]
 800cae4:	6e9b      	ldr	r3, [r3, #104]	; 0x68
 800cae6:	4a1e      	ldr	r2, [pc, #120]	; (800cb60 <_nx_tcp_deferred_cleanup_check+0x128>)
 800cae8:	4293      	cmp	r3, r2
 800caea:	d103      	bne.n	800caf4 <_nx_tcp_deferred_cleanup_check+0xbc>
                {

                    /* Yes, call the cleanup routine again!  */
                    _nx_tcp_receive_cleanup(thread_ptr NX_CLEANUP_ARGUMENT);
 800caec:	2100      	movs	r1, #0
 800caee:	68b8      	ldr	r0, [r7, #8]
 800caf0:	f001 f960 	bl	800ddb4 <_nx_tcp_receive_cleanup>
                }

                /* Move to next suspended thread.  */
                thread_ptr =  thread_ptr -> tx_thread_suspended_next;
 800caf4:	68bb      	ldr	r3, [r7, #8]
 800caf6:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 800caf8:	60bb      	str	r3, [r7, #8]
            } while (--suspended_threads);
 800cafa:	693b      	ldr	r3, [r7, #16]
 800cafc:	3b01      	subs	r3, #1
 800cafe:	613b      	str	r3, [r7, #16]
 800cb00:	693b      	ldr	r3, [r7, #16]
 800cb02:	2b00      	cmp	r3, #0
 800cb04:	d1ed      	bne.n	800cae2 <_nx_tcp_deferred_cleanup_check+0xaa>
        }

        /* Check the socket for deferred transmit cleanup.  */
        suspended_threads =  socket_ptr -> nx_tcp_socket_transmit_suspended_count;
 800cb06:	68fb      	ldr	r3, [r7, #12]
 800cb08:	f8d3 30f8 	ldr.w	r3, [r3, #248]	; 0xf8
 800cb0c:	613b      	str	r3, [r7, #16]
        if (suspended_threads)
 800cb0e:	693b      	ldr	r3, [r7, #16]
 800cb10:	2b00      	cmp	r3, #0
 800cb12:	d015      	beq.n	800cb40 <_nx_tcp_deferred_cleanup_check+0x108>
        {

            /* Pickup the socket pointer.  */
            thread_ptr =  socket_ptr -> nx_tcp_socket_transmit_suspension_list;
 800cb14:	68fb      	ldr	r3, [r7, #12]
 800cb16:	f8d3 30f4 	ldr.w	r3, [r3, #244]	; 0xf4
 800cb1a:	60bb      	str	r3, [r7, #8]
               is a timeout.  */
            do
            {

                /* Determine if this thread has deferred the timeout processing.  */
                if (thread_ptr -> tx_thread_suspend_cleanup == _nx_tcp_cleanup_deferred)
 800cb1c:	68bb      	ldr	r3, [r7, #8]
 800cb1e:	6e9b      	ldr	r3, [r3, #104]	; 0x68
 800cb20:	4a0f      	ldr	r2, [pc, #60]	; (800cb60 <_nx_tcp_deferred_cleanup_check+0x128>)
 800cb22:	4293      	cmp	r3, r2
 800cb24:	d103      	bne.n	800cb2e <_nx_tcp_deferred_cleanup_check+0xf6>
                {

                    /* Yes, call the cleanup routine again!  */
                    _nx_tcp_transmit_cleanup(thread_ptr NX_CLEANUP_ARGUMENT);
 800cb26:	2100      	movs	r1, #0
 800cb28:	68b8      	ldr	r0, [r7, #8]
 800cb2a:	f003 f857 	bl	800fbdc <_nx_tcp_transmit_cleanup>
                }

                /* Move to next suspended thread.  */
                thread_ptr =  thread_ptr -> tx_thread_suspended_next;
 800cb2e:	68bb      	ldr	r3, [r7, #8]
 800cb30:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 800cb32:	60bb      	str	r3, [r7, #8]
            } while (--suspended_threads);
 800cb34:	693b      	ldr	r3, [r7, #16]
 800cb36:	3b01      	subs	r3, #1
 800cb38:	613b      	str	r3, [r7, #16]
 800cb3a:	693b      	ldr	r3, [r7, #16]
 800cb3c:	2b00      	cmp	r3, #0
 800cb3e:	d1ed      	bne.n	800cb1c <_nx_tcp_deferred_cleanup_check+0xe4>
        }

        /* Move to next created TCP socket.  */
        socket_ptr =  socket_ptr -> nx_tcp_socket_created_next;
 800cb40:	68fb      	ldr	r3, [r7, #12]
 800cb42:	f8d3 310c 	ldr.w	r3, [r3, #268]	; 0x10c
 800cb46:	60fb      	str	r3, [r7, #12]
    while (created_sockets--)
 800cb48:	697b      	ldr	r3, [r7, #20]
 800cb4a:	1e5a      	subs	r2, r3, #1
 800cb4c:	617a      	str	r2, [r7, #20]
 800cb4e:	2b00      	cmp	r3, #0
 800cb50:	f47f af7f 	bne.w	800ca52 <_nx_tcp_deferred_cleanup_check+0x1a>
    }
}
 800cb54:	bf00      	nop
 800cb56:	bf00      	nop
 800cb58:	3718      	adds	r7, #24
 800cb5a:	46bd      	mov	sp, r7
 800cb5c:	bd80      	pop	{r7, pc}
 800cb5e:	bf00      	nop
 800cb60:	0800c7a9 	.word	0x0800c7a9

0800cb64 <_nx_tcp_disconnect_cleanup>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
VOID  _nx_tcp_disconnect_cleanup(TX_THREAD *thread_ptr NX_CLEANUP_PARAMETER)
{
 800cb64:	b580      	push	{r7, lr}
 800cb66:	b08e      	sub	sp, #56	; 0x38
 800cb68:	af00      	add	r7, sp, #0
 800cb6a:	6078      	str	r0, [r7, #4]
 800cb6c:	6039      	str	r1, [r7, #0]
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 800cb6e:	f3ef 8310 	mrs	r3, PRIMASK
 800cb72:	62bb      	str	r3, [r7, #40]	; 0x28
    return(posture);
 800cb74:	6abb      	ldr	r3, [r7, #40]	; 0x28
    int_posture = __get_interrupt_posture();
 800cb76:	627b      	str	r3, [r7, #36]	; 0x24
    __asm__ volatile ("CPSID i" : : : "memory");
 800cb78:	b672      	cpsid	i
    return(int_posture);
 800cb7a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
NX_TCP_SOCKET *socket_ptr;  /* Working socket pointer  */

    NX_CLEANUP_EXTENSION

    /* Disable interrupts.  */
    TX_DISABLE
 800cb7c:	637b      	str	r3, [r7, #52]	; 0x34

    /* Setup pointer to TCP socket control block.  */
    socket_ptr =  (NX_TCP_SOCKET *)thread_ptr -> tx_thread_suspend_control_block;
 800cb7e:	687b      	ldr	r3, [r7, #4]
 800cb80:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 800cb82:	633b      	str	r3, [r7, #48]	; 0x30

    /* Determine if the socket pointer is valid.  */
    if ((!socket_ptr) || (socket_ptr -> nx_tcp_socket_id != NX_TCP_ID))
 800cb84:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800cb86:	2b00      	cmp	r3, #0
 800cb88:	d004      	beq.n	800cb94 <_nx_tcp_disconnect_cleanup+0x30>
 800cb8a:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800cb8c:	681b      	ldr	r3, [r3, #0]
 800cb8e:	4a30      	ldr	r2, [pc, #192]	; (800cc50 <_nx_tcp_disconnect_cleanup+0xec>)
 800cb90:	4293      	cmp	r3, r2
 800cb92:	d006      	beq.n	800cba2 <_nx_tcp_disconnect_cleanup+0x3e>
 800cb94:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800cb96:	623b      	str	r3, [r7, #32]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 800cb98:	6a3b      	ldr	r3, [r7, #32]
 800cb9a:	f383 8810 	msr	PRIMASK, r3
}
 800cb9e:	bf00      	nop
    {

        /* Restore interrupts.  */
        TX_RESTORE

        return;
 800cba0:	e053      	b.n	800cc4a <_nx_tcp_disconnect_cleanup+0xe6>
    }

    /* Determine if the cleanup is still required.  */
    if (!(thread_ptr -> tx_thread_suspend_cleanup))
 800cba2:	687b      	ldr	r3, [r7, #4]
 800cba4:	6e9b      	ldr	r3, [r3, #104]	; 0x68
 800cba6:	2b00      	cmp	r3, #0
 800cba8:	d106      	bne.n	800cbb8 <_nx_tcp_disconnect_cleanup+0x54>
 800cbaa:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800cbac:	61fb      	str	r3, [r7, #28]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 800cbae:	69fb      	ldr	r3, [r7, #28]
 800cbb0:	f383 8810 	msr	PRIMASK, r3
}
 800cbb4:	bf00      	nop
    {

        /* Restore interrupts.  */
        TX_RESTORE

        return;
 800cbb6:	e048      	b.n	800cc4a <_nx_tcp_disconnect_cleanup+0xe6>
    __asm__ volatile (" MRS  %0,IPSR ": "=r" (ipsr_value) );
 800cbb8:	f3ef 8305 	mrs	r3, IPSR
 800cbbc:	61bb      	str	r3, [r7, #24]
    return(ipsr_value);
 800cbbe:	69ba      	ldr	r2, [r7, #24]
    }

    /* Determine if the caller is an ISR or the system timer thread.  */
#ifndef TX_TIMER_PROCESS_IN_ISR
    if ((TX_THREAD_GET_SYSTEM_STATE()) || (_tx_thread_current_ptr == &_tx_timer_thread))
 800cbc0:	4b24      	ldr	r3, [pc, #144]	; (800cc54 <_nx_tcp_disconnect_cleanup+0xf0>)
 800cbc2:	681b      	ldr	r3, [r3, #0]
 800cbc4:	4313      	orrs	r3, r2
 800cbc6:	2b00      	cmp	r3, #0
 800cbc8:	d104      	bne.n	800cbd4 <_nx_tcp_disconnect_cleanup+0x70>
 800cbca:	4b23      	ldr	r3, [pc, #140]	; (800cc58 <_nx_tcp_disconnect_cleanup+0xf4>)
 800cbcc:	681b      	ldr	r3, [r3, #0]
 800cbce:	4a23      	ldr	r2, [pc, #140]	; (800cc5c <_nx_tcp_disconnect_cleanup+0xf8>)
 800cbd0:	4293      	cmp	r3, r2
 800cbd2:	d116      	bne.n	800cc02 <_nx_tcp_disconnect_cleanup+0x9e>
    {

        /* Yes, defer the processing to the NetX IP thread.  */

        /* Yes, change the suspend cleanup routine to indicate the cleanup is deferred.  */
        thread_ptr -> tx_thread_suspend_cleanup =  _nx_tcp_cleanup_deferred;
 800cbd4:	687b      	ldr	r3, [r7, #4]
 800cbd6:	4a22      	ldr	r2, [pc, #136]	; (800cc60 <_nx_tcp_disconnect_cleanup+0xfc>)
 800cbd8:	669a      	str	r2, [r3, #104]	; 0x68

        /* Pickup the IP pointer.  */
        ip_ptr =  socket_ptr -> nx_tcp_socket_ip_ptr;
 800cbda:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800cbdc:	f8d3 30a0 	ldr.w	r3, [r3, #160]	; 0xa0
 800cbe0:	62fb      	str	r3, [r7, #44]	; 0x2c
 800cbe2:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800cbe4:	617b      	str	r3, [r7, #20]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 800cbe6:	697b      	ldr	r3, [r7, #20]
 800cbe8:	f383 8810 	msr	PRIMASK, r3
}
 800cbec:	bf00      	nop

        /* Restore interrupts.  */
        TX_RESTORE

        /* Set the deferred cleanup flag for the IP thread.  */
        tx_event_flags_set(&(ip_ptr -> nx_ip_events), NX_IP_TCP_CLEANUP_DEFERRED, TX_OR);
 800cbee:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800cbf0:	f503 7313 	add.w	r3, r3, #588	; 0x24c
 800cbf4:	2200      	movs	r2, #0
 800cbf6:	f44f 5180 	mov.w	r1, #4096	; 0x1000
 800cbfa:	4618      	mov	r0, r3
 800cbfc:	f005 fc76 	bl	80124ec <_tx_event_flags_set>

        /* Return to caller.  */
        return;
 800cc00:	e023      	b.n	800cc4a <_nx_tcp_disconnect_cleanup+0xe6>
    {

        /* Yes, we still have thread suspension!  */

        /* Clear the suspension cleanup flag.  */
        thread_ptr -> tx_thread_suspend_cleanup =  TX_NULL;
 800cc02:	687b      	ldr	r3, [r7, #4]
 800cc04:	2200      	movs	r2, #0
 800cc06:	669a      	str	r2, [r3, #104]	; 0x68

        /* Clear the suspension pointer.   */
        socket_ptr -> nx_tcp_socket_disconnect_suspended_thread =  NX_NULL;
 800cc08:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800cc0a:	2200      	movs	r2, #0
 800cc0c:	f8c3 2100 	str.w	r2, [r3, #256]	; 0x100

        /* Now we need to determine if this cleanup is from a terminate, timeout,
           or from a wait abort.  */
        if (thread_ptr -> tx_thread_state == TX_TCP_IP)
 800cc10:	687b      	ldr	r3, [r7, #4]
 800cc12:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800cc14:	2b0c      	cmp	r3, #12
 800cc16:	d112      	bne.n	800cc3e <_nx_tcp_disconnect_cleanup+0xda>

            /* Thread still suspended on the TCP socket.  Setup return error status and
               resume the thread.  */

            /* Setup return status.  */
            thread_ptr -> tx_thread_suspend_status =  NX_DISCONNECT_FAILED;
 800cc18:	687b      	ldr	r3, [r7, #4]
 800cc1a:	2241      	movs	r2, #65	; 0x41
 800cc1c:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84

            /* Temporarily disable preemption.  */
            _tx_thread_preempt_disable++;
 800cc20:	4b10      	ldr	r3, [pc, #64]	; (800cc64 <_nx_tcp_disconnect_cleanup+0x100>)
 800cc22:	681b      	ldr	r3, [r3, #0]
 800cc24:	3301      	adds	r3, #1
 800cc26:	4a0f      	ldr	r2, [pc, #60]	; (800cc64 <_nx_tcp_disconnect_cleanup+0x100>)
 800cc28:	6013      	str	r3, [r2, #0]
 800cc2a:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800cc2c:	613b      	str	r3, [r7, #16]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 800cc2e:	693b      	ldr	r3, [r7, #16]
 800cc30:	f383 8810 	msr	PRIMASK, r3
}
 800cc34:	bf00      	nop
            TX_RESTORE

            /* Resume the thread!  Check for preemption even though we are executing
               from the system timer thread right now which normally executes at the
               highest priority.  */
            _tx_thread_system_resume(thread_ptr);
 800cc36:	6878      	ldr	r0, [r7, #4]
 800cc38:	f008 f876 	bl	8014d28 <_tx_thread_system_resume>

            /* Finished, just return.  */
            return;
 800cc3c:	e005      	b.n	800cc4a <_nx_tcp_disconnect_cleanup+0xe6>
 800cc3e:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800cc40:	60fb      	str	r3, [r7, #12]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 800cc42:	68fb      	ldr	r3, [r7, #12]
 800cc44:	f383 8810 	msr	PRIMASK, r3
}
 800cc48:	bf00      	nop
        }
    }

    /* Restore interrupts.  */
    TX_RESTORE
}
 800cc4a:	3738      	adds	r7, #56	; 0x38
 800cc4c:	46bd      	mov	sp, r7
 800cc4e:	bd80      	pop	{r7, pc}
 800cc50:	54435020 	.word	0x54435020
 800cc54:	24000078 	.word	0x24000078
 800cc58:	24031bc4 	.word	0x24031bc4
 800cc5c:	24031d0c 	.word	0x24031d0c
 800cc60:	0800c7a9 	.word	0x0800c7a9
 800cc64:	24031c5c 	.word	0x24031c5c

0800cc68 <_nx_tcp_enable>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
UINT  _nx_tcp_enable(NX_IP *ip_ptr)
{
 800cc68:	b580      	push	{r7, lr}
 800cc6a:	b084      	sub	sp, #16
 800cc6c:	af00      	add	r7, sp, #0
 800cc6e:	6078      	str	r0, [r7, #4]
    /* If trace is enabled, insert this event into the trace buffer.  */
    NX_TRACE_IN_LINE_INSERT(NX_TRACE_TCP_ENABLE, ip_ptr, 0, 0, 0, NX_TRACE_TCP_EVENTS, 0, 0);
    /* Place all server listen request structures on the available list.   */

    /* Setup a pointer to the first listen.  */
    listen_ptr =  &(ip_ptr -> nx_ip_tcp_server_listen_reqs[0]);
 800cc70:	687b      	ldr	r3, [r7, #4]
 800cc72:	f503 6396 	add.w	r3, r3, #1200	; 0x4b0
 800cc76:	60bb      	str	r3, [r7, #8]

    /* Setup the available listen requests head pointer.  */
    ip_ptr -> nx_ip_tcp_available_listen_requests =  listen_ptr;
 800cc78:	687b      	ldr	r3, [r7, #4]
 800cc7a:	68ba      	ldr	r2, [r7, #8]
 800cc7c:	f8c3 2618 	str.w	r2, [r3, #1560]	; 0x618

    /* Loop through the listen requests and link them on the available list.  */
    for (i = 0; i < NX_MAX_LISTEN_REQUESTS; i++)
 800cc80:	2300      	movs	r3, #0
 800cc82:	60fb      	str	r3, [r7, #12]
 800cc84:	e00d      	b.n	800cca2 <_nx_tcp_enable+0x3a>
    {

        /* Link listen request to next listen request.  */
        listen_ptr -> nx_tcp_listen_next =  listen_ptr + 1;
 800cc86:	68bb      	ldr	r3, [r7, #8]
 800cc88:	f103 0224 	add.w	r2, r3, #36	; 0x24
 800cc8c:	68bb      	ldr	r3, [r7, #8]
 800cc8e:	61da      	str	r2, [r3, #28]

        /* Determine if we need to move to the next listen request.  */
        if (i < (NX_MAX_LISTEN_REQUESTS - 1))
 800cc90:	68fb      	ldr	r3, [r7, #12]
 800cc92:	2b08      	cmp	r3, #8
 800cc94:	d802      	bhi.n	800cc9c <_nx_tcp_enable+0x34>
        {
            listen_ptr++;
 800cc96:	68bb      	ldr	r3, [r7, #8]
 800cc98:	3324      	adds	r3, #36	; 0x24
 800cc9a:	60bb      	str	r3, [r7, #8]
    for (i = 0; i < NX_MAX_LISTEN_REQUESTS; i++)
 800cc9c:	68fb      	ldr	r3, [r7, #12]
 800cc9e:	3301      	adds	r3, #1
 800cca0:	60fb      	str	r3, [r7, #12]
 800cca2:	68fb      	ldr	r3, [r7, #12]
 800cca4:	2b09      	cmp	r3, #9
 800cca6:	d9ee      	bls.n	800cc86 <_nx_tcp_enable+0x1e>
        }
    }

    /* Make sure the last listen request has a NULL pointer.  */
    listen_ptr -> nx_tcp_listen_next =  NX_NULL;
 800cca8:	68bb      	ldr	r3, [r7, #8]
 800ccaa:	2200      	movs	r2, #0
 800ccac:	61da      	str	r2, [r3, #28]

    /* Set the TCP packet queue processing function.  */
    ip_ptr -> nx_ip_tcp_queue_process =  _nx_tcp_queue_process;
 800ccae:	687b      	ldr	r3, [r7, #4]
 800ccb0:	4a13      	ldr	r2, [pc, #76]	; (800cd00 <_nx_tcp_enable+0x98>)
 800ccb2:	f8c3 24a0 	str.w	r2, [r3, #1184]	; 0x4a0

    /* Set the TCP periodic processing function.  */
    ip_ptr -> nx_ip_tcp_periodic_processing =  _nx_tcp_periodic_processing;
 800ccb6:	687b      	ldr	r3, [r7, #4]
 800ccb8:	4a12      	ldr	r2, [pc, #72]	; (800cd04 <_nx_tcp_enable+0x9c>)
 800ccba:	f8c3 2498 	str.w	r2, [r3, #1176]	; 0x498

    /* Set the TCP fast periodic processing function.  */
    ip_ptr -> nx_ip_tcp_fast_periodic_processing =  _nx_tcp_fast_periodic_processing;
 800ccbe:	687b      	ldr	r3, [r7, #4]
 800ccc0:	4a11      	ldr	r2, [pc, #68]	; (800cd08 <_nx_tcp_enable+0xa0>)
 800ccc2:	f8c3 249c 	str.w	r2, [r3, #1180]	; 0x49c

    /* Set the TCP deferred cleanup check function.  */
    ip_ptr -> nx_tcp_deferred_cleanup_check =  _nx_tcp_deferred_cleanup_check;
 800ccc6:	687b      	ldr	r3, [r7, #4]
 800ccc8:	4a10      	ldr	r2, [pc, #64]	; (800cd0c <_nx_tcp_enable+0xa4>)
 800ccca:	f8c3 271c 	str.w	r2, [r3, #1820]	; 0x71c

    /* Setup base timer variables.  */
    _nx_tcp_fast_timer_rate =       (NX_IP_PERIODIC_RATE + (NX_TCP_FAST_TIMER_RATE - 1)) / NX_TCP_FAST_TIMER_RATE;
 800ccce:	4b10      	ldr	r3, [pc, #64]	; (800cd10 <_nx_tcp_enable+0xa8>)
 800ccd0:	220a      	movs	r2, #10
 800ccd2:	601a      	str	r2, [r3, #0]
    _nx_tcp_ack_timer_rate =        (NX_IP_PERIODIC_RATE + (NX_TCP_ACK_TIMER_RATE - 1)) / NX_TCP_ACK_TIMER_RATE;
 800ccd4:	4b0f      	ldr	r3, [pc, #60]	; (800cd14 <_nx_tcp_enable+0xac>)
 800ccd6:	2214      	movs	r2, #20
 800ccd8:	601a      	str	r2, [r3, #0]

    /*lint -e{778} suppress constant expression, since NX_TCP_TRANSMIT_TIMER_RATE can be redefined. */
    /*lint -e{835} -e{845} suppress operating on zero. */
    _nx_tcp_transmit_timer_rate =   (NX_IP_PERIODIC_RATE + (NX_TCP_TRANSMIT_TIMER_RATE - 1)) / NX_TCP_TRANSMIT_TIMER_RATE;
 800ccda:	4b0f      	ldr	r3, [pc, #60]	; (800cd18 <_nx_tcp_enable+0xb0>)
 800ccdc:	2264      	movs	r2, #100	; 0x64
 800ccde:	601a      	str	r2, [r3, #0]

    _nx_tcp_2MSL_timer_rate = 2 * NX_IP_PERIODIC_RATE * NX_TCP_MAXIMUM_SEGMENT_LIFETIME;
 800cce0:	4b0e      	ldr	r3, [pc, #56]	; (800cd1c <_nx_tcp_enable+0xb4>)
 800cce2:	f645 52c0 	movw	r2, #24000	; 0x5dc0
 800cce6:	601a      	str	r2, [r3, #0]

    _nx_ip_fast_periodic_timer_create(ip_ptr);
 800cce8:	6878      	ldr	r0, [r7, #4]
 800ccea:	f7fd fcf7 	bl	800a6dc <_nx_ip_fast_periodic_timer_create>

    /* Set the TCP packet receive function in the IP structure to indicate
       we are ready to receive TCP packets.  */
    ip_ptr -> nx_ip_tcp_packet_receive =  _nx_tcp_packet_receive;
 800ccee:	687b      	ldr	r3, [r7, #4]
 800ccf0:	4a0b      	ldr	r2, [pc, #44]	; (800cd20 <_nx_tcp_enable+0xb8>)
 800ccf2:	f8c3 2494 	str.w	r2, [r3, #1172]	; 0x494

    /* Return successful completion.  */
    return(NX_SUCCESS);
 800ccf6:	2300      	movs	r3, #0
}
 800ccf8:	4618      	mov	r0, r3
 800ccfa:	3710      	adds	r7, #16
 800ccfc:	46bd      	mov	sp, r7
 800ccfe:	bd80      	pop	{r7, pc}
 800cd00:	0800dd45 	.word	0x0800dd45
 800cd04:	0800dd31 	.word	0x0800dd31
 800cd08:	0800cd25 	.word	0x0800cd25
 800cd0c:	0800ca39 	.word	0x0800ca39
 800cd10:	24000b2c 	.word	0x24000b2c
 800cd14:	24000b30 	.word	0x24000b30
 800cd18:	24000b34 	.word	0x24000b34
 800cd1c:	24000b38 	.word	0x24000b38
 800cd20:	0800d855 	.word	0x0800d855

0800cd24 <_nx_tcp_fast_periodic_processing>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
VOID  _nx_tcp_fast_periodic_processing(NX_IP *ip_ptr)
{
 800cd24:	b580      	push	{r7, lr}
 800cd26:	b086      	sub	sp, #24
 800cd28:	af00      	add	r7, sp, #0
 800cd2a:	6078      	str	r0, [r7, #4]
ULONG          sockets;
ULONG          timer_rate;


    /* Pickup this timer's periodic rate.  */
    timer_rate =  _nx_tcp_fast_timer_rate;
 800cd2c:	4b73      	ldr	r3, [pc, #460]	; (800cefc <_nx_tcp_fast_periodic_processing+0x1d8>)
 800cd2e:	681b      	ldr	r3, [r3, #0]
 800cd30:	60fb      	str	r3, [r7, #12]

    /* Pickup the number of created TCP sockets.  */
    sockets =  ip_ptr -> nx_ip_tcp_created_sockets_count;
 800cd32:	687b      	ldr	r3, [r7, #4]
 800cd34:	f8d3 3490 	ldr.w	r3, [r3, #1168]	; 0x490
 800cd38:	613b      	str	r3, [r7, #16]

    /* Pickup the first socket.  */
    socket_ptr =  ip_ptr -> nx_ip_tcp_created_sockets_ptr;
 800cd3a:	687b      	ldr	r3, [r7, #4]
 800cd3c:	f8d3 348c 	ldr.w	r3, [r3, #1164]	; 0x48c
 800cd40:	617b      	str	r3, [r7, #20]

    /* Loop through the created sockets.  */
    while (sockets--)
 800cd42:	e0cf      	b.n	800cee4 <_nx_tcp_fast_periodic_processing+0x1c0>
    {

        /* Determine if the socket is in an established or disconnect state and has delayed sending an ACK
           from a previous receive packet event.  */
        if ((socket_ptr -> nx_tcp_socket_state >= NX_TCP_ESTABLISHED) &&
 800cd44:	697b      	ldr	r3, [r7, #20]
 800cd46:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 800cd48:	2b04      	cmp	r3, #4
 800cd4a:	d91d      	bls.n	800cd88 <_nx_tcp_fast_periodic_processing+0x64>
            ((socket_ptr -> nx_tcp_socket_rx_sequence != socket_ptr -> nx_tcp_socket_rx_sequence_acked) ||
 800cd4c:	697b      	ldr	r3, [r7, #20]
 800cd4e:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 800cd50:	697b      	ldr	r3, [r7, #20]
 800cd52:	6c5b      	ldr	r3, [r3, #68]	; 0x44
        if ((socket_ptr -> nx_tcp_socket_state >= NX_TCP_ESTABLISHED) &&
 800cd54:	429a      	cmp	r2, r3
 800cd56:	d105      	bne.n	800cd64 <_nx_tcp_fast_periodic_processing+0x40>
             (socket_ptr -> nx_tcp_socket_rx_window_last_sent < socket_ptr -> nx_tcp_socket_rx_window_current)))
 800cd58:	697b      	ldr	r3, [r7, #20]
 800cd5a:	6f9a      	ldr	r2, [r3, #120]	; 0x78
 800cd5c:	697b      	ldr	r3, [r7, #20]
 800cd5e:	6f5b      	ldr	r3, [r3, #116]	; 0x74
            ((socket_ptr -> nx_tcp_socket_rx_sequence != socket_ptr -> nx_tcp_socket_rx_sequence_acked) ||
 800cd60:	429a      	cmp	r2, r3
 800cd62:	d211      	bcs.n	800cd88 <_nx_tcp_fast_periodic_processing+0x64>
        {

            /* Determine if the ACK has expired.  */
            if (socket_ptr -> nx_tcp_socket_delayed_ack_timeout <= timer_rate)
 800cd64:	697b      	ldr	r3, [r7, #20]
 800cd66:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 800cd68:	68fa      	ldr	r2, [r7, #12]
 800cd6a:	429a      	cmp	r2, r3
 800cd6c:	d306      	bcc.n	800cd7c <_nx_tcp_fast_periodic_processing+0x58>
            {

                /* Send the delayed ACK, which also resets the ACK timeout.  */
                _nx_tcp_packet_send_ack(socket_ptr, socket_ptr -> nx_tcp_socket_tx_sequence);
 800cd6e:	697b      	ldr	r3, [r7, #20]
 800cd70:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 800cd72:	4619      	mov	r1, r3
 800cd74:	6978      	ldr	r0, [r7, #20]
 800cd76:	f000 fddb 	bl	800d930 <_nx_tcp_packet_send_ack>
 800cd7a:	e005      	b.n	800cd88 <_nx_tcp_fast_periodic_processing+0x64>
            }
            else
            {

                /* No, it hasn't expired yet.  Just decrement it for now.  */
                socket_ptr -> nx_tcp_socket_delayed_ack_timeout -= timer_rate;
 800cd7c:	697b      	ldr	r3, [r7, #20]
 800cd7e:	6c9a      	ldr	r2, [r3, #72]	; 0x48
 800cd80:	68fb      	ldr	r3, [r7, #12]
 800cd82:	1ad2      	subs	r2, r2, r3
 800cd84:	697b      	ldr	r3, [r7, #20]
 800cd86:	649a      	str	r2, [r3, #72]	; 0x48
            }
        }

        /* Determine if a timeout is active.  */
        if (socket_ptr -> nx_tcp_socket_timeout)
 800cd88:	697b      	ldr	r3, [r7, #20]
 800cd8a:	f8d3 30cc 	ldr.w	r3, [r3, #204]	; 0xcc
 800cd8e:	2b00      	cmp	r3, #0
 800cd90:	f000 80a4 	beq.w	800cedc <_nx_tcp_fast_periodic_processing+0x1b8>
        {

            /* Yes, a timeout is active.  Determine if it has expired.  */
            if (socket_ptr -> nx_tcp_socket_timeout > timer_rate)
 800cd94:	697b      	ldr	r3, [r7, #20]
 800cd96:	f8d3 30cc 	ldr.w	r3, [r3, #204]	; 0xcc
 800cd9a:	68fa      	ldr	r2, [r7, #12]
 800cd9c:	429a      	cmp	r2, r3
 800cd9e:	d208      	bcs.n	800cdb2 <_nx_tcp_fast_periodic_processing+0x8e>
            {

                /* No, it hasn't expired yet.  Just decrement the timeout value.  */
                socket_ptr -> nx_tcp_socket_timeout -= timer_rate;
 800cda0:	697b      	ldr	r3, [r7, #20]
 800cda2:	f8d3 20cc 	ldr.w	r2, [r3, #204]	; 0xcc
 800cda6:	68fb      	ldr	r3, [r7, #12]
 800cda8:	1ad2      	subs	r2, r2, r3
 800cdaa:	697b      	ldr	r3, [r7, #20]
 800cdac:	f8c3 20cc 	str.w	r2, [r3, #204]	; 0xcc
 800cdb0:	e094      	b.n	800cedc <_nx_tcp_fast_periodic_processing+0x1b8>
            }
            else if (((socket_ptr -> nx_tcp_socket_timeout_retries >= socket_ptr -> nx_tcp_socket_timeout_max_retries) &&
 800cdb2:	697b      	ldr	r3, [r7, #20]
 800cdb4:	f8d3 20d4 	ldr.w	r2, [r3, #212]	; 0xd4
 800cdb8:	697b      	ldr	r3, [r7, #20]
 800cdba:	f8d3 30d8 	ldr.w	r3, [r3, #216]	; 0xd8
 800cdbe:	429a      	cmp	r2, r3
 800cdc0:	d304      	bcc.n	800cdcc <_nx_tcp_fast_periodic_processing+0xa8>
                      (socket_ptr -> nx_tcp_socket_zero_window_probe_has_data == NX_FALSE)) ||
 800cdc2:	697b      	ldr	r3, [r7, #20]
 800cdc4:	f893 309c 	ldrb.w	r3, [r3, #156]	; 0x9c
            else if (((socket_ptr -> nx_tcp_socket_timeout_retries >= socket_ptr -> nx_tcp_socket_timeout_max_retries) &&
 800cdc8:	2b00      	cmp	r3, #0
 800cdca:	d00c      	beq.n	800cde6 <_nx_tcp_fast_periodic_processing+0xc2>
                     ((socket_ptr -> nx_tcp_socket_zero_window_probe_failure >= socket_ptr -> nx_tcp_socket_timeout_max_retries) &&
 800cdcc:	697b      	ldr	r3, [r7, #20]
 800cdce:	f8d3 2094 	ldr.w	r2, [r3, #148]	; 0x94
 800cdd2:	697b      	ldr	r3, [r7, #20]
 800cdd4:	f8d3 30d8 	ldr.w	r3, [r3, #216]	; 0xd8
                      (socket_ptr -> nx_tcp_socket_zero_window_probe_has_data == NX_FALSE)) ||
 800cdd8:	429a      	cmp	r2, r3
 800cdda:	d308      	bcc.n	800cdee <_nx_tcp_fast_periodic_processing+0xca>
                      (socket_ptr -> nx_tcp_socket_zero_window_probe_has_data == NX_TRUE))
 800cddc:	697b      	ldr	r3, [r7, #20]
 800cdde:	f893 309c 	ldrb.w	r3, [r3, #156]	; 0x9c
                     ((socket_ptr -> nx_tcp_socket_zero_window_probe_failure >= socket_ptr -> nx_tcp_socket_timeout_max_retries) &&
 800cde2:	2b01      	cmp	r3, #1
 800cde4:	d103      	bne.n	800cdee <_nx_tcp_fast_periodic_processing+0xca>
            {

                /* Number of retries has been exceeded.  */

                /* Close the socket via a connection reset.  */
                _nx_tcp_socket_connection_reset(socket_ptr);
 800cde6:	6978      	ldr	r0, [r7, #20]
 800cde8:	f001 f8b9 	bl	800df5e <_nx_tcp_socket_connection_reset>
 800cdec:	e076      	b.n	800cedc <_nx_tcp_fast_periodic_processing+0x1b8>
            }
            /* YUXIN MODIFIED HERE */
            else if ((socket_ptr -> nx_tcp_socket_state == NX_TCP_SYN_SENT) ||
 800cdee:	697b      	ldr	r3, [r7, #20]
 800cdf0:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 800cdf2:	2b03      	cmp	r3, #3
 800cdf4:	d003      	beq.n	800cdfe <_nx_tcp_fast_periodic_processing+0xda>
                     (socket_ptr -> nx_tcp_socket_state == NX_TCP_SYN_RECEIVED))
 800cdf6:	697b      	ldr	r3, [r7, #20]
 800cdf8:	6b9b      	ldr	r3, [r3, #56]	; 0x38
            else if ((socket_ptr -> nx_tcp_socket_state == NX_TCP_SYN_SENT) ||
 800cdfa:	2b04      	cmp	r3, #4
 800cdfc:	d11d      	bne.n	800ce3a <_nx_tcp_fast_periodic_processing+0x116>
            {

                /* Yes, the timeout on the SYN message has expired.  */

                /* Increment the retry counter.  */
                socket_ptr -> nx_tcp_socket_timeout_retries++;
 800cdfe:	697b      	ldr	r3, [r7, #20]
 800ce00:	f8d3 30d4 	ldr.w	r3, [r3, #212]	; 0xd4
 800ce04:	1c5a      	adds	r2, r3, #1
 800ce06:	697b      	ldr	r3, [r7, #20]
 800ce08:	f8c3 20d4 	str.w	r2, [r3, #212]	; 0xd4

                /* Setup the next timeout.  */
                socket_ptr -> nx_tcp_socket_timeout = socket_ptr -> nx_tcp_socket_timeout_rate <<
 800ce0c:	697b      	ldr	r3, [r7, #20]
 800ce0e:	f8d3 20d0 	ldr.w	r2, [r3, #208]	; 0xd0
                    (socket_ptr -> nx_tcp_socket_timeout_retries * socket_ptr -> nx_tcp_socket_timeout_shift);
 800ce12:	697b      	ldr	r3, [r7, #20]
 800ce14:	f8d3 30d4 	ldr.w	r3, [r3, #212]	; 0xd4
 800ce18:	6979      	ldr	r1, [r7, #20]
 800ce1a:	f8d1 10dc 	ldr.w	r1, [r1, #220]	; 0xdc
 800ce1e:	fb01 f303 	mul.w	r3, r1, r3
                socket_ptr -> nx_tcp_socket_timeout = socket_ptr -> nx_tcp_socket_timeout_rate <<
 800ce22:	409a      	lsls	r2, r3
 800ce24:	697b      	ldr	r3, [r7, #20]
 800ce26:	f8c3 20cc 	str.w	r2, [r3, #204]	; 0xcc

                /* Send the initial SYN message again.  Adjust the sequence number before and
                   after to ensure the same sequence as the initial SYN.  */
                _nx_tcp_packet_send_syn(socket_ptr, (socket_ptr -> nx_tcp_socket_tx_sequence - 1));
 800ce2a:	697b      	ldr	r3, [r7, #20]
 800ce2c:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 800ce2e:	3b01      	subs	r3, #1
 800ce30:	4619      	mov	r1, r3
 800ce32:	6978      	ldr	r0, [r7, #20]
 800ce34:	f000 ff0c 	bl	800dc50 <_nx_tcp_packet_send_syn>
 800ce38:	e050      	b.n	800cedc <_nx_tcp_fast_periodic_processing+0x1b8>
            }
            /* Has the TCP timeout for transmit packet or probing zero window expired?  */
            else if (socket_ptr -> nx_tcp_socket_transmit_sent_head ||
 800ce3a:	697b      	ldr	r3, [r7, #20]
 800ce3c:	f8d3 30c4 	ldr.w	r3, [r3, #196]	; 0xc4
 800ce40:	2b00      	cmp	r3, #0
 800ce42:	d107      	bne.n	800ce54 <_nx_tcp_fast_periodic_processing+0x130>
                     ((socket_ptr -> nx_tcp_socket_tx_window_advertised == 0) &&
 800ce44:	697b      	ldr	r3, [r7, #20]
 800ce46:	6d5b      	ldr	r3, [r3, #84]	; 0x54
            else if (socket_ptr -> nx_tcp_socket_transmit_sent_head ||
 800ce48:	2b00      	cmp	r3, #0
 800ce4a:	d116      	bne.n	800ce7a <_nx_tcp_fast_periodic_processing+0x156>
                      (socket_ptr -> nx_tcp_socket_state <= NX_TCP_CLOSE_WAIT)))
 800ce4c:	697b      	ldr	r3, [r7, #20]
 800ce4e:	6b9b      	ldr	r3, [r3, #56]	; 0x38
                     ((socket_ptr -> nx_tcp_socket_tx_window_advertised == 0) &&
 800ce50:	2b06      	cmp	r3, #6
 800ce52:	d812      	bhi.n	800ce7a <_nx_tcp_fast_periodic_processing+0x156>
            {

                /* Update the transmit sequence that entered fast transmit. */
                socket_ptr -> nx_tcp_socket_tx_sequence_recover = socket_ptr -> nx_tcp_socket_tx_sequence - 1;
 800ce54:	697b      	ldr	r3, [r7, #20]
 800ce56:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 800ce58:	1e5a      	subs	r2, r3, #1
 800ce5a:	697b      	ldr	r3, [r7, #20]
 800ce5c:	661a      	str	r2, [r3, #96]	; 0x60

                /* Retransmit the packet. */
                _nx_tcp_socket_retransmit(ip_ptr, socket_ptr, NX_FALSE);
 800ce5e:	2200      	movs	r2, #0
 800ce60:	6979      	ldr	r1, [r7, #20]
 800ce62:	6878      	ldr	r0, [r7, #4]
 800ce64:	f001 fa9e 	bl	800e3a4 <_nx_tcp_socket_retransmit>

                /* Exit fast recovery procedure. */
                socket_ptr -> nx_tcp_socket_fast_recovery = NX_FALSE;
 800ce68:	697b      	ldr	r3, [r7, #20]
 800ce6a:	2200      	movs	r2, #0
 800ce6c:	f883 209e 	strb.w	r2, [r3, #158]	; 0x9e
                socket_ptr -> nx_tcp_socket_tx_window_congestion = socket_ptr -> nx_tcp_socket_tx_slow_start_threshold;
 800ce70:	697b      	ldr	r3, [r7, #20]
 800ce72:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 800ce74:	697b      	ldr	r3, [r7, #20]
 800ce76:	659a      	str	r2, [r3, #88]	; 0x58
 800ce78:	e030      	b.n	800cedc <_nx_tcp_fast_periodic_processing+0x1b8>
            }
            else if ((socket_ptr -> nx_tcp_socket_state == NX_TCP_FIN_WAIT_1) ||
 800ce7a:	697b      	ldr	r3, [r7, #20]
 800ce7c:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 800ce7e:	2b07      	cmp	r3, #7
 800ce80:	d007      	beq.n	800ce92 <_nx_tcp_fast_periodic_processing+0x16e>
                     (socket_ptr -> nx_tcp_socket_state == NX_TCP_CLOSING)    ||
 800ce82:	697b      	ldr	r3, [r7, #20]
 800ce84:	6b9b      	ldr	r3, [r3, #56]	; 0x38
            else if ((socket_ptr -> nx_tcp_socket_state == NX_TCP_FIN_WAIT_1) ||
 800ce86:	2b09      	cmp	r3, #9
 800ce88:	d003      	beq.n	800ce92 <_nx_tcp_fast_periodic_processing+0x16e>
                     (socket_ptr -> nx_tcp_socket_state == NX_TCP_LAST_ACK))
 800ce8a:	697b      	ldr	r3, [r7, #20]
 800ce8c:	6b9b      	ldr	r3, [r3, #56]	; 0x38
                     (socket_ptr -> nx_tcp_socket_state == NX_TCP_CLOSING)    ||
 800ce8e:	2b0b      	cmp	r3, #11
 800ce90:	d11d      	bne.n	800cece <_nx_tcp_fast_periodic_processing+0x1aa>

                /* We have a timeout condition on sending the FIN... so it needs to be
                   retried.  */

                /* Increment the retry counter.  */
                socket_ptr -> nx_tcp_socket_timeout_retries++;
 800ce92:	697b      	ldr	r3, [r7, #20]
 800ce94:	f8d3 30d4 	ldr.w	r3, [r3, #212]	; 0xd4
 800ce98:	1c5a      	adds	r2, r3, #1
 800ce9a:	697b      	ldr	r3, [r7, #20]
 800ce9c:	f8c3 20d4 	str.w	r2, [r3, #212]	; 0xd4

                /* Setup the next timeout.  */
                socket_ptr -> nx_tcp_socket_timeout = socket_ptr -> nx_tcp_socket_timeout_rate <<
 800cea0:	697b      	ldr	r3, [r7, #20]
 800cea2:	f8d3 20d0 	ldr.w	r2, [r3, #208]	; 0xd0
                    (socket_ptr -> nx_tcp_socket_timeout_retries * socket_ptr -> nx_tcp_socket_timeout_shift);
 800cea6:	697b      	ldr	r3, [r7, #20]
 800cea8:	f8d3 30d4 	ldr.w	r3, [r3, #212]	; 0xd4
 800ceac:	6979      	ldr	r1, [r7, #20]
 800ceae:	f8d1 10dc 	ldr.w	r1, [r1, #220]	; 0xdc
 800ceb2:	fb01 f303 	mul.w	r3, r1, r3
                socket_ptr -> nx_tcp_socket_timeout = socket_ptr -> nx_tcp_socket_timeout_rate <<
 800ceb6:	409a      	lsls	r2, r3
 800ceb8:	697b      	ldr	r3, [r7, #20]
 800ceba:	f8c3 20cc 	str.w	r2, [r3, #204]	; 0xcc

                /* Send another FIN packet.  */
                _nx_tcp_packet_send_fin(socket_ptr, (socket_ptr -> nx_tcp_socket_tx_sequence - 1));
 800cebe:	697b      	ldr	r3, [r7, #20]
 800cec0:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 800cec2:	3b01      	subs	r3, #1
 800cec4:	4619      	mov	r1, r3
 800cec6:	6978      	ldr	r0, [r7, #20]
 800cec8:	f000 fe56 	bl	800db78 <_nx_tcp_packet_send_fin>
 800cecc:	e006      	b.n	800cedc <_nx_tcp_fast_periodic_processing+0x1b8>
            }
            else if (socket_ptr -> nx_tcp_socket_state == NX_TCP_TIMED_WAIT)
 800cece:	697b      	ldr	r3, [r7, #20]
 800ced0:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 800ced2:	2b0a      	cmp	r3, #10
 800ced4:	d102      	bne.n	800cedc <_nx_tcp_fast_periodic_processing+0x1b8>
            {

                /* Clean the transmission control block.  */
                _nx_tcp_socket_block_cleanup(socket_ptr);
 800ced6:	6978      	ldr	r0, [r7, #20]
 800ced8:	f001 f814 	bl	800df04 <_nx_tcp_socket_block_cleanup>
            }
        }

        /* Move to the next TCP socket.  */
        socket_ptr =  socket_ptr -> nx_tcp_socket_created_next;
 800cedc:	697b      	ldr	r3, [r7, #20]
 800cede:	f8d3 310c 	ldr.w	r3, [r3, #268]	; 0x10c
 800cee2:	617b      	str	r3, [r7, #20]
    while (sockets--)
 800cee4:	693b      	ldr	r3, [r7, #16]
 800cee6:	1e5a      	subs	r2, r3, #1
 800cee8:	613a      	str	r2, [r7, #16]
 800ceea:	2b00      	cmp	r3, #0
 800ceec:	f47f af2a 	bne.w	800cd44 <_nx_tcp_fast_periodic_processing+0x20>
    }
}
 800cef0:	bf00      	nop
 800cef2:	bf00      	nop
 800cef4:	3718      	adds	r7, #24
 800cef6:	46bd      	mov	sp, r7
 800cef8:	bd80      	pop	{r7, pc}
 800cefa:	bf00      	nop
 800cefc:	24000b2c 	.word	0x24000b2c

0800cf00 <_nx_tcp_initialize>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
VOID  _nx_tcp_initialize(VOID)
{
 800cf00:	b480      	push	{r7}
 800cf02:	af00      	add	r7, sp, #0
}
 800cf04:	bf00      	nop
 800cf06:	46bd      	mov	sp, r7
 800cf08:	f85d 7b04 	ldr.w	r7, [sp], #4
 800cf0c:	4770      	bx	lr

0800cf0e <_nx_tcp_mss_option_get>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
UINT  _nx_tcp_mss_option_get(UCHAR *option_ptr, ULONG option_area_size, ULONG *mss)
{
 800cf0e:	b480      	push	{r7}
 800cf10:	b087      	sub	sp, #28
 800cf12:	af00      	add	r7, sp, #0
 800cf14:	60f8      	str	r0, [r7, #12]
 800cf16:	60b9      	str	r1, [r7, #8]
 800cf18:	607a      	str	r2, [r7, #4]

ULONG option_length;

    /* Initialize the value.  */
    *mss = 0;
 800cf1a:	687b      	ldr	r3, [r7, #4]
 800cf1c:	2200      	movs	r2, #0
 800cf1e:	601a      	str	r2, [r3, #0]

    /* Loop through the option area looking for the MSS.  */
    while (option_area_size >= 4)
 800cf20:	e043      	b.n	800cfaa <_nx_tcp_mss_option_get+0x9c>
    {

        /* Is the current character the MSS type?  */
        if (*option_ptr == NX_TCP_MSS_KIND)
 800cf22:	68fb      	ldr	r3, [r7, #12]
 800cf24:	781b      	ldrb	r3, [r3, #0]
 800cf26:	2b02      	cmp	r3, #2
 800cf28:	d11a      	bne.n	800cf60 <_nx_tcp_mss_option_get+0x52>
        {

            /* Yes, we found it!  */

            /* Move the pointer forward by one.  */
            option_ptr++;
 800cf2a:	68fb      	ldr	r3, [r7, #12]
 800cf2c:	3301      	adds	r3, #1
 800cf2e:	60fb      	str	r3, [r7, #12]

            /* Check the option length, if option length is not equal to 4, return NX_FALSE.  */
            if (*option_ptr++ != 4)
 800cf30:	68fb      	ldr	r3, [r7, #12]
 800cf32:	1c5a      	adds	r2, r3, #1
 800cf34:	60fa      	str	r2, [r7, #12]
 800cf36:	781b      	ldrb	r3, [r3, #0]
 800cf38:	2b04      	cmp	r3, #4
 800cf3a:	d001      	beq.n	800cf40 <_nx_tcp_mss_option_get+0x32>
            {
                return(NX_FALSE);
 800cf3c:	2300      	movs	r3, #0
 800cf3e:	e03a      	b.n	800cfb6 <_nx_tcp_mss_option_get+0xa8>
            }

            /* Build the mss size.  */
            *mss = (ULONG)*option_ptr++;
 800cf40:	68fb      	ldr	r3, [r7, #12]
 800cf42:	1c5a      	adds	r2, r3, #1
 800cf44:	60fa      	str	r2, [r7, #12]
 800cf46:	781b      	ldrb	r3, [r3, #0]
 800cf48:	461a      	mov	r2, r3
 800cf4a:	687b      	ldr	r3, [r7, #4]
 800cf4c:	601a      	str	r2, [r3, #0]

            /* Get the LSB of the MSS.  */
            *mss = (*mss << 8) | (ULONG)*option_ptr;
 800cf4e:	687b      	ldr	r3, [r7, #4]
 800cf50:	681b      	ldr	r3, [r3, #0]
 800cf52:	021b      	lsls	r3, r3, #8
 800cf54:	68fa      	ldr	r2, [r7, #12]
 800cf56:	7812      	ldrb	r2, [r2, #0]
 800cf58:	431a      	orrs	r2, r3
 800cf5a:	687b      	ldr	r3, [r7, #4]
 800cf5c:	601a      	str	r2, [r3, #0]

            /* Finished, get out of the loop!  */
            break;
 800cf5e:	e029      	b.n	800cfb4 <_nx_tcp_mss_option_get+0xa6>
        }

        /* Otherwise, process relative to the option type.  */

        /* Check for end of list.  */
        if (*option_ptr == NX_TCP_EOL_KIND)
 800cf60:	68fb      	ldr	r3, [r7, #12]
 800cf62:	781b      	ldrb	r3, [r3, #0]
 800cf64:	2b00      	cmp	r3, #0
 800cf66:	d024      	beq.n	800cfb2 <_nx_tcp_mss_option_get+0xa4>
            /* Yes, end of list, get out!  */
            break;
        }

        /* Check for NOP.  */
        if (*option_ptr++ == NX_TCP_NOP_KIND)
 800cf68:	68fb      	ldr	r3, [r7, #12]
 800cf6a:	1c5a      	adds	r2, r3, #1
 800cf6c:	60fa      	str	r2, [r7, #12]
 800cf6e:	781b      	ldrb	r3, [r3, #0]
 800cf70:	2b01      	cmp	r3, #1
 800cf72:	d103      	bne.n	800cf7c <_nx_tcp_mss_option_get+0x6e>
        {

            /* One character option!  */
            option_area_size--;
 800cf74:	68bb      	ldr	r3, [r7, #8]
 800cf76:	3b01      	subs	r3, #1
 800cf78:	60bb      	str	r3, [r7, #8]
 800cf7a:	e016      	b.n	800cfaa <_nx_tcp_mss_option_get+0x9c>
        }
        else
        {

            /* Derive the option length.  */
            option_length =  ((ULONG)*option_ptr);
 800cf7c:	68fb      	ldr	r3, [r7, #12]
 800cf7e:	781b      	ldrb	r3, [r3, #0]
 800cf80:	617b      	str	r3, [r7, #20]

            /* Return when option length is invalid. */
            if (option_length == 0)
 800cf82:	697b      	ldr	r3, [r7, #20]
 800cf84:	2b00      	cmp	r3, #0
 800cf86:	d101      	bne.n	800cf8c <_nx_tcp_mss_option_get+0x7e>
            {
                return(NX_FALSE);
 800cf88:	2300      	movs	r3, #0
 800cf8a:	e014      	b.n	800cfb6 <_nx_tcp_mss_option_get+0xa8>
            }

            /* Move the option pointer forward.  */
            option_ptr =  option_ptr + (option_length - 1);
 800cf8c:	697b      	ldr	r3, [r7, #20]
 800cf8e:	3b01      	subs	r3, #1
 800cf90:	68fa      	ldr	r2, [r7, #12]
 800cf92:	4413      	add	r3, r2
 800cf94:	60fb      	str	r3, [r7, #12]

            /* Determine if this is greater than the option area size.  */
            if (option_length > option_area_size)
 800cf96:	697a      	ldr	r2, [r7, #20]
 800cf98:	68bb      	ldr	r3, [r7, #8]
 800cf9a:	429a      	cmp	r2, r3
 800cf9c:	d901      	bls.n	800cfa2 <_nx_tcp_mss_option_get+0x94>
            {
                return(NX_FALSE);
 800cf9e:	2300      	movs	r3, #0
 800cfa0:	e009      	b.n	800cfb6 <_nx_tcp_mss_option_get+0xa8>
            }
            else
            {
                option_area_size =  option_area_size - option_length;
 800cfa2:	68ba      	ldr	r2, [r7, #8]
 800cfa4:	697b      	ldr	r3, [r7, #20]
 800cfa6:	1ad3      	subs	r3, r2, r3
 800cfa8:	60bb      	str	r3, [r7, #8]
    while (option_area_size >= 4)
 800cfaa:	68bb      	ldr	r3, [r7, #8]
 800cfac:	2b03      	cmp	r3, #3
 800cfae:	d8b8      	bhi.n	800cf22 <_nx_tcp_mss_option_get+0x14>
 800cfb0:	e000      	b.n	800cfb4 <_nx_tcp_mss_option_get+0xa6>
            break;
 800cfb2:	bf00      	nop
            }
        }
    }

    /* Return.  */
    return(NX_TRUE);
 800cfb4:	2301      	movs	r3, #1
}
 800cfb6:	4618      	mov	r0, r3
 800cfb8:	371c      	adds	r7, #28
 800cfba:	46bd      	mov	sp, r7
 800cfbc:	f85d 7b04 	ldr.w	r7, [sp], #4
 800cfc0:	4770      	bx	lr

0800cfc2 <_nx_tcp_no_connection_reset>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
VOID  _nx_tcp_no_connection_reset(NX_IP *ip_ptr, NX_PACKET *packet_ptr, NX_TCP_HEADER *tcp_header_ptr)
{
 800cfc2:	b590      	push	{r4, r7, lr}
 800cfc4:	b0d3      	sub	sp, #332	; 0x14c
 800cfc6:	af00      	add	r7, sp, #0
 800cfc8:	f507 73a4 	add.w	r3, r7, #328	; 0x148
 800cfcc:	f5a3 739e 	sub.w	r3, r3, #316	; 0x13c
 800cfd0:	6018      	str	r0, [r3, #0]
 800cfd2:	f507 73a4 	add.w	r3, r7, #328	; 0x148
 800cfd6:	f5a3 73a0 	sub.w	r3, r3, #320	; 0x140
 800cfda:	6019      	str	r1, [r3, #0]
 800cfdc:	f507 73a4 	add.w	r3, r7, #328	; 0x148
 800cfe0:	f5a3 73a2 	sub.w	r3, r3, #324	; 0x144
 800cfe4:	601a      	str	r2, [r3, #0]
ULONG         data_offset = 0;
#endif /* NX_IPSEC_ENABLE */


    /* Clear the fake socket first.  */
    memset((void *)&fake_socket, 0, sizeof(NX_TCP_SOCKET));
 800cfe6:	f107 0314 	add.w	r3, r7, #20
 800cfea:	f44f 7296 	mov.w	r2, #300	; 0x12c
 800cfee:	2100      	movs	r1, #0
 800cff0:	4618      	mov	r0, r3
 800cff2:	f012 fc43 	bl	801f87c <memset>

    /* Build a fake socket so we can send a reset TCP requests that are not valid.  */
    fake_socket.nx_tcp_socket_ip_ptr = ip_ptr;
 800cff6:	f507 73a4 	add.w	r3, r7, #328	; 0x148
 800cffa:	f5a3 739a 	sub.w	r3, r3, #308	; 0x134
 800cffe:	f507 72a4 	add.w	r2, r7, #328	; 0x148
 800d002:	f5a2 729e 	sub.w	r2, r2, #316	; 0x13c
 800d006:	6812      	ldr	r2, [r2, #0]
 800d008:	f8c3 20a0 	str.w	r2, [r3, #160]	; 0xa0

    /* Set the connection IP address.  */
#ifndef NX_DISABLE_IPV4
    if (packet_ptr -> nx_packet_ip_version == NX_IP_VERSION_V4)
 800d00c:	f507 73a4 	add.w	r3, r7, #328	; 0x148
 800d010:	f5a3 73a0 	sub.w	r3, r3, #320	; 0x140
 800d014:	681b      	ldr	r3, [r3, #0]
 800d016:	f893 302c 	ldrb.w	r3, [r3, #44]	; 0x2c
 800d01a:	2b04      	cmp	r3, #4
 800d01c:	d13b      	bne.n	800d096 <_nx_tcp_no_connection_reset+0xd4>
    {
    NX_IPV4_HEADER *ip_header_ptr;

        /* Set the IP header.  */
        /*lint -e{927} -e{826} suppress cast of pointer to pointer, since it is necessary  */
        ip_header_ptr =  (NX_IPV4_HEADER *)packet_ptr -> nx_packet_ip_header;
 800d01e:	f507 73a4 	add.w	r3, r7, #328	; 0x148
 800d022:	f5a3 73a0 	sub.w	r3, r3, #320	; 0x140
 800d026:	681b      	ldr	r3, [r3, #0]
 800d028:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 800d02a:	f8c7 3144 	str.w	r3, [r7, #324]	; 0x144

        /* Set the connection ip.  */
        fake_socket.nx_tcp_socket_connect_ip.nxd_ip_version = NX_IP_VERSION_V4;
 800d02e:	f507 73a4 	add.w	r3, r7, #328	; 0x148
 800d032:	f5a3 739a 	sub.w	r3, r3, #308	; 0x134
 800d036:	2204      	movs	r2, #4
 800d038:	615a      	str	r2, [r3, #20]
        fake_socket.nx_tcp_socket_connect_ip.nxd_ip_address.v4 = ip_header_ptr -> nx_ip_header_source_ip;
 800d03a:	f8d7 3144 	ldr.w	r3, [r7, #324]	; 0x144
 800d03e:	68da      	ldr	r2, [r3, #12]
 800d040:	f507 73a4 	add.w	r3, r7, #328	; 0x148
 800d044:	f5a3 739a 	sub.w	r3, r3, #308	; 0x134
 800d048:	619a      	str	r2, [r3, #24]

        /* Assume the interface that receives the incoming packet is the best interface
           for sending responses. */
        fake_socket.nx_tcp_socket_connect_interface = packet_ptr -> nx_packet_address.nx_packet_interface_ptr;
 800d04a:	f507 73a4 	add.w	r3, r7, #328	; 0x148
 800d04e:	f5a3 73a0 	sub.w	r3, r3, #320	; 0x140
 800d052:	681b      	ldr	r3, [r3, #0]
 800d054:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 800d056:	f507 73a4 	add.w	r3, r7, #328	; 0x148
 800d05a:	f5a3 739a 	sub.w	r3, r3, #308	; 0x134
 800d05e:	629a      	str	r2, [r3, #40]	; 0x28
        fake_socket.nx_tcp_socket_next_hop_address = NX_NULL;
 800d060:	f507 73a4 	add.w	r3, r7, #328	; 0x148
 800d064:	f5a3 739a 	sub.w	r3, r3, #308	; 0x134
 800d068:	2200      	movs	r2, #0
 800d06a:	62da      	str	r2, [r3, #44]	; 0x2c

        /* Find the next hop info. */
        _nx_ip_route_find(ip_ptr, fake_socket.nx_tcp_socket_connect_ip.nxd_ip_address.v4, &fake_socket.nx_tcp_socket_connect_interface,
 800d06c:	f507 73a4 	add.w	r3, r7, #328	; 0x148
 800d070:	f5a3 739a 	sub.w	r3, r3, #308	; 0x134
 800d074:	6999      	ldr	r1, [r3, #24]
 800d076:	f107 0314 	add.w	r3, r7, #20
 800d07a:	f103 042c 	add.w	r4, r3, #44	; 0x2c
 800d07e:	f107 0314 	add.w	r3, r7, #20
 800d082:	f103 0228 	add.w	r2, r3, #40	; 0x28
 800d086:	f507 73a4 	add.w	r3, r7, #328	; 0x148
 800d08a:	f5a3 709e 	sub.w	r0, r3, #316	; 0x13c
 800d08e:	4623      	mov	r3, r4
 800d090:	6800      	ldr	r0, [r0, #0]
 800d092:	f7fd febf 	bl	800ae14 <_nx_ip_route_find>
#endif /*NX_IPSEC_ENABLE*/
    }
#endif /* FEATURE_NX_IPV6 */

    /* Set the source port and destination port.  */
    fake_socket.nx_tcp_socket_port  = (UINT)(tcp_header_ptr -> nx_tcp_header_word_0 & NX_LOWER_16_MASK);
 800d096:	f507 73a4 	add.w	r3, r7, #328	; 0x148
 800d09a:	f5a3 73a2 	sub.w	r3, r3, #324	; 0x144
 800d09e:	681b      	ldr	r3, [r3, #0]
 800d0a0:	681b      	ldr	r3, [r3, #0]
 800d0a2:	b29a      	uxth	r2, r3
 800d0a4:	f507 73a4 	add.w	r3, r7, #328	; 0x148
 800d0a8:	f5a3 739a 	sub.w	r3, r3, #308	; 0x134
 800d0ac:	60da      	str	r2, [r3, #12]
    fake_socket.nx_tcp_socket_connect_port = (UINT)(tcp_header_ptr -> nx_tcp_header_word_0 >> NX_SHIFT_BY_16);
 800d0ae:	f507 73a4 	add.w	r3, r7, #328	; 0x148
 800d0b2:	f5a3 73a2 	sub.w	r3, r3, #324	; 0x144
 800d0b6:	681b      	ldr	r3, [r3, #0]
 800d0b8:	681b      	ldr	r3, [r3, #0]
 800d0ba:	0c1a      	lsrs	r2, r3, #16
 800d0bc:	f507 73a4 	add.w	r3, r7, #328	; 0x148
 800d0c0:	f5a3 739a 	sub.w	r3, r3, #308	; 0x134
 800d0c4:	61da      	str	r2, [r3, #28]

    /* Set the sequence number only if the incoming segment does not have the ACK flag, according to
       Section 3.4, "Reset Generation" on page 37, RFC793. */
    if (!(tcp_header_ptr -> nx_tcp_header_word_3 & NX_TCP_ACK_BIT))
 800d0c6:	f507 73a4 	add.w	r3, r7, #328	; 0x148
 800d0ca:	f5a3 73a2 	sub.w	r3, r3, #324	; 0x144
 800d0ce:	681b      	ldr	r3, [r3, #0]
 800d0d0:	68db      	ldr	r3, [r3, #12]
 800d0d2:	f403 1380 	and.w	r3, r3, #1048576	; 0x100000
 800d0d6:	2b00      	cmp	r3, #0
 800d0d8:	d136      	bne.n	800d148 <_nx_tcp_no_connection_reset+0x186>
    {
        /* Get the header length.  */
        header_length = (tcp_header_ptr -> nx_tcp_header_word_3 >> NX_TCP_HEADER_SHIFT) * (ULONG)sizeof(ULONG);
 800d0da:	f507 73a4 	add.w	r3, r7, #328	; 0x148
 800d0de:	f5a3 73a2 	sub.w	r3, r3, #324	; 0x144
 800d0e2:	681b      	ldr	r3, [r3, #0]
 800d0e4:	68db      	ldr	r3, [r3, #12]
 800d0e6:	0f1b      	lsrs	r3, r3, #28
 800d0e8:	009b      	lsls	r3, r3, #2
 800d0ea:	f8c7 3140 	str.w	r3, [r7, #320]	; 0x140

        /* Update sequence number to set the reset acknowledge number.  */
        tcp_header_ptr -> nx_tcp_sequence_number += (packet_ptr -> nx_packet_length - header_length);
 800d0ee:	f507 73a4 	add.w	r3, r7, #328	; 0x148
 800d0f2:	f5a3 73a2 	sub.w	r3, r3, #324	; 0x144
 800d0f6:	681b      	ldr	r3, [r3, #0]
 800d0f8:	685a      	ldr	r2, [r3, #4]
 800d0fa:	f507 73a4 	add.w	r3, r7, #328	; 0x148
 800d0fe:	f5a3 73a0 	sub.w	r3, r3, #320	; 0x140
 800d102:	681b      	ldr	r3, [r3, #0]
 800d104:	6a59      	ldr	r1, [r3, #36]	; 0x24
 800d106:	f8d7 3140 	ldr.w	r3, [r7, #320]	; 0x140
 800d10a:	1acb      	subs	r3, r1, r3
 800d10c:	441a      	add	r2, r3
 800d10e:	f507 73a4 	add.w	r3, r7, #328	; 0x148
 800d112:	f5a3 73a2 	sub.w	r3, r3, #324	; 0x144
 800d116:	681b      	ldr	r3, [r3, #0]
 800d118:	605a      	str	r2, [r3, #4]

        /* Check the SYN and FIN bits.  */
        if (tcp_header_ptr -> nx_tcp_header_word_3 & (NX_TCP_SYN_BIT | NX_TCP_FIN_BIT))
 800d11a:	f507 73a4 	add.w	r3, r7, #328	; 0x148
 800d11e:	f5a3 73a2 	sub.w	r3, r3, #324	; 0x144
 800d122:	681b      	ldr	r3, [r3, #0]
 800d124:	68db      	ldr	r3, [r3, #12]
 800d126:	f403 3340 	and.w	r3, r3, #196608	; 0x30000
 800d12a:	2b00      	cmp	r3, #0
 800d12c:	d00c      	beq.n	800d148 <_nx_tcp_no_connection_reset+0x186>
        {

            /* Update sequence number to set the reset acknowledge number.  */
            tcp_header_ptr -> nx_tcp_sequence_number++;
 800d12e:	f507 73a4 	add.w	r3, r7, #328	; 0x148
 800d132:	f5a3 73a2 	sub.w	r3, r3, #324	; 0x144
 800d136:	681b      	ldr	r3, [r3, #0]
 800d138:	685b      	ldr	r3, [r3, #4]
 800d13a:	1c5a      	adds	r2, r3, #1
 800d13c:	f507 73a4 	add.w	r3, r7, #328	; 0x148
 800d140:	f5a3 73a2 	sub.w	r3, r3, #324	; 0x144
 800d144:	681b      	ldr	r3, [r3, #0]
 800d146:	605a      	str	r2, [r3, #4]
            fake_socket.nx_tcp_socket_egress_sa_data_offset = 0;
        }
    }
#endif

    fake_socket.nx_tcp_socket_time_to_live = (UINT)NX_IP_TIME_TO_LIVE;
 800d148:	f507 73a4 	add.w	r3, r7, #328	; 0x148
 800d14c:	f5a3 739a 	sub.w	r3, r3, #308	; 0x134
 800d150:	2280      	movs	r2, #128	; 0x80
 800d152:	f8c3 20a8 	str.w	r2, [r3, #168]	; 0xa8

    /* Send a RST to indicate the connection was not available.  */
    _nx_tcp_packet_send_rst(&fake_socket, tcp_header_ptr);
 800d156:	f507 73a4 	add.w	r3, r7, #328	; 0x148
 800d15a:	f5a3 73a2 	sub.w	r3, r3, #324	; 0x144
 800d15e:	f107 0214 	add.w	r2, r7, #20
 800d162:	6819      	ldr	r1, [r3, #0]
 800d164:	4610      	mov	r0, r2
 800d166:	f000 fd3f 	bl	800dbe8 <_nx_tcp_packet_send_rst>
}
 800d16a:	bf00      	nop
 800d16c:	f507 77a6 	add.w	r7, r7, #332	; 0x14c
 800d170:	46bd      	mov	sp, r7
 800d172:	bd90      	pop	{r4, r7, pc}

0800d174 <_nx_tcp_packet_process>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
VOID  _nx_tcp_packet_process(NX_IP *ip_ptr, NX_PACKET *packet_ptr)
{
 800d174:	b580      	push	{r7, lr}
 800d176:	b09c      	sub	sp, #112	; 0x70
 800d178:	af02      	add	r7, sp, #8
 800d17a:	6078      	str	r0, [r7, #4]
 800d17c:	6039      	str	r1, [r7, #0]

UINT                         index;
UINT                         port;
ULONG                       *source_ip = NX_NULL;
 800d17e:	2300      	movs	r3, #0
 800d180:	667b      	str	r3, [r7, #100]	; 0x64
ULONG                       *dest_ip = NX_NULL;
 800d182:	2300      	movs	r3, #0
 800d184:	663b      	str	r3, [r7, #96]	; 0x60
NX_TCP_SOCKET               *socket_ptr;
NX_TCP_HEADER               *tcp_header_ptr;
struct NX_TCP_LISTEN_STRUCT *listen_ptr;
VOID                         (*listen_callback)(NX_TCP_SOCKET *socket_ptr, UINT port);
ULONG                        option_words;
ULONG                        mss = 0;
 800d186:	2300      	movs	r3, #0
 800d188:	60fb      	str	r3, [r7, #12]
ULONG                        checksum;
NX_INTERFACE                *interface_ptr = NX_NULL;
 800d18a:	2300      	movs	r3, #0
 800d18c:	657b      	str	r3, [r7, #84]	; 0x54
NX_PACKET                   *queued_ptr;
NX_PACKET                   *queued_prev_ptr;
ULONG                       *queued_source_ip;
UINT                         queued_source_port;
UINT                         is_a_RST_request;
UINT                         is_valid_option_flag = NX_TRUE;
 800d18e:	2301      	movs	r3, #1
 800d190:	643b      	str	r3, [r7, #64]	; 0x40
    /* Add debug information. */
    NX_PACKET_DEBUG(__FILE__, __LINE__, packet_ptr);

    /* Pickup the source IP address.  */
#ifndef NX_DISABLE_IPV4
    if (packet_ptr -> nx_packet_ip_version == NX_IP_VERSION_V4)
 800d192:	683b      	ldr	r3, [r7, #0]
 800d194:	f893 302c 	ldrb.w	r3, [r3, #44]	; 0x2c
 800d198:	2b04      	cmp	r3, #4
 800d19a:	d10e      	bne.n	800d1ba <_nx_tcp_packet_process+0x46>
    {

    NX_IPV4_HEADER *ip_header_ptr;

        /*lint -e{927} -e{826} suppress cast of pointer to pointer, since it is necessary  */
        ip_header_ptr = (NX_IPV4_HEADER *)packet_ptr -> nx_packet_ip_header;
 800d19c:	683b      	ldr	r3, [r7, #0]
 800d19e:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 800d1a0:	63bb      	str	r3, [r7, #56]	; 0x38

        source_ip = &ip_header_ptr -> nx_ip_header_source_ip;
 800d1a2:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800d1a4:	330c      	adds	r3, #12
 800d1a6:	667b      	str	r3, [r7, #100]	; 0x64

        dest_ip = &ip_header_ptr -> nx_ip_header_destination_ip;
 800d1a8:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800d1aa:	3310      	adds	r3, #16
 800d1ac:	663b      	str	r3, [r7, #96]	; 0x60

        mss = 536;
 800d1ae:	f44f 7306 	mov.w	r3, #536	; 0x218
 800d1b2:	60fb      	str	r3, [r7, #12]

        interface_ptr = packet_ptr -> nx_packet_address.nx_packet_interface_ptr;
 800d1b4:	683b      	ldr	r3, [r7, #0]
 800d1b6:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800d1b8:	657b      	str	r3, [r7, #84]	; 0x54
#if defined(NX_DISABLE_TCP_RX_CHECKSUM) || defined(NX_ENABLE_INTERFACE_CAPABILITY) || defined(NX_IPSEC_ENABLE)
    if (compute_checksum)
#endif /* defined(NX_DISABLE_TCP_RX_CHECKSUM) || defined(NX_ENABLE_INTERFACE_CAPABILITY) || defined(NX_IPSEC_ENABLE) */
    {
        checksum = _nx_ip_checksum_compute(packet_ptr, NX_PROTOCOL_TCP,
                                           (UINT)packet_ptr -> nx_packet_length,
 800d1ba:	683b      	ldr	r3, [r7, #0]
 800d1bc:	6a5a      	ldr	r2, [r3, #36]	; 0x24
        checksum = _nx_ip_checksum_compute(packet_ptr, NX_PROTOCOL_TCP,
 800d1be:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 800d1c0:	9300      	str	r3, [sp, #0]
 800d1c2:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 800d1c4:	2106      	movs	r1, #6
 800d1c6:	6838      	ldr	r0, [r7, #0]
 800d1c8:	f7fc fd2e 	bl	8009c28 <_nx_ip_checksum_compute>
 800d1cc:	4603      	mov	r3, r0
 800d1ce:	637b      	str	r3, [r7, #52]	; 0x34
                                           source_ip, dest_ip);

        checksum = NX_LOWER_16_MASK & ~checksum;
 800d1d0:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800d1d2:	43db      	mvns	r3, r3
 800d1d4:	b29b      	uxth	r3, r3
 800d1d6:	637b      	str	r3, [r7, #52]	; 0x34

        /* Calculate the checksum.  */
        if (checksum != 0)
 800d1d8:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800d1da:	2b00      	cmp	r3, #0
 800d1dc:	d011      	beq.n	800d202 <_nx_tcp_packet_process+0x8e>
        {

#ifndef NX_DISABLE_TCP_INFO

            /* Increment the TCP invalid packet error count.  */
            ip_ptr -> nx_ip_tcp_invalid_packets++;
 800d1de:	687b      	ldr	r3, [r7, #4]
 800d1e0:	f8d3 30b8 	ldr.w	r3, [r3, #184]	; 0xb8
 800d1e4:	1c5a      	adds	r2, r3, #1
 800d1e6:	687b      	ldr	r3, [r7, #4]
 800d1e8:	f8c3 20b8 	str.w	r2, [r3, #184]	; 0xb8

            /* Increment the TCP packet checksum error count.  */
            ip_ptr -> nx_ip_tcp_checksum_errors++;
 800d1ec:	687b      	ldr	r3, [r7, #4]
 800d1ee:	f8d3 30c0 	ldr.w	r3, [r3, #192]	; 0xc0
 800d1f2:	1c5a      	adds	r2, r3, #1
 800d1f4:	687b      	ldr	r3, [r7, #4]
 800d1f6:	f8c3 20c0 	str.w	r2, [r3, #192]	; 0xc0
#endif

            /* Checksum error, just release the packet.  */
            _nx_packet_release(packet_ptr);
 800d1fa:	6838      	ldr	r0, [r7, #0]
 800d1fc:	f7ff f904 	bl	800c408 <_nx_packet_release>
            return;
 800d200:	e325      	b.n	800d84e <_nx_tcp_packet_process+0x6da>
        }
    }

    /* Pickup the pointer to the head of the TCP packet.  */
    /*lint -e{927} -e{826} suppress cast of pointer to pointer, since it is necessary  */
    tcp_header_ptr =  (NX_TCP_HEADER *)packet_ptr -> nx_packet_prepend_ptr;
 800d202:	683b      	ldr	r3, [r7, #0]
 800d204:	689b      	ldr	r3, [r3, #8]
 800d206:	633b      	str	r3, [r7, #48]	; 0x30

    /* Endian swapping logic.  If NX_LITTLE_ENDIAN is specified, these macros will
       swap the endian of the TCP header.  */
    NX_CHANGE_ULONG_ENDIAN(tcp_header_ptr -> nx_tcp_header_word_0);
 800d208:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800d20a:	681b      	ldr	r3, [r3, #0]
 800d20c:	ba1a      	rev	r2, r3
 800d20e:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800d210:	601a      	str	r2, [r3, #0]
    NX_CHANGE_ULONG_ENDIAN(tcp_header_ptr -> nx_tcp_sequence_number);
 800d212:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800d214:	685b      	ldr	r3, [r3, #4]
 800d216:	ba1a      	rev	r2, r3
 800d218:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800d21a:	605a      	str	r2, [r3, #4]
    NX_CHANGE_ULONG_ENDIAN(tcp_header_ptr -> nx_tcp_acknowledgment_number);
 800d21c:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800d21e:	689b      	ldr	r3, [r3, #8]
 800d220:	ba1a      	rev	r2, r3
 800d222:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800d224:	609a      	str	r2, [r3, #8]
    NX_CHANGE_ULONG_ENDIAN(tcp_header_ptr -> nx_tcp_header_word_3);
 800d226:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800d228:	68db      	ldr	r3, [r3, #12]
 800d22a:	ba1a      	rev	r2, r3
 800d22c:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800d22e:	60da      	str	r2, [r3, #12]
    NX_CHANGE_ULONG_ENDIAN(tcp_header_ptr -> nx_tcp_header_word_4);
 800d230:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800d232:	691b      	ldr	r3, [r3, #16]
 800d234:	ba1a      	rev	r2, r3
 800d236:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800d238:	611a      	str	r2, [r3, #16]

    /* Determine if there are any option words...  Note there are always 5 words in a TCP header.  */
    option_words =  (tcp_header_ptr -> nx_tcp_header_word_3 >> 28) - 5;
 800d23a:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800d23c:	68db      	ldr	r3, [r3, #12]
 800d23e:	0f1b      	lsrs	r3, r3, #28
 800d240:	3b05      	subs	r3, #5
 800d242:	62fb      	str	r3, [r7, #44]	; 0x2c

#ifndef NX_DISABLE_RX_SIZE_CHECKING
    /* Check for valid packet length.  */
    if (((INT)option_words < 0) || (packet_ptr -> nx_packet_length < (sizeof(NX_TCP_HEADER) + (option_words << 2))))
 800d244:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800d246:	2b00      	cmp	r3, #0
 800d248:	db06      	blt.n	800d258 <_nx_tcp_packet_process+0xe4>
 800d24a:	683b      	ldr	r3, [r7, #0]
 800d24c:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 800d24e:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800d250:	009b      	lsls	r3, r3, #2
 800d252:	3314      	adds	r3, #20
 800d254:	429a      	cmp	r2, r3
 800d256:	d20a      	bcs.n	800d26e <_nx_tcp_packet_process+0xfa>
    {

#ifndef NX_DISABLE_TCP_INFO
        /* Increment the TCP invalid packet error.  */
        ip_ptr -> nx_ip_tcp_invalid_packets++;
 800d258:	687b      	ldr	r3, [r7, #4]
 800d25a:	f8d3 30b8 	ldr.w	r3, [r3, #184]	; 0xb8
 800d25e:	1c5a      	adds	r2, r3, #1
 800d260:	687b      	ldr	r3, [r7, #4]
 800d262:	f8c3 20b8 	str.w	r2, [r3, #184]	; 0xb8
#endif

        /* Invalid packet length, just release it.  */
        _nx_packet_release(packet_ptr);
 800d266:	6838      	ldr	r0, [r7, #0]
 800d268:	f7ff f8ce 	bl	800c408 <_nx_packet_release>

        /* The function is complete, just return!  */
        return;
 800d26c:	e2ef      	b.n	800d84e <_nx_tcp_packet_process+0x6da>
    }
#endif

    if (option_words)
 800d26e:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800d270:	2b00      	cmp	r3, #0
 800d272:	d01c      	beq.n	800d2ae <_nx_tcp_packet_process+0x13a>
    {

        /* Yes, there are one or more option words.  */

        /* Derive the Maximum Segment Size (MSS) in the option words.  */
        status = _nx_tcp_mss_option_get((packet_ptr -> nx_packet_prepend_ptr + sizeof(NX_TCP_HEADER)), option_words * (ULONG)sizeof(ULONG), &mss);
 800d274:	683b      	ldr	r3, [r7, #0]
 800d276:	689b      	ldr	r3, [r3, #8]
 800d278:	f103 0014 	add.w	r0, r3, #20
 800d27c:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800d27e:	009b      	lsls	r3, r3, #2
 800d280:	f107 020c 	add.w	r2, r7, #12
 800d284:	4619      	mov	r1, r3
 800d286:	f7ff fe42 	bl	800cf0e <_nx_tcp_mss_option_get>
 800d28a:	62b8      	str	r0, [r7, #40]	; 0x28

        /* Check the status. if status is NX_FALSE, means Option Length is invalid.  */
        if (status == NX_FALSE)
 800d28c:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800d28e:	2b00      	cmp	r3, #0
 800d290:	d102      	bne.n	800d298 <_nx_tcp_packet_process+0x124>
        {

            /* The option is invalid.  */
            is_valid_option_flag = NX_FALSE;
 800d292:	2300      	movs	r3, #0
 800d294:	643b      	str	r3, [r7, #64]	; 0x40
 800d296:	e00a      	b.n	800d2ae <_nx_tcp_packet_process+0x13a>
        else
        {

            /* Set the default MSS if the MSS value was not found.  */
            /*lint -e{644} suppress variable might not be initialized, since "mss" was initialized in _nx_tcp_mss_option_get. */
            if (mss == 0)
 800d298:	68fb      	ldr	r3, [r7, #12]
 800d29a:	2b00      	cmp	r3, #0
 800d29c:	d107      	bne.n	800d2ae <_nx_tcp_packet_process+0x13a>
            {
#ifndef NX_DISABLE_IPV4
                if (packet_ptr -> nx_packet_ip_version == NX_IP_VERSION_V4)
 800d29e:	683b      	ldr	r3, [r7, #0]
 800d2a0:	f893 302c 	ldrb.w	r3, [r3, #44]	; 0x2c
 800d2a4:	2b04      	cmp	r3, #4
 800d2a6:	d102      	bne.n	800d2ae <_nx_tcp_packet_process+0x13a>
                {
                    mss = 536;
 800d2a8:	f44f 7306 	mov.w	r3, #536	; 0x218
 800d2ac:	60fb      	str	r3, [r7, #12]
        }
#endif /* NX_ENABLE_TCP_WINDOW_SCALING */
    }

    /* Pickup the destination TCP port.  */
    port =  (UINT)(tcp_header_ptr -> nx_tcp_header_word_0 & NX_LOWER_16_MASK);
 800d2ae:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800d2b0:	681b      	ldr	r3, [r3, #0]
 800d2b2:	b29b      	uxth	r3, r3
 800d2b4:	627b      	str	r3, [r7, #36]	; 0x24

    /* Pickup the source TCP port.  */
    source_port =  (UINT)(tcp_header_ptr -> nx_tcp_header_word_0 >> NX_SHIFT_BY_16);
 800d2b6:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800d2b8:	681b      	ldr	r3, [r3, #0]
 800d2ba:	0c1b      	lsrs	r3, r3, #16
 800d2bc:	623b      	str	r3, [r7, #32]

    /* Calculate the hash index in the TCP port array of the associated IP instance.  */
    index =  (UINT)((port + (port >> 8)) & NX_TCP_PORT_TABLE_MASK);
 800d2be:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800d2c0:	0a1a      	lsrs	r2, r3, #8
 800d2c2:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800d2c4:	4413      	add	r3, r2
 800d2c6:	f003 031f 	and.w	r3, r3, #31
 800d2ca:	61fb      	str	r3, [r7, #28]

    /* Search the bound sockets in this index for the particular port.  */
    socket_ptr =  ip_ptr -> nx_ip_tcp_port_table[index];
 800d2cc:	687a      	ldr	r2, [r7, #4]
 800d2ce:	69fb      	ldr	r3, [r7, #28]
 800d2d0:	f503 7381 	add.w	r3, r3, #258	; 0x102
 800d2d4:	009b      	lsls	r3, r3, #2
 800d2d6:	4413      	add	r3, r2
 800d2d8:	685b      	ldr	r3, [r3, #4]
 800d2da:	65fb      	str	r3, [r7, #92]	; 0x5c

    /* Determine if there are any sockets bound on this port index.  */
    if (socket_ptr)
 800d2dc:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 800d2de:	2b00      	cmp	r3, #0
 800d2e0:	d068      	beq.n	800d3b4 <_nx_tcp_packet_process+0x240>

        /*  Yes, loop to examine the list of bound ports on this index.  */
        do
        {

            find_a_match = 0;
 800d2e2:	2300      	movs	r3, #0
 800d2e4:	63fb      	str	r3, [r7, #60]	; 0x3c

            /* Determine if the port has been found.  */
            if ((socket_ptr -> nx_tcp_socket_port == port) &&
 800d2e6:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 800d2e8:	68db      	ldr	r3, [r3, #12]
 800d2ea:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 800d2ec:	429a      	cmp	r2, r3
 800d2ee:	d153      	bne.n	800d398 <_nx_tcp_packet_process+0x224>
                (socket_ptr -> nx_tcp_socket_connect_port == source_port))
 800d2f0:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 800d2f2:	69db      	ldr	r3, [r3, #28]
            if ((socket_ptr -> nx_tcp_socket_port == port) &&
 800d2f4:	6a3a      	ldr	r2, [r7, #32]
 800d2f6:	429a      	cmp	r2, r3
 800d2f8:	d14e      	bne.n	800d398 <_nx_tcp_packet_process+0x224>
            {

                /* Make sure they are the same IP protocol */
                if (socket_ptr -> nx_tcp_socket_connect_ip.nxd_ip_version == packet_ptr -> nx_packet_ip_version)
 800d2fa:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 800d2fc:	695b      	ldr	r3, [r3, #20]
 800d2fe:	683a      	ldr	r2, [r7, #0]
 800d300:	f892 202c 	ldrb.w	r2, [r2, #44]	; 0x2c
 800d304:	4293      	cmp	r3, r2
 800d306:	d10c      	bne.n	800d322 <_nx_tcp_packet_process+0x1ae>
                {

#ifndef NX_DISABLE_IPV4
                    if (packet_ptr -> nx_packet_ip_version == NX_IP_VERSION_V4)
 800d308:	683b      	ldr	r3, [r7, #0]
 800d30a:	f893 302c 	ldrb.w	r3, [r3, #44]	; 0x2c
 800d30e:	2b04      	cmp	r3, #4
 800d310:	d107      	bne.n	800d322 <_nx_tcp_packet_process+0x1ae>
                    {

                        if (socket_ptr -> nx_tcp_socket_connect_ip.nxd_ip_address.v4 == *source_ip)
 800d312:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 800d314:	699a      	ldr	r2, [r3, #24]
 800d316:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 800d318:	681b      	ldr	r3, [r3, #0]
 800d31a:	429a      	cmp	r2, r3
 800d31c:	d101      	bne.n	800d322 <_nx_tcp_packet_process+0x1ae>
                        {
                            find_a_match = 1;
 800d31e:	2301      	movs	r3, #1
 800d320:	63fb      	str	r3, [r7, #60]	; 0x3c
                        }
                    }
#endif /* FEATURE_NX_IPV6 */
                }

                if (find_a_match)
 800d322:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800d324:	2b00      	cmp	r3, #0
 800d326:	d037      	beq.n	800d398 <_nx_tcp_packet_process+0x224>
                    /* Determine if we need to update the tcp port head pointer.  This should
                       only be done if the found socket pointer is not the head pointer and
                       the mutex for this IP instance is available.  */

                    /* Move the port head pointer to this socket.  */
                    ip_ptr -> nx_ip_tcp_port_table[index] = socket_ptr;
 800d328:	687a      	ldr	r2, [r7, #4]
 800d32a:	69fb      	ldr	r3, [r7, #28]
 800d32c:	f503 7381 	add.w	r3, r3, #258	; 0x102
 800d330:	009b      	lsls	r3, r3, #2
 800d332:	4413      	add	r3, r2
 800d334:	6dfa      	ldr	r2, [r7, #92]	; 0x5c
 800d336:	605a      	str	r2, [r3, #4]

                    /* If this packet contains SYN */
                    if (tcp_header_ptr -> nx_tcp_header_word_3 & NX_TCP_SYN_BIT)
 800d338:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800d33a:	68db      	ldr	r3, [r3, #12]
 800d33c:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
 800d340:	2b00      	cmp	r3, #0
 800d342:	d024      	beq.n	800d38e <_nx_tcp_packet_process+0x21a>
                    {

                        /* Record the MSS value if it is present and the   Otherwise use 536, as
                           outlined in RFC 1122 section 4.2.2.6. */
                        socket_ptr -> nx_tcp_socket_peer_mss = mss;
 800d344:	68fa      	ldr	r2, [r7, #12]
 800d346:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 800d348:	625a      	str	r2, [r3, #36]	; 0x24

                        if ((mss > socket_ptr -> nx_tcp_socket_mss) && socket_ptr -> nx_tcp_socket_mss)
 800d34a:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 800d34c:	691a      	ldr	r2, [r3, #16]
 800d34e:	68fb      	ldr	r3, [r7, #12]
 800d350:	429a      	cmp	r2, r3
 800d352:	d208      	bcs.n	800d366 <_nx_tcp_packet_process+0x1f2>
 800d354:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 800d356:	691b      	ldr	r3, [r3, #16]
 800d358:	2b00      	cmp	r3, #0
 800d35a:	d004      	beq.n	800d366 <_nx_tcp_packet_process+0x1f2>
                        {
                            socket_ptr -> nx_tcp_socket_connect_mss  = socket_ptr -> nx_tcp_socket_mss;
 800d35c:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 800d35e:	691a      	ldr	r2, [r3, #16]
 800d360:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 800d362:	621a      	str	r2, [r3, #32]
 800d364:	e00b      	b.n	800d37e <_nx_tcp_packet_process+0x20a>
                        }
                        else if ((socket_ptr -> nx_tcp_socket_state != NX_TCP_SYN_SENT) ||
 800d366:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 800d368:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 800d36a:	2b03      	cmp	r3, #3
 800d36c:	d104      	bne.n	800d378 <_nx_tcp_packet_process+0x204>
                                 (socket_ptr -> nx_tcp_socket_connect_mss > mss))
 800d36e:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 800d370:	6a1a      	ldr	r2, [r3, #32]
 800d372:	68fb      	ldr	r3, [r7, #12]
                        else if ((socket_ptr -> nx_tcp_socket_state != NX_TCP_SYN_SENT) ||
 800d374:	429a      	cmp	r2, r3
 800d376:	d902      	bls.n	800d37e <_nx_tcp_packet_process+0x20a>
                        {
                            socket_ptr -> nx_tcp_socket_connect_mss  = mss;
 800d378:	68fa      	ldr	r2, [r7, #12]
 800d37a:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 800d37c:	621a      	str	r2, [r3, #32]
                        }

                        /* Compute the SMSS * SMSS value, so later TCP module doesn't need to redo the multiplication. */
                        socket_ptr -> nx_tcp_socket_connect_mss2 =
                            socket_ptr -> nx_tcp_socket_connect_mss * socket_ptr -> nx_tcp_socket_connect_mss;
 800d37e:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 800d380:	6a1b      	ldr	r3, [r3, #32]
 800d382:	6dfa      	ldr	r2, [r7, #92]	; 0x5c
 800d384:	6a12      	ldr	r2, [r2, #32]
 800d386:	fb03 f202 	mul.w	r2, r3, r2
                        socket_ptr -> nx_tcp_socket_connect_mss2 =
 800d38a:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 800d38c:	631a      	str	r2, [r3, #48]	; 0x30
                        socket_ptr -> nx_tcp_snd_win_scale_value = rwin_scale;
#endif /* NX_ENABLE_TCP_WINDOW_SCALING */
                    }

                    /* Process the packet within an existing TCP connection.  */
                    _nx_tcp_socket_packet_process(socket_ptr, packet_ptr);
 800d38e:	6839      	ldr	r1, [r7, #0]
 800d390:	6df8      	ldr	r0, [r7, #92]	; 0x5c
 800d392:	f000 fe41 	bl	800e018 <_nx_tcp_socket_packet_process>

                    /* Get out of the search loop and this function!  */
                    return;
 800d396:	e25a      	b.n	800d84e <_nx_tcp_packet_process+0x6da>
                }
            }

            /* Move to the next entry in the bound index.  */
            socket_ptr =  socket_ptr -> nx_tcp_socket_bound_next;
 800d398:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 800d39a:	f8d3 30e0 	ldr.w	r3, [r3, #224]	; 0xe0
 800d39e:	65fb      	str	r3, [r7, #92]	; 0x5c
        } while (socket_ptr != ip_ptr -> nx_ip_tcp_port_table[index]);
 800d3a0:	687a      	ldr	r2, [r7, #4]
 800d3a2:	69fb      	ldr	r3, [r7, #28]
 800d3a4:	f503 7381 	add.w	r3, r3, #258	; 0x102
 800d3a8:	009b      	lsls	r3, r3, #2
 800d3aa:	4413      	add	r3, r2
 800d3ac:	685b      	ldr	r3, [r3, #4]
 800d3ae:	6dfa      	ldr	r2, [r7, #92]	; 0x5c
 800d3b0:	429a      	cmp	r2, r3
 800d3b2:	d196      	bne.n	800d2e2 <_nx_tcp_packet_process+0x16e>
    }

    /* At this point, we know there is not an existing TCP connection.  */

    /* If this packet contains the valid option.  */
    if (is_valid_option_flag == NX_FALSE)
 800d3b4:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 800d3b6:	2b00      	cmp	r3, #0
 800d3b8:	d10f      	bne.n	800d3da <_nx_tcp_packet_process+0x266>
    {

        /* Send RST message.
           TCP MUST be prepared to handle an illegal option length (e.g., zero) without crashing;
           a suggested procedure is to reset the connection and log the reason, outlined in RFC 1122, Section 4.2.2.5, Page85. */
        _nx_tcp_no_connection_reset(ip_ptr, packet_ptr, tcp_header_ptr);
 800d3ba:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 800d3bc:	6839      	ldr	r1, [r7, #0]
 800d3be:	6878      	ldr	r0, [r7, #4]
 800d3c0:	f7ff fdff 	bl	800cfc2 <_nx_tcp_no_connection_reset>

#ifndef NX_DISABLE_TCP_INFO
        /* Increment the TCP invalid packet error count.  */
        ip_ptr -> nx_ip_tcp_invalid_packets++;
 800d3c4:	687b      	ldr	r3, [r7, #4]
 800d3c6:	f8d3 30b8 	ldr.w	r3, [r3, #184]	; 0xb8
 800d3ca:	1c5a      	adds	r2, r3, #1
 800d3cc:	687b      	ldr	r3, [r7, #4]
 800d3ce:	f8c3 20b8 	str.w	r2, [r3, #184]	; 0xb8
#endif /* NX_DISABLE_TCP_INFO */

        /* Not a connection request, just release the packet.  */
        _nx_packet_release(packet_ptr);
 800d3d2:	6838      	ldr	r0, [r7, #0]
 800d3d4:	f7ff f818 	bl	800c408 <_nx_packet_release>

        return;
 800d3d8:	e239      	b.n	800d84e <_nx_tcp_packet_process+0x6da>
#endif

    /* Handle new connection requests without ACK bit in NX_TCP_SYN_RECEIVED state.
       NX_TCP_SYN_RECEIVED state is equal of LISTEN state of RFC.
       RFC793, Section3.9, Page65. */
    if ((!(tcp_header_ptr -> nx_tcp_header_word_3 & NX_TCP_ACK_BIT)) &&
 800d3da:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800d3dc:	68db      	ldr	r3, [r3, #12]
 800d3de:	f403 1380 	and.w	r3, r3, #1048576	; 0x100000
 800d3e2:	2b00      	cmp	r3, #0
 800d3e4:	f040 820f 	bne.w	800d806 <_nx_tcp_packet_process+0x692>
        (ip_ptr -> nx_ip_tcp_active_listen_requests))
 800d3e8:	687b      	ldr	r3, [r7, #4]
 800d3ea:	f8d3 361c 	ldr.w	r3, [r3, #1564]	; 0x61c
    if ((!(tcp_header_ptr -> nx_tcp_header_word_3 & NX_TCP_ACK_BIT)) &&
 800d3ee:	2b00      	cmp	r3, #0
 800d3f0:	f000 8209 	beq.w	800d806 <_nx_tcp_packet_process+0x692>
    {

#ifndef NX_DISABLE_IPV4
        if (packet_ptr -> nx_packet_ip_version == NX_IP_VERSION_V4)
 800d3f4:	683b      	ldr	r3, [r7, #0]
 800d3f6:	f893 302c 	ldrb.w	r3, [r3, #44]	; 0x2c
 800d3fa:	2b04      	cmp	r3, #4
 800d3fc:	d145      	bne.n	800d48a <_nx_tcp_packet_process+0x316>
        {

            /* Check for LAND attack packet. This is an incoming packet with matching
               Source and Destination IP address, and matching source and destination port. */
            if ((*source_ip == *dest_ip) && (source_port == port))
 800d3fe:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 800d400:	681a      	ldr	r2, [r3, #0]
 800d402:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 800d404:	681b      	ldr	r3, [r3, #0]
 800d406:	429a      	cmp	r2, r3
 800d408:	d10e      	bne.n	800d428 <_nx_tcp_packet_process+0x2b4>
 800d40a:	6a3a      	ldr	r2, [r7, #32]
 800d40c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800d40e:	429a      	cmp	r2, r3
 800d410:	d10a      	bne.n	800d428 <_nx_tcp_packet_process+0x2b4>

                /* Bogus packet. Drop it! */

#ifndef NX_DISABLE_TCP_INFO
                /* Increment the TCP invalid packet error count.  */
                ip_ptr -> nx_ip_tcp_invalid_packets++;
 800d412:	687b      	ldr	r3, [r7, #4]
 800d414:	f8d3 30b8 	ldr.w	r3, [r3, #184]	; 0xb8
 800d418:	1c5a      	adds	r2, r3, #1
 800d41a:	687b      	ldr	r3, [r7, #4]
 800d41c:	f8c3 20b8 	str.w	r2, [r3, #184]	; 0xb8
#endif /* NX_DISABLE_TCP_INFO */

                /* Release the packet we will not process any further.  */
                _nx_packet_release(packet_ptr);
 800d420:	6838      	ldr	r0, [r7, #0]
 800d422:	f7fe fff1 	bl	800c408 <_nx_packet_release>
                return;
 800d426:	e212      	b.n	800d84e <_nx_tcp_packet_process+0x6da>

            /* It shall not make connections if the source IP address
               is broadcast or multicast.   */
            if (
                /* Check for Multicast address */
                ((*source_ip & NX_IP_CLASS_D_MASK) == NX_IP_CLASS_D_TYPE) ||
 800d428:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 800d42a:	681b      	ldr	r3, [r3, #0]
 800d42c:	f003 4370 	and.w	r3, r3, #4026531840	; 0xf0000000
            if (
 800d430:	f1b3 4f60 	cmp.w	r3, #3758096384	; 0xe0000000
 800d434:	d01e      	beq.n	800d474 <_nx_tcp_packet_process+0x300>
                /* Check for subnet-directed broadcast */
                (((*source_ip & interface_ptr -> nx_interface_ip_network_mask) == interface_ptr -> nx_interface_ip_network) &&
 800d436:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 800d438:	681a      	ldr	r2, [r3, #0]
 800d43a:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 800d43c:	699b      	ldr	r3, [r3, #24]
 800d43e:	401a      	ands	r2, r3
 800d440:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 800d442:	69db      	ldr	r3, [r3, #28]
                ((*source_ip & NX_IP_CLASS_D_MASK) == NX_IP_CLASS_D_TYPE) ||
 800d444:	429a      	cmp	r2, r3
 800d446:	d10a      	bne.n	800d45e <_nx_tcp_packet_process+0x2ea>
                 ((*source_ip & ~(interface_ptr -> nx_interface_ip_network_mask)) == ~(interface_ptr -> nx_interface_ip_network_mask))) ||
 800d448:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 800d44a:	681a      	ldr	r2, [r3, #0]
 800d44c:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 800d44e:	699b      	ldr	r3, [r3, #24]
 800d450:	43db      	mvns	r3, r3
 800d452:	401a      	ands	r2, r3
 800d454:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 800d456:	699b      	ldr	r3, [r3, #24]
 800d458:	43db      	mvns	r3, r3
                (((*source_ip & interface_ptr -> nx_interface_ip_network_mask) == interface_ptr -> nx_interface_ip_network) &&
 800d45a:	429a      	cmp	r2, r3
 800d45c:	d00a      	beq.n	800d474 <_nx_tcp_packet_process+0x300>
                /* Check for local subnet address */
                (*source_ip == interface_ptr -> nx_interface_ip_network)  ||
 800d45e:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 800d460:	681a      	ldr	r2, [r3, #0]
 800d462:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 800d464:	69db      	ldr	r3, [r3, #28]
                 ((*source_ip & ~(interface_ptr -> nx_interface_ip_network_mask)) == ~(interface_ptr -> nx_interface_ip_network_mask))) ||
 800d466:	429a      	cmp	r2, r3
 800d468:	d004      	beq.n	800d474 <_nx_tcp_packet_process+0x300>
                /* Check for limited broadcast */
                (*source_ip == NX_IP_LIMITED_BROADCAST)
 800d46a:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 800d46c:	681b      	ldr	r3, [r3, #0]
                (*source_ip == interface_ptr -> nx_interface_ip_network)  ||
 800d46e:	f1b3 3fff 	cmp.w	r3, #4294967295
 800d472:	d10a      	bne.n	800d48a <_nx_tcp_packet_process+0x316>
               )
            {

#ifndef NX_DISABLE_TCP_INFO
                /* Increment the TCP invalid packet error count.  */
                ip_ptr -> nx_ip_tcp_invalid_packets++;
 800d474:	687b      	ldr	r3, [r7, #4]
 800d476:	f8d3 30b8 	ldr.w	r3, [r3, #184]	; 0xb8
 800d47a:	1c5a      	adds	r2, r3, #1
 800d47c:	687b      	ldr	r3, [r7, #4]
 800d47e:	f8c3 20b8 	str.w	r2, [r3, #184]	; 0xb8
#endif /* NX_DISABLE_TCP_INFO */

                /* Release the packet.  */
                _nx_packet_release(packet_ptr);
 800d482:	6838      	ldr	r0, [r7, #0]
 800d484:	f7fe ffc0 	bl	800c408 <_nx_packet_release>

                /* Finished processing, simply return!  */
                return;
 800d488:	e1e1      	b.n	800d84e <_nx_tcp_packet_process+0x6da>
            }
        }
#endif /* FEATURE_NX_IPV6*/

        /* Search all ports in listen mode for a match. */
        listen_ptr =  ip_ptr -> nx_ip_tcp_active_listen_requests;
 800d48a:	687b      	ldr	r3, [r7, #4]
 800d48c:	f8d3 361c 	ldr.w	r3, [r3, #1564]	; 0x61c
 800d490:	65bb      	str	r3, [r7, #88]	; 0x58
        do
        {

            /* Determine if this port is in a listen mode.  */
            if (listen_ptr -> nx_tcp_listen_port == port)
 800d492:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 800d494:	681b      	ldr	r3, [r3, #0]
 800d496:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 800d498:	429a      	cmp	r2, r3
 800d49a:	f040 81aa 	bne.w	800d7f2 <_nx_tcp_packet_process+0x67e>

                /* Determine if the packet is an initial connection request.
                   The incoming SYN packet is a connection request.
                   The incoming RST packet is related to a previous connection request.
                   Fourth other text or control. RFC793, Section3.9, Page66. */
                if ((!(tcp_header_ptr -> nx_tcp_header_word_3 & NX_TCP_SYN_BIT)) &&
 800d49e:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800d4a0:	68db      	ldr	r3, [r3, #12]
 800d4a2:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
 800d4a6:	2b00      	cmp	r3, #0
 800d4a8:	d110      	bne.n	800d4cc <_nx_tcp_packet_process+0x358>
                    (!(tcp_header_ptr -> nx_tcp_header_word_3 & NX_TCP_RST_BIT)))
 800d4aa:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800d4ac:	68db      	ldr	r3, [r3, #12]
 800d4ae:	f403 2380 	and.w	r3, r3, #262144	; 0x40000
                if ((!(tcp_header_ptr -> nx_tcp_header_word_3 & NX_TCP_SYN_BIT)) &&
 800d4b2:	2b00      	cmp	r3, #0
 800d4b4:	d10a      	bne.n	800d4cc <_nx_tcp_packet_process+0x358>
                {

#ifndef NX_DISABLE_TCP_INFO
                    /* This is a duplicate connection request. Increment the TCP dropped packet count.  */
                    ip_ptr -> nx_ip_tcp_receive_packets_dropped++;
 800d4b6:	687b      	ldr	r3, [r7, #4]
 800d4b8:	f8d3 30bc 	ldr.w	r3, [r3, #188]	; 0xbc
 800d4bc:	1c5a      	adds	r2, r3, #1
 800d4be:	687b      	ldr	r3, [r7, #4]
 800d4c0:	f8c3 20bc 	str.w	r2, [r3, #188]	; 0xbc
#endif /* NX_DISABLE_TCP_INFO */

                    /* Release the packet.  */
                    _nx_packet_release(packet_ptr);
 800d4c4:	6838      	ldr	r0, [r7, #0]
 800d4c6:	f7fe ff9f 	bl	800c408 <_nx_packet_release>

                    return;
 800d4ca:	e1c0      	b.n	800d84e <_nx_tcp_packet_process+0x6da>
                }

#ifndef NX_DISABLE_TCP_INFO

                /* Check for a SYN bit set.  */
                if ((tcp_header_ptr -> nx_tcp_header_word_3 & NX_TCP_SYN_BIT))
 800d4cc:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800d4ce:	68db      	ldr	r3, [r3, #12]
 800d4d0:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
 800d4d4:	2b00      	cmp	r3, #0
 800d4d6:	d00d      	beq.n	800d4f4 <_nx_tcp_packet_process+0x380>
                {

                    /* Increment the passive TCP connections count.  */
                    ip_ptr -> nx_ip_tcp_passive_connections++;
 800d4d8:	687b      	ldr	r3, [r7, #4]
 800d4da:	f8d3 30c8 	ldr.w	r3, [r3, #200]	; 0xc8
 800d4de:	1c5a      	adds	r2, r3, #1
 800d4e0:	687b      	ldr	r3, [r7, #4]
 800d4e2:	f8c3 20c8 	str.w	r2, [r3, #200]	; 0xc8

                    /* Increment the TCP connections count.  */
                    ip_ptr -> nx_ip_tcp_connections++;
 800d4e6:	687b      	ldr	r3, [r7, #4]
 800d4e8:	f8d3 30c4 	ldr.w	r3, [r3, #196]	; 0xc4
 800d4ec:	1c5a      	adds	r2, r3, #1
 800d4ee:	687b      	ldr	r3, [r7, #4]
 800d4f0:	f8c3 20c4 	str.w	r2, [r3, #196]	; 0xc4
#endif

                /* Okay, this port is in a listen mode.  We now need to see if
                   there is an available socket for the new connection request
                   present.  */
                if ((listen_ptr -> nx_tcp_listen_socket_ptr) &&
 800d4f4:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 800d4f6:	689b      	ldr	r3, [r3, #8]
 800d4f8:	2b00      	cmp	r3, #0
 800d4fa:	f000 80b8 	beq.w	800d66e <_nx_tcp_packet_process+0x4fa>
                    ((tcp_header_ptr -> nx_tcp_header_word_3 & NX_TCP_RST_BIT) == NX_NULL))
 800d4fe:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800d500:	68db      	ldr	r3, [r3, #12]
 800d502:	f403 2380 	and.w	r3, r3, #262144	; 0x40000
                if ((listen_ptr -> nx_tcp_listen_socket_ptr) &&
 800d506:	2b00      	cmp	r3, #0
 800d508:	f040 80b1 	bne.w	800d66e <_nx_tcp_packet_process+0x4fa>
                    /* Yes there is indeed a socket present.  We now need to
                       fill in the appropriate info and call the server callback
                       routine.  */

                    /* Allocate the supplied server socket.  */
                    socket_ptr = listen_ptr -> nx_tcp_listen_socket_ptr;
 800d50c:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 800d50e:	689b      	ldr	r3, [r3, #8]
 800d510:	65fb      	str	r3, [r7, #92]	; 0x5c

                    /* Clear the server socket pointer in the listen request.  If the
                       application wishes to honor more server connections on this port,
                       the application must call relisten with a new server socket
                       pointer.  */
                    listen_ptr -> nx_tcp_listen_socket_ptr =  NX_NULL;
 800d512:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 800d514:	2200      	movs	r2, #0
 800d516:	609a      	str	r2, [r3, #8]

                    /* Fill the socket in with the appropriate information.  */


#ifndef NX_DISABLE_IPV4
                    if (packet_ptr -> nx_packet_ip_version == NX_IP_VERSION_V4)
 800d518:	683b      	ldr	r3, [r7, #0]
 800d51a:	f893 302c 	ldrb.w	r3, [r3, #44]	; 0x2c
 800d51e:	2b04      	cmp	r3, #4
 800d520:	d116      	bne.n	800d550 <_nx_tcp_packet_process+0x3dc>
                    {

                        /* Assume the interface that receives the incoming packet is the best interface
                           for sending responses. */
                        socket_ptr -> nx_tcp_socket_connect_interface = interface_ptr;
 800d522:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 800d524:	6d7a      	ldr	r2, [r7, #84]	; 0x54
 800d526:	629a      	str	r2, [r3, #40]	; 0x28
                        socket_ptr -> nx_tcp_socket_next_hop_address = NX_NULL;
 800d528:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 800d52a:	2200      	movs	r2, #0
 800d52c:	62da      	str	r2, [r3, #44]	; 0x2c

                        /* Set the next hop address.  */
                        _nx_ip_route_find(ip_ptr, *source_ip, &socket_ptr -> nx_tcp_socket_connect_interface,
 800d52e:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 800d530:	6819      	ldr	r1, [r3, #0]
 800d532:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 800d534:	f103 0228 	add.w	r2, r3, #40	; 0x28
 800d538:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 800d53a:	332c      	adds	r3, #44	; 0x2c
 800d53c:	6878      	ldr	r0, [r7, #4]
 800d53e:	f7fd fc69 	bl	800ae14 <_nx_ip_route_find>
                                          &socket_ptr -> nx_tcp_socket_next_hop_address);

                        socket_ptr -> nx_tcp_socket_connect_ip.nxd_ip_version =  NX_IP_VERSION_V4;
 800d542:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 800d544:	2204      	movs	r2, #4
 800d546:	615a      	str	r2, [r3, #20]
                        socket_ptr -> nx_tcp_socket_connect_ip.nxd_ip_address.v4 = *source_ip;
 800d548:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 800d54a:	681a      	ldr	r2, [r3, #0]
 800d54c:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 800d54e:	619a      	str	r2, [r3, #24]
                        socket_ptr -> nx_tcp_socket_ipv6_addr = packet_ptr -> nx_packet_address.nx_packet_ipv6_address_ptr;
                        socket_ptr -> nx_tcp_socket_connect_interface = interface_ptr;
                    }
#endif /* FEATURE_NX_IPV6 */

                    socket_ptr -> nx_tcp_socket_connect_port = source_port;
 800d550:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 800d552:	6a3a      	ldr	r2, [r7, #32]
 800d554:	61da      	str	r2, [r3, #28]
                    socket_ptr -> nx_tcp_socket_rx_sequence =  tcp_header_ptr -> nx_tcp_sequence_number;
 800d556:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800d558:	685a      	ldr	r2, [r3, #4]
 800d55a:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 800d55c:	641a      	str	r2, [r3, #64]	; 0x40


                    /* Yes, MSS was found, so store it!  */
                    socket_ptr -> nx_tcp_socket_peer_mss = mss;
 800d55e:	68fa      	ldr	r2, [r7, #12]
 800d560:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 800d562:	625a      	str	r2, [r3, #36]	; 0x24
                     */
                    socket_ptr -> nx_tcp_snd_win_scale_value = rwin_scale;
#endif /* NX_ENABLE_TCP_WINDOW_SCALING */

                    /* Set the initial slow start threshold to be the advertised window size. */
                    socket_ptr -> nx_tcp_socket_tx_slow_start_threshold = socket_ptr -> nx_tcp_socket_tx_window_advertised;
 800d564:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 800d566:	6d5a      	ldr	r2, [r3, #84]	; 0x54
 800d568:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 800d56a:	635a      	str	r2, [r3, #52]	; 0x34

                    /* Slow start:  setup initial window (IW) to be MSS,  RFC 2581, 3.1 */
                    socket_ptr -> nx_tcp_socket_tx_window_congestion = mss;
 800d56c:	68fa      	ldr	r2, [r7, #12]
 800d56e:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 800d570:	659a      	str	r2, [r3, #88]	; 0x58

                    /* Initialize the transmit outstanding byte count to zero. */
                    socket_ptr -> nx_tcp_socket_tx_outstanding_bytes = 0;
 800d572:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 800d574:	2200      	movs	r2, #0
 800d576:	65da      	str	r2, [r3, #92]	; 0x5c

                    /* Calculate the hash index in the TCP port array of the associated IP instance.  */
                    index = (UINT)((port + (port >> 8)) & NX_TCP_PORT_TABLE_MASK);
 800d578:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800d57a:	0a1a      	lsrs	r2, r3, #8
 800d57c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800d57e:	4413      	add	r3, r2
 800d580:	f003 031f 	and.w	r3, r3, #31
 800d584:	61fb      	str	r3, [r7, #28]

                    /* Determine if the list is NULL.  */
                    if (ip_ptr -> nx_ip_tcp_port_table[index])
 800d586:	687a      	ldr	r2, [r7, #4]
 800d588:	69fb      	ldr	r3, [r7, #28]
 800d58a:	f503 7381 	add.w	r3, r3, #258	; 0x102
 800d58e:	009b      	lsls	r3, r3, #2
 800d590:	4413      	add	r3, r2
 800d592:	685b      	ldr	r3, [r3, #4]
 800d594:	2b00      	cmp	r3, #0
 800d596:	d02c      	beq.n	800d5f2 <_nx_tcp_packet_process+0x47e>
                    {

                        /* There are already sockets on this list... just add this one
                           to the end.  */
                        socket_ptr -> nx_tcp_socket_bound_next =
                            ip_ptr -> nx_ip_tcp_port_table[index];
 800d598:	687a      	ldr	r2, [r7, #4]
 800d59a:	69fb      	ldr	r3, [r7, #28]
 800d59c:	f503 7381 	add.w	r3, r3, #258	; 0x102
 800d5a0:	009b      	lsls	r3, r3, #2
 800d5a2:	4413      	add	r3, r2
 800d5a4:	685a      	ldr	r2, [r3, #4]
                        socket_ptr -> nx_tcp_socket_bound_next =
 800d5a6:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 800d5a8:	f8c3 20e0 	str.w	r2, [r3, #224]	; 0xe0
                        socket_ptr -> nx_tcp_socket_bound_previous =
                            (ip_ptr -> nx_ip_tcp_port_table[index]) -> nx_tcp_socket_bound_previous;
 800d5ac:	687a      	ldr	r2, [r7, #4]
 800d5ae:	69fb      	ldr	r3, [r7, #28]
 800d5b0:	f503 7381 	add.w	r3, r3, #258	; 0x102
 800d5b4:	009b      	lsls	r3, r3, #2
 800d5b6:	4413      	add	r3, r2
 800d5b8:	685b      	ldr	r3, [r3, #4]
 800d5ba:	f8d3 20e4 	ldr.w	r2, [r3, #228]	; 0xe4
                        socket_ptr -> nx_tcp_socket_bound_previous =
 800d5be:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 800d5c0:	f8c3 20e4 	str.w	r2, [r3, #228]	; 0xe4
                        ((ip_ptr -> nx_ip_tcp_port_table[index]) -> nx_tcp_socket_bound_previous) -> nx_tcp_socket_bound_next =
 800d5c4:	687a      	ldr	r2, [r7, #4]
 800d5c6:	69fb      	ldr	r3, [r7, #28]
 800d5c8:	f503 7381 	add.w	r3, r3, #258	; 0x102
 800d5cc:	009b      	lsls	r3, r3, #2
 800d5ce:	4413      	add	r3, r2
 800d5d0:	685b      	ldr	r3, [r3, #4]
 800d5d2:	f8d3 30e4 	ldr.w	r3, [r3, #228]	; 0xe4
 800d5d6:	6dfa      	ldr	r2, [r7, #92]	; 0x5c
 800d5d8:	f8c3 20e0 	str.w	r2, [r3, #224]	; 0xe0
                            socket_ptr;
                        (ip_ptr -> nx_ip_tcp_port_table[index]) -> nx_tcp_socket_bound_previous = socket_ptr;
 800d5dc:	687a      	ldr	r2, [r7, #4]
 800d5de:	69fb      	ldr	r3, [r7, #28]
 800d5e0:	f503 7381 	add.w	r3, r3, #258	; 0x102
 800d5e4:	009b      	lsls	r3, r3, #2
 800d5e6:	4413      	add	r3, r2
 800d5e8:	685b      	ldr	r3, [r3, #4]
 800d5ea:	6dfa      	ldr	r2, [r7, #92]	; 0x5c
 800d5ec:	f8c3 20e4 	str.w	r2, [r3, #228]	; 0xe4
 800d5f0:	e00f      	b.n	800d612 <_nx_tcp_packet_process+0x49e>
                    else
                    {

                        /* Nothing is on the TCP port list.  Add this TCP socket to an
                           empty list.  */
                        socket_ptr -> nx_tcp_socket_bound_next =      socket_ptr;
 800d5f2:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 800d5f4:	6dfa      	ldr	r2, [r7, #92]	; 0x5c
 800d5f6:	f8c3 20e0 	str.w	r2, [r3, #224]	; 0xe0
                        socket_ptr -> nx_tcp_socket_bound_previous =  socket_ptr;
 800d5fa:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 800d5fc:	6dfa      	ldr	r2, [r7, #92]	; 0x5c
 800d5fe:	f8c3 20e4 	str.w	r2, [r3, #228]	; 0xe4
                        ip_ptr -> nx_ip_tcp_port_table[index] =       socket_ptr;
 800d602:	687a      	ldr	r2, [r7, #4]
 800d604:	69fb      	ldr	r3, [r7, #28]
 800d606:	f503 7381 	add.w	r3, r3, #258	; 0x102
 800d60a:	009b      	lsls	r3, r3, #2
 800d60c:	4413      	add	r3, r2
 800d60e:	6dfa      	ldr	r2, [r7, #92]	; 0x5c
 800d610:	605a      	str	r2, [r3, #4]
                    }

                    /* Pickup the listen callback function.  */
                    listen_callback = listen_ptr -> nx_tcp_listen_callback;
 800d612:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 800d614:	685b      	ldr	r3, [r3, #4]
 800d616:	61bb      	str	r3, [r7, #24]

                    /* Release the incoming packet.  */
                    _nx_packet_release(packet_ptr);
 800d618:	6838      	ldr	r0, [r7, #0]
 800d61a:	f7fe fef5 	bl	800c408 <_nx_packet_release>

                    /* Determine if an accept call with suspension has already been made
                       for this socket.  If so, the SYN message needs to be sent from
                       here.  */
                    if (socket_ptr -> nx_tcp_socket_state == NX_TCP_SYN_RECEIVED)
 800d61e:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 800d620:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 800d622:	2b04      	cmp	r3, #4
 800d624:	d11a      	bne.n	800d65c <_nx_tcp_packet_process+0x4e8>
                        /* The application is suspended on an accept call for this socket.
                           Simply send the SYN now and keep the thread suspended until the
                           other side completes the connection.  */

                        /* Send the SYN message, but increment the ACK first.  */
                        socket_ptr -> nx_tcp_socket_rx_sequence++;
 800d626:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 800d628:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 800d62a:	1c5a      	adds	r2, r3, #1
 800d62c:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 800d62e:	641a      	str	r2, [r3, #64]	; 0x40

                        /* Increment the sequence number for the SYN message.  */
                        socket_ptr -> nx_tcp_socket_tx_sequence++;
 800d630:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 800d632:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 800d634:	1c5a      	adds	r2, r3, #1
 800d636:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 800d638:	63da      	str	r2, [r3, #60]	; 0x3c

                        /* Setup a timeout so the connection attempt can be sent again.  */
                        socket_ptr -> nx_tcp_socket_timeout =          socket_ptr -> nx_tcp_socket_timeout_rate;
 800d63a:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 800d63c:	f8d3 20d0 	ldr.w	r2, [r3, #208]	; 0xd0
 800d640:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 800d642:	f8c3 20cc 	str.w	r2, [r3, #204]	; 0xcc
                        socket_ptr -> nx_tcp_socket_timeout_retries =  0;
 800d646:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 800d648:	2200      	movs	r2, #0
 800d64a:	f8c3 20d4 	str.w	r2, [r3, #212]	; 0xd4

                        /* Send the SYN+ACK message.  */
                        _nx_tcp_packet_send_syn(socket_ptr, (socket_ptr -> nx_tcp_socket_tx_sequence - 1));
 800d64e:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 800d650:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 800d652:	3b01      	subs	r3, #1
 800d654:	4619      	mov	r1, r3
 800d656:	6df8      	ldr	r0, [r7, #92]	; 0x5c
 800d658:	f000 fafa 	bl	800dc50 <_nx_tcp_packet_send_syn>
                    }

                    /* Determine if there is a listen callback function.  */
                    if (listen_callback)
 800d65c:	69bb      	ldr	r3, [r7, #24]
 800d65e:	2b00      	cmp	r3, #0
 800d660:	f000 80c6 	beq.w	800d7f0 <_nx_tcp_packet_process+0x67c>
                    {
                        /* Call the user's listen callback function.  */
                        (listen_callback)(socket_ptr, port);
 800d664:	69bb      	ldr	r3, [r7, #24]
 800d666:	6a79      	ldr	r1, [r7, #36]	; 0x24
 800d668:	6df8      	ldr	r0, [r7, #92]	; 0x5c
 800d66a:	4798      	blx	r3
                    if (listen_callback)
 800d66c:	e0c0      	b.n	800d7f0 <_nx_tcp_packet_process+0x67c>
                        /* If trace is enabled, insert this event into the trace buffer.  */
                        NX_TRACE_IN_LINE_INSERT(NX_TRACE_INTERNAL_TCP_SYN_RECEIVE, ip_ptr, NX_NULL, packet_ptr, tcp_header_ptr -> nx_tcp_sequence_number, NX_TRACE_INTERNAL_EVENTS, 0, 0);
                    }

                    /* Check for the same connection request already in the queue.  */
                    queued_count = listen_ptr -> nx_tcp_listen_queue_current;
 800d66e:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 800d670:	691b      	ldr	r3, [r3, #16]
 800d672:	653b      	str	r3, [r7, #80]	; 0x50
                    queued_ptr = listen_ptr -> nx_tcp_listen_queue_head;
 800d674:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 800d676:	695b      	ldr	r3, [r3, #20]
 800d678:	64fb      	str	r3, [r7, #76]	; 0x4c
                    queued_prev_ptr = queued_ptr;
 800d67a:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800d67c:	64bb      	str	r3, [r7, #72]	; 0x48

                    /* Initialize the check for queued request to false.*/
                    is_a_RST_request = NX_FALSE;
 800d67e:	2300      	movs	r3, #0
 800d680:	647b      	str	r3, [r7, #68]	; 0x44

                    /* Loop through the queued list in order to search for duplicate request.  */
                    while (queued_count--)
 800d682:	e05c      	b.n	800d73e <_nx_tcp_packet_process+0x5ca>
                    {

                        /*lint -e{927} -e{826} suppress cast of pointer to pointer, since it is necessary  */
                        queued_source_port = (UINT)(*((ULONG *)queued_ptr -> nx_packet_prepend_ptr) >> NX_SHIFT_BY_16);
 800d684:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800d686:	689b      	ldr	r3, [r3, #8]
 800d688:	681b      	ldr	r3, [r3, #0]
 800d68a:	0c1b      	lsrs	r3, r3, #16
 800d68c:	617b      	str	r3, [r7, #20]

#ifndef NX_DISABLE_IPV4
                        /* Pickup the queued source port and source IP address for comparison.  */
                        if (queued_ptr -> nx_packet_ip_version == NX_IP_VERSION_V4)
 800d68e:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800d690:	f893 302c 	ldrb.w	r3, [r3, #44]	; 0x2c
 800d694:	2b04      	cmp	r3, #4
 800d696:	d121      	bne.n	800d6dc <_nx_tcp_packet_process+0x568>
                        {

                            /*lint -e{929} -e{927} -e{826} suppress cast of pointer to pointer, since it is necessary  */
                            queued_source_ip = (ULONG *)(((ULONG *)queued_ptr -> nx_packet_prepend_ptr) - 2);
 800d698:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800d69a:	689b      	ldr	r3, [r3, #8]
 800d69c:	3b08      	subs	r3, #8
 800d69e:	613b      	str	r3, [r7, #16]

                            /* Determine if this matches the current connection request.  */
                            if ((*queued_source_ip == *source_ip) && (queued_source_port == source_port))
 800d6a0:	693b      	ldr	r3, [r7, #16]
 800d6a2:	681a      	ldr	r2, [r3, #0]
 800d6a4:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 800d6a6:	681b      	ldr	r3, [r3, #0]
 800d6a8:	429a      	cmp	r2, r3
 800d6aa:	d117      	bne.n	800d6dc <_nx_tcp_packet_process+0x568>
 800d6ac:	697a      	ldr	r2, [r7, #20]
 800d6ae:	6a3b      	ldr	r3, [r7, #32]
 800d6b0:	429a      	cmp	r2, r3
 800d6b2:	d113      	bne.n	800d6dc <_nx_tcp_packet_process+0x568>
                            {

                                /* Possible duplicate connection request to one that is already queued.  */

                                /* Check for a RST (reset) bit set.  */
                                if (tcp_header_ptr -> nx_tcp_header_word_3 & NX_TCP_RST_BIT)
 800d6b4:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800d6b6:	68db      	ldr	r3, [r3, #12]
 800d6b8:	f403 2380 	and.w	r3, r3, #262144	; 0x40000
 800d6bc:	2b00      	cmp	r3, #0
 800d6be:	d002      	beq.n	800d6c6 <_nx_tcp_packet_process+0x552>
                                {

                                    /* RST packet matches a previously queued connection request. */
                                    is_a_RST_request = NX_TRUE;
 800d6c0:	2301      	movs	r3, #1
 800d6c2:	647b      	str	r3, [r7, #68]	; 0x44
 800d6c4:	e00a      	b.n	800d6dc <_nx_tcp_packet_process+0x568>
                                }
                                else
                                {
#ifndef NX_DISABLE_TCP_INFO
                                    /* This is a duplicate connection request. Increment the TCP dropped packet count.  */
                                    ip_ptr -> nx_ip_tcp_receive_packets_dropped++;
 800d6c6:	687b      	ldr	r3, [r7, #4]
 800d6c8:	f8d3 30bc 	ldr.w	r3, [r3, #188]	; 0xbc
 800d6cc:	1c5a      	adds	r2, r3, #1
 800d6ce:	687b      	ldr	r3, [r7, #4]
 800d6d0:	f8c3 20bc 	str.w	r2, [r3, #188]	; 0xbc
#endif
                                    /* Simply release the packet and return.  */
                                    _nx_packet_release(packet_ptr);
 800d6d4:	6838      	ldr	r0, [r7, #0]
 800d6d6:	f7fe fe97 	bl	800c408 <_nx_packet_release>

                                    /* Return!  */
                                    return;
 800d6da:	e0b8      	b.n	800d84e <_nx_tcp_packet_process+0x6da>
                        }
#endif /* FEATURE_NX_IPV6  */

                        /* Handle the case of the RST packet which cancels a previously received
                           connection request. */
                        if (is_a_RST_request)
 800d6dc:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 800d6de:	2b00      	cmp	r3, #0
 800d6e0:	d028      	beq.n	800d734 <_nx_tcp_packet_process+0x5c0>
                        {

                            /* A previous connection request needs to be removed from the listen queue. */
                            if (queued_ptr == listen_ptr -> nx_tcp_listen_queue_head)
 800d6e2:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 800d6e4:	695b      	ldr	r3, [r3, #20]
 800d6e6:	6cfa      	ldr	r2, [r7, #76]	; 0x4c
 800d6e8:	429a      	cmp	r2, r3
 800d6ea:	d104      	bne.n	800d6f6 <_nx_tcp_packet_process+0x582>
                            {

                                /* Reset the front (oldest) of the queue to the next request. */
                                listen_ptr -> nx_tcp_listen_queue_head = queued_ptr -> nx_packet_queue_next;
 800d6ec:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800d6ee:	69da      	ldr	r2, [r3, #28]
 800d6f0:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 800d6f2:	615a      	str	r2, [r3, #20]
 800d6f4:	e003      	b.n	800d6fe <_nx_tcp_packet_process+0x58a>
                            else
                            {

                                /* Link around the request we are removing. */
                                /*lint -e{613} suppress possible use of null pointer, since 'queued_prev_ptr' must not be NULL.  */
                                queued_prev_ptr -> nx_packet_queue_next = queued_ptr -> nx_packet_queue_next;
 800d6f6:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800d6f8:	69da      	ldr	r2, [r3, #28]
 800d6fa:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 800d6fc:	61da      	str	r2, [r3, #28]
                            }

                            /* Is the request being removed the tail (most recent connection?)   */
                            if (queued_ptr == listen_ptr -> nx_tcp_listen_queue_tail)
 800d6fe:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 800d700:	699b      	ldr	r3, [r3, #24]
 800d702:	6cfa      	ldr	r2, [r7, #76]	; 0x4c
 800d704:	429a      	cmp	r2, r3
 800d706:	d102      	bne.n	800d70e <_nx_tcp_packet_process+0x59a>
                            {

                                /* Yes, set the previous connection request as the tail. */
                                listen_ptr -> nx_tcp_listen_queue_tail = queued_prev_ptr;
 800d708:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 800d70a:	6cba      	ldr	r2, [r7, #72]	; 0x48
 800d70c:	619a      	str	r2, [r3, #24]
                            }

                            /* Release the connection request packet.  */
                            _nx_packet_release(queued_ptr);
 800d70e:	6cf8      	ldr	r0, [r7, #76]	; 0x4c
 800d710:	f7fe fe7a 	bl	800c408 <_nx_packet_release>

                            /* Update the listen queue. */
                            listen_ptr -> nx_tcp_listen_queue_current--;
 800d714:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 800d716:	691b      	ldr	r3, [r3, #16]
 800d718:	1e5a      	subs	r2, r3, #1
 800d71a:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 800d71c:	611a      	str	r2, [r3, #16]

#ifndef NX_DISABLE_TCP_INFO
                            /* Increment the TCP dropped packet count.  */
                            ip_ptr -> nx_ip_tcp_receive_packets_dropped++;
 800d71e:	687b      	ldr	r3, [r7, #4]
 800d720:	f8d3 30bc 	ldr.w	r3, [r3, #188]	; 0xbc
 800d724:	1c5a      	adds	r2, r3, #1
 800d726:	687b      	ldr	r3, [r7, #4]
 800d728:	f8c3 20bc 	str.w	r2, [r3, #188]	; 0xbc
#endif

                            /* Simply release the packet and return.  */
                            _nx_packet_release(packet_ptr);
 800d72c:	6838      	ldr	r0, [r7, #0]
 800d72e:	f7fe fe6b 	bl	800c408 <_nx_packet_release>

                            /* Return!  */
                            return;
 800d732:	e08c      	b.n	800d84e <_nx_tcp_packet_process+0x6da>
                        }

                        /* Move to next item in the queue.  */
                        queued_prev_ptr = queued_ptr;
 800d734:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800d736:	64bb      	str	r3, [r7, #72]	; 0x48
                        queued_ptr = queued_ptr -> nx_packet_queue_next;
 800d738:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800d73a:	69db      	ldr	r3, [r3, #28]
 800d73c:	64fb      	str	r3, [r7, #76]	; 0x4c
                    while (queued_count--)
 800d73e:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 800d740:	1e5a      	subs	r2, r3, #1
 800d742:	653a      	str	r2, [r7, #80]	; 0x50
 800d744:	2b00      	cmp	r3, #0
 800d746:	d19d      	bne.n	800d684 <_nx_tcp_packet_process+0x510>
                    }

                    /* Not a duplicate connection request, place this request on the listen queue.  */

                    /* Is this a RST packet? */
                    if (tcp_header_ptr -> nx_tcp_header_word_3 & NX_TCP_RST_BIT)
 800d748:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800d74a:	68db      	ldr	r3, [r3, #12]
 800d74c:	f403 2380 	and.w	r3, r3, #262144	; 0x40000
 800d750:	2b00      	cmp	r3, #0
 800d752:	d00a      	beq.n	800d76a <_nx_tcp_packet_process+0x5f6>
                    {

                        /* Yes, so not a connection request. Do not place on the listen queue. */
#ifndef NX_DISABLE_TCP_INFO
                        /* Increment the TCP dropped packet count.  */
                        ip_ptr -> nx_ip_tcp_receive_packets_dropped++;
 800d754:	687b      	ldr	r3, [r7, #4]
 800d756:	f8d3 30bc 	ldr.w	r3, [r3, #188]	; 0xbc
 800d75a:	1c5a      	adds	r2, r3, #1
 800d75c:	687b      	ldr	r3, [r7, #4]
 800d75e:	f8c3 20bc 	str.w	r2, [r3, #188]	; 0xbc
#endif

                        /* Release the packet.  */
                        _nx_packet_release(packet_ptr);
 800d762:	6838      	ldr	r0, [r7, #0]
 800d764:	f7fe fe50 	bl	800c408 <_nx_packet_release>

                        /* Return!  */
                        return;
 800d768:	e071      	b.n	800d84e <_nx_tcp_packet_process+0x6da>
                    }

                    /* Set the next pointer of the packet to NULL.  */
                    packet_ptr -> nx_packet_queue_next = NX_NULL;
 800d76a:	683b      	ldr	r3, [r7, #0]
 800d76c:	2200      	movs	r2, #0
 800d76e:	61da      	str	r2, [r3, #28]

                    /* Queue the new connection request.  */
                    if (listen_ptr -> nx_tcp_listen_queue_head)
 800d770:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 800d772:	695b      	ldr	r3, [r3, #20]
 800d774:	2b00      	cmp	r3, #0
 800d776:	d004      	beq.n	800d782 <_nx_tcp_packet_process+0x60e>
                    {

                        /* There is a connection request already queued, just link packet to tail.  */
                        (listen_ptr -> nx_tcp_listen_queue_tail) -> nx_packet_queue_next = packet_ptr;
 800d778:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 800d77a:	699b      	ldr	r3, [r3, #24]
 800d77c:	683a      	ldr	r2, [r7, #0]
 800d77e:	61da      	str	r2, [r3, #28]
 800d780:	e002      	b.n	800d788 <_nx_tcp_packet_process+0x614>
                    }
                    else
                    {

                        /* The queue is empty.  Setup head pointer to the new packet.  */
                        listen_ptr -> nx_tcp_listen_queue_head = packet_ptr;
 800d782:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 800d784:	683a      	ldr	r2, [r7, #0]
 800d786:	615a      	str	r2, [r3, #20]
                    }

                    /* Setup the tail pointer to the new packet and increment the queue count.  */
                    listen_ptr -> nx_tcp_listen_queue_tail =  packet_ptr;
 800d788:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 800d78a:	683a      	ldr	r2, [r7, #0]
 800d78c:	619a      	str	r2, [r3, #24]
                    listen_ptr -> nx_tcp_listen_queue_current++;
 800d78e:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 800d790:	691b      	ldr	r3, [r3, #16]
 800d792:	1c5a      	adds	r2, r3, #1
 800d794:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 800d796:	611a      	str	r2, [r3, #16]

                    /* Add debug information. */
                    NX_PACKET_DEBUG(NX_PACKET_TCP_LISTEN_QUEUE, __LINE__, packet_ptr);

                    /* Determine if the queue depth has been exceeded.  */
                    if (listen_ptr -> nx_tcp_listen_queue_current > listen_ptr -> nx_tcp_listen_queue_maximum)
 800d798:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 800d79a:	691a      	ldr	r2, [r3, #16]
 800d79c:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 800d79e:	68db      	ldr	r3, [r3, #12]
 800d7a0:	429a      	cmp	r2, r3
 800d7a2:	d953      	bls.n	800d84c <_nx_tcp_packet_process+0x6d8>
                    {

#ifndef NX_DISABLE_TCP_INFO

                        /* Increment the TCP connections dropped count.  */
                        ip_ptr -> nx_ip_tcp_connections_dropped++;
 800d7a4:	687b      	ldr	r3, [r7, #4]
 800d7a6:	f8d3 30d4 	ldr.w	r3, [r3, #212]	; 0xd4
 800d7aa:	1c5a      	adds	r2, r3, #1
 800d7ac:	687b      	ldr	r3, [r7, #4]
 800d7ae:	f8c3 20d4 	str.w	r2, [r3, #212]	; 0xd4
                        ip_ptr -> nx_ip_tcp_connections--;
 800d7b2:	687b      	ldr	r3, [r7, #4]
 800d7b4:	f8d3 30c4 	ldr.w	r3, [r3, #196]	; 0xc4
 800d7b8:	1e5a      	subs	r2, r3, #1
 800d7ba:	687b      	ldr	r3, [r7, #4]
 800d7bc:	f8c3 20c4 	str.w	r2, [r3, #196]	; 0xc4

                        /* Increment the TCP dropped packet count.  */
                        ip_ptr -> nx_ip_tcp_receive_packets_dropped++;
 800d7c0:	687b      	ldr	r3, [r7, #4]
 800d7c2:	f8d3 30bc 	ldr.w	r3, [r3, #188]	; 0xbc
 800d7c6:	1c5a      	adds	r2, r3, #1
 800d7c8:	687b      	ldr	r3, [r7, #4]
 800d7ca:	f8c3 20bc 	str.w	r2, [r3, #188]	; 0xbc
#endif

                        /* Save the head packet pointer, since this will be released below.  */
                        packet_ptr = listen_ptr -> nx_tcp_listen_queue_head;
 800d7ce:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 800d7d0:	695b      	ldr	r3, [r3, #20]
 800d7d2:	603b      	str	r3, [r7, #0]

                        /* Remove the oldest packet from the queue.  */
                        listen_ptr -> nx_tcp_listen_queue_head = (listen_ptr -> nx_tcp_listen_queue_head) -> nx_packet_queue_next;
 800d7d4:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 800d7d6:	695b      	ldr	r3, [r3, #20]
 800d7d8:	69da      	ldr	r2, [r3, #28]
 800d7da:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 800d7dc:	615a      	str	r2, [r3, #20]

                        /* Decrement the number of packets in the queue.  */
                        listen_ptr -> nx_tcp_listen_queue_current--;
 800d7de:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 800d7e0:	691b      	ldr	r3, [r3, #16]
 800d7e2:	1e5a      	subs	r2, r3, #1
 800d7e4:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 800d7e6:	611a      	str	r2, [r3, #16]

                        /* We have exceeded the number of connections that can be
                           queued for this port.  */

                        /* Release the packet.  */
                        _nx_packet_release(packet_ptr);
 800d7e8:	6838      	ldr	r0, [r7, #0]
 800d7ea:	f7fe fe0d 	bl	800c408 <_nx_packet_release>
                    }
                }

                /* Finished processing, just return.  */
                return;
 800d7ee:	e02d      	b.n	800d84c <_nx_tcp_packet_process+0x6d8>
 800d7f0:	e02c      	b.n	800d84c <_nx_tcp_packet_process+0x6d8>
            }

            /* Move to the next listen request.  */
            listen_ptr = listen_ptr -> nx_tcp_listen_next;
 800d7f2:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 800d7f4:	69db      	ldr	r3, [r3, #28]
 800d7f6:	65bb      	str	r3, [r7, #88]	; 0x58
        } while (listen_ptr != ip_ptr -> nx_ip_tcp_active_listen_requests);
 800d7f8:	687b      	ldr	r3, [r7, #4]
 800d7fa:	f8d3 361c 	ldr.w	r3, [r3, #1564]	; 0x61c
 800d7fe:	6dba      	ldr	r2, [r7, #88]	; 0x58
 800d800:	429a      	cmp	r2, r3
 800d802:	f47f ae46 	bne.w	800d492 <_nx_tcp_packet_process+0x31e>
    }

#ifndef NX_DISABLE_TCP_INFO

    /* Determine if a connection request is present.  */
    if (tcp_header_ptr -> nx_tcp_header_word_3 & NX_TCP_SYN_BIT)
 800d806:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800d808:	68db      	ldr	r3, [r3, #12]
 800d80a:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
 800d80e:	2b00      	cmp	r3, #0
 800d810:	d006      	beq.n	800d820 <_nx_tcp_packet_process+0x6ac>
    {

        /* Yes, increment the TCP connections dropped count.  */
        ip_ptr -> nx_ip_tcp_connections_dropped++;
 800d812:	687b      	ldr	r3, [r7, #4]
 800d814:	f8d3 30d4 	ldr.w	r3, [r3, #212]	; 0xd4
 800d818:	1c5a      	adds	r2, r3, #1
 800d81a:	687b      	ldr	r3, [r7, #4]
 800d81c:	f8c3 20d4 	str.w	r2, [r3, #212]	; 0xd4
    }

    /* Increment the TCP dropped packet count.  */
    ip_ptr -> nx_ip_tcp_receive_packets_dropped++;
 800d820:	687b      	ldr	r3, [r7, #4]
 800d822:	f8d3 30bc 	ldr.w	r3, [r3, #188]	; 0xbc
 800d826:	1c5a      	adds	r2, r3, #1
 800d828:	687b      	ldr	r3, [r7, #4]
 800d82a:	f8c3 20bc 	str.w	r2, [r3, #188]	; 0xbc
#endif /* NX_DISABLE_TCP_INFO  */

    /* Determine if a RST is present. If so, don't send a RST in response.  */
    if (!(tcp_header_ptr -> nx_tcp_header_word_3 & NX_TCP_RST_BIT))
 800d82e:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800d830:	68db      	ldr	r3, [r3, #12]
 800d832:	f403 2380 	and.w	r3, r3, #262144	; 0x40000
 800d836:	2b00      	cmp	r3, #0
 800d838:	d104      	bne.n	800d844 <_nx_tcp_packet_process+0x6d0>
    {

        /* Non RST is present, send reset when no connection is present.  */
        _nx_tcp_no_connection_reset(ip_ptr, packet_ptr, tcp_header_ptr);
 800d83a:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 800d83c:	6839      	ldr	r1, [r7, #0]
 800d83e:	6878      	ldr	r0, [r7, #4]
 800d840:	f7ff fbbf 	bl	800cfc2 <_nx_tcp_no_connection_reset>
    }

    /* Not a connection request, just release the packet.  */
    _nx_packet_release(packet_ptr);
 800d844:	6838      	ldr	r0, [r7, #0]
 800d846:	f7fe fddf 	bl	800c408 <_nx_packet_release>

    return;
 800d84a:	e000      	b.n	800d84e <_nx_tcp_packet_process+0x6da>
                return;
 800d84c:	bf00      	nop
}
 800d84e:	3768      	adds	r7, #104	; 0x68
 800d850:	46bd      	mov	sp, r7
 800d852:	bd80      	pop	{r7, pc}

0800d854 <_nx_tcp_packet_receive>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
VOID  _nx_tcp_packet_receive(NX_IP *ip_ptr, NX_PACKET *packet_ptr)
{
 800d854:	b580      	push	{r7, lr}
 800d856:	b088      	sub	sp, #32
 800d858:	af00      	add	r7, sp, #0
 800d85a:	6078      	str	r0, [r7, #4]
 800d85c:	6039      	str	r1, [r7, #0]
    NX_PACKET_DEBUG(__FILE__, __LINE__, packet_ptr);

#ifndef NX_DISABLE_RX_SIZE_CHECKING

    /* Check for valid packet length.  */
    if (packet_ptr -> nx_packet_length < sizeof(NX_TCP_HEADER))
 800d85e:	683b      	ldr	r3, [r7, #0]
 800d860:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800d862:	2b13      	cmp	r3, #19
 800d864:	d80a      	bhi.n	800d87c <_nx_tcp_packet_receive+0x28>
    {

#ifndef NX_DISABLE_TCP_INFO
        /* Increment the TCP invalid packet error.  */
        ip_ptr -> nx_ip_tcp_invalid_packets++;
 800d866:	687b      	ldr	r3, [r7, #4]
 800d868:	f8d3 30b8 	ldr.w	r3, [r3, #184]	; 0xb8
 800d86c:	1c5a      	adds	r2, r3, #1
 800d86e:	687b      	ldr	r3, [r7, #4]
 800d870:	f8c3 20b8 	str.w	r2, [r3, #184]	; 0xb8
#endif

        /* Invalid packet length, just release it.  */
        _nx_packet_release(packet_ptr);
 800d874:	6838      	ldr	r0, [r7, #0]
 800d876:	f7fe fdc7 	bl	800c408 <_nx_packet_release>

        /* The function is complete, just return!  */
        return;
 800d87a:	e052      	b.n	800d922 <_nx_tcp_packet_receive+0xce>
    __asm__ volatile (" MRS  %0,IPSR ": "=r" (ipsr_value) );
 800d87c:	f3ef 8305 	mrs	r3, IPSR
 800d880:	61bb      	str	r3, [r7, #24]
    return(ipsr_value);
 800d882:	69ba      	ldr	r2, [r7, #24]
    }
#endif

    /* Determine if this routine is being called from an ISR.  */
    if ((TX_THREAD_GET_SYSTEM_STATE()) || (&(ip_ptr -> nx_ip_thread) != _tx_thread_current_ptr))
 800d884:	4b28      	ldr	r3, [pc, #160]	; (800d928 <_nx_tcp_packet_receive+0xd4>)
 800d886:	681b      	ldr	r3, [r3, #0]
 800d888:	4313      	orrs	r3, r2
 800d88a:	2b00      	cmp	r3, #0
 800d88c:	d106      	bne.n	800d89c <_nx_tcp_packet_receive+0x48>
 800d88e:	687b      	ldr	r3, [r7, #4]
 800d890:	f503 72cc 	add.w	r2, r3, #408	; 0x198
 800d894:	4b25      	ldr	r3, [pc, #148]	; (800d92c <_nx_tcp_packet_receive+0xd8>)
 800d896:	681b      	ldr	r3, [r3, #0]
 800d898:	429a      	cmp	r2, r3
 800d89a:	d03e      	beq.n	800d91a <_nx_tcp_packet_receive+0xc6>
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 800d89c:	f3ef 8310 	mrs	r3, PRIMASK
 800d8a0:	617b      	str	r3, [r7, #20]
    return(posture);
 800d8a2:	697b      	ldr	r3, [r7, #20]
    int_posture = __get_interrupt_posture();
 800d8a4:	613b      	str	r3, [r7, #16]
    __asm__ volatile ("CPSID i" : : : "memory");
 800d8a6:	b672      	cpsid	i
    return(int_posture);
 800d8a8:	693b      	ldr	r3, [r7, #16]
        /* If system state is non-zero, we are in an ISR. If the current thread is not the IP thread,
           we need to prevent unnecessary recursion in loopback.  Just place the message at the
           end of the TCP message queue and wakeup the IP helper thread.  */

        /* Disable interrupts.  */
        TX_DISABLE
 800d8aa:	61fb      	str	r3, [r7, #28]

        /* Add the packet to the TCP message queue.  */
        if (ip_ptr -> nx_ip_tcp_queue_head)
 800d8ac:	687b      	ldr	r3, [r7, #4]
 800d8ae:	f8d3 34a4 	ldr.w	r3, [r3, #1188]	; 0x4a4
 800d8b2:	2b00      	cmp	r3, #0
 800d8b4:	d013      	beq.n	800d8de <_nx_tcp_packet_receive+0x8a>
        {

            /* Link the current packet at the end of the queue.  */
            (ip_ptr -> nx_ip_tcp_queue_tail) -> nx_packet_queue_next =  packet_ptr;
 800d8b6:	687b      	ldr	r3, [r7, #4]
 800d8b8:	f8d3 34a8 	ldr.w	r3, [r3, #1192]	; 0x4a8
 800d8bc:	683a      	ldr	r2, [r7, #0]
 800d8be:	61da      	str	r2, [r3, #28]
            ip_ptr -> nx_ip_tcp_queue_tail =                            packet_ptr;
 800d8c0:	687b      	ldr	r3, [r7, #4]
 800d8c2:	683a      	ldr	r2, [r7, #0]
 800d8c4:	f8c3 24a8 	str.w	r2, [r3, #1192]	; 0x4a8
            packet_ptr -> nx_packet_queue_next =                        NX_NULL;
 800d8c8:	683b      	ldr	r3, [r7, #0]
 800d8ca:	2200      	movs	r2, #0
 800d8cc:	61da      	str	r2, [r3, #28]

            /* Increment the count of incoming TCP packets queued.  */
            ip_ptr -> nx_ip_tcp_received_packet_count++;
 800d8ce:	687b      	ldr	r3, [r7, #4]
 800d8d0:	f8d3 34ac 	ldr.w	r3, [r3, #1196]	; 0x4ac
 800d8d4:	1c5a      	adds	r2, r3, #1
 800d8d6:	687b      	ldr	r3, [r7, #4]
 800d8d8:	f8c3 24ac 	str.w	r2, [r3, #1196]	; 0x4ac
 800d8dc:	e00e      	b.n	800d8fc <_nx_tcp_packet_receive+0xa8>
        }
        else
        {

            /* Empty queue, add to the head of the TCP message queue.  */
            ip_ptr -> nx_ip_tcp_queue_head =        packet_ptr;
 800d8de:	687b      	ldr	r3, [r7, #4]
 800d8e0:	683a      	ldr	r2, [r7, #0]
 800d8e2:	f8c3 24a4 	str.w	r2, [r3, #1188]	; 0x4a4
            ip_ptr -> nx_ip_tcp_queue_tail =        packet_ptr;
 800d8e6:	687b      	ldr	r3, [r7, #4]
 800d8e8:	683a      	ldr	r2, [r7, #0]
 800d8ea:	f8c3 24a8 	str.w	r2, [r3, #1192]	; 0x4a8
            packet_ptr -> nx_packet_queue_next =    NX_NULL;
 800d8ee:	683b      	ldr	r3, [r7, #0]
 800d8f0:	2200      	movs	r2, #0
 800d8f2:	61da      	str	r2, [r3, #28]

            /* Set the initial count TCP packets queued.  */
            ip_ptr -> nx_ip_tcp_received_packet_count =  1;
 800d8f4:	687b      	ldr	r3, [r7, #4]
 800d8f6:	2201      	movs	r2, #1
 800d8f8:	f8c3 24ac 	str.w	r2, [r3, #1196]	; 0x4ac
 800d8fc:	69fb      	ldr	r3, [r7, #28]
 800d8fe:	60fb      	str	r3, [r7, #12]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 800d900:	68fb      	ldr	r3, [r7, #12]
 800d902:	f383 8810 	msr	PRIMASK, r3
}
 800d906:	bf00      	nop

        /* Restore interrupts.  */
        TX_RESTORE

        /* Wakeup IP thread for processing one or more messages in the TCP queue.  */
        tx_event_flags_set(&(ip_ptr -> nx_ip_events), NX_IP_TCP_EVENT, TX_OR);
 800d908:	687b      	ldr	r3, [r7, #4]
 800d90a:	f503 7313 	add.w	r3, r3, #588	; 0x24c
 800d90e:	2200      	movs	r2, #0
 800d910:	2180      	movs	r1, #128	; 0x80
 800d912:	4618      	mov	r0, r3
 800d914:	f004 fdea 	bl	80124ec <_tx_event_flags_set>
 800d918:	e003      	b.n	800d922 <_nx_tcp_packet_receive+0xce>
    else
    {

        /* The IP message was deferred, so this routine is called from the IP helper
           thread and thus may call the TCP processing directly.  */
        _nx_tcp_packet_process(ip_ptr, packet_ptr);
 800d91a:	6839      	ldr	r1, [r7, #0]
 800d91c:	6878      	ldr	r0, [r7, #4]
 800d91e:	f7ff fc29 	bl	800d174 <_nx_tcp_packet_process>
    }
}
 800d922:	3720      	adds	r7, #32
 800d924:	46bd      	mov	sp, r7
 800d926:	bd80      	pop	{r7, pc}
 800d928:	24000078 	.word	0x24000078
 800d92c:	24031bc4 	.word	0x24031bc4

0800d930 <_nx_tcp_packet_send_ack>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
VOID  _nx_tcp_packet_send_ack(NX_TCP_SOCKET *socket_ptr, ULONG tx_sequence)
{
 800d930:	b580      	push	{r7, lr}
 800d932:	b086      	sub	sp, #24
 800d934:	af04      	add	r7, sp, #16
 800d936:	6078      	str	r0, [r7, #4]
 800d938:	6039      	str	r1, [r7, #0]
    _nx_tcp_packet_send_control(socket_ptr, NX_TCP_ACK_BIT, tx_sequence,
 800d93a:	687b      	ldr	r3, [r7, #4]
 800d93c:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 800d93e:	2200      	movs	r2, #0
 800d940:	9202      	str	r2, [sp, #8]
 800d942:	2200      	movs	r2, #0
 800d944:	9201      	str	r2, [sp, #4]
 800d946:	2200      	movs	r2, #0
 800d948:	9200      	str	r2, [sp, #0]
 800d94a:	683a      	ldr	r2, [r7, #0]
 800d94c:	f44f 1180 	mov.w	r1, #1048576	; 0x100000
 800d950:	6878      	ldr	r0, [r7, #4]
 800d952:	f000 f80b 	bl	800d96c <_nx_tcp_packet_send_control>
                                socket_ptr -> nx_tcp_socket_rx_sequence, 0, 0, NX_NULL);

    /* Setup a new delayed ACK timeout.  */
    socket_ptr -> nx_tcp_socket_delayed_ack_timeout =  _nx_tcp_ack_timer_rate;
 800d956:	4b04      	ldr	r3, [pc, #16]	; (800d968 <_nx_tcp_packet_send_ack+0x38>)
 800d958:	681a      	ldr	r2, [r3, #0]
 800d95a:	687b      	ldr	r3, [r7, #4]
 800d95c:	649a      	str	r2, [r3, #72]	; 0x48
}
 800d95e:	bf00      	nop
 800d960:	3708      	adds	r7, #8
 800d962:	46bd      	mov	sp, r7
 800d964:	bd80      	pop	{r7, pc}
 800d966:	bf00      	nop
 800d968:	24000b30 	.word	0x24000b30

0800d96c <_nx_tcp_packet_send_control>:
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
VOID  _nx_tcp_packet_send_control(NX_TCP_SOCKET *socket_ptr, ULONG control_bits, ULONG tx_sequence,
                                  ULONG ack_number, ULONG option_word_1, ULONG option_word_2, UCHAR *data)
{
 800d96c:	b5b0      	push	{r4, r5, r7, lr}
 800d96e:	b092      	sub	sp, #72	; 0x48
 800d970:	af04      	add	r7, sp, #16
 800d972:	60f8      	str	r0, [r7, #12]
 800d974:	60b9      	str	r1, [r7, #8]
 800d976:	607a      	str	r2, [r7, #4]
 800d978:	603b      	str	r3, [r7, #0]

NX_IP         *ip_ptr;
NX_PACKET     *packet_ptr;
NX_TCP_HEADER *tcp_header_ptr;
ULONG          checksum;
ULONG          data_offset = 0;
 800d97a:	2300      	movs	r3, #0
 800d97c:	627b      	str	r3, [r7, #36]	; 0x24
ULONG         *source_ip = NX_NULL, *dest_ip = NX_NULL;
 800d97e:	2300      	movs	r3, #0
 800d980:	637b      	str	r3, [r7, #52]	; 0x34
 800d982:	2300      	movs	r3, #0
 800d984:	633b      	str	r3, [r7, #48]	; 0x30
#ifdef NX_DISABLE_TCP_TX_CHECKSUM
    compute_checksum = 0;
#endif /* NX_DISABLE_TCP_TX_CHECKSUM */

    /* Setup the IP pointer.  */
    ip_ptr =  socket_ptr -> nx_tcp_socket_ip_ptr;
 800d986:	68fb      	ldr	r3, [r7, #12]
 800d988:	f8d3 30a0 	ldr.w	r3, [r3, #160]	; 0xa0
 800d98c:	623b      	str	r3, [r7, #32]

    if (control_bits & NX_TCP_SYN_BIT)
 800d98e:	68bb      	ldr	r3, [r7, #8]
 800d990:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
 800d994:	2b00      	cmp	r3, #0
 800d996:	d006      	beq.n	800d9a6 <_nx_tcp_packet_send_control+0x3a>
    {

        /* Set header size. */
        header_size = NX_TCP_SYN_HEADER;
 800d998:	f04f 43e0 	mov.w	r3, #1879048192	; 0x70000000
 800d99c:	62fb      	str	r3, [r7, #44]	; 0x2c
        window_size = socket_ptr -> nx_tcp_socket_rx_window_current;
 800d99e:	68fb      	ldr	r3, [r7, #12]
 800d9a0:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 800d9a2:	62bb      	str	r3, [r7, #40]	; 0x28
 800d9a4:	e005      	b.n	800d9b2 <_nx_tcp_packet_send_control+0x46>
    }
    else
    {

        /* Set header size. */
        header_size = NX_TCP_HEADER_SIZE;
 800d9a6:	f04f 43a0 	mov.w	r3, #1342177280	; 0x50000000
 800d9aa:	62fb      	str	r3, [r7, #44]	; 0x2c

        /* Set window size. */
#ifdef NX_ENABLE_TCP_WINDOW_SCALING
        window_size = socket_ptr -> nx_tcp_socket_rx_window_current >> socket_ptr -> nx_tcp_rcv_win_scale_value;
#else
        window_size = socket_ptr -> nx_tcp_socket_rx_window_current;
 800d9ac:	68fb      	ldr	r3, [r7, #12]
 800d9ae:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 800d9b0:	62bb      	str	r3, [r7, #40]	; 0x28
        if (ip_ptr -> nx_ip_auxiliary_packet_pool != ip_ptr -> nx_ip_default_packet_pool)
#endif /* NX_ENABLE_DUAL_PACKET_POOL */
        {

            /*lint -e{835} -e{845} suppress operating on zero. */
            if (_nx_packet_allocate(ip_ptr -> nx_ip_default_packet_pool,
 800d9b2:	6a3b      	ldr	r3, [r7, #32]
 800d9b4:	f8d3 0138 	ldr.w	r0, [r3, #312]	; 0x138
 800d9b8:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800d9ba:	f103 0224 	add.w	r2, r3, #36	; 0x24
 800d9be:	f107 0114 	add.w	r1, r7, #20
 800d9c2:	2300      	movs	r3, #0
 800d9c4:	f7fe f8bc 	bl	800bb40 <_nx_packet_allocate>
 800d9c8:	4603      	mov	r3, r0
 800d9ca:	2b00      	cmp	r3, #0
 800d9cc:	f040 80d0 	bne.w	800db70 <_nx_tcp_packet_send_control+0x204>
        }
    }
#endif /* NX_ENABLE_DUAL_PACKET_POOL */

    /* Check to see if the packet has enough room to fill with the max TCP header (SYN + probe data).  */
    if ((UINT)(packet_ptr -> nx_packet_data_end - packet_ptr -> nx_packet_prepend_ptr) < (NX_TCP_SYN_SIZE + 1))
 800d9d0:	697b      	ldr	r3, [r7, #20]
 800d9d2:	695a      	ldr	r2, [r3, #20]
 800d9d4:	697b      	ldr	r3, [r7, #20]
 800d9d6:	689b      	ldr	r3, [r3, #8]
 800d9d8:	1ad3      	subs	r3, r2, r3
 800d9da:	2b1c      	cmp	r3, #28
 800d9dc:	d804      	bhi.n	800d9e8 <_nx_tcp_packet_send_control+0x7c>
    {

        /* Error getting packet, so just get out!  */
        _nx_packet_release(packet_ptr);
 800d9de:	697b      	ldr	r3, [r7, #20]
 800d9e0:	4618      	mov	r0, r3
 800d9e2:	f7fe fd11 	bl	800c408 <_nx_packet_release>
        return;
 800d9e6:	e0c4      	b.n	800db72 <_nx_tcp_packet_send_control+0x206>
    }

    /*lint -e{644} suppress variable might not be initialized, since "packet_ptr" was initialized in _nx_packet_allocate. */
    packet_ptr -> nx_packet_ip_version = (UCHAR)(socket_ptr -> nx_tcp_socket_connect_ip.nxd_ip_version);
 800d9e8:	68fb      	ldr	r3, [r7, #12]
 800d9ea:	695a      	ldr	r2, [r3, #20]
 800d9ec:	697b      	ldr	r3, [r7, #20]
 800d9ee:	b2d2      	uxtb	r2, r2
 800d9f0:	f883 202c 	strb.w	r2, [r3, #44]	; 0x2c

    /* Allocate a packet for the control message.  */
#ifndef NX_DISABLE_IPV4
    if (socket_ptr -> nx_tcp_socket_connect_ip.nxd_ip_version == NX_IP_VERSION_V4)
 800d9f4:	68fb      	ldr	r3, [r7, #12]
 800d9f6:	695b      	ldr	r3, [r3, #20]
 800d9f8:	2b04      	cmp	r3, #4
 800d9fa:	d103      	bne.n	800da04 <_nx_tcp_packet_send_control+0x98>
    {

        /* The outgoing interface should have been stored in the socket structure. */
        packet_ptr -> nx_packet_address.nx_packet_interface_ptr = socket_ptr -> nx_tcp_socket_connect_interface;
 800d9fc:	697b      	ldr	r3, [r7, #20]
 800d9fe:	68fa      	ldr	r2, [r7, #12]
 800da00:	6a92      	ldr	r2, [r2, #40]	; 0x28
 800da02:	631a      	str	r2, [r3, #48]	; 0x30
#ifdef NX_IPSEC_ENABLE
    packet_ptr -> nx_packet_ipsec_sa_ptr = socket_ptr -> nx_tcp_socket_egress_sa;
#endif

    /* Setup the packet payload pointers and length for a basic TCP packet.  */
    packet_ptr -> nx_packet_append_ptr =  packet_ptr -> nx_packet_prepend_ptr + sizeof(NX_TCP_HEADER);
 800da04:	697b      	ldr	r3, [r7, #20]
 800da06:	689a      	ldr	r2, [r3, #8]
 800da08:	697b      	ldr	r3, [r7, #20]
 800da0a:	3214      	adds	r2, #20
 800da0c:	60da      	str	r2, [r3, #12]

    /* Setup the packet length.  */
    packet_ptr -> nx_packet_length =  sizeof(NX_TCP_HEADER);
 800da0e:	697b      	ldr	r3, [r7, #20]
 800da10:	2214      	movs	r2, #20
 800da12:	625a      	str	r2, [r3, #36]	; 0x24

    /* Pickup the pointer to the head of the TCP packet.  */
    /*lint -e{927} -e{826} suppress cast of pointer to pointer, since it is necessary  */
    tcp_header_ptr =  (NX_TCP_HEADER *)packet_ptr -> nx_packet_prepend_ptr;
 800da14:	697b      	ldr	r3, [r7, #20]
 800da16:	689b      	ldr	r3, [r3, #8]
 800da18:	61fb      	str	r3, [r7, #28]

    /* Build the control request in the TCP header.  */
    tcp_header_ptr -> nx_tcp_header_word_0 =        (((ULONG)(socket_ptr -> nx_tcp_socket_port)) << NX_SHIFT_BY_16) | (ULONG)socket_ptr -> nx_tcp_socket_connect_port;
 800da1a:	68fb      	ldr	r3, [r7, #12]
 800da1c:	68db      	ldr	r3, [r3, #12]
 800da1e:	041a      	lsls	r2, r3, #16
 800da20:	68fb      	ldr	r3, [r7, #12]
 800da22:	69db      	ldr	r3, [r3, #28]
 800da24:	431a      	orrs	r2, r3
 800da26:	69fb      	ldr	r3, [r7, #28]
 800da28:	601a      	str	r2, [r3, #0]
    tcp_header_ptr -> nx_tcp_sequence_number =      tx_sequence;
 800da2a:	69fb      	ldr	r3, [r7, #28]
 800da2c:	687a      	ldr	r2, [r7, #4]
 800da2e:	605a      	str	r2, [r3, #4]
    tcp_header_ptr -> nx_tcp_acknowledgment_number = ack_number;
 800da30:	69fb      	ldr	r3, [r7, #28]
 800da32:	683a      	ldr	r2, [r7, #0]
 800da34:	609a      	str	r2, [r3, #8]
    tcp_header_ptr -> nx_tcp_header_word_3 =        header_size | control_bits | window_size;
 800da36:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 800da38:	68bb      	ldr	r3, [r7, #8]
 800da3a:	431a      	orrs	r2, r3
 800da3c:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800da3e:	431a      	orrs	r2, r3
 800da40:	69fb      	ldr	r3, [r7, #28]
 800da42:	60da      	str	r2, [r3, #12]
    tcp_header_ptr -> nx_tcp_header_word_4 =        0;
 800da44:	69fb      	ldr	r3, [r7, #28]
 800da46:	2200      	movs	r2, #0
 800da48:	611a      	str	r2, [r3, #16]

    /* Remember the last ACKed sequence and the last reported window size.  */
    socket_ptr -> nx_tcp_socket_rx_sequence_acked =    ack_number;
 800da4a:	68fb      	ldr	r3, [r7, #12]
 800da4c:	683a      	ldr	r2, [r7, #0]
 800da4e:	645a      	str	r2, [r3, #68]	; 0x44
    socket_ptr -> nx_tcp_socket_rx_window_last_sent =  socket_ptr -> nx_tcp_socket_rx_window_current;
 800da50:	68fb      	ldr	r3, [r7, #12]
 800da52:	6f5a      	ldr	r2, [r3, #116]	; 0x74
 800da54:	68fb      	ldr	r3, [r7, #12]
 800da56:	679a      	str	r2, [r3, #120]	; 0x78

    /* Endian swapping logic.  If NX_LITTLE_ENDIAN is specified, these macros will
       swap the endian of the TCP header.  */
    NX_CHANGE_ULONG_ENDIAN(tcp_header_ptr -> nx_tcp_header_word_0);
 800da58:	69fb      	ldr	r3, [r7, #28]
 800da5a:	681b      	ldr	r3, [r3, #0]
 800da5c:	ba1a      	rev	r2, r3
 800da5e:	69fb      	ldr	r3, [r7, #28]
 800da60:	601a      	str	r2, [r3, #0]
    NX_CHANGE_ULONG_ENDIAN(tcp_header_ptr -> nx_tcp_sequence_number);
 800da62:	69fb      	ldr	r3, [r7, #28]
 800da64:	685b      	ldr	r3, [r3, #4]
 800da66:	ba1a      	rev	r2, r3
 800da68:	69fb      	ldr	r3, [r7, #28]
 800da6a:	605a      	str	r2, [r3, #4]
    NX_CHANGE_ULONG_ENDIAN(tcp_header_ptr -> nx_tcp_acknowledgment_number);
 800da6c:	69fb      	ldr	r3, [r7, #28]
 800da6e:	689b      	ldr	r3, [r3, #8]
 800da70:	ba1a      	rev	r2, r3
 800da72:	69fb      	ldr	r3, [r7, #28]
 800da74:	609a      	str	r2, [r3, #8]
    NX_CHANGE_ULONG_ENDIAN(tcp_header_ptr -> nx_tcp_header_word_3);
 800da76:	69fb      	ldr	r3, [r7, #28]
 800da78:	68db      	ldr	r3, [r3, #12]
 800da7a:	ba1a      	rev	r2, r3
 800da7c:	69fb      	ldr	r3, [r7, #28]
 800da7e:	60da      	str	r2, [r3, #12]
    NX_CHANGE_ULONG_ENDIAN(tcp_header_ptr -> nx_tcp_header_word_4);
 800da80:	69fb      	ldr	r3, [r7, #28]
 800da82:	691b      	ldr	r3, [r3, #16]
 800da84:	ba1a      	rev	r2, r3
 800da86:	69fb      	ldr	r3, [r7, #28]
 800da88:	611a      	str	r2, [r3, #16]

    /* Check whether or not data is set. */
    if (data)
 800da8a:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 800da8c:	2b00      	cmp	r3, #0
 800da8e:	d00a      	beq.n	800daa6 <_nx_tcp_packet_send_control+0x13a>
    {

        /* Zero window probe data exist. */
        *packet_ptr -> nx_packet_append_ptr++ = *data;
 800da90:	697a      	ldr	r2, [r7, #20]
 800da92:	68d3      	ldr	r3, [r2, #12]
 800da94:	1c59      	adds	r1, r3, #1
 800da96:	60d1      	str	r1, [r2, #12]
 800da98:	6d3a      	ldr	r2, [r7, #80]	; 0x50
 800da9a:	7812      	ldrb	r2, [r2, #0]
 800da9c:	701a      	strb	r2, [r3, #0]
        packet_ptr -> nx_packet_length++;
 800da9e:	697b      	ldr	r3, [r7, #20]
 800daa0:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 800daa2:	3201      	adds	r2, #1
 800daa4:	625a      	str	r2, [r3, #36]	; 0x24
    }

    /* Whether it is a SYN packet. */
    if (control_bits & NX_TCP_SYN_BIT)
 800daa6:	68bb      	ldr	r3, [r7, #8]
 800daa8:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
 800daac:	2b00      	cmp	r3, #0
 800daae:	d018      	beq.n	800dae2 <_nx_tcp_packet_send_control+0x176>
    {

        /* Endian swapping logic.  If NX_LITTLE_ENDIAN is specified, these macros will
           swap the endian of the TCP header.  */
        NX_CHANGE_ULONG_ENDIAN(option_word_1);
 800dab0:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 800dab2:	ba1b      	rev	r3, r3
 800dab4:	64bb      	str	r3, [r7, #72]	; 0x48
        NX_CHANGE_ULONG_ENDIAN(option_word_2);
 800dab6:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800dab8:	ba1b      	rev	r3, r3
 800daba:	64fb      	str	r3, [r7, #76]	; 0x4c

        /* Set options. */
        /*lint --e{927} --e{826} suppress cast of pointer to pointer, since it is necessary  */
        *((ULONG *)packet_ptr -> nx_packet_append_ptr) = option_word_1;
 800dabc:	697b      	ldr	r3, [r7, #20]
 800dabe:	68db      	ldr	r3, [r3, #12]
 800dac0:	6cba      	ldr	r2, [r7, #72]	; 0x48
 800dac2:	601a      	str	r2, [r3, #0]
        *(((ULONG *)packet_ptr -> nx_packet_append_ptr) + 1) = option_word_2;
 800dac4:	697b      	ldr	r3, [r7, #20]
 800dac6:	68db      	ldr	r3, [r3, #12]
 800dac8:	3304      	adds	r3, #4
 800daca:	6cfa      	ldr	r2, [r7, #76]	; 0x4c
 800dacc:	601a      	str	r2, [r3, #0]

        /* Adjust packet information. */
        packet_ptr -> nx_packet_append_ptr += (sizeof(ULONG) << 1);
 800dace:	697b      	ldr	r3, [r7, #20]
 800dad0:	68da      	ldr	r2, [r3, #12]
 800dad2:	697b      	ldr	r3, [r7, #20]
 800dad4:	3208      	adds	r2, #8
 800dad6:	60da      	str	r2, [r3, #12]
        packet_ptr -> nx_packet_length += (ULONG)(sizeof(ULONG) << 1);
 800dad8:	697b      	ldr	r3, [r7, #20]
 800dada:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 800dadc:	697b      	ldr	r3, [r7, #20]
 800dade:	3208      	adds	r2, #8
 800dae0:	625a      	str	r2, [r3, #36]	; 0x24
    {


        /* Set the packet source IP address. */
#ifndef NX_DISABLE_IPV4
        if (socket_ptr -> nx_tcp_socket_connect_ip.nxd_ip_version == NX_IP_VERSION_V4)
 800dae2:	68fb      	ldr	r3, [r7, #12]
 800dae4:	695b      	ldr	r3, [r3, #20]
 800dae6:	2b04      	cmp	r3, #4
 800dae8:	d106      	bne.n	800daf8 <_nx_tcp_packet_send_control+0x18c>
        {

            /* For IPv4 the IP instance has only one global address. */
            source_ip = &socket_ptr -> nx_tcp_socket_connect_interface -> nx_interface_ip_address;
 800daea:	68fb      	ldr	r3, [r7, #12]
 800daec:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 800daee:	3314      	adds	r3, #20
 800daf0:	637b      	str	r3, [r7, #52]	; 0x34

            /* Set the destination address to the other side of the TCP connection. */
            dest_ip = &socket_ptr -> nx_tcp_socket_connect_ip.nxd_ip_address.v4;
 800daf2:	68fb      	ldr	r3, [r7, #12]
 800daf4:	3318      	adds	r3, #24
 800daf6:	633b      	str	r3, [r7, #48]	; 0x30
            dest_ip = socket_ptr -> nx_tcp_socket_connect_ip.nxd_ip_address.v6;
        }
#endif /* FEATURE_NX_IPV6 */

        /* Calculate the TCP checksum.  */
        checksum =  _nx_ip_checksum_compute(packet_ptr, NX_PROTOCOL_TCP,
 800daf8:	6978      	ldr	r0, [r7, #20]
                                            (UINT)packet_ptr -> nx_packet_length, source_ip, dest_ip);
 800dafa:	697b      	ldr	r3, [r7, #20]
 800dafc:	6a5a      	ldr	r2, [r3, #36]	; 0x24
        checksum =  _nx_ip_checksum_compute(packet_ptr, NX_PROTOCOL_TCP,
 800dafe:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800db00:	9300      	str	r3, [sp, #0]
 800db02:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800db04:	2106      	movs	r1, #6
 800db06:	f7fc f88f 	bl	8009c28 <_nx_ip_checksum_compute>
 800db0a:	4603      	mov	r3, r0
 800db0c:	61bb      	str	r3, [r7, #24]

        checksum = ~checksum & NX_LOWER_16_MASK;
 800db0e:	69bb      	ldr	r3, [r7, #24]
 800db10:	43db      	mvns	r3, r3
 800db12:	b29b      	uxth	r3, r3
 800db14:	61bb      	str	r3, [r7, #24]

        /* Move the checksum into header.  */
        NX_CHANGE_ULONG_ENDIAN(tcp_header_ptr -> nx_tcp_header_word_4);
 800db16:	69fb      	ldr	r3, [r7, #28]
 800db18:	691b      	ldr	r3, [r3, #16]
 800db1a:	ba1a      	rev	r2, r3
 800db1c:	69fb      	ldr	r3, [r7, #28]
 800db1e:	611a      	str	r2, [r3, #16]
        tcp_header_ptr -> nx_tcp_header_word_4 =  (checksum << NX_SHIFT_BY_16);
 800db20:	69bb      	ldr	r3, [r7, #24]
 800db22:	041a      	lsls	r2, r3, #16
 800db24:	69fb      	ldr	r3, [r7, #28]
 800db26:	611a      	str	r2, [r3, #16]
        NX_CHANGE_ULONG_ENDIAN(tcp_header_ptr -> nx_tcp_header_word_4);
 800db28:	69fb      	ldr	r3, [r7, #28]
 800db2a:	691b      	ldr	r3, [r3, #16]
 800db2c:	ba1a      	rev	r2, r3
 800db2e:	69fb      	ldr	r3, [r7, #28]
 800db30:	611a      	str	r2, [r3, #16]
    }
#endif /* NX_ENABLE_INTERFACE_CAPABILITY  */

#ifndef NX_DISABLE_IPV4
    /* Send the TCP packet to the IP component.  */
    if (socket_ptr -> nx_tcp_socket_connect_ip.nxd_ip_version == NX_IP_VERSION_V4)
 800db32:	68fb      	ldr	r3, [r7, #12]
 800db34:	695b      	ldr	r3, [r3, #20]
 800db36:	2b04      	cmp	r3, #4
 800db38:	d11b      	bne.n	800db72 <_nx_tcp_packet_send_control+0x206>
    {

        _nx_ip_packet_send(ip_ptr, packet_ptr, socket_ptr -> nx_tcp_socket_connect_ip.nxd_ip_address.v4,
 800db3a:	6978      	ldr	r0, [r7, #20]
 800db3c:	68fb      	ldr	r3, [r7, #12]
 800db3e:	699c      	ldr	r4, [r3, #24]
 800db40:	68fb      	ldr	r3, [r7, #12]
 800db42:	f8d3 50a4 	ldr.w	r5, [r3, #164]	; 0xa4
                           socket_ptr -> nx_tcp_socket_type_of_service, socket_ptr -> nx_tcp_socket_time_to_live, NX_IP_TCP,
 800db46:	68fb      	ldr	r3, [r7, #12]
 800db48:	f8d3 30a8 	ldr.w	r3, [r3, #168]	; 0xa8
        _nx_ip_packet_send(ip_ptr, packet_ptr, socket_ptr -> nx_tcp_socket_connect_ip.nxd_ip_address.v4,
 800db4c:	68fa      	ldr	r2, [r7, #12]
 800db4e:	f8d2 20ac 	ldr.w	r2, [r2, #172]	; 0xac
 800db52:	68f9      	ldr	r1, [r7, #12]
 800db54:	6ac9      	ldr	r1, [r1, #44]	; 0x2c
 800db56:	9103      	str	r1, [sp, #12]
 800db58:	9202      	str	r2, [sp, #8]
 800db5a:	f44f 22c0 	mov.w	r2, #393216	; 0x60000
 800db5e:	9201      	str	r2, [sp, #4]
 800db60:	9300      	str	r3, [sp, #0]
 800db62:	462b      	mov	r3, r5
 800db64:	4622      	mov	r2, r4
 800db66:	4601      	mov	r1, r0
 800db68:	6a38      	ldr	r0, [r7, #32]
 800db6a:	f7fd f8e1 	bl	800ad30 <_nx_ip_packet_send>
 800db6e:	e000      	b.n	800db72 <_nx_tcp_packet_send_control+0x206>
                return;
 800db70:	bf00      	nop
        _nx_ipv6_packet_send(ip_ptr, packet_ptr, NX_PROTOCOL_TCP, packet_ptr -> nx_packet_length, ip_ptr -> nx_ipv6_hop_limit,
                             socket_ptr -> nx_tcp_socket_ipv6_addr -> nxd_ipv6_address,
                             socket_ptr -> nx_tcp_socket_connect_ip.nxd_ip_address.v6);
    }
#endif /* FEATURE_NX_IPV6 */
}
 800db72:	3738      	adds	r7, #56	; 0x38
 800db74:	46bd      	mov	sp, r7
 800db76:	bdb0      	pop	{r4, r5, r7, pc}

0800db78 <_nx_tcp_packet_send_fin>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
VOID  _nx_tcp_packet_send_fin(NX_TCP_SOCKET *socket_ptr, ULONG tx_sequence)
{
 800db78:	b580      	push	{r7, lr}
 800db7a:	b086      	sub	sp, #24
 800db7c:	af04      	add	r7, sp, #16
 800db7e:	6078      	str	r0, [r7, #4]
 800db80:	6039      	str	r1, [r7, #0]
    _nx_tcp_packet_send_control(socket_ptr, (NX_TCP_FIN_BIT | NX_TCP_ACK_BIT), tx_sequence,
 800db82:	687b      	ldr	r3, [r7, #4]
 800db84:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 800db86:	2200      	movs	r2, #0
 800db88:	9202      	str	r2, [sp, #8]
 800db8a:	2200      	movs	r2, #0
 800db8c:	9201      	str	r2, [sp, #4]
 800db8e:	2200      	movs	r2, #0
 800db90:	9200      	str	r2, [sp, #0]
 800db92:	683a      	ldr	r2, [r7, #0]
 800db94:	f44f 1188 	mov.w	r1, #1114112	; 0x110000
 800db98:	6878      	ldr	r0, [r7, #4]
 800db9a:	f7ff fee7 	bl	800d96c <_nx_tcp_packet_send_control>
                                socket_ptr -> nx_tcp_socket_rx_sequence, 0, 0, NX_NULL);
}
 800db9e:	bf00      	nop
 800dba0:	3708      	adds	r7, #8
 800dba2:	46bd      	mov	sp, r7
 800dba4:	bd80      	pop	{r7, pc}
	...

0800dba8 <_nx_tcp_packet_send_probe>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
VOID  _nx_tcp_packet_send_probe(NX_TCP_SOCKET *socket_ptr, ULONG tx_sequence, UCHAR data)
{
 800dba8:	b580      	push	{r7, lr}
 800dbaa:	b088      	sub	sp, #32
 800dbac:	af04      	add	r7, sp, #16
 800dbae:	60f8      	str	r0, [r7, #12]
 800dbb0:	60b9      	str	r1, [r7, #8]
 800dbb2:	4613      	mov	r3, r2
 800dbb4:	71fb      	strb	r3, [r7, #7]

    _nx_tcp_packet_send_control(socket_ptr, NX_TCP_ACK_BIT, tx_sequence,
 800dbb6:	68fb      	ldr	r3, [r7, #12]
 800dbb8:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 800dbba:	1dfb      	adds	r3, r7, #7
 800dbbc:	9302      	str	r3, [sp, #8]
 800dbbe:	2300      	movs	r3, #0
 800dbc0:	9301      	str	r3, [sp, #4]
 800dbc2:	2300      	movs	r3, #0
 800dbc4:	9300      	str	r3, [sp, #0]
 800dbc6:	4613      	mov	r3, r2
 800dbc8:	68ba      	ldr	r2, [r7, #8]
 800dbca:	f44f 1180 	mov.w	r1, #1048576	; 0x100000
 800dbce:	68f8      	ldr	r0, [r7, #12]
 800dbd0:	f7ff fecc 	bl	800d96c <_nx_tcp_packet_send_control>
                                socket_ptr -> nx_tcp_socket_rx_sequence, 0, 0, &data);

    /* Setup a new delayed ACK timeout.  */
    socket_ptr -> nx_tcp_socket_delayed_ack_timeout =  _nx_tcp_ack_timer_rate;
 800dbd4:	4b03      	ldr	r3, [pc, #12]	; (800dbe4 <_nx_tcp_packet_send_probe+0x3c>)
 800dbd6:	681a      	ldr	r2, [r3, #0]
 800dbd8:	68fb      	ldr	r3, [r7, #12]
 800dbda:	649a      	str	r2, [r3, #72]	; 0x48
}
 800dbdc:	bf00      	nop
 800dbde:	3710      	adds	r7, #16
 800dbe0:	46bd      	mov	sp, r7
 800dbe2:	bd80      	pop	{r7, pc}
 800dbe4:	24000b30 	.word	0x24000b30

0800dbe8 <_nx_tcp_packet_send_rst>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
VOID  _nx_tcp_packet_send_rst(NX_TCP_SOCKET *socket_ptr, NX_TCP_HEADER *header_ptr)
{
 800dbe8:	b580      	push	{r7, lr}
 800dbea:	b086      	sub	sp, #24
 800dbec:	af04      	add	r7, sp, #16
 800dbee:	6078      	str	r0, [r7, #4]
 800dbf0:	6039      	str	r1, [r7, #0]
    /* Reset Generation, RFC793, Section3.4, Page37, the RST packet is set up based on if the incoming packet has the ACK bit set. */
    /* If the incoming segment has an ACK field, the reset takes its sequence number from the ACK field of the segment,
       otherwise the reset has sequence number zero and the ACK field is set to the sum of the sequence number and segment length of the incoming segment.  */

    /* Check for the ACK bit in the incoming TCP header.  */
    if (header_ptr -> nx_tcp_header_word_3 & NX_TCP_ACK_BIT)
 800dbf2:	683b      	ldr	r3, [r7, #0]
 800dbf4:	68db      	ldr	r3, [r3, #12]
 800dbf6:	f403 1380 	and.w	r3, r3, #1048576	; 0x100000
 800dbfa:	2b00      	cmp	r3, #0
 800dbfc:	d00e      	beq.n	800dc1c <_nx_tcp_packet_send_rst+0x34>
    {
        _nx_tcp_packet_send_control(socket_ptr, NX_TCP_RST_BIT, header_ptr -> nx_tcp_acknowledgment_number,
 800dbfe:	683b      	ldr	r3, [r7, #0]
 800dc00:	689a      	ldr	r2, [r3, #8]
 800dc02:	2300      	movs	r3, #0
 800dc04:	9302      	str	r3, [sp, #8]
 800dc06:	2300      	movs	r3, #0
 800dc08:	9301      	str	r3, [sp, #4]
 800dc0a:	2300      	movs	r3, #0
 800dc0c:	9300      	str	r3, [sp, #0]
 800dc0e:	2300      	movs	r3, #0
 800dc10:	f44f 2180 	mov.w	r1, #262144	; 0x40000
 800dc14:	6878      	ldr	r0, [r7, #4]
 800dc16:	f7ff fea9 	bl	800d96c <_nx_tcp_packet_send_control>
 800dc1a:	e00d      	b.n	800dc38 <_nx_tcp_packet_send_rst+0x50>
                                    0, 0, 0, NX_NULL);
    }
    else
    {
        _nx_tcp_packet_send_control(socket_ptr, (NX_TCP_RST_BIT | NX_TCP_ACK_BIT), 0,
 800dc1c:	683b      	ldr	r3, [r7, #0]
 800dc1e:	685b      	ldr	r3, [r3, #4]
 800dc20:	2200      	movs	r2, #0
 800dc22:	9202      	str	r2, [sp, #8]
 800dc24:	2200      	movs	r2, #0
 800dc26:	9201      	str	r2, [sp, #4]
 800dc28:	2200      	movs	r2, #0
 800dc2a:	9200      	str	r2, [sp, #0]
 800dc2c:	2200      	movs	r2, #0
 800dc2e:	f44f 11a0 	mov.w	r1, #1310720	; 0x140000
 800dc32:	6878      	ldr	r0, [r7, #4]
 800dc34:	f7ff fe9a 	bl	800d96c <_nx_tcp_packet_send_control>
                                    header_ptr -> nx_tcp_sequence_number, 0, 0, NX_NULL);
    }

#ifndef NX_DISABLE_TCP_INFO
    /* Increment the resets sent count.  */
    socket_ptr -> nx_tcp_socket_ip_ptr -> nx_ip_tcp_resets_sent++;
 800dc38:	687b      	ldr	r3, [r7, #4]
 800dc3a:	f8d3 30a0 	ldr.w	r3, [r3, #160]	; 0xa0
 800dc3e:	f8d3 20e0 	ldr.w	r2, [r3, #224]	; 0xe0
 800dc42:	3201      	adds	r2, #1
 800dc44:	f8c3 20e0 	str.w	r2, [r3, #224]	; 0xe0
#endif /* NX_DISABLE_TCP_INFO */
}
 800dc48:	bf00      	nop
 800dc4a:	3708      	adds	r7, #8
 800dc4c:	46bd      	mov	sp, r7
 800dc4e:	bd80      	pop	{r7, pc}

0800dc50 <_nx_tcp_packet_send_syn>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
VOID  _nx_tcp_packet_send_syn(NX_TCP_SOCKET *socket_ptr, ULONG tx_sequence)
{
 800dc50:	b580      	push	{r7, lr}
 800dc52:	b08a      	sub	sp, #40	; 0x28
 800dc54:	af04      	add	r7, sp, #16
 800dc56:	6078      	str	r0, [r7, #4]
 800dc58:	6039      	str	r1, [r7, #0]
ULONG        option_word_2;
#ifdef NX_ENABLE_TCP_WINDOW_SCALING
UINT         include_window_scaling = NX_FALSE;
UINT         scale_factor;
#endif /* NX_ENABLE_TCP_WINDOW_SCALING */
ULONG        mss = 0;
 800dc5a:	2300      	movs	r3, #0
 800dc5c:	617b      	str	r3, [r7, #20]
    }
#endif /* NX_IPSEC_ENABLE */

#ifndef NX_DISABLE_IPV4
    /* Update the mss value based on IP version type. */
    if (socket_ptr -> nx_tcp_socket_connect_ip.nxd_ip_version == NX_IP_VERSION_V4)
 800dc5e:	687b      	ldr	r3, [r7, #4]
 800dc60:	695b      	ldr	r3, [r3, #20]
 800dc62:	2b04      	cmp	r3, #4
 800dc64:	d104      	bne.n	800dc70 <_nx_tcp_packet_send_syn+0x20>
    {
        mss = (ULONG)((socket_ptr -> nx_tcp_socket_connect_interface -> nx_interface_ip_mtu_size - sizeof(NX_IPV4_HEADER)) - sizeof(NX_TCP_HEADER));
 800dc66:	687b      	ldr	r3, [r7, #4]
 800dc68:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 800dc6a:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800dc6c:	3b28      	subs	r3, #40	; 0x28
 800dc6e:	617b      	str	r3, [r7, #20]
        }
#endif /* NX_IPSEC_ENABLE */
    }
#endif /* FEATURE_NX_IPV6 */

    mss &= 0x0000FFFFUL;
 800dc70:	697b      	ldr	r3, [r7, #20]
 800dc72:	b29b      	uxth	r3, r3
 800dc74:	617b      	str	r3, [r7, #20]

    if ((socket_ptr -> nx_tcp_socket_mss < mss) && socket_ptr -> nx_tcp_socket_mss)
 800dc76:	687b      	ldr	r3, [r7, #4]
 800dc78:	691b      	ldr	r3, [r3, #16]
 800dc7a:	697a      	ldr	r2, [r7, #20]
 800dc7c:	429a      	cmp	r2, r3
 800dc7e:	d906      	bls.n	800dc8e <_nx_tcp_packet_send_syn+0x3e>
 800dc80:	687b      	ldr	r3, [r7, #4]
 800dc82:	691b      	ldr	r3, [r3, #16]
 800dc84:	2b00      	cmp	r3, #0
 800dc86:	d002      	beq.n	800dc8e <_nx_tcp_packet_send_syn+0x3e>
    {

        /* Use the custom MSS. */
        mss = socket_ptr -> nx_tcp_socket_mss;
 800dc88:	687b      	ldr	r3, [r7, #4]
 800dc8a:	691b      	ldr	r3, [r3, #16]
 800dc8c:	617b      	str	r3, [r7, #20]
    }

    if (socket_ptr -> nx_tcp_socket_state == NX_TCP_SYN_RECEIVED)
 800dc8e:	687b      	ldr	r3, [r7, #4]
 800dc90:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 800dc92:	2b04      	cmp	r3, #4
 800dc94:	d115      	bne.n	800dcc2 <_nx_tcp_packet_send_syn+0x72>
    {

        /* Update the connect MSS for TCP server socket. */
        if (mss < socket_ptr -> nx_tcp_socket_peer_mss)
 800dc96:	687b      	ldr	r3, [r7, #4]
 800dc98:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800dc9a:	697a      	ldr	r2, [r7, #20]
 800dc9c:	429a      	cmp	r2, r3
 800dc9e:	d203      	bcs.n	800dca8 <_nx_tcp_packet_send_syn+0x58>
        {
            socket_ptr -> nx_tcp_socket_connect_mss  = mss;
 800dca0:	687b      	ldr	r3, [r7, #4]
 800dca2:	697a      	ldr	r2, [r7, #20]
 800dca4:	621a      	str	r2, [r3, #32]
 800dca6:	e003      	b.n	800dcb0 <_nx_tcp_packet_send_syn+0x60>
        }
        else
        {
            socket_ptr -> nx_tcp_socket_connect_mss =  socket_ptr -> nx_tcp_socket_peer_mss;
 800dca8:	687b      	ldr	r3, [r7, #4]
 800dcaa:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 800dcac:	687b      	ldr	r3, [r7, #4]
 800dcae:	621a      	str	r2, [r3, #32]
        }

        /* Compute the SMSS * SMSS value, so later TCP module doesn't need to redo the multiplication. */
        socket_ptr -> nx_tcp_socket_connect_mss2 =
            socket_ptr -> nx_tcp_socket_connect_mss * socket_ptr -> nx_tcp_socket_connect_mss;
 800dcb0:	687b      	ldr	r3, [r7, #4]
 800dcb2:	6a1b      	ldr	r3, [r3, #32]
 800dcb4:	687a      	ldr	r2, [r7, #4]
 800dcb6:	6a12      	ldr	r2, [r2, #32]
 800dcb8:	fb03 f202 	mul.w	r2, r3, r2
        socket_ptr -> nx_tcp_socket_connect_mss2 =
 800dcbc:	687b      	ldr	r3, [r7, #4]
 800dcbe:	631a      	str	r2, [r3, #48]	; 0x30
 800dcc0:	e002      	b.n	800dcc8 <_nx_tcp_packet_send_syn+0x78>
    }
    else
    {

        /* Set the MSS. */
        socket_ptr -> nx_tcp_socket_connect_mss = mss;
 800dcc2:	687b      	ldr	r3, [r7, #4]
 800dcc4:	697a      	ldr	r2, [r7, #20]
 800dcc6:	621a      	str	r2, [r3, #32]
    }

    /* Build the MSS option.  */
    option_word_1 = NX_TCP_MSS_OPTION | mss;
 800dcc8:	697b      	ldr	r3, [r7, #20]
 800dcca:	f043 7301 	orr.w	r3, r3, #33816576	; 0x2040000
 800dcce:	613b      	str	r3, [r7, #16]

    /* Set default option word2. */
    option_word_2 = NX_TCP_OPTION_END;
 800dcd0:	4b16      	ldr	r3, [pc, #88]	; (800dd2c <_nx_tcp_packet_send_syn+0xdc>)
 800dcd2:	60fb      	str	r3, [r7, #12]
        socket_ptr -> nx_tcp_rcv_win_scale_value = scale_factor;
    }
#endif /* NX_ENABLE_TCP_WINDOW_SCALING */

    /* Send SYN or SYN+ACK packet according to socket state. */
    if (socket_ptr -> nx_tcp_socket_state == NX_TCP_SYN_SENT)
 800dcd4:	687b      	ldr	r3, [r7, #4]
 800dcd6:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 800dcd8:	2b03      	cmp	r3, #3
 800dcda:	d10d      	bne.n	800dcf8 <_nx_tcp_packet_send_syn+0xa8>
    {
        _nx_tcp_packet_send_control(socket_ptr, NX_TCP_SYN_BIT, tx_sequence,
 800dcdc:	2300      	movs	r3, #0
 800dcde:	9302      	str	r3, [sp, #8]
 800dce0:	68fb      	ldr	r3, [r7, #12]
 800dce2:	9301      	str	r3, [sp, #4]
 800dce4:	693b      	ldr	r3, [r7, #16]
 800dce6:	9300      	str	r3, [sp, #0]
 800dce8:	2300      	movs	r3, #0
 800dcea:	683a      	ldr	r2, [r7, #0]
 800dcec:	f44f 3100 	mov.w	r1, #131072	; 0x20000
 800dcf0:	6878      	ldr	r0, [r7, #4]
 800dcf2:	f7ff fe3b 	bl	800d96c <_nx_tcp_packet_send_control>
 800dcf6:	e00e      	b.n	800dd16 <_nx_tcp_packet_send_syn+0xc6>
                                    0, option_word_1, option_word_2, NX_NULL);
    }
    else
    {
        _nx_tcp_packet_send_control(socket_ptr, (NX_TCP_SYN_BIT | NX_TCP_ACK_BIT), tx_sequence,
 800dcf8:	687b      	ldr	r3, [r7, #4]
 800dcfa:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 800dcfc:	2300      	movs	r3, #0
 800dcfe:	9302      	str	r3, [sp, #8]
 800dd00:	68fb      	ldr	r3, [r7, #12]
 800dd02:	9301      	str	r3, [sp, #4]
 800dd04:	693b      	ldr	r3, [r7, #16]
 800dd06:	9300      	str	r3, [sp, #0]
 800dd08:	4613      	mov	r3, r2
 800dd0a:	683a      	ldr	r2, [r7, #0]
 800dd0c:	f44f 1190 	mov.w	r1, #1179648	; 0x120000
 800dd10:	6878      	ldr	r0, [r7, #4]
 800dd12:	f7ff fe2b 	bl	800d96c <_nx_tcp_packet_send_control>
                                    socket_ptr -> nx_tcp_socket_rx_sequence, option_word_1, option_word_2, NX_NULL);
    }

    /* Initialize recover sequence and previous cumulative acknowledgment. */
    socket_ptr -> nx_tcp_socket_tx_sequence_recover = tx_sequence;
 800dd16:	687b      	ldr	r3, [r7, #4]
 800dd18:	683a      	ldr	r2, [r7, #0]
 800dd1a:	661a      	str	r2, [r3, #96]	; 0x60
    socket_ptr -> nx_tcp_socket_previous_highest_ack = tx_sequence;
 800dd1c:	687b      	ldr	r3, [r7, #4]
 800dd1e:	683a      	ldr	r2, [r7, #0]
 800dd20:	665a      	str	r2, [r3, #100]	; 0x64
}
 800dd22:	bf00      	nop
 800dd24:	3718      	adds	r7, #24
 800dd26:	46bd      	mov	sp, r7
 800dd28:	bd80      	pop	{r7, pc}
 800dd2a:	bf00      	nop
 800dd2c:	01010100 	.word	0x01010100

0800dd30 <_nx_tcp_periodic_processing>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
VOID  _nx_tcp_periodic_processing(NX_IP *ip_ptr)
{
 800dd30:	b480      	push	{r7}
 800dd32:	b083      	sub	sp, #12
 800dd34:	af00      	add	r7, sp, #0
 800dd36:	6078      	str	r0, [r7, #4]
        keepalive_enabled = socket_ptr -> nx_tcp_socket_keepalive_enabled;
    }
#else
    NX_PARAMETER_NOT_USED(ip_ptr);
#endif
}
 800dd38:	bf00      	nop
 800dd3a:	370c      	adds	r7, #12
 800dd3c:	46bd      	mov	sp, r7
 800dd3e:	f85d 7b04 	ldr.w	r7, [sp], #4
 800dd42:	4770      	bx	lr

0800dd44 <_nx_tcp_queue_process>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
VOID  _nx_tcp_queue_process(NX_IP *ip_ptr)
{
 800dd44:	b580      	push	{r7, lr}
 800dd46:	b088      	sub	sp, #32
 800dd48:	af00      	add	r7, sp, #0
 800dd4a:	6078      	str	r0, [r7, #4]
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 800dd4c:	f3ef 8310 	mrs	r3, PRIMASK
 800dd50:	60fb      	str	r3, [r7, #12]
    return(posture);
 800dd52:	68fb      	ldr	r3, [r7, #12]
    int_posture = __get_interrupt_posture();
 800dd54:	60bb      	str	r3, [r7, #8]
    __asm__ volatile ("CPSID i" : : : "memory");
 800dd56:	b672      	cpsid	i
    return(int_posture);
 800dd58:	68bb      	ldr	r3, [r7, #8]
NX_PACKET *queue_head;
NX_PACKET *packet_ptr;


    /* Disable interrupts.  */
    TX_DISABLE
 800dd5a:	61bb      	str	r3, [r7, #24]

    /* Remove the TCP message queue from the IP structure.  */
    queue_head =  ip_ptr -> nx_ip_tcp_queue_head;
 800dd5c:	687b      	ldr	r3, [r7, #4]
 800dd5e:	f8d3 34a4 	ldr.w	r3, [r3, #1188]	; 0x4a4
 800dd62:	61fb      	str	r3, [r7, #28]
    ip_ptr -> nx_ip_tcp_queue_head =  NX_NULL;
 800dd64:	687b      	ldr	r3, [r7, #4]
 800dd66:	2200      	movs	r2, #0
 800dd68:	f8c3 24a4 	str.w	r2, [r3, #1188]	; 0x4a4
    ip_ptr -> nx_ip_tcp_queue_tail =  NX_NULL;
 800dd6c:	687b      	ldr	r3, [r7, #4]
 800dd6e:	2200      	movs	r2, #0
 800dd70:	f8c3 24a8 	str.w	r2, [r3, #1192]	; 0x4a8
    ip_ptr -> nx_ip_tcp_received_packet_count =  0;
 800dd74:	687b      	ldr	r3, [r7, #4]
 800dd76:	2200      	movs	r2, #0
 800dd78:	f8c3 24ac 	str.w	r2, [r3, #1196]	; 0x4ac
 800dd7c:	69bb      	ldr	r3, [r7, #24]
 800dd7e:	613b      	str	r3, [r7, #16]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 800dd80:	693b      	ldr	r3, [r7, #16]
 800dd82:	f383 8810 	msr	PRIMASK, r3
}
 800dd86:	bf00      	nop
    /* Restore interrupts.  */
    TX_RESTORE

    /* Walk through the entire TCP message queue and process packets
       one by one.  */
    while (queue_head)
 800dd88:	e00b      	b.n	800dda2 <_nx_tcp_queue_process+0x5e>
    {

        /* Pickup the first queue TCP message and remove it from the
           TCP queue.  */
        packet_ptr =  queue_head;
 800dd8a:	69fb      	ldr	r3, [r7, #28]
 800dd8c:	617b      	str	r3, [r7, #20]
        queue_head =  queue_head -> nx_packet_queue_next;
 800dd8e:	69fb      	ldr	r3, [r7, #28]
 800dd90:	69db      	ldr	r3, [r3, #28]
 800dd92:	61fb      	str	r3, [r7, #28]
        packet_ptr -> nx_packet_queue_next =  NX_NULL;
 800dd94:	697b      	ldr	r3, [r7, #20]
 800dd96:	2200      	movs	r2, #0
 800dd98:	61da      	str	r2, [r3, #28]

        /* Add debug information. */
        NX_PACKET_DEBUG(__FILE__, __LINE__, packet_ptr);

        /* Process the packet.  */
        _nx_tcp_packet_process(ip_ptr, packet_ptr);
 800dd9a:	6979      	ldr	r1, [r7, #20]
 800dd9c:	6878      	ldr	r0, [r7, #4]
 800dd9e:	f7ff f9e9 	bl	800d174 <_nx_tcp_packet_process>
    while (queue_head)
 800dda2:	69fb      	ldr	r3, [r7, #28]
 800dda4:	2b00      	cmp	r3, #0
 800dda6:	d1f0      	bne.n	800dd8a <_nx_tcp_queue_process+0x46>
    }
}
 800dda8:	bf00      	nop
 800ddaa:	bf00      	nop
 800ddac:	3720      	adds	r7, #32
 800ddae:	46bd      	mov	sp, r7
 800ddb0:	bd80      	pop	{r7, pc}
	...

0800ddb4 <_nx_tcp_receive_cleanup>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
VOID  _nx_tcp_receive_cleanup(TX_THREAD *thread_ptr NX_CLEANUP_PARAMETER)
{
 800ddb4:	b580      	push	{r7, lr}
 800ddb6:	b08e      	sub	sp, #56	; 0x38
 800ddb8:	af00      	add	r7, sp, #0
 800ddba:	6078      	str	r0, [r7, #4]
 800ddbc:	6039      	str	r1, [r7, #0]
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 800ddbe:	f3ef 8310 	mrs	r3, PRIMASK
 800ddc2:	62bb      	str	r3, [r7, #40]	; 0x28
    return(posture);
 800ddc4:	6abb      	ldr	r3, [r7, #40]	; 0x28
    int_posture = __get_interrupt_posture();
 800ddc6:	627b      	str	r3, [r7, #36]	; 0x24
    __asm__ volatile ("CPSID i" : : : "memory");
 800ddc8:	b672      	cpsid	i
    return(int_posture);
 800ddca:	6a7b      	ldr	r3, [r7, #36]	; 0x24
NX_TCP_SOCKET *socket_ptr;  /* Working socket pointer  */

    NX_CLEANUP_EXTENSION

    /* Disable interrupts.  */
    TX_DISABLE
 800ddcc:	637b      	str	r3, [r7, #52]	; 0x34

    /* Setup pointer to TCP socket control block.  */
    socket_ptr =  (NX_TCP_SOCKET *)thread_ptr -> tx_thread_suspend_control_block;
 800ddce:	687b      	ldr	r3, [r7, #4]
 800ddd0:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 800ddd2:	633b      	str	r3, [r7, #48]	; 0x30

    /* Determine if the socket pointer is valid.  */
    if ((!socket_ptr) || (socket_ptr -> nx_tcp_socket_id != NX_TCP_ID))
 800ddd4:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800ddd6:	2b00      	cmp	r3, #0
 800ddd8:	d004      	beq.n	800dde4 <_nx_tcp_receive_cleanup+0x30>
 800ddda:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800dddc:	681b      	ldr	r3, [r3, #0]
 800ddde:	4a43      	ldr	r2, [pc, #268]	; (800deec <_nx_tcp_receive_cleanup+0x138>)
 800dde0:	4293      	cmp	r3, r2
 800dde2:	d006      	beq.n	800ddf2 <_nx_tcp_receive_cleanup+0x3e>
 800dde4:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800dde6:	623b      	str	r3, [r7, #32]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 800dde8:	6a3b      	ldr	r3, [r7, #32]
 800ddea:	f383 8810 	msr	PRIMASK, r3
}
 800ddee:	bf00      	nop
    {

        /* Restore interrupts.  */
        TX_RESTORE

        return;
 800ddf0:	e078      	b.n	800dee4 <_nx_tcp_receive_cleanup+0x130>
    }

    /* Determine if the cleanup is still required.  */
    if (!(thread_ptr -> tx_thread_suspend_cleanup))
 800ddf2:	687b      	ldr	r3, [r7, #4]
 800ddf4:	6e9b      	ldr	r3, [r3, #104]	; 0x68
 800ddf6:	2b00      	cmp	r3, #0
 800ddf8:	d106      	bne.n	800de08 <_nx_tcp_receive_cleanup+0x54>
 800ddfa:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800ddfc:	61fb      	str	r3, [r7, #28]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 800ddfe:	69fb      	ldr	r3, [r7, #28]
 800de00:	f383 8810 	msr	PRIMASK, r3
}
 800de04:	bf00      	nop
    {

        /* Restore interrupts.  */
        TX_RESTORE

        return;
 800de06:	e06d      	b.n	800dee4 <_nx_tcp_receive_cleanup+0x130>
    __asm__ volatile (" MRS  %0,IPSR ": "=r" (ipsr_value) );
 800de08:	f3ef 8305 	mrs	r3, IPSR
 800de0c:	61bb      	str	r3, [r7, #24]
    return(ipsr_value);
 800de0e:	69ba      	ldr	r2, [r7, #24]
    }

    /* Determine if the caller is an ISR or the system timer thread.  */
#ifndef TX_TIMER_PROCESS_IN_ISR
    if ((TX_THREAD_GET_SYSTEM_STATE()) || (_tx_thread_current_ptr == &_tx_timer_thread))
 800de10:	4b37      	ldr	r3, [pc, #220]	; (800def0 <_nx_tcp_receive_cleanup+0x13c>)
 800de12:	681b      	ldr	r3, [r3, #0]
 800de14:	4313      	orrs	r3, r2
 800de16:	2b00      	cmp	r3, #0
 800de18:	d104      	bne.n	800de24 <_nx_tcp_receive_cleanup+0x70>
 800de1a:	4b36      	ldr	r3, [pc, #216]	; (800def4 <_nx_tcp_receive_cleanup+0x140>)
 800de1c:	681b      	ldr	r3, [r3, #0]
 800de1e:	4a36      	ldr	r2, [pc, #216]	; (800def8 <_nx_tcp_receive_cleanup+0x144>)
 800de20:	4293      	cmp	r3, r2
 800de22:	d116      	bne.n	800de52 <_nx_tcp_receive_cleanup+0x9e>
    {

        /* Yes, defer the processing to the NetX IP thread.  */

        /* Yes, change the suspend cleanup routine to indicate the cleanup is deferred.  */
        thread_ptr -> tx_thread_suspend_cleanup =  _nx_tcp_cleanup_deferred;
 800de24:	687b      	ldr	r3, [r7, #4]
 800de26:	4a35      	ldr	r2, [pc, #212]	; (800defc <_nx_tcp_receive_cleanup+0x148>)
 800de28:	669a      	str	r2, [r3, #104]	; 0x68

        /* Pickup the IP pointer.  */
        ip_ptr =  socket_ptr -> nx_tcp_socket_ip_ptr;
 800de2a:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800de2c:	f8d3 30a0 	ldr.w	r3, [r3, #160]	; 0xa0
 800de30:	62fb      	str	r3, [r7, #44]	; 0x2c
 800de32:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800de34:	617b      	str	r3, [r7, #20]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 800de36:	697b      	ldr	r3, [r7, #20]
 800de38:	f383 8810 	msr	PRIMASK, r3
}
 800de3c:	bf00      	nop

        /* Restore interrupts.  */
        TX_RESTORE

        /* Set the deferred cleanup flag for the IP thread.  */
        tx_event_flags_set(&(ip_ptr -> nx_ip_events), NX_IP_TCP_CLEANUP_DEFERRED, TX_OR);
 800de3e:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800de40:	f503 7313 	add.w	r3, r3, #588	; 0x24c
 800de44:	2200      	movs	r2, #0
 800de46:	f44f 5180 	mov.w	r1, #4096	; 0x1000
 800de4a:	4618      	mov	r0, r3
 800de4c:	f004 fb4e 	bl	80124ec <_tx_event_flags_set>

        /* Return to caller.  */
        return;
 800de50:	e048      	b.n	800dee4 <_nx_tcp_receive_cleanup+0x130>
    {

        /* Yes, we still have thread suspension!  */

        /* Clear the suspension cleanup flag.  */
        thread_ptr -> tx_thread_suspend_cleanup =  TX_NULL;
 800de52:	687b      	ldr	r3, [r7, #4]
 800de54:	2200      	movs	r2, #0
 800de56:	669a      	str	r2, [r3, #104]	; 0x68

        /* Remove the suspended thread from the list.  */

        /* See if this is the only suspended thread on the list.  */
        if (thread_ptr == thread_ptr -> tx_thread_suspended_next)
 800de58:	687b      	ldr	r3, [r7, #4]
 800de5a:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 800de5c:	687a      	ldr	r2, [r7, #4]
 800de5e:	429a      	cmp	r2, r3
 800de60:	d104      	bne.n	800de6c <_nx_tcp_receive_cleanup+0xb8>
        {

            /* Yes, the only suspended thread.  */

            /* Update the head pointer.  */
            socket_ptr -> nx_tcp_socket_receive_suspension_list =  NX_NULL;
 800de62:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800de64:	2200      	movs	r2, #0
 800de66:	f8c3 20ec 	str.w	r2, [r3, #236]	; 0xec
 800de6a:	e00e      	b.n	800de8a <_nx_tcp_receive_cleanup+0xd6>
        {

            /* At least one more thread is on the same suspension list.  */

            /* Update the list head pointer.  */
            socket_ptr -> nx_tcp_socket_receive_suspension_list =  thread_ptr -> tx_thread_suspended_next;
 800de6c:	687b      	ldr	r3, [r7, #4]
 800de6e:	6f1a      	ldr	r2, [r3, #112]	; 0x70
 800de70:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800de72:	f8c3 20ec 	str.w	r2, [r3, #236]	; 0xec

            /* Update the links of the adjacent threads.  */
            (thread_ptr -> tx_thread_suspended_next) -> tx_thread_suspended_previous =
 800de76:	687b      	ldr	r3, [r7, #4]
 800de78:	6f1b      	ldr	r3, [r3, #112]	; 0x70
                thread_ptr -> tx_thread_suspended_previous;
 800de7a:	687a      	ldr	r2, [r7, #4]
 800de7c:	6f52      	ldr	r2, [r2, #116]	; 0x74
            (thread_ptr -> tx_thread_suspended_next) -> tx_thread_suspended_previous =
 800de7e:	675a      	str	r2, [r3, #116]	; 0x74
            (thread_ptr -> tx_thread_suspended_previous) -> tx_thread_suspended_next =
 800de80:	687b      	ldr	r3, [r7, #4]
 800de82:	6f5b      	ldr	r3, [r3, #116]	; 0x74
                thread_ptr -> tx_thread_suspended_next;
 800de84:	687a      	ldr	r2, [r7, #4]
 800de86:	6f12      	ldr	r2, [r2, #112]	; 0x70
            (thread_ptr -> tx_thread_suspended_previous) -> tx_thread_suspended_next =
 800de88:	671a      	str	r2, [r3, #112]	; 0x70
        }

        /* Decrement the suspension count.  */
        socket_ptr -> nx_tcp_socket_receive_suspended_count--;
 800de8a:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800de8c:	f8d3 30f0 	ldr.w	r3, [r3, #240]	; 0xf0
 800de90:	1e5a      	subs	r2, r3, #1
 800de92:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800de94:	f8c3 20f0 	str.w	r2, [r3, #240]	; 0xf0

        /* Now we need to determine if this cleanup is from a terminate, timeout,
           or from a wait abort.  */
        if (thread_ptr -> tx_thread_state == TX_TCP_IP)
 800de98:	687b      	ldr	r3, [r7, #4]
 800de9a:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800de9c:	2b0c      	cmp	r3, #12
 800de9e:	d11b      	bne.n	800ded8 <_nx_tcp_receive_cleanup+0x124>

            /* Thread still suspended on the TCP socket.  Setup return error status and
               resume the thread.  */

            /* Determine which receive error is present.  */
            if (socket_ptr -> nx_tcp_socket_state != NX_TCP_ESTABLISHED)
 800dea0:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800dea2:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 800dea4:	2b05      	cmp	r3, #5
 800dea6:	d004      	beq.n	800deb2 <_nx_tcp_receive_cleanup+0xfe>
            {

                /* This socket is no longer connected.  */
                thread_ptr -> tx_thread_suspend_status =  NX_NOT_CONNECTED;
 800dea8:	687b      	ldr	r3, [r7, #4]
 800deaa:	2238      	movs	r2, #56	; 0x38
 800deac:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84
 800deb0:	e003      	b.n	800deba <_nx_tcp_receive_cleanup+0x106>
            }
            else
            {

                /* Setup return status.  */
                thread_ptr -> tx_thread_suspend_status =  NX_NO_PACKET;
 800deb2:	687b      	ldr	r3, [r7, #4]
 800deb4:	2201      	movs	r2, #1
 800deb6:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84
            }

            /* Temporarily disable preemption.  */
            _tx_thread_preempt_disable++;
 800deba:	4b11      	ldr	r3, [pc, #68]	; (800df00 <_nx_tcp_receive_cleanup+0x14c>)
 800debc:	681b      	ldr	r3, [r3, #0]
 800debe:	3301      	adds	r3, #1
 800dec0:	4a0f      	ldr	r2, [pc, #60]	; (800df00 <_nx_tcp_receive_cleanup+0x14c>)
 800dec2:	6013      	str	r3, [r2, #0]
 800dec4:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800dec6:	613b      	str	r3, [r7, #16]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 800dec8:	693b      	ldr	r3, [r7, #16]
 800deca:	f383 8810 	msr	PRIMASK, r3
}
 800dece:	bf00      	nop
            TX_RESTORE

            /* Resume the thread!  Check for preemption even though we are executing
               from the system timer thread right now which normally executes at the
               highest priority.  */
            _tx_thread_system_resume(thread_ptr);
 800ded0:	6878      	ldr	r0, [r7, #4]
 800ded2:	f006 ff29 	bl	8014d28 <_tx_thread_system_resume>

            /* Finished, just return.  */
            return;
 800ded6:	e005      	b.n	800dee4 <_nx_tcp_receive_cleanup+0x130>
 800ded8:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800deda:	60fb      	str	r3, [r7, #12]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 800dedc:	68fb      	ldr	r3, [r7, #12]
 800dede:	f383 8810 	msr	PRIMASK, r3
}
 800dee2:	bf00      	nop
        }
    }

    /* Restore interrupts.  */
    TX_RESTORE
}
 800dee4:	3738      	adds	r7, #56	; 0x38
 800dee6:	46bd      	mov	sp, r7
 800dee8:	bd80      	pop	{r7, pc}
 800deea:	bf00      	nop
 800deec:	54435020 	.word	0x54435020
 800def0:	24000078 	.word	0x24000078
 800def4:	24031bc4 	.word	0x24031bc4
 800def8:	24031d0c 	.word	0x24031d0c
 800defc:	0800c7a9 	.word	0x0800c7a9
 800df00:	24031c5c 	.word	0x24031c5c

0800df04 <_nx_tcp_socket_block_cleanup>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
VOID  _nx_tcp_socket_block_cleanup(NX_TCP_SOCKET *socket_ptr)
{
 800df04:	b480      	push	{r7}
 800df06:	b083      	sub	sp, #12
 800df08:	af00      	add	r7, sp, #0
 800df0a:	6078      	str	r0, [r7, #4]

    /* Clean up the connect IP address.  */

    socket_ptr -> nx_tcp_socket_connect_ip.nxd_ip_version = 0;
 800df0c:	687b      	ldr	r3, [r7, #4]
 800df0e:	2200      	movs	r2, #0
 800df10:	615a      	str	r2, [r3, #20]
#ifdef FEATURE_NX_IPV6
    /* Clean up the IP address field. */
    SET_UNSPECIFIED_ADDRESS(socket_ptr -> nx_tcp_socket_connect_ip.nxd_ip_address.v6);
#else /* FEATURE_NX_IPV6 */
    socket_ptr -> nx_tcp_socket_connect_ip.nxd_ip_address.v4 = 0;
 800df12:	687b      	ldr	r3, [r7, #4]
 800df14:	2200      	movs	r2, #0
 800df16:	619a      	str	r2, [r3, #24]
#endif /* FEATURE_NX_IPV6 */

    /* Clean up the connect port.  */
    socket_ptr -> nx_tcp_socket_connect_port = 0;
 800df18:	687b      	ldr	r3, [r7, #4]
 800df1a:	2200      	movs	r2, #0
 800df1c:	61da      	str	r2, [r3, #28]

    /* Reset zero window probe flag. */
    socket_ptr -> nx_tcp_socket_zero_window_probe_has_data = NX_FALSE;
 800df1e:	687b      	ldr	r3, [r7, #4]
 800df20:	2200      	movs	r2, #0
 800df22:	f883 209c 	strb.w	r2, [r3, #156]	; 0x9c

    /* Simply clear the timeout.  */
    socket_ptr -> nx_tcp_socket_timeout = 0;
 800df26:	687b      	ldr	r3, [r7, #4]
 800df28:	2200      	movs	r2, #0
 800df2a:	f8c3 20cc 	str.w	r2, [r3, #204]	; 0xcc

    /* Reset duplicated ack received. */
    socket_ptr -> nx_tcp_socket_duplicated_ack_received = 0;
 800df2e:	687b      	ldr	r3, [r7, #4]
 800df30:	2200      	movs	r2, #0
 800df32:	66da      	str	r2, [r3, #108]	; 0x6c

    /* Reset fast recovery stage. */
    socket_ptr -> nx_tcp_socket_fast_recovery = NX_FALSE;
 800df34:	687b      	ldr	r3, [r7, #4]
 800df36:	2200      	movs	r2, #0
 800df38:	f883 209e 	strb.w	r2, [r3, #158]	; 0x9e

    /* Connection needs to be closed down immediately.  */
    if (socket_ptr -> nx_tcp_socket_client_type)
 800df3c:	687b      	ldr	r3, [r7, #4]
 800df3e:	689b      	ldr	r3, [r3, #8]
 800df40:	2b00      	cmp	r3, #0
 800df42:	d003      	beq.n	800df4c <_nx_tcp_socket_block_cleanup+0x48>

        /* If trace is enabled, insert this event into the trace buffer.  */
        NX_TRACE_IN_LINE_INSERT(NX_TRACE_INTERNAL_TCP_STATE_CHANGE, socket_ptr -> nx_tcp_socket_ip_ptr, socket_ptr, socket_ptr -> nx_tcp_socket_state, NX_TCP_CLOSED, NX_TRACE_INTERNAL_EVENTS, 0, 0);

        /* Client socket, return to a CLOSED state.  */
        socket_ptr -> nx_tcp_socket_state =  NX_TCP_CLOSED;
 800df44:	687b      	ldr	r3, [r7, #4]
 800df46:	2201      	movs	r2, #1
 800df48:	639a      	str	r2, [r3, #56]	; 0x38
        NX_TRACE_IN_LINE_INSERT(NX_TRACE_INTERNAL_TCP_STATE_CHANGE, socket_ptr -> nx_tcp_socket_ip_ptr, socket_ptr, socket_ptr -> nx_tcp_socket_state, NX_TCP_LISTEN_STATE, NX_TRACE_INTERNAL_EVENTS, 0, 0);

        /* Server socket, return to LISTEN state.  */
        socket_ptr -> nx_tcp_socket_state =  NX_TCP_LISTEN_STATE;
    }
}
 800df4a:	e002      	b.n	800df52 <_nx_tcp_socket_block_cleanup+0x4e>
        socket_ptr -> nx_tcp_socket_state =  NX_TCP_LISTEN_STATE;
 800df4c:	687b      	ldr	r3, [r7, #4]
 800df4e:	2202      	movs	r2, #2
 800df50:	639a      	str	r2, [r3, #56]	; 0x38
}
 800df52:	bf00      	nop
 800df54:	370c      	adds	r7, #12
 800df56:	46bd      	mov	sp, r7
 800df58:	f85d 7b04 	ldr.w	r7, [sp], #4
 800df5c:	4770      	bx	lr

0800df5e <_nx_tcp_socket_connection_reset>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
VOID  _nx_tcp_socket_connection_reset(NX_TCP_SOCKET *socket_ptr)
{
 800df5e:	b580      	push	{r7, lr}
 800df60:	b084      	sub	sp, #16
 800df62:	af00      	add	r7, sp, #0
 800df64:	6078      	str	r0, [r7, #4]

UINT saved_state;

    /* Save the current state of the socket.  */
    saved_state =  socket_ptr -> nx_tcp_socket_state;
 800df66:	687b      	ldr	r3, [r7, #4]
 800df68:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 800df6a:	60fb      	str	r3, [r7, #12]

    /* Cleanup the transmission control block.  */
    _nx_tcp_socket_block_cleanup(socket_ptr);
 800df6c:	6878      	ldr	r0, [r7, #4]
 800df6e:	f7ff ffc9 	bl	800df04 <_nx_tcp_socket_block_cleanup>

    /* Check for queued sent packets and if found they need
       to be released.  */
    if (socket_ptr -> nx_tcp_socket_transmit_sent_count)
 800df72:	687b      	ldr	r3, [r7, #4]
 800df74:	f8d3 30c0 	ldr.w	r3, [r3, #192]	; 0xc0
 800df78:	2b00      	cmp	r3, #0
 800df7a:	d002      	beq.n	800df82 <_nx_tcp_socket_connection_reset+0x24>
    {

        /* Release all transmit packets.  */
        _nx_tcp_socket_transmit_queue_flush(socket_ptr);
 800df7c:	6878      	ldr	r0, [r7, #4]
 800df7e:	f001 fde5 	bl	800fb4c <_nx_tcp_socket_transmit_queue_flush>
    }

    /* Check for queued receive packets and if found they need
       to be released.  */
    if (socket_ptr -> nx_tcp_socket_receive_queue_count)
 800df82:	687b      	ldr	r3, [r7, #4]
 800df84:	f8d3 30b0 	ldr.w	r3, [r3, #176]	; 0xb0
 800df88:	2b00      	cmp	r3, #0
 800df8a:	d00a      	beq.n	800dfa2 <_nx_tcp_socket_connection_reset+0x44>
    {

        /* Release all received packets.  */
        _nx_tcp_socket_receive_queue_flush(socket_ptr);
 800df8c:	6878      	ldr	r0, [r7, #4]
 800df8e:	f000 f9db 	bl	800e348 <_nx_tcp_socket_receive_queue_flush>
    }

    /* Clear all receive thread suspensions on this socket.  */
    while (socket_ptr -> nx_tcp_socket_receive_suspension_list)
 800df92:	e006      	b.n	800dfa2 <_nx_tcp_socket_connection_reset+0x44>
    {

        /* Call the receive thread suspension cleanup routine.  */
        _nx_tcp_receive_cleanup(socket_ptr -> nx_tcp_socket_receive_suspension_list NX_CLEANUP_ARGUMENT);
 800df94:	687b      	ldr	r3, [r7, #4]
 800df96:	f8d3 30ec 	ldr.w	r3, [r3, #236]	; 0xec
 800df9a:	2100      	movs	r1, #0
 800df9c:	4618      	mov	r0, r3
 800df9e:	f7ff ff09 	bl	800ddb4 <_nx_tcp_receive_cleanup>
    while (socket_ptr -> nx_tcp_socket_receive_suspension_list)
 800dfa2:	687b      	ldr	r3, [r7, #4]
 800dfa4:	f8d3 30ec 	ldr.w	r3, [r3, #236]	; 0xec
 800dfa8:	2b00      	cmp	r3, #0
 800dfaa:	d1f3      	bne.n	800df94 <_nx_tcp_socket_connection_reset+0x36>
    }

    /* Clear all transmit thread suspensions on this socket.  */
    while (socket_ptr -> nx_tcp_socket_transmit_suspension_list)
 800dfac:	e006      	b.n	800dfbc <_nx_tcp_socket_connection_reset+0x5e>
    {

        /* Call the receive thread suspension cleanup routine.  */
        _nx_tcp_transmit_cleanup(socket_ptr -> nx_tcp_socket_transmit_suspension_list NX_CLEANUP_ARGUMENT);
 800dfae:	687b      	ldr	r3, [r7, #4]
 800dfb0:	f8d3 30f4 	ldr.w	r3, [r3, #244]	; 0xf4
 800dfb4:	2100      	movs	r1, #0
 800dfb6:	4618      	mov	r0, r3
 800dfb8:	f001 fe10 	bl	800fbdc <_nx_tcp_transmit_cleanup>
    while (socket_ptr -> nx_tcp_socket_transmit_suspension_list)
 800dfbc:	687b      	ldr	r3, [r7, #4]
 800dfbe:	f8d3 30f4 	ldr.w	r3, [r3, #244]	; 0xf4
 800dfc2:	2b00      	cmp	r3, #0
 800dfc4:	d1f3      	bne.n	800dfae <_nx_tcp_socket_connection_reset+0x50>
    }

    /* Check for suspended connect thread.  */
    if (socket_ptr -> nx_tcp_socket_connect_suspended_thread)
 800dfc6:	687b      	ldr	r3, [r7, #4]
 800dfc8:	f8d3 30fc 	ldr.w	r3, [r3, #252]	; 0xfc
 800dfcc:	2b00      	cmp	r3, #0
 800dfce:	d006      	beq.n	800dfde <_nx_tcp_socket_connection_reset+0x80>
    {

        /* Call the connect thread suspension cleanup routine.  */
        _nx_tcp_connect_cleanup(socket_ptr -> nx_tcp_socket_connect_suspended_thread NX_CLEANUP_ARGUMENT);
 800dfd0:	687b      	ldr	r3, [r7, #4]
 800dfd2:	f8d3 30fc 	ldr.w	r3, [r3, #252]	; 0xfc
 800dfd6:	2100      	movs	r1, #0
 800dfd8:	4618      	mov	r0, r3
 800dfda:	f7fe fc97 	bl	800c90c <_nx_tcp_connect_cleanup>
    }

    /* Check for suspended disconnect thread.  */
    if (socket_ptr -> nx_tcp_socket_disconnect_suspended_thread)
 800dfde:	687b      	ldr	r3, [r7, #4]
 800dfe0:	f8d3 3100 	ldr.w	r3, [r3, #256]	; 0x100
 800dfe4:	2b00      	cmp	r3, #0
 800dfe6:	d006      	beq.n	800dff6 <_nx_tcp_socket_connection_reset+0x98>
    {

        /* Resume the thread suspended on the disconnect.  */
        _nx_tcp_disconnect_cleanup(socket_ptr -> nx_tcp_socket_disconnect_suspended_thread NX_CLEANUP_ARGUMENT);
 800dfe8:	687b      	ldr	r3, [r7, #4]
 800dfea:	f8d3 3100 	ldr.w	r3, [r3, #256]	; 0x100
 800dfee:	2100      	movs	r1, #0
 800dff0:	4618      	mov	r0, r3
 800dff2:	f7fe fdb7 	bl	800cb64 <_nx_tcp_disconnect_cleanup>
    }

    /* Determine if the socket was in an established state.  */
    if (saved_state == NX_TCP_ESTABLISHED)
 800dff6:	68fb      	ldr	r3, [r7, #12]
 800dff8:	2b05      	cmp	r3, #5
 800dffa:	d109      	bne.n	800e010 <_nx_tcp_socket_connection_reset+0xb2>
    {

        /* If given, call the application's disconnect callback function
           for disconnect.  */
        if (socket_ptr -> nx_tcp_disconnect_callback)
 800dffc:	687b      	ldr	r3, [r7, #4]
 800dffe:	f8d3 3118 	ldr.w	r3, [r3, #280]	; 0x118
 800e002:	2b00      	cmp	r3, #0
 800e004:	d004      	beq.n	800e010 <_nx_tcp_socket_connection_reset+0xb2>
        {

            /* Call the application's disconnect handling function.  It is
               responsible for calling the socket disconnect function.  */
            (socket_ptr -> nx_tcp_disconnect_callback)(socket_ptr);
 800e006:	687b      	ldr	r3, [r7, #4]
 800e008:	f8d3 3118 	ldr.w	r3, [r3, #280]	; 0x118
 800e00c:	6878      	ldr	r0, [r7, #4]
 800e00e:	4798      	blx	r3

        /* Notify the application through the socket disconnect_complete callback.  */
        (socket_ptr -> nx_tcp_disconnect_complete_notify)(socket_ptr);
    }
#endif
}
 800e010:	bf00      	nop
 800e012:	3710      	adds	r7, #16
 800e014:	46bd      	mov	sp, r7
 800e016:	bd80      	pop	{r7, pc}

0800e018 <_nx_tcp_socket_packet_process>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
VOID  _nx_tcp_socket_packet_process(NX_TCP_SOCKET *socket_ptr, NX_PACKET *packet_ptr)
{
 800e018:	b5b0      	push	{r4, r5, r7, lr}
 800e01a:	b090      	sub	sp, #64	; 0x40
 800e01c:	af00      	add	r7, sp, #0
 800e01e:	6078      	str	r0, [r7, #4]
 800e020:	6039      	str	r1, [r7, #0]

UINT          packet_queued =  NX_FALSE;
 800e022:	2300      	movs	r3, #0
 800e024:	63fb      	str	r3, [r7, #60]	; 0x3c
ULONG         packet_data_length;
ULONG         packet_sequence;
ULONG         rx_sequence;
ULONG         rx_window;
UINT          outside_of_window;
ULONG         mss = 0;
 800e026:	2300      	movs	r3, #0
 800e028:	60bb      	str	r3, [r7, #8]

    /* Copy the TCP header, since the actual packet can be delivered to
       a waiting socket/thread during this routine and before we are done
       using the header.  */
    /*lint -e{927} -e{826} suppress cast of pointer to pointer, since it is necessary  */
    tcp_header_copy =  *((NX_TCP_HEADER *)packet_ptr -> nx_packet_prepend_ptr);
 800e02a:	683b      	ldr	r3, [r7, #0]
 800e02c:	689b      	ldr	r3, [r3, #8]
 800e02e:	f107 040c 	add.w	r4, r7, #12
 800e032:	461d      	mov	r5, r3
 800e034:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 800e036:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 800e038:	682b      	ldr	r3, [r5, #0]
 800e03a:	6023      	str	r3, [r4, #0]

    /* Get the size of the TCP header.  */
    header_length =  (tcp_header_copy.nx_tcp_header_word_3 >> NX_TCP_HEADER_SHIFT) * (ULONG)sizeof(ULONG);
 800e03c:	69bb      	ldr	r3, [r7, #24]
 800e03e:	0f1b      	lsrs	r3, r3, #28
 800e040:	009b      	lsls	r3, r3, #2
 800e042:	637b      	str	r3, [r7, #52]	; 0x34

    /* Process the segment if socket state is equal or greater than NX_TCP_SYN_RECEIVED. According to RFC 793, Section 3.9, Page 69.  */
    if (socket_ptr -> nx_tcp_socket_state >= NX_TCP_SYN_RECEIVED)
 800e044:	687b      	ldr	r3, [r7, #4]
 800e046:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 800e048:	2b03      	cmp	r3, #3
 800e04a:	f240 80b5 	bls.w	800e1b8 <_nx_tcp_socket_packet_process+0x1a0>
    {

        /* Step1: Check sequence number. According to RFC 793, Section 3.9, Page 69.  */

        /* Pickup the sequence of this packet. */
        packet_sequence = tcp_header_copy.nx_tcp_sequence_number;
 800e04e:	693b      	ldr	r3, [r7, #16]
 800e050:	633b      	str	r3, [r7, #48]	; 0x30

        /* Calculate the data length in the packet.  */
        packet_data_length = packet_ptr -> nx_packet_length - header_length;
 800e052:	683b      	ldr	r3, [r7, #0]
 800e054:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 800e056:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800e058:	1ad3      	subs	r3, r2, r3
 800e05a:	62fb      	str	r3, [r7, #44]	; 0x2c

        /* Pickup the rx sequence.  */
        rx_sequence = socket_ptr -> nx_tcp_socket_rx_sequence;
 800e05c:	687b      	ldr	r3, [r7, #4]
 800e05e:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 800e060:	62bb      	str	r3, [r7, #40]	; 0x28
            socket_ptr -> nx_tcp_socket_rx_window_current =  socket_ptr -> nx_tcp_socket_rx_window_default;
        }
#endif /* NX_ENABLE_LOW_WATERMARK */

        /* Pickup the rx window.  */
        rx_window = socket_ptr -> nx_tcp_socket_rx_window_current;
 800e062:	687b      	ldr	r3, [r7, #4]
 800e064:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 800e066:	627b      	str	r3, [r7, #36]	; 0x24

        /* There are four cases for the acceptability test for an incoming segment.
           Section 3.9 Page 69, RFC 793.  */
        outside_of_window = NX_TRUE;
 800e068:	2301      	movs	r3, #1
 800e06a:	63bb      	str	r3, [r7, #56]	; 0x38

        if (packet_data_length == 0)
 800e06c:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800e06e:	2b00      	cmp	r3, #0
 800e070:	d12b      	bne.n	800e0ca <_nx_tcp_socket_packet_process+0xb2>
        {
            if (rx_window == 0)
 800e072:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800e074:	2b00      	cmp	r3, #0
 800e076:	d119      	bne.n	800e0ac <_nx_tcp_socket_packet_process+0x94>
            {
                if (packet_sequence == rx_sequence)
 800e078:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 800e07a:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800e07c:	429a      	cmp	r2, r3
 800e07e:	d102      	bne.n	800e086 <_nx_tcp_socket_packet_process+0x6e>
                {
                    outside_of_window = NX_FALSE;
 800e080:	2300      	movs	r3, #0
 800e082:	63bb      	str	r3, [r7, #56]	; 0x38
 800e084:	e044      	b.n	800e110 <_nx_tcp_socket_packet_process+0xf8>
                }
                else if ((tcp_header_copy.nx_tcp_header_word_3 & NX_TCP_RST_BIT) ||
 800e086:	69bb      	ldr	r3, [r7, #24]
 800e088:	f403 2380 	and.w	r3, r3, #262144	; 0x40000
 800e08c:	2b00      	cmp	r3, #0
 800e08e:	d10a      	bne.n	800e0a6 <_nx_tcp_socket_packet_process+0x8e>
                         (tcp_header_copy.nx_tcp_header_word_3 & NX_TCP_URG_BIT) ||
 800e090:	69bb      	ldr	r3, [r7, #24]
 800e092:	f403 1300 	and.w	r3, r3, #2097152	; 0x200000
                else if ((tcp_header_copy.nx_tcp_header_word_3 & NX_TCP_RST_BIT) ||
 800e096:	2b00      	cmp	r3, #0
 800e098:	d105      	bne.n	800e0a6 <_nx_tcp_socket_packet_process+0x8e>
                         ((tcp_header_copy.nx_tcp_header_word_3 & NX_TCP_CONTROL_MASK) == NX_TCP_ACK_BIT))
 800e09a:	69bb      	ldr	r3, [r7, #24]
 800e09c:	f403 13b8 	and.w	r3, r3, #1507328	; 0x170000
                         (tcp_header_copy.nx_tcp_header_word_3 & NX_TCP_URG_BIT) ||
 800e0a0:	f5b3 1f80 	cmp.w	r3, #1048576	; 0x100000
 800e0a4:	d134      	bne.n	800e110 <_nx_tcp_socket_packet_process+0xf8>
                {

                    /* If the RCV.WND is zero, no segments will be acceptable, but
                       special allowance should be made to accept valid ACKs, URGs and RSTs.
                       Section 3.9 Page 69, RFC 793. */
                    outside_of_window = NX_FALSE;
 800e0a6:	2300      	movs	r3, #0
 800e0a8:	63bb      	str	r3, [r7, #56]	; 0x38
 800e0aa:	e031      	b.n	800e110 <_nx_tcp_socket_packet_process+0xf8>
                }
            }
            else if (((INT)packet_sequence - (INT)rx_sequence >= 0) &&
 800e0ac:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 800e0ae:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800e0b0:	1ad3      	subs	r3, r2, r3
 800e0b2:	2b00      	cmp	r3, #0
 800e0b4:	db2c      	blt.n	800e110 <_nx_tcp_socket_packet_process+0xf8>
                     ((INT)rx_sequence + (INT)rx_window - (INT)packet_sequence > 0))
 800e0b6:	6aba      	ldr	r2, [r7, #40]	; 0x28
 800e0b8:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800e0ba:	441a      	add	r2, r3
 800e0bc:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800e0be:	1ad3      	subs	r3, r2, r3
            else if (((INT)packet_sequence - (INT)rx_sequence >= 0) &&
 800e0c0:	2b00      	cmp	r3, #0
 800e0c2:	dd25      	ble.n	800e110 <_nx_tcp_socket_packet_process+0xf8>
            {
                outside_of_window = NX_FALSE;
 800e0c4:	2300      	movs	r3, #0
 800e0c6:	63bb      	str	r3, [r7, #56]	; 0x38
 800e0c8:	e022      	b.n	800e110 <_nx_tcp_socket_packet_process+0xf8>
            }
        }
        else
        {
            if ((rx_window > 0) &&
 800e0ca:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800e0cc:	2b00      	cmp	r3, #0
 800e0ce:	d01f      	beq.n	800e110 <_nx_tcp_socket_packet_process+0xf8>
                ((((INT)packet_sequence - (INT)rx_sequence >= 0) &&
 800e0d0:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 800e0d2:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800e0d4:	1ad3      	subs	r3, r2, r3
            if ((rx_window > 0) &&
 800e0d6:	2b00      	cmp	r3, #0
 800e0d8:	db06      	blt.n	800e0e8 <_nx_tcp_socket_packet_process+0xd0>
                  ((INT)rx_sequence + (INT)rx_window - (INT)packet_sequence > 0)) ||
 800e0da:	6aba      	ldr	r2, [r7, #40]	; 0x28
 800e0dc:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800e0de:	441a      	add	r2, r3
 800e0e0:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800e0e2:	1ad3      	subs	r3, r2, r3
                ((((INT)packet_sequence - (INT)rx_sequence >= 0) &&
 800e0e4:	2b00      	cmp	r3, #0
 800e0e6:	dc11      	bgt.n	800e10c <_nx_tcp_socket_packet_process+0xf4>
                 (((INT)packet_sequence + ((INT)packet_data_length - 1) - (INT)rx_sequence >= 0) &&
 800e0e8:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 800e0ea:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800e0ec:	441a      	add	r2, r3
 800e0ee:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800e0f0:	1ad3      	subs	r3, r2, r3
 800e0f2:	3b01      	subs	r3, #1
                  ((INT)rx_sequence + (INT)rx_window - (INT)packet_sequence > 0)) ||
 800e0f4:	2b00      	cmp	r3, #0
 800e0f6:	db0b      	blt.n	800e110 <_nx_tcp_socket_packet_process+0xf8>
                  ((INT)rx_sequence + 1 + ((INT)rx_window - (INT)packet_sequence) - (INT)packet_data_length > 0))))
 800e0f8:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800e0fa:	1c5a      	adds	r2, r3, #1
 800e0fc:	6a79      	ldr	r1, [r7, #36]	; 0x24
 800e0fe:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800e100:	1acb      	subs	r3, r1, r3
 800e102:	441a      	add	r2, r3
 800e104:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800e106:	1ad3      	subs	r3, r2, r3
                 (((INT)packet_sequence + ((INT)packet_data_length - 1) - (INT)rx_sequence >= 0) &&
 800e108:	2b00      	cmp	r3, #0
 800e10a:	dd01      	ble.n	800e110 <_nx_tcp_socket_packet_process+0xf8>
            {
                outside_of_window = NX_FALSE;
 800e10c:	2300      	movs	r3, #0
 800e10e:	63bb      	str	r3, [r7, #56]	; 0x38
            }
        }

        /* Detect whether or not the data is outside the window.  */
        if (outside_of_window)
 800e110:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800e112:	2b00      	cmp	r3, #0
 800e114:	d016      	beq.n	800e144 <_nx_tcp_socket_packet_process+0x12c>
        {

            /* If an incoming segment is not acceptable, an acknowledgment should be sent in reply
               (unless the RST bit is set, if so drop the segment and return).
               Section 3.9, Page 69, RFC 793.  */
            if (!(tcp_header_copy.nx_tcp_header_word_3 & NX_TCP_RST_BIT))
 800e116:	69bb      	ldr	r3, [r7, #24]
 800e118:	f403 2380 	and.w	r3, r3, #262144	; 0x40000
 800e11c:	2b00      	cmp	r3, #0
 800e11e:	d105      	bne.n	800e12c <_nx_tcp_socket_packet_process+0x114>
            {

                /* Send an immediate ACK.  */
                _nx_tcp_packet_send_ack(socket_ptr, socket_ptr -> nx_tcp_socket_tx_sequence);
 800e120:	687b      	ldr	r3, [r7, #4]
 800e122:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 800e124:	4619      	mov	r1, r3
 800e126:	6878      	ldr	r0, [r7, #4]
 800e128:	f7ff fc02 	bl	800d930 <_nx_tcp_packet_send_ack>
            }

#ifndef NX_DISABLE_TCP_INFO

            /* Increment the TCP dropped packet count.  */
            socket_ptr -> nx_tcp_socket_ip_ptr -> nx_ip_tcp_receive_packets_dropped++;
 800e12c:	687b      	ldr	r3, [r7, #4]
 800e12e:	f8d3 30a0 	ldr.w	r3, [r3, #160]	; 0xa0
 800e132:	f8d3 20bc 	ldr.w	r2, [r3, #188]	; 0xbc
 800e136:	3201      	adds	r2, #1
 800e138:	f8c3 20bc 	str.w	r2, [r3, #188]	; 0xbc
#endif

            /* Release the packet.  */
            _nx_packet_release(packet_ptr);
 800e13c:	6838      	ldr	r0, [r7, #0]
 800e13e:	f7fe f963 	bl	800c408 <_nx_packet_release>

            /* Finished processing, simply return!  */
            return;
 800e142:	e0fe      	b.n	800e342 <_nx_tcp_socket_packet_process+0x32a>
        }

        /* Step2: Check the RST bit. According to RFC 793, Section 3.9, Page 70.  */
        if (tcp_header_copy.nx_tcp_header_word_3 & NX_TCP_RST_BIT)
 800e144:	69bb      	ldr	r3, [r7, #24]
 800e146:	f403 2380 	and.w	r3, r3, #262144	; 0x40000
 800e14a:	2b00      	cmp	r3, #0
 800e14c:	d00e      	beq.n	800e16c <_nx_tcp_socket_packet_process+0x154>
        {

#ifndef NX_DISABLE_TCP_INFO

            /* Increment the resets received count.  */
            (socket_ptr -> nx_tcp_socket_ip_ptr) -> nx_ip_tcp_resets_received++;
 800e14e:	687b      	ldr	r3, [r7, #4]
 800e150:	f8d3 30a0 	ldr.w	r3, [r3, #160]	; 0xa0
 800e154:	f8d3 20dc 	ldr.w	r2, [r3, #220]	; 0xdc
 800e158:	3201      	adds	r2, #1
 800e15a:	f8c3 20dc 	str.w	r2, [r3, #220]	; 0xdc

            /* If trace is enabled, insert this event into the trace buffer.  */
            NX_TRACE_IN_LINE_INSERT(NX_TRACE_INTERNAL_TCP_RESET_RECEIVE, socket_ptr -> nx_tcp_socket_ip_ptr, socket_ptr, packet_ptr, tcp_header_copy.nx_tcp_sequence_number, NX_TRACE_INTERNAL_EVENTS, 0, 0);

            /* Reset connection.  */
            _nx_tcp_socket_connection_reset(socket_ptr);
 800e15e:	6878      	ldr	r0, [r7, #4]
 800e160:	f7ff fefd 	bl	800df5e <_nx_tcp_socket_connection_reset>

            /* Release the packet.  */
            _nx_packet_release(packet_ptr);
 800e164:	6838      	ldr	r0, [r7, #0]
 800e166:	f7fe f94f 	bl	800c408 <_nx_packet_release>

            /* Finished processing, simply return!  */
            return;
 800e16a:	e0ea      	b.n	800e342 <_nx_tcp_socket_packet_process+0x32a>
        }

        /* Step3: Check the SYN bit. According to RFC 793, Section 3.9, Page 71.  */
        if (tcp_header_copy.nx_tcp_header_word_3 & NX_TCP_SYN_BIT)
 800e16c:	69bb      	ldr	r3, [r7, #24]
 800e16e:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
 800e172:	2b00      	cmp	r3, #0
 800e174:	d00f      	beq.n	800e196 <_nx_tcp_socket_packet_process+0x17e>

            /* The SYN is in the window it is an error, send a reset.  */

            /* Adjust the SEQ for the SYN bit. */
            /* The reset logic uses the sequence number in tcp_header_ptr as its ACK number. */
            tcp_header_copy.nx_tcp_sequence_number++;
 800e176:	693b      	ldr	r3, [r7, #16]
 800e178:	3301      	adds	r3, #1
 800e17a:	613b      	str	r3, [r7, #16]

            /* Send RST message.  */
            _nx_tcp_packet_send_rst(socket_ptr, &tcp_header_copy);
 800e17c:	f107 030c 	add.w	r3, r7, #12
 800e180:	4619      	mov	r1, r3
 800e182:	6878      	ldr	r0, [r7, #4]
 800e184:	f7ff fd30 	bl	800dbe8 <_nx_tcp_packet_send_rst>

            /* Reset the connection. */
            _nx_tcp_socket_connection_reset(socket_ptr);
 800e188:	6878      	ldr	r0, [r7, #4]
 800e18a:	f7ff fee8 	bl	800df5e <_nx_tcp_socket_connection_reset>

            /* Release the packet.  */
            _nx_packet_release(packet_ptr);
 800e18e:	6838      	ldr	r0, [r7, #0]
 800e190:	f7fe f93a 	bl	800c408 <_nx_packet_release>

            /* Finished processing, simply return!  */
            return;
 800e194:	e0d5      	b.n	800e342 <_nx_tcp_socket_packet_process+0x32a>
        }

        /* Step4: Check the ACK field. According to RFC 793, Section 3.9, Page 72.  */
        if (socket_ptr -> nx_tcp_socket_state != NX_TCP_SYN_RECEIVED)
 800e196:	687b      	ldr	r3, [r7, #4]
 800e198:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 800e19a:	2b04      	cmp	r3, #4
 800e19c:	d00c      	beq.n	800e1b8 <_nx_tcp_socket_packet_process+0x1a0>
        {

            /* Check the ACK field.  */
            if (_nx_tcp_socket_state_ack_check(socket_ptr, &tcp_header_copy) == NX_FALSE)
 800e19e:	f107 030c 	add.w	r3, r7, #12
 800e1a2:	4619      	mov	r1, r3
 800e1a4:	6878      	ldr	r0, [r7, #4]
 800e1a6:	f000 faa1 	bl	800e6ec <_nx_tcp_socket_state_ack_check>
 800e1aa:	4603      	mov	r3, r0
 800e1ac:	2b00      	cmp	r3, #0
 800e1ae:	d103      	bne.n	800e1b8 <_nx_tcp_socket_packet_process+0x1a0>
            {

                /* Release the packet.  */
                _nx_packet_release(packet_ptr);
 800e1b0:	6838      	ldr	r0, [r7, #0]
 800e1b2:	f7fe f929 	bl	800c408 <_nx_packet_release>

                /* Finished processing, simply return!  */
                return;
 800e1b6:	e0c4      	b.n	800e342 <_nx_tcp_socket_packet_process+0x32a>
            }
        }
    }

    /* Illegal option length check. */
    if (header_length > sizeof(NX_TCP_HEADER))
 800e1b8:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800e1ba:	2b14      	cmp	r3, #20
 800e1bc:	d93b      	bls.n	800e236 <_nx_tcp_socket_packet_process+0x21e>
    {

        /* There are one or more option words.  */
        /* The illegal option length is validated during MSS option get function. */
        if (!_nx_tcp_mss_option_get((packet_ptr -> nx_packet_prepend_ptr + sizeof(NX_TCP_HEADER)),
 800e1be:	683b      	ldr	r3, [r7, #0]
 800e1c0:	689b      	ldr	r3, [r3, #8]
 800e1c2:	f103 0014 	add.w	r0, r3, #20
 800e1c6:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800e1c8:	3b14      	subs	r3, #20
 800e1ca:	f107 0208 	add.w	r2, r7, #8
 800e1ce:	4619      	mov	r1, r3
 800e1d0:	f7fe fe9d 	bl	800cf0e <_nx_tcp_mss_option_get>
 800e1d4:	4603      	mov	r3, r0
 800e1d6:	2b00      	cmp	r3, #0
 800e1d8:	d12d      	bne.n	800e236 <_nx_tcp_socket_packet_process+0x21e>
            /* TCP MUST be prepared to handle an illegal option length (e.g., zero) without crashing;
               a suggested procedure is to reset the connection and log the reason, outlined in RFC 1122, Section 4.2.2.5, Page85. */

            /* Preprocess the sequence number if the incoming segment does not have an ACK field.
               Reset Generation, RFC793, Section3.4, Page37. */
            if (!(tcp_header_copy.nx_tcp_header_word_3 & NX_TCP_ACK_BIT))
 800e1da:	69bb      	ldr	r3, [r7, #24]
 800e1dc:	f403 1380 	and.w	r3, r3, #1048576	; 0x100000
 800e1e0:	2b00      	cmp	r3, #0
 800e1e2:	d113      	bne.n	800e20c <_nx_tcp_socket_packet_process+0x1f4>
            {

                /* Update sequence number to set the reset acknowledge number.  */
                tcp_header_copy.nx_tcp_sequence_number += (packet_ptr -> nx_packet_length - header_length);
 800e1e4:	693a      	ldr	r2, [r7, #16]
 800e1e6:	683b      	ldr	r3, [r7, #0]
 800e1e8:	6a59      	ldr	r1, [r3, #36]	; 0x24
 800e1ea:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800e1ec:	1acb      	subs	r3, r1, r3
 800e1ee:	4413      	add	r3, r2
 800e1f0:	613b      	str	r3, [r7, #16]

                /* Check the SYN and FIN bits.  */
                if ((tcp_header_copy.nx_tcp_header_word_3 & NX_TCP_SYN_BIT) ||
 800e1f2:	69bb      	ldr	r3, [r7, #24]
 800e1f4:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
 800e1f8:	2b00      	cmp	r3, #0
 800e1fa:	d104      	bne.n	800e206 <_nx_tcp_socket_packet_process+0x1ee>
                    (tcp_header_copy.nx_tcp_header_word_3 & NX_TCP_FIN_BIT))
 800e1fc:	69bb      	ldr	r3, [r7, #24]
 800e1fe:	f403 3380 	and.w	r3, r3, #65536	; 0x10000
                if ((tcp_header_copy.nx_tcp_header_word_3 & NX_TCP_SYN_BIT) ||
 800e202:	2b00      	cmp	r3, #0
 800e204:	d002      	beq.n	800e20c <_nx_tcp_socket_packet_process+0x1f4>
                {

                    /* Update sequence number to set the reset acknowledge number.  */
                    tcp_header_copy.nx_tcp_sequence_number++;
 800e206:	693b      	ldr	r3, [r7, #16]
 800e208:	3301      	adds	r3, #1
 800e20a:	613b      	str	r3, [r7, #16]
                }
            }

            /* Send RST message.  */
            _nx_tcp_packet_send_rst(socket_ptr, &tcp_header_copy);
 800e20c:	f107 030c 	add.w	r3, r7, #12
 800e210:	4619      	mov	r1, r3
 800e212:	6878      	ldr	r0, [r7, #4]
 800e214:	f7ff fce8 	bl	800dbe8 <_nx_tcp_packet_send_rst>

            /* Reset the connection. */
            _nx_tcp_socket_connection_reset(socket_ptr);
 800e218:	6878      	ldr	r0, [r7, #4]
 800e21a:	f7ff fea0 	bl	800df5e <_nx_tcp_socket_connection_reset>

#ifndef NX_DISABLE_TCP_INFO
            /* Increment the TCP invalid packet error count.  */
            socket_ptr -> nx_tcp_socket_ip_ptr -> nx_ip_tcp_invalid_packets++;
 800e21e:	687b      	ldr	r3, [r7, #4]
 800e220:	f8d3 30a0 	ldr.w	r3, [r3, #160]	; 0xa0
 800e224:	f8d3 20b8 	ldr.w	r2, [r3, #184]	; 0xb8
 800e228:	3201      	adds	r2, #1
 800e22a:	f8c3 20b8 	str.w	r2, [r3, #184]	; 0xb8
#endif /* NX_DISABLE_TCP_INFO */

            /* Release the packet.  */
            _nx_packet_release(packet_ptr);
 800e22e:	6838      	ldr	r0, [r7, #0]
 800e230:	f7fe f8ea 	bl	800c408 <_nx_packet_release>

            return;
 800e234:	e085      	b.n	800e342 <_nx_tcp_socket_packet_process+0x32a>
        }

    }

    /* Process relative to the state of the socket.  */
    switch (socket_ptr -> nx_tcp_socket_state)
 800e236:	687b      	ldr	r3, [r7, #4]
 800e238:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 800e23a:	3b03      	subs	r3, #3
 800e23c:	2b08      	cmp	r3, #8
 800e23e:	d866      	bhi.n	800e30e <_nx_tcp_socket_packet_process+0x2f6>
 800e240:	a201      	add	r2, pc, #4	; (adr r2, 800e248 <_nx_tcp_socket_packet_process+0x230>)
 800e242:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 800e246:	bf00      	nop
 800e248:	0800e26d 	.word	0x0800e26d
 800e24c:	0800e28f 	.word	0x0800e28f
 800e250:	0800e2af 	.word	0x0800e2af
 800e254:	0800e2c7 	.word	0x0800e2c7
 800e258:	0800e2dd 	.word	0x0800e2dd
 800e25c:	0800e2ef 	.word	0x0800e2ef
 800e260:	0800e301 	.word	0x0800e301
 800e264:	0800e30f 	.word	0x0800e30f
 800e268:	0800e2cf 	.word	0x0800e2cf

    case  NX_TCP_SYN_SENT:

        /* Call the SYN SENT state handling function to process any state
           changes caused by this new packet.  */
        _nx_tcp_socket_state_syn_sent(socket_ptr, &tcp_header_copy, packet_ptr);
 800e26c:	f107 030c 	add.w	r3, r7, #12
 800e270:	683a      	ldr	r2, [r7, #0]
 800e272:	4619      	mov	r1, r3
 800e274:	6878      	ldr	r0, [r7, #4]
 800e276:	f001 fad4 	bl	800f822 <_nx_tcp_socket_state_syn_sent>

        /* Check whether socket is established. */
        if (socket_ptr -> nx_tcp_socket_state == NX_TCP_ESTABLISHED)
 800e27a:	687b      	ldr	r3, [r7, #4]
 800e27c:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 800e27e:	2b05      	cmp	r3, #5
 800e280:	d147      	bne.n	800e312 <_nx_tcp_socket_packet_process+0x2fa>
        {

            /* Check for data in the current packet.  */
            packet_queued =  _nx_tcp_socket_state_data_check(socket_ptr, packet_ptr);
 800e282:	6839      	ldr	r1, [r7, #0]
 800e284:	6878      	ldr	r0, [r7, #4]
 800e286:	f000 fe1f 	bl	800eec8 <_nx_tcp_socket_state_data_check>
 800e28a:	63f8      	str	r0, [r7, #60]	; 0x3c
        }

        /* State processing is complete.  */
        break;
 800e28c:	e041      	b.n	800e312 <_nx_tcp_socket_packet_process+0x2fa>

    case  NX_TCP_SYN_RECEIVED:

        /* Call the SYN RECEIVED state handling function to process any state
           changes caused by this new packet.  */
        _nx_tcp_socket_state_syn_received(socket_ptr, &tcp_header_copy);
 800e28e:	f107 030c 	add.w	r3, r7, #12
 800e292:	4619      	mov	r1, r3
 800e294:	6878      	ldr	r0, [r7, #4]
 800e296:	f001 fa67 	bl	800f768 <_nx_tcp_socket_state_syn_received>

        /* Check whether socket is established. */
        if (socket_ptr -> nx_tcp_socket_state == NX_TCP_ESTABLISHED)
 800e29a:	687b      	ldr	r3, [r7, #4]
 800e29c:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 800e29e:	2b05      	cmp	r3, #5
 800e2a0:	d139      	bne.n	800e316 <_nx_tcp_socket_packet_process+0x2fe>
        {

            /* Check for data in the current packet.  */
            packet_queued =  _nx_tcp_socket_state_data_check(socket_ptr, packet_ptr);
 800e2a2:	6839      	ldr	r1, [r7, #0]
 800e2a4:	6878      	ldr	r0, [r7, #4]
 800e2a6:	f000 fe0f 	bl	800eec8 <_nx_tcp_socket_state_data_check>
 800e2aa:	63f8      	str	r0, [r7, #60]	; 0x3c
        }

        /* State processing is complete.  */
        break;
 800e2ac:	e033      	b.n	800e316 <_nx_tcp_socket_packet_process+0x2fe>

    case  NX_TCP_ESTABLISHED:

        /* Check for data in the current packet.  */
        packet_queued =  _nx_tcp_socket_state_data_check(socket_ptr, packet_ptr);
 800e2ae:	6839      	ldr	r1, [r7, #0]
 800e2b0:	6878      	ldr	r0, [r7, #4]
 800e2b2:	f000 fe09 	bl	800eec8 <_nx_tcp_socket_state_data_check>
 800e2b6:	63f8      	str	r0, [r7, #60]	; 0x3c

        /* Call the ESTABLISHED state handling function to process any state
           changes caused by this new packet.  */
        _nx_tcp_socket_state_established(socket_ptr);
 800e2b8:	6878      	ldr	r0, [r7, #4]
 800e2ba:	f001 f93d 	bl	800f538 <_nx_tcp_socket_state_established>

        /* Determine if any transmit suspension can be lifted.  */
        _nx_tcp_socket_state_transmit_check(socket_ptr);
 800e2be:	6878      	ldr	r0, [r7, #4]
 800e2c0:	f001 fb98 	bl	800f9f4 <_nx_tcp_socket_state_transmit_check>

        /* State processing is complete.  */
        break;
 800e2c4:	e028      	b.n	800e318 <_nx_tcp_socket_packet_process+0x300>

    case  NX_TCP_CLOSE_WAIT:

        /* Determine if any transmit suspension can be lifted.  */
        _nx_tcp_socket_state_transmit_check(socket_ptr);
 800e2c6:	6878      	ldr	r0, [r7, #4]
 800e2c8:	f001 fb94 	bl	800f9f4 <_nx_tcp_socket_state_transmit_check>

        /* State processing is complete.  */
        break;
 800e2cc:	e024      	b.n	800e318 <_nx_tcp_socket_packet_process+0x300>

    case  NX_TCP_LAST_ACK:

        /* Call the LAST ACK state handling function to process any state
           changes caused by this new packet.  */
        _nx_tcp_socket_state_last_ack(socket_ptr, &tcp_header_copy);
 800e2ce:	f107 030c 	add.w	r3, r7, #12
 800e2d2:	4619      	mov	r1, r3
 800e2d4:	6878      	ldr	r0, [r7, #4]
 800e2d6:	f001 fa1d 	bl	800f714 <_nx_tcp_socket_state_last_ack>

        /* State processing is complete.  */
        break;
 800e2da:	e01d      	b.n	800e318 <_nx_tcp_socket_packet_process+0x300>

    case  NX_TCP_FIN_WAIT_1:

        /* Check for data in the current packet.  */
        packet_queued =  _nx_tcp_socket_state_data_check(socket_ptr, packet_ptr);
 800e2dc:	6839      	ldr	r1, [r7, #0]
 800e2de:	6878      	ldr	r0, [r7, #4]
 800e2e0:	f000 fdf2 	bl	800eec8 <_nx_tcp_socket_state_data_check>
 800e2e4:	63f8      	str	r0, [r7, #60]	; 0x3c

        /* Call the FIN WAIT 1 state handling function to process any state
           changes caused by this new packet.  */
        _nx_tcp_socket_state_fin_wait1(socket_ptr);
 800e2e6:	6878      	ldr	r0, [r7, #4]
 800e2e8:	f001 f96a 	bl	800f5c0 <_nx_tcp_socket_state_fin_wait1>

        /* State processing is complete.  */
        break;
 800e2ec:	e014      	b.n	800e318 <_nx_tcp_socket_packet_process+0x300>

    case  NX_TCP_FIN_WAIT_2:

        /* Check for data in the current packet.  */
        packet_queued =  _nx_tcp_socket_state_data_check(socket_ptr, packet_ptr);
 800e2ee:	6839      	ldr	r1, [r7, #0]
 800e2f0:	6878      	ldr	r0, [r7, #4]
 800e2f2:	f000 fde9 	bl	800eec8 <_nx_tcp_socket_state_data_check>
 800e2f6:	63f8      	str	r0, [r7, #60]	; 0x3c

        /* Call the FIN WAIT 2 state handling function to process any state
           changes caused by this new packet.  */
        _nx_tcp_socket_state_fin_wait2(socket_ptr);
 800e2f8:	6878      	ldr	r0, [r7, #4]
 800e2fa:	f001 f9cd 	bl	800f698 <_nx_tcp_socket_state_fin_wait2>

        /* State processing is complete.  */
        break;
 800e2fe:	e00b      	b.n	800e318 <_nx_tcp_socket_packet_process+0x300>

    case  NX_TCP_CLOSING:

        /* Call the CLOSING state handling function to process any state
           changes caused by this new packet.  */
        _nx_tcp_socket_state_closing(socket_ptr, &tcp_header_copy);
 800e300:	f107 030c 	add.w	r3, r7, #12
 800e304:	4619      	mov	r1, r3
 800e306:	6878      	ldr	r0, [r7, #4]
 800e308:	f000 fce2 	bl	800ecd0 <_nx_tcp_socket_state_closing>

        /* State processing is complete.  */
        break;
 800e30c:	e004      	b.n	800e318 <_nx_tcp_socket_packet_process+0x300>

        /* State processing is complete.  */
        break;

    default:
        break;
 800e30e:	bf00      	nop
 800e310:	e002      	b.n	800e318 <_nx_tcp_socket_packet_process+0x300>
        break;
 800e312:	bf00      	nop
 800e314:	e000      	b.n	800e318 <_nx_tcp_socket_packet_process+0x300>
        break;
 800e316:	bf00      	nop
    }

    /* Check for an URG (urgent) bit set.  */
    /*lint -e{644} suppress variable might not be initialized, since "tcp_header_copy" was initialized. */
    if (tcp_header_copy.nx_tcp_header_word_3 & NX_TCP_URG_BIT)
 800e318:	69bb      	ldr	r3, [r7, #24]
 800e31a:	f403 1300 	and.w	r3, r3, #2097152	; 0x200000
 800e31e:	2b00      	cmp	r3, #0
 800e320:	d009      	beq.n	800e336 <_nx_tcp_socket_packet_process+0x31e>
    {

        /* Yes, an Urgent bit is set.  */

        /* Pickup the urgent callback function specified when the socket was created.  */
        urgent_callback =  socket_ptr -> nx_tcp_urgent_data_callback;
 800e322:	687b      	ldr	r3, [r7, #4]
 800e324:	f8d3 3114 	ldr.w	r3, [r3, #276]	; 0x114
 800e328:	623b      	str	r3, [r7, #32]

        /* Determine if there is an urgent callback function specified.  */
        if (urgent_callback)
 800e32a:	6a3b      	ldr	r3, [r7, #32]
 800e32c:	2b00      	cmp	r3, #0
 800e32e:	d002      	beq.n	800e336 <_nx_tcp_socket_packet_process+0x31e>
        {

            /* Yes, call the application's urgent callback function to alert the application
               of the presence of the urgent bit.  */
            (urgent_callback)(socket_ptr);
 800e330:	6a3b      	ldr	r3, [r7, #32]
 800e332:	6878      	ldr	r0, [r7, #4]
 800e334:	4798      	blx	r3
        }
    }

    /* Determine if we need to release the packet.  */
    if (!packet_queued)
 800e336:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800e338:	2b00      	cmp	r3, #0
 800e33a:	d102      	bne.n	800e342 <_nx_tcp_socket_packet_process+0x32a>
    {

        /* Yes, the packet was not queued up above, so it needs to be released.  */
        _nx_packet_release(packet_ptr);
 800e33c:	6838      	ldr	r0, [r7, #0]
 800e33e:	f7fe f863 	bl	800c408 <_nx_packet_release>
    }
}
 800e342:	3740      	adds	r7, #64	; 0x40
 800e344:	46bd      	mov	sp, r7
 800e346:	bdb0      	pop	{r4, r5, r7, pc}

0800e348 <_nx_tcp_socket_receive_queue_flush>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
VOID  _nx_tcp_socket_receive_queue_flush(NX_TCP_SOCKET *socket_ptr)
{
 800e348:	b580      	push	{r7, lr}
 800e34a:	b084      	sub	sp, #16
 800e34c:	af00      	add	r7, sp, #0
 800e34e:	6078      	str	r0, [r7, #4]
NX_PACKET *packet_ptr;
NX_PACKET *next_packet_ptr;


    /* Setup packet pointer.  */
    packet_ptr =  socket_ptr -> nx_tcp_socket_receive_queue_head;
 800e350:	687b      	ldr	r3, [r7, #4]
 800e352:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 800e356:	60fb      	str	r3, [r7, #12]

    /* Clear the head and the tail pointers.  */
    socket_ptr -> nx_tcp_socket_receive_queue_head =  NX_NULL;
 800e358:	687b      	ldr	r3, [r7, #4]
 800e35a:	2200      	movs	r2, #0
 800e35c:	f8c3 20b4 	str.w	r2, [r3, #180]	; 0xb4
    socket_ptr -> nx_tcp_socket_receive_queue_tail =  NX_NULL;
 800e360:	687b      	ldr	r3, [r7, #4]
 800e362:	2200      	movs	r2, #0
 800e364:	f8c3 20b8 	str.w	r2, [r3, #184]	; 0xb8

    /* Loop to clear all the packets out.  */
    while (socket_ptr -> nx_tcp_socket_receive_queue_count)
 800e368:	e012      	b.n	800e390 <_nx_tcp_socket_receive_queue_flush+0x48>
    {

        /* Pickup the next queued packet.  */
        next_packet_ptr =  packet_ptr -> nx_packet_union_next.nx_packet_tcp_queue_next;
 800e36a:	68fb      	ldr	r3, [r7, #12]
 800e36c:	6a1b      	ldr	r3, [r3, #32]
 800e36e:	60bb      	str	r3, [r7, #8]

        /* Mark it as allocated so it will be released.  */
        /*lint -e{923} suppress cast of ULONT to pointer.  */
        packet_ptr -> nx_packet_union_next.nx_packet_tcp_queue_next =  (NX_PACKET *)NX_PACKET_ALLOCATED;
 800e370:	68fb      	ldr	r3, [r7, #12]
 800e372:	f04f 32aa 	mov.w	r2, #2863311530	; 0xaaaaaaaa
 800e376:	621a      	str	r2, [r3, #32]

        /* Release the packet.  */
        _nx_packet_release(packet_ptr);
 800e378:	68f8      	ldr	r0, [r7, #12]
 800e37a:	f7fe f845 	bl	800c408 <_nx_packet_release>

        /* Move to the next packet.  */
        packet_ptr =  next_packet_ptr;
 800e37e:	68bb      	ldr	r3, [r7, #8]
 800e380:	60fb      	str	r3, [r7, #12]

        /* Decrease the queued packet count.  */
        socket_ptr -> nx_tcp_socket_receive_queue_count--;
 800e382:	687b      	ldr	r3, [r7, #4]
 800e384:	f8d3 30b0 	ldr.w	r3, [r3, #176]	; 0xb0
 800e388:	1e5a      	subs	r2, r3, #1
 800e38a:	687b      	ldr	r3, [r7, #4]
 800e38c:	f8c3 20b0 	str.w	r2, [r3, #176]	; 0xb0
    while (socket_ptr -> nx_tcp_socket_receive_queue_count)
 800e390:	687b      	ldr	r3, [r7, #4]
 800e392:	f8d3 30b0 	ldr.w	r3, [r3, #176]	; 0xb0
 800e396:	2b00      	cmp	r3, #0
 800e398:	d1e7      	bne.n	800e36a <_nx_tcp_socket_receive_queue_flush+0x22>
    }
}
 800e39a:	bf00      	nop
 800e39c:	bf00      	nop
 800e39e:	3710      	adds	r7, #16
 800e3a0:	46bd      	mov	sp, r7
 800e3a2:	bd80      	pop	{r7, pc}

0800e3a4 <_nx_tcp_socket_retransmit>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
VOID  _nx_tcp_socket_retransmit(NX_IP *ip_ptr, NX_TCP_SOCKET *socket_ptr, UINT need_fast_retransmit)
{
 800e3a4:	b590      	push	{r4, r7, lr}
 800e3a6:	b097      	sub	sp, #92	; 0x5c
 800e3a8:	af04      	add	r7, sp, #16
 800e3aa:	60f8      	str	r0, [r7, #12]
 800e3ac:	60b9      	str	r1, [r7, #8]
 800e3ae:	607a      	str	r2, [r7, #4]
       RFC 793 Sec 3.7, p42: keep send new data.

       In the zero window probe phase, we send the zero window probe, and increase
       exponentially the interval between successive probes.
       RFC 1122 Sec 4.2.2.17, p92.  */
    if (socket_ptr -> nx_tcp_socket_tx_window_advertised == 0)
 800e3b0:	68bb      	ldr	r3, [r7, #8]
 800e3b2:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 800e3b4:	2b00      	cmp	r3, #0
 800e3b6:	d164      	bne.n	800e482 <_nx_tcp_socket_retransmit+0xde>
    {

        /* Pickup the head of the transmit queue.  */
        packet_ptr =  socket_ptr -> nx_tcp_socket_transmit_sent_head;
 800e3b8:	68bb      	ldr	r3, [r7, #8]
 800e3ba:	f8d3 30c4 	ldr.w	r3, [r3, #196]	; 0xc4
 800e3be:	647b      	str	r3, [r7, #68]	; 0x44

        if (packet_ptr)
 800e3c0:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 800e3c2:	2b00      	cmp	r3, #0
 800e3c4:	d02f      	beq.n	800e426 <_nx_tcp_socket_retransmit+0x82>
        {

        /* Get one byte from send queue. */
        /* Pick up the pointer to the head of the TCP packet.  */
        /*lint -e{927} -e{826} suppress cast of pointer to pointer, since it is necessary  */
        NX_TCP_HEADER *header_ptr =  (NX_TCP_HEADER *)packet_ptr -> nx_packet_prepend_ptr;
 800e3c6:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 800e3c8:	689b      	ldr	r3, [r3, #8]
 800e3ca:	617b      	str	r3, [r7, #20]

            NX_CHANGE_ULONG_ENDIAN(header_ptr -> nx_tcp_header_word_3);
 800e3cc:	697b      	ldr	r3, [r7, #20]
 800e3ce:	68db      	ldr	r3, [r3, #12]
 800e3d0:	ba1a      	rev	r2, r3
 800e3d2:	697b      	ldr	r3, [r7, #20]
 800e3d4:	60da      	str	r2, [r3, #12]
            NX_CHANGE_ULONG_ENDIAN(header_ptr -> nx_tcp_sequence_number);
 800e3d6:	697b      	ldr	r3, [r7, #20]
 800e3d8:	685b      	ldr	r3, [r3, #4]
 800e3da:	ba1a      	rev	r2, r3
 800e3dc:	697b      	ldr	r3, [r7, #20]
 800e3de:	605a      	str	r2, [r3, #4]

            /* Get sequence number and first byte. */
            socket_ptr -> nx_tcp_socket_zero_window_probe_data = *(packet_ptr -> nx_packet_prepend_ptr + ((header_ptr -> nx_tcp_header_word_3 >> 28) << 2));
 800e3e0:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 800e3e2:	689a      	ldr	r2, [r3, #8]
 800e3e4:	697b      	ldr	r3, [r7, #20]
 800e3e6:	68db      	ldr	r3, [r3, #12]
 800e3e8:	0f1b      	lsrs	r3, r3, #28
 800e3ea:	009b      	lsls	r3, r3, #2
 800e3ec:	4413      	add	r3, r2
 800e3ee:	781a      	ldrb	r2, [r3, #0]
 800e3f0:	68bb      	ldr	r3, [r7, #8]
 800e3f2:	f883 209d 	strb.w	r2, [r3, #157]	; 0x9d

            /* Now set zero window probe started. */
            socket_ptr -> nx_tcp_socket_zero_window_probe_has_data = NX_TRUE;
 800e3f6:	68bb      	ldr	r3, [r7, #8]
 800e3f8:	2201      	movs	r2, #1
 800e3fa:	f883 209c 	strb.w	r2, [r3, #156]	; 0x9c
            socket_ptr -> nx_tcp_socket_zero_window_probe_sequence = header_ptr -> nx_tcp_sequence_number;
 800e3fe:	697b      	ldr	r3, [r7, #20]
 800e400:	685a      	ldr	r2, [r3, #4]
 800e402:	68bb      	ldr	r3, [r7, #8]
 800e404:	f8c3 2098 	str.w	r2, [r3, #152]	; 0x98
            socket_ptr -> nx_tcp_socket_zero_window_probe_failure = 0;
 800e408:	68bb      	ldr	r3, [r7, #8]
 800e40a:	2200      	movs	r2, #0
 800e40c:	f8c3 2094 	str.w	r2, [r3, #148]	; 0x94

            NX_CHANGE_ULONG_ENDIAN(header_ptr -> nx_tcp_sequence_number);
 800e410:	697b      	ldr	r3, [r7, #20]
 800e412:	685b      	ldr	r3, [r3, #4]
 800e414:	ba1a      	rev	r2, r3
 800e416:	697b      	ldr	r3, [r7, #20]
 800e418:	605a      	str	r2, [r3, #4]
            NX_CHANGE_ULONG_ENDIAN(header_ptr -> nx_tcp_header_word_3);
 800e41a:	697b      	ldr	r3, [r7, #20]
 800e41c:	68db      	ldr	r3, [r3, #12]
 800e41e:	ba1a      	rev	r2, r3
 800e420:	697b      	ldr	r3, [r7, #20]
 800e422:	60da      	str	r2, [r3, #12]
 800e424:	e005      	b.n	800e432 <_nx_tcp_socket_retransmit+0x8e>
        }
        else if (socket_ptr -> nx_tcp_socket_zero_window_probe_has_data == NX_FALSE)
 800e426:	68bb      	ldr	r3, [r7, #8]
 800e428:	f893 309c 	ldrb.w	r3, [r3, #156]	; 0x9c
 800e42c:	2b00      	cmp	r3, #0
 800e42e:	f000 8154 	beq.w	800e6da <_nx_tcp_socket_retransmit+0x336>

        /* In the zero window probe phase, we send the zero window probe, and increase
           exponentially the interval between successive probes.  */

        /* Increment the retry counter.  */
        socket_ptr -> nx_tcp_socket_timeout_retries++;
 800e432:	68bb      	ldr	r3, [r7, #8]
 800e434:	f8d3 30d4 	ldr.w	r3, [r3, #212]	; 0xd4
 800e438:	1c5a      	adds	r2, r3, #1
 800e43a:	68bb      	ldr	r3, [r7, #8]
 800e43c:	f8c3 20d4 	str.w	r2, [r3, #212]	; 0xd4
        socket_ptr -> nx_tcp_socket_zero_window_probe_failure++;
 800e440:	68bb      	ldr	r3, [r7, #8]
 800e442:	f8d3 3094 	ldr.w	r3, [r3, #148]	; 0x94
 800e446:	1c5a      	adds	r2, r3, #1
 800e448:	68bb      	ldr	r3, [r7, #8]
 800e44a:	f8c3 2094 	str.w	r2, [r3, #148]	; 0x94

        /* Setup the next timeout.  */
        socket_ptr -> nx_tcp_socket_timeout = socket_ptr -> nx_tcp_socket_timeout_rate <<
 800e44e:	68bb      	ldr	r3, [r7, #8]
 800e450:	f8d3 20d0 	ldr.w	r2, [r3, #208]	; 0xd0
            (socket_ptr -> nx_tcp_socket_timeout_retries * socket_ptr -> nx_tcp_socket_timeout_shift);
 800e454:	68bb      	ldr	r3, [r7, #8]
 800e456:	f8d3 30d4 	ldr.w	r3, [r3, #212]	; 0xd4
 800e45a:	68b9      	ldr	r1, [r7, #8]
 800e45c:	f8d1 10dc 	ldr.w	r1, [r1, #220]	; 0xdc
 800e460:	fb01 f303 	mul.w	r3, r1, r3
        socket_ptr -> nx_tcp_socket_timeout = socket_ptr -> nx_tcp_socket_timeout_rate <<
 800e464:	409a      	lsls	r2, r3
 800e466:	68bb      	ldr	r3, [r7, #8]
 800e468:	f8c3 20cc 	str.w	r2, [r3, #204]	; 0xcc

        /* Send the zero window probe.  */
        _nx_tcp_packet_send_probe(socket_ptr, socket_ptr -> nx_tcp_socket_zero_window_probe_sequence,
 800e46c:	68bb      	ldr	r3, [r7, #8]
 800e46e:	f8d3 1098 	ldr.w	r1, [r3, #152]	; 0x98
 800e472:	68bb      	ldr	r3, [r7, #8]
 800e474:	f893 309d 	ldrb.w	r3, [r3, #157]	; 0x9d
 800e478:	461a      	mov	r2, r3
 800e47a:	68b8      	ldr	r0, [r7, #8]
 800e47c:	f7ff fb94 	bl	800dba8 <_nx_tcp_packet_send_probe>
                                  socket_ptr -> nx_tcp_socket_zero_window_probe_data);

        return;
 800e480:	e12e      	b.n	800e6e0 <_nx_tcp_socket_retransmit+0x33c>
    }
    else if (socket_ptr -> nx_tcp_socket_zero_window_probe_has_data == NX_TRUE)
 800e482:	68bb      	ldr	r3, [r7, #8]
 800e484:	f893 309c 	ldrb.w	r3, [r3, #156]	; 0x9c
 800e488:	2b01      	cmp	r3, #1
 800e48a:	d103      	bne.n	800e494 <_nx_tcp_socket_retransmit+0xf0>
    {

        /* If advertised window isn't zero, reset zero window probe flag. */
        socket_ptr -> nx_tcp_socket_zero_window_probe_has_data = NX_FALSE;
 800e48c:	68bb      	ldr	r3, [r7, #8]
 800e48e:	2200      	movs	r2, #0
 800e490:	f883 209c 	strb.w	r2, [r3, #156]	; 0x9c
    }

    /* Increment the retry counter only if the receiver window is open. */
    /* Increment the retry counter.  */
    socket_ptr -> nx_tcp_socket_timeout_retries++;
 800e494:	68bb      	ldr	r3, [r7, #8]
 800e496:	f8d3 30d4 	ldr.w	r3, [r3, #212]	; 0xd4
 800e49a:	1c5a      	adds	r2, r3, #1
 800e49c:	68bb      	ldr	r3, [r7, #8]
 800e49e:	f8c3 20d4 	str.w	r2, [r3, #212]	; 0xd4

    if ((need_fast_retransmit == NX_TRUE) || (socket_ptr -> nx_tcp_socket_fast_recovery == NX_FALSE))
 800e4a2:	687b      	ldr	r3, [r7, #4]
 800e4a4:	2b01      	cmp	r3, #1
 800e4a6:	d004      	beq.n	800e4b2 <_nx_tcp_socket_retransmit+0x10e>
 800e4a8:	68bb      	ldr	r3, [r7, #8]
 800e4aa:	f893 309e 	ldrb.w	r3, [r3, #158]	; 0x9e
 800e4ae:	2b00      	cmp	r3, #0
 800e4b0:	d12a      	bne.n	800e508 <_nx_tcp_socket_retransmit+0x164>
    {

        /* Timed out on an outgoing packet.  Enter slow start mode. */
        /* Compute the flight size / 2 value. */
        window = socket_ptr -> nx_tcp_socket_tx_outstanding_bytes >> 1;
 800e4b2:	68bb      	ldr	r3, [r7, #8]
 800e4b4:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
 800e4b6:	085b      	lsrs	r3, r3, #1
 800e4b8:	643b      	str	r3, [r7, #64]	; 0x40

        /* Make sure we have at least 2 * MSS */
        if (window < (socket_ptr -> nx_tcp_socket_connect_mss << 1))
 800e4ba:	68bb      	ldr	r3, [r7, #8]
 800e4bc:	6a1b      	ldr	r3, [r3, #32]
 800e4be:	005b      	lsls	r3, r3, #1
 800e4c0:	6c3a      	ldr	r2, [r7, #64]	; 0x40
 800e4c2:	429a      	cmp	r2, r3
 800e4c4:	d203      	bcs.n	800e4ce <_nx_tcp_socket_retransmit+0x12a>
        {
            window = socket_ptr -> nx_tcp_socket_connect_mss << 1;
 800e4c6:	68bb      	ldr	r3, [r7, #8]
 800e4c8:	6a1b      	ldr	r3, [r3, #32]
 800e4ca:	005b      	lsls	r3, r3, #1
 800e4cc:	643b      	str	r3, [r7, #64]	; 0x40
        }

        /* Set the slow_start_threshold */
        socket_ptr -> nx_tcp_socket_tx_slow_start_threshold = window;
 800e4ce:	68bb      	ldr	r3, [r7, #8]
 800e4d0:	6c3a      	ldr	r2, [r7, #64]	; 0x40
 800e4d2:	635a      	str	r2, [r3, #52]	; 0x34

        /* Set the current window to be MSS size. */
        socket_ptr -> nx_tcp_socket_tx_window_congestion = socket_ptr -> nx_tcp_socket_connect_mss;
 800e4d4:	68bb      	ldr	r3, [r7, #8]
 800e4d6:	6a1a      	ldr	r2, [r3, #32]
 800e4d8:	68bb      	ldr	r3, [r7, #8]
 800e4da:	659a      	str	r2, [r3, #88]	; 0x58

        /* Determine if this socket needs fast retransmit.  */
        if (need_fast_retransmit == NX_TRUE)
 800e4dc:	687b      	ldr	r3, [r7, #4]
 800e4de:	2b01      	cmp	r3, #1
 800e4e0:	d112      	bne.n	800e508 <_nx_tcp_socket_retransmit+0x164>
        {

            /* Update cwnd to ssthreshold plus 3 * MSS.  */
            socket_ptr -> nx_tcp_socket_tx_window_congestion += window + (socket_ptr -> nx_tcp_socket_connect_mss << 1);
 800e4e2:	68bb      	ldr	r3, [r7, #8]
 800e4e4:	6d9a      	ldr	r2, [r3, #88]	; 0x58
 800e4e6:	68bb      	ldr	r3, [r7, #8]
 800e4e8:	6a1b      	ldr	r3, [r3, #32]
 800e4ea:	0059      	lsls	r1, r3, #1
 800e4ec:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 800e4ee:	440b      	add	r3, r1
 800e4f0:	441a      	add	r2, r3
 800e4f2:	68bb      	ldr	r3, [r7, #8]
 800e4f4:	659a      	str	r2, [r3, #88]	; 0x58

            /* Now TCP is in fast recovery procedure. */
            socket_ptr -> nx_tcp_socket_fast_recovery = NX_TRUE;
 800e4f6:	68bb      	ldr	r3, [r7, #8]
 800e4f8:	2201      	movs	r2, #1
 800e4fa:	f883 209e 	strb.w	r2, [r3, #158]	; 0x9e

            /* Update the transmit sequence that enters fast transmit. */
            socket_ptr -> nx_tcp_socket_tx_sequence_recover = socket_ptr -> nx_tcp_socket_tx_sequence - 1;
 800e4fe:	68bb      	ldr	r3, [r7, #8]
 800e500:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 800e502:	1e5a      	subs	r2, r3, #1
 800e504:	68bb      	ldr	r3, [r7, #8]
 800e506:	661a      	str	r2, [r3, #96]	; 0x60
        }
    }

    /* Setup the next timeout.  */
    socket_ptr -> nx_tcp_socket_timeout = socket_ptr -> nx_tcp_socket_timeout_rate <<
 800e508:	68bb      	ldr	r3, [r7, #8]
 800e50a:	f8d3 20d0 	ldr.w	r2, [r3, #208]	; 0xd0
        (socket_ptr -> nx_tcp_socket_timeout_retries * socket_ptr -> nx_tcp_socket_timeout_shift);
 800e50e:	68bb      	ldr	r3, [r7, #8]
 800e510:	f8d3 30d4 	ldr.w	r3, [r3, #212]	; 0xd4
 800e514:	68b9      	ldr	r1, [r7, #8]
 800e516:	f8d1 10dc 	ldr.w	r1, [r1, #220]	; 0xdc
 800e51a:	fb01 f303 	mul.w	r3, r1, r3
    socket_ptr -> nx_tcp_socket_timeout = socket_ptr -> nx_tcp_socket_timeout_rate <<
 800e51e:	409a      	lsls	r2, r3
 800e520:	68bb      	ldr	r3, [r7, #8]
 800e522:	f8c3 20cc 	str.w	r2, [r3, #204]	; 0xcc

    /* Get available size of packet that can be sent. */
    available = socket_ptr -> nx_tcp_socket_tx_window_congestion;
 800e526:	68bb      	ldr	r3, [r7, #8]
 800e528:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 800e52a:	63fb      	str	r3, [r7, #60]	; 0x3c

    /* Pickup the head of the transmit queue.  */
    packet_ptr =  socket_ptr -> nx_tcp_socket_transmit_sent_head;
 800e52c:	68bb      	ldr	r3, [r7, #8]
 800e52e:	f8d3 30c4 	ldr.w	r3, [r3, #196]	; 0xc4
 800e532:	647b      	str	r3, [r7, #68]	; 0x44

    /* Determine if the packet has been released by the
       application I/O driver.  */
    /*lint -e{923} suppress cast of ULONG to pointer.  */
    while (packet_ptr && (packet_ptr -> nx_packet_queue_next == (NX_PACKET *)NX_DRIVER_TX_DONE))
 800e534:	e0c7      	b.n	800e6c6 <_nx_tcp_socket_retransmit+0x322>
    {

    /* Update the ACK number in case it has changed since the data was originally transmitted. */
    ULONG          checksum;
    NX_TCP_HEADER *header_ptr;
    ULONG         *source_ip = NX_NULL, *dest_ip = NX_NULL;
 800e536:	2300      	movs	r3, #0
 800e538:	63bb      	str	r3, [r7, #56]	; 0x38
 800e53a:	2300      	movs	r3, #0
 800e53c:	637b      	str	r3, [r7, #52]	; 0x34

#ifdef NX_DISABLE_TCP_TX_CHECKSUM
        compute_checksum = 0;
#endif /* NX_DISABLE_TCP_TX_CHECKSUM */

        if (packet_ptr -> nx_packet_length > (available + sizeof(NX_TCP_HEADER)))
 800e53e:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 800e540:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 800e542:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800e544:	3314      	adds	r3, #20
 800e546:	429a      	cmp	r2, r3
 800e548:	f200 80c9 	bhi.w	800e6de <_nx_tcp_socket_retransmit+0x33a>
            /* This packet can not be sent. */
            break;
        }

        /* Decrease the available size. */
        available -= (packet_ptr -> nx_packet_length - (ULONG)sizeof(NX_TCP_HEADER));
 800e54c:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 800e54e:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800e550:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 800e552:	1ad3      	subs	r3, r2, r3
 800e554:	3314      	adds	r3, #20
 800e556:	63fb      	str	r3, [r7, #60]	; 0x3c

        /* Pickup next packet. */
        next_ptr = packet_ptr -> nx_packet_union_next.nx_packet_tcp_queue_next;
 800e558:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 800e55a:	6a1b      	ldr	r3, [r3, #32]
 800e55c:	633b      	str	r3, [r7, #48]	; 0x30

#ifndef NX_DISABLE_IPV4
        /* Is this an IPv4 connection? */
        if (socket_ptr -> nx_tcp_socket_connect_ip.nxd_ip_version == NX_IP_VERSION_V4)
 800e55e:	68bb      	ldr	r3, [r7, #8]
 800e560:	695b      	ldr	r3, [r3, #20]
 800e562:	2b04      	cmp	r3, #4
 800e564:	d10a      	bne.n	800e57c <_nx_tcp_socket_retransmit+0x1d8>
        {

            packet_ptr -> nx_packet_ip_version = NX_IP_VERSION_V4;
 800e566:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 800e568:	2204      	movs	r2, #4
 800e56a:	f883 202c 	strb.w	r2, [r3, #44]	; 0x2c

            /* Get the source and destination addresses. */
            source_ip = &socket_ptr -> nx_tcp_socket_connect_interface -> nx_interface_ip_address;
 800e56e:	68bb      	ldr	r3, [r7, #8]
 800e570:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 800e572:	3314      	adds	r3, #20
 800e574:	63bb      	str	r3, [r7, #56]	; 0x38
            dest_ip = &socket_ptr -> nx_tcp_socket_connect_ip.nxd_ip_address.v4;
 800e576:	68bb      	ldr	r3, [r7, #8]
 800e578:	3318      	adds	r3, #24
 800e57a:	637b      	str	r3, [r7, #52]	; 0x34
        }
#endif /* FEATURE_NX_IPV6 */

        /* Pick up the pointer to the head of the TCP packet.  */
        /*lint -e{927} -e{826} suppress cast of pointer to pointer, since it is necessary  */
        header_ptr =  (NX_TCP_HEADER *)packet_ptr -> nx_packet_prepend_ptr;
 800e57c:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 800e57e:	689b      	ldr	r3, [r3, #8]
 800e580:	62fb      	str	r3, [r7, #44]	; 0x2c

        /* Record the original data.  */
        original_acknowledgment_number = header_ptr -> nx_tcp_acknowledgment_number;
 800e582:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800e584:	689b      	ldr	r3, [r3, #8]
 800e586:	62bb      	str	r3, [r7, #40]	; 0x28
        original_header_word_3 = header_ptr -> nx_tcp_header_word_3;
 800e588:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800e58a:	68db      	ldr	r3, [r3, #12]
 800e58c:	627b      	str	r3, [r7, #36]	; 0x24
        original_header_word_4 = header_ptr -> nx_tcp_header_word_4;
 800e58e:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800e590:	691b      	ldr	r3, [r3, #16]
 800e592:	623b      	str	r3, [r7, #32]

        /* Update the ACK number in the TCP header.  */
        header_ptr -> nx_tcp_acknowledgment_number = socket_ptr -> nx_tcp_socket_rx_sequence;
 800e594:	68bb      	ldr	r3, [r7, #8]
 800e596:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 800e598:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800e59a:	609a      	str	r2, [r3, #8]

        /* Convert to network byte order for checksum */
        NX_CHANGE_ULONG_ENDIAN(header_ptr -> nx_tcp_acknowledgment_number);
 800e59c:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800e59e:	689b      	ldr	r3, [r3, #8]
 800e5a0:	ba1a      	rev	r2, r3
 800e5a2:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800e5a4:	609a      	str	r2, [r3, #8]
        if (window_size > 0xFFFF)
        {
            window_size = 0xFFFF;
        }
#else
        window_size = socket_ptr -> nx_tcp_socket_rx_window_current;
 800e5a6:	68bb      	ldr	r3, [r7, #8]
 800e5a8:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 800e5aa:	61fb      	str	r3, [r7, #28]
#endif /* NX_ENABLE_TCP_WINDOW_SCALING */

        header_ptr -> nx_tcp_header_word_3 =        NX_TCP_HEADER_SIZE | NX_TCP_ACK_BIT | NX_TCP_PSH_BIT | window_size;
 800e5ac:	69fa      	ldr	r2, [r7, #28]
 800e5ae:	4b4e      	ldr	r3, [pc, #312]	; (800e6e8 <_nx_tcp_socket_retransmit+0x344>)
 800e5b0:	4313      	orrs	r3, r2
 800e5b2:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 800e5b4:	60d3      	str	r3, [r2, #12]

        /* Swap the content to network byte order. */
        NX_CHANGE_ULONG_ENDIAN(header_ptr -> nx_tcp_header_word_3);
 800e5b6:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800e5b8:	68db      	ldr	r3, [r3, #12]
 800e5ba:	ba1a      	rev	r2, r3
 800e5bc:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800e5be:	60da      	str	r2, [r3, #12]

        /* Convert back to host byte order to so we can zero out the checksum. */
        NX_CHANGE_ULONG_ENDIAN(header_ptr -> nx_tcp_header_word_4);
 800e5c0:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800e5c2:	691b      	ldr	r3, [r3, #16]
 800e5c4:	ba1a      	rev	r2, r3
 800e5c6:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800e5c8:	611a      	str	r2, [r3, #16]

        /* Remember the last ACKed sequence and the last reported window size.  */
        socket_ptr -> nx_tcp_socket_rx_sequence_acked =    socket_ptr -> nx_tcp_socket_rx_sequence;
 800e5ca:	68bb      	ldr	r3, [r7, #8]
 800e5cc:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 800e5ce:	68bb      	ldr	r3, [r7, #8]
 800e5d0:	645a      	str	r2, [r3, #68]	; 0x44
        socket_ptr -> nx_tcp_socket_rx_window_last_sent =  socket_ptr -> nx_tcp_socket_rx_window_current;
 800e5d2:	68bb      	ldr	r3, [r7, #8]
 800e5d4:	6f5a      	ldr	r2, [r3, #116]	; 0x74
 800e5d6:	68bb      	ldr	r3, [r7, #8]
 800e5d8:	679a      	str	r2, [r3, #120]	; 0x78

        /* Zero out existing checksum before computing new one. */
        header_ptr -> nx_tcp_header_word_4 = header_ptr -> nx_tcp_header_word_4 & 0x0000FFFF;
 800e5da:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800e5dc:	691b      	ldr	r3, [r3, #16]
 800e5de:	b29a      	uxth	r2, r3
 800e5e0:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800e5e2:	611a      	str	r2, [r3, #16]

        /* Convert back to network byte order to so we can do the checksum. */
        NX_CHANGE_ULONG_ENDIAN(header_ptr -> nx_tcp_header_word_4);
 800e5e4:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800e5e6:	691b      	ldr	r3, [r3, #16]
 800e5e8:	ba1a      	rev	r2, r3
 800e5ea:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800e5ec:	611a      	str	r2, [r3, #16]
        if (compute_checksum)
#endif /* defined(NX_DISABLE_TCP_TX_CHECKSUM) || defined(NX_ENABLE_INTERFACE_CAPABILITY) || defined(NX_IPSEC_ENABLE) */
        {
            /* Calculate the TCP checksum without protection.  */
            checksum =  _nx_ip_checksum_compute(packet_ptr, NX_PROTOCOL_TCP,
                                                packet_ptr -> nx_packet_length,
 800e5ee:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 800e5f0:	6a5a      	ldr	r2, [r3, #36]	; 0x24
            checksum =  _nx_ip_checksum_compute(packet_ptr, NX_PROTOCOL_TCP,
 800e5f2:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800e5f4:	9300      	str	r3, [sp, #0]
 800e5f6:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800e5f8:	2106      	movs	r1, #6
 800e5fa:	6c78      	ldr	r0, [r7, #68]	; 0x44
 800e5fc:	f7fb fb14 	bl	8009c28 <_nx_ip_checksum_compute>
 800e600:	4603      	mov	r3, r0
 800e602:	61bb      	str	r3, [r7, #24]
                                                source_ip, dest_ip);
            checksum = ~checksum & NX_LOWER_16_MASK;
 800e604:	69bb      	ldr	r3, [r7, #24]
 800e606:	43db      	mvns	r3, r3
 800e608:	b29b      	uxth	r3, r3
 800e60a:	61bb      	str	r3, [r7, #24]

            /* Convert back to host byte order */
            NX_CHANGE_ULONG_ENDIAN(header_ptr -> nx_tcp_header_word_4);
 800e60c:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800e60e:	691b      	ldr	r3, [r3, #16]
 800e610:	ba1a      	rev	r2, r3
 800e612:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800e614:	611a      	str	r2, [r3, #16]

            /* Move the checksum into header.  */
            header_ptr -> nx_tcp_header_word_4 =  header_ptr -> nx_tcp_header_word_4 | (checksum << NX_SHIFT_BY_16);
 800e616:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800e618:	691a      	ldr	r2, [r3, #16]
 800e61a:	69bb      	ldr	r3, [r7, #24]
 800e61c:	041b      	lsls	r3, r3, #16
 800e61e:	431a      	orrs	r2, r3
 800e620:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800e622:	611a      	str	r2, [r3, #16]

            /* Convert back to network byte order for transmit. */
            NX_CHANGE_ULONG_ENDIAN(header_ptr -> nx_tcp_header_word_4);
 800e624:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800e626:	691b      	ldr	r3, [r3, #16]
 800e628:	ba1a      	rev	r2, r3
 800e62a:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800e62c:	611a      	str	r2, [r3, #16]
        }
#endif /* NX_ENABLE_INTERFACE_CAPABILITY */

        /* Determine if the retransmitted packet is identical to the original packet.
           RFC1122, Section3.2.1.5, Page32-33. RFC1122, Section4.2.2.15, Page90-91.  */
        if ((header_ptr -> nx_tcp_acknowledgment_number == original_acknowledgment_number) &&
 800e62e:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800e630:	689b      	ldr	r3, [r3, #8]
 800e632:	6aba      	ldr	r2, [r7, #40]	; 0x28
 800e634:	429a      	cmp	r2, r3
 800e636:	d10d      	bne.n	800e654 <_nx_tcp_socket_retransmit+0x2b0>
            (header_ptr -> nx_tcp_header_word_3 == original_header_word_3) &&
 800e638:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800e63a:	68db      	ldr	r3, [r3, #12]
        if ((header_ptr -> nx_tcp_acknowledgment_number == original_acknowledgment_number) &&
 800e63c:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 800e63e:	429a      	cmp	r2, r3
 800e640:	d108      	bne.n	800e654 <_nx_tcp_socket_retransmit+0x2b0>
            (header_ptr -> nx_tcp_header_word_4 == original_header_word_4))
 800e642:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800e644:	691b      	ldr	r3, [r3, #16]
            (header_ptr -> nx_tcp_header_word_3 == original_header_word_3) &&
 800e646:	6a3a      	ldr	r2, [r7, #32]
 800e648:	429a      	cmp	r2, r3
 800e64a:	d103      	bne.n	800e654 <_nx_tcp_socket_retransmit+0x2b0>
        {

            /* Yes, identical packet, update the identification flag.  */
            packet_ptr -> nx_packet_identical_copy = NX_TRUE;
 800e64c:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 800e64e:	2201      	movs	r2, #1
 800e650:	f883 202d 	strb.w	r2, [r3, #45]	; 0x2d
        }


#ifndef NX_DISABLE_TCP_INFO
        /* Increment the TCP retransmit count.  */
        ip_ptr -> nx_ip_tcp_retransmit_packets++;
 800e654:	68fb      	ldr	r3, [r7, #12]
 800e656:	f8d3 30d8 	ldr.w	r3, [r3, #216]	; 0xd8
 800e65a:	1c5a      	adds	r2, r3, #1
 800e65c:	68fb      	ldr	r3, [r7, #12]
 800e65e:	f8c3 20d8 	str.w	r2, [r3, #216]	; 0xd8

        /* Increment the TCP retransmit count for the socket.  */
        socket_ptr -> nx_tcp_socket_retransmit_packets++;
 800e662:	68bb      	ldr	r3, [r7, #8]
 800e664:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
 800e668:	1c5a      	adds	r2, r3, #1
 800e66a:	68bb      	ldr	r3, [r7, #8]
 800e66c:	f8c3 208c 	str.w	r2, [r3, #140]	; 0x8c

        /* If trace is enabled, insert this event into the trace buffer.  */
        NX_TRACE_IN_LINE_INSERT(NX_TRACE_INTERNAL_TCP_RETRY, ip_ptr, socket_ptr, packet_ptr, socket_ptr -> nx_tcp_socket_timeout_retries, NX_TRACE_INTERNAL_EVENTS, 0, 0);

        /* Clear the queue next pointer.  */
        packet_ptr -> nx_packet_queue_next =  NX_NULL;
 800e670:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 800e672:	2200      	movs	r2, #0
 800e674:	61da      	str	r2, [r3, #28]
        /* Yes, the driver has finished with the packet at the head of the
           transmit sent list... so it can be sent again!  */

#ifndef NX_DISABLE_IPV4
        /* Is this an IPv4 connection? */
        if (socket_ptr -> nx_tcp_socket_connect_ip.nxd_ip_version == NX_IP_VERSION_V4)
 800e676:	68bb      	ldr	r3, [r7, #8]
 800e678:	695b      	ldr	r3, [r3, #20]
 800e67a:	2b04      	cmp	r3, #4
 800e67c:	d118      	bne.n	800e6b0 <_nx_tcp_socket_retransmit+0x30c>
        {
            _nx_ip_packet_send(ip_ptr, packet_ptr,
 800e67e:	68bb      	ldr	r3, [r7, #8]
 800e680:	6998      	ldr	r0, [r3, #24]
 800e682:	68bb      	ldr	r3, [r7, #8]
 800e684:	f8d3 40a4 	ldr.w	r4, [r3, #164]	; 0xa4
                               socket_ptr -> nx_tcp_socket_connect_ip.nxd_ip_address.v4,
                               socket_ptr -> nx_tcp_socket_type_of_service,
                               socket_ptr -> nx_tcp_socket_time_to_live, NX_IP_TCP,
 800e688:	68bb      	ldr	r3, [r7, #8]
 800e68a:	f8d3 30a8 	ldr.w	r3, [r3, #168]	; 0xa8
            _nx_ip_packet_send(ip_ptr, packet_ptr,
 800e68e:	68ba      	ldr	r2, [r7, #8]
 800e690:	f8d2 20ac 	ldr.w	r2, [r2, #172]	; 0xac
 800e694:	68b9      	ldr	r1, [r7, #8]
 800e696:	6ac9      	ldr	r1, [r1, #44]	; 0x2c
 800e698:	9103      	str	r1, [sp, #12]
 800e69a:	9202      	str	r2, [sp, #8]
 800e69c:	f44f 22c0 	mov.w	r2, #393216	; 0x60000
 800e6a0:	9201      	str	r2, [sp, #4]
 800e6a2:	9300      	str	r3, [sp, #0]
 800e6a4:	4623      	mov	r3, r4
 800e6a6:	4602      	mov	r2, r0
 800e6a8:	6c79      	ldr	r1, [r7, #68]	; 0x44
 800e6aa:	68f8      	ldr	r0, [r7, #12]
 800e6ac:	f7fc fb40 	bl	800ad30 <_nx_ip_packet_send>
#endif /* FEATURE_NX_IPV6 */

        /* Move to next packet. */
        /* During fast recovery, only one packet is retransmitted at once. */
        /* After a timeout, the sending data can be at most one SMSS. */
        if ((next_ptr == (NX_PACKET *)NX_PACKET_ENQUEUED) ||
 800e6b0:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800e6b2:	f1b3 3fee 	cmp.w	r3, #4008636142	; 0xeeeeeeee
 800e6b6:	d013      	beq.n	800e6e0 <_nx_tcp_socket_retransmit+0x33c>
            (socket_ptr -> nx_tcp_socket_fast_recovery == NX_TRUE))
 800e6b8:	68bb      	ldr	r3, [r7, #8]
 800e6ba:	f893 309e 	ldrb.w	r3, [r3, #158]	; 0x9e
        if ((next_ptr == (NX_PACKET *)NX_PACKET_ENQUEUED) ||
 800e6be:	2b01      	cmp	r3, #1
 800e6c0:	d00e      	beq.n	800e6e0 <_nx_tcp_socket_retransmit+0x33c>
        {
            break;
        }
        else
        {
            packet_ptr = next_ptr;
 800e6c2:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800e6c4:	647b      	str	r3, [r7, #68]	; 0x44
    while (packet_ptr && (packet_ptr -> nx_packet_queue_next == (NX_PACKET *)NX_DRIVER_TX_DONE))
 800e6c6:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 800e6c8:	2b00      	cmp	r3, #0
 800e6ca:	d009      	beq.n	800e6e0 <_nx_tcp_socket_retransmit+0x33c>
 800e6cc:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 800e6ce:	69db      	ldr	r3, [r3, #28]
 800e6d0:	f1b3 3fdd 	cmp.w	r3, #3722304989	; 0xdddddddd
 800e6d4:	f43f af2f 	beq.w	800e536 <_nx_tcp_socket_retransmit+0x192>
 800e6d8:	e002      	b.n	800e6e0 <_nx_tcp_socket_retransmit+0x33c>
            return;
 800e6da:	bf00      	nop
 800e6dc:	e000      	b.n	800e6e0 <_nx_tcp_socket_retransmit+0x33c>
            break;
 800e6de:	bf00      	nop
        }
    }
}
 800e6e0:	374c      	adds	r7, #76	; 0x4c
 800e6e2:	46bd      	mov	sp, r7
 800e6e4:	bd90      	pop	{r4, r7, pc}
 800e6e6:	bf00      	nop
 800e6e8:	50180000 	.word	0x50180000

0800e6ec <_nx_tcp_socket_state_ack_check>:
/*                                            fixed compiler warnings,    */
/*                                            resulting in version 6.1.7  */
/*                                                                        */
/**************************************************************************/
UINT  _nx_tcp_socket_state_ack_check(NX_TCP_SOCKET *socket_ptr, NX_TCP_HEADER *tcp_header_ptr)
{
 800e6ec:	b580      	push	{r7, lr}
 800e6ee:	b090      	sub	sp, #64	; 0x40
 800e6f0:	af00      	add	r7, sp, #0
 800e6f2:	6078      	str	r0, [r7, #4]
 800e6f4:	6039      	str	r1, [r7, #0]

NX_TCP_HEADER *search_header_ptr = NX_NULL;
 800e6f6:	2300      	movs	r3, #0
 800e6f8:	63fb      	str	r3, [r7, #60]	; 0x3c
ULONG          starting_tx_sequence;
ULONG          ending_tx_sequence;
ULONG          ending_rx_sequence;
ULONG          acked_bytes;
ULONG          tcp_payload_length;
UINT           wrapped_flag = NX_FALSE;
 800e6fa:	2300      	movs	r3, #0
 800e6fc:	623b      	str	r3, [r7, #32]


    /* Determine if the header has an ACK bit set.  This is an
       acknowledgement of a previous transmission.  */
    if (tcp_header_ptr -> nx_tcp_header_word_3 & NX_TCP_ACK_BIT)
 800e6fe:	683b      	ldr	r3, [r7, #0]
 800e700:	68db      	ldr	r3, [r3, #12]
 800e702:	f403 1380 	and.w	r3, r3, #1048576	; 0x100000
 800e706:	2b00      	cmp	r3, #0
 800e708:	f000 82dc 	beq.w	800ecc4 <_nx_tcp_socket_state_ack_check+0x5d8>
    {

        /* Initialize tx sequence. */
        if (socket_ptr -> nx_tcp_socket_zero_window_probe_has_data)
 800e70c:	687b      	ldr	r3, [r7, #4]
 800e70e:	f893 309c 	ldrb.w	r3, [r3, #156]	; 0x9c
 800e712:	2b00      	cmp	r3, #0
 800e714:	d004      	beq.n	800e720 <_nx_tcp_socket_state_ack_check+0x34>
        {
            ending_tx_sequence = socket_ptr -> nx_tcp_socket_tx_sequence + 1;
 800e716:	687b      	ldr	r3, [r7, #4]
 800e718:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 800e71a:	3301      	adds	r3, #1
 800e71c:	62bb      	str	r3, [r7, #40]	; 0x28
 800e71e:	e002      	b.n	800e726 <_nx_tcp_socket_state_ack_check+0x3a>
        }
        else
        {
            ending_tx_sequence = socket_ptr -> nx_tcp_socket_tx_sequence;
 800e720:	687b      	ldr	r3, [r7, #4]
 800e722:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 800e724:	62bb      	str	r3, [r7, #40]	; 0x28
        }
        starting_tx_sequence = socket_ptr -> nx_tcp_socket_tx_sequence - socket_ptr -> nx_tcp_socket_tx_outstanding_bytes;
 800e726:	687b      	ldr	r3, [r7, #4]
 800e728:	6bda      	ldr	r2, [r3, #60]	; 0x3c
 800e72a:	687b      	ldr	r3, [r7, #4]
 800e72c:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
 800e72e:	1ad3      	subs	r3, r2, r3
 800e730:	61fb      	str	r3, [r7, #28]

        /* Initialize ending rx sequence. */
        if (socket_ptr -> nx_tcp_socket_receive_queue_tail)
 800e732:	687b      	ldr	r3, [r7, #4]
 800e734:	f8d3 30b8 	ldr.w	r3, [r3, #184]	; 0xb8
 800e738:	2b00      	cmp	r3, #0
 800e73a:	d028      	beq.n	800e78e <_nx_tcp_socket_state_ack_check+0xa2>
        {
            search_ptr = socket_ptr -> nx_tcp_socket_receive_queue_tail;
 800e73c:	687b      	ldr	r3, [r7, #4]
 800e73e:	f8d3 30b8 	ldr.w	r3, [r3, #184]	; 0xb8
 800e742:	63bb      	str	r3, [r7, #56]	; 0x38

            /* Setup a pointer to header of this packet in the sent list.  */
#ifndef NX_DISABLE_IPV4
            if (search_ptr -> nx_packet_ip_version == NX_IP_VERSION_V4)
 800e744:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800e746:	f893 302c 	ldrb.w	r3, [r3, #44]	; 0x2c
 800e74a:	2b04      	cmp	r3, #4
 800e74c:	d11d      	bne.n	800e78a <_nx_tcp_socket_state_ack_check+0x9e>
            {

                /*lint -e{927} -e{826} suppress cast of pointer to pointer, since it is necessary  */
                search_header_ptr =  (NX_TCP_HEADER *)(search_ptr -> nx_packet_ip_header +
 800e74e:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800e750:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 800e752:	3314      	adds	r3, #20
 800e754:	63fb      	str	r3, [r7, #60]	; 0x3c
            {
                return(NX_FALSE);
            }

            /* Determine the size of the TCP header.  */
            temp =  search_header_ptr -> nx_tcp_header_word_3;
 800e756:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800e758:	68db      	ldr	r3, [r3, #12]
 800e75a:	633b      	str	r3, [r7, #48]	; 0x30
            header_length =  (temp >> NX_TCP_HEADER_SHIFT) * (ULONG)sizeof(ULONG);
 800e75c:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800e75e:	0f1b      	lsrs	r3, r3, #28
 800e760:	009b      	lsls	r3, r3, #2
 800e762:	61bb      	str	r3, [r7, #24]

            /* Determine the sequence number in the TCP header.  */
            search_sequence =  search_header_ptr -> nx_tcp_sequence_number;
 800e764:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800e766:	685b      	ldr	r3, [r3, #4]
 800e768:	617b      	str	r3, [r7, #20]

            /* Calculate the payload length of TCP. */
            tcp_payload_length = (search_ptr -> nx_packet_length -
 800e76a:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800e76c:	6a5a      	ldr	r2, [r3, #36]	; 0x24
                                  (header_length +
                                   (ULONG)((ALIGN_TYPE)search_header_ptr -
                                           (ALIGN_TYPE)search_ptr -> nx_packet_prepend_ptr)));
 800e76e:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800e770:	689b      	ldr	r3, [r3, #8]
 800e772:	4619      	mov	r1, r3
                                   (ULONG)((ALIGN_TYPE)search_header_ptr -
 800e774:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800e776:	1ac9      	subs	r1, r1, r3
                                  (header_length +
 800e778:	69bb      	ldr	r3, [r7, #24]
 800e77a:	1acb      	subs	r3, r1, r3
            tcp_payload_length = (search_ptr -> nx_packet_length -
 800e77c:	4413      	add	r3, r2
 800e77e:	613b      	str	r3, [r7, #16]

            /* Calculate the ending packet sequence.  */
            ending_rx_sequence =  search_sequence + tcp_payload_length;
 800e780:	697a      	ldr	r2, [r7, #20]
 800e782:	693b      	ldr	r3, [r7, #16]
 800e784:	4413      	add	r3, r2
 800e786:	627b      	str	r3, [r7, #36]	; 0x24
 800e788:	e004      	b.n	800e794 <_nx_tcp_socket_state_ack_check+0xa8>
                return(NX_FALSE);
 800e78a:	2300      	movs	r3, #0
 800e78c:	e29b      	b.n	800ecc6 <_nx_tcp_socket_state_ack_check+0x5da>
        }
        else
        {
            ending_rx_sequence = socket_ptr -> nx_tcp_socket_rx_sequence;
 800e78e:	687b      	ldr	r3, [r7, #4]
 800e790:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 800e792:	627b      	str	r3, [r7, #36]	; 0x24
        }
#endif

        /* First, determine if incoming ACK matches our transmit sequence.  */
        /*lint -e{923} suppress cast of pointer to ULONG.  */
        if (tcp_header_ptr -> nx_tcp_acknowledgment_number == ending_tx_sequence)
 800e794:	683b      	ldr	r3, [r7, #0]
 800e796:	689b      	ldr	r3, [r3, #8]
 800e798:	6aba      	ldr	r2, [r7, #40]	; 0x28
 800e79a:	429a      	cmp	r2, r3
 800e79c:	d111      	bne.n	800e7c2 <_nx_tcp_socket_state_ack_check+0xd6>
        {

            /* In this case, everything on the transmit list is acknowledged.  Simply set the packet
               release count to the number of packets in the transmit queue.  */
            packet_release_count =  socket_ptr -> nx_tcp_socket_transmit_sent_count;
 800e79e:	687b      	ldr	r3, [r7, #4]
 800e7a0:	f8d3 30c0 	ldr.w	r3, [r3, #192]	; 0xc0
 800e7a4:	62fb      	str	r3, [r7, #44]	; 0x2c

            /* Set the previous pointer to the socket transmit tail pointer.  */
            previous_ptr =  socket_ptr -> nx_tcp_socket_transmit_sent_tail;
 800e7a6:	687b      	ldr	r3, [r7, #4]
 800e7a8:	f8d3 30c8 	ldr.w	r3, [r3, #200]	; 0xc8
 800e7ac:	637b      	str	r3, [r7, #52]	; 0x34

            /* Is this ACK to FIN? */
            if (socket_ptr -> nx_tcp_socket_state >= NX_TCP_FIN_WAIT_1)
 800e7ae:	687b      	ldr	r3, [r7, #4]
 800e7b0:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 800e7b2:	2b06      	cmp	r3, #6
 800e7b4:	f240 80d6 	bls.w	800e964 <_nx_tcp_socket_state_ack_check+0x278>
            {

                /* Yes it is. */
                socket_ptr -> nx_tcp_socket_fin_acked = NX_TRUE;
 800e7b8:	687b      	ldr	r3, [r7, #4]
 800e7ba:	2201      	movs	r2, #1
 800e7bc:	f8a3 2052 	strh.w	r2, [r3, #82]	; 0x52
 800e7c0:	e0d0      	b.n	800e964 <_nx_tcp_socket_state_ack_check+0x278>
        {

            /* Calculate the start and end of the transmit sequence.  */

            /* Pickup the head of the transmit queue.  */
            search_ptr =    socket_ptr -> nx_tcp_socket_transmit_sent_head;
 800e7c2:	687b      	ldr	r3, [r7, #4]
 800e7c4:	f8d3 30c4 	ldr.w	r3, [r3, #196]	; 0xc4
 800e7c8:	63bb      	str	r3, [r7, #56]	; 0x38

            /* Determine if there is a packet on the transmit queue... and determine if the packet has been
               transmitted.  */
            /*lint -e{923} suppress cast of ULONG to pointer.  */
            if ((search_ptr) && (search_ptr -> nx_packet_queue_next == ((NX_PACKET *)NX_DRIVER_TX_DONE)))
 800e7ca:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800e7cc:	2b00      	cmp	r3, #0
 800e7ce:	d059      	beq.n	800e884 <_nx_tcp_socket_state_ack_check+0x198>
 800e7d0:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800e7d2:	69db      	ldr	r3, [r3, #28]
 800e7d4:	f1b3 3fdd 	cmp.w	r3, #3722304989	; 0xdddddddd
 800e7d8:	d154      	bne.n	800e884 <_nx_tcp_socket_state_ack_check+0x198>
            {

                /* Setup a pointer to header of this packet in the sent list.  */
                /*lint -e{927} -e{826} suppress cast of pointer to pointer, since it is necessary  */
                search_header_ptr =  (NX_TCP_HEADER *)search_ptr -> nx_packet_prepend_ptr;
 800e7da:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800e7dc:	689b      	ldr	r3, [r3, #8]
 800e7de:	63fb      	str	r3, [r7, #60]	; 0x3c

                /* Determine if the incoming ACK matches the front of our transmit queue. */
                if (tcp_header_ptr -> nx_tcp_acknowledgment_number == starting_tx_sequence)
 800e7e0:	683b      	ldr	r3, [r7, #0]
 800e7e2:	689b      	ldr	r3, [r3, #8]
 800e7e4:	69fa      	ldr	r2, [r7, #28]
 800e7e6:	429a      	cmp	r2, r3
 800e7e8:	d143      	bne.n	800e872 <_nx_tcp_socket_state_ack_check+0x186>
                {

                    /* Handle duplicated ACK packet.  */
                    socket_ptr -> nx_tcp_socket_duplicated_ack_received++;
 800e7ea:	687b      	ldr	r3, [r7, #4]
 800e7ec:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 800e7ee:	1c5a      	adds	r2, r3, #1
 800e7f0:	687b      	ldr	r3, [r7, #4]
 800e7f2:	66da      	str	r2, [r3, #108]	; 0x6c

                    if (socket_ptr -> nx_tcp_socket_duplicated_ack_received == 3)
 800e7f4:	687b      	ldr	r3, [r7, #4]
 800e7f6:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 800e7f8:	2b03      	cmp	r3, #3
 800e7fa:	d12a      	bne.n	800e852 <_nx_tcp_socket_state_ack_check+0x166>
                    {
                        if ((INT)((tcp_header_ptr -> nx_tcp_acknowledgment_number - 1) -
 800e7fc:	683b      	ldr	r3, [r7, #0]
 800e7fe:	689a      	ldr	r2, [r3, #8]
                                  socket_ptr -> nx_tcp_socket_tx_sequence_recover) > 0)
 800e800:	687b      	ldr	r3, [r7, #4]
 800e802:	6e1b      	ldr	r3, [r3, #96]	; 0x60
                        if ((INT)((tcp_header_ptr -> nx_tcp_acknowledgment_number - 1) -
 800e804:	1ad3      	subs	r3, r2, r3
 800e806:	3b01      	subs	r3, #1
 800e808:	2b00      	cmp	r3, #0
 800e80a:	dd08      	ble.n	800e81e <_nx_tcp_socket_state_ack_check+0x132>
                        {

                            /* Cumulative acknowledge covers more than recover. */
                            /* Section 3.2, Page 5, RFC6582. */
                            /* Retransmit packet immediately. */
                            _nx_tcp_socket_retransmit(socket_ptr -> nx_tcp_socket_ip_ptr, socket_ptr, NX_TRUE);
 800e80c:	687b      	ldr	r3, [r7, #4]
 800e80e:	f8d3 30a0 	ldr.w	r3, [r3, #160]	; 0xa0
 800e812:	2201      	movs	r2, #1
 800e814:	6879      	ldr	r1, [r7, #4]
 800e816:	4618      	mov	r0, r3
 800e818:	f7ff fdc4 	bl	800e3a4 <_nx_tcp_socket_retransmit>
 800e81c:	e029      	b.n	800e872 <_nx_tcp_socket_state_ack_check+0x186>
                        }
                        else if ((socket_ptr -> nx_tcp_socket_tx_window_congestion > socket_ptr -> nx_tcp_socket_connect_mss) &&
 800e81e:	687b      	ldr	r3, [r7, #4]
 800e820:	6d9a      	ldr	r2, [r3, #88]	; 0x58
 800e822:	687b      	ldr	r3, [r7, #4]
 800e824:	6a1b      	ldr	r3, [r3, #32]
 800e826:	429a      	cmp	r2, r3
 800e828:	d923      	bls.n	800e872 <_nx_tcp_socket_state_ack_check+0x186>
                                 ((INT)(tcp_header_ptr -> nx_tcp_acknowledgment_number - (socket_ptr -> nx_tcp_socket_previous_highest_ack +
 800e82a:	683b      	ldr	r3, [r7, #0]
 800e82c:	689a      	ldr	r2, [r3, #8]
 800e82e:	687b      	ldr	r3, [r7, #4]
 800e830:	6e59      	ldr	r1, [r3, #100]	; 0x64
                                                                                          (socket_ptr -> nx_tcp_socket_connect_mss << 2))) < 0))
 800e832:	687b      	ldr	r3, [r7, #4]
 800e834:	6a1b      	ldr	r3, [r3, #32]
 800e836:	009b      	lsls	r3, r3, #2
                                 ((INT)(tcp_header_ptr -> nx_tcp_acknowledgment_number - (socket_ptr -> nx_tcp_socket_previous_highest_ack +
 800e838:	440b      	add	r3, r1
 800e83a:	1ad3      	subs	r3, r2, r3
                        else if ((socket_ptr -> nx_tcp_socket_tx_window_congestion > socket_ptr -> nx_tcp_socket_connect_mss) &&
 800e83c:	2b00      	cmp	r3, #0
 800e83e:	da18      	bge.n	800e872 <_nx_tcp_socket_state_ack_check+0x186>

                            /* Congestion window is greater than SMSS bytes and
                               the difference between highest_ack and prev_highest_ack is at most 4*SMSS bytes.*/
                            /* Section 4.1, Page 5, RFC6582. */
                            /* Retransmit packet immediately. */
                            _nx_tcp_socket_retransmit(socket_ptr -> nx_tcp_socket_ip_ptr, socket_ptr, NX_TRUE);
 800e840:	687b      	ldr	r3, [r7, #4]
 800e842:	f8d3 30a0 	ldr.w	r3, [r3, #160]	; 0xa0
 800e846:	2201      	movs	r2, #1
 800e848:	6879      	ldr	r1, [r7, #4]
 800e84a:	4618      	mov	r0, r3
 800e84c:	f7ff fdaa 	bl	800e3a4 <_nx_tcp_socket_retransmit>
 800e850:	e00f      	b.n	800e872 <_nx_tcp_socket_state_ack_check+0x186>
                        }
                    }
                    else if ((socket_ptr -> nx_tcp_socket_duplicated_ack_received > 3) &&
 800e852:	687b      	ldr	r3, [r7, #4]
 800e854:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 800e856:	2b03      	cmp	r3, #3
 800e858:	d90b      	bls.n	800e872 <_nx_tcp_socket_state_ack_check+0x186>
                             (socket_ptr -> nx_tcp_socket_fast_recovery == NX_TRUE))
 800e85a:	687b      	ldr	r3, [r7, #4]
 800e85c:	f893 309e 	ldrb.w	r3, [r3, #158]	; 0x9e
                    else if ((socket_ptr -> nx_tcp_socket_duplicated_ack_received > 3) &&
 800e860:	2b01      	cmp	r3, #1
 800e862:	d106      	bne.n	800e872 <_nx_tcp_socket_state_ack_check+0x186>
                    {

                        /* CWND += MSS  */
                        socket_ptr -> nx_tcp_socket_tx_window_congestion += socket_ptr -> nx_tcp_socket_connect_mss;
 800e864:	687b      	ldr	r3, [r7, #4]
 800e866:	6d9a      	ldr	r2, [r3, #88]	; 0x58
 800e868:	687b      	ldr	r3, [r7, #4]
 800e86a:	6a1b      	ldr	r3, [r3, #32]
 800e86c:	441a      	add	r2, r3
 800e86e:	687b      	ldr	r3, [r7, #4]
 800e870:	659a      	str	r2, [r3, #88]	; 0x58
                    }
                }

                /* Determine if the transmit queue has wrapped.  */
                if (ending_tx_sequence > starting_tx_sequence)
 800e872:	6aba      	ldr	r2, [r7, #40]	; 0x28
 800e874:	69fb      	ldr	r3, [r7, #28]
 800e876:	429a      	cmp	r2, r3
 800e878:	d902      	bls.n	800e880 <_nx_tcp_socket_state_ack_check+0x194>
                {

                    /* Clear the wrapped flag.  */
                    wrapped_flag =  NX_FALSE;
 800e87a:	2300      	movs	r3, #0
 800e87c:	623b      	str	r3, [r7, #32]
 800e87e:	e001      	b.n	800e884 <_nx_tcp_socket_state_ack_check+0x198>
                }
                else
                {

                    /* Set the wrapped flag.  */
                    wrapped_flag =  NX_TRUE;
 800e880:	2301      	movs	r3, #1
 800e882:	623b      	str	r3, [r7, #32]
                }
            }

            /* Initialize the packet release count.  */
            packet_release_count =  0;
 800e884:	2300      	movs	r3, #0
 800e886:	62fb      	str	r3, [r7, #44]	; 0x2c

            /* See if we can find the sequence number in the sent queue for this
               socket.  */
            previous_ptr =  NX_NULL;
 800e888:	2300      	movs	r3, #0
 800e88a:	637b      	str	r3, [r7, #52]	; 0x34
            while (search_ptr)
 800e88c:	e063      	b.n	800e956 <_nx_tcp_socket_state_ack_check+0x26a>
            {

                /* Determine if the packet has been transmitted.  */
                /*lint -e{923} suppress cast of ULONG to pointer.  */
                if (search_ptr -> nx_packet_queue_next != ((NX_PACKET *)NX_DRIVER_TX_DONE))
 800e88e:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800e890:	69db      	ldr	r3, [r3, #28]
 800e892:	f1b3 3fdd 	cmp.w	r3, #3722304989	; 0xdddddddd
 800e896:	d007      	beq.n	800e8a8 <_nx_tcp_socket_state_ack_check+0x1bc>
                {

                    /* Setup a pointer to header of this packet in the sent list.  */
                    search_header_ptr =  (NX_TCP_HEADER *)(search_ptr -> nx_packet_ip_header +
 800e898:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800e89a:	6b5b      	ldr	r3, [r3, #52]	; 0x34
                                                           search_ptr -> nx_packet_ip_header_length);
 800e89c:	6bba      	ldr	r2, [r7, #56]	; 0x38
 800e89e:	f892 202e 	ldrb.w	r2, [r2, #46]	; 0x2e
                    search_header_ptr =  (NX_TCP_HEADER *)(search_ptr -> nx_packet_ip_header +
 800e8a2:	4413      	add	r3, r2
 800e8a4:	63fb      	str	r3, [r7, #60]	; 0x3c
 800e8a6:	e002      	b.n	800e8ae <_nx_tcp_socket_state_ack_check+0x1c2>
                else
                {

                    /* Setup a pointer to header of this packet in the sent list.  */
                    /*lint -e{927} -e{826} suppress cast of pointer to pointer, since it is necessary  */
                    search_header_ptr =  (NX_TCP_HEADER *)search_ptr -> nx_packet_prepend_ptr;
 800e8a8:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800e8aa:	689b      	ldr	r3, [r3, #8]
 800e8ac:	63fb      	str	r3, [r7, #60]	; 0x3c
                }

                /* Determine the size of the TCP header.  */
                temp =  search_header_ptr -> nx_tcp_header_word_3;
 800e8ae:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800e8b0:	68db      	ldr	r3, [r3, #12]
 800e8b2:	633b      	str	r3, [r7, #48]	; 0x30
                NX_CHANGE_ULONG_ENDIAN(temp);
 800e8b4:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800e8b6:	ba1b      	rev	r3, r3
 800e8b8:	633b      	str	r3, [r7, #48]	; 0x30
                header_length =  (temp >> NX_TCP_HEADER_SHIFT) * (ULONG)sizeof(ULONG);
 800e8ba:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800e8bc:	0f1b      	lsrs	r3, r3, #28
 800e8be:	009b      	lsls	r3, r3, #2
 800e8c0:	61bb      	str	r3, [r7, #24]

                /* Determine the sequence number in the TCP header.  */
                search_sequence =  search_header_ptr -> nx_tcp_sequence_number;
 800e8c2:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800e8c4:	685b      	ldr	r3, [r3, #4]
 800e8c6:	617b      	str	r3, [r7, #20]
                NX_CHANGE_ULONG_ENDIAN(search_sequence);
 800e8c8:	697b      	ldr	r3, [r7, #20]
 800e8ca:	ba1b      	rev	r3, r3
 800e8cc:	617b      	str	r3, [r7, #20]

                /* Calculate the payload length of TCP. */
                tcp_payload_length = (search_ptr -> nx_packet_length -
 800e8ce:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800e8d0:	6a5a      	ldr	r2, [r3, #36]	; 0x24
                                      (header_length +
                                       (ULONG)((ALIGN_TYPE)search_header_ptr -
                                               (ALIGN_TYPE)search_ptr -> nx_packet_prepend_ptr)));
 800e8d2:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800e8d4:	689b      	ldr	r3, [r3, #8]
 800e8d6:	4619      	mov	r1, r3
                                       (ULONG)((ALIGN_TYPE)search_header_ptr -
 800e8d8:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800e8da:	1ac9      	subs	r1, r1, r3
                                      (header_length +
 800e8dc:	69bb      	ldr	r3, [r7, #24]
 800e8de:	1acb      	subs	r3, r1, r3
                tcp_payload_length = (search_ptr -> nx_packet_length -
 800e8e0:	4413      	add	r3, r2
 800e8e2:	613b      	str	r3, [r7, #16]

                /* Calculate the ending packet sequence.  */
                ending_packet_sequence =  search_sequence + tcp_payload_length;
 800e8e4:	697a      	ldr	r2, [r7, #20]
 800e8e6:	693b      	ldr	r3, [r7, #16]
 800e8e8:	4413      	add	r3, r2
 800e8ea:	60fb      	str	r3, [r7, #12]

                /* Determine if the transmit window is wrapped.  */
                if (wrapped_flag == NX_FALSE)
 800e8ec:	6a3b      	ldr	r3, [r7, #32]
 800e8ee:	2b00      	cmp	r3, #0
 800e8f0:	d10a      	bne.n	800e908 <_nx_tcp_socket_state_ack_check+0x21c>

                    /* No, the transmit window is not wrapped. Perform a simple compare to determine if the ACK
                       covers the current search packet.  */

                    /* Is this ACK before the current search packet or after the transmit sequence?  */
                    if ((tcp_header_ptr -> nx_tcp_acknowledgment_number < ending_packet_sequence) ||
 800e8f2:	683b      	ldr	r3, [r7, #0]
 800e8f4:	689b      	ldr	r3, [r3, #8]
 800e8f6:	68fa      	ldr	r2, [r7, #12]
 800e8f8:	429a      	cmp	r2, r3
 800e8fa:	d833      	bhi.n	800e964 <_nx_tcp_socket_state_ack_check+0x278>
                        (tcp_header_ptr -> nx_tcp_acknowledgment_number > ending_tx_sequence))
 800e8fc:	683b      	ldr	r3, [r7, #0]
 800e8fe:	689b      	ldr	r3, [r3, #8]
                    if ((tcp_header_ptr -> nx_tcp_acknowledgment_number < ending_packet_sequence) ||
 800e900:	6aba      	ldr	r2, [r7, #40]	; 0x28
 800e902:	429a      	cmp	r2, r3
 800e904:	d32e      	bcc.n	800e964 <_nx_tcp_socket_state_ack_check+0x278>
 800e906:	e018      	b.n	800e93a <_nx_tcp_socket_state_ack_check+0x24e>

                    /* Yes, the transmit window has wrapped.  We need to now check for all the wrap conditions to
                       determine if ACK covers the current search packet.  */

                    /* Is the search packet's ending sequence number in the wrapped part of the window.  */
                    if (ending_packet_sequence < starting_tx_sequence)
 800e908:	68fa      	ldr	r2, [r7, #12]
 800e90a:	69fb      	ldr	r3, [r7, #28]
 800e90c:	429a      	cmp	r2, r3
 800e90e:	d20a      	bcs.n	800e926 <_nx_tcp_socket_state_ack_check+0x23a>
                    {

                        /* The search packet ends in the wrapped portion of the window.  Determine if the ACK
                           sequence in the wrapped portion as well.  */
                        if (tcp_header_ptr -> nx_tcp_acknowledgment_number < starting_tx_sequence)
 800e910:	683b      	ldr	r3, [r7, #0]
 800e912:	689b      	ldr	r3, [r3, #8]
 800e914:	69fa      	ldr	r2, [r7, #28]
 800e916:	429a      	cmp	r2, r3
 800e918:	d921      	bls.n	800e95e <_nx_tcp_socket_state_ack_check+0x272>
                        {

                            /* Yes, the ACK sequence is in the wrapped portion as well. Simply compare the ACK
                               sequence with the search packet sequence.  */
                            if (tcp_header_ptr -> nx_tcp_acknowledgment_number < ending_packet_sequence)
 800e91a:	683b      	ldr	r3, [r7, #0]
 800e91c:	689b      	ldr	r3, [r3, #8]
 800e91e:	68fa      	ldr	r2, [r7, #12]
 800e920:	429a      	cmp	r2, r3
 800e922:	d90a      	bls.n	800e93a <_nx_tcp_socket_state_ack_check+0x24e>
                            {

                                /* ACK does not cover the search packet. Break out of the loop.  */
                                break;
 800e924:	e01e      	b.n	800e964 <_nx_tcp_socket_state_ack_check+0x278>
                    else
                    {

                        /* The search packet is in the non-wrapped portion of the window.  Determine if the ACK
                           sequence is in the non-wrapped portion as well.  */
                        if (tcp_header_ptr -> nx_tcp_acknowledgment_number >= starting_tx_sequence)
 800e926:	683b      	ldr	r3, [r7, #0]
 800e928:	689b      	ldr	r3, [r3, #8]
 800e92a:	69fa      	ldr	r2, [r7, #28]
 800e92c:	429a      	cmp	r2, r3
 800e92e:	d804      	bhi.n	800e93a <_nx_tcp_socket_state_ack_check+0x24e>
                        {

                            /* Yes, the ACK sequence is in the non-wrapped portion of the window. Simply compare the ACK
                               sequence with the search packet sequence.  */
                            if (tcp_header_ptr -> nx_tcp_acknowledgment_number < ending_packet_sequence)
 800e930:	683b      	ldr	r3, [r7, #0]
 800e932:	689b      	ldr	r3, [r3, #8]
 800e934:	68fa      	ldr	r2, [r7, #12]
 800e936:	429a      	cmp	r2, r3
 800e938:	d813      	bhi.n	800e962 <_nx_tcp_socket_state_ack_check+0x276>
                }

                /* At this point we know that the ACK received covers the search packet.  */

                /* Increase the packet release count.  */
                packet_release_count++;
 800e93a:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800e93c:	3301      	adds	r3, #1
 800e93e:	62fb      	str	r3, [r7, #44]	; 0x2c

                /* Move the search and previous pointers forward.  */
                previous_ptr =  search_ptr;
 800e940:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800e942:	637b      	str	r3, [r7, #52]	; 0x34
                search_ptr =  search_ptr -> nx_packet_union_next.nx_packet_tcp_queue_next;
 800e944:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800e946:	6a1b      	ldr	r3, [r3, #32]
 800e948:	63bb      	str	r3, [r7, #56]	; 0x38

                /* Determine if we are at the end of the TCP queue.  */
                /*lint -e{923} suppress cast of ULONG to pointer.  */
                if (search_ptr == ((NX_PACKET *)NX_PACKET_ENQUEUED))
 800e94a:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800e94c:	f1b3 3fee 	cmp.w	r3, #4008636142	; 0xeeeeeeee
 800e950:	d101      	bne.n	800e956 <_nx_tcp_socket_state_ack_check+0x26a>
                {

                    /* Yes, set the search pointer to NULL.  */
                    search_ptr =  NX_NULL;
 800e952:	2300      	movs	r3, #0
 800e954:	63bb      	str	r3, [r7, #56]	; 0x38
            while (search_ptr)
 800e956:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800e958:	2b00      	cmp	r3, #0
 800e95a:	d198      	bne.n	800e88e <_nx_tcp_socket_state_ack_check+0x1a2>
 800e95c:	e002      	b.n	800e964 <_nx_tcp_socket_state_ack_check+0x278>
                            break;
 800e95e:	bf00      	nop
 800e960:	e000      	b.n	800e964 <_nx_tcp_socket_state_ack_check+0x278>
                                break;
 800e962:	bf00      	nop
                }
            }
        }

        /* Determine if anything needs to be released.  */
        if (!packet_release_count)
 800e964:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800e966:	2b00      	cmp	r3, #0
 800e968:	d123      	bne.n	800e9b2 <_nx_tcp_socket_state_ack_check+0x2c6>
        {

            /* No, check and see if the ACK is valid.  */
            /* If the ACK acks something not yet sent (SEG.ACK > SND.NXT) then send an ACK, drop the segment */
            /* Page 72, section 3.9, RFC 793.*/
            if (tcp_header_ptr -> nx_tcp_acknowledgment_number != ending_tx_sequence)
 800e96a:	683b      	ldr	r3, [r7, #0]
 800e96c:	689b      	ldr	r3, [r3, #8]
 800e96e:	6aba      	ldr	r2, [r7, #40]	; 0x28
 800e970:	429a      	cmp	r2, r3
 800e972:	d00d      	beq.n	800e990 <_nx_tcp_socket_state_ack_check+0x2a4>
            {

                /* If the ACK is a duplicate, it can be ignored. */
                if ((INT)tcp_header_ptr -> nx_tcp_acknowledgment_number - (INT)ending_tx_sequence > 0)
 800e974:	683b      	ldr	r3, [r7, #0]
 800e976:	689b      	ldr	r3, [r3, #8]
 800e978:	461a      	mov	r2, r3
 800e97a:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800e97c:	1ad3      	subs	r3, r2, r3
 800e97e:	2b00      	cmp	r3, #0
 800e980:	f340 809f 	ble.w	800eac2 <_nx_tcp_socket_state_ack_check+0x3d6>
                {

                    /* The ACK sequence is invalid. Respond with an ACK to let the other
                       side of the connection figure out if everything is still okay.  */
                    _nx_tcp_packet_send_ack(socket_ptr, ending_tx_sequence);
 800e984:	6ab9      	ldr	r1, [r7, #40]	; 0x28
 800e986:	6878      	ldr	r0, [r7, #4]
 800e988:	f7fe ffd2 	bl	800d930 <_nx_tcp_packet_send_ack>
                    return(NX_FALSE);
 800e98c:	2300      	movs	r3, #0
 800e98e:	e19a      	b.n	800ecc6 <_nx_tcp_socket_state_ack_check+0x5da>
                }
            }
            else if ((socket_ptr -> nx_tcp_socket_rx_window_current == 0) &&
 800e990:	687b      	ldr	r3, [r7, #4]
 800e992:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 800e994:	2b00      	cmp	r3, #0
 800e996:	f040 8094 	bne.w	800eac2 <_nx_tcp_socket_state_ack_check+0x3d6>
                     (tcp_header_ptr -> nx_tcp_sequence_number == socket_ptr -> nx_tcp_socket_rx_sequence))
 800e99a:	683b      	ldr	r3, [r7, #0]
 800e99c:	685a      	ldr	r2, [r3, #4]
 800e99e:	687b      	ldr	r3, [r7, #4]
 800e9a0:	6c1b      	ldr	r3, [r3, #64]	; 0x40
            else if ((socket_ptr -> nx_tcp_socket_rx_window_current == 0) &&
 800e9a2:	429a      	cmp	r2, r3
 800e9a4:	f040 808d 	bne.w	800eac2 <_nx_tcp_socket_state_ack_check+0x3d6>
            {

                /* Response to zero window probe.  */
                _nx_tcp_packet_send_ack(socket_ptr, ending_tx_sequence);
 800e9a8:	6ab9      	ldr	r1, [r7, #40]	; 0x28
 800e9aa:	6878      	ldr	r0, [r7, #4]
 800e9ac:	f7fe ffc0 	bl	800d930 <_nx_tcp_packet_send_ack>
 800e9b0:	e087      	b.n	800eac2 <_nx_tcp_socket_state_ack_check+0x3d6>

            /* Congestion window adjustment during slow start and congestion avoidance is executed
               on every incoming ACK that acknowledges new data. RFC5681, Section3.1, Page4-8.  */

            /* Check whether the socket is in fast recovery procedure. */
            if (socket_ptr -> nx_tcp_socket_fast_recovery == NX_TRUE)
 800e9b2:	687b      	ldr	r3, [r7, #4]
 800e9b4:	f893 309e 	ldrb.w	r3, [r3, #158]	; 0x9e
 800e9b8:	2b01      	cmp	r3, #1
 800e9ba:	d10e      	bne.n	800e9da <_nx_tcp_socket_state_ack_check+0x2ee>
            {

                /* Yes. */
                if ((INT)(tcp_header_ptr -> nx_tcp_acknowledgment_number -
 800e9bc:	683b      	ldr	r3, [r7, #0]
 800e9be:	689a      	ldr	r2, [r3, #8]
                          socket_ptr -> nx_tcp_socket_tx_sequence_recover) > 0)
 800e9c0:	687b      	ldr	r3, [r7, #4]
 800e9c2:	6e1b      	ldr	r3, [r3, #96]	; 0x60
                if ((INT)(tcp_header_ptr -> nx_tcp_acknowledgment_number -
 800e9c4:	1ad3      	subs	r3, r2, r3
 800e9c6:	2b00      	cmp	r3, #0
 800e9c8:	dd07      	ble.n	800e9da <_nx_tcp_socket_state_ack_check+0x2ee>
                {

                    /* All packets sent before entering fast recovery are ACKed. */
                    /* Exit fast recovery procedure. */
                    socket_ptr -> nx_tcp_socket_fast_recovery = NX_FALSE;
 800e9ca:	687b      	ldr	r3, [r7, #4]
 800e9cc:	2200      	movs	r2, #0
 800e9ce:	f883 209e 	strb.w	r2, [r3, #158]	; 0x9e
                    socket_ptr -> nx_tcp_socket_tx_window_congestion = socket_ptr -> nx_tcp_socket_tx_slow_start_threshold;
 800e9d2:	687b      	ldr	r3, [r7, #4]
 800e9d4:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 800e9d6:	687b      	ldr	r3, [r7, #4]
 800e9d8:	659a      	str	r2, [r3, #88]	; 0x58
                }
            }

            if ((INT)(socket_ptr -> nx_tcp_socket_tx_sequence_recover -
 800e9da:	687b      	ldr	r3, [r7, #4]
 800e9dc:	6e1a      	ldr	r2, [r3, #96]	; 0x60
                      (tcp_header_ptr -> nx_tcp_acknowledgment_number - 2)) < 0)
 800e9de:	683b      	ldr	r3, [r7, #0]
 800e9e0:	689b      	ldr	r3, [r3, #8]
            if ((INT)(socket_ptr -> nx_tcp_socket_tx_sequence_recover -
 800e9e2:	1ad3      	subs	r3, r2, r3
 800e9e4:	3302      	adds	r3, #2
 800e9e6:	2b00      	cmp	r3, #0
 800e9e8:	da04      	bge.n	800e9f4 <_nx_tcp_socket_state_ack_check+0x308>
            {

                /* Update the transmit sequence that entered fast transmit. */
                socket_ptr -> nx_tcp_socket_tx_sequence_recover = tcp_header_ptr -> nx_tcp_acknowledgment_number - 2;
 800e9ea:	683b      	ldr	r3, [r7, #0]
 800e9ec:	689b      	ldr	r3, [r3, #8]
 800e9ee:	1e9a      	subs	r2, r3, #2
 800e9f0:	687b      	ldr	r3, [r7, #4]
 800e9f2:	661a      	str	r2, [r3, #96]	; 0x60
            }

            /* Reset the duplicated ACK counter. */
            socket_ptr -> nx_tcp_socket_duplicated_ack_received = 0;
 800e9f4:	687b      	ldr	r3, [r7, #4]
 800e9f6:	2200      	movs	r2, #0
 800e9f8:	66da      	str	r2, [r3, #108]	; 0x6c

            /* Determine if the packet has been transmitted.  */
            /*lint -e{923} suppress cast of ULONG to pointer.  */
            if (socket_ptr -> nx_tcp_socket_transmit_sent_head -> nx_packet_queue_next != ((NX_PACKET *)NX_DRIVER_TX_DONE))
 800e9fa:	687b      	ldr	r3, [r7, #4]
 800e9fc:	f8d3 30c4 	ldr.w	r3, [r3, #196]	; 0xc4
 800ea00:	69db      	ldr	r3, [r3, #28]
 800ea02:	f1b3 3fdd 	cmp.w	r3, #3722304989	; 0xdddddddd
 800ea06:	d00b      	beq.n	800ea20 <_nx_tcp_socket_state_ack_check+0x334>
            {

                /* Setup a pointer to header of this packet in the sent list.  */
                search_header_ptr =  (NX_TCP_HEADER *)(socket_ptr -> nx_tcp_socket_transmit_sent_head -> nx_packet_ip_header +
 800ea08:	687b      	ldr	r3, [r7, #4]
 800ea0a:	f8d3 30c4 	ldr.w	r3, [r3, #196]	; 0xc4
 800ea0e:	6b5b      	ldr	r3, [r3, #52]	; 0x34
                                                       socket_ptr -> nx_tcp_socket_transmit_sent_head -> nx_packet_ip_header_length);
 800ea10:	687a      	ldr	r2, [r7, #4]
 800ea12:	f8d2 20c4 	ldr.w	r2, [r2, #196]	; 0xc4
 800ea16:	f892 202e 	ldrb.w	r2, [r2, #46]	; 0x2e
                search_header_ptr =  (NX_TCP_HEADER *)(socket_ptr -> nx_tcp_socket_transmit_sent_head -> nx_packet_ip_header +
 800ea1a:	4413      	add	r3, r2
 800ea1c:	63fb      	str	r3, [r7, #60]	; 0x3c
 800ea1e:	e004      	b.n	800ea2a <_nx_tcp_socket_state_ack_check+0x33e>
            else
            {

                /* Setup a pointer to header of this packet in the sent list.  */
                /*lint -e{927} -e{826} suppress cast of pointer to pointer, since it is necessary  */
                search_header_ptr =  (NX_TCP_HEADER *)socket_ptr -> nx_tcp_socket_transmit_sent_head -> nx_packet_prepend_ptr;
 800ea20:	687b      	ldr	r3, [r7, #4]
 800ea22:	f8d3 30c4 	ldr.w	r3, [r3, #196]	; 0xc4
 800ea26:	689b      	ldr	r3, [r3, #8]
 800ea28:	63fb      	str	r3, [r7, #60]	; 0x3c
            }

            /* Set previous cumulative acknowlesgement. */
            socket_ptr -> nx_tcp_socket_previous_highest_ack = starting_tx_sequence;
 800ea2a:	687b      	ldr	r3, [r7, #4]
 800ea2c:	69fa      	ldr	r2, [r7, #28]
 800ea2e:	665a      	str	r2, [r3, #100]	; 0x64

            /* Calculate ACKed length. */
            acked_bytes = tcp_header_ptr -> nx_tcp_acknowledgment_number - starting_tx_sequence;
 800ea30:	683b      	ldr	r3, [r7, #0]
 800ea32:	689a      	ldr	r2, [r3, #8]
 800ea34:	69fb      	ldr	r3, [r7, #28]
 800ea36:	1ad3      	subs	r3, r2, r3
 800ea38:	60bb      	str	r3, [r7, #8]

            if (socket_ptr -> nx_tcp_socket_fast_recovery == NX_TRUE)
 800ea3a:	687b      	ldr	r3, [r7, #4]
 800ea3c:	f893 309e 	ldrb.w	r3, [r3, #158]	; 0x9e
 800ea40:	2b01      	cmp	r3, #1
 800ea42:	d112      	bne.n	800ea6a <_nx_tcp_socket_state_ack_check+0x37e>
            {

                /* Process cwnd in fast recovery procedure. */
                socket_ptr -> nx_tcp_socket_tx_window_congestion -= acked_bytes;
 800ea44:	687b      	ldr	r3, [r7, #4]
 800ea46:	6d9a      	ldr	r2, [r3, #88]	; 0x58
 800ea48:	68bb      	ldr	r3, [r7, #8]
 800ea4a:	1ad2      	subs	r2, r2, r3
 800ea4c:	687b      	ldr	r3, [r7, #4]
 800ea4e:	659a      	str	r2, [r3, #88]	; 0x58
                if (acked_bytes > socket_ptr -> nx_tcp_socket_connect_mss)
 800ea50:	687b      	ldr	r3, [r7, #4]
 800ea52:	6a1b      	ldr	r3, [r3, #32]
 800ea54:	68ba      	ldr	r2, [r7, #8]
 800ea56:	429a      	cmp	r2, r3
 800ea58:	d933      	bls.n	800eac2 <_nx_tcp_socket_state_ack_check+0x3d6>
                {
                    socket_ptr -> nx_tcp_socket_tx_window_congestion += socket_ptr -> nx_tcp_socket_connect_mss;
 800ea5a:	687b      	ldr	r3, [r7, #4]
 800ea5c:	6d9a      	ldr	r2, [r3, #88]	; 0x58
 800ea5e:	687b      	ldr	r3, [r7, #4]
 800ea60:	6a1b      	ldr	r3, [r3, #32]
 800ea62:	441a      	add	r2, r3
 800ea64:	687b      	ldr	r3, [r7, #4]
 800ea66:	659a      	str	r2, [r3, #88]	; 0x58
 800ea68:	e02b      	b.n	800eac2 <_nx_tcp_socket_state_ack_check+0x3d6>
            else
            {

                /* Adjust the transmit window.  In slow start phase, the transmit window is incremented for every ACK.
                   In Congestion Avoidance phase, the window is incremented for every RTT. Section 3.1, Page 4-7, RFC5681.  */
                if (socket_ptr -> nx_tcp_socket_tx_window_congestion >= socket_ptr -> nx_tcp_socket_tx_slow_start_threshold)
 800ea6a:	687b      	ldr	r3, [r7, #4]
 800ea6c:	6d9a      	ldr	r2, [r3, #88]	; 0x58
 800ea6e:	687b      	ldr	r3, [r7, #4]
 800ea70:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 800ea72:	429a      	cmp	r2, r3
 800ea74:	d312      	bcc.n	800ea9c <_nx_tcp_socket_state_ack_check+0x3b0>
                {

                    /* In Congestion avoidance phase, for every ACK it receives, increase the window size using the
                       following approximation:
                       cwnd = cwnd + MSS * MSS / cwnd;  */
                    temp = socket_ptr -> nx_tcp_socket_connect_mss2 / socket_ptr -> nx_tcp_socket_tx_window_congestion;
 800ea76:	687b      	ldr	r3, [r7, #4]
 800ea78:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 800ea7a:	687b      	ldr	r3, [r7, #4]
 800ea7c:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 800ea7e:	fbb2 f3f3 	udiv	r3, r2, r3
 800ea82:	633b      	str	r3, [r7, #48]	; 0x30

                    /* If the above formula yields 0, the result SHOULD be rounded up to 1 byte.  */
                    if (temp == 0)
 800ea84:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800ea86:	2b00      	cmp	r3, #0
 800ea88:	d101      	bne.n	800ea8e <_nx_tcp_socket_state_ack_check+0x3a2>
                    {
                        temp = 1;
 800ea8a:	2301      	movs	r3, #1
 800ea8c:	633b      	str	r3, [r7, #48]	; 0x30
                    }
                    socket_ptr -> nx_tcp_socket_tx_window_congestion = socket_ptr -> nx_tcp_socket_tx_window_congestion + temp;
 800ea8e:	687b      	ldr	r3, [r7, #4]
 800ea90:	6d9a      	ldr	r2, [r3, #88]	; 0x58
 800ea92:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800ea94:	441a      	add	r2, r3
 800ea96:	687b      	ldr	r3, [r7, #4]
 800ea98:	659a      	str	r2, [r3, #88]	; 0x58
 800ea9a:	e012      	b.n	800eac2 <_nx_tcp_socket_state_ack_check+0x3d6>
                {

                    /* In Slow start phase:
                       cwnd += min (N, SMSS),
                       where N is the number of ACKed bytes. */
                    if (acked_bytes < socket_ptr -> nx_tcp_socket_connect_mss)
 800ea9c:	687b      	ldr	r3, [r7, #4]
 800ea9e:	6a1b      	ldr	r3, [r3, #32]
 800eaa0:	68ba      	ldr	r2, [r7, #8]
 800eaa2:	429a      	cmp	r2, r3
 800eaa4:	d206      	bcs.n	800eab4 <_nx_tcp_socket_state_ack_check+0x3c8>
                    {

                        /* In Slow start phase. Increase the cwnd by acked bytes.*/
                        socket_ptr -> nx_tcp_socket_tx_window_congestion += acked_bytes;
 800eaa6:	687b      	ldr	r3, [r7, #4]
 800eaa8:	6d9a      	ldr	r2, [r3, #88]	; 0x58
 800eaaa:	68bb      	ldr	r3, [r7, #8]
 800eaac:	441a      	add	r2, r3
 800eaae:	687b      	ldr	r3, [r7, #4]
 800eab0:	659a      	str	r2, [r3, #88]	; 0x58
 800eab2:	e006      	b.n	800eac2 <_nx_tcp_socket_state_ack_check+0x3d6>
                    }
                    else
                    {

                        /* In Slow start phase. Increase the cwnd by full MSS for every ack.*/
                        socket_ptr -> nx_tcp_socket_tx_window_congestion += socket_ptr -> nx_tcp_socket_connect_mss;
 800eab4:	687b      	ldr	r3, [r7, #4]
 800eab6:	6d9a      	ldr	r2, [r3, #88]	; 0x58
 800eab8:	687b      	ldr	r3, [r7, #4]
 800eaba:	6a1b      	ldr	r3, [r3, #32]
 800eabc:	441a      	add	r2, r3
 800eabe:	687b      	ldr	r3, [r7, #4]
 800eac0:	659a      	str	r2, [r3, #88]	; 0x58
        /* Update the window only when
         * 1. SND.UNA < SEG.ACK =< SND.NXT or
         * 2. SND.WL1 < SEG.SEQ or
         * 3. SND.WL1 = SEG.SEQ and SND.WL2 =< SEG.ACK
         * RFC793, Section 3.9, Page72. */
        if ((((INT)tcp_header_ptr -> nx_tcp_acknowledgment_number - (INT)starting_tx_sequence > 0) &&
 800eac2:	683b      	ldr	r3, [r7, #0]
 800eac4:	689b      	ldr	r3, [r3, #8]
 800eac6:	461a      	mov	r2, r3
 800eac8:	69fb      	ldr	r3, [r7, #28]
 800eaca:	1ad3      	subs	r3, r2, r3
 800eacc:	2b00      	cmp	r3, #0
 800eace:	dd06      	ble.n	800eade <_nx_tcp_socket_state_ack_check+0x3f2>
             ((INT)tcp_header_ptr -> nx_tcp_acknowledgment_number - (INT)ending_tx_sequence <= 0)) ||
 800ead0:	683b      	ldr	r3, [r7, #0]
 800ead2:	689b      	ldr	r3, [r3, #8]
 800ead4:	461a      	mov	r2, r3
 800ead6:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800ead8:	1ad3      	subs	r3, r2, r3
        if ((((INT)tcp_header_ptr -> nx_tcp_acknowledgment_number - (INT)starting_tx_sequence > 0) &&
 800eada:	2b00      	cmp	r3, #0
 800eadc:	dd12      	ble.n	800eb04 <_nx_tcp_socket_state_ack_check+0x418>
            ((INT)tcp_header_ptr -> nx_tcp_sequence_number - (INT)ending_rx_sequence > 0) ||
 800eade:	683b      	ldr	r3, [r7, #0]
 800eae0:	685b      	ldr	r3, [r3, #4]
 800eae2:	461a      	mov	r2, r3
 800eae4:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800eae6:	1ad3      	subs	r3, r2, r3
             ((INT)tcp_header_ptr -> nx_tcp_acknowledgment_number - (INT)ending_tx_sequence <= 0)) ||
 800eae8:	2b00      	cmp	r3, #0
 800eaea:	dc0b      	bgt.n	800eb04 <_nx_tcp_socket_state_ack_check+0x418>
            (((INT)tcp_header_ptr -> nx_tcp_sequence_number == (INT)ending_rx_sequence) &&
 800eaec:	683b      	ldr	r3, [r7, #0]
 800eaee:	685b      	ldr	r3, [r3, #4]
            ((INT)tcp_header_ptr -> nx_tcp_sequence_number - (INT)ending_rx_sequence > 0) ||
 800eaf0:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 800eaf2:	429a      	cmp	r2, r3
 800eaf4:	d10b      	bne.n	800eb0e <_nx_tcp_socket_state_ack_check+0x422>
             ((INT)tcp_header_ptr -> nx_tcp_acknowledgment_number - (INT)starting_tx_sequence >= 0)))
 800eaf6:	683b      	ldr	r3, [r7, #0]
 800eaf8:	689b      	ldr	r3, [r3, #8]
 800eafa:	461a      	mov	r2, r3
 800eafc:	69fb      	ldr	r3, [r7, #28]
 800eafe:	1ad3      	subs	r3, r2, r3
            (((INT)tcp_header_ptr -> nx_tcp_sequence_number == (INT)ending_rx_sequence) &&
 800eb00:	2b00      	cmp	r3, #0
 800eb02:	db04      	blt.n	800eb0e <_nx_tcp_socket_state_ack_check+0x422>
        {

            /* Update this socket's transmit window with the advertised window size in the ACK message.  */
            socket_ptr -> nx_tcp_socket_tx_window_advertised =  (tcp_header_ptr -> nx_tcp_header_word_3) & NX_LOWER_16_MASK;
 800eb04:	683b      	ldr	r3, [r7, #0]
 800eb06:	68db      	ldr	r3, [r3, #12]
 800eb08:	b29a      	uxth	r2, r3
 800eb0a:	687b      	ldr	r3, [r7, #4]
 800eb0c:	655a      	str	r2, [r3, #84]	; 0x54
            socket_ptr -> nx_tcp_socket_tx_window_advertised <<= socket_ptr -> nx_tcp_snd_win_scale_value;
#endif /* NX_ENABLE_TCP_WINDOW_SCALING */
        }

        /* Check advertised window. */
        if ((socket_ptr -> nx_tcp_socket_tx_window_advertised <= socket_ptr -> nx_tcp_socket_tx_outstanding_bytes) &&
 800eb0e:	687b      	ldr	r3, [r7, #4]
 800eb10:	6d5a      	ldr	r2, [r3, #84]	; 0x54
 800eb12:	687b      	ldr	r3, [r7, #4]
 800eb14:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
 800eb16:	429a      	cmp	r2, r3
 800eb18:	d80a      	bhi.n	800eb30 <_nx_tcp_socket_state_ack_check+0x444>
            (tcp_header_ptr -> nx_tcp_acknowledgment_number >= socket_ptr -> nx_tcp_socket_zero_window_probe_sequence))
 800eb1a:	683b      	ldr	r3, [r7, #0]
 800eb1c:	689a      	ldr	r2, [r3, #8]
 800eb1e:	687b      	ldr	r3, [r7, #4]
 800eb20:	f8d3 3098 	ldr.w	r3, [r3, #152]	; 0x98
        if ((socket_ptr -> nx_tcp_socket_tx_window_advertised <= socket_ptr -> nx_tcp_socket_tx_outstanding_bytes) &&
 800eb24:	429a      	cmp	r2, r3
 800eb26:	d303      	bcc.n	800eb30 <_nx_tcp_socket_state_ack_check+0x444>
        {

            /* It is an ACK to Zero Window Probe. Reset the zero window probe failure. */
            socket_ptr -> nx_tcp_socket_zero_window_probe_failure = 0;
 800eb28:	687b      	ldr	r3, [r7, #4]
 800eb2a:	2200      	movs	r2, #0
 800eb2c:	f8c3 2094 	str.w	r2, [r3, #148]	; 0x94
        }

        if (!packet_release_count)
 800eb30:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800eb32:	2b00      	cmp	r3, #0
 800eb34:	d101      	bne.n	800eb3a <_nx_tcp_socket_state_ack_check+0x44e>
        {
            /* Done, return to caller. */
            return(NX_TRUE);
 800eb36:	2301      	movs	r3, #1
 800eb38:	e0c5      	b.n	800ecc6 <_nx_tcp_socket_state_ack_check+0x5da>
            }
        }
#endif

        /* Save the front of the of the transmit queue.  */
        search_ptr =  socket_ptr -> nx_tcp_socket_transmit_sent_head;
 800eb3a:	687b      	ldr	r3, [r7, #4]
 800eb3c:	f8d3 30c4 	ldr.w	r3, [r3, #196]	; 0xc4
 800eb40:	63bb      	str	r3, [r7, #56]	; 0x38

        /* Okay so now the packet after the previous pointer needs to be the front of the
           queue.  */
        if (previous_ptr != socket_ptr -> nx_tcp_socket_transmit_sent_tail)
 800eb42:	687b      	ldr	r3, [r7, #4]
 800eb44:	f8d3 30c8 	ldr.w	r3, [r3, #200]	; 0xc8
 800eb48:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 800eb4a:	429a      	cmp	r2, r3
 800eb4c:	d017      	beq.n	800eb7e <_nx_tcp_socket_state_ack_check+0x492>
        {

            /* Just update the head pointer.  */
            socket_ptr -> nx_tcp_socket_transmit_sent_head  =  previous_ptr -> nx_packet_union_next.nx_packet_tcp_queue_next;
 800eb4e:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800eb50:	6a1a      	ldr	r2, [r3, #32]
 800eb52:	687b      	ldr	r3, [r7, #4]
 800eb54:	f8c3 20c4 	str.w	r2, [r3, #196]	; 0xc4

            /* And decrease the transmit queue count accordingly.  */
            socket_ptr -> nx_tcp_socket_transmit_sent_count =   socket_ptr -> nx_tcp_socket_transmit_sent_count - packet_release_count;
 800eb58:	687b      	ldr	r3, [r7, #4]
 800eb5a:	f8d3 20c0 	ldr.w	r2, [r3, #192]	; 0xc0
 800eb5e:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800eb60:	1ad2      	subs	r2, r2, r3
 800eb62:	687b      	ldr	r3, [r7, #4]
 800eb64:	f8c3 20c0 	str.w	r2, [r3, #192]	; 0xc0

            /* Setup a new transmit timeout.  */
            socket_ptr -> nx_tcp_socket_timeout =          socket_ptr -> nx_tcp_socket_timeout_rate;
 800eb68:	687b      	ldr	r3, [r7, #4]
 800eb6a:	f8d3 20d0 	ldr.w	r2, [r3, #208]	; 0xd0
 800eb6e:	687b      	ldr	r3, [r7, #4]
 800eb70:	f8c3 20cc 	str.w	r2, [r3, #204]	; 0xcc
            socket_ptr -> nx_tcp_socket_timeout_retries =  0;
 800eb74:	687b      	ldr	r3, [r7, #4]
 800eb76:	2200      	movs	r2, #0
 800eb78:	f8c3 20d4 	str.w	r2, [r3, #212]	; 0xd4
 800eb7c:	e08e      	b.n	800ec9c <_nx_tcp_socket_state_ack_check+0x5b0>
        else
        {

            /* The transmit list is now cleared, just set the head and tail pointers to
               NULL.  */
            socket_ptr -> nx_tcp_socket_transmit_sent_head  =  NX_NULL;
 800eb7e:	687b      	ldr	r3, [r7, #4]
 800eb80:	2200      	movs	r2, #0
 800eb82:	f8c3 20c4 	str.w	r2, [r3, #196]	; 0xc4
            socket_ptr -> nx_tcp_socket_transmit_sent_tail  =  NX_NULL;
 800eb86:	687b      	ldr	r3, [r7, #4]
 800eb88:	2200      	movs	r2, #0
 800eb8a:	f8c3 20c8 	str.w	r2, [r3, #200]	; 0xc8

            /* Clear the transmit queue count.  */
            socket_ptr -> nx_tcp_socket_transmit_sent_count =  0;
 800eb8e:	687b      	ldr	r3, [r7, #4]
 800eb90:	2200      	movs	r2, #0
 800eb92:	f8c3 20c0 	str.w	r2, [r3, #192]	; 0xc0

            /* Determine if a disconnect FIN has been sent from this side of the connection.  */
            if ((socket_ptr -> nx_tcp_socket_state == NX_TCP_FIN_WAIT_1) ||
 800eb96:	687b      	ldr	r3, [r7, #4]
 800eb98:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 800eb9a:	2b07      	cmp	r3, #7
 800eb9c:	d007      	beq.n	800ebae <_nx_tcp_socket_state_ack_check+0x4c2>
                (socket_ptr -> nx_tcp_socket_state == NX_TCP_CLOSING)    ||
 800eb9e:	687b      	ldr	r3, [r7, #4]
 800eba0:	6b9b      	ldr	r3, [r3, #56]	; 0x38
            if ((socket_ptr -> nx_tcp_socket_state == NX_TCP_FIN_WAIT_1) ||
 800eba2:	2b09      	cmp	r3, #9
 800eba4:	d003      	beq.n	800ebae <_nx_tcp_socket_state_ack_check+0x4c2>
                (socket_ptr -> nx_tcp_socket_state == NX_TCP_LAST_ACK))
 800eba6:	687b      	ldr	r3, [r7, #4]
 800eba8:	6b9b      	ldr	r3, [r3, #56]	; 0x38
                (socket_ptr -> nx_tcp_socket_state == NX_TCP_CLOSING)    ||
 800ebaa:	2b0b      	cmp	r3, #11
 800ebac:	d10a      	bne.n	800ebc4 <_nx_tcp_socket_state_ack_check+0x4d8>
            {

                /* Yes, setup timeout such that the FIN can be retried if it is lost.  */
                socket_ptr -> nx_tcp_socket_timeout =          socket_ptr -> nx_tcp_socket_timeout_rate;
 800ebae:	687b      	ldr	r3, [r7, #4]
 800ebb0:	f8d3 20d0 	ldr.w	r2, [r3, #208]	; 0xd0
 800ebb4:	687b      	ldr	r3, [r7, #4]
 800ebb6:	f8c3 20cc 	str.w	r2, [r3, #204]	; 0xcc
                socket_ptr -> nx_tcp_socket_timeout_retries =  0;
 800ebba:	687b      	ldr	r3, [r7, #4]
 800ebbc:	2200      	movs	r2, #0
 800ebbe:	f8c3 20d4 	str.w	r2, [r3, #212]	; 0xd4
 800ebc2:	e007      	b.n	800ebd4 <_nx_tcp_socket_state_ack_check+0x4e8>
            }
            else if (socket_ptr -> nx_tcp_socket_tx_window_advertised != 0)
 800ebc4:	687b      	ldr	r3, [r7, #4]
 800ebc6:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 800ebc8:	2b00      	cmp	r3, #0
 800ebca:	d067      	beq.n	800ec9c <_nx_tcp_socket_state_ack_check+0x5b0>
            {

                /* Otherwise, a FIN has not been sent, simply clear the transmit timeout.  */
                socket_ptr -> nx_tcp_socket_timeout =  0;
 800ebcc:	687b      	ldr	r3, [r7, #4]
 800ebce:	2200      	movs	r2, #0
 800ebd0:	f8c3 20cc 	str.w	r2, [r3, #204]	; 0xcc
            }
        }

        /* Now walk through the packets to release and set them
           free.  */
        while (packet_release_count--)
 800ebd4:	e062      	b.n	800ec9c <_nx_tcp_socket_state_ack_check+0x5b0>
        {

            /* Use the previous pointer as the release pointer.  */
            previous_ptr =  search_ptr;
 800ebd6:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800ebd8:	637b      	str	r3, [r7, #52]	; 0x34

            /* Move to the next packet in the queue before we clip the
               next pointer.  */
            search_ptr =  search_ptr -> nx_packet_union_next.nx_packet_tcp_queue_next;
 800ebda:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800ebdc:	6a1b      	ldr	r3, [r3, #32]
 800ebde:	63bb      	str	r3, [r7, #56]	; 0x38

            /* Set the packet to allocated to indicate it is no longer part of the TCP queue.  */
            /*lint -e{923} suppress cast of ULONG to pointer.  */
            previous_ptr -> nx_packet_union_next.nx_packet_tcp_queue_next =  ((NX_PACKET *)NX_PACKET_ALLOCATED);
 800ebe0:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800ebe2:	f04f 32aa 	mov.w	r2, #2863311530	; 0xaaaaaaaa
 800ebe6:	621a      	str	r2, [r3, #32]
               the packet occurred prior to receiving the ACK. If so, the packet could be
               in an ARP queue or in a driver queue waiting for transmission so we can't
               release it directly at this point.  The driver or the ARP processing will
               release it when finished.  */
            /*lint -e{923} suppress cast of ULONG to pointer.  */
            if (previous_ptr -> nx_packet_queue_next ==  ((NX_PACKET *)NX_DRIVER_TX_DONE))
 800ebe8:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800ebea:	69db      	ldr	r3, [r3, #28]
 800ebec:	f1b3 3fdd 	cmp.w	r3, #3722304989	; 0xdddddddd
 800ebf0:	d125      	bne.n	800ec3e <_nx_tcp_socket_state_ack_check+0x552>

                /* Yes, the driver has already released the packet.  */

                /* Open up the transmit window. */
                /*lint -e{927} -e{826} suppress cast of pointer to pointer, since it is necessary  */
                search_header_ptr = (NX_TCP_HEADER *)previous_ptr -> nx_packet_prepend_ptr;
 800ebf2:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800ebf4:	689b      	ldr	r3, [r3, #8]
 800ebf6:	63fb      	str	r3, [r7, #60]	; 0x3c

                temp = search_header_ptr -> nx_tcp_header_word_3;
 800ebf8:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800ebfa:	68db      	ldr	r3, [r3, #12]
 800ebfc:	633b      	str	r3, [r7, #48]	; 0x30
                NX_CHANGE_ULONG_ENDIAN(temp);
 800ebfe:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800ec00:	ba1b      	rev	r3, r3
 800ec02:	633b      	str	r3, [r7, #48]	; 0x30
                header_length = (temp >> NX_TCP_HEADER_SHIFT) * (ULONG)sizeof(ULONG);
 800ec04:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800ec06:	0f1b      	lsrs	r3, r3, #28
 800ec08:	009b      	lsls	r3, r3, #2
 800ec0a:	61bb      	str	r3, [r7, #24]
                if (socket_ptr -> nx_tcp_socket_tx_outstanding_bytes > (previous_ptr -> nx_packet_length - header_length))
 800ec0c:	687b      	ldr	r3, [r7, #4]
 800ec0e:	6dda      	ldr	r2, [r3, #92]	; 0x5c
 800ec10:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800ec12:	6a59      	ldr	r1, [r3, #36]	; 0x24
 800ec14:	69bb      	ldr	r3, [r7, #24]
 800ec16:	1acb      	subs	r3, r1, r3
 800ec18:	429a      	cmp	r2, r3
 800ec1a:	d909      	bls.n	800ec30 <_nx_tcp_socket_state_ack_check+0x544>
                {
                    socket_ptr -> nx_tcp_socket_tx_outstanding_bytes -= previous_ptr -> nx_packet_length - header_length;
 800ec1c:	687b      	ldr	r3, [r7, #4]
 800ec1e:	6dda      	ldr	r2, [r3, #92]	; 0x5c
 800ec20:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800ec22:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800ec24:	69b9      	ldr	r1, [r7, #24]
 800ec26:	1acb      	subs	r3, r1, r3
 800ec28:	441a      	add	r2, r3
 800ec2a:	687b      	ldr	r3, [r7, #4]
 800ec2c:	65da      	str	r2, [r3, #92]	; 0x5c
 800ec2e:	e002      	b.n	800ec36 <_nx_tcp_socket_state_ack_check+0x54a>
                }
                else
                {
                    socket_ptr -> nx_tcp_socket_tx_outstanding_bytes = 0;
 800ec30:	687b      	ldr	r3, [r7, #4]
 800ec32:	2200      	movs	r2, #0
 800ec34:	65da      	str	r2, [r3, #92]	; 0x5c
                }
                /* Release the packet.  */
                _nx_packet_release(previous_ptr);
 800ec36:	6b78      	ldr	r0, [r7, #52]	; 0x34
 800ec38:	f7fd fbe6 	bl	800c408 <_nx_packet_release>
 800ec3c:	e02e      	b.n	800ec9c <_nx_tcp_socket_state_ack_check+0x5b0>
            else
            {

                /* No, the driver has not released the packet.  */
                /* Open up the transmit window. */
                search_header_ptr =  (NX_TCP_HEADER *)(previous_ptr -> nx_packet_ip_header +
 800ec3e:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800ec40:	6b5b      	ldr	r3, [r3, #52]	; 0x34
                                                       previous_ptr -> nx_packet_ip_header_length);
 800ec42:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 800ec44:	f892 202e 	ldrb.w	r2, [r2, #46]	; 0x2e
                search_header_ptr =  (NX_TCP_HEADER *)(previous_ptr -> nx_packet_ip_header +
 800ec48:	4413      	add	r3, r2
 800ec4a:	63fb      	str	r3, [r7, #60]	; 0x3c

                temp = search_header_ptr -> nx_tcp_header_word_3;
 800ec4c:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800ec4e:	68db      	ldr	r3, [r3, #12]
 800ec50:	633b      	str	r3, [r7, #48]	; 0x30
                NX_CHANGE_ULONG_ENDIAN(temp);
 800ec52:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800ec54:	ba1b      	rev	r3, r3
 800ec56:	633b      	str	r3, [r7, #48]	; 0x30
                header_length = (temp >> NX_TCP_HEADER_SHIFT) * (ULONG)sizeof(ULONG);
 800ec58:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800ec5a:	0f1b      	lsrs	r3, r3, #28
 800ec5c:	009b      	lsls	r3, r3, #2
 800ec5e:	61bb      	str	r3, [r7, #24]
                tcp_payload_length = (previous_ptr -> nx_packet_length -
 800ec60:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800ec62:	6a5a      	ldr	r2, [r3, #36]	; 0x24
                                      (header_length +
                                       (ULONG)((ALIGN_TYPE)search_header_ptr -
                                               (ALIGN_TYPE)(previous_ptr -> nx_packet_prepend_ptr))));
 800ec64:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800ec66:	689b      	ldr	r3, [r3, #8]
 800ec68:	4619      	mov	r1, r3
                                       (ULONG)((ALIGN_TYPE)search_header_ptr -
 800ec6a:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800ec6c:	1ac9      	subs	r1, r1, r3
                                      (header_length +
 800ec6e:	69bb      	ldr	r3, [r7, #24]
 800ec70:	1acb      	subs	r3, r1, r3
                tcp_payload_length = (previous_ptr -> nx_packet_length -
 800ec72:	4413      	add	r3, r2
 800ec74:	613b      	str	r3, [r7, #16]
                if (socket_ptr -> nx_tcp_socket_tx_outstanding_bytes > tcp_payload_length)
 800ec76:	687b      	ldr	r3, [r7, #4]
 800ec78:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
 800ec7a:	693a      	ldr	r2, [r7, #16]
 800ec7c:	429a      	cmp	r2, r3
 800ec7e:	d206      	bcs.n	800ec8e <_nx_tcp_socket_state_ack_check+0x5a2>
                {
                    socket_ptr -> nx_tcp_socket_tx_outstanding_bytes -= tcp_payload_length;
 800ec80:	687b      	ldr	r3, [r7, #4]
 800ec82:	6dda      	ldr	r2, [r3, #92]	; 0x5c
 800ec84:	693b      	ldr	r3, [r7, #16]
 800ec86:	1ad2      	subs	r2, r2, r3
 800ec88:	687b      	ldr	r3, [r7, #4]
 800ec8a:	65da      	str	r2, [r3, #92]	; 0x5c
 800ec8c:	e002      	b.n	800ec94 <_nx_tcp_socket_state_ack_check+0x5a8>
                }
                else
                {
                    socket_ptr -> nx_tcp_socket_tx_outstanding_bytes = 0;
 800ec8e:	687b      	ldr	r3, [r7, #4]
 800ec90:	2200      	movs	r2, #0
 800ec92:	65da      	str	r2, [r3, #92]	; 0x5c
                }

                /* Let driver release the packet.  */
                previous_ptr -> nx_packet_union_next.nx_packet_tcp_queue_next = ((NX_PACKET *)NX_PACKET_ALLOCATED);
 800ec94:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800ec96:	f04f 32aa 	mov.w	r2, #2863311530	; 0xaaaaaaaa
 800ec9a:	621a      	str	r2, [r3, #32]
        while (packet_release_count--)
 800ec9c:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800ec9e:	1e5a      	subs	r2, r3, #1
 800eca0:	62fa      	str	r2, [r7, #44]	; 0x2c
 800eca2:	2b00      	cmp	r3, #0
 800eca4:	d197      	bne.n	800ebd6 <_nx_tcp_socket_state_ack_check+0x4ea>
            }
        }

        if (socket_ptr -> nx_tcp_socket_fast_recovery == NX_TRUE)
 800eca6:	687b      	ldr	r3, [r7, #4]
 800eca8:	f893 309e 	ldrb.w	r3, [r3, #158]	; 0x9e
 800ecac:	2b01      	cmp	r3, #1
 800ecae:	d107      	bne.n	800ecc0 <_nx_tcp_socket_state_ack_check+0x5d4>
        {

            /* Only partial data are ACKed. Retransmit packet immediately. */
            _nx_tcp_socket_retransmit(socket_ptr -> nx_tcp_socket_ip_ptr, socket_ptr, NX_FALSE);
 800ecb0:	687b      	ldr	r3, [r7, #4]
 800ecb2:	f8d3 30a0 	ldr.w	r3, [r3, #160]	; 0xa0
 800ecb6:	2200      	movs	r2, #0
 800ecb8:	6879      	ldr	r1, [r7, #4]
 800ecba:	4618      	mov	r0, r3
 800ecbc:	f7ff fb72 	bl	800e3a4 <_nx_tcp_socket_retransmit>
        }

        return(NX_TRUE);
 800ecc0:	2301      	movs	r3, #1
 800ecc2:	e000      	b.n	800ecc6 <_nx_tcp_socket_state_ack_check+0x5da>
    else
    {

        /* The ACK bit is off drop the segment and return.  */
        /* RFC793, Section3.9, Page72.  */
        return(NX_FALSE);
 800ecc4:	2300      	movs	r3, #0
    }
}
 800ecc6:	4618      	mov	r0, r3
 800ecc8:	3740      	adds	r7, #64	; 0x40
 800ecca:	46bd      	mov	sp, r7
 800eccc:	bd80      	pop	{r7, pc}
	...

0800ecd0 <_nx_tcp_socket_state_closing>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
VOID  _nx_tcp_socket_state_closing(NX_TCP_SOCKET *socket_ptr, NX_TCP_HEADER *tcp_header_ptr)
{
 800ecd0:	b580      	push	{r7, lr}
 800ecd2:	b082      	sub	sp, #8
 800ecd4:	af00      	add	r7, sp, #0
 800ecd6:	6078      	str	r0, [r7, #4]
 800ecd8:	6039      	str	r1, [r7, #0]


    /* Determine if the incoming message is an ACK message.  */
    if (tcp_header_ptr -> nx_tcp_header_word_3 & NX_TCP_ACK_BIT)
 800ecda:	683b      	ldr	r3, [r7, #0]
 800ecdc:	68db      	ldr	r3, [r3, #12]
 800ecde:	f403 1380 	and.w	r3, r3, #1048576	; 0x100000
 800ece2:	2b00      	cmp	r3, #0
 800ece4:	d029      	beq.n	800ed3a <_nx_tcp_socket_state_closing+0x6a>
    {

        /* If it is proper, finish the disconnect. */
        if ((tcp_header_ptr -> nx_tcp_acknowledgment_number == socket_ptr -> nx_tcp_socket_tx_sequence) &&
 800ece6:	683b      	ldr	r3, [r7, #0]
 800ece8:	689a      	ldr	r2, [r3, #8]
 800ecea:	687b      	ldr	r3, [r7, #4]
 800ecec:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 800ecee:	429a      	cmp	r2, r3
 800ecf0:	d123      	bne.n	800ed3a <_nx_tcp_socket_state_closing+0x6a>
            (tcp_header_ptr -> nx_tcp_sequence_number == socket_ptr -> nx_tcp_socket_rx_sequence))
 800ecf2:	683b      	ldr	r3, [r7, #0]
 800ecf4:	685a      	ldr	r2, [r3, #4]
 800ecf6:	687b      	ldr	r3, [r7, #4]
 800ecf8:	6c1b      	ldr	r3, [r3, #64]	; 0x40
        if ((tcp_header_ptr -> nx_tcp_acknowledgment_number == socket_ptr -> nx_tcp_socket_tx_sequence) &&
 800ecfa:	429a      	cmp	r2, r3
 800ecfc:	d11d      	bne.n	800ed3a <_nx_tcp_socket_state_closing+0x6a>

            /* If trace is enabled, insert this event into the trace buffer.  */
            NX_TRACE_IN_LINE_INSERT(NX_TRACE_INTERNAL_TCP_STATE_CHANGE, socket_ptr -> nx_tcp_socket_ip_ptr, socket_ptr, socket_ptr -> nx_tcp_socket_state, NX_TCP_TIMED_WAIT, NX_TRACE_INTERNAL_EVENTS, 0, 0);

            /* Set the socket state to TIMED WAIT now.  */
            socket_ptr -> nx_tcp_socket_state = NX_TCP_TIMED_WAIT;
 800ecfe:	687b      	ldr	r3, [r7, #4]
 800ed00:	220a      	movs	r2, #10
 800ed02:	639a      	str	r2, [r3, #56]	; 0x38

            /* Set the timeout as 2MSL (Maximum Segment Lifetime). */
            socket_ptr -> nx_tcp_socket_timeout = _nx_tcp_2MSL_timer_rate;
 800ed04:	4b0f      	ldr	r3, [pc, #60]	; (800ed44 <_nx_tcp_socket_state_closing+0x74>)
 800ed06:	681a      	ldr	r2, [r3, #0]
 800ed08:	687b      	ldr	r3, [r7, #4]
 800ed0a:	f8c3 20cc 	str.w	r2, [r3, #204]	; 0xcc

            /* Determine if we need to wake a thread suspended on the connection.  */
            if (socket_ptr -> nx_tcp_socket_disconnect_suspended_thread)
 800ed0e:	687b      	ldr	r3, [r7, #4]
 800ed10:	f8d3 3100 	ldr.w	r3, [r3, #256]	; 0x100
 800ed14:	2b00      	cmp	r3, #0
 800ed16:	d006      	beq.n	800ed26 <_nx_tcp_socket_state_closing+0x56>
            {

                /* Resume the thread suspended for the disconnect.  */
                _nx_tcp_socket_thread_resume(&(socket_ptr -> nx_tcp_socket_disconnect_suspended_thread), NX_SUCCESS);
 800ed18:	687b      	ldr	r3, [r7, #4]
 800ed1a:	f503 7380 	add.w	r3, r3, #256	; 0x100
 800ed1e:	2100      	movs	r1, #0
 800ed20:	4618      	mov	r0, r3
 800ed22:	f000 fec7 	bl	800fab4 <_nx_tcp_socket_thread_resume>
            }

            /* If given, call the application's disconnect callback function
               for disconnect.  */
            if (socket_ptr -> nx_tcp_disconnect_callback)
 800ed26:	687b      	ldr	r3, [r7, #4]
 800ed28:	f8d3 3118 	ldr.w	r3, [r3, #280]	; 0x118
 800ed2c:	2b00      	cmp	r3, #0
 800ed2e:	d004      	beq.n	800ed3a <_nx_tcp_socket_state_closing+0x6a>
            {

                /* Call the application's disconnect handling function.  It is
                   responsible for calling the socket disconnect function.  */
                (socket_ptr -> nx_tcp_disconnect_callback)(socket_ptr);
 800ed30:	687b      	ldr	r3, [r7, #4]
 800ed32:	f8d3 3118 	ldr.w	r3, [r3, #280]	; 0x118
 800ed36:	6878      	ldr	r0, [r7, #4]
 800ed38:	4798      	blx	r3
#endif
        }

        /* Ignore the segment.  According to RFC 793, Section 3.9, Page 73.  */
    }
}
 800ed3a:	bf00      	nop
 800ed3c:	3708      	adds	r7, #8
 800ed3e:	46bd      	mov	sp, r7
 800ed40:	bd80      	pop	{r7, pc}
 800ed42:	bf00      	nop
 800ed44:	24000b38 	.word	0x24000b38

0800ed48 <_nx_tcp_socket_state_data_trim>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
VOID _nx_tcp_socket_state_data_trim(NX_PACKET *packet_ptr, ULONG amount)
{
 800ed48:	b580      	push	{r7, lr}
 800ed4a:	b086      	sub	sp, #24
 800ed4c:	af00      	add	r7, sp, #0
 800ed4e:	6078      	str	r0, [r7, #4]
 800ed50:	6039      	str	r1, [r7, #0]
ULONG      bytes_to_keep;
NX_PACKET *work_ptr;

    if (amount >= packet_ptr -> nx_packet_length)
 800ed52:	687b      	ldr	r3, [r7, #4]
 800ed54:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800ed56:	683a      	ldr	r2, [r7, #0]
 800ed58:	429a      	cmp	r2, r3
 800ed5a:	d23c      	bcs.n	800edd6 <_nx_tcp_socket_state_data_trim+0x8e>
    {
        /* Invalid input. */
        return;
    }

    bytes_to_keep = packet_ptr -> nx_packet_length - amount;
 800ed5c:	687b      	ldr	r3, [r7, #4]
 800ed5e:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 800ed60:	683b      	ldr	r3, [r7, #0]
 800ed62:	1ad3      	subs	r3, r2, r3
 800ed64:	617b      	str	r3, [r7, #20]

    packet_ptr -> nx_packet_length = bytes_to_keep;
 800ed66:	687b      	ldr	r3, [r7, #4]
 800ed68:	697a      	ldr	r2, [r7, #20]
 800ed6a:	625a      	str	r2, [r3, #36]	; 0x24

    work_ptr = packet_ptr;
 800ed6c:	687b      	ldr	r3, [r7, #4]
 800ed6e:	613b      	str	r3, [r7, #16]

#ifndef NX_DISABLE_PACKET_CHAIN
    /* Walk down the packet chain for the "bytes_to_keep" amount. */
    while (work_ptr)
 800ed70:	e02d      	b.n	800edce <_nx_tcp_socket_state_data_trim+0x86>
    {

    NX_PACKET *tmp_ptr;

        /*lint -e{946} -e{947} suppress pointer subtraction, since it is necessary. */
        if ((INT)(work_ptr -> nx_packet_append_ptr - work_ptr -> nx_packet_prepend_ptr) < (INT)bytes_to_keep)
 800ed72:	693b      	ldr	r3, [r7, #16]
 800ed74:	68da      	ldr	r2, [r3, #12]
 800ed76:	693b      	ldr	r3, [r7, #16]
 800ed78:	689b      	ldr	r3, [r3, #8]
 800ed7a:	1ad2      	subs	r2, r2, r3
 800ed7c:	697b      	ldr	r3, [r7, #20]
 800ed7e:	429a      	cmp	r2, r3
 800ed80:	da0c      	bge.n	800ed9c <_nx_tcp_socket_state_data_trim+0x54>
        {

            /*lint -e{923} suppress cast of pointer to ULONG.  */
            bytes_to_keep -= (ULONG)((ALIGN_TYPE)work_ptr -> nx_packet_append_ptr - (ALIGN_TYPE)work_ptr -> nx_packet_prepend_ptr);
 800ed82:	693b      	ldr	r3, [r7, #16]
 800ed84:	689b      	ldr	r3, [r3, #8]
 800ed86:	461a      	mov	r2, r3
 800ed88:	693b      	ldr	r3, [r7, #16]
 800ed8a:	68db      	ldr	r3, [r3, #12]
 800ed8c:	1ad3      	subs	r3, r2, r3
 800ed8e:	697a      	ldr	r2, [r7, #20]
 800ed90:	4413      	add	r3, r2
 800ed92:	617b      	str	r3, [r7, #20]

            work_ptr = work_ptr -> nx_packet_next;
 800ed94:	693b      	ldr	r3, [r7, #16]
 800ed96:	685b      	ldr	r3, [r3, #4]
 800ed98:	613b      	str	r3, [r7, #16]

            continue;
 800ed9a:	e018      	b.n	800edce <_nx_tcp_socket_state_data_trim+0x86>
        }
#endif /* NX_DISABLE_PACKET_CHAIN */

        /* This is the last packet. */
        work_ptr -> nx_packet_append_ptr = work_ptr -> nx_packet_prepend_ptr + bytes_to_keep;
 800ed9c:	693b      	ldr	r3, [r7, #16]
 800ed9e:	689a      	ldr	r2, [r3, #8]
 800eda0:	697b      	ldr	r3, [r7, #20]
 800eda2:	441a      	add	r2, r3
 800eda4:	693b      	ldr	r3, [r7, #16]
 800eda6:	60da      	str	r2, [r3, #12]

#ifndef NX_DISABLE_PACKET_CHAIN
        /* Free the rest of the packet chain. */
        tmp_ptr = work_ptr -> nx_packet_next;
 800eda8:	693b      	ldr	r3, [r7, #16]
 800edaa:	685b      	ldr	r3, [r3, #4]
 800edac:	60fb      	str	r3, [r7, #12]
        work_ptr -> nx_packet_next = NX_NULL;
 800edae:	693b      	ldr	r3, [r7, #16]
 800edb0:	2200      	movs	r2, #0
 800edb2:	605a      	str	r2, [r3, #4]
        work_ptr = tmp_ptr;
 800edb4:	68fb      	ldr	r3, [r7, #12]
 800edb6:	613b      	str	r3, [r7, #16]

        if (work_ptr)
 800edb8:	693b      	ldr	r3, [r7, #16]
 800edba:	2b00      	cmp	r3, #0
 800edbc:	d007      	beq.n	800edce <_nx_tcp_socket_state_data_trim+0x86>
        {

            /*lint -e{923} suppress cast of ULONG to pointer.  */
            work_ptr -> nx_packet_union_next.nx_packet_tcp_queue_next = (NX_PACKET *)NX_PACKET_ALLOCATED;
 800edbe:	693b      	ldr	r3, [r7, #16]
 800edc0:	f04f 32aa 	mov.w	r2, #2863311530	; 0xaaaaaaaa
 800edc4:	621a      	str	r2, [r3, #32]

            _nx_packet_release(work_ptr);
 800edc6:	6938      	ldr	r0, [r7, #16]
 800edc8:	f7fd fb1e 	bl	800c408 <_nx_packet_release>

            /* All done. Break out of the while loop and return. */
            break;
 800edcc:	e004      	b.n	800edd8 <_nx_tcp_socket_state_data_trim+0x90>
    while (work_ptr)
 800edce:	693b      	ldr	r3, [r7, #16]
 800edd0:	2b00      	cmp	r3, #0
 800edd2:	d1ce      	bne.n	800ed72 <_nx_tcp_socket_state_data_trim+0x2a>
 800edd4:	e000      	b.n	800edd8 <_nx_tcp_socket_state_data_trim+0x90>
        return;
 800edd6:	bf00      	nop
        }
    }
#endif /* NX_DISABLE_PACKET_CHAIN */
}
 800edd8:	3718      	adds	r7, #24
 800edda:	46bd      	mov	sp, r7
 800eddc:	bd80      	pop	{r7, pc}

0800edde <_nx_tcp_socket_state_data_trim_front>:
/*                                            verified memmove use cases, */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
VOID _nx_tcp_socket_state_data_trim_front(NX_PACKET *packet_ptr, ULONG amount)
{
 800edde:	b580      	push	{r7, lr}
 800ede0:	b084      	sub	sp, #16
 800ede2:	af00      	add	r7, sp, #0
 800ede4:	6078      	str	r0, [r7, #4]
 800ede6:	6039      	str	r1, [r7, #0]
NX_PACKET *work_ptr = packet_ptr;
 800ede8:	687b      	ldr	r3, [r7, #4]
 800edea:	60fb      	str	r3, [r7, #12]
ULONG      work_length;

    if (amount >= packet_ptr -> nx_packet_length || amount == 0)
 800edec:	687b      	ldr	r3, [r7, #4]
 800edee:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800edf0:	683a      	ldr	r2, [r7, #0]
 800edf2:	429a      	cmp	r2, r3
 800edf4:	d263      	bcs.n	800eebe <_nx_tcp_socket_state_data_trim_front+0xe0>
 800edf6:	683b      	ldr	r3, [r7, #0]
 800edf8:	2b00      	cmp	r3, #0
 800edfa:	d060      	beq.n	800eebe <_nx_tcp_socket_state_data_trim_front+0xe0>
        /* Invalid input. */
        return;
    }

    /* Adjust the packet length.  */
    packet_ptr -> nx_packet_length -= amount;
 800edfc:	687b      	ldr	r3, [r7, #4]
 800edfe:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 800ee00:	683b      	ldr	r3, [r7, #0]
 800ee02:	1ad2      	subs	r2, r2, r3
 800ee04:	687b      	ldr	r3, [r7, #4]
 800ee06:	625a      	str	r2, [r3, #36]	; 0x24

    /* Move prepend_ptr of first packet to TCP data.  */
    packet_ptr -> nx_packet_prepend_ptr += sizeof(NX_TCP_HEADER);
 800ee08:	687b      	ldr	r3, [r7, #4]
 800ee0a:	689b      	ldr	r3, [r3, #8]
 800ee0c:	f103 0214 	add.w	r2, r3, #20
 800ee10:	687b      	ldr	r3, [r7, #4]
 800ee12:	609a      	str	r2, [r3, #8]

#ifndef NX_DISABLE_PACKET_CHAIN
    /* Walk down the packet chain for the amount. */
    while (amount)
 800ee14:	e049      	b.n	800eeaa <_nx_tcp_socket_state_data_trim_front+0xcc>
    {
#endif /* NX_DISABLE_PACKET_CHAIN */

        /* Compute the size of the data portion work_ptr.  */
        /*lint -e{923} suppress cast of pointer to ULONG.  */
        work_length = (ULONG)((ALIGN_TYPE)work_ptr -> nx_packet_append_ptr - (ALIGN_TYPE)work_ptr -> nx_packet_prepend_ptr);
 800ee16:	68fb      	ldr	r3, [r7, #12]
 800ee18:	68db      	ldr	r3, [r3, #12]
 800ee1a:	461a      	mov	r2, r3
 800ee1c:	68fb      	ldr	r3, [r7, #12]
 800ee1e:	689b      	ldr	r3, [r3, #8]
 800ee20:	1ad3      	subs	r3, r2, r3
 800ee22:	60bb      	str	r3, [r7, #8]

#ifndef NX_DISABLE_PACKET_CHAIN
        if (amount > work_length)
 800ee24:	683a      	ldr	r2, [r7, #0]
 800ee26:	68bb      	ldr	r3, [r7, #8]
 800ee28:	429a      	cmp	r2, r3
 800ee2a:	d91e      	bls.n	800ee6a <_nx_tcp_socket_state_data_trim_front+0x8c>
        {

            /* All data in work_ptr need to be trimmed.  */
            if (work_ptr == packet_ptr)
 800ee2c:	68fa      	ldr	r2, [r7, #12]
 800ee2e:	687b      	ldr	r3, [r7, #4]
 800ee30:	429a      	cmp	r2, r3
 800ee32:	d104      	bne.n	800ee3e <_nx_tcp_socket_state_data_trim_front+0x60>
            {

                /* This packet is the header of packet chain.  */
                /* Clear TCP data in this packet.  */
                work_ptr -> nx_packet_append_ptr = work_ptr -> nx_packet_prepend_ptr;
 800ee34:	68fb      	ldr	r3, [r7, #12]
 800ee36:	689a      	ldr	r2, [r3, #8]
 800ee38:	68fb      	ldr	r3, [r7, #12]
 800ee3a:	60da      	str	r2, [r3, #12]
 800ee3c:	e00d      	b.n	800ee5a <_nx_tcp_socket_state_data_trim_front+0x7c>
            else
            {

                /* This packet is not the first packet.  */
                /* Remove work_ptr from packet chain.  */
                packet_ptr -> nx_packet_next = work_ptr -> nx_packet_next;
 800ee3e:	68fb      	ldr	r3, [r7, #12]
 800ee40:	685a      	ldr	r2, [r3, #4]
 800ee42:	687b      	ldr	r3, [r7, #4]
 800ee44:	605a      	str	r2, [r3, #4]

                /* Disconnect work_ptr from the rest of the packet chain. */
                work_ptr -> nx_packet_next = NX_NULL;
 800ee46:	68fb      	ldr	r3, [r7, #12]
 800ee48:	2200      	movs	r2, #0
 800ee4a:	605a      	str	r2, [r3, #4]

                /* Mark the packet as ALLOCATED. */
                /*lint -e{923} suppress cast of ULONG to pointer.  */
                work_ptr -> nx_packet_union_next.nx_packet_tcp_queue_next = (NX_PACKET *)NX_PACKET_ALLOCATED;
 800ee4c:	68fb      	ldr	r3, [r7, #12]
 800ee4e:	f04f 32aa 	mov.w	r2, #2863311530	; 0xaaaaaaaa
 800ee52:	621a      	str	r2, [r3, #32]

                _nx_packet_release(work_ptr);
 800ee54:	68f8      	ldr	r0, [r7, #12]
 800ee56:	f7fd fad7 	bl	800c408 <_nx_packet_release>
            }
            /* Reduce the amount being trimmed.  */
            amount -= work_length;
 800ee5a:	683a      	ldr	r2, [r7, #0]
 800ee5c:	68bb      	ldr	r3, [r7, #8]
 800ee5e:	1ad3      	subs	r3, r2, r3
 800ee60:	603b      	str	r3, [r7, #0]

            /* Move to the next packet. */
            work_ptr = packet_ptr -> nx_packet_next;
 800ee62:	687b      	ldr	r3, [r7, #4]
 800ee64:	685b      	ldr	r3, [r3, #4]
 800ee66:	60fb      	str	r3, [r7, #12]
 800ee68:	e01f      	b.n	800eeaa <_nx_tcp_socket_state_data_trim_front+0xcc>
        else
        {

            /* This is the last packet to trim.  */

            if (work_ptr == packet_ptr)
 800ee6a:	68fa      	ldr	r2, [r7, #12]
 800ee6c:	687b      	ldr	r3, [r7, #4]
 800ee6e:	429a      	cmp	r2, r3
 800ee70:	d113      	bne.n	800ee9a <_nx_tcp_socket_state_data_trim_front+0xbc>
            {
#endif /* NX_DISABLE_PACKET_CHAIN */

                /* For the first packet, move data towards the beginning
                   of the packet, right after TCP header.  */
                memmove(packet_ptr -> nx_packet_prepend_ptr, /* Use case of memmove is verified.  */
 800ee72:	687b      	ldr	r3, [r7, #4]
 800ee74:	6898      	ldr	r0, [r3, #8]
                        packet_ptr -> nx_packet_prepend_ptr + amount,
 800ee76:	687b      	ldr	r3, [r7, #4]
 800ee78:	689a      	ldr	r2, [r3, #8]
 800ee7a:	683b      	ldr	r3, [r7, #0]
 800ee7c:	18d1      	adds	r1, r2, r3
                        work_length - amount);
 800ee7e:	68ba      	ldr	r2, [r7, #8]
 800ee80:	683b      	ldr	r3, [r7, #0]
 800ee82:	1ad3      	subs	r3, r2, r3
                memmove(packet_ptr -> nx_packet_prepend_ptr, /* Use case of memmove is verified.  */
 800ee84:	461a      	mov	r2, r3
 800ee86:	f010 fcdf 	bl	801f848 <memmove>
                packet_ptr -> nx_packet_append_ptr -= amount;
 800ee8a:	687b      	ldr	r3, [r7, #4]
 800ee8c:	68da      	ldr	r2, [r3, #12]
 800ee8e:	683b      	ldr	r3, [r7, #0]
 800ee90:	425b      	negs	r3, r3
 800ee92:	441a      	add	r2, r3
 800ee94:	687b      	ldr	r3, [r7, #4]
 800ee96:	60da      	str	r2, [r3, #12]
 800ee98:	e005      	b.n	800eea6 <_nx_tcp_socket_state_data_trim_front+0xc8>
            }
            else
            {

                /* Advance nx_packet_prepend_ptr to where the usable data starts. */
                work_ptr -> nx_packet_prepend_ptr += amount;
 800ee9a:	68fb      	ldr	r3, [r7, #12]
 800ee9c:	689a      	ldr	r2, [r3, #8]
 800ee9e:	683b      	ldr	r3, [r7, #0]
 800eea0:	441a      	add	r2, r3
 800eea2:	68fb      	ldr	r3, [r7, #12]
 800eea4:	609a      	str	r2, [r3, #8]
            }

            /* Cut down amount*/
            amount = 0;
 800eea6:	2300      	movs	r3, #0
 800eea8:	603b      	str	r3, [r7, #0]
    while (amount)
 800eeaa:	683b      	ldr	r3, [r7, #0]
 800eeac:	2b00      	cmp	r3, #0
 800eeae:	d1b2      	bne.n	800ee16 <_nx_tcp_socket_state_data_trim_front+0x38>
        }
    }
#endif /* NX_DISABLE_PACKET_CHAIN */

    /* Restore prepend_ptr of first packet to TCP data.  */
    packet_ptr -> nx_packet_prepend_ptr -= sizeof(NX_TCP_HEADER);
 800eeb0:	687b      	ldr	r3, [r7, #4]
 800eeb2:	689b      	ldr	r3, [r3, #8]
 800eeb4:	f1a3 0214 	sub.w	r2, r3, #20
 800eeb8:	687b      	ldr	r3, [r7, #4]
 800eeba:	609a      	str	r2, [r3, #8]
 800eebc:	e000      	b.n	800eec0 <_nx_tcp_socket_state_data_trim_front+0xe2>
        return;
 800eebe:	bf00      	nop
}
 800eec0:	3710      	adds	r7, #16
 800eec2:	46bd      	mov	sp, r7
 800eec4:	bd80      	pop	{r7, pc}
	...

0800eec8 <_nx_tcp_socket_state_data_check>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
UINT  _nx_tcp_socket_state_data_check(NX_TCP_SOCKET *socket_ptr, NX_PACKET *packet_ptr)
{
 800eec8:	b580      	push	{r7, lr}
 800eeca:	b096      	sub	sp, #88	; 0x58
 800eecc:	af00      	add	r7, sp, #0
 800eece:	6078      	str	r0, [r7, #4]
 800eed0:	6039      	str	r1, [r7, #0]
ULONG          search_begin_sequence;
ULONG          search_end_sequence;
ULONG          original_rx_sequence;
ULONG          trim_data_length;
TX_THREAD     *thread_ptr;
ULONG          acked_packets = 0;
 800eed2:	2300      	movs	r3, #0
 800eed4:	63bb      	str	r3, [r7, #56]	; 0x38
UINT           need_ack = NX_FALSE;
 800eed6:	2300      	movs	r3, #0
 800eed8:	637b      	str	r3, [r7, #52]	; 0x34
#endif /* NX_ENABLE_LOW_WATERMARK */
#if ((!defined(NX_DISABLE_TCP_INFO)) || defined(TX_ENABLE_EVENT_TRACE))
NX_IP         *ip_ptr;

    /* Setup the IP pointer.  */
    ip_ptr =  socket_ptr -> nx_tcp_socket_ip_ptr;
 800eeda:	687b      	ldr	r3, [r7, #4]
 800eedc:	f8d3 30a0 	ldr.w	r3, [r3, #160]	; 0xa0
 800eee0:	633b      	str	r3, [r7, #48]	; 0x30
#endif


    /* Pickup the pointer to the head of the TCP packet.  */
    /*lint -e{927} -e{826} suppress cast of pointer to pointer, since it is necessary  */
    tcp_header_ptr =  (NX_TCP_HEADER *)packet_ptr -> nx_packet_prepend_ptr;
 800eee2:	683b      	ldr	r3, [r7, #0]
 800eee4:	689b      	ldr	r3, [r3, #8]
 800eee6:	62fb      	str	r3, [r7, #44]	; 0x2c

    /* Determine the size of the TCP header.  */
    header_length =  (tcp_header_ptr -> nx_tcp_header_word_3 >> NX_TCP_HEADER_SHIFT) * (ULONG)sizeof(ULONG);
 800eee8:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800eeea:	68db      	ldr	r3, [r3, #12]
 800eeec:	0f1b      	lsrs	r3, r3, #28
 800eeee:	009b      	lsls	r3, r3, #2
 800eef0:	62bb      	str	r3, [r7, #40]	; 0x28

    /* Record the original rx_sequence. */
    original_rx_sequence = socket_ptr -> nx_tcp_socket_rx_sequence;
 800eef2:	687b      	ldr	r3, [r7, #4]
 800eef4:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 800eef6:	627b      	str	r3, [r7, #36]	; 0x24

    /* Pickup the begin sequence of this packet. */
    packet_begin_sequence = tcp_header_ptr -> nx_tcp_sequence_number;
 800eef8:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800eefa:	685b      	ldr	r3, [r3, #4]
 800eefc:	64bb      	str	r3, [r7, #72]	; 0x48

    /* Calculate the data length in the packet.  */
    packet_data_length = packet_ptr -> nx_packet_length - header_length;
 800eefe:	683b      	ldr	r3, [r7, #0]
 800ef00:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 800ef02:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800ef04:	1ad3      	subs	r3, r2, r3
 800ef06:	643b      	str	r3, [r7, #64]	; 0x40

    /* Pickup the end sequence of this packet. The end sequence is one byte to the last byte in this packet. */
    packet_end_sequence =  tcp_header_ptr -> nx_tcp_sequence_number + packet_data_length;
 800ef08:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800ef0a:	685b      	ldr	r3, [r3, #4]
 800ef0c:	6c3a      	ldr	r2, [r7, #64]	; 0x40
 800ef0e:	4413      	add	r3, r2
 800ef10:	647b      	str	r3, [r7, #68]	; 0x44

    /* Trim the data that out of the receive window, make sure all data are in receive window.  */
    if (packet_data_length)
 800ef12:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 800ef14:	2b00      	cmp	r3, #0
 800ef16:	d03a      	beq.n	800ef8e <_nx_tcp_socket_state_data_check+0xc6>
    {

        /* Step1. trim the data on the left side of the receive window.  */
        if (((INT)socket_ptr -> nx_tcp_socket_rx_sequence - (INT)packet_begin_sequence) > 0)
 800ef18:	687b      	ldr	r3, [r7, #4]
 800ef1a:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 800ef1c:	461a      	mov	r2, r3
 800ef1e:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 800ef20:	1ad3      	subs	r3, r2, r3
 800ef22:	2b00      	cmp	r3, #0
 800ef24:	dd16      	ble.n	800ef54 <_nx_tcp_socket_state_data_check+0x8c>
        {

            /* Calculate the data length that out of window.  */
            trim_data_length = socket_ptr -> nx_tcp_socket_rx_sequence - packet_begin_sequence;
 800ef26:	687b      	ldr	r3, [r7, #4]
 800ef28:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 800ef2a:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 800ef2c:	1ad3      	subs	r3, r2, r3
 800ef2e:	623b      	str	r3, [r7, #32]

            /* Trim the data that exceed the receive window.  */
            _nx_tcp_socket_state_data_trim_front(packet_ptr, trim_data_length);
 800ef30:	6a39      	ldr	r1, [r7, #32]
 800ef32:	6838      	ldr	r0, [r7, #0]
 800ef34:	f7ff ff53 	bl	800edde <_nx_tcp_socket_state_data_trim_front>

            /* Fix the sequence of this packet. */
            tcp_header_ptr -> nx_tcp_sequence_number += trim_data_length;
 800ef38:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800ef3a:	685a      	ldr	r2, [r3, #4]
 800ef3c:	6a3b      	ldr	r3, [r7, #32]
 800ef3e:	441a      	add	r2, r3
 800ef40:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800ef42:	605a      	str	r2, [r3, #4]

            /* Update the data length and begin sequence.  */
            packet_data_length -= trim_data_length;
 800ef44:	6c3a      	ldr	r2, [r7, #64]	; 0x40
 800ef46:	6a3b      	ldr	r3, [r7, #32]
 800ef48:	1ad3      	subs	r3, r2, r3
 800ef4a:	643b      	str	r3, [r7, #64]	; 0x40
            packet_begin_sequence += trim_data_length;
 800ef4c:	6cba      	ldr	r2, [r7, #72]	; 0x48
 800ef4e:	6a3b      	ldr	r3, [r7, #32]
 800ef50:	4413      	add	r3, r2
 800ef52:	64bb      	str	r3, [r7, #72]	; 0x48
        }

        /* Step2. trim the data on the right side of the receive window.  */
        if ((((INT)packet_end_sequence - (INT)socket_ptr -> nx_tcp_socket_rx_sequence) -
 800ef54:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 800ef56:	687a      	ldr	r2, [r7, #4]
 800ef58:	6c12      	ldr	r2, [r2, #64]	; 0x40
 800ef5a:	1a9b      	subs	r3, r3, r2
             (INT)socket_ptr -> nx_tcp_socket_rx_window_current) > 0)
 800ef5c:	687a      	ldr	r2, [r7, #4]
 800ef5e:	6f52      	ldr	r2, [r2, #116]	; 0x74
        if ((((INT)packet_end_sequence - (INT)socket_ptr -> nx_tcp_socket_rx_sequence) -
 800ef60:	1a9b      	subs	r3, r3, r2
 800ef62:	2b00      	cmp	r3, #0
 800ef64:	dd13      	ble.n	800ef8e <_nx_tcp_socket_state_data_check+0xc6>
        {

            /* Calculate the data length that out of window.  */
            trim_data_length = packet_end_sequence - (socket_ptr -> nx_tcp_socket_rx_sequence + socket_ptr -> nx_tcp_socket_rx_window_current);
 800ef66:	687b      	ldr	r3, [r7, #4]
 800ef68:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 800ef6a:	687b      	ldr	r3, [r7, #4]
 800ef6c:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 800ef6e:	4413      	add	r3, r2
 800ef70:	6c7a      	ldr	r2, [r7, #68]	; 0x44
 800ef72:	1ad3      	subs	r3, r2, r3
 800ef74:	623b      	str	r3, [r7, #32]

            /* Trim the data that exceed the receive window.  */
            _nx_tcp_socket_state_data_trim(packet_ptr, trim_data_length);
 800ef76:	6a39      	ldr	r1, [r7, #32]
 800ef78:	6838      	ldr	r0, [r7, #0]
 800ef7a:	f7ff fee5 	bl	800ed48 <_nx_tcp_socket_state_data_trim>

            /* Update the data length and end sequence.  */
            packet_data_length -= trim_data_length;
 800ef7e:	6c3a      	ldr	r2, [r7, #64]	; 0x40
 800ef80:	6a3b      	ldr	r3, [r7, #32]
 800ef82:	1ad3      	subs	r3, r2, r3
 800ef84:	643b      	str	r3, [r7, #64]	; 0x40
            packet_end_sequence -= trim_data_length;
 800ef86:	6c7a      	ldr	r2, [r7, #68]	; 0x44
 800ef88:	6a3b      	ldr	r3, [r7, #32]
 800ef8a:	1ad3      	subs	r3, r2, r3
 800ef8c:	647b      	str	r3, [r7, #68]	; 0x44
        }
    }

    /* Determine if the packet has the FIN bit set to signal a disconnect.  */
    if (tcp_header_ptr -> nx_tcp_header_word_3 & NX_TCP_FIN_BIT)
 800ef8e:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800ef90:	68db      	ldr	r3, [r3, #12]
 800ef92:	f403 3380 	and.w	r3, r3, #65536	; 0x10000
 800ef96:	2b00      	cmp	r3, #0
 800ef98:	d009      	beq.n	800efae <_nx_tcp_socket_state_data_check+0xe6>
    {

        /* Setup the FIN sequence number that we need to look at.  */
        socket_ptr -> nx_tcp_socket_fin_sequence =  tcp_header_ptr -> nx_tcp_sequence_number + packet_data_length;
 800ef9a:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800ef9c:	685a      	ldr	r2, [r3, #4]
 800ef9e:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 800efa0:	441a      	add	r2, r3
 800efa2:	687b      	ldr	r3, [r7, #4]
 800efa4:	64da      	str	r2, [r3, #76]	; 0x4c

        /* Indicate that the FIN sequence is now valid.  Once the receive chain is complete
           we will process (ACK) the FIN command which is part of a disconnect started by the
           other side of the connection.  */
        socket_ptr -> nx_tcp_socket_fin_received =  NX_TRUE;
 800efa6:	687b      	ldr	r3, [r7, #4]
 800efa8:	2201      	movs	r2, #1
 800efaa:	f8a3 2050 	strh.w	r2, [r3, #80]	; 0x50
        /* If trace is enabled, insert this event into the trace buffer.  */
        NX_TRACE_IN_LINE_INSERT(NX_TRACE_INTERNAL_TCP_FIN_RECEIVE, ip_ptr, socket_ptr, packet_ptr, tcp_header_ptr -> nx_tcp_sequence_number, NX_TRACE_INTERNAL_EVENTS, 0, 0);
    }

    /* Compute the amount of payload data in this packet. */
    if (packet_data_length == 0)
 800efae:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 800efb0:	2b00      	cmp	r3, #0
 800efb2:	d11d      	bne.n	800eff0 <_nx_tcp_socket_state_data_check+0x128>
    {
        /* This packet does not contain TCP data payload.  */

        /* Check for invalid sequence number.  */
        if ((socket_ptr -> nx_tcp_socket_state == NX_TCP_ESTABLISHED) &&
 800efb4:	687b      	ldr	r3, [r7, #4]
 800efb6:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 800efb8:	2b05      	cmp	r3, #5
 800efba:	d117      	bne.n	800efec <_nx_tcp_socket_state_data_check+0x124>
            (socket_ptr -> nx_tcp_socket_receive_queue_count == 0) &&
 800efbc:	687b      	ldr	r3, [r7, #4]
 800efbe:	f8d3 30b0 	ldr.w	r3, [r3, #176]	; 0xb0
        if ((socket_ptr -> nx_tcp_socket_state == NX_TCP_ESTABLISHED) &&
 800efc2:	2b00      	cmp	r3, #0
 800efc4:	d112      	bne.n	800efec <_nx_tcp_socket_state_data_check+0x124>
            (socket_ptr -> nx_tcp_socket_rx_sequence != tcp_header_ptr -> nx_tcp_sequence_number) &&
 800efc6:	687b      	ldr	r3, [r7, #4]
 800efc8:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 800efca:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800efcc:	685b      	ldr	r3, [r3, #4]
            (socket_ptr -> nx_tcp_socket_receive_queue_count == 0) &&
 800efce:	429a      	cmp	r2, r3
 800efd0:	d00c      	beq.n	800efec <_nx_tcp_socket_state_data_check+0x124>
            ((socket_ptr -> nx_tcp_socket_rx_sequence - 1) != tcp_header_ptr -> nx_tcp_sequence_number))
 800efd2:	687b      	ldr	r3, [r7, #4]
 800efd4:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 800efd6:	1e5a      	subs	r2, r3, #1
 800efd8:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800efda:	685b      	ldr	r3, [r3, #4]
            (socket_ptr -> nx_tcp_socket_rx_sequence != tcp_header_ptr -> nx_tcp_sequence_number) &&
 800efdc:	429a      	cmp	r2, r3
 800efde:	d005      	beq.n	800efec <_nx_tcp_socket_state_data_check+0x124>
        {

            /* Send an immediate ACK.  */
            _nx_tcp_packet_send_ack(socket_ptr, socket_ptr -> nx_tcp_socket_tx_sequence);
 800efe0:	687b      	ldr	r3, [r7, #4]
 800efe2:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 800efe4:	4619      	mov	r1, r3
 800efe6:	6878      	ldr	r0, [r7, #4]
 800efe8:	f7fe fca2 	bl	800d930 <_nx_tcp_packet_send_ack>
        }

        /* This packet does not have data, so return false. */
        return(NX_FALSE);
 800efec:	2300      	movs	r3, #0
 800efee:	e29e      	b.n	800f52e <_nx_tcp_socket_state_data_check+0x666>
    /* If trace is enabled, insert this event into the trace buffer.  */
    NX_TRACE_IN_LINE_INSERT(NX_TRACE_INTERNAL_TCP_DATA_RECEIVE, ip_ptr, socket_ptr, packet_ptr, tcp_header_ptr -> nx_tcp_sequence_number, NX_TRACE_INTERNAL_EVENTS, 0, 0);

    /* Ensure the next pointer in the packet is set to NULL, which will indicate to the
       receive logic that it is not yet part of a contiguous stream.  */
    packet_ptr -> nx_packet_queue_next =  (NX_PACKET *)NX_NULL;
 800eff0:	683b      	ldr	r3, [r7, #0]
 800eff2:	2200      	movs	r2, #0
 800eff4:	61da      	str	r2, [r3, #28]

    /* Otherwise, the packet is within the receive window so continue processing
       the incoming TCP data.  */

    /* Pickup the tail pointer of the receive queue.  */
    search_ptr = socket_ptr -> nx_tcp_socket_receive_queue_tail;
 800eff6:	687b      	ldr	r3, [r7, #4]
 800eff8:	f8d3 30b8 	ldr.w	r3, [r3, #184]	; 0xb8
 800effc:	657b      	str	r3, [r7, #84]	; 0x54

    /* Check to see if the tail pointer is part of a contiguous stream.  */
    if (search_ptr)
 800effe:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 800f000:	2b00      	cmp	r3, #0
 800f002:	d010      	beq.n	800f026 <_nx_tcp_socket_state_data_check+0x15e>
    {

        /* Setup a pointer to header of this packet in the sent list.  */
        /*lint -e{927} -e{826} suppress cast of pointer to pointer, since it is necessary  */
        search_header_ptr =  (NX_TCP_HEADER *)search_ptr -> nx_packet_prepend_ptr;
 800f004:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 800f006:	689b      	ldr	r3, [r3, #8]
 800f008:	61fb      	str	r3, [r7, #28]

        /* Determine the size of the search TCP header.  */
        search_header_length =  (search_header_ptr -> nx_tcp_header_word_3 >> NX_TCP_HEADER_SHIFT) * (ULONG)sizeof(ULONG);
 800f00a:	69fb      	ldr	r3, [r7, #28]
 800f00c:	68db      	ldr	r3, [r3, #12]
 800f00e:	0f1b      	lsrs	r3, r3, #28
 800f010:	009b      	lsls	r3, r3, #2
 800f012:	61bb      	str	r3, [r7, #24]

        /* Now see if the current sequence number accounts for the last packet.  */
        search_end_sequence = search_header_ptr -> nx_tcp_sequence_number  + search_ptr -> nx_packet_length - search_header_length;
 800f014:	69fb      	ldr	r3, [r7, #28]
 800f016:	685a      	ldr	r2, [r3, #4]
 800f018:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 800f01a:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800f01c:	441a      	add	r2, r3
 800f01e:	69bb      	ldr	r3, [r7, #24]
 800f020:	1ad3      	subs	r3, r2, r3
 800f022:	63fb      	str	r3, [r7, #60]	; 0x3c
 800f024:	e002      	b.n	800f02c <_nx_tcp_socket_state_data_check+0x164>
    else
    {

        /* Set the sequence number to the socket's receive sequence if there isn't a receive
           packet on the queue.  */
        search_end_sequence =  socket_ptr -> nx_tcp_socket_rx_sequence;
 800f026:	687b      	ldr	r3, [r7, #4]
 800f028:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 800f02a:	63fb      	str	r3, [r7, #60]	; 0x3c
#endif /* NX_ENABLE_LOW_WATERMARK */

    /* Determine if we have a simple case of TCP data coming in the correct order.  This means
       the socket's sequence number matches the incoming packet sequence number and the last packet's
       data on the socket's receive queue (if any) matches the current sequence number.  */
    if ((tcp_header_ptr -> nx_tcp_sequence_number == socket_ptr -> nx_tcp_socket_rx_sequence) &&
 800f02c:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800f02e:	685a      	ldr	r2, [r3, #4]
 800f030:	687b      	ldr	r3, [r7, #4]
 800f032:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 800f034:	429a      	cmp	r2, r3
 800f036:	d132      	bne.n	800f09e <_nx_tcp_socket_state_data_check+0x1d6>
        (search_end_sequence == socket_ptr -> nx_tcp_socket_rx_sequence))
 800f038:	687b      	ldr	r3, [r7, #4]
 800f03a:	6c1b      	ldr	r3, [r3, #64]	; 0x40
    if ((tcp_header_ptr -> nx_tcp_sequence_number == socket_ptr -> nx_tcp_socket_rx_sequence) &&
 800f03c:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 800f03e:	429a      	cmp	r2, r3
 800f040:	d12d      	bne.n	800f09e <_nx_tcp_socket_state_data_check+0x1d6>
        {
#endif /* NX_ENABLE_LOW_WATERMARK */

            /* Mark the packet as ready. This is done to simplify the logic in socket receive.  */
            /*lint -e{923} suppress cast of ULONG to pointer.  */
            packet_ptr -> nx_packet_queue_next =  (NX_PACKET *)NX_PACKET_READY;
 800f042:	683b      	ldr	r3, [r7, #0]
 800f044:	f04f 32bb 	mov.w	r2, #3149642683	; 0xbbbbbbbb
 800f048:	61da      	str	r2, [r3, #28]
            /* Add debug information. */
            NX_PACKET_DEBUG(NX_PACKET_TCP_RECEIVE_QUEUE, __LINE__, packet_ptr);

            /* Place the packet on the receive queue.  Search pointer still points to the tail packet on
               the queue.  */
            if (search_ptr)
 800f04a:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 800f04c:	2b00      	cmp	r3, #0
 800f04e:	d007      	beq.n	800f060 <_nx_tcp_socket_state_data_check+0x198>
            {

                /* Nonempty receive queue, add packet to the end of the receive queue.  */
                search_ptr -> nx_packet_union_next.nx_packet_tcp_queue_next =  packet_ptr;
 800f050:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 800f052:	683a      	ldr	r2, [r7, #0]
 800f054:	621a      	str	r2, [r3, #32]

                /* Update the tail of the receive queue.  */
                socket_ptr -> nx_tcp_socket_receive_queue_tail =  packet_ptr;
 800f056:	687b      	ldr	r3, [r7, #4]
 800f058:	683a      	ldr	r2, [r7, #0]
 800f05a:	f8c3 20b8 	str.w	r2, [r3, #184]	; 0xb8
 800f05e:	e00b      	b.n	800f078 <_nx_tcp_socket_state_data_check+0x1b0>
            }
            else
            {

                /* Empty receive queue.  Set both the head and the tail pointers this packet.  */
                socket_ptr -> nx_tcp_socket_receive_queue_head =  packet_ptr;
 800f060:	687b      	ldr	r3, [r7, #4]
 800f062:	683a      	ldr	r2, [r7, #0]
 800f064:	f8c3 20b4 	str.w	r2, [r3, #180]	; 0xb4
                socket_ptr -> nx_tcp_socket_receive_queue_tail =  packet_ptr;
 800f068:	687b      	ldr	r3, [r7, #4]
 800f06a:	683a      	ldr	r2, [r7, #0]
 800f06c:	f8c3 20b8 	str.w	r2, [r3, #184]	; 0xb8

                /* Setup a new delayed ACK timeout.  */
                socket_ptr -> nx_tcp_socket_delayed_ack_timeout =  _nx_tcp_ack_timer_rate;
 800f070:	4b8a      	ldr	r3, [pc, #552]	; (800f29c <_nx_tcp_socket_state_data_check+0x3d4>)
 800f072:	681a      	ldr	r2, [r3, #0]
 800f074:	687b      	ldr	r3, [r7, #4]
 800f076:	649a      	str	r2, [r3, #72]	; 0x48
            }

            /* Increment the receive TCP packet count.  */
            socket_ptr -> nx_tcp_socket_receive_queue_count++;
 800f078:	687b      	ldr	r3, [r7, #4]
 800f07a:	f8d3 30b0 	ldr.w	r3, [r3, #176]	; 0xb0
 800f07e:	1c5a      	adds	r2, r3, #1
 800f080:	687b      	ldr	r3, [r7, #4]
 800f082:	f8c3 20b0 	str.w	r2, [r3, #176]	; 0xb0

            /* Set the next pointer to indicate the packet is part of a TCP queue.  */
            /*lint -e{923} suppress cast of ULONG to pointer.  */
            packet_ptr -> nx_packet_union_next.nx_packet_tcp_queue_next =  (NX_PACKET *)NX_PACKET_ENQUEUED;
 800f086:	683b      	ldr	r3, [r7, #0]
 800f088:	f04f 32ee 	mov.w	r2, #4008636142	; 0xeeeeeeee
 800f08c:	621a      	str	r2, [r3, #32]

            /* Calculate the next sequence number.  */
            socket_ptr -> nx_tcp_socket_rx_sequence =  packet_end_sequence;
 800f08e:	687b      	ldr	r3, [r7, #4]
 800f090:	6c7a      	ldr	r2, [r7, #68]	; 0x44
 800f092:	641a      	str	r2, [r3, #64]	; 0x40

            /* All packets can be acked. */
            acked_packets = socket_ptr -> nx_tcp_socket_receive_queue_count;
 800f094:	687b      	ldr	r3, [r7, #4]
 800f096:	f8d3 30b0 	ldr.w	r3, [r3, #176]	; 0xb0
 800f09a:	63bb      	str	r3, [r7, #56]	; 0x38
 800f09c:	e147      	b.n	800f32e <_nx_tcp_socket_state_data_check+0x466>
#endif /* NX_ENABLE_LOW_WATERMARK */

        /* End of the simple case: add new packet towards the end of the recv queue.
           All packets in the receive queue are in sequence. */
    }
    else if (socket_ptr -> nx_tcp_socket_receive_queue_head == NX_NULL)
 800f09e:	687b      	ldr	r3, [r7, #4]
 800f0a0:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 800f0a4:	2b00      	cmp	r3, #0
 800f0a6:	d11a      	bne.n	800f0de <_nx_tcp_socket_state_data_check+0x216>
        if (drop_packet == NX_FALSE)
        {
#endif /* NX_ENABLE_LOW_WATERMARK */

            /* Packet data begins to the right of the expected sequence (out of sequence data). Force an ACK. */
            _nx_tcp_packet_send_ack(socket_ptr, socket_ptr -> nx_tcp_socket_tx_sequence);
 800f0a8:	687b      	ldr	r3, [r7, #4]
 800f0aa:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 800f0ac:	4619      	mov	r1, r3
 800f0ae:	6878      	ldr	r0, [r7, #4]
 800f0b0:	f7fe fc3e 	bl	800d930 <_nx_tcp_packet_send_ack>
            /* Add debug information. */
            NX_PACKET_DEBUG(NX_PACKET_TCP_RECEIVE_QUEUE, __LINE__, packet_ptr);

            /* There are no packets chained on the receive queue.  Simply add the
               new packet to the receive queue. */
            socket_ptr -> nx_tcp_socket_receive_queue_head = packet_ptr;
 800f0b4:	687b      	ldr	r3, [r7, #4]
 800f0b6:	683a      	ldr	r2, [r7, #0]
 800f0b8:	f8c3 20b4 	str.w	r2, [r3, #180]	; 0xb4
            socket_ptr -> nx_tcp_socket_receive_queue_tail = packet_ptr;
 800f0bc:	687b      	ldr	r3, [r7, #4]
 800f0be:	683a      	ldr	r2, [r7, #0]
 800f0c0:	f8c3 20b8 	str.w	r2, [r3, #184]	; 0xb8

            /* Increase the receive queue count. */
            socket_ptr -> nx_tcp_socket_receive_queue_count = 1;
 800f0c4:	687b      	ldr	r3, [r7, #4]
 800f0c6:	2201      	movs	r2, #1
 800f0c8:	f8c3 20b0 	str.w	r2, [r3, #176]	; 0xb0

            /* Setup a new delayed ACK timeout.  */
            socket_ptr -> nx_tcp_socket_delayed_ack_timeout =  _nx_tcp_ack_timer_rate;
 800f0cc:	4b73      	ldr	r3, [pc, #460]	; (800f29c <_nx_tcp_socket_state_data_check+0x3d4>)
 800f0ce:	681a      	ldr	r2, [r3, #0]
 800f0d0:	687b      	ldr	r3, [r7, #4]
 800f0d2:	649a      	str	r2, [r3, #72]	; 0x48

            /* Mark the packet as being part of a TCP queue.  */
            /*lint -e{923} suppress cast of ULONG to pointer.  */
            packet_ptr -> nx_packet_union_next.nx_packet_tcp_queue_next =  (NX_PACKET *)NX_PACKET_ENQUEUED;
 800f0d4:	683b      	ldr	r3, [r7, #0]
 800f0d6:	f04f 32ee 	mov.w	r2, #4008636142	; 0xeeeeeeee
 800f0da:	621a      	str	r2, [r3, #32]
 800f0dc:	e127      	b.n	800f32e <_nx_tcp_socket_state_data_check+0x466>

        /* Go through the received packet chain, and locate the first packet that the
           packet_begin_sequence is to the right of the end of it. */

        /* Packet data begins to the right of the expected sequence (out of sequence data). Force an ACK. */
        if (((INT)packet_begin_sequence - (INT)socket_ptr -> nx_tcp_socket_rx_sequence) > 0)
 800f0de:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 800f0e0:	687a      	ldr	r2, [r7, #4]
 800f0e2:	6c12      	ldr	r2, [r2, #64]	; 0x40
 800f0e4:	1a9b      	subs	r3, r3, r2
 800f0e6:	2b00      	cmp	r3, #0
 800f0e8:	dd05      	ble.n	800f0f6 <_nx_tcp_socket_state_data_check+0x22e>
        {
            _nx_tcp_packet_send_ack(socket_ptr, socket_ptr -> nx_tcp_socket_tx_sequence);
 800f0ea:	687b      	ldr	r3, [r7, #4]
 800f0ec:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 800f0ee:	4619      	mov	r1, r3
 800f0f0:	6878      	ldr	r0, [r7, #4]
 800f0f2:	f7fe fc1d 	bl	800d930 <_nx_tcp_packet_send_ack>
        }

        /* At this point, it is guaranteed that the receive queue contains packets. */
        search_ptr = socket_ptr -> nx_tcp_socket_receive_queue_head;
 800f0f6:	687b      	ldr	r3, [r7, #4]
 800f0f8:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 800f0fc:	657b      	str	r3, [r7, #84]	; 0x54

        previous_ptr = NX_NULL;
 800f0fe:	2300      	movs	r3, #0
 800f100:	653b      	str	r3, [r7, #80]	; 0x50

        while (search_ptr)
 800f102:	e0ae      	b.n	800f262 <_nx_tcp_socket_state_data_check+0x39a>
        {

            /*lint -e{923} suppress cast of ULONG to pointer.  */
            if (search_ptr == (NX_PACKET *)NX_PACKET_ENQUEUED)
 800f104:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 800f106:	f1b3 3fee 	cmp.w	r3, #4008636142	; 0xeeeeeeee
 800f10a:	d102      	bne.n	800f112 <_nx_tcp_socket_state_data_check+0x24a>
            {
                /* We hit the end of the receive queue. */
                search_ptr = NX_NULL;
 800f10c:	2300      	movs	r3, #0
 800f10e:	657b      	str	r3, [r7, #84]	; 0x54

                /* Terminate the out-of-order search.  */
                break;
 800f110:	e0ad      	b.n	800f26e <_nx_tcp_socket_state_data_check+0x3a6>
            }

            /* Setup a pointer to header of this packet in the receive list.  */
            /*lint -e{927} -e{826} suppress cast of pointer to pointer, since it is necessary  */
            search_header_ptr =  (NX_TCP_HEADER *)search_ptr -> nx_packet_prepend_ptr;
 800f112:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 800f114:	689b      	ldr	r3, [r3, #8]
 800f116:	61fb      	str	r3, [r7, #28]

            search_begin_sequence = search_header_ptr -> nx_tcp_sequence_number;
 800f118:	69fb      	ldr	r3, [r7, #28]
 800f11a:	685b      	ldr	r3, [r3, #4]
 800f11c:	617b      	str	r3, [r7, #20]

            /* Calculate the header size for this packet.  */
            header_length =  (search_header_ptr -> nx_tcp_header_word_3 >> NX_TCP_HEADER_SHIFT) * (ULONG)sizeof(ULONG);
 800f11e:	69fb      	ldr	r3, [r7, #28]
 800f120:	68db      	ldr	r3, [r3, #12]
 800f122:	0f1b      	lsrs	r3, r3, #28
 800f124:	009b      	lsls	r3, r3, #2
 800f126:	62bb      	str	r3, [r7, #40]	; 0x28

            search_end_sequence = search_begin_sequence + search_ptr -> nx_packet_length - header_length;
 800f128:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 800f12a:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 800f12c:	697b      	ldr	r3, [r7, #20]
 800f12e:	441a      	add	r2, r3
 800f130:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800f132:	1ad3      	subs	r3, r2, r3
 800f134:	63fb      	str	r3, [r7, #60]	; 0x3c
             *        In this configuration, the incoming packet is completely to the right of      *
             *        search_ptr.  Move to the next search packet.                                  *
             *                                                                                      *
             ****************************************************************************************/
            /* packet_ptr is to the right of search_ptr */
            if (((INT)(packet_begin_sequence - search_end_sequence)) >= 0)
 800f136:	6cba      	ldr	r2, [r7, #72]	; 0x48
 800f138:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800f13a:	1ad3      	subs	r3, r2, r3
 800f13c:	2b00      	cmp	r3, #0
 800f13e:	db05      	blt.n	800f14c <_nx_tcp_socket_state_data_check+0x284>
            {
                /* Move on to the next packet. */
                previous_ptr = search_ptr;
 800f140:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 800f142:	653b      	str	r3, [r7, #80]	; 0x50

                search_ptr = search_ptr -> nx_packet_union_next.nx_packet_tcp_queue_next;
 800f144:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 800f146:	6a1b      	ldr	r3, [r3, #32]
 800f148:	657b      	str	r3, [r7, #84]	; 0x54

                /* Continue the search */
                continue;
 800f14a:	e08a      	b.n	800f262 <_nx_tcp_socket_state_data_check+0x39a>
             *              SSSSSSSSS                                                               *
             *        In this configuration, the incoming packet is completely to the left of       *
             *        search_ptr.  Incoming packet needs to be inserted in front of search ptr.     *
             *                                                                                      *
             ****************************************************************************************/
            if (((INT)(search_begin_sequence - packet_end_sequence)) >= 0)
 800f14c:	697a      	ldr	r2, [r7, #20]
 800f14e:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 800f150:	1ad3      	subs	r3, r2, r3
 800f152:	2b00      	cmp	r3, #0
 800f154:	f280 808a 	bge.w	800f26c <_nx_tcp_socket_state_data_check+0x3a4>
             *        to search for contigous data, therefore no need to wake up user thread.       *
             *        Howerver may need to send out ACK if new packet is to the right of the seq    *
             *        number.                                                                       *
             *                                                                                      *
             ****************************************************************************************/
            if ((((INT)(packet_begin_sequence - search_begin_sequence)) >= 0) &&
 800f158:	6cba      	ldr	r2, [r7, #72]	; 0x48
 800f15a:	697b      	ldr	r3, [r7, #20]
 800f15c:	1ad3      	subs	r3, r2, r3
 800f15e:	2b00      	cmp	r3, #0
 800f160:	db0c      	blt.n	800f17c <_nx_tcp_socket_state_data_check+0x2b4>
                (((INT)(search_end_sequence - packet_end_sequence)) >= 0))
 800f162:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 800f164:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 800f166:	1ad3      	subs	r3, r2, r3
            if ((((INT)(packet_begin_sequence - search_begin_sequence)) >= 0) &&
 800f168:	2b00      	cmp	r3, #0
 800f16a:	db07      	blt.n	800f17c <_nx_tcp_socket_state_data_check+0x2b4>
            {

                /* Send an immediate ACK.  */
                _nx_tcp_packet_send_ack(socket_ptr, socket_ptr -> nx_tcp_socket_tx_sequence);
 800f16c:	687b      	ldr	r3, [r7, #4]
 800f16e:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 800f170:	4619      	mov	r1, r3
 800f172:	6878      	ldr	r0, [r7, #4]
 800f174:	f7fe fbdc 	bl	800d930 <_nx_tcp_packet_send_ack>

                /* Since packet is not queued, return NX_FALSE so the caller releases the packet. */
                return(NX_FALSE);
 800f178:	2300      	movs	r3, #0
 800f17a:	e1d8      	b.n	800f52e <_nx_tcp_socket_state_data_check+0x666>
             *         Release existing packet, and insert new packet, then check for the next      *
             *         packet on the chain.  The next search may yield case (5).  Need to check     *
             *         for contingous data, may need to send ACK.                                   *
             *                                                                                      *
            ****************************************************************************************/
            if ((((INT)(search_begin_sequence - packet_begin_sequence)) >= 0) &&
 800f17c:	697a      	ldr	r2, [r7, #20]
 800f17e:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 800f180:	1ad3      	subs	r3, r2, r3
 800f182:	2b00      	cmp	r3, #0
 800f184:	db3a      	blt.n	800f1fc <_nx_tcp_socket_state_data_check+0x334>
                (((INT)(packet_end_sequence - search_end_sequence) >= 0)))
 800f186:	6c7a      	ldr	r2, [r7, #68]	; 0x44
 800f188:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800f18a:	1ad3      	subs	r3, r2, r3
            if ((((INT)(search_begin_sequence - packet_begin_sequence)) >= 0) &&
 800f18c:	2b00      	cmp	r3, #0
 800f18e:	db35      	blt.n	800f1fc <_nx_tcp_socket_state_data_check+0x334>
            {
            NX_PACKET *tmp_ptr;
                /* Release the search_ptr, and move to the next packet on the chain. */
                tmp_ptr = search_ptr -> nx_packet_union_next.nx_packet_tcp_queue_next;
 800f190:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 800f192:	6a1b      	ldr	r3, [r3, #32]
 800f194:	613b      	str	r3, [r7, #16]

                /* Mark the packet as no longer being part of the TCP queue. */
                /*lint -e{923} suppress cast of ULONG to pointer.  */
                search_ptr -> nx_packet_union_next.nx_packet_tcp_queue_next = (NX_PACKET *)NX_PACKET_ALLOCATED;
 800f196:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 800f198:	f04f 32aa 	mov.w	r2, #2863311530	; 0xaaaaaaaa
 800f19c:	621a      	str	r2, [r3, #32]

                /* Decrease the packet queue count */
                socket_ptr -> nx_tcp_socket_receive_queue_count--;
 800f19e:	687b      	ldr	r3, [r7, #4]
 800f1a0:	f8d3 30b0 	ldr.w	r3, [r3, #176]	; 0xb0
 800f1a4:	1e5a      	subs	r2, r3, #1
 800f1a6:	687b      	ldr	r3, [r7, #4]
 800f1a8:	f8c3 20b0 	str.w	r2, [r3, #176]	; 0xb0

                /* Adjust the receive window. */

                /* Release the search packet. */
                _nx_packet_release(search_ptr);
 800f1ac:	6d78      	ldr	r0, [r7, #84]	; 0x54
 800f1ae:	f7fd f92b 	bl	800c408 <_nx_packet_release>

#ifndef NX_DISABLE_TCP_INFO
                /* The new packet has been admitted to the receive queue. */

                /* Increment the TCP packet receive count and bytes received count.  */
                ip_ptr -> nx_ip_tcp_packets_received--;
 800f1b2:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800f1b4:	f8d3 30b0 	ldr.w	r3, [r3, #176]	; 0xb0
 800f1b8:	1e5a      	subs	r2, r3, #1
 800f1ba:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800f1bc:	f8c3 20b0 	str.w	r2, [r3, #176]	; 0xb0
                ip_ptr -> nx_ip_tcp_bytes_received -= (search_end_sequence - search_begin_sequence);
 800f1c0:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800f1c2:	f8d3 20b4 	ldr.w	r2, [r3, #180]	; 0xb4
 800f1c6:	6979      	ldr	r1, [r7, #20]
 800f1c8:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800f1ca:	1acb      	subs	r3, r1, r3
 800f1cc:	441a      	add	r2, r3
 800f1ce:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800f1d0:	f8c3 20b4 	str.w	r2, [r3, #180]	; 0xb4

                /* Increment the TCP packet receive count and bytes received count for the socket.  */
                socket_ptr -> nx_tcp_socket_packets_received--;
 800f1d4:	687b      	ldr	r3, [r7, #4]
 800f1d6:	f8d3 3084 	ldr.w	r3, [r3, #132]	; 0x84
 800f1da:	1e5a      	subs	r2, r3, #1
 800f1dc:	687b      	ldr	r3, [r7, #4]
 800f1de:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84
                socket_ptr -> nx_tcp_socket_bytes_received -= (search_end_sequence - search_begin_sequence);
 800f1e2:	687b      	ldr	r3, [r7, #4]
 800f1e4:	f8d3 2088 	ldr.w	r2, [r3, #136]	; 0x88
 800f1e8:	6979      	ldr	r1, [r7, #20]
 800f1ea:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800f1ec:	1acb      	subs	r3, r1, r3
 800f1ee:	441a      	add	r2, r3
 800f1f0:	687b      	ldr	r3, [r7, #4]
 800f1f2:	f8c3 2088 	str.w	r2, [r3, #136]	; 0x88

#endif /* NX_DISABLE_TCP_INFO */

                /* Move to the next packet.  (note: no need to update previous_ptr. */
                search_ptr = tmp_ptr;
 800f1f6:	693b      	ldr	r3, [r7, #16]
 800f1f8:	657b      	str	r3, [r7, #84]	; 0x54

                /* Continue the search. */
                continue;
 800f1fa:	e032      	b.n	800f262 <_nx_tcp_socket_state_data_check+0x39a>
             *                   SSSSSSSSSSSS                                                       *
             *        In this configuration, remove data from the back of the new packet,  insert   *
             *        packet into the chain, and terminate the search.  Need to search for          *
             *        contigous data, may need to send out ACK.                                     *
             ****************************************************************************************/
            if (((INT)(search_begin_sequence - packet_begin_sequence)) >= 0)
 800f1fc:	697a      	ldr	r2, [r7, #20]
 800f1fe:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 800f200:	1ad3      	subs	r3, r2, r3
 800f202:	2b00      	cmp	r3, #0
 800f204:	db0d      	blt.n	800f222 <_nx_tcp_socket_state_data_check+0x35a>
            {

                _nx_tcp_socket_state_data_trim(packet_ptr, (packet_end_sequence - search_begin_sequence));
 800f206:	6c7a      	ldr	r2, [r7, #68]	; 0x44
 800f208:	697b      	ldr	r3, [r7, #20]
 800f20a:	1ad3      	subs	r3, r2, r3
 800f20c:	4619      	mov	r1, r3
 800f20e:	6838      	ldr	r0, [r7, #0]
 800f210:	f7ff fd9a 	bl	800ed48 <_nx_tcp_socket_state_data_trim>

                /* Update packet_data_length. */
                packet_data_length -= (packet_end_sequence - search_begin_sequence);
 800f214:	697a      	ldr	r2, [r7, #20]
 800f216:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 800f218:	1ad3      	subs	r3, r2, r3
 800f21a:	6c3a      	ldr	r2, [r7, #64]	; 0x40
 800f21c:	4413      	add	r3, r2
 800f21e:	643b      	str	r3, [r7, #64]	; 0x40

                /* Now the packet should be chained before search_ptr. */

                break;
 800f220:	e025      	b.n	800f26e <_nx_tcp_socket_state_data_check+0x3a6>
             *        insert the packet after the search packet and continue the search.  This may  *
             *        lead to case (2) and (3).                                                     *
             *                                                                                      *
             *                                                                                      *
             ***************************************************************************************/
            _nx_tcp_socket_state_data_trim(search_ptr, (ULONG)(search_end_sequence - packet_begin_sequence));
 800f222:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 800f224:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 800f226:	1ad3      	subs	r3, r2, r3
 800f228:	4619      	mov	r1, r3
 800f22a:	6d78      	ldr	r0, [r7, #84]	; 0x54
 800f22c:	f7ff fd8c 	bl	800ed48 <_nx_tcp_socket_state_data_trim>

#ifndef NX_DISABLE_TCP_INFO
            /* The new packet has been admitted to the receive queue. */

            /* Reduce the TCP bytes received count.  */
            ip_ptr -> nx_ip_tcp_bytes_received -= (search_end_sequence - packet_begin_sequence);
 800f230:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800f232:	f8d3 20b4 	ldr.w	r2, [r3, #180]	; 0xb4
 800f236:	6cb9      	ldr	r1, [r7, #72]	; 0x48
 800f238:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800f23a:	1acb      	subs	r3, r1, r3
 800f23c:	441a      	add	r2, r3
 800f23e:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800f240:	f8c3 20b4 	str.w	r2, [r3, #180]	; 0xb4

            /* Reduce the TCP bytes received count for the socket.  */
            socket_ptr -> nx_tcp_socket_bytes_received -= (search_end_sequence - packet_begin_sequence);
 800f244:	687b      	ldr	r3, [r7, #4]
 800f246:	f8d3 2088 	ldr.w	r2, [r3, #136]	; 0x88
 800f24a:	6cb9      	ldr	r1, [r7, #72]	; 0x48
 800f24c:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800f24e:	1acb      	subs	r3, r1, r3
 800f250:	441a      	add	r2, r3
 800f252:	687b      	ldr	r3, [r7, #4]
 800f254:	f8c3 2088 	str.w	r2, [r3, #136]	; 0x88

#endif /* NX_DISABLE_TCP_INFO */

            /* Move to the next packet and continue; */
            previous_ptr = search_ptr;
 800f258:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 800f25a:	653b      	str	r3, [r7, #80]	; 0x50
            search_ptr = search_ptr -> nx_packet_union_next.nx_packet_tcp_queue_next;
 800f25c:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 800f25e:	6a1b      	ldr	r3, [r3, #32]
 800f260:	657b      	str	r3, [r7, #84]	; 0x54
        while (search_ptr)
 800f262:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 800f264:	2b00      	cmp	r3, #0
 800f266:	f47f af4d 	bne.w	800f104 <_nx_tcp_socket_state_data_check+0x23c>
 800f26a:	e000      	b.n	800f26e <_nx_tcp_socket_state_data_check+0x3a6>
                break;
 800f26c:	bf00      	nop
        }   /* End of while (search_ptr) */

        /* At this point, the logic (within the while loop) finds a location where this packet should be inserted. */
        if (previous_ptr == NX_NULL)
 800f26e:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 800f270:	2b00      	cmp	r3, #0
 800f272:	d104      	bne.n	800f27e <_nx_tcp_socket_state_data_check+0x3b6>
        {

            /* The packet needs to be inserted at the beginning of the queue. */
            socket_ptr -> nx_tcp_socket_receive_queue_head = packet_ptr;
 800f274:	687b      	ldr	r3, [r7, #4]
 800f276:	683a      	ldr	r2, [r7, #0]
 800f278:	f8c3 20b4 	str.w	r2, [r3, #180]	; 0xb4
 800f27c:	e002      	b.n	800f284 <_nx_tcp_socket_state_data_check+0x3bc>
        }
        else
        {

            /* The packet needs to be inserted after previous_ptr. */
            previous_ptr -> nx_packet_union_next.nx_packet_tcp_queue_next = packet_ptr;
 800f27e:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 800f280:	683a      	ldr	r2, [r7, #0]
 800f282:	621a      	str	r2, [r3, #32]
        }

        if (search_ptr == NX_NULL)
 800f284:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 800f286:	2b00      	cmp	r3, #0
 800f288:	d10a      	bne.n	800f2a0 <_nx_tcp_socket_state_data_check+0x3d8>
        {

            /* This packet is on the last one on the queue. */
            socket_ptr -> nx_tcp_socket_receive_queue_tail = packet_ptr;
 800f28a:	687b      	ldr	r3, [r7, #4]
 800f28c:	683a      	ldr	r2, [r7, #0]
 800f28e:	f8c3 20b8 	str.w	r2, [r3, #184]	; 0xb8

            /* Set the next pointer to indicate the packet is part of a TCP queue.  */
            /*lint -e{923} suppress cast of ULONG to pointer.  */
            packet_ptr -> nx_packet_union_next.nx_packet_tcp_queue_next = (NX_PACKET *)NX_PACKET_ENQUEUED;
 800f292:	683b      	ldr	r3, [r7, #0]
 800f294:	f04f 32ee 	mov.w	r2, #4008636142	; 0xeeeeeeee
 800f298:	621a      	str	r2, [r3, #32]
 800f29a:	e004      	b.n	800f2a6 <_nx_tcp_socket_state_data_check+0x3de>
 800f29c:	24000b30 	.word	0x24000b30
        }
        else
        {

            /* Chain search_ptr onto packet_ptr. */
            packet_ptr -> nx_packet_union_next.nx_packet_tcp_queue_next = search_ptr;
 800f2a0:	683b      	ldr	r3, [r7, #0]
 800f2a2:	6d7a      	ldr	r2, [r7, #84]	; 0x54
 800f2a4:	621a      	str	r2, [r3, #32]

        /* Add debug information. */
        NX_PACKET_DEBUG(NX_PACKET_TCP_RECEIVE_QUEUE, __LINE__, packet_ptr);

        /* Increment the receive TCP packet count.  */
        socket_ptr -> nx_tcp_socket_receive_queue_count++;
 800f2a6:	687b      	ldr	r3, [r7, #4]
 800f2a8:	f8d3 30b0 	ldr.w	r3, [r3, #176]	; 0xb0
 800f2ac:	1c5a      	adds	r2, r3, #1
 800f2ae:	687b      	ldr	r3, [r7, #4]
 800f2b0:	f8c3 20b0 	str.w	r2, [r3, #176]	; 0xb0

        /* End of the out-of-order search.  At this point, the packet has been inserted. */

        /* Now we need to figure out how much, if any, we can ACK.  */
        search_ptr =    socket_ptr -> nx_tcp_socket_receive_queue_head;
 800f2b4:	687b      	ldr	r3, [r7, #4]
 800f2b6:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 800f2ba:	657b      	str	r3, [r7, #84]	; 0x54

        /* Get the sequence number expected by the TCP receive socket. */
        expected_sequence =  socket_ptr -> nx_tcp_socket_rx_sequence;
 800f2bc:	687b      	ldr	r3, [r7, #4]
 800f2be:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 800f2c0:	64fb      	str	r3, [r7, #76]	; 0x4c
        do
        {

            /* Setup a pointer to header of this packet in the sent list.  */
            /*lint -e{927} -e{826} suppress cast of pointer to pointer, since it is necessary  */
            search_header_ptr =  (NX_TCP_HEADER *)search_ptr -> nx_packet_prepend_ptr;
 800f2c2:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 800f2c4:	689b      	ldr	r3, [r3, #8]
 800f2c6:	61fb      	str	r3, [r7, #28]


            /* Calculate the header size for this packet.  */
            header_length =  (search_header_ptr -> nx_tcp_header_word_3 >> NX_TCP_HEADER_SHIFT) * (ULONG)sizeof(ULONG);
 800f2c8:	69fb      	ldr	r3, [r7, #28]
 800f2ca:	68db      	ldr	r3, [r3, #12]
 800f2cc:	0f1b      	lsrs	r3, r3, #28
 800f2ce:	009b      	lsls	r3, r3, #2
 800f2d0:	62bb      	str	r3, [r7, #40]	; 0x28

            search_begin_sequence = search_header_ptr -> nx_tcp_sequence_number;
 800f2d2:	69fb      	ldr	r3, [r7, #28]
 800f2d4:	685b      	ldr	r3, [r3, #4]
 800f2d6:	617b      	str	r3, [r7, #20]

            search_end_sequence = search_begin_sequence + search_ptr -> nx_packet_length - header_length;
 800f2d8:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 800f2da:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 800f2dc:	697b      	ldr	r3, [r7, #20]
 800f2de:	441a      	add	r2, r3
 800f2e0:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800f2e2:	1ad3      	subs	r3, r2, r3
 800f2e4:	63fb      	str	r3, [r7, #60]	; 0x3c

            if ((INT)(expected_sequence - search_begin_sequence) >= 0)
 800f2e6:	6cfa      	ldr	r2, [r7, #76]	; 0x4c
 800f2e8:	697b      	ldr	r3, [r7, #20]
 800f2ea:	1ad3      	subs	r3, r2, r3
 800f2ec:	2b00      	cmp	r3, #0
 800f2ee:	db1d      	blt.n	800f32c <_nx_tcp_socket_state_data_check+0x464>
            {

                if ((INT)(search_end_sequence - expected_sequence) > 0)
 800f2f0:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 800f2f2:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800f2f4:	1ad3      	subs	r3, r2, r3
 800f2f6:	2b00      	cmp	r3, #0
 800f2f8:	dd0b      	ble.n	800f312 <_nx_tcp_socket_state_data_check+0x44a>
                {
                    /* Sequence number is within this packet.  Advance sequence number. */
                    expected_sequence = search_end_sequence;
 800f2fa:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800f2fc:	64fb      	str	r3, [r7, #76]	; 0x4c

                    socket_ptr -> nx_tcp_socket_rx_sequence = expected_sequence;
 800f2fe:	687b      	ldr	r3, [r7, #4]
 800f300:	6cfa      	ldr	r2, [r7, #76]	; 0x4c
 800f302:	641a      	str	r2, [r3, #64]	; 0x40

                    acked_packets++;
 800f304:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800f306:	3301      	adds	r3, #1
 800f308:	63bb      	str	r3, [r7, #56]	; 0x38

                    /* Mark this packet as ready for retrieval.  */
                    /*lint -e{923} suppress cast of ULONG to pointer.  */
                    search_ptr -> nx_packet_queue_next =  (NX_PACKET *)NX_PACKET_READY;
 800f30a:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 800f30c:	f04f 32bb 	mov.w	r2, #3149642683	; 0xbbbbbbbb
 800f310:	61da      	str	r2, [r3, #28]
                /* Expected number is to the left of search_ptr.   Get out of the do-while loop!  */
                break;
            }

            /* Move the search pointer to the next queued receive packet.  */
            search_ptr =  search_ptr -> nx_packet_union_next.nx_packet_tcp_queue_next;
 800f312:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 800f314:	6a1b      	ldr	r3, [r3, #32]
 800f316:	657b      	str	r3, [r7, #84]	; 0x54

            /* Determine if we are at the end of the queue.  */
            /*lint -e{923} suppress cast of ULONG to pointer.  */
            if (search_ptr == ((NX_PACKET *)NX_PACKET_ENQUEUED))
 800f318:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 800f31a:	f1b3 3fee 	cmp.w	r3, #4008636142	; 0xeeeeeeee
 800f31e:	d101      	bne.n	800f324 <_nx_tcp_socket_state_data_check+0x45c>
            {

                /* At the end, set the search pointer to NULL.  */
                search_ptr =  NX_NULL;
 800f320:	2300      	movs	r3, #0
 800f322:	657b      	str	r3, [r7, #84]	; 0x54

                /* Get out of the loop!  */
                break;
            }
#endif /* NX_ENABLE_LOW_WATERMARK */
        } while (search_ptr);
 800f324:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 800f326:	2b00      	cmp	r3, #0
 800f328:	d1cb      	bne.n	800f2c2 <_nx_tcp_socket_state_data_check+0x3fa>
 800f32a:	e000      	b.n	800f32e <_nx_tcp_socket_state_data_check+0x466>
                break;
 800f32c:	bf00      	nop

#ifndef NX_DISABLE_TCP_INFO
    /* The new packet has been admitted to the receive queue. */

    /* Increment the TCP packet receive count and bytes received count.  */
    ip_ptr -> nx_ip_tcp_packets_received++;
 800f32e:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800f330:	f8d3 30b0 	ldr.w	r3, [r3, #176]	; 0xb0
 800f334:	1c5a      	adds	r2, r3, #1
 800f336:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800f338:	f8c3 20b0 	str.w	r2, [r3, #176]	; 0xb0
    ip_ptr -> nx_ip_tcp_bytes_received += packet_data_length;
 800f33c:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800f33e:	f8d3 20b4 	ldr.w	r2, [r3, #180]	; 0xb4
 800f342:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 800f344:	441a      	add	r2, r3
 800f346:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800f348:	f8c3 20b4 	str.w	r2, [r3, #180]	; 0xb4

    /* Increment the TCP packet receive count and bytes received count for the socket.  */
    socket_ptr -> nx_tcp_socket_packets_received++;
 800f34c:	687b      	ldr	r3, [r7, #4]
 800f34e:	f8d3 3084 	ldr.w	r3, [r3, #132]	; 0x84
 800f352:	1c5a      	adds	r2, r3, #1
 800f354:	687b      	ldr	r3, [r7, #4]
 800f356:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84
    socket_ptr -> nx_tcp_socket_bytes_received += packet_data_length;
 800f35a:	687b      	ldr	r3, [r7, #4]
 800f35c:	f8d3 2088 	ldr.w	r2, [r3, #136]	; 0x88
 800f360:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 800f362:	441a      	add	r2, r3
 800f364:	687b      	ldr	r3, [r7, #4]
 800f366:	f8c3 2088 	str.w	r2, [r3, #136]	; 0x88
#endif

    /* Check if the rx sequence number has been updated.  */
    if (original_rx_sequence != socket_ptr -> nx_tcp_socket_rx_sequence)
 800f36a:	687b      	ldr	r3, [r7, #4]
 800f36c:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 800f36e:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 800f370:	429a      	cmp	r2, r3
 800f372:	d011      	beq.n	800f398 <_nx_tcp_socket_state_data_check+0x4d0>
    {

        /* Decrease the receive window size since rx_sequence is updated.  */
        socket_ptr -> nx_tcp_socket_rx_window_current -= (socket_ptr -> nx_tcp_socket_rx_sequence - original_rx_sequence);
 800f374:	687b      	ldr	r3, [r7, #4]
 800f376:	6f5a      	ldr	r2, [r3, #116]	; 0x74
 800f378:	687b      	ldr	r3, [r7, #4]
 800f37a:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 800f37c:	6a79      	ldr	r1, [r7, #36]	; 0x24
 800f37e:	1acb      	subs	r3, r1, r3
 800f380:	441a      	add	r2, r3
 800f382:	687b      	ldr	r3, [r7, #4]
 800f384:	675a      	str	r2, [r3, #116]	; 0x74

        /* Update the rx_window_last_sent for SWS avoidance algorithm.
           RFC1122, Section4.2.3.3, Page97-98.  */
        socket_ptr -> nx_tcp_socket_rx_window_last_sent -= (socket_ptr -> nx_tcp_socket_rx_sequence - original_rx_sequence);
 800f386:	687b      	ldr	r3, [r7, #4]
 800f388:	6f9a      	ldr	r2, [r3, #120]	; 0x78
 800f38a:	687b      	ldr	r3, [r7, #4]
 800f38c:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 800f38e:	6a79      	ldr	r1, [r7, #36]	; 0x24
 800f390:	1acb      	subs	r3, r1, r3
 800f392:	441a      	add	r2, r3
 800f394:	687b      	ldr	r3, [r7, #4]
 800f396:	679a      	str	r2, [r3, #120]	; 0x78
    }

#ifdef NX_TCP_MAX_OUT_OF_ORDER_PACKETS
    /* Does the count of out of order packets exceed the defined value? */
    if ((socket_ptr -> nx_tcp_socket_receive_queue_count - acked_packets) >
 800f398:	687b      	ldr	r3, [r7, #4]
 800f39a:	f8d3 20b0 	ldr.w	r2, [r3, #176]	; 0xb0
 800f39e:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800f3a0:	1ad3      	subs	r3, r2, r3
 800f3a2:	2b08      	cmp	r3, #8
 800f3a4:	f240 8089 	bls.w	800f4ba <_nx_tcp_socket_state_data_check+0x5f2>
        NX_TCP_MAX_OUT_OF_ORDER_PACKETS)
    {

        /* Yes it is. Remove the last packet in queue. */
        socket_ptr -> nx_tcp_socket_receive_queue_tail -> nx_packet_union_next.nx_packet_tcp_queue_next = (NX_PACKET *)NX_PACKET_ALLOCATED;
 800f3a8:	687b      	ldr	r3, [r7, #4]
 800f3aa:	f8d3 30b8 	ldr.w	r3, [r3, #184]	; 0xb8
 800f3ae:	f04f 32aa 	mov.w	r2, #2863311530	; 0xaaaaaaaa
 800f3b2:	621a      	str	r2, [r3, #32]
        if (socket_ptr -> nx_tcp_socket_receive_queue_count > 1)
 800f3b4:	687b      	ldr	r3, [r7, #4]
 800f3b6:	f8d3 30b0 	ldr.w	r3, [r3, #176]	; 0xb0
 800f3ba:	2b01      	cmp	r3, #1
 800f3bc:	d91d      	bls.n	800f3fa <_nx_tcp_socket_state_data_check+0x532>
        {

            /* Find the previous packet of tail. */
            search_ptr = socket_ptr -> nx_tcp_socket_receive_queue_head;
 800f3be:	687b      	ldr	r3, [r7, #4]
 800f3c0:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 800f3c4:	657b      	str	r3, [r7, #84]	; 0x54
            while (search_ptr -> nx_packet_union_next.nx_packet_tcp_queue_next != socket_ptr -> nx_tcp_socket_receive_queue_tail)
 800f3c6:	e002      	b.n	800f3ce <_nx_tcp_socket_state_data_check+0x506>
            {
                search_ptr = search_ptr -> nx_packet_union_next.nx_packet_tcp_queue_next;
 800f3c8:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 800f3ca:	6a1b      	ldr	r3, [r3, #32]
 800f3cc:	657b      	str	r3, [r7, #84]	; 0x54
            while (search_ptr -> nx_packet_union_next.nx_packet_tcp_queue_next != socket_ptr -> nx_tcp_socket_receive_queue_tail)
 800f3ce:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 800f3d0:	6a1a      	ldr	r2, [r3, #32]
 800f3d2:	687b      	ldr	r3, [r7, #4]
 800f3d4:	f8d3 30b8 	ldr.w	r3, [r3, #184]	; 0xb8
 800f3d8:	429a      	cmp	r2, r3
 800f3da:	d1f5      	bne.n	800f3c8 <_nx_tcp_socket_state_data_check+0x500>
            }

            /* Release the tail. */
            _nx_packet_release(socket_ptr -> nx_tcp_socket_receive_queue_tail);
 800f3dc:	687b      	ldr	r3, [r7, #4]
 800f3de:	f8d3 30b8 	ldr.w	r3, [r3, #184]	; 0xb8
 800f3e2:	4618      	mov	r0, r3
 800f3e4:	f7fd f810 	bl	800c408 <_nx_packet_release>

            /* Setup the tail packet. */
            socket_ptr -> nx_tcp_socket_receive_queue_tail = search_ptr;
 800f3e8:	687b      	ldr	r3, [r7, #4]
 800f3ea:	6d7a      	ldr	r2, [r7, #84]	; 0x54
 800f3ec:	f8c3 20b8 	str.w	r2, [r3, #184]	; 0xb8

            search_ptr -> nx_packet_union_next.nx_packet_tcp_queue_next = (NX_PACKET *)NX_PACKET_ENQUEUED;
 800f3f0:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 800f3f2:	f04f 32ee 	mov.w	r2, #4008636142	; 0xeeeeeeee
 800f3f6:	621a      	str	r2, [r3, #32]
 800f3f8:	e00d      	b.n	800f416 <_nx_tcp_socket_state_data_check+0x54e>
        }
        else
        {

            /* Release the tail. */
            _nx_packet_release(socket_ptr -> nx_tcp_socket_receive_queue_tail);
 800f3fa:	687b      	ldr	r3, [r7, #4]
 800f3fc:	f8d3 30b8 	ldr.w	r3, [r3, #184]	; 0xb8
 800f400:	4618      	mov	r0, r3
 800f402:	f7fd f801 	bl	800c408 <_nx_packet_release>

            /* Clear the head and tail packets. */
            socket_ptr -> nx_tcp_socket_receive_queue_head = NX_NULL;
 800f406:	687b      	ldr	r3, [r7, #4]
 800f408:	2200      	movs	r2, #0
 800f40a:	f8c3 20b4 	str.w	r2, [r3, #180]	; 0xb4
            socket_ptr -> nx_tcp_socket_receive_queue_tail = NX_NULL;
 800f40e:	687b      	ldr	r3, [r7, #4]
 800f410:	2200      	movs	r2, #0
 800f412:	f8c3 20b8 	str.w	r2, [r3, #184]	; 0xb8
        }

        /* Decrease receive queue count. */
        socket_ptr -> nx_tcp_socket_receive_queue_count--;
 800f416:	687b      	ldr	r3, [r7, #4]
 800f418:	f8d3 30b0 	ldr.w	r3, [r3, #176]	; 0xb0
 800f41c:	1e5a      	subs	r2, r3, #1
 800f41e:	687b      	ldr	r3, [r7, #4]
 800f420:	f8c3 20b0 	str.w	r2, [r3, #176]	; 0xb0

    /* At this point, we can use the packet TCP header pointers since the received
       packet is already queued.  */

    /* Any packets for receving? */
    while (acked_packets && socket_ptr -> nx_tcp_socket_receive_suspension_list)
 800f424:	e049      	b.n	800f4ba <_nx_tcp_socket_state_data_check+0x5f2>
    {

        /* Setup a pointer to the first queued packet.  */
        packet_ptr =  socket_ptr -> nx_tcp_socket_receive_queue_head;
 800f426:	687b      	ldr	r3, [r7, #4]
 800f428:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 800f42c:	603b      	str	r3, [r7, #0]
        /* Remove it from the queue.  */

        /* Simply update the head pointer of the queue.  */
        socket_ptr -> nx_tcp_socket_receive_queue_head =  packet_ptr -> nx_packet_union_next.nx_packet_tcp_queue_next;
 800f42e:	683b      	ldr	r3, [r7, #0]
 800f430:	6a1a      	ldr	r2, [r3, #32]
 800f432:	687b      	ldr	r3, [r7, #4]
 800f434:	f8c3 20b4 	str.w	r2, [r3, #180]	; 0xb4

        /* Mark the packet as no longer being part of the TCP queue.  */
        /*lint -e{923} suppress cast of ULONG to pointer.  */
        packet_ptr -> nx_packet_union_next.nx_packet_tcp_queue_next =  (NX_PACKET *)NX_PACKET_ALLOCATED;
 800f438:	683b      	ldr	r3, [r7, #0]
 800f43a:	f04f 32aa 	mov.w	r2, #2863311530	; 0xaaaaaaaa
 800f43e:	621a      	str	r2, [r3, #32]

        /* Clear the queue next pointer.  */
        packet_ptr -> nx_packet_queue_next =  NX_NULL;
 800f440:	683b      	ldr	r3, [r7, #0]
 800f442:	2200      	movs	r2, #0
 800f444:	61da      	str	r2, [r3, #28]

        /* Decrease the number of received packets.  */
        socket_ptr -> nx_tcp_socket_receive_queue_count--;
 800f446:	687b      	ldr	r3, [r7, #4]
 800f448:	f8d3 30b0 	ldr.w	r3, [r3, #176]	; 0xb0
 800f44c:	1e5a      	subs	r2, r3, #1
 800f44e:	687b      	ldr	r3, [r7, #4]
 800f450:	f8c3 20b0 	str.w	r2, [r3, #176]	; 0xb0

        /* Adjust the packet for delivery to the suspended thread.  */

        /* Setup a pointer to the TCP header of this packet.  */
        /*lint -e{927} -e{826} suppress cast of pointer to pointer, since it is necessary  */
        tcp_header_ptr =  (NX_TCP_HEADER *)packet_ptr -> nx_packet_prepend_ptr;
 800f454:	683b      	ldr	r3, [r7, #0]
 800f456:	689b      	ldr	r3, [r3, #8]
 800f458:	62fb      	str	r3, [r7, #44]	; 0x2c

        /* Calculate the header size for this packet.  */
        header_length =  (tcp_header_ptr -> nx_tcp_header_word_3 >> NX_TCP_HEADER_SHIFT) * (ULONG)sizeof(ULONG);
 800f45a:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800f45c:	68db      	ldr	r3, [r3, #12]
 800f45e:	0f1b      	lsrs	r3, r3, #28
 800f460:	009b      	lsls	r3, r3, #2
 800f462:	62bb      	str	r3, [r7, #40]	; 0x28

        /* Adjust the packet prepend pointer and length to position past the TCP header.  */
        packet_ptr -> nx_packet_prepend_ptr =  packet_ptr -> nx_packet_prepend_ptr + header_length;
 800f464:	683b      	ldr	r3, [r7, #0]
 800f466:	689a      	ldr	r2, [r3, #8]
 800f468:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800f46a:	441a      	add	r2, r3
 800f46c:	683b      	ldr	r3, [r7, #0]
 800f46e:	609a      	str	r2, [r3, #8]
        packet_ptr -> nx_packet_length =       packet_ptr -> nx_packet_length - header_length;
 800f470:	683b      	ldr	r3, [r7, #0]
 800f472:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 800f474:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800f476:	1ad2      	subs	r2, r2, r3
 800f478:	683b      	ldr	r3, [r7, #0]
 800f47a:	625a      	str	r2, [r3, #36]	; 0x24

        /* Setup a pointer to the first thread suspended on the receive queue.  */
        thread_ptr =  socket_ptr -> nx_tcp_socket_receive_suspension_list;
 800f47c:	687b      	ldr	r3, [r7, #4]
 800f47e:	f8d3 30ec 	ldr.w	r3, [r3, #236]	; 0xec
 800f482:	60fb      	str	r3, [r7, #12]

        /* Place the packet pointer in the return pointer.  */
        *((NX_PACKET **)thread_ptr -> tx_thread_additional_suspend_info) =  packet_ptr;
 800f484:	68fb      	ldr	r3, [r7, #12]
 800f486:	6fdb      	ldr	r3, [r3, #124]	; 0x7c
 800f488:	683a      	ldr	r2, [r7, #0]
 800f48a:	601a      	str	r2, [r3, #0]

        /* Increase the receive window size.  */
        socket_ptr -> nx_tcp_socket_rx_window_current += packet_ptr -> nx_packet_length;
 800f48c:	687b      	ldr	r3, [r7, #4]
 800f48e:	6f5a      	ldr	r2, [r3, #116]	; 0x74
 800f490:	683b      	ldr	r3, [r7, #0]
 800f492:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800f494:	441a      	add	r2, r3
 800f496:	687b      	ldr	r3, [r7, #4]
 800f498:	675a      	str	r2, [r3, #116]	; 0x74

        /* Remove the suspended thread from the list.  */

        /* Decrement the suspension count.  */
        socket_ptr -> nx_tcp_socket_receive_suspended_count--;
 800f49a:	687b      	ldr	r3, [r7, #4]
 800f49c:	f8d3 30f0 	ldr.w	r3, [r3, #240]	; 0xf0
 800f4a0:	1e5a      	subs	r2, r3, #1
 800f4a2:	687b      	ldr	r3, [r7, #4]
 800f4a4:	f8c3 20f0 	str.w	r2, [r3, #240]	; 0xf0

        /* Decrement the acked_packets count. */
        acked_packets--;
 800f4a8:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800f4aa:	3b01      	subs	r3, #1
 800f4ac:	63bb      	str	r3, [r7, #56]	; 0x38

        /* Resume thread.  */
        _nx_tcp_socket_thread_resume(&(socket_ptr -> nx_tcp_socket_receive_suspension_list), NX_SUCCESS);
 800f4ae:	687b      	ldr	r3, [r7, #4]
 800f4b0:	33ec      	adds	r3, #236	; 0xec
 800f4b2:	2100      	movs	r1, #0
 800f4b4:	4618      	mov	r0, r3
 800f4b6:	f000 fafd 	bl	800fab4 <_nx_tcp_socket_thread_resume>
    while (acked_packets && socket_ptr -> nx_tcp_socket_receive_suspension_list)
 800f4ba:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800f4bc:	2b00      	cmp	r3, #0
 800f4be:	d004      	beq.n	800f4ca <_nx_tcp_socket_state_data_check+0x602>
 800f4c0:	687b      	ldr	r3, [r7, #4]
 800f4c2:	f8d3 30ec 	ldr.w	r3, [r3, #236]	; 0xec
 800f4c6:	2b00      	cmp	r3, #0
 800f4c8:	d1ad      	bne.n	800f426 <_nx_tcp_socket_state_data_check+0x55e>
    }

    /* Is the queue empty?.  */
    if (socket_ptr -> nx_tcp_socket_receive_queue_count == 0)
 800f4ca:	687b      	ldr	r3, [r7, #4]
 800f4cc:	f8d3 30b0 	ldr.w	r3, [r3, #176]	; 0xb0
 800f4d0:	2b00      	cmp	r3, #0
 800f4d2:	d107      	bne.n	800f4e4 <_nx_tcp_socket_state_data_check+0x61c>
    {

        /* Yes. Set both head and tail pointers to NULL.  */
        socket_ptr -> nx_tcp_socket_receive_queue_head =  NX_NULL;
 800f4d4:	687b      	ldr	r3, [r7, #4]
 800f4d6:	2200      	movs	r2, #0
 800f4d8:	f8c3 20b4 	str.w	r2, [r3, #180]	; 0xb4
        socket_ptr -> nx_tcp_socket_receive_queue_tail =  NX_NULL;
 800f4dc:	687b      	ldr	r3, [r7, #4]
 800f4de:	2200      	movs	r2, #0
 800f4e0:	f8c3 20b8 	str.w	r2, [r3, #184]	; 0xb8
    }

    /* Determine if an ACK should be forced out for window update, SWS avoidance algorithm.
       RFC1122, Section4.2.3.3, Page97-98. */
    if ((socket_ptr -> nx_tcp_socket_rx_window_current - socket_ptr -> nx_tcp_socket_rx_window_last_sent) >= (socket_ptr -> nx_tcp_socket_rx_window_default / 2))
 800f4e4:	687b      	ldr	r3, [r7, #4]
 800f4e6:	6f5a      	ldr	r2, [r3, #116]	; 0x74
 800f4e8:	687b      	ldr	r3, [r7, #4]
 800f4ea:	6f9b      	ldr	r3, [r3, #120]	; 0x78
 800f4ec:	1ad2      	subs	r2, r2, r3
 800f4ee:	687b      	ldr	r3, [r7, #4]
 800f4f0:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 800f4f2:	085b      	lsrs	r3, r3, #1
 800f4f4:	429a      	cmp	r2, r3
 800f4f6:	d301      	bcc.n	800f4fc <_nx_tcp_socket_state_data_check+0x634>
    {

        /* Need to send ACK for window update.  */
        need_ack = NX_TRUE;
 800f4f8:	2301      	movs	r3, #1
 800f4fa:	637b      	str	r3, [r7, #52]	; 0x34
    }

    /* If the incoming packet caused the sequence number to move forward,
       indicating the new piece of data is in order, in sequence, and valid for receiving. */
    if (original_rx_sequence != socket_ptr -> nx_tcp_socket_rx_sequence)
 800f4fc:	687b      	ldr	r3, [r7, #4]
 800f4fe:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 800f500:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 800f502:	429a      	cmp	r2, r3
 800f504:	d009      	beq.n	800f51a <_nx_tcp_socket_state_data_check+0x652>
    {
        /* Determine if there is a socket receive notification function specified.  */
        if (socket_ptr -> nx_tcp_receive_callback)
 800f506:	687b      	ldr	r3, [r7, #4]
 800f508:	f8d3 311c 	ldr.w	r3, [r3, #284]	; 0x11c
 800f50c:	2b00      	cmp	r3, #0
 800f50e:	d004      	beq.n	800f51a <_nx_tcp_socket_state_data_check+0x652>
        {

            /* Yes, notification is requested.  Call the application's receive notification
               function for this socket.  */
            (socket_ptr -> nx_tcp_receive_callback)(socket_ptr);
 800f510:	687b      	ldr	r3, [r7, #4]
 800f512:	f8d3 311c 	ldr.w	r3, [r3, #284]	; 0x11c
 800f516:	6878      	ldr	r0, [r7, #4]
 800f518:	4798      	blx	r3
            }
        }
#endif
    }

    if (need_ack == NX_TRUE)
 800f51a:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800f51c:	2b01      	cmp	r3, #1
 800f51e:	d105      	bne.n	800f52c <_nx_tcp_socket_state_data_check+0x664>
    {

        /* Need to send ACK.  */
        _nx_tcp_packet_send_ack(socket_ptr, socket_ptr -> nx_tcp_socket_tx_sequence);
 800f520:	687b      	ldr	r3, [r7, #4]
 800f522:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 800f524:	4619      	mov	r1, r3
 800f526:	6878      	ldr	r0, [r7, #4]
 800f528:	f7fe fa02 	bl	800d930 <_nx_tcp_packet_send_ack>
    }

    /* Return true since the packet was queued.  */
    return(NX_TRUE);
 800f52c:	2301      	movs	r3, #1
}
 800f52e:	4618      	mov	r0, r3
 800f530:	3758      	adds	r7, #88	; 0x58
 800f532:	46bd      	mov	sp, r7
 800f534:	bd80      	pop	{r7, pc}
 800f536:	bf00      	nop

0800f538 <_nx_tcp_socket_state_established>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
VOID  _nx_tcp_socket_state_established(NX_TCP_SOCKET *socket_ptr)
{
 800f538:	b580      	push	{r7, lr}
 800f53a:	b084      	sub	sp, #16
 800f53c:	af00      	add	r7, sp, #0
 800f53e:	6078      	str	r0, [r7, #4]
#if !defined(NX_DISABLE_TCP_INFO) || defined(TX_ENABLE_EVENT_TRACE)
NX_IP *ip_ptr;


    /* Setup the IP pointer.  */
    ip_ptr =  socket_ptr -> nx_tcp_socket_ip_ptr;
 800f540:	687b      	ldr	r3, [r7, #4]
 800f542:	f8d3 30a0 	ldr.w	r3, [r3, #160]	; 0xa0
 800f546:	60fb      	str	r3, [r7, #12]
#endif
    /* Determine if a FIN has been previously detected in the _nx_tcp_socket_state_data_check
       routine and if the socket's sequence number matches the expected FIN sequence number.  */
    if ((socket_ptr -> nx_tcp_socket_fin_received) &&
 800f548:	687b      	ldr	r3, [r7, #4]
 800f54a:	f8b3 3050 	ldrh.w	r3, [r3, #80]	; 0x50
 800f54e:	2b00      	cmp	r3, #0
 800f550:	d031      	beq.n	800f5b6 <_nx_tcp_socket_state_established+0x7e>
        (socket_ptr -> nx_tcp_socket_fin_sequence == socket_ptr -> nx_tcp_socket_rx_sequence))
 800f552:	687b      	ldr	r3, [r7, #4]
 800f554:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 800f556:	687b      	ldr	r3, [r7, #4]
 800f558:	6c1b      	ldr	r3, [r3, #64]	; 0x40
    if ((socket_ptr -> nx_tcp_socket_fin_received) &&
 800f55a:	429a      	cmp	r2, r3
 800f55c:	d12b      	bne.n	800f5b6 <_nx_tcp_socket_state_established+0x7e>
    {

#ifndef NX_DISABLE_TCP_INFO
        /* Increment the TCP disconnections count.  */
        ip_ptr -> nx_ip_tcp_disconnections++;
 800f55e:	68fb      	ldr	r3, [r7, #12]
 800f560:	f8d3 30d0 	ldr.w	r3, [r3, #208]	; 0xd0
 800f564:	1c5a      	adds	r2, r3, #1
 800f566:	68fb      	ldr	r3, [r7, #12]
 800f568:	f8c3 20d0 	str.w	r2, [r3, #208]	; 0xd0

        /* If trace is enabled, insert this event into the trace buffer.  */
        NX_TRACE_IN_LINE_INSERT(NX_TRACE_INTERNAL_TCP_STATE_CHANGE, ip_ptr, socket_ptr, socket_ptr -> nx_tcp_socket_state, NX_TCP_CLOSE_WAIT, NX_TRACE_INTERNAL_EVENTS, 0, 0);

        /* The FIN bit is set, we need to go into the finished state.  */
        socket_ptr -> nx_tcp_socket_state =  NX_TCP_CLOSE_WAIT;
 800f56c:	687b      	ldr	r3, [r7, #4]
 800f56e:	2206      	movs	r2, #6
 800f570:	639a      	str	r2, [r3, #56]	; 0x38

        /* Increment the received sequence.  */
        socket_ptr -> nx_tcp_socket_rx_sequence++;
 800f572:	687b      	ldr	r3, [r7, #4]
 800f574:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 800f576:	1c5a      	adds	r2, r3, #1
 800f578:	687b      	ldr	r3, [r7, #4]
 800f57a:	641a      	str	r2, [r3, #64]	; 0x40

        /* Loop to release all threads suspended while trying to receive on the socket.  */
        while (socket_ptr -> nx_tcp_socket_receive_suspension_list)
 800f57c:	e006      	b.n	800f58c <_nx_tcp_socket_state_established+0x54>
        {

            /* Release the head of the receive suspension list. */
            _nx_tcp_receive_cleanup(socket_ptr -> nx_tcp_socket_receive_suspension_list NX_CLEANUP_ARGUMENT);
 800f57e:	687b      	ldr	r3, [r7, #4]
 800f580:	f8d3 30ec 	ldr.w	r3, [r3, #236]	; 0xec
 800f584:	2100      	movs	r1, #0
 800f586:	4618      	mov	r0, r3
 800f588:	f7fe fc14 	bl	800ddb4 <_nx_tcp_receive_cleanup>
        while (socket_ptr -> nx_tcp_socket_receive_suspension_list)
 800f58c:	687b      	ldr	r3, [r7, #4]
 800f58e:	f8d3 30ec 	ldr.w	r3, [r3, #236]	; 0xec
 800f592:	2b00      	cmp	r3, #0
 800f594:	d1f3      	bne.n	800f57e <_nx_tcp_socket_state_established+0x46>
        }

        /* Send ACK message.  */
        _nx_tcp_packet_send_ack(socket_ptr, socket_ptr -> nx_tcp_socket_tx_sequence);
 800f596:	687b      	ldr	r3, [r7, #4]
 800f598:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 800f59a:	4619      	mov	r1, r3
 800f59c:	6878      	ldr	r0, [r7, #4]
 800f59e:	f7fe f9c7 	bl	800d930 <_nx_tcp_packet_send_ack>

        /* If given, call the application's disconnect callback function
           for disconnect.  */
        if (socket_ptr -> nx_tcp_disconnect_callback)
 800f5a2:	687b      	ldr	r3, [r7, #4]
 800f5a4:	f8d3 3118 	ldr.w	r3, [r3, #280]	; 0x118
 800f5a8:	2b00      	cmp	r3, #0
 800f5aa:	d004      	beq.n	800f5b6 <_nx_tcp_socket_state_established+0x7e>
        {

            /* Call the application's disconnect handling function.  It is
               responsible for calling the socket disconnect function.  */
            (socket_ptr -> nx_tcp_disconnect_callback)(socket_ptr);
 800f5ac:	687b      	ldr	r3, [r7, #4]
 800f5ae:	f8d3 3118 	ldr.w	r3, [r3, #280]	; 0x118
 800f5b2:	6878      	ldr	r0, [r7, #4]
 800f5b4:	4798      	blx	r3
        }
    }
}
 800f5b6:	bf00      	nop
 800f5b8:	3710      	adds	r7, #16
 800f5ba:	46bd      	mov	sp, r7
 800f5bc:	bd80      	pop	{r7, pc}
	...

0800f5c0 <_nx_tcp_socket_state_fin_wait1>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
VOID  _nx_tcp_socket_state_fin_wait1(NX_TCP_SOCKET *socket_ptr)
{
 800f5c0:	b580      	push	{r7, lr}
 800f5c2:	b082      	sub	sp, #8
 800f5c4:	af00      	add	r7, sp, #0
 800f5c6:	6078      	str	r0, [r7, #4]


    /* Determine if the peer has proper ACK number but FIN is not sent,
       move into the FIN WAIT 2 state and do nothing else.  */
    if ((socket_ptr -> nx_tcp_socket_fin_acked) &&
 800f5c8:	687b      	ldr	r3, [r7, #4]
 800f5ca:	f8b3 3052 	ldrh.w	r3, [r3, #82]	; 0x52
 800f5ce:	2b00      	cmp	r3, #0
 800f5d0:	d00c      	beq.n	800f5ec <_nx_tcp_socket_state_fin_wait1+0x2c>
        (socket_ptr -> nx_tcp_socket_fin_received == NX_FALSE))
 800f5d2:	687b      	ldr	r3, [r7, #4]
 800f5d4:	f8b3 3050 	ldrh.w	r3, [r3, #80]	; 0x50
    if ((socket_ptr -> nx_tcp_socket_fin_acked) &&
 800f5d8:	2b00      	cmp	r3, #0
 800f5da:	d107      	bne.n	800f5ec <_nx_tcp_socket_state_fin_wait1+0x2c>
        /* If trace is enabled, insert this event into the trace buffer.  */
        NX_TRACE_IN_LINE_INSERT(NX_TRACE_INTERNAL_TCP_STATE_CHANGE, socket_ptr -> nx_tcp_socket_ip_ptr, socket_ptr, socket_ptr -> nx_tcp_socket_state, NX_TCP_FIN_WAIT_2, NX_TRACE_INTERNAL_EVENTS, 0, 0);

        /* We have a legitimate ACK message.  Simply move into the WAIT FIN 2 state
           for the other side to finish its processing and disconnect.  */
        socket_ptr -> nx_tcp_socket_state =  NX_TCP_FIN_WAIT_2;
 800f5dc:	687b      	ldr	r3, [r7, #4]
 800f5de:	2208      	movs	r2, #8
 800f5e0:	639a      	str	r2, [r3, #56]	; 0x38

        /* Otherwise, simply clear the FIN timeout.  */
        socket_ptr -> nx_tcp_socket_timeout =  0;
 800f5e2:	687b      	ldr	r3, [r7, #4]
 800f5e4:	2200      	movs	r2, #0
 800f5e6:	f8c3 20cc 	str.w	r2, [r3, #204]	; 0xcc
 800f5ea:	e04e      	b.n	800f68a <_nx_tcp_socket_state_fin_wait1+0xca>
    }
    else if ((socket_ptr -> nx_tcp_socket_fin_acked) &&
 800f5ec:	687b      	ldr	r3, [r7, #4]
 800f5ee:	f8b3 3052 	ldrh.w	r3, [r3, #82]	; 0x52
 800f5f2:	2b00      	cmp	r3, #0
 800f5f4:	d02f      	beq.n	800f656 <_nx_tcp_socket_state_fin_wait1+0x96>
             (socket_ptr -> nx_tcp_socket_fin_sequence == socket_ptr -> nx_tcp_socket_rx_sequence))
 800f5f6:	687b      	ldr	r3, [r7, #4]
 800f5f8:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 800f5fa:	687b      	ldr	r3, [r7, #4]
 800f5fc:	6c1b      	ldr	r3, [r3, #64]	; 0x40
    else if ((socket_ptr -> nx_tcp_socket_fin_acked) &&
 800f5fe:	429a      	cmp	r2, r3
 800f600:	d129      	bne.n	800f656 <_nx_tcp_socket_state_fin_wait1+0x96>

        /* If trace is enabled, insert this event into the trace buffer.  */
        NX_TRACE_IN_LINE_INSERT(NX_TRACE_INTERNAL_TCP_STATE_CHANGE, socket_ptr -> nx_tcp_socket_ip_ptr, socket_ptr, socket_ptr -> nx_tcp_socket_state, NX_TCP_TIMED_WAIT, NX_TRACE_INTERNAL_EVENTS, 0, 0);

        /* Set the socket state to TIMED WAIT now.  */
        socket_ptr -> nx_tcp_socket_state = NX_TCP_TIMED_WAIT;
 800f602:	687b      	ldr	r3, [r7, #4]
 800f604:	220a      	movs	r2, #10
 800f606:	639a      	str	r2, [r3, #56]	; 0x38

        /* Set the timeout as 2MSL (Maximum Segment Lifetime). */
        socket_ptr -> nx_tcp_socket_timeout = _nx_tcp_2MSL_timer_rate;
 800f608:	4b22      	ldr	r3, [pc, #136]	; (800f694 <_nx_tcp_socket_state_fin_wait1+0xd4>)
 800f60a:	681a      	ldr	r2, [r3, #0]
 800f60c:	687b      	ldr	r3, [r7, #4]
 800f60e:	f8c3 20cc 	str.w	r2, [r3, #204]	; 0xcc

        /* Send ACK back to the other side of the connection.  */

        /* Increment the received sequence number.  */
        socket_ptr -> nx_tcp_socket_rx_sequence++;
 800f612:	687b      	ldr	r3, [r7, #4]
 800f614:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 800f616:	1c5a      	adds	r2, r3, #1
 800f618:	687b      	ldr	r3, [r7, #4]
 800f61a:	641a      	str	r2, [r3, #64]	; 0x40

        /* Send ACK message.  */
        _nx_tcp_packet_send_ack(socket_ptr, socket_ptr -> nx_tcp_socket_tx_sequence);
 800f61c:	687b      	ldr	r3, [r7, #4]
 800f61e:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 800f620:	4619      	mov	r1, r3
 800f622:	6878      	ldr	r0, [r7, #4]
 800f624:	f7fe f984 	bl	800d930 <_nx_tcp_packet_send_ack>

        /* Determine if we need to wake a thread suspended on the connection.  */
        if (socket_ptr -> nx_tcp_socket_disconnect_suspended_thread)
 800f628:	687b      	ldr	r3, [r7, #4]
 800f62a:	f8d3 3100 	ldr.w	r3, [r3, #256]	; 0x100
 800f62e:	2b00      	cmp	r3, #0
 800f630:	d006      	beq.n	800f640 <_nx_tcp_socket_state_fin_wait1+0x80>
        {

            /* Resume the thread suspended for the disconnect.  */
            _nx_tcp_socket_thread_resume(&(socket_ptr -> nx_tcp_socket_disconnect_suspended_thread), NX_SUCCESS);
 800f632:	687b      	ldr	r3, [r7, #4]
 800f634:	f503 7380 	add.w	r3, r3, #256	; 0x100
 800f638:	2100      	movs	r1, #0
 800f63a:	4618      	mov	r0, r3
 800f63c:	f000 fa3a 	bl	800fab4 <_nx_tcp_socket_thread_resume>
        }

        /* If given, call the application's disconnect callback function
           for disconnect.  */
        if (socket_ptr -> nx_tcp_disconnect_callback)
 800f640:	687b      	ldr	r3, [r7, #4]
 800f642:	f8d3 3118 	ldr.w	r3, [r3, #280]	; 0x118
 800f646:	2b00      	cmp	r3, #0
 800f648:	d01f      	beq.n	800f68a <_nx_tcp_socket_state_fin_wait1+0xca>
        {

            /* Call the application's disconnect handling function.  It is
               responsible for calling the socket disconnect function.  */
            (socket_ptr -> nx_tcp_disconnect_callback)(socket_ptr);
 800f64a:	687b      	ldr	r3, [r7, #4]
 800f64c:	f8d3 3118 	ldr.w	r3, [r3, #280]	; 0x118
 800f650:	6878      	ldr	r0, [r7, #4]
 800f652:	4798      	blx	r3
        if (socket_ptr -> nx_tcp_disconnect_callback)
 800f654:	e019      	b.n	800f68a <_nx_tcp_socket_state_fin_wait1+0xca>
            /* Call the application's disconnect_complete callback function.    */
            (socket_ptr -> nx_tcp_disconnect_complete_notify)(socket_ptr);
        }
#endif
    }
    else if ((socket_ptr -> nx_tcp_socket_fin_received) &&
 800f656:	687b      	ldr	r3, [r7, #4]
 800f658:	f8b3 3050 	ldrh.w	r3, [r3, #80]	; 0x50
 800f65c:	2b00      	cmp	r3, #0
 800f65e:	d014      	beq.n	800f68a <_nx_tcp_socket_state_fin_wait1+0xca>
             (socket_ptr -> nx_tcp_socket_fin_sequence == socket_ptr -> nx_tcp_socket_rx_sequence))
 800f660:	687b      	ldr	r3, [r7, #4]
 800f662:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 800f664:	687b      	ldr	r3, [r7, #4]
 800f666:	6c1b      	ldr	r3, [r3, #64]	; 0x40
    else if ((socket_ptr -> nx_tcp_socket_fin_received) &&
 800f668:	429a      	cmp	r2, r3
 800f66a:	d10e      	bne.n	800f68a <_nx_tcp_socket_state_fin_wait1+0xca>

        /* If trace is enabled, insert this event into the trace buffer.  */
        NX_TRACE_IN_LINE_INSERT(NX_TRACE_INTERNAL_TCP_STATE_CHANGE, socket_ptr -> nx_tcp_socket_ip_ptr, socket_ptr, socket_ptr -> nx_tcp_socket_state, NX_TCP_CLOSING, NX_TRACE_INTERNAL_EVENTS, 0, 0);

        /* Move to the CLOSING state for simultaneous close situation.  */
        socket_ptr -> nx_tcp_socket_state =  NX_TCP_CLOSING;
 800f66c:	687b      	ldr	r3, [r7, #4]
 800f66e:	2209      	movs	r2, #9
 800f670:	639a      	str	r2, [r3, #56]	; 0x38

        /* Send ACK back to the other side of the connection.  */

        /* Increment the received sequence number.  */
        socket_ptr -> nx_tcp_socket_rx_sequence++;
 800f672:	687b      	ldr	r3, [r7, #4]
 800f674:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 800f676:	1c5a      	adds	r2, r3, #1
 800f678:	687b      	ldr	r3, [r7, #4]
 800f67a:	641a      	str	r2, [r3, #64]	; 0x40

        /* Send ACK message.  */
        _nx_tcp_packet_send_ack(socket_ptr, socket_ptr -> nx_tcp_socket_tx_sequence);
 800f67c:	687b      	ldr	r3, [r7, #4]
 800f67e:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 800f680:	4619      	mov	r1, r3
 800f682:	6878      	ldr	r0, [r7, #4]
 800f684:	f7fe f954 	bl	800d930 <_nx_tcp_packet_send_ack>
    }
}
 800f688:	e7ff      	b.n	800f68a <_nx_tcp_socket_state_fin_wait1+0xca>
 800f68a:	bf00      	nop
 800f68c:	3708      	adds	r7, #8
 800f68e:	46bd      	mov	sp, r7
 800f690:	bd80      	pop	{r7, pc}
 800f692:	bf00      	nop
 800f694:	24000b38 	.word	0x24000b38

0800f698 <_nx_tcp_socket_state_fin_wait2>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
VOID  _nx_tcp_socket_state_fin_wait2(NX_TCP_SOCKET *socket_ptr)
{
 800f698:	b580      	push	{r7, lr}
 800f69a:	b082      	sub	sp, #8
 800f69c:	af00      	add	r7, sp, #0
 800f69e:	6078      	str	r0, [r7, #4]


    /* Determine if a FIN has been previously detected in the _nx_tcp_socket_state_data_check
       routine and if the socket's sequence number matches the expected FIN sequence number.  */
    if ((socket_ptr -> nx_tcp_socket_fin_received) &&
 800f6a0:	687b      	ldr	r3, [r7, #4]
 800f6a2:	f8b3 3050 	ldrh.w	r3, [r3, #80]	; 0x50
 800f6a6:	2b00      	cmp	r3, #0
 800f6a8:	d02e      	beq.n	800f708 <_nx_tcp_socket_state_fin_wait2+0x70>
        (socket_ptr -> nx_tcp_socket_fin_sequence == socket_ptr -> nx_tcp_socket_rx_sequence))
 800f6aa:	687b      	ldr	r3, [r7, #4]
 800f6ac:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 800f6ae:	687b      	ldr	r3, [r7, #4]
 800f6b0:	6c1b      	ldr	r3, [r3, #64]	; 0x40
    if ((socket_ptr -> nx_tcp_socket_fin_received) &&
 800f6b2:	429a      	cmp	r2, r3
 800f6b4:	d128      	bne.n	800f708 <_nx_tcp_socket_state_fin_wait2+0x70>

        /* If trace is enabled, insert this event into the trace buffer.  */
        NX_TRACE_IN_LINE_INSERT(NX_TRACE_INTERNAL_TCP_STATE_CHANGE, socket_ptr -> nx_tcp_socket_ip_ptr, socket_ptr, socket_ptr -> nx_tcp_socket_state, NX_TCP_TIMED_WAIT, NX_TRACE_INTERNAL_EVENTS, 0, 0);

        /* Set the socket state to TIMED WAIT now.  */
        socket_ptr -> nx_tcp_socket_state = NX_TCP_TIMED_WAIT;
 800f6b6:	687b      	ldr	r3, [r7, #4]
 800f6b8:	220a      	movs	r2, #10
 800f6ba:	639a      	str	r2, [r3, #56]	; 0x38

        /* Set the timeout as 2MSL (Maximum Segment Lifetime).  */
        socket_ptr -> nx_tcp_socket_timeout = _nx_tcp_2MSL_timer_rate;
 800f6bc:	4b14      	ldr	r3, [pc, #80]	; (800f710 <_nx_tcp_socket_state_fin_wait2+0x78>)
 800f6be:	681a      	ldr	r2, [r3, #0]
 800f6c0:	687b      	ldr	r3, [r7, #4]
 800f6c2:	f8c3 20cc 	str.w	r2, [r3, #204]	; 0xcc

        /* Send ACK back to the other side of the connection.  */

        /* Increment the received sequence number.  */
        socket_ptr -> nx_tcp_socket_rx_sequence++;
 800f6c6:	687b      	ldr	r3, [r7, #4]
 800f6c8:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 800f6ca:	1c5a      	adds	r2, r3, #1
 800f6cc:	687b      	ldr	r3, [r7, #4]
 800f6ce:	641a      	str	r2, [r3, #64]	; 0x40

        /* Send ACK message.  */
        _nx_tcp_packet_send_ack(socket_ptr, socket_ptr -> nx_tcp_socket_tx_sequence);
 800f6d0:	687b      	ldr	r3, [r7, #4]
 800f6d2:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 800f6d4:	4619      	mov	r1, r3
 800f6d6:	6878      	ldr	r0, [r7, #4]
 800f6d8:	f7fe f92a 	bl	800d930 <_nx_tcp_packet_send_ack>

        /* Determine if we need to wake a thread suspended on the connection.  */
        if (socket_ptr -> nx_tcp_socket_disconnect_suspended_thread)
 800f6dc:	687b      	ldr	r3, [r7, #4]
 800f6de:	f8d3 3100 	ldr.w	r3, [r3, #256]	; 0x100
 800f6e2:	2b00      	cmp	r3, #0
 800f6e4:	d006      	beq.n	800f6f4 <_nx_tcp_socket_state_fin_wait2+0x5c>
        {

            /* Resume the thread suspended for the disconnect.  */
            _nx_tcp_socket_thread_resume(&(socket_ptr -> nx_tcp_socket_disconnect_suspended_thread), NX_SUCCESS);
 800f6e6:	687b      	ldr	r3, [r7, #4]
 800f6e8:	f503 7380 	add.w	r3, r3, #256	; 0x100
 800f6ec:	2100      	movs	r1, #0
 800f6ee:	4618      	mov	r0, r3
 800f6f0:	f000 f9e0 	bl	800fab4 <_nx_tcp_socket_thread_resume>
        }

        /* If given, call the application's disconnect callback function
           for disconnect.  */
        if (socket_ptr -> nx_tcp_disconnect_callback)
 800f6f4:	687b      	ldr	r3, [r7, #4]
 800f6f6:	f8d3 3118 	ldr.w	r3, [r3, #280]	; 0x118
 800f6fa:	2b00      	cmp	r3, #0
 800f6fc:	d004      	beq.n	800f708 <_nx_tcp_socket_state_fin_wait2+0x70>
        {

            /* Call the application's disconnect handling function.  It is
               responsible for calling the socket disconnect function.  */
            (socket_ptr -> nx_tcp_disconnect_callback)(socket_ptr);
 800f6fe:	687b      	ldr	r3, [r7, #4]
 800f700:	f8d3 3118 	ldr.w	r3, [r3, #280]	; 0x118
 800f704:	6878      	ldr	r0, [r7, #4]
 800f706:	4798      	blx	r3
            /* Call the application's disconnect_complete callback function.    */
            (socket_ptr -> nx_tcp_disconnect_complete_notify)(socket_ptr);
        }
#endif
    }
}
 800f708:	bf00      	nop
 800f70a:	3708      	adds	r7, #8
 800f70c:	46bd      	mov	sp, r7
 800f70e:	bd80      	pop	{r7, pc}
 800f710:	24000b38 	.word	0x24000b38

0800f714 <_nx_tcp_socket_state_last_ack>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
VOID  _nx_tcp_socket_state_last_ack(NX_TCP_SOCKET *socket_ptr, NX_TCP_HEADER *tcp_header_ptr)
{
 800f714:	b580      	push	{r7, lr}
 800f716:	b082      	sub	sp, #8
 800f718:	af00      	add	r7, sp, #0
 800f71a:	6078      	str	r0, [r7, #4]
 800f71c:	6039      	str	r1, [r7, #0]

    /* Determine if the incoming message is an ACK message.  */
    if (tcp_header_ptr -> nx_tcp_header_word_3 & NX_TCP_ACK_BIT)
 800f71e:	683b      	ldr	r3, [r7, #0]
 800f720:	68db      	ldr	r3, [r3, #12]
 800f722:	f403 1380 	and.w	r3, r3, #1048576	; 0x100000
 800f726:	2b00      	cmp	r3, #0
 800f728:	d01a      	beq.n	800f760 <_nx_tcp_socket_state_last_ack+0x4c>
    {

        /*   If it is proper, finish the disconnect. */
        if ((tcp_header_ptr -> nx_tcp_acknowledgment_number == socket_ptr -> nx_tcp_socket_tx_sequence) &&
 800f72a:	683b      	ldr	r3, [r7, #0]
 800f72c:	689a      	ldr	r2, [r3, #8]
 800f72e:	687b      	ldr	r3, [r7, #4]
 800f730:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 800f732:	429a      	cmp	r2, r3
 800f734:	d114      	bne.n	800f760 <_nx_tcp_socket_state_last_ack+0x4c>
            (tcp_header_ptr -> nx_tcp_sequence_number == socket_ptr -> nx_tcp_socket_rx_sequence))
 800f736:	683b      	ldr	r3, [r7, #0]
 800f738:	685a      	ldr	r2, [r3, #4]
 800f73a:	687b      	ldr	r3, [r7, #4]
 800f73c:	6c1b      	ldr	r3, [r3, #64]	; 0x40
        if ((tcp_header_ptr -> nx_tcp_acknowledgment_number == socket_ptr -> nx_tcp_socket_tx_sequence) &&
 800f73e:	429a      	cmp	r2, r3
 800f740:	d10e      	bne.n	800f760 <_nx_tcp_socket_state_last_ack+0x4c>
        {

            /* Cleanup the transmission control block.  */
            _nx_tcp_socket_block_cleanup(socket_ptr);
 800f742:	6878      	ldr	r0, [r7, #4]
 800f744:	f7fe fbde 	bl	800df04 <_nx_tcp_socket_block_cleanup>

            /* Determine if we need to wake a thread suspended on the disconnection.  */
            if (socket_ptr -> nx_tcp_socket_disconnect_suspended_thread)
 800f748:	687b      	ldr	r3, [r7, #4]
 800f74a:	f8d3 3100 	ldr.w	r3, [r3, #256]	; 0x100
 800f74e:	2b00      	cmp	r3, #0
 800f750:	d006      	beq.n	800f760 <_nx_tcp_socket_state_last_ack+0x4c>
            {

                /* Resume suspended thread.  */
                _nx_tcp_socket_thread_resume(&(socket_ptr -> nx_tcp_socket_disconnect_suspended_thread), NX_SUCCESS);
 800f752:	687b      	ldr	r3, [r7, #4]
 800f754:	f503 7380 	add.w	r3, r3, #256	; 0x100
 800f758:	2100      	movs	r1, #0
 800f75a:	4618      	mov	r0, r3
 800f75c:	f000 f9aa 	bl	800fab4 <_nx_tcp_socket_thread_resume>
                (socket_ptr -> nx_tcp_disconnect_complete_notify)(socket_ptr);
            }
#endif
        }
    }
}
 800f760:	bf00      	nop
 800f762:	3708      	adds	r7, #8
 800f764:	46bd      	mov	sp, r7
 800f766:	bd80      	pop	{r7, pc}

0800f768 <_nx_tcp_socket_state_syn_received>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
VOID  _nx_tcp_socket_state_syn_received(NX_TCP_SOCKET *socket_ptr, NX_TCP_HEADER *tcp_header_ptr)
{
 800f768:	b580      	push	{r7, lr}
 800f76a:	b082      	sub	sp, #8
 800f76c:	af00      	add	r7, sp, #0
 800f76e:	6078      	str	r0, [r7, #4]
 800f770:	6039      	str	r1, [r7, #0]


    /* Determine if the incoming message is an ACK message.  If it is and
       if it is proper, move into the ESTABLISHED state.  */
    if (tcp_header_ptr -> nx_tcp_header_word_3 & NX_TCP_ACK_BIT)
 800f772:	683b      	ldr	r3, [r7, #0]
 800f774:	68db      	ldr	r3, [r3, #12]
 800f776:	f403 1380 	and.w	r3, r3, #1048576	; 0x100000
 800f77a:	2b00      	cmp	r3, #0
 800f77c:	d04d      	beq.n	800f81a <_nx_tcp_socket_state_syn_received+0xb2>
    {

        if (tcp_header_ptr -> nx_tcp_acknowledgment_number == socket_ptr -> nx_tcp_socket_tx_sequence)
 800f77e:	683b      	ldr	r3, [r7, #0]
 800f780:	689a      	ldr	r2, [r3, #8]
 800f782:	687b      	ldr	r3, [r7, #4]
 800f784:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 800f786:	429a      	cmp	r2, r3
 800f788:	d143      	bne.n	800f812 <_nx_tcp_socket_state_syn_received+0xaa>
            /* If trace is enabled, insert this event into the trace buffer.  */
            NX_TRACE_IN_LINE_INSERT(NX_TRACE_INTERNAL_TCP_STATE_CHANGE, socket_ptr -> nx_tcp_socket_ip_ptr, socket_ptr, socket_ptr -> nx_tcp_socket_state, NX_TCP_ESTABLISHED, NX_TRACE_INTERNAL_EVENTS, 0, 0);

            /* Save the window size.  */
            socket_ptr -> nx_tcp_socket_tx_window_advertised =
                tcp_header_ptr -> nx_tcp_header_word_3 & NX_LOWER_16_MASK;
 800f78a:	683b      	ldr	r3, [r7, #0]
 800f78c:	68db      	ldr	r3, [r3, #12]
 800f78e:	b29a      	uxth	r2, r3
            socket_ptr -> nx_tcp_socket_tx_window_advertised =
 800f790:	687b      	ldr	r3, [r7, #4]
 800f792:	655a      	str	r2, [r3, #84]	; 0x54
            socket_ptr -> nx_tcp_socket_tx_window_advertised <<= socket_ptr -> nx_tcp_snd_win_scale_value;

#endif /* NX_ENABLE_TCP_WINDOW_SCALING  */

            /* Set the initial slow start threshold to be the advertised window size. */
            socket_ptr -> nx_tcp_socket_tx_slow_start_threshold = socket_ptr -> nx_tcp_socket_tx_window_advertised;
 800f794:	687b      	ldr	r3, [r7, #4]
 800f796:	6d5a      	ldr	r2, [r3, #84]	; 0x54
 800f798:	687b      	ldr	r3, [r7, #4]
 800f79a:	635a      	str	r2, [r3, #52]	; 0x34

            /* Set the initial congestion control window size. */
            /* Section 3.1, Page 5, RFC5681. */
            if (socket_ptr -> nx_tcp_socket_timeout_retries > 0)
 800f79c:	687b      	ldr	r3, [r7, #4]
 800f79e:	f8d3 30d4 	ldr.w	r3, [r3, #212]	; 0xd4
 800f7a2:	2b00      	cmp	r3, #0
 800f7a4:	d004      	beq.n	800f7b0 <_nx_tcp_socket_state_syn_received+0x48>
            {

                /* Set the initial congestion control window size to be the mss. */
                socket_ptr -> nx_tcp_socket_tx_window_congestion = socket_ptr -> nx_tcp_socket_connect_mss;
 800f7a6:	687b      	ldr	r3, [r7, #4]
 800f7a8:	6a1a      	ldr	r2, [r3, #32]
 800f7aa:	687b      	ldr	r3, [r7, #4]
 800f7ac:	659a      	str	r2, [r3, #88]	; 0x58
 800f7ae:	e01d      	b.n	800f7ec <_nx_tcp_socket_state_syn_received+0x84>
            }
            else
            {
                socket_ptr -> nx_tcp_socket_tx_window_congestion = (socket_ptr -> nx_tcp_socket_connect_mss << 2);
 800f7b0:	687b      	ldr	r3, [r7, #4]
 800f7b2:	6a1b      	ldr	r3, [r3, #32]
 800f7b4:	009a      	lsls	r2, r3, #2
 800f7b6:	687b      	ldr	r3, [r7, #4]
 800f7b8:	659a      	str	r2, [r3, #88]	; 0x58
                if (socket_ptr -> nx_tcp_socket_connect_mss > 1095)
 800f7ba:	687b      	ldr	r3, [r7, #4]
 800f7bc:	6a1b      	ldr	r3, [r3, #32]
 800f7be:	f5b3 6f89 	cmp.w	r3, #1096	; 0x448
 800f7c2:	d306      	bcc.n	800f7d2 <_nx_tcp_socket_state_syn_received+0x6a>
                {
                    socket_ptr -> nx_tcp_socket_tx_window_congestion -= socket_ptr -> nx_tcp_socket_connect_mss;
 800f7c4:	687b      	ldr	r3, [r7, #4]
 800f7c6:	6d9a      	ldr	r2, [r3, #88]	; 0x58
 800f7c8:	687b      	ldr	r3, [r7, #4]
 800f7ca:	6a1b      	ldr	r3, [r3, #32]
 800f7cc:	1ad2      	subs	r2, r2, r3
 800f7ce:	687b      	ldr	r3, [r7, #4]
 800f7d0:	659a      	str	r2, [r3, #88]	; 0x58
                }
                if (socket_ptr -> nx_tcp_socket_connect_mss > 2190)
 800f7d2:	687b      	ldr	r3, [r7, #4]
 800f7d4:	6a1b      	ldr	r3, [r3, #32]
 800f7d6:	f640 028e 	movw	r2, #2190	; 0x88e
 800f7da:	4293      	cmp	r3, r2
 800f7dc:	d906      	bls.n	800f7ec <_nx_tcp_socket_state_syn_received+0x84>
                {
                    socket_ptr -> nx_tcp_socket_tx_window_congestion -= socket_ptr -> nx_tcp_socket_connect_mss;
 800f7de:	687b      	ldr	r3, [r7, #4]
 800f7e0:	6d9a      	ldr	r2, [r3, #88]	; 0x58
 800f7e2:	687b      	ldr	r3, [r7, #4]
 800f7e4:	6a1b      	ldr	r3, [r3, #32]
 800f7e6:	1ad2      	subs	r2, r2, r3
 800f7e8:	687b      	ldr	r3, [r7, #4]
 800f7ea:	659a      	str	r2, [r3, #88]	; 0x58
                }
            }

            /* Move into the ESTABLISHED state.  */
            socket_ptr -> nx_tcp_socket_state =  NX_TCP_ESTABLISHED;
 800f7ec:	687b      	ldr	r3, [r7, #4]
 800f7ee:	2205      	movs	r2, #5
 800f7f0:	639a      	str	r2, [r3, #56]	; 0x38
                socket_ptr -> nx_tcp_socket_keepalive_timeout =  NX_TCP_KEEPALIVE_INITIAL;
                socket_ptr -> nx_tcp_socket_keepalive_retries =  0;
            }
#endif
            /* Update the value of nx_tcp_socket_rx_sequence_acked */
            socket_ptr -> nx_tcp_socket_rx_sequence_acked =    socket_ptr -> nx_tcp_socket_rx_sequence;
 800f7f2:	687b      	ldr	r3, [r7, #4]
 800f7f4:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 800f7f6:	687b      	ldr	r3, [r7, #4]
 800f7f8:	645a      	str	r2, [r3, #68]	; 0x44

            /* Determine if we need to wake a thread suspended on the connection.  */
            if (socket_ptr -> nx_tcp_socket_connect_suspended_thread)
 800f7fa:	687b      	ldr	r3, [r7, #4]
 800f7fc:	f8d3 30fc 	ldr.w	r3, [r3, #252]	; 0xfc
 800f800:	2b00      	cmp	r3, #0
 800f802:	d00a      	beq.n	800f81a <_nx_tcp_socket_state_syn_received+0xb2>
            {

                /* Resume the suspended thread.  */
                _nx_tcp_socket_thread_resume(&(socket_ptr -> nx_tcp_socket_connect_suspended_thread), NX_SUCCESS);
 800f804:	687b      	ldr	r3, [r7, #4]
 800f806:	33fc      	adds	r3, #252	; 0xfc
 800f808:	2100      	movs	r1, #0
 800f80a:	4618      	mov	r0, r3
 800f80c:	f000 f952 	bl	800fab4 <_nx_tcp_socket_thread_resume>

            /* Send the RST packet.  */
            _nx_tcp_packet_send_rst(socket_ptr, tcp_header_ptr);
        }
    }
}
 800f810:	e003      	b.n	800f81a <_nx_tcp_socket_state_syn_received+0xb2>
            _nx_tcp_packet_send_rst(socket_ptr, tcp_header_ptr);
 800f812:	6839      	ldr	r1, [r7, #0]
 800f814:	6878      	ldr	r0, [r7, #4]
 800f816:	f7fe f9e7 	bl	800dbe8 <_nx_tcp_packet_send_rst>
}
 800f81a:	bf00      	nop
 800f81c:	3708      	adds	r7, #8
 800f81e:	46bd      	mov	sp, r7
 800f820:	bd80      	pop	{r7, pc}

0800f822 <_nx_tcp_socket_state_syn_sent>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
VOID  _nx_tcp_socket_state_syn_sent(NX_TCP_SOCKET *socket_ptr, NX_TCP_HEADER *tcp_header_ptr, NX_PACKET *packet_ptr)
{
 800f822:	b580      	push	{r7, lr}
 800f824:	b084      	sub	sp, #16
 800f826:	af00      	add	r7, sp, #0
 800f828:	60f8      	str	r0, [r7, #12]
 800f82a:	60b9      	str	r1, [r7, #8]
 800f82c:	607a      	str	r2, [r7, #4]
#ifndef TX_ENABLE_EVENT_TRACE
    NX_PARAMETER_NOT_USED(packet_ptr);
#endif /* TX_ENABLE_EVENT_TRACE */

    /* Check if a RST is present. */
    if (tcp_header_ptr -> nx_tcp_header_word_3 & NX_TCP_RST_BIT)
 800f82e:	68bb      	ldr	r3, [r7, #8]
 800f830:	68db      	ldr	r3, [r3, #12]
 800f832:	f403 2380 	and.w	r3, r3, #262144	; 0x40000
 800f836:	2b00      	cmp	r3, #0
 800f838:	d019      	beq.n	800f86e <_nx_tcp_socket_state_syn_sent+0x4c>
    {

        /* Check if the ACK was acceptable. According to RFC 793, Section 3.9, Page 67.  */
        if ((tcp_header_ptr -> nx_tcp_header_word_3 & NX_TCP_ACK_BIT) &&
 800f83a:	68bb      	ldr	r3, [r7, #8]
 800f83c:	68db      	ldr	r3, [r3, #12]
 800f83e:	f403 1380 	and.w	r3, r3, #1048576	; 0x100000
 800f842:	2b00      	cmp	r3, #0
 800f844:	f000 80d2 	beq.w	800f9ec <_nx_tcp_socket_state_syn_sent+0x1ca>
            (tcp_header_ptr -> nx_tcp_acknowledgment_number == socket_ptr -> nx_tcp_socket_tx_sequence))
 800f848:	68bb      	ldr	r3, [r7, #8]
 800f84a:	689a      	ldr	r2, [r3, #8]
 800f84c:	68fb      	ldr	r3, [r7, #12]
 800f84e:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
        if ((tcp_header_ptr -> nx_tcp_header_word_3 & NX_TCP_ACK_BIT) &&
 800f850:	429a      	cmp	r2, r3
 800f852:	f040 80cb 	bne.w	800f9ec <_nx_tcp_socket_state_syn_sent+0x1ca>
        {

#ifndef NX_DISABLE_TCP_INFO

            /* Increment the resets received count.  */
            (socket_ptr -> nx_tcp_socket_ip_ptr) -> nx_ip_tcp_resets_received++;
 800f856:	68fb      	ldr	r3, [r7, #12]
 800f858:	f8d3 30a0 	ldr.w	r3, [r3, #160]	; 0xa0
 800f85c:	f8d3 20dc 	ldr.w	r2, [r3, #220]	; 0xdc
 800f860:	3201      	adds	r2, #1
 800f862:	f8c3 20dc 	str.w	r2, [r3, #220]	; 0xdc

            /* If trace is enabled, insert this event into the trace buffer.  */
            NX_TRACE_IN_LINE_INSERT(NX_TRACE_INTERNAL_TCP_RESET_RECEIVE, socket_ptr -> nx_tcp_socket_ip_ptr, socket_ptr, packet_ptr, tcp_header_ptr -> nx_tcp_sequence_number, NX_TRACE_INTERNAL_EVENTS, 0, 0);

            /* Reset connection.  */
            _nx_tcp_socket_connection_reset(socket_ptr);
 800f866:	68f8      	ldr	r0, [r7, #12]
 800f868:	f7fe fb79 	bl	800df5e <_nx_tcp_socket_connection_reset>
        }

        /* Finished processing, simply return!  */
        return;
 800f86c:	e0be      	b.n	800f9ec <_nx_tcp_socket_state_syn_sent+0x1ca>
    }
    /* Determine if a valid SYN/ACK is present.  */
    else if ((tcp_header_ptr -> nx_tcp_header_word_3 & NX_TCP_SYN_BIT) &&
 800f86e:	68bb      	ldr	r3, [r7, #8]
 800f870:	68db      	ldr	r3, [r3, #12]
 800f872:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
 800f876:	2b00      	cmp	r3, #0
 800f878:	d05d      	beq.n	800f936 <_nx_tcp_socket_state_syn_sent+0x114>
             (tcp_header_ptr -> nx_tcp_header_word_3 & NX_TCP_ACK_BIT) &&
 800f87a:	68bb      	ldr	r3, [r7, #8]
 800f87c:	68db      	ldr	r3, [r3, #12]
 800f87e:	f403 1380 	and.w	r3, r3, #1048576	; 0x100000
    else if ((tcp_header_ptr -> nx_tcp_header_word_3 & NX_TCP_SYN_BIT) &&
 800f882:	2b00      	cmp	r3, #0
 800f884:	d057      	beq.n	800f936 <_nx_tcp_socket_state_syn_sent+0x114>
             (tcp_header_ptr -> nx_tcp_acknowledgment_number == socket_ptr -> nx_tcp_socket_tx_sequence))
 800f886:	68bb      	ldr	r3, [r7, #8]
 800f888:	689a      	ldr	r2, [r3, #8]
 800f88a:	68fb      	ldr	r3, [r7, #12]
 800f88c:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
             (tcp_header_ptr -> nx_tcp_header_word_3 & NX_TCP_ACK_BIT) &&
 800f88e:	429a      	cmp	r2, r3
 800f890:	d151      	bne.n	800f936 <_nx_tcp_socket_state_syn_sent+0x114>
        /* Yes, this is a proper SYN/ACK message.  We need to send an ACK
           back the other direction before we go into the ESTABLISHED
           state.  */

        /* Save the sequence number.  */
        socket_ptr -> nx_tcp_socket_rx_sequence =  tcp_header_ptr -> nx_tcp_sequence_number + 1;
 800f892:	68bb      	ldr	r3, [r7, #8]
 800f894:	685b      	ldr	r3, [r3, #4]
 800f896:	1c5a      	adds	r2, r3, #1
 800f898:	68fb      	ldr	r3, [r7, #12]
 800f89a:	641a      	str	r2, [r3, #64]	; 0x40

        /* Save the window size.  */
        socket_ptr -> nx_tcp_socket_tx_window_advertised = tcp_header_ptr -> nx_tcp_header_word_3 & NX_LOWER_16_MASK;
 800f89c:	68bb      	ldr	r3, [r7, #8]
 800f89e:	68db      	ldr	r3, [r3, #12]
 800f8a0:	b29a      	uxth	r2, r3
 800f8a2:	68fb      	ldr	r3, [r7, #12]
 800f8a4:	655a      	str	r2, [r3, #84]	; 0x54
        }

#endif /* NX_ENABLE_TCP_WINDOW_SCALING */

        /* Initialize the slow start threshold to be the advertised window size. */
        socket_ptr -> nx_tcp_socket_tx_slow_start_threshold = socket_ptr -> nx_tcp_socket_tx_window_advertised;
 800f8a6:	68fb      	ldr	r3, [r7, #12]
 800f8a8:	6d5a      	ldr	r2, [r3, #84]	; 0x54
 800f8aa:	68fb      	ldr	r3, [r7, #12]
 800f8ac:	635a      	str	r2, [r3, #52]	; 0x34

        /* Set the Initial transmit outstanding byte count. */
        socket_ptr -> nx_tcp_socket_tx_outstanding_bytes = 0;
 800f8ae:	68fb      	ldr	r3, [r7, #12]
 800f8b0:	2200      	movs	r2, #0
 800f8b2:	65da      	str	r2, [r3, #92]	; 0x5c

        /* Set the initial congestion control window size. */
        /* Section 3.1, Page 5, RFC5681. */
        if (socket_ptr -> nx_tcp_socket_timeout_retries > 0)
 800f8b4:	68fb      	ldr	r3, [r7, #12]
 800f8b6:	f8d3 30d4 	ldr.w	r3, [r3, #212]	; 0xd4
 800f8ba:	2b00      	cmp	r3, #0
 800f8bc:	d004      	beq.n	800f8c8 <_nx_tcp_socket_state_syn_sent+0xa6>
        {

            /* Set the initial congestion control window size to be the mss. */
            socket_ptr -> nx_tcp_socket_tx_window_congestion = socket_ptr -> nx_tcp_socket_connect_mss;
 800f8be:	68fb      	ldr	r3, [r7, #12]
 800f8c0:	6a1a      	ldr	r2, [r3, #32]
 800f8c2:	68fb      	ldr	r3, [r7, #12]
 800f8c4:	659a      	str	r2, [r3, #88]	; 0x58
 800f8c6:	e01d      	b.n	800f904 <_nx_tcp_socket_state_syn_sent+0xe2>
        }
        else
        {
            socket_ptr -> nx_tcp_socket_tx_window_congestion = (socket_ptr -> nx_tcp_socket_connect_mss << 2);
 800f8c8:	68fb      	ldr	r3, [r7, #12]
 800f8ca:	6a1b      	ldr	r3, [r3, #32]
 800f8cc:	009a      	lsls	r2, r3, #2
 800f8ce:	68fb      	ldr	r3, [r7, #12]
 800f8d0:	659a      	str	r2, [r3, #88]	; 0x58
            if (socket_ptr -> nx_tcp_socket_connect_mss > 1095)
 800f8d2:	68fb      	ldr	r3, [r7, #12]
 800f8d4:	6a1b      	ldr	r3, [r3, #32]
 800f8d6:	f5b3 6f89 	cmp.w	r3, #1096	; 0x448
 800f8da:	d306      	bcc.n	800f8ea <_nx_tcp_socket_state_syn_sent+0xc8>
            {
                socket_ptr -> nx_tcp_socket_tx_window_congestion -= socket_ptr -> nx_tcp_socket_connect_mss;
 800f8dc:	68fb      	ldr	r3, [r7, #12]
 800f8de:	6d9a      	ldr	r2, [r3, #88]	; 0x58
 800f8e0:	68fb      	ldr	r3, [r7, #12]
 800f8e2:	6a1b      	ldr	r3, [r3, #32]
 800f8e4:	1ad2      	subs	r2, r2, r3
 800f8e6:	68fb      	ldr	r3, [r7, #12]
 800f8e8:	659a      	str	r2, [r3, #88]	; 0x58
            }
            if (socket_ptr -> nx_tcp_socket_connect_mss > 2190)
 800f8ea:	68fb      	ldr	r3, [r7, #12]
 800f8ec:	6a1b      	ldr	r3, [r3, #32]
 800f8ee:	f640 028e 	movw	r2, #2190	; 0x88e
 800f8f2:	4293      	cmp	r3, r2
 800f8f4:	d906      	bls.n	800f904 <_nx_tcp_socket_state_syn_sent+0xe2>
            {
                socket_ptr -> nx_tcp_socket_tx_window_congestion -= socket_ptr -> nx_tcp_socket_connect_mss;
 800f8f6:	68fb      	ldr	r3, [r7, #12]
 800f8f8:	6d9a      	ldr	r2, [r3, #88]	; 0x58
 800f8fa:	68fb      	ldr	r3, [r7, #12]
 800f8fc:	6a1b      	ldr	r3, [r3, #32]
 800f8fe:	1ad2      	subs	r2, r2, r3
 800f900:	68fb      	ldr	r3, [r7, #12]
 800f902:	659a      	str	r2, [r3, #88]	; 0x58
            }
        }

        /* Send the ACK.  */
        _nx_tcp_packet_send_ack(socket_ptr, socket_ptr -> nx_tcp_socket_tx_sequence);
 800f904:	68fb      	ldr	r3, [r7, #12]
 800f906:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 800f908:	4619      	mov	r1, r3
 800f90a:	68f8      	ldr	r0, [r7, #12]
 800f90c:	f7fe f810 	bl	800d930 <_nx_tcp_packet_send_ack>

        /* If trace is enabled, insert this event into the trace buffer.  */
        NX_TRACE_IN_LINE_INSERT(NX_TRACE_INTERNAL_TCP_STATE_CHANGE, socket_ptr -> nx_tcp_socket_ip_ptr, socket_ptr, socket_ptr -> nx_tcp_socket_state, NX_TCP_ESTABLISHED, NX_TRACE_INTERNAL_EVENTS, 0, 0);

        /* Move to the ESTABLISHED state.  */
        socket_ptr -> nx_tcp_socket_state =  NX_TCP_ESTABLISHED;
 800f910:	68fb      	ldr	r3, [r7, #12]
 800f912:	2205      	movs	r2, #5
 800f914:	639a      	str	r2, [r3, #56]	; 0x38

        /* Clear the socket timeout.  */
        socket_ptr -> nx_tcp_socket_timeout =  0;
 800f916:	68fb      	ldr	r3, [r7, #12]
 800f918:	2200      	movs	r2, #0
 800f91a:	f8c3 20cc 	str.w	r2, [r3, #204]	; 0xcc
            socket_ptr -> nx_tcp_socket_keepalive_retries =  0;
        }
#endif

        /* Determine if we need to wake a thread suspended on the connection.  */
        if (socket_ptr -> nx_tcp_socket_connect_suspended_thread)
 800f91e:	68fb      	ldr	r3, [r7, #12]
 800f920:	f8d3 30fc 	ldr.w	r3, [r3, #252]	; 0xfc
 800f924:	2b00      	cmp	r3, #0
 800f926:	d062      	beq.n	800f9ee <_nx_tcp_socket_state_syn_sent+0x1cc>
        {

            /* Resume the suspended thread.  */
            _nx_tcp_socket_thread_resume(&(socket_ptr -> nx_tcp_socket_connect_suspended_thread), NX_SUCCESS);
 800f928:	68fb      	ldr	r3, [r7, #12]
 800f92a:	33fc      	adds	r3, #252	; 0xfc
 800f92c:	2100      	movs	r1, #0
 800f92e:	4618      	mov	r0, r3
 800f930:	f000 f8c0 	bl	800fab4 <_nx_tcp_socket_thread_resume>
        if (socket_ptr -> nx_tcp_socket_connect_suspended_thread)
 800f934:	e05b      	b.n	800f9ee <_nx_tcp_socket_state_syn_sent+0x1cc>
        }
    }
    else if ((tcp_header_ptr -> nx_tcp_header_word_3 & NX_TCP_SYN_BIT) &&
 800f936:	68bb      	ldr	r3, [r7, #8]
 800f938:	68db      	ldr	r3, [r3, #12]
 800f93a:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
 800f93e:	2b00      	cmp	r3, #0
 800f940:	d043      	beq.n	800f9ca <_nx_tcp_socket_state_syn_sent+0x1a8>
             (!(tcp_header_ptr -> nx_tcp_header_word_3 & NX_TCP_ACK_BIT)))
 800f942:	68bb      	ldr	r3, [r7, #8]
 800f944:	68db      	ldr	r3, [r3, #12]
 800f946:	f403 1380 	and.w	r3, r3, #1048576	; 0x100000
    else if ((tcp_header_ptr -> nx_tcp_header_word_3 & NX_TCP_SYN_BIT) &&
 800f94a:	2b00      	cmp	r3, #0
 800f94c:	d13d      	bne.n	800f9ca <_nx_tcp_socket_state_syn_sent+0x1a8>

        /* Simultaneous Connection Synchronization,
           A SYN message was received.  We need to send both a SYN and ACK and move to the SYN RECEIVED state.  */

        /* Save the sequence number.  */
        socket_ptr -> nx_tcp_socket_rx_sequence =   tcp_header_ptr -> nx_tcp_sequence_number + 1;
 800f94e:	68bb      	ldr	r3, [r7, #8]
 800f950:	685b      	ldr	r3, [r3, #4]
 800f952:	1c5a      	adds	r2, r3, #1
 800f954:	68fb      	ldr	r3, [r7, #12]
 800f956:	641a      	str	r2, [r3, #64]	; 0x40

        /* Save the window size.  */
        socket_ptr -> nx_tcp_socket_tx_window_advertised = tcp_header_ptr -> nx_tcp_header_word_3 & NX_LOWER_16_MASK;
 800f958:	68bb      	ldr	r3, [r7, #8]
 800f95a:	68db      	ldr	r3, [r3, #12]
 800f95c:	b29a      	uxth	r2, r3
 800f95e:	68fb      	ldr	r3, [r7, #12]
 800f960:	655a      	str	r2, [r3, #84]	; 0x54
#ifdef NX_ENABLE_TCP_WINDOW_SCALING
        socket_ptr -> nx_tcp_socket_tx_window_advertised <<= socket_ptr -> nx_tcp_rcv_win_scale_value;
#endif /* NX_ENABLE_TCP_WINDOW_SCALING  */

        /* Initialize the slow start threshold to be the advertised window size. */
        socket_ptr -> nx_tcp_socket_tx_slow_start_threshold = socket_ptr -> nx_tcp_socket_tx_window_advertised;
 800f962:	68fb      	ldr	r3, [r7, #12]
 800f964:	6d5a      	ldr	r2, [r3, #84]	; 0x54
 800f966:	68fb      	ldr	r3, [r7, #12]
 800f968:	635a      	str	r2, [r3, #52]	; 0x34

        /* Set the initial congestion control window size. */
        /* Section 3.1, Page 5, RFC5681. */
        socket_ptr -> nx_tcp_socket_tx_window_congestion = (socket_ptr -> nx_tcp_socket_connect_mss << 2);
 800f96a:	68fb      	ldr	r3, [r7, #12]
 800f96c:	6a1b      	ldr	r3, [r3, #32]
 800f96e:	009a      	lsls	r2, r3, #2
 800f970:	68fb      	ldr	r3, [r7, #12]
 800f972:	659a      	str	r2, [r3, #88]	; 0x58
        if (socket_ptr -> nx_tcp_socket_connect_mss > 1095)
 800f974:	68fb      	ldr	r3, [r7, #12]
 800f976:	6a1b      	ldr	r3, [r3, #32]
 800f978:	f5b3 6f89 	cmp.w	r3, #1096	; 0x448
 800f97c:	d306      	bcc.n	800f98c <_nx_tcp_socket_state_syn_sent+0x16a>
        {
            socket_ptr -> nx_tcp_socket_tx_window_congestion -= socket_ptr -> nx_tcp_socket_connect_mss;
 800f97e:	68fb      	ldr	r3, [r7, #12]
 800f980:	6d9a      	ldr	r2, [r3, #88]	; 0x58
 800f982:	68fb      	ldr	r3, [r7, #12]
 800f984:	6a1b      	ldr	r3, [r3, #32]
 800f986:	1ad2      	subs	r2, r2, r3
 800f988:	68fb      	ldr	r3, [r7, #12]
 800f98a:	659a      	str	r2, [r3, #88]	; 0x58
        }
        if (socket_ptr -> nx_tcp_socket_connect_mss > 2190)
 800f98c:	68fb      	ldr	r3, [r7, #12]
 800f98e:	6a1b      	ldr	r3, [r3, #32]
 800f990:	f640 028e 	movw	r2, #2190	; 0x88e
 800f994:	4293      	cmp	r3, r2
 800f996:	d906      	bls.n	800f9a6 <_nx_tcp_socket_state_syn_sent+0x184>
        {
            socket_ptr -> nx_tcp_socket_tx_window_congestion -= socket_ptr -> nx_tcp_socket_connect_mss;
 800f998:	68fb      	ldr	r3, [r7, #12]
 800f99a:	6d9a      	ldr	r2, [r3, #88]	; 0x58
 800f99c:	68fb      	ldr	r3, [r7, #12]
 800f99e:	6a1b      	ldr	r3, [r3, #32]
 800f9a0:	1ad2      	subs	r2, r2, r3
 800f9a2:	68fb      	ldr	r3, [r7, #12]
 800f9a4:	659a      	str	r2, [r3, #88]	; 0x58
        }

        /* Set the Initial transmit outstanding byte count. */
        socket_ptr -> nx_tcp_socket_tx_outstanding_bytes = 0;
 800f9a6:	68fb      	ldr	r3, [r7, #12]
 800f9a8:	2200      	movs	r2, #0
 800f9aa:	65da      	str	r2, [r3, #92]	; 0x5c

        /* If trace is enabled, insert this event into the trace buffer.  */
        NX_TRACE_IN_LINE_INSERT(NX_TRACE_INTERNAL_TCP_STATE_CHANGE, socket_ptr -> nx_tcp_socket_ip_ptr, socket_ptr, socket_ptr -> nx_tcp_socket_state, NX_TCP_SYN_RECEIVED, NX_TRACE_INTERNAL_EVENTS, 0, 0);

        /* Move to the SYN RECEIVED state.  */
        socket_ptr -> nx_tcp_socket_state =  NX_TCP_SYN_RECEIVED;
 800f9ac:	68fb      	ldr	r3, [r7, #12]
 800f9ae:	2204      	movs	r2, #4
 800f9b0:	639a      	str	r2, [r3, #56]	; 0x38

        /* Clear the timeout.  */
        socket_ptr -> nx_tcp_socket_timeout =  0;
 800f9b2:	68fb      	ldr	r3, [r7, #12]
 800f9b4:	2200      	movs	r2, #0
 800f9b6:	f8c3 20cc 	str.w	r2, [r3, #204]	; 0xcc

        /* Send the SYN packet.  */
        _nx_tcp_packet_send_syn(socket_ptr, (socket_ptr -> nx_tcp_socket_tx_sequence - 1));
 800f9ba:	68fb      	ldr	r3, [r7, #12]
 800f9bc:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 800f9be:	3b01      	subs	r3, #1
 800f9c0:	4619      	mov	r1, r3
 800f9c2:	68f8      	ldr	r0, [r7, #12]
 800f9c4:	f7fe f944 	bl	800dc50 <_nx_tcp_packet_send_syn>
 800f9c8:	e011      	b.n	800f9ee <_nx_tcp_socket_state_syn_sent+0x1cc>
    }
    /* Check for an invalid response to an attempted connection.  */
    else if ((tcp_header_ptr -> nx_tcp_header_word_3 & NX_TCP_ACK_BIT) &&
 800f9ca:	68bb      	ldr	r3, [r7, #8]
 800f9cc:	68db      	ldr	r3, [r3, #12]
 800f9ce:	f403 1380 	and.w	r3, r3, #1048576	; 0x100000
 800f9d2:	2b00      	cmp	r3, #0
 800f9d4:	d00b      	beq.n	800f9ee <_nx_tcp_socket_state_syn_sent+0x1cc>
             (tcp_header_ptr -> nx_tcp_acknowledgment_number != socket_ptr -> nx_tcp_socket_tx_sequence))
 800f9d6:	68bb      	ldr	r3, [r7, #8]
 800f9d8:	689a      	ldr	r2, [r3, #8]
 800f9da:	68fb      	ldr	r3, [r7, #12]
 800f9dc:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
    else if ((tcp_header_ptr -> nx_tcp_header_word_3 & NX_TCP_ACK_BIT) &&
 800f9de:	429a      	cmp	r2, r3
 800f9e0:	d005      	beq.n	800f9ee <_nx_tcp_socket_state_syn_sent+0x1cc>
        /* Invalid response was received, it is likely that the other side still
           thinks a previous connection is active.  Send a reset (RST) message to
           the other side to clear any previous connection.  */

        /* Send the RST packet.  */
        _nx_tcp_packet_send_rst(socket_ptr, tcp_header_ptr);
 800f9e2:	68b9      	ldr	r1, [r7, #8]
 800f9e4:	68f8      	ldr	r0, [r7, #12]
 800f9e6:	f7fe f8ff 	bl	800dbe8 <_nx_tcp_packet_send_rst>
 800f9ea:	e000      	b.n	800f9ee <_nx_tcp_socket_state_syn_sent+0x1cc>
        return;
 800f9ec:	bf00      	nop
    }
}
 800f9ee:	3710      	adds	r7, #16
 800f9f0:	46bd      	mov	sp, r7
 800f9f2:	bd80      	pop	{r7, pc}

0800f9f4 <_nx_tcp_socket_state_transmit_check>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
VOID  _nx_tcp_socket_state_transmit_check(NX_TCP_SOCKET *socket_ptr)
{
 800f9f4:	b580      	push	{r7, lr}
 800f9f6:	b084      	sub	sp, #16
 800f9f8:	af00      	add	r7, sp, #0
 800f9fa:	6078      	str	r0, [r7, #4]

ULONG tx_window_current;

    /* Now check to see if there is a thread suspended attempting to transmit.  */
    if (socket_ptr -> nx_tcp_socket_transmit_suspension_list)
 800f9fc:	687b      	ldr	r3, [r7, #4]
 800f9fe:	f8d3 30f4 	ldr.w	r3, [r3, #244]	; 0xf4
 800fa02:	2b00      	cmp	r3, #0
 800fa04:	d051      	beq.n	800faaa <_nx_tcp_socket_state_transmit_check+0xb6>
        /* Yes, a thread is suspended attempting to transmit when the transmit window
           is lower than its request size.  Determine if the current transmit window
           size can now accommodate the request.  */

        /* Pick up the min(cwnd, swnd) */
        if (socket_ptr -> nx_tcp_socket_tx_window_advertised > socket_ptr -> nx_tcp_socket_tx_window_congestion)
 800fa06:	687b      	ldr	r3, [r7, #4]
 800fa08:	6d5a      	ldr	r2, [r3, #84]	; 0x54
 800fa0a:	687b      	ldr	r3, [r7, #4]
 800fa0c:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 800fa0e:	429a      	cmp	r2, r3
 800fa10:	d919      	bls.n	800fa46 <_nx_tcp_socket_state_transmit_check+0x52>
        {
            tx_window_current = socket_ptr -> nx_tcp_socket_tx_window_congestion;
 800fa12:	687b      	ldr	r3, [r7, #4]
 800fa14:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 800fa16:	60fb      	str	r3, [r7, #12]

            /* On the first and second duplicate ACKs received, the total FlightSize would
               remain less than or equal to cwnd plus 2*SMSS.
               Section 3.2, Page 9, RFC5681. */
            if ((socket_ptr -> nx_tcp_socket_duplicated_ack_received == 1) ||
 800fa18:	687b      	ldr	r3, [r7, #4]
 800fa1a:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 800fa1c:	2b01      	cmp	r3, #1
 800fa1e:	d003      	beq.n	800fa28 <_nx_tcp_socket_state_transmit_check+0x34>
                (socket_ptr -> nx_tcp_socket_duplicated_ack_received == 2))
 800fa20:	687b      	ldr	r3, [r7, #4]
 800fa22:	6edb      	ldr	r3, [r3, #108]	; 0x6c
            if ((socket_ptr -> nx_tcp_socket_duplicated_ack_received == 1) ||
 800fa24:	2b02      	cmp	r3, #2
 800fa26:	d105      	bne.n	800fa34 <_nx_tcp_socket_state_transmit_check+0x40>
            {
                tx_window_current += (socket_ptr -> nx_tcp_socket_connect_mss << 1);
 800fa28:	687b      	ldr	r3, [r7, #4]
 800fa2a:	6a1b      	ldr	r3, [r3, #32]
 800fa2c:	005b      	lsls	r3, r3, #1
 800fa2e:	68fa      	ldr	r2, [r7, #12]
 800fa30:	4413      	add	r3, r2
 800fa32:	60fb      	str	r3, [r7, #12]
            }

            /* Make sure the tx_window_current is less or equal to swnd. */
            if (tx_window_current > socket_ptr -> nx_tcp_socket_tx_window_advertised)
 800fa34:	687b      	ldr	r3, [r7, #4]
 800fa36:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 800fa38:	68fa      	ldr	r2, [r7, #12]
 800fa3a:	429a      	cmp	r2, r3
 800fa3c:	d906      	bls.n	800fa4c <_nx_tcp_socket_state_transmit_check+0x58>
            {
                tx_window_current = socket_ptr -> nx_tcp_socket_tx_window_advertised;
 800fa3e:	687b      	ldr	r3, [r7, #4]
 800fa40:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 800fa42:	60fb      	str	r3, [r7, #12]
 800fa44:	e002      	b.n	800fa4c <_nx_tcp_socket_state_transmit_check+0x58>
            }
        }
        else
        {
            tx_window_current = socket_ptr -> nx_tcp_socket_tx_window_advertised;
 800fa46:	687b      	ldr	r3, [r7, #4]
 800fa48:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 800fa4a:	60fb      	str	r3, [r7, #12]
        }

        /* Substract any data transmitted but unacked (outstanding bytes) */
        if (tx_window_current > socket_ptr -> nx_tcp_socket_tx_outstanding_bytes)
 800fa4c:	687b      	ldr	r3, [r7, #4]
 800fa4e:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
 800fa50:	68fa      	ldr	r2, [r7, #12]
 800fa52:	429a      	cmp	r2, r3
 800fa54:	d905      	bls.n	800fa62 <_nx_tcp_socket_state_transmit_check+0x6e>
        {
            tx_window_current -= socket_ptr -> nx_tcp_socket_tx_outstanding_bytes;
 800fa56:	687b      	ldr	r3, [r7, #4]
 800fa58:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
 800fa5a:	68fa      	ldr	r2, [r7, #12]
 800fa5c:	1ad3      	subs	r3, r2, r3
 800fa5e:	60fb      	str	r3, [r7, #12]
 800fa60:	e001      	b.n	800fa66 <_nx_tcp_socket_state_transmit_check+0x72>
        }
        else    /* Set tx_window_current to zero. */
        {
            tx_window_current = 0;
 800fa62:	2300      	movs	r3, #0
 800fa64:	60fb      	str	r3, [r7, #12]
        }


        /* Determine if the current transmit window (received from the connected socket)
           is large enough to handle the transmit.  */
        if ((tx_window_current) &&
 800fa66:	68fb      	ldr	r3, [r7, #12]
 800fa68:	2b00      	cmp	r3, #0
 800fa6a:	d01e      	beq.n	800faaa <_nx_tcp_socket_state_transmit_check+0xb6>
            (socket_ptr -> nx_tcp_socket_transmit_sent_count < socket_ptr -> nx_tcp_socket_transmit_queue_maximum))
 800fa6c:	687b      	ldr	r3, [r7, #4]
 800fa6e:	f8d3 20c0 	ldr.w	r2, [r3, #192]	; 0xc0
 800fa72:	687b      	ldr	r3, [r7, #4]
 800fa74:	f8d3 30bc 	ldr.w	r3, [r3, #188]	; 0xbc
        if ((tx_window_current) &&
 800fa78:	429a      	cmp	r2, r3
 800fa7a:	d216      	bcs.n	800faaa <_nx_tcp_socket_state_transmit_check+0xb6>
        {

            /* Is NetX set up with a windows update callback? */
            if (socket_ptr -> nx_tcp_socket_window_update_notify)
 800fa7c:	687b      	ldr	r3, [r7, #4]
 800fa7e:	f8d3 3120 	ldr.w	r3, [r3, #288]	; 0x120
 800fa82:	2b00      	cmp	r3, #0
 800fa84:	d004      	beq.n	800fa90 <_nx_tcp_socket_state_transmit_check+0x9c>
            {

                /* Yes; Call this function when there is a change in transmit windows size. */
                (socket_ptr -> nx_tcp_socket_window_update_notify)(socket_ptr);
 800fa86:	687b      	ldr	r3, [r7, #4]
 800fa88:	f8d3 3120 	ldr.w	r3, [r3, #288]	; 0x120
 800fa8c:	6878      	ldr	r0, [r7, #4]
 800fa8e:	4798      	blx	r3
            }


            /* Decrement the suspension count.  */
            socket_ptr -> nx_tcp_socket_transmit_suspended_count--;
 800fa90:	687b      	ldr	r3, [r7, #4]
 800fa92:	f8d3 30f8 	ldr.w	r3, [r3, #248]	; 0xf8
 800fa96:	1e5a      	subs	r2, r3, #1
 800fa98:	687b      	ldr	r3, [r7, #4]
 800fa9a:	f8c3 20f8 	str.w	r2, [r3, #248]	; 0xf8

            /* Remove the suspended thread from the list.  */
            _nx_tcp_socket_thread_resume(&(socket_ptr -> nx_tcp_socket_transmit_suspension_list), NX_SUCCESS);
 800fa9e:	687b      	ldr	r3, [r7, #4]
 800faa0:	33f4      	adds	r3, #244	; 0xf4
 800faa2:	2100      	movs	r1, #0
 800faa4:	4618      	mov	r0, r3
 800faa6:	f000 f805 	bl	800fab4 <_nx_tcp_socket_thread_resume>
        }
    }
}
 800faaa:	bf00      	nop
 800faac:	3710      	adds	r7, #16
 800faae:	46bd      	mov	sp, r7
 800fab0:	bd80      	pop	{r7, pc}
	...

0800fab4 <_nx_tcp_socket_thread_resume>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
VOID  _nx_tcp_socket_thread_resume(TX_THREAD **suspension_list_head, UINT status)
{
 800fab4:	b580      	push	{r7, lr}
 800fab6:	b088      	sub	sp, #32
 800fab8:	af00      	add	r7, sp, #0
 800faba:	6078      	str	r0, [r7, #4]
 800fabc:	6039      	str	r1, [r7, #0]
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 800fabe:	f3ef 8310 	mrs	r3, PRIMASK
 800fac2:	617b      	str	r3, [r7, #20]
    return(posture);
 800fac4:	697b      	ldr	r3, [r7, #20]
    int_posture = __get_interrupt_posture();
 800fac6:	613b      	str	r3, [r7, #16]
    __asm__ volatile ("CPSID i" : : : "memory");
 800fac8:	b672      	cpsid	i
    return(int_posture);
 800faca:	693b      	ldr	r3, [r7, #16]

TX_THREAD *thread_ptr;


    /* Disable interrupts.  */
    TX_DISABLE
 800facc:	61fb      	str	r3, [r7, #28]

    /* Pickup the thread pointer.  */
    thread_ptr =  *suspension_list_head;
 800face:	687b      	ldr	r3, [r7, #4]
 800fad0:	681b      	ldr	r3, [r3, #0]
 800fad2:	61bb      	str	r3, [r7, #24]

    /* Determine if there still is a thread suspended.  */
    if (thread_ptr)
 800fad4:	69bb      	ldr	r3, [r7, #24]
 800fad6:	2b00      	cmp	r3, #0
 800fad8:	d02c      	beq.n	800fb34 <_nx_tcp_socket_thread_resume+0x80>
    {

        /* Determine if there are anymore threads on the suspension list.  */
        if (thread_ptr == thread_ptr -> tx_thread_suspended_next)
 800fada:	69bb      	ldr	r3, [r7, #24]
 800fadc:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 800fade:	69ba      	ldr	r2, [r7, #24]
 800fae0:	429a      	cmp	r2, r3
 800fae2:	d103      	bne.n	800faec <_nx_tcp_socket_thread_resume+0x38>
        {

            /* Only this thread is on the suspension list.  Simply set the
               list head to NULL to reflect an empty suspension list.  */
            *suspension_list_head =  TX_NULL;
 800fae4:	687b      	ldr	r3, [r7, #4]
 800fae6:	2200      	movs	r2, #0
 800fae8:	601a      	str	r2, [r3, #0]
 800faea:	e00d      	b.n	800fb08 <_nx_tcp_socket_thread_resume+0x54>
        {

            /* More than one thread is on the suspension list, we need to
               adjust the link pointers and move the next entry to the
               front of the list.  */
            *suspension_list_head =  thread_ptr -> tx_thread_suspended_next;
 800faec:	69bb      	ldr	r3, [r7, #24]
 800faee:	6f1a      	ldr	r2, [r3, #112]	; 0x70
 800faf0:	687b      	ldr	r3, [r7, #4]
 800faf2:	601a      	str	r2, [r3, #0]

            /* Update the links of the adjacent threads.  */
            (thread_ptr -> tx_thread_suspended_next) -> tx_thread_suspended_previous =
 800faf4:	69bb      	ldr	r3, [r7, #24]
 800faf6:	6f1b      	ldr	r3, [r3, #112]	; 0x70
                thread_ptr -> tx_thread_suspended_previous;
 800faf8:	69ba      	ldr	r2, [r7, #24]
 800fafa:	6f52      	ldr	r2, [r2, #116]	; 0x74
            (thread_ptr -> tx_thread_suspended_next) -> tx_thread_suspended_previous =
 800fafc:	675a      	str	r2, [r3, #116]	; 0x74
            (thread_ptr -> tx_thread_suspended_previous) -> tx_thread_suspended_next =
 800fafe:	69bb      	ldr	r3, [r7, #24]
 800fb00:	6f5b      	ldr	r3, [r3, #116]	; 0x74
                thread_ptr -> tx_thread_suspended_next;
 800fb02:	69ba      	ldr	r2, [r7, #24]
 800fb04:	6f12      	ldr	r2, [r2, #112]	; 0x70
            (thread_ptr -> tx_thread_suspended_previous) -> tx_thread_suspended_next =
 800fb06:	671a      	str	r2, [r3, #112]	; 0x70
        }

        /* Prepare for resumption of the thread.  */

        /* Clear cleanup routine to avoid timeout.  */
        thread_ptr -> tx_thread_suspend_cleanup =  TX_NULL;
 800fb08:	69bb      	ldr	r3, [r7, #24]
 800fb0a:	2200      	movs	r2, #0
 800fb0c:	669a      	str	r2, [r3, #104]	; 0x68

        /* Temporarily disable preemption.  */
        _tx_thread_preempt_disable++;
 800fb0e:	4b0e      	ldr	r3, [pc, #56]	; (800fb48 <_nx_tcp_socket_thread_resume+0x94>)
 800fb10:	681b      	ldr	r3, [r3, #0]
 800fb12:	3301      	adds	r3, #1
 800fb14:	4a0c      	ldr	r2, [pc, #48]	; (800fb48 <_nx_tcp_socket_thread_resume+0x94>)
 800fb16:	6013      	str	r3, [r2, #0]
 800fb18:	69fb      	ldr	r3, [r7, #28]
 800fb1a:	60fb      	str	r3, [r7, #12]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 800fb1c:	68fb      	ldr	r3, [r7, #12]
 800fb1e:	f383 8810 	msr	PRIMASK, r3
}
 800fb22:	bf00      	nop

        /* Restore interrupts.  */
        TX_RESTORE

        /* Put return status into the thread control block.  */
        thread_ptr -> tx_thread_suspend_status =  status;
 800fb24:	69bb      	ldr	r3, [r7, #24]
 800fb26:	683a      	ldr	r2, [r7, #0]
 800fb28:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84

        /* Resume thread.  */
        _tx_thread_system_resume(thread_ptr);
 800fb2c:	69b8      	ldr	r0, [r7, #24]
 800fb2e:	f005 f8fb 	bl	8014d28 <_tx_thread_system_resume>
    {

        /* Nothing was suspended.  Simply restore interrupts.  */
        TX_RESTORE
    }
}
 800fb32:	e005      	b.n	800fb40 <_nx_tcp_socket_thread_resume+0x8c>
 800fb34:	69fb      	ldr	r3, [r7, #28]
 800fb36:	60bb      	str	r3, [r7, #8]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 800fb38:	68bb      	ldr	r3, [r7, #8]
 800fb3a:	f383 8810 	msr	PRIMASK, r3
}
 800fb3e:	bf00      	nop
 800fb40:	bf00      	nop
 800fb42:	3720      	adds	r7, #32
 800fb44:	46bd      	mov	sp, r7
 800fb46:	bd80      	pop	{r7, pc}
 800fb48:	24031c5c 	.word	0x24031c5c

0800fb4c <_nx_tcp_socket_transmit_queue_flush>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
VOID  _nx_tcp_socket_transmit_queue_flush(NX_TCP_SOCKET *socket_ptr)
{
 800fb4c:	b580      	push	{r7, lr}
 800fb4e:	b08a      	sub	sp, #40	; 0x28
 800fb50:	af00      	add	r7, sp, #0
 800fb52:	6078      	str	r0, [r7, #4]
NX_PACKET *packet_ptr;
NX_PACKET *next_packet_ptr;


    /* Setup packet pointer.  */
    packet_ptr =  socket_ptr -> nx_tcp_socket_transmit_sent_head;
 800fb54:	687b      	ldr	r3, [r7, #4]
 800fb56:	f8d3 30c4 	ldr.w	r3, [r3, #196]	; 0xc4
 800fb5a:	627b      	str	r3, [r7, #36]	; 0x24

    /* Clear the head and the tail pointers.  */
    socket_ptr -> nx_tcp_socket_transmit_sent_head =  NX_NULL;
 800fb5c:	687b      	ldr	r3, [r7, #4]
 800fb5e:	2200      	movs	r2, #0
 800fb60:	f8c3 20c4 	str.w	r2, [r3, #196]	; 0xc4
    socket_ptr -> nx_tcp_socket_transmit_sent_tail =  NX_NULL;
 800fb64:	687b      	ldr	r3, [r7, #4]
 800fb66:	2200      	movs	r2, #0
 800fb68:	f8c3 20c8 	str.w	r2, [r3, #200]	; 0xc8

    /* Loop to clear all the packets out.  */
    while (socket_ptr -> nx_tcp_socket_transmit_sent_count)
 800fb6c:	e02c      	b.n	800fbc8 <_nx_tcp_socket_transmit_queue_flush+0x7c>
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 800fb6e:	f3ef 8310 	mrs	r3, PRIMASK
 800fb72:	61bb      	str	r3, [r7, #24]
    return(posture);
 800fb74:	69bb      	ldr	r3, [r7, #24]
    int_posture = __get_interrupt_posture();
 800fb76:	617b      	str	r3, [r7, #20]
    __asm__ volatile ("CPSID i" : : : "memory");
 800fb78:	b672      	cpsid	i
    return(int_posture);
 800fb7a:	697b      	ldr	r3, [r7, #20]
    {

        /* Disable interrupts.  */
        TX_DISABLE
 800fb7c:	623b      	str	r3, [r7, #32]

        /* Pickup the next queued packet.  */
        next_packet_ptr =  packet_ptr -> nx_packet_union_next.nx_packet_tcp_queue_next;
 800fb7e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800fb80:	6a1b      	ldr	r3, [r3, #32]
 800fb82:	61fb      	str	r3, [r7, #28]

        /* Mark the packet as no longer being in a TCP queue.  */
        /*lint -e{923} suppress cast of ULONG to pointer.  */
        packet_ptr -> nx_packet_union_next.nx_packet_tcp_queue_next =  (NX_PACKET *)NX_PACKET_ALLOCATED;
 800fb84:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800fb86:	f04f 32aa 	mov.w	r2, #2863311530	; 0xaaaaaaaa
 800fb8a:	621a      	str	r2, [r3, #32]

        /* Has the packet been transmitted?  */
        /*lint -e{923} suppress cast of ULONG to pointer.  */
        if (packet_ptr -> nx_packet_queue_next ==  ((NX_PACKET *)NX_DRIVER_TX_DONE))
 800fb8c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800fb8e:	69db      	ldr	r3, [r3, #28]
 800fb90:	f1b3 3fdd 	cmp.w	r3, #3722304989	; 0xdddddddd
 800fb94:	d109      	bne.n	800fbaa <_nx_tcp_socket_transmit_queue_flush+0x5e>
 800fb96:	6a3b      	ldr	r3, [r7, #32]
 800fb98:	613b      	str	r3, [r7, #16]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 800fb9a:	693b      	ldr	r3, [r7, #16]
 800fb9c:	f383 8810 	msr	PRIMASK, r3
}
 800fba0:	bf00      	nop

            /* Restore interrupts.  */
            TX_RESTORE

            /* Release the packet.  */
            _nx_packet_release(packet_ptr);
 800fba2:	6a78      	ldr	r0, [r7, #36]	; 0x24
 800fba4:	f7fc fc30 	bl	800c408 <_nx_packet_release>
 800fba8:	e005      	b.n	800fbb6 <_nx_tcp_socket_transmit_queue_flush+0x6a>
 800fbaa:	6a3b      	ldr	r3, [r7, #32]
 800fbac:	60fb      	str	r3, [r7, #12]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 800fbae:	68fb      	ldr	r3, [r7, #12]
 800fbb0:	f383 8810 	msr	PRIMASK, r3
}
 800fbb4:	bf00      	nop
            /* Just restore interrupts.  */
            TX_RESTORE
        }

        /* Move to the next packet.  */
        packet_ptr =  next_packet_ptr;
 800fbb6:	69fb      	ldr	r3, [r7, #28]
 800fbb8:	627b      	str	r3, [r7, #36]	; 0x24

        /* Decrease the queued packet count.  */
        socket_ptr -> nx_tcp_socket_transmit_sent_count--;
 800fbba:	687b      	ldr	r3, [r7, #4]
 800fbbc:	f8d3 30c0 	ldr.w	r3, [r3, #192]	; 0xc0
 800fbc0:	1e5a      	subs	r2, r3, #1
 800fbc2:	687b      	ldr	r3, [r7, #4]
 800fbc4:	f8c3 20c0 	str.w	r2, [r3, #192]	; 0xc0
    while (socket_ptr -> nx_tcp_socket_transmit_sent_count)
 800fbc8:	687b      	ldr	r3, [r7, #4]
 800fbca:	f8d3 30c0 	ldr.w	r3, [r3, #192]	; 0xc0
 800fbce:	2b00      	cmp	r3, #0
 800fbd0:	d1cd      	bne.n	800fb6e <_nx_tcp_socket_transmit_queue_flush+0x22>
    }
}
 800fbd2:	bf00      	nop
 800fbd4:	bf00      	nop
 800fbd6:	3728      	adds	r7, #40	; 0x28
 800fbd8:	46bd      	mov	sp, r7
 800fbda:	bd80      	pop	{r7, pc}

0800fbdc <_nx_tcp_transmit_cleanup>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
VOID  _nx_tcp_transmit_cleanup(TX_THREAD *thread_ptr NX_CLEANUP_PARAMETER)
{
 800fbdc:	b580      	push	{r7, lr}
 800fbde:	b08e      	sub	sp, #56	; 0x38
 800fbe0:	af00      	add	r7, sp, #0
 800fbe2:	6078      	str	r0, [r7, #4]
 800fbe4:	6039      	str	r1, [r7, #0]
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 800fbe6:	f3ef 8310 	mrs	r3, PRIMASK
 800fbea:	62bb      	str	r3, [r7, #40]	; 0x28
    return(posture);
 800fbec:	6abb      	ldr	r3, [r7, #40]	; 0x28
    int_posture = __get_interrupt_posture();
 800fbee:	627b      	str	r3, [r7, #36]	; 0x24
    __asm__ volatile ("CPSID i" : : : "memory");
 800fbf0:	b672      	cpsid	i
    return(int_posture);
 800fbf2:	6a7b      	ldr	r3, [r7, #36]	; 0x24
NX_IP         *ip_ptr;

    NX_CLEANUP_EXTENSION

    /* Disable interrupts.  */
    TX_DISABLE
 800fbf4:	637b      	str	r3, [r7, #52]	; 0x34

    /* Setup pointer to TCP socket control block.  */
    socket_ptr =  (NX_TCP_SOCKET *)thread_ptr -> tx_thread_suspend_control_block;
 800fbf6:	687b      	ldr	r3, [r7, #4]
 800fbf8:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 800fbfa:	633b      	str	r3, [r7, #48]	; 0x30

    /* Determine if the socket pointer is valid.  */
    if ((!socket_ptr) || (socket_ptr -> nx_tcp_socket_id != NX_TCP_ID))
 800fbfc:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800fbfe:	2b00      	cmp	r3, #0
 800fc00:	d004      	beq.n	800fc0c <_nx_tcp_transmit_cleanup+0x30>
 800fc02:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800fc04:	681b      	ldr	r3, [r3, #0]
 800fc06:	4a49      	ldr	r2, [pc, #292]	; (800fd2c <_nx_tcp_transmit_cleanup+0x150>)
 800fc08:	4293      	cmp	r3, r2
 800fc0a:	d006      	beq.n	800fc1a <_nx_tcp_transmit_cleanup+0x3e>
 800fc0c:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800fc0e:	623b      	str	r3, [r7, #32]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 800fc10:	6a3b      	ldr	r3, [r7, #32]
 800fc12:	f383 8810 	msr	PRIMASK, r3
}
 800fc16:	bf00      	nop
    {

        /* Restore interrupts.  */
        TX_RESTORE

        return;
 800fc18:	e085      	b.n	800fd26 <_nx_tcp_transmit_cleanup+0x14a>
    }

    /* Determine if the cleanup is still required.  */
    if (!(thread_ptr -> tx_thread_suspend_cleanup))
 800fc1a:	687b      	ldr	r3, [r7, #4]
 800fc1c:	6e9b      	ldr	r3, [r3, #104]	; 0x68
 800fc1e:	2b00      	cmp	r3, #0
 800fc20:	d106      	bne.n	800fc30 <_nx_tcp_transmit_cleanup+0x54>
 800fc22:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800fc24:	61fb      	str	r3, [r7, #28]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 800fc26:	69fb      	ldr	r3, [r7, #28]
 800fc28:	f383 8810 	msr	PRIMASK, r3
}
 800fc2c:	bf00      	nop
    {

        /* Restore interrupts.  */
        TX_RESTORE

        return;
 800fc2e:	e07a      	b.n	800fd26 <_nx_tcp_transmit_cleanup+0x14a>
    __asm__ volatile (" MRS  %0,IPSR ": "=r" (ipsr_value) );
 800fc30:	f3ef 8305 	mrs	r3, IPSR
 800fc34:	61bb      	str	r3, [r7, #24]
    return(ipsr_value);
 800fc36:	69ba      	ldr	r2, [r7, #24]
    }

    /* Determine if the caller is an ISR or the system timer thread.  */
#ifndef TX_TIMER_PROCESS_IN_ISR
    if ((TX_THREAD_GET_SYSTEM_STATE()) || (_tx_thread_current_ptr == &_tx_timer_thread))
 800fc38:	4b3d      	ldr	r3, [pc, #244]	; (800fd30 <_nx_tcp_transmit_cleanup+0x154>)
 800fc3a:	681b      	ldr	r3, [r3, #0]
 800fc3c:	4313      	orrs	r3, r2
 800fc3e:	2b00      	cmp	r3, #0
 800fc40:	d104      	bne.n	800fc4c <_nx_tcp_transmit_cleanup+0x70>
 800fc42:	4b3c      	ldr	r3, [pc, #240]	; (800fd34 <_nx_tcp_transmit_cleanup+0x158>)
 800fc44:	681b      	ldr	r3, [r3, #0]
 800fc46:	4a3c      	ldr	r2, [pc, #240]	; (800fd38 <_nx_tcp_transmit_cleanup+0x15c>)
 800fc48:	4293      	cmp	r3, r2
 800fc4a:	d116      	bne.n	800fc7a <_nx_tcp_transmit_cleanup+0x9e>
    {

        /* Yes, defer the processing to the NetX IP thread.  */

        /* Yes, change the suspend cleanup routine to indicate the cleanup is deferred.  */
        thread_ptr -> tx_thread_suspend_cleanup =  _nx_tcp_cleanup_deferred;
 800fc4c:	687b      	ldr	r3, [r7, #4]
 800fc4e:	4a3b      	ldr	r2, [pc, #236]	; (800fd3c <_nx_tcp_transmit_cleanup+0x160>)
 800fc50:	669a      	str	r2, [r3, #104]	; 0x68

        /* Pickup the IP pointer.  */
        ip_ptr =  socket_ptr -> nx_tcp_socket_ip_ptr;
 800fc52:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800fc54:	f8d3 30a0 	ldr.w	r3, [r3, #160]	; 0xa0
 800fc58:	62fb      	str	r3, [r7, #44]	; 0x2c
 800fc5a:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800fc5c:	617b      	str	r3, [r7, #20]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 800fc5e:	697b      	ldr	r3, [r7, #20]
 800fc60:	f383 8810 	msr	PRIMASK, r3
}
 800fc64:	bf00      	nop

        /* Restore interrupts.  */
        TX_RESTORE

        /* Set the deferred cleanup flag for the IP thread.  */
        tx_event_flags_set(&(ip_ptr -> nx_ip_events), NX_IP_TCP_CLEANUP_DEFERRED, TX_OR);
 800fc66:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800fc68:	f503 7313 	add.w	r3, r3, #588	; 0x24c
 800fc6c:	2200      	movs	r2, #0
 800fc6e:	f44f 5180 	mov.w	r1, #4096	; 0x1000
 800fc72:	4618      	mov	r0, r3
 800fc74:	f002 fc3a 	bl	80124ec <_tx_event_flags_set>

        /* Return to caller.  */
        return;
 800fc78:	e055      	b.n	800fd26 <_nx_tcp_transmit_cleanup+0x14a>
    {

        /* Yes, we still have thread suspension!  */

        /* Clear the suspension cleanup flag.  */
        thread_ptr -> tx_thread_suspend_cleanup =  TX_NULL;
 800fc7a:	687b      	ldr	r3, [r7, #4]
 800fc7c:	2200      	movs	r2, #0
 800fc7e:	669a      	str	r2, [r3, #104]	; 0x68

        /* Remove the suspended thread from the list.  */

        /* See if this is the only suspended thread on the list.  */
        if (thread_ptr == thread_ptr -> tx_thread_suspended_next)
 800fc80:	687b      	ldr	r3, [r7, #4]
 800fc82:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 800fc84:	687a      	ldr	r2, [r7, #4]
 800fc86:	429a      	cmp	r2, r3
 800fc88:	d104      	bne.n	800fc94 <_nx_tcp_transmit_cleanup+0xb8>
        {

            /* Yes, the only suspended thread.  */

            /* Update the head pointer.  */
            socket_ptr -> nx_tcp_socket_transmit_suspension_list =  NX_NULL;
 800fc8a:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800fc8c:	2200      	movs	r2, #0
 800fc8e:	f8c3 20f4 	str.w	r2, [r3, #244]	; 0xf4
 800fc92:	e00e      	b.n	800fcb2 <_nx_tcp_transmit_cleanup+0xd6>
        {

            /* At least one more thread is on the same suspension list.  */

            /* Update the list head pointer.  */
            socket_ptr -> nx_tcp_socket_transmit_suspension_list =  thread_ptr -> tx_thread_suspended_next;
 800fc94:	687b      	ldr	r3, [r7, #4]
 800fc96:	6f1a      	ldr	r2, [r3, #112]	; 0x70
 800fc98:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800fc9a:	f8c3 20f4 	str.w	r2, [r3, #244]	; 0xf4

            /* Update the links of the adjacent threads.  */
            (thread_ptr -> tx_thread_suspended_next) -> tx_thread_suspended_previous =
 800fc9e:	687b      	ldr	r3, [r7, #4]
 800fca0:	6f1b      	ldr	r3, [r3, #112]	; 0x70
                thread_ptr -> tx_thread_suspended_previous;
 800fca2:	687a      	ldr	r2, [r7, #4]
 800fca4:	6f52      	ldr	r2, [r2, #116]	; 0x74
            (thread_ptr -> tx_thread_suspended_next) -> tx_thread_suspended_previous =
 800fca6:	675a      	str	r2, [r3, #116]	; 0x74
            (thread_ptr -> tx_thread_suspended_previous) -> tx_thread_suspended_next =
 800fca8:	687b      	ldr	r3, [r7, #4]
 800fcaa:	6f5b      	ldr	r3, [r3, #116]	; 0x74
                thread_ptr -> tx_thread_suspended_next;
 800fcac:	687a      	ldr	r2, [r7, #4]
 800fcae:	6f12      	ldr	r2, [r2, #112]	; 0x70
            (thread_ptr -> tx_thread_suspended_previous) -> tx_thread_suspended_next =
 800fcb0:	671a      	str	r2, [r3, #112]	; 0x70
        }

        /* Decrement the suspension count.  */
        socket_ptr -> nx_tcp_socket_transmit_suspended_count--;
 800fcb2:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800fcb4:	f8d3 30f8 	ldr.w	r3, [r3, #248]	; 0xf8
 800fcb8:	1e5a      	subs	r2, r3, #1
 800fcba:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800fcbc:	f8c3 20f8 	str.w	r2, [r3, #248]	; 0xf8

        /* Now we need to determine if this cleanup is from a terminate, timeout,
           or from a wait abort.  */
        if (thread_ptr -> tx_thread_state == TX_TCP_IP)
 800fcc0:	687b      	ldr	r3, [r7, #4]
 800fcc2:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800fcc4:	2b0c      	cmp	r3, #12
 800fcc6:	d128      	bne.n	800fd1a <_nx_tcp_transmit_cleanup+0x13e>

            /* Thread still suspended on the TCP socket.  Setup return error status and
               resume the thread.  */

            /* Determine which transmit error is present.  */
            if (socket_ptr -> nx_tcp_socket_state != NX_TCP_ESTABLISHED)
 800fcc8:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800fcca:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 800fccc:	2b05      	cmp	r3, #5
 800fcce:	d004      	beq.n	800fcda <_nx_tcp_transmit_cleanup+0xfe>
            {

                /* This socket is no longer connected.  */
                thread_ptr -> tx_thread_suspend_status =  NX_NOT_CONNECTED;
 800fcd0:	687b      	ldr	r3, [r7, #4]
 800fcd2:	2238      	movs	r2, #56	; 0x38
 800fcd4:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84
 800fcd8:	e010      	b.n	800fcfc <_nx_tcp_transmit_cleanup+0x120>
            }
            else if (socket_ptr -> nx_tcp_socket_transmit_sent_count < socket_ptr -> nx_tcp_socket_transmit_queue_maximum)
 800fcda:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800fcdc:	f8d3 20c0 	ldr.w	r2, [r3, #192]	; 0xc0
 800fce0:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800fce2:	f8d3 30bc 	ldr.w	r3, [r3, #188]	; 0xbc
 800fce6:	429a      	cmp	r2, r3
 800fce8:	d204      	bcs.n	800fcf4 <_nx_tcp_transmit_cleanup+0x118>
            {

                /* Not a queue depth problem, return a window overflow error.  */
                thread_ptr -> tx_thread_suspend_status =  NX_WINDOW_OVERFLOW;
 800fcea:	687b      	ldr	r3, [r7, #4]
 800fcec:	2239      	movs	r2, #57	; 0x39
 800fcee:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84
 800fcf2:	e003      	b.n	800fcfc <_nx_tcp_transmit_cleanup+0x120>
            }
            else
            {

                /* Return a transmit queue exceeded error.  */
                thread_ptr -> tx_thread_suspend_status =  NX_TX_QUEUE_DEPTH;
 800fcf4:	687b      	ldr	r3, [r7, #4]
 800fcf6:	2249      	movs	r2, #73	; 0x49
 800fcf8:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84
            }

            /* Temporarily disable preemption.  */
            _tx_thread_preempt_disable++;
 800fcfc:	4b10      	ldr	r3, [pc, #64]	; (800fd40 <_nx_tcp_transmit_cleanup+0x164>)
 800fcfe:	681b      	ldr	r3, [r3, #0]
 800fd00:	3301      	adds	r3, #1
 800fd02:	4a0f      	ldr	r2, [pc, #60]	; (800fd40 <_nx_tcp_transmit_cleanup+0x164>)
 800fd04:	6013      	str	r3, [r2, #0]
 800fd06:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800fd08:	613b      	str	r3, [r7, #16]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 800fd0a:	693b      	ldr	r3, [r7, #16]
 800fd0c:	f383 8810 	msr	PRIMASK, r3
}
 800fd10:	bf00      	nop

            /* Restore interrupts.  */
            TX_RESTORE

            /* Resume the thread!  */
            _tx_thread_system_resume(thread_ptr);
 800fd12:	6878      	ldr	r0, [r7, #4]
 800fd14:	f005 f808 	bl	8014d28 <_tx_thread_system_resume>

            /* Finished, just return.  */
            return;
 800fd18:	e005      	b.n	800fd26 <_nx_tcp_transmit_cleanup+0x14a>
 800fd1a:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800fd1c:	60fb      	str	r3, [r7, #12]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 800fd1e:	68fb      	ldr	r3, [r7, #12]
 800fd20:	f383 8810 	msr	PRIMASK, r3
}
 800fd24:	bf00      	nop
        }
    }

    /* Restore interrupts.  */
    TX_RESTORE
}
 800fd26:	3738      	adds	r7, #56	; 0x38
 800fd28:	46bd      	mov	sp, r7
 800fd2a:	bd80      	pop	{r7, pc}
 800fd2c:	54435020 	.word	0x54435020
 800fd30:	24000078 	.word	0x24000078
 800fd34:	24031bc4 	.word	0x24031bc4
 800fd38:	24031d0c 	.word	0x24031d0c
 800fd3c:	0800c7a9 	.word	0x0800c7a9
 800fd40:	24031c5c 	.word	0x24031c5c

0800fd44 <_nx_udp_bind_cleanup>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
VOID  _nx_udp_bind_cleanup(TX_THREAD *thread_ptr NX_CLEANUP_PARAMETER)
{
 800fd44:	b580      	push	{r7, lr}
 800fd46:	b08a      	sub	sp, #40	; 0x28
 800fd48:	af00      	add	r7, sp, #0
 800fd4a:	6078      	str	r0, [r7, #4]
 800fd4c:	6039      	str	r1, [r7, #0]
NX_UDP_SOCKET *owning_socket_ptr; /* Socket owning the port  */

    NX_CLEANUP_EXTENSION

    /* Setup pointer to UDP socket control block.  */
    socket_ptr =  (NX_UDP_SOCKET *)thread_ptr -> tx_thread_suspend_control_block;
 800fd4e:	687b      	ldr	r3, [r7, #4]
 800fd50:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 800fd52:	627b      	str	r3, [r7, #36]	; 0x24
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 800fd54:	f3ef 8310 	mrs	r3, PRIMASK
 800fd58:	61bb      	str	r3, [r7, #24]
    return(posture);
 800fd5a:	69bb      	ldr	r3, [r7, #24]
    int_posture = __get_interrupt_posture();
 800fd5c:	617b      	str	r3, [r7, #20]
    __asm__ volatile ("CPSID i" : : : "memory");
 800fd5e:	b672      	cpsid	i
    return(int_posture);
 800fd60:	697b      	ldr	r3, [r7, #20]

    /* Disable interrupts to remove the suspended thread from the UDP socket.  */
    TX_DISABLE
 800fd62:	623b      	str	r3, [r7, #32]

    /* Determine if the cleanup is still required.  */
    if ((thread_ptr -> tx_thread_suspend_cleanup) && (socket_ptr) &&
 800fd64:	687b      	ldr	r3, [r7, #4]
 800fd66:	6e9b      	ldr	r3, [r3, #104]	; 0x68
 800fd68:	2b00      	cmp	r3, #0
 800fd6a:	d043      	beq.n	800fdf4 <_nx_udp_bind_cleanup+0xb0>
 800fd6c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800fd6e:	2b00      	cmp	r3, #0
 800fd70:	d040      	beq.n	800fdf4 <_nx_udp_bind_cleanup+0xb0>
        (socket_ptr -> nx_udp_socket_id == NX_UDP_ID))
 800fd72:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800fd74:	681b      	ldr	r3, [r3, #0]
    if ((thread_ptr -> tx_thread_suspend_cleanup) && (socket_ptr) &&
 800fd76:	4a24      	ldr	r2, [pc, #144]	; (800fe08 <_nx_udp_bind_cleanup+0xc4>)
 800fd78:	4293      	cmp	r3, r2
 800fd7a:	d13b      	bne.n	800fdf4 <_nx_udp_bind_cleanup+0xb0>
    {

        /* Yes, we still have thread suspension!  */

        /* Clear the socket bind in progress flag.  */
        socket_ptr -> nx_udp_socket_bind_in_progress =  NX_NULL;
 800fd7c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800fd7e:	2200      	movs	r2, #0
 800fd80:	655a      	str	r2, [r3, #84]	; 0x54

        /* Clear the suspension cleanup flag.  */
        thread_ptr -> tx_thread_suspend_cleanup =  TX_NULL;
 800fd82:	687b      	ldr	r3, [r7, #4]
 800fd84:	2200      	movs	r2, #0
 800fd86:	669a      	str	r2, [r3, #104]	; 0x68

        /* Pickup the socket owning the port. This pointer was
           saved in the bind processing prior to suspension.  */
        owning_socket_ptr =  socket_ptr -> nx_udp_socket_bound_previous;
 800fd88:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800fd8a:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 800fd8c:	61fb      	str	r3, [r7, #28]

        /* Remove the suspended thread from the list.  */

        /* See if this is the only suspended thread on the list.  */
        if (thread_ptr == thread_ptr -> tx_thread_suspended_next)
 800fd8e:	687b      	ldr	r3, [r7, #4]
 800fd90:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 800fd92:	687a      	ldr	r2, [r7, #4]
 800fd94:	429a      	cmp	r2, r3
 800fd96:	d103      	bne.n	800fda0 <_nx_udp_bind_cleanup+0x5c>
        {

            /* Yes, the only suspended thread.  */

            /* Update the head pointer.  */
            owning_socket_ptr -> nx_udp_socket_bind_suspension_list =  NX_NULL;
 800fd98:	69fb      	ldr	r3, [r7, #28]
 800fd9a:	2200      	movs	r2, #0
 800fd9c:	661a      	str	r2, [r3, #96]	; 0x60
 800fd9e:	e00d      	b.n	800fdbc <_nx_udp_bind_cleanup+0x78>
        {

            /* At least one more thread is on the same suspension list.  */

            /* Update the list head pointer.  */
            owning_socket_ptr -> nx_udp_socket_bind_suspension_list =  thread_ptr -> tx_thread_suspended_next;
 800fda0:	687b      	ldr	r3, [r7, #4]
 800fda2:	6f1a      	ldr	r2, [r3, #112]	; 0x70
 800fda4:	69fb      	ldr	r3, [r7, #28]
 800fda6:	661a      	str	r2, [r3, #96]	; 0x60

            /* Update the links of the adjacent threads.  */
            (thread_ptr -> tx_thread_suspended_next) -> tx_thread_suspended_previous =
 800fda8:	687b      	ldr	r3, [r7, #4]
 800fdaa:	6f1b      	ldr	r3, [r3, #112]	; 0x70
                thread_ptr -> tx_thread_suspended_previous;
 800fdac:	687a      	ldr	r2, [r7, #4]
 800fdae:	6f52      	ldr	r2, [r2, #116]	; 0x74
            (thread_ptr -> tx_thread_suspended_next) -> tx_thread_suspended_previous =
 800fdb0:	675a      	str	r2, [r3, #116]	; 0x74
            (thread_ptr -> tx_thread_suspended_previous) -> tx_thread_suspended_next =
 800fdb2:	687b      	ldr	r3, [r7, #4]
 800fdb4:	6f5b      	ldr	r3, [r3, #116]	; 0x74
                thread_ptr -> tx_thread_suspended_next;
 800fdb6:	687a      	ldr	r2, [r7, #4]
 800fdb8:	6f12      	ldr	r2, [r2, #112]	; 0x70
            (thread_ptr -> tx_thread_suspended_previous) -> tx_thread_suspended_next =
 800fdba:	671a      	str	r2, [r3, #112]	; 0x70
        }

        /* Decrement the suspension count.  */
        owning_socket_ptr -> nx_udp_socket_bind_suspended_count--;
 800fdbc:	69fb      	ldr	r3, [r7, #28]
 800fdbe:	6e5b      	ldr	r3, [r3, #100]	; 0x64
 800fdc0:	1e5a      	subs	r2, r3, #1
 800fdc2:	69fb      	ldr	r3, [r7, #28]
 800fdc4:	665a      	str	r2, [r3, #100]	; 0x64

        /* Now we need to determine if this cleanup is from a terminate, timeout,
           or from a wait abort.  */
        if (thread_ptr -> tx_thread_state == TX_TCP_IP)
 800fdc6:	687b      	ldr	r3, [r7, #4]
 800fdc8:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800fdca:	2b0c      	cmp	r3, #12
 800fdcc:	d112      	bne.n	800fdf4 <_nx_udp_bind_cleanup+0xb0>

            /* Thread still suspended on the UDP socket.  Setup return error status and
               resume the thread.  */

            /* Setup return status.  */
            thread_ptr -> tx_thread_suspend_status =  NX_PORT_UNAVAILABLE;
 800fdce:	687b      	ldr	r3, [r7, #4]
 800fdd0:	2223      	movs	r2, #35	; 0x23
 800fdd2:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84

            /* Temporarily disable preemption.  */
            _tx_thread_preempt_disable++;
 800fdd6:	4b0d      	ldr	r3, [pc, #52]	; (800fe0c <_nx_udp_bind_cleanup+0xc8>)
 800fdd8:	681b      	ldr	r3, [r3, #0]
 800fdda:	3301      	adds	r3, #1
 800fddc:	4a0b      	ldr	r2, [pc, #44]	; (800fe0c <_nx_udp_bind_cleanup+0xc8>)
 800fdde:	6013      	str	r3, [r2, #0]
 800fde0:	6a3b      	ldr	r3, [r7, #32]
 800fde2:	613b      	str	r3, [r7, #16]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 800fde4:	693b      	ldr	r3, [r7, #16]
 800fde6:	f383 8810 	msr	PRIMASK, r3
}
 800fdea:	bf00      	nop
            TX_RESTORE

            /* Resume the thread!  Check for preemption even though we are executing
               from the system timer thread right now which normally executes at the
               highest priority.  */
            _tx_thread_system_resume(thread_ptr);
 800fdec:	6878      	ldr	r0, [r7, #4]
 800fdee:	f004 ff9b 	bl	8014d28 <_tx_thread_system_resume>

            /* Finished, just return.  */
            return;
 800fdf2:	e005      	b.n	800fe00 <_nx_udp_bind_cleanup+0xbc>
 800fdf4:	6a3b      	ldr	r3, [r7, #32]
 800fdf6:	60fb      	str	r3, [r7, #12]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 800fdf8:	68fb      	ldr	r3, [r7, #12]
 800fdfa:	f383 8810 	msr	PRIMASK, r3
}
 800fdfe:	bf00      	nop
        }
    }

    /* Restore interrupts.  */
    TX_RESTORE
}
 800fe00:	3728      	adds	r7, #40	; 0x28
 800fe02:	46bd      	mov	sp, r7
 800fe04:	bd80      	pop	{r7, pc}
 800fe06:	bf00      	nop
 800fe08:	55445020 	.word	0x55445020
 800fe0c:	24031c5c 	.word	0x24031c5c

0800fe10 <_nx_udp_enable>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
UINT  _nx_udp_enable(NX_IP *ip_ptr)
{
 800fe10:	b480      	push	{r7}
 800fe12:	b083      	sub	sp, #12
 800fe14:	af00      	add	r7, sp, #0
 800fe16:	6078      	str	r0, [r7, #4]
    /* If trace is enabled, insert this event into the trace buffer.  */
    NX_TRACE_IN_LINE_INSERT(NX_TRACE_UDP_ENABLE, ip_ptr, 0, 0, 0, NX_TRACE_UDP_EVENTS, 0, 0);

    /* Set the UDP packet receive function in the IP structure to indicate
       we are ready to receive UDP packets.  */
    ip_ptr -> nx_ip_udp_packet_receive =  _nx_udp_packet_receive;
 800fe18:	687b      	ldr	r3, [r7, #4]
 800fe1a:	4a05      	ldr	r2, [pc, #20]	; (800fe30 <_nx_udp_enable+0x20>)
 800fe1c:	f8c3 2408 	str.w	r2, [r3, #1032]	; 0x408

    /* Return successful completion.  */
    return(NX_SUCCESS);
 800fe20:	2300      	movs	r3, #0
}
 800fe22:	4618      	mov	r0, r3
 800fe24:	370c      	adds	r7, #12
 800fe26:	46bd      	mov	sp, r7
 800fe28:	f85d 7b04 	ldr.w	r7, [sp], #4
 800fe2c:	4770      	bx	lr
 800fe2e:	bf00      	nop
 800fe30:	0800ff29 	.word	0x0800ff29

0800fe34 <_nx_udp_free_port_find>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
UINT  _nx_udp_free_port_find(NX_IP *ip_ptr, UINT port, UINT *free_port_ptr)
{
 800fe34:	b580      	push	{r7, lr}
 800fe36:	b08a      	sub	sp, #40	; 0x28
 800fe38:	af00      	add	r7, sp, #0
 800fe3a:	60f8      	str	r0, [r7, #12]
 800fe3c:	60b9      	str	r1, [r7, #8]
 800fe3e:	607a      	str	r2, [r7, #4]

    /* If trace is enabled, insert this event into the trace buffer.  */
    NX_TRACE_IN_LINE_INSERT(NX_TRACE_UDP_FREE_PORT_FIND, ip_ptr, port, 0, 0, NX_TRACE_UDP_EVENTS, &trace_event, &trace_timestamp);

    /* Save the original port.  */
    starting_port =  port;
 800fe40:	68bb      	ldr	r3, [r7, #8]
 800fe42:	61fb      	str	r3, [r7, #28]
    /* Loop through the UDP ports until a free entry is found.  */
    do
    {

        /* Calculate the hash index in the UDP port array of the associated IP instance.  */
        index =  (UINT)((port + (port >> 8)) & NX_UDP_PORT_TABLE_MASK);
 800fe44:	68bb      	ldr	r3, [r7, #8]
 800fe46:	0a1a      	lsrs	r2, r3, #8
 800fe48:	68bb      	ldr	r3, [r7, #8]
 800fe4a:	4413      	add	r3, r2
 800fe4c:	f003 031f 	and.w	r3, r3, #31
 800fe50:	61bb      	str	r3, [r7, #24]

        /* Obtain the IP mutex so we can figure out whether or not the port has already
           been bound to.  */
        tx_mutex_get(&(ip_ptr -> nx_ip_protection), TX_WAIT_FOREVER);
 800fe52:	68fb      	ldr	r3, [r7, #12]
 800fe54:	f503 739e 	add.w	r3, r3, #316	; 0x13c
 800fe58:	f04f 31ff 	mov.w	r1, #4294967295
 800fe5c:	4618      	mov	r0, r3
 800fe5e:	f002 ff89 	bl	8012d74 <_tx_mutex_get>

        /* Pickup the head of the UDP ports bound list.  */
        search_ptr =  ip_ptr -> nx_ip_udp_port_table[index];
 800fe62:	68fb      	ldr	r3, [r7, #12]
 800fe64:	69ba      	ldr	r2, [r7, #24]
 800fe66:	32e0      	adds	r2, #224	; 0xe0
 800fe68:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 800fe6c:	623b      	str	r3, [r7, #32]

        /* Set the bound flag to false.  */
        bound =  NX_FALSE;
 800fe6e:	2300      	movs	r3, #0
 800fe70:	627b      	str	r3, [r7, #36]	; 0x24

        /* Determine if we need to perform a list search.  */
        if (search_ptr)
 800fe72:	6a3b      	ldr	r3, [r7, #32]
 800fe74:	2b00      	cmp	r3, #0
 800fe76:	d010      	beq.n	800fe9a <_nx_udp_free_port_find+0x66>
        {

            /* Walk through the circular list of UDP sockets that are already
               bound.  */
            end_ptr =     search_ptr;
 800fe78:	6a3b      	ldr	r3, [r7, #32]
 800fe7a:	617b      	str	r3, [r7, #20]
            do
            {

                /* Determine if this entry is the same as the requested port.  */
                if (search_ptr -> nx_udp_socket_port == port)
 800fe7c:	6a3b      	ldr	r3, [r7, #32]
 800fe7e:	689b      	ldr	r3, [r3, #8]
 800fe80:	68ba      	ldr	r2, [r7, #8]
 800fe82:	429a      	cmp	r2, r3
 800fe84:	d102      	bne.n	800fe8c <_nx_udp_free_port_find+0x58>
                {

                    /* Set the bound flag.  */
                    bound =  NX_TRUE;
 800fe86:	2301      	movs	r3, #1
 800fe88:	627b      	str	r3, [r7, #36]	; 0x24

                    /* Get out of the loop.  */
                    break;
 800fe8a:	e006      	b.n	800fe9a <_nx_udp_free_port_find+0x66>
                }

                /* Move to the next entry in the list.  */
                search_ptr =  search_ptr -> nx_udp_socket_bound_next;
 800fe8c:	6a3b      	ldr	r3, [r7, #32]
 800fe8e:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 800fe90:	623b      	str	r3, [r7, #32]
            } while (search_ptr != end_ptr);
 800fe92:	6a3a      	ldr	r2, [r7, #32]
 800fe94:	697b      	ldr	r3, [r7, #20]
 800fe96:	429a      	cmp	r2, r3
 800fe98:	d1f0      	bne.n	800fe7c <_nx_udp_free_port_find+0x48>
            }
        }
#endif

        /* Release protection.  */
        tx_mutex_put(&(ip_ptr -> nx_ip_protection));
 800fe9a:	68fb      	ldr	r3, [r7, #12]
 800fe9c:	f503 739e 	add.w	r3, r3, #316	; 0x13c
 800fea0:	4618      	mov	r0, r3
 800fea2:	f003 f9df 	bl	8013264 <_tx_mutex_put>

        /* Determine if the port is available.  */
        if (!bound)
 800fea6:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800fea8:	2b00      	cmp	r3, #0
 800feaa:	d104      	bne.n	800feb6 <_nx_udp_free_port_find+0x82>
        {

            /* Setup the return port number.  */
            *free_port_ptr =  port;
 800feac:	687b      	ldr	r3, [r7, #4]
 800feae:	68ba      	ldr	r2, [r7, #8]
 800feb0:	601a      	str	r2, [r3, #0]

            /* Update the trace event with the status.  */
            NX_TRACE_EVENT_UPDATE(trace_event, trace_timestamp, NX_TRACE_UDP_FREE_PORT_FIND, 0, 0, port, 0);

            /* Return success.  */
            return(NX_SUCCESS);
 800feb2:	2300      	movs	r3, #0
 800feb4:	e00e      	b.n	800fed4 <_nx_udp_free_port_find+0xa0>
        }

        /* Move to the next port.  */
        port++;
 800feb6:	68bb      	ldr	r3, [r7, #8]
 800feb8:	3301      	adds	r3, #1
 800feba:	60bb      	str	r3, [r7, #8]

        /* Determine if we need to wrap.  */
        if (port > NX_MAX_PORT)
 800febc:	68bb      	ldr	r3, [r7, #8]
 800febe:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
 800fec2:	d302      	bcc.n	800feca <_nx_udp_free_port_find+0x96>
        {

            /* Yes, we need to wrap around.  */
            port =  NX_SEARCH_PORT_START;
 800fec4:	f44f 4340 	mov.w	r3, #49152	; 0xc000
 800fec8:	60bb      	str	r3, [r7, #8]
        }
    } while (starting_port != port);
 800feca:	69fa      	ldr	r2, [r7, #28]
 800fecc:	68bb      	ldr	r3, [r7, #8]
 800fece:	429a      	cmp	r2, r3
 800fed0:	d1b8      	bne.n	800fe44 <_nx_udp_free_port_find+0x10>

    /* A free port was not found, return an error.  */
    return(NX_NO_FREE_PORTS);
 800fed2:	2345      	movs	r3, #69	; 0x45
}
 800fed4:	4618      	mov	r0, r3
 800fed6:	3728      	adds	r7, #40	; 0x28
 800fed8:	46bd      	mov	sp, r7
 800feda:	bd80      	pop	{r7, pc}

0800fedc <_nx_udp_packet_info_extract>:
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
UINT  _nx_udp_packet_info_extract(NX_PACKET *packet_ptr, ULONG *ip_address,
                                  UINT *protocol, UINT *port, UINT *interface_index)
{
 800fedc:	b580      	push	{r7, lr}
 800fede:	b08a      	sub	sp, #40	; 0x28
 800fee0:	af02      	add	r7, sp, #8
 800fee2:	60f8      	str	r0, [r7, #12]
 800fee4:	60b9      	str	r1, [r7, #8]
 800fee6:	607a      	str	r2, [r7, #4]
 800fee8:	603b      	str	r3, [r7, #0]
NXD_ADDRESS nxd_ip_address;
UINT        status;


    /* Call the NXD version of the service. */
    status = _nxd_udp_packet_info_extract(packet_ptr, &nxd_ip_address, protocol, port, interface_index);
 800feea:	f107 0114 	add.w	r1, r7, #20
 800feee:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800fef0:	9300      	str	r3, [sp, #0]
 800fef2:	683b      	ldr	r3, [r7, #0]
 800fef4:	687a      	ldr	r2, [r7, #4]
 800fef6:	68f8      	ldr	r0, [r7, #12]
 800fef8:	f000 ffb4 	bl	8010e64 <_nxd_udp_packet_info_extract>
 800fefc:	61f8      	str	r0, [r7, #28]

    if (status == NX_SUCCESS)
 800fefe:	69fb      	ldr	r3, [r7, #28]
 800ff00:	2b00      	cmp	r3, #0
 800ff02:	d10b      	bne.n	800ff1c <_nx_udp_packet_info_extract+0x40>
    {
        if (ip_address)
 800ff04:	68bb      	ldr	r3, [r7, #8]
 800ff06:	2b00      	cmp	r3, #0
 800ff08:	d008      	beq.n	800ff1c <_nx_udp_packet_info_extract+0x40>
        {

            /*lint -e{644} suppress variable might not be initialized, since "nxd_ip_address" was initialized in _nxd_udp_packet_info_extract. */
            if (nxd_ip_address.nxd_ip_version == NX_IP_VERSION_V4)
 800ff0a:	697b      	ldr	r3, [r7, #20]
 800ff0c:	2b04      	cmp	r3, #4
 800ff0e:	d103      	bne.n	800ff18 <_nx_udp_packet_info_extract+0x3c>
            {
                *ip_address = nxd_ip_address.nxd_ip_address.v4;
 800ff10:	69ba      	ldr	r2, [r7, #24]
 800ff12:	68bb      	ldr	r3, [r7, #8]
 800ff14:	601a      	str	r2, [r3, #0]
 800ff16:	e001      	b.n	800ff1c <_nx_udp_packet_info_extract+0x40>
            }
            else
            {
                return(NX_INVALID_PACKET);
 800ff18:	2312      	movs	r3, #18
 800ff1a:	e000      	b.n	800ff1e <_nx_udp_packet_info_extract+0x42>
            }
        }
    }

    return(status);
 800ff1c:	69fb      	ldr	r3, [r7, #28]
    NX_PARAMETER_NOT_USED(port);
    NX_PARAMETER_NOT_USED(interface_index);

    return(NX_NOT_SUPPORTED);
#endif /* NX_DISABLE_IPV4 */
}
 800ff1e:	4618      	mov	r0, r3
 800ff20:	3720      	adds	r7, #32
 800ff22:	46bd      	mov	sp, r7
 800ff24:	bd80      	pop	{r7, pc}
	...

0800ff28 <_nx_udp_packet_receive>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
VOID  _nx_udp_packet_receive(NX_IP *ip_ptr, NX_PACKET *packet_ptr)
{
 800ff28:	b580      	push	{r7, lr}
 800ff2a:	b094      	sub	sp, #80	; 0x50
 800ff2c:	af00      	add	r7, sp, #0
 800ff2e:	6078      	str	r0, [r7, #4]
 800ff30:	6039      	str	r1, [r7, #0]
    NX_PACKET_DEBUG(__FILE__, __LINE__, packet_ptr);

#ifndef NX_DISABLE_UDP_INFO

    /* Increment the total UDP receive packets count.  */
    ip_ptr -> nx_ip_udp_packets_received++;
 800ff32:	687b      	ldr	r3, [r7, #4]
 800ff34:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 800ff38:	1c5a      	adds	r2, r3, #1
 800ff3a:	687b      	ldr	r3, [r7, #4]
 800ff3c:	f8c3 2090 	str.w	r2, [r3, #144]	; 0x90
#endif

#ifndef NX_DISABLE_RX_SIZE_CHECKING

    /* Check for valid packet length.  */
    if (packet_ptr -> nx_packet_length < sizeof(NX_UDP_HEADER))
 800ff40:	683b      	ldr	r3, [r7, #0]
 800ff42:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800ff44:	2b07      	cmp	r3, #7
 800ff46:	d80a      	bhi.n	800ff5e <_nx_udp_packet_receive+0x36>
    {

#ifndef NX_DISABLE_UDP_INFO

        /* Increment the UDP invalid packet error.  */
        ip_ptr -> nx_ip_udp_invalid_packets++;
 800ff48:	687b      	ldr	r3, [r7, #4]
 800ff4a:	f8d3 3098 	ldr.w	r3, [r3, #152]	; 0x98
 800ff4e:	1c5a      	adds	r2, r3, #1
 800ff50:	687b      	ldr	r3, [r7, #4]
 800ff52:	f8c3 2098 	str.w	r2, [r3, #152]	; 0x98
#endif

        /* Invalid packet length, just release it.  */
        _nx_packet_release(packet_ptr);
 800ff56:	6838      	ldr	r0, [r7, #0]
 800ff58:	f7fc fa56 	bl	800c408 <_nx_packet_release>

        /* The function is complete, just return!  */
        return;
 800ff5c:	e1d4      	b.n	8010308 <_nx_udp_packet_receive+0x3e0>
    }
#endif

    /* Pickup the pointer to the head of the UDP packet.  */
    /*lint -e{927} -e{826} suppress cast of pointer to pointer, since it is necessary  */
    udp_header_ptr =  (NX_UDP_HEADER *)packet_ptr -> nx_packet_prepend_ptr;
 800ff5e:	683b      	ldr	r3, [r7, #0]
 800ff60:	689b      	ldr	r3, [r3, #8]
 800ff62:	64bb      	str	r3, [r7, #72]	; 0x48

    /* Endian swapping logic.  If NX_LITTLE_ENDIAN is specified, these macros will
       swap the endian of the UDP header.  */
    NX_CHANGE_ULONG_ENDIAN(udp_header_ptr -> nx_udp_header_word_0);
 800ff64:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 800ff66:	681b      	ldr	r3, [r3, #0]
 800ff68:	ba1a      	rev	r2, r3
 800ff6a:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 800ff6c:	601a      	str	r2, [r3, #0]
    NX_CHANGE_ULONG_ENDIAN(udp_header_ptr -> nx_udp_header_word_1);
 800ff6e:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 800ff70:	685b      	ldr	r3, [r3, #4]
 800ff72:	ba1a      	rev	r2, r3
 800ff74:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 800ff76:	605a      	str	r2, [r3, #4]

#ifndef NX_DISABLE_RX_SIZE_CHECKING

    /* Check for valid packet length.  */
    if (packet_ptr -> nx_packet_length < (((udp_header_ptr -> nx_udp_header_word_1) >> NX_SHIFT_BY_16) & NX_LOWER_16_MASK))
 800ff78:	683b      	ldr	r3, [r7, #0]
 800ff7a:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 800ff7c:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 800ff7e:	685b      	ldr	r3, [r3, #4]
 800ff80:	0c1b      	lsrs	r3, r3, #16
 800ff82:	429a      	cmp	r2, r3
 800ff84:	d20a      	bcs.n	800ff9c <_nx_udp_packet_receive+0x74>
    {

#ifndef NX_DISABLE_UDP_INFO

        /* Increment the UDP invalid packet error.  */
        ip_ptr -> nx_ip_udp_invalid_packets++;
 800ff86:	687b      	ldr	r3, [r7, #4]
 800ff88:	f8d3 3098 	ldr.w	r3, [r3, #152]	; 0x98
 800ff8c:	1c5a      	adds	r2, r3, #1
 800ff8e:	687b      	ldr	r3, [r7, #4]
 800ff90:	f8c3 2098 	str.w	r2, [r3, #152]	; 0x98
#endif

        /* Invalid packet length, just release it.  */
        _nx_packet_release(packet_ptr);
 800ff94:	6838      	ldr	r0, [r7, #0]
 800ff96:	f7fc fa37 	bl	800c408 <_nx_packet_release>

        /* The function is complete, just return!  */
        return;
 800ff9a:	e1b5      	b.n	8010308 <_nx_udp_packet_receive+0x3e0>
    /* Recompute the packet length in case TFC padding is present. */
    packet_ptr -> nx_packet_length = (((udp_header_ptr -> nx_udp_header_word_1) >> NX_SHIFT_BY_16) & NX_LOWER_16_MASK);
#endif /* NX_IPSEC_ENABLE */

    /* Pickup the destination UDP port.  */
    port =  (UINT)(udp_header_ptr -> nx_udp_header_word_0 & NX_LOWER_16_MASK);
 800ff9c:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 800ff9e:	681b      	ldr	r3, [r3, #0]
 800ffa0:	b29b      	uxth	r3, r3
 800ffa2:	647b      	str	r3, [r7, #68]	; 0x44

    /* Calculate the hash index in the UDP port array of the associated IP instance.  */
    index =  (UINT)((port + (port >> 8)) & NX_UDP_PORT_TABLE_MASK);
 800ffa4:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 800ffa6:	0a1a      	lsrs	r2, r3, #8
 800ffa8:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 800ffaa:	4413      	add	r3, r2
 800ffac:	f003 031f 	and.w	r3, r3, #31
 800ffb0:	643b      	str	r3, [r7, #64]	; 0x40

    /* Determine if the caller is a thread. If so, we should use the protection mutex
       to avoid having the port list examined while we are traversing it. If this routine
       is called from an ISR nothing needs to be done since bind/unbind are not allowed
       from ISRs.  */
    if ((_tx_thread_current_ptr) && (TX_THREAD_GET_SYSTEM_STATE() == 0))
 800ffb2:	4b8d      	ldr	r3, [pc, #564]	; (80101e8 <_nx_udp_packet_receive+0x2c0>)
 800ffb4:	681b      	ldr	r3, [r3, #0]
 800ffb6:	2b00      	cmp	r3, #0
 800ffb8:	d010      	beq.n	800ffdc <_nx_udp_packet_receive+0xb4>
    __asm__ volatile (" MRS  %0,IPSR ": "=r" (ipsr_value) );
 800ffba:	f3ef 8305 	mrs	r3, IPSR
 800ffbe:	633b      	str	r3, [r7, #48]	; 0x30
    return(ipsr_value);
 800ffc0:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 800ffc2:	4b8a      	ldr	r3, [pc, #552]	; (80101ec <_nx_udp_packet_receive+0x2c4>)
 800ffc4:	681b      	ldr	r3, [r3, #0]
 800ffc6:	4313      	orrs	r3, r2
 800ffc8:	2b00      	cmp	r3, #0
 800ffca:	d107      	bne.n	800ffdc <_nx_udp_packet_receive+0xb4>
    {

        /* Get mutex protection.  */
        tx_mutex_get(&(ip_ptr -> nx_ip_protection), NX_WAIT_FOREVER);
 800ffcc:	687b      	ldr	r3, [r7, #4]
 800ffce:	f503 739e 	add.w	r3, r3, #316	; 0x13c
 800ffd2:	f04f 31ff 	mov.w	r1, #4294967295
 800ffd6:	4618      	mov	r0, r3
 800ffd8:	f002 fecc 	bl	8012d74 <_tx_mutex_get>
    }

    /* Search the bound sockets in this index for the particular port.  */
    socket_ptr =  ip_ptr -> nx_ip_udp_port_table[index];
 800ffdc:	687b      	ldr	r3, [r7, #4]
 800ffde:	6c3a      	ldr	r2, [r7, #64]	; 0x40
 800ffe0:	32e0      	adds	r2, #224	; 0xe0
 800ffe2:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 800ffe6:	64fb      	str	r3, [r7, #76]	; 0x4c

    /* Determine if there are any sockets bound on this port index.  */
    if (!socket_ptr)
 800ffe8:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800ffea:	2b00      	cmp	r3, #0
 800ffec:	d13e      	bne.n	801006c <_nx_udp_packet_receive+0x144>
    {

#ifndef NX_DISABLE_IPV4
#ifndef NX_DISABLE_ICMPV4_ERROR_MESSAGE
        /* If ICMPv4 is enabled, send Destination unreachable. */
        if ((packet_ptr -> nx_packet_ip_version == NX_IP_VERSION_V4) &&
 800ffee:	683b      	ldr	r3, [r7, #0]
 800fff0:	f893 302c 	ldrb.w	r3, [r3, #44]	; 0x2c
 800fff4:	2b04      	cmp	r3, #4
 800fff6:	d114      	bne.n	8010022 <_nx_udp_packet_receive+0xfa>
            (ip_ptr -> nx_ip_icmpv4_packet_process))
 800fff8:	687b      	ldr	r3, [r7, #4]
 800fffa:	f8d3 3370 	ldr.w	r3, [r3, #880]	; 0x370
        if ((packet_ptr -> nx_packet_ip_version == NX_IP_VERSION_V4) &&
 800fffe:	2b00      	cmp	r3, #0
 8010000:	d00f      	beq.n	8010022 <_nx_udp_packet_receive+0xfa>
        {

            /* Restore UDP header. */
            NX_CHANGE_ULONG_ENDIAN(udp_header_ptr -> nx_udp_header_word_0);
 8010002:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 8010004:	681b      	ldr	r3, [r3, #0]
 8010006:	ba1a      	rev	r2, r3
 8010008:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 801000a:	601a      	str	r2, [r3, #0]
            NX_CHANGE_ULONG_ENDIAN(udp_header_ptr -> nx_udp_header_word_1);
 801000c:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 801000e:	685b      	ldr	r3, [r3, #4]
 8010010:	ba1a      	rev	r2, r3
 8010012:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 8010014:	605a      	str	r2, [r3, #4]

            /* Send out ICMP error message if dest is not multicast. */
            NX_ICMPV4_SEND_DEST_UNREACHABLE(ip_ptr, packet_ptr, NX_ICMP_PORT_UNREACH_CODE);
 8010016:	2300      	movs	r3, #0
 8010018:	4a75      	ldr	r2, [pc, #468]	; (80101f0 <_nx_udp_packet_receive+0x2c8>)
 801001a:	6839      	ldr	r1, [r7, #0]
 801001c:	6878      	ldr	r0, [r7, #4]
 801001e:	f7f9 fc4b 	bl	80098b8 <_nx_icmpv4_send_error_message>
#endif /* FEATURE_NX_IPV6 */

#ifndef NX_DISABLE_UDP_INFO

        /* Increment the no port for delivery count.  */
        ip_ptr -> nx_ip_udp_no_port_for_delivery++;
 8010022:	687b      	ldr	r3, [r7, #4]
 8010024:	f8d3 309c 	ldr.w	r3, [r3, #156]	; 0x9c
 8010028:	1c5a      	adds	r2, r3, #1
 801002a:	687b      	ldr	r3, [r7, #4]
 801002c:	f8c3 209c 	str.w	r2, [r3, #156]	; 0x9c

        /* Increment the total UDP receive packets dropped count.  */
        ip_ptr -> nx_ip_udp_receive_packets_dropped++;
 8010030:	687b      	ldr	r3, [r7, #4]
 8010032:	f8d3 30a0 	ldr.w	r3, [r3, #160]	; 0xa0
 8010036:	1c5a      	adds	r2, r3, #1
 8010038:	687b      	ldr	r3, [r7, #4]
 801003a:	f8c3 20a0 	str.w	r2, [r3, #160]	; 0xa0
#endif

        /* Determine if the caller is a thread. If so, release the mutex protection previously setup.  */
        if ((_tx_thread_current_ptr) && (TX_THREAD_GET_SYSTEM_STATE() == 0))
 801003e:	4b6a      	ldr	r3, [pc, #424]	; (80101e8 <_nx_udp_packet_receive+0x2c0>)
 8010040:	681b      	ldr	r3, [r3, #0]
 8010042:	2b00      	cmp	r3, #0
 8010044:	d00e      	beq.n	8010064 <_nx_udp_packet_receive+0x13c>
    __asm__ volatile (" MRS  %0,IPSR ": "=r" (ipsr_value) );
 8010046:	f3ef 8305 	mrs	r3, IPSR
 801004a:	62fb      	str	r3, [r7, #44]	; 0x2c
    return(ipsr_value);
 801004c:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 801004e:	4b67      	ldr	r3, [pc, #412]	; (80101ec <_nx_udp_packet_receive+0x2c4>)
 8010050:	681b      	ldr	r3, [r3, #0]
 8010052:	4313      	orrs	r3, r2
 8010054:	2b00      	cmp	r3, #0
 8010056:	d105      	bne.n	8010064 <_nx_udp_packet_receive+0x13c>
        {

            /* Release mutex protection.  */
            tx_mutex_put(&(ip_ptr -> nx_ip_protection));
 8010058:	687b      	ldr	r3, [r7, #4]
 801005a:	f503 739e 	add.w	r3, r3, #316	; 0x13c
 801005e:	4618      	mov	r0, r3
 8010060:	f003 f900 	bl	8013264 <_tx_mutex_put>
        }

        /* Release the packet.  */
        _nx_packet_release(packet_ptr);
 8010064:	6838      	ldr	r0, [r7, #0]
 8010066:	f7fc f9cf 	bl	800c408 <_nx_packet_release>

        /* Just return.  */
        return;
 801006a:	e14d      	b.n	8010308 <_nx_udp_packet_receive+0x3e0>
    /*  Loop to examine the list of bound ports on this index.  */
    do
    {

        /* Determine if the port has been found.  */
        if (socket_ptr -> nx_udp_socket_port == port)
 801006c:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 801006e:	689b      	ldr	r3, [r3, #8]
 8010070:	6c7a      	ldr	r2, [r7, #68]	; 0x44
 8010072:	429a      	cmp	r2, r3
 8010074:	d119      	bne.n	80100aa <_nx_udp_packet_receive+0x182>
            /* Yes, we have a match.  */

#ifndef NX_DISABLE_UDP_INFO

            /* Increment the total number of packets received for this socket.  */
            socket_ptr -> nx_udp_socket_packets_received++;
 8010076:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8010078:	699b      	ldr	r3, [r3, #24]
 801007a:	1c5a      	adds	r2, r3, #1
 801007c:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 801007e:	619a      	str	r2, [r3, #24]

            /* Increment the total UDP receive bytes.  */
            ip_ptr -> nx_ip_udp_bytes_received +=          packet_ptr -> nx_packet_length - (ULONG)sizeof(NX_UDP_HEADER);
 8010080:	687b      	ldr	r3, [r7, #4]
 8010082:	f8d3 2094 	ldr.w	r2, [r3, #148]	; 0x94
 8010086:	683b      	ldr	r3, [r7, #0]
 8010088:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 801008a:	4413      	add	r3, r2
 801008c:	f1a3 0208 	sub.w	r2, r3, #8
 8010090:	687b      	ldr	r3, [r7, #4]
 8010092:	f8c3 2094 	str.w	r2, [r3, #148]	; 0x94
            socket_ptr -> nx_udp_socket_bytes_received +=  packet_ptr -> nx_packet_length - (ULONG)sizeof(NX_UDP_HEADER);
 8010096:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8010098:	69da      	ldr	r2, [r3, #28]
 801009a:	683b      	ldr	r3, [r7, #0]
 801009c:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 801009e:	4413      	add	r3, r2
 80100a0:	f1a3 0208 	sub.w	r2, r3, #8
 80100a4:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 80100a6:	61da      	str	r2, [r3, #28]

            /* If trace is enabled, insert this event into the trace buffer.  */
            NX_TRACE_IN_LINE_INSERT(NX_TRACE_INTERNAL_UDP_RECEIVE, ip_ptr, socket_ptr, packet_ptr, udp_header_ptr -> nx_udp_header_word_0, NX_TRACE_INTERNAL_EVENTS, 0, 0);

            /* Get out of the search loop.  */
            break;
 80100a8:	e00a      	b.n	80100c0 <_nx_udp_packet_receive+0x198>
        }
        else
        {

            /* Move to the next entry in the bound index.  */
            socket_ptr =  socket_ptr -> nx_udp_socket_bound_next;
 80100aa:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 80100ac:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 80100ae:	64fb      	str	r3, [r7, #76]	; 0x4c
        }
    } while (socket_ptr != ip_ptr -> nx_ip_udp_port_table[index]);
 80100b0:	687b      	ldr	r3, [r7, #4]
 80100b2:	6c3a      	ldr	r2, [r7, #64]	; 0x40
 80100b4:	32e0      	adds	r2, #224	; 0xe0
 80100b6:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 80100ba:	6cfa      	ldr	r2, [r7, #76]	; 0x4c
 80100bc:	429a      	cmp	r2, r3
 80100be:	d1d5      	bne.n	801006c <_nx_udp_packet_receive+0x144>

    /* Determine if the caller is a thread. If so, release the mutex protection previously setup.  */
    if ((_tx_thread_current_ptr) && (TX_THREAD_GET_SYSTEM_STATE() == 0))
 80100c0:	4b49      	ldr	r3, [pc, #292]	; (80101e8 <_nx_udp_packet_receive+0x2c0>)
 80100c2:	681b      	ldr	r3, [r3, #0]
 80100c4:	2b00      	cmp	r3, #0
 80100c6:	d00e      	beq.n	80100e6 <_nx_udp_packet_receive+0x1be>
    __asm__ volatile (" MRS  %0,IPSR ": "=r" (ipsr_value) );
 80100c8:	f3ef 8305 	mrs	r3, IPSR
 80100cc:	62bb      	str	r3, [r7, #40]	; 0x28
    return(ipsr_value);
 80100ce:	6aba      	ldr	r2, [r7, #40]	; 0x28
 80100d0:	4b46      	ldr	r3, [pc, #280]	; (80101ec <_nx_udp_packet_receive+0x2c4>)
 80100d2:	681b      	ldr	r3, [r3, #0]
 80100d4:	4313      	orrs	r3, r2
 80100d6:	2b00      	cmp	r3, #0
 80100d8:	d105      	bne.n	80100e6 <_nx_udp_packet_receive+0x1be>
    {

        /* Release mutex protection.  */
        tx_mutex_put(&(ip_ptr -> nx_ip_protection));
 80100da:	687b      	ldr	r3, [r7, #4]
 80100dc:	f503 739e 	add.w	r3, r3, #316	; 0x13c
 80100e0:	4618      	mov	r0, r3
 80100e2:	f003 f8bf 	bl	8013264 <_tx_mutex_put>
    }

    /* Determine if a match was found.  */
    if (socket_ptr -> nx_udp_socket_port != port)
 80100e6:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 80100e8:	689b      	ldr	r3, [r3, #8]
 80100ea:	6c7a      	ldr	r2, [r7, #68]	; 0x44
 80100ec:	429a      	cmp	r2, r3
 80100ee:	d02b      	beq.n	8010148 <_nx_udp_packet_receive+0x220>
    {

#ifndef NX_DISABLE_UDP_INFO

        /* Increment the no port for delivery count.  */
        ip_ptr -> nx_ip_udp_no_port_for_delivery++;
 80100f0:	687b      	ldr	r3, [r7, #4]
 80100f2:	f8d3 309c 	ldr.w	r3, [r3, #156]	; 0x9c
 80100f6:	1c5a      	adds	r2, r3, #1
 80100f8:	687b      	ldr	r3, [r7, #4]
 80100fa:	f8c3 209c 	str.w	r2, [r3, #156]	; 0x9c

        /* Increment the total UDP receive packets dropped count.  */
        ip_ptr -> nx_ip_udp_receive_packets_dropped++;
 80100fe:	687b      	ldr	r3, [r7, #4]
 8010100:	f8d3 30a0 	ldr.w	r3, [r3, #160]	; 0xa0
 8010104:	1c5a      	adds	r2, r3, #1
 8010106:	687b      	ldr	r3, [r7, #4]
 8010108:	f8c3 20a0 	str.w	r2, [r3, #160]	; 0xa0
#endif

#if !defined(NX_DISABLE_IPV4) && !defined(NX_DISABLE_ICMPV4_ERROR_MESSAGE)
        /* If ICMPv4 is enabled, send Destination unreachable. */
        if ((packet_ptr -> nx_packet_ip_version == NX_IP_VERSION_V4) &&
 801010c:	683b      	ldr	r3, [r7, #0]
 801010e:	f893 302c 	ldrb.w	r3, [r3, #44]	; 0x2c
 8010112:	2b04      	cmp	r3, #4
 8010114:	d114      	bne.n	8010140 <_nx_udp_packet_receive+0x218>
            (ip_ptr -> nx_ip_icmpv4_packet_process))
 8010116:	687b      	ldr	r3, [r7, #4]
 8010118:	f8d3 3370 	ldr.w	r3, [r3, #880]	; 0x370
        if ((packet_ptr -> nx_packet_ip_version == NX_IP_VERSION_V4) &&
 801011c:	2b00      	cmp	r3, #0
 801011e:	d00f      	beq.n	8010140 <_nx_udp_packet_receive+0x218>
        {

            /* Restore UDP header. */
            NX_CHANGE_ULONG_ENDIAN(udp_header_ptr -> nx_udp_header_word_0);
 8010120:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 8010122:	681b      	ldr	r3, [r3, #0]
 8010124:	ba1a      	rev	r2, r3
 8010126:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 8010128:	601a      	str	r2, [r3, #0]
            NX_CHANGE_ULONG_ENDIAN(udp_header_ptr -> nx_udp_header_word_1);
 801012a:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 801012c:	685b      	ldr	r3, [r3, #4]
 801012e:	ba1a      	rev	r2, r3
 8010130:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 8010132:	605a      	str	r2, [r3, #4]

            /* Send out ICMP error message if dest is not multicast. */
            NX_ICMPV4_SEND_DEST_UNREACHABLE(ip_ptr, packet_ptr, NX_ICMP_PORT_UNREACH_CODE);
 8010134:	2300      	movs	r3, #0
 8010136:	4a2e      	ldr	r2, [pc, #184]	; (80101f0 <_nx_udp_packet_receive+0x2c8>)
 8010138:	6839      	ldr	r1, [r7, #0]
 801013a:	6878      	ldr	r0, [r7, #4]
 801013c:	f7f9 fbbc 	bl	80098b8 <_nx_icmpv4_send_error_message>
            }
        }
#endif /* FEATURE_NX_IPV6 && !NX_DISABLE_ICMPV6_ERROR_MESSAGE  */

        /* No socket structure bound to this port, just release the packet.  */
        _nx_packet_release(packet_ptr);
 8010140:	6838      	ldr	r0, [r7, #0]
 8010142:	f7fc f961 	bl	800c408 <_nx_packet_release>
        return;
 8010146:	e0df      	b.n	8010308 <_nx_udp_packet_receive+0x3e0>
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 8010148:	f3ef 8310 	mrs	r3, PRIMASK
 801014c:	627b      	str	r3, [r7, #36]	; 0x24
    return(posture);
 801014e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    int_posture = __get_interrupt_posture();
 8010150:	623b      	str	r3, [r7, #32]
    __asm__ volatile ("CPSID i" : : : "memory");
 8010152:	b672      	cpsid	i
    return(int_posture);
 8010154:	6a3b      	ldr	r3, [r7, #32]
    }

    /* Disable interrupts.  */
    TX_DISABLE
 8010156:	63fb      	str	r3, [r7, #60]	; 0x3c

    /* Determine if the socket is still valid.  */
    if (socket_ptr -> nx_udp_socket_id != NX_UDP_ID)
 8010158:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 801015a:	681b      	ldr	r3, [r3, #0]
 801015c:	4a25      	ldr	r2, [pc, #148]	; (80101f4 <_nx_udp_packet_receive+0x2cc>)
 801015e:	4293      	cmp	r3, r2
 8010160:	d01c      	beq.n	801019c <_nx_udp_packet_receive+0x274>
    {

#ifndef NX_DISABLE_UDP_INFO

        /* Increment the no port for delivery count.  */
        ip_ptr -> nx_ip_udp_no_port_for_delivery++;
 8010162:	687b      	ldr	r3, [r7, #4]
 8010164:	f8d3 309c 	ldr.w	r3, [r3, #156]	; 0x9c
 8010168:	1c5a      	adds	r2, r3, #1
 801016a:	687b      	ldr	r3, [r7, #4]
 801016c:	f8c3 209c 	str.w	r2, [r3, #156]	; 0x9c

        /* Increment the total UDP receive packets dropped count.  */
        ip_ptr -> nx_ip_udp_receive_packets_dropped++;
 8010170:	687b      	ldr	r3, [r7, #4]
 8010172:	f8d3 30a0 	ldr.w	r3, [r3, #160]	; 0xa0
 8010176:	1c5a      	adds	r2, r3, #1
 8010178:	687b      	ldr	r3, [r7, #4]
 801017a:	f8c3 20a0 	str.w	r2, [r3, #160]	; 0xa0

        /* Increment the total UDP receive packets dropped count for this socket.  */
        socket_ptr -> nx_udp_socket_packets_dropped++;
 801017e:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8010180:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8010182:	1c5a      	adds	r2, r3, #1
 8010184:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8010186:	625a      	str	r2, [r3, #36]	; 0x24
 8010188:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 801018a:	61fb      	str	r3, [r7, #28]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 801018c:	69fb      	ldr	r3, [r7, #28]
 801018e:	f383 8810 	msr	PRIMASK, r3
}
 8010192:	bf00      	nop

        /* Restore interrupts.  */
        TX_RESTORE

        /* Release the packet.  */
        _nx_packet_release(packet_ptr);
 8010194:	6838      	ldr	r0, [r7, #0]
 8010196:	f7fc f937 	bl	800c408 <_nx_packet_release>

        /* Return to caller.  */
        return;
 801019a:	e0b5      	b.n	8010308 <_nx_udp_packet_receive+0x3e0>
    }

    /* Pickup the receive notify function.  */
    receive_callback =  socket_ptr -> nx_udp_receive_callback;
 801019c:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 801019e:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 80101a0:	63bb      	str	r3, [r7, #56]	; 0x38

    /* Determine if we need to update the UDP port head pointer.  This should
       only be done if the found socket pointer is not the head pointer and
       the mutex for this IP instance is available.  */
    if ((socket_ptr != ip_ptr -> nx_ip_udp_port_table[index]) && (!ip_ptr -> nx_ip_protection.tx_mutex_ownership_count))
 80101a2:	687b      	ldr	r3, [r7, #4]
 80101a4:	6c3a      	ldr	r2, [r7, #64]	; 0x40
 80101a6:	32e0      	adds	r2, #224	; 0xe0
 80101a8:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 80101ac:	6cfa      	ldr	r2, [r7, #76]	; 0x4c
 80101ae:	429a      	cmp	r2, r3
 80101b0:	d00a      	beq.n	80101c8 <_nx_udp_packet_receive+0x2a0>
 80101b2:	687b      	ldr	r3, [r7, #4]
 80101b4:	f8d3 3144 	ldr.w	r3, [r3, #324]	; 0x144
 80101b8:	2b00      	cmp	r3, #0
 80101ba:	d105      	bne.n	80101c8 <_nx_udp_packet_receive+0x2a0>
    {

        /* Move the port head pointer to this socket.  */
        ip_ptr -> nx_ip_udp_port_table[index] =  socket_ptr;
 80101bc:	687b      	ldr	r3, [r7, #4]
 80101be:	6c3a      	ldr	r2, [r7, #64]	; 0x40
 80101c0:	32e0      	adds	r2, #224	; 0xe0
 80101c2:	6cf9      	ldr	r1, [r7, #76]	; 0x4c
 80101c4:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
    }

    /* Determine if there is thread waiting for a packet from this port.  */
    thread_ptr =  socket_ptr -> nx_udp_socket_receive_suspension_list;
 80101c8:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 80101ca:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 80101cc:	637b      	str	r3, [r7, #52]	; 0x34
    if (thread_ptr)
 80101ce:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 80101d0:	2b00      	cmp	r3, #0
 80101d2:	d03e      	beq.n	8010252 <_nx_udp_packet_receive+0x32a>
    {

        /* Remove the suspended thread from the list.  */

        /* See if this is the only suspended thread on the list.  */
        if (thread_ptr == thread_ptr -> tx_thread_suspended_next)
 80101d4:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 80101d6:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 80101d8:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 80101da:	429a      	cmp	r2, r3
 80101dc:	d10c      	bne.n	80101f8 <_nx_udp_packet_receive+0x2d0>
        {

            /* Yes, the only suspended thread.  */

            /* Update the head pointer.  */
            socket_ptr -> nx_udp_socket_receive_suspension_list =  NX_NULL;
 80101de:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 80101e0:	2200      	movs	r2, #0
 80101e2:	659a      	str	r2, [r3, #88]	; 0x58
 80101e4:	e016      	b.n	8010214 <_nx_udp_packet_receive+0x2ec>
 80101e6:	bf00      	nop
 80101e8:	24031bc4 	.word	0x24031bc4
 80101ec:	24000078 	.word	0x24000078
 80101f0:	03030000 	.word	0x03030000
 80101f4:	55445020 	.word	0x55445020
        {

            /* At least one more thread is on the same expiration list.  */

            /* Update the list head pointer.  */
            socket_ptr -> nx_udp_socket_receive_suspension_list =  thread_ptr -> tx_thread_suspended_next;
 80101f8:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 80101fa:	6f1a      	ldr	r2, [r3, #112]	; 0x70
 80101fc:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 80101fe:	659a      	str	r2, [r3, #88]	; 0x58

            /* Update the links of the adjacent threads.  */
            (thread_ptr -> tx_thread_suspended_next) -> tx_thread_suspended_previous =
 8010200:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8010202:	6f1b      	ldr	r3, [r3, #112]	; 0x70
                thread_ptr -> tx_thread_suspended_previous;
 8010204:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 8010206:	6f52      	ldr	r2, [r2, #116]	; 0x74
            (thread_ptr -> tx_thread_suspended_next) -> tx_thread_suspended_previous =
 8010208:	675a      	str	r2, [r3, #116]	; 0x74
            (thread_ptr -> tx_thread_suspended_previous) -> tx_thread_suspended_next =
 801020a:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 801020c:	6f5b      	ldr	r3, [r3, #116]	; 0x74
                thread_ptr -> tx_thread_suspended_next;
 801020e:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 8010210:	6f12      	ldr	r2, [r2, #112]	; 0x70
            (thread_ptr -> tx_thread_suspended_previous) -> tx_thread_suspended_next =
 8010212:	671a      	str	r2, [r3, #112]	; 0x70
        }

        /* Decrement the suspension count.  */
        socket_ptr -> nx_udp_socket_receive_suspended_count--;
 8010214:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8010216:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
 8010218:	1e5a      	subs	r2, r3, #1
 801021a:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 801021c:	65da      	str	r2, [r3, #92]	; 0x5c

        /* Prepare for resumption of the first thread.  */

        /* Clear cleanup routine to avoid timeout.  */
        thread_ptr -> tx_thread_suspend_cleanup =  TX_NULL;
 801021e:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8010220:	2200      	movs	r2, #0
 8010222:	669a      	str	r2, [r3, #104]	; 0x68

        /* Temporarily disable preemption.  */
        _tx_thread_preempt_disable++;
 8010224:	4b3a      	ldr	r3, [pc, #232]	; (8010310 <_nx_udp_packet_receive+0x3e8>)
 8010226:	681b      	ldr	r3, [r3, #0]
 8010228:	3301      	adds	r3, #1
 801022a:	4a39      	ldr	r2, [pc, #228]	; (8010310 <_nx_udp_packet_receive+0x3e8>)
 801022c:	6013      	str	r3, [r2, #0]

        /* Return this block pointer to the suspended thread waiting for
           a block.  */
        *((NX_PACKET **)thread_ptr -> tx_thread_additional_suspend_info) =  packet_ptr;
 801022e:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8010230:	6fdb      	ldr	r3, [r3, #124]	; 0x7c
 8010232:	683a      	ldr	r2, [r7, #0]
 8010234:	601a      	str	r2, [r3, #0]
 8010236:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8010238:	61bb      	str	r3, [r7, #24]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 801023a:	69bb      	ldr	r3, [r7, #24]
 801023c:	f383 8810 	msr	PRIMASK, r3
}
 8010240:	bf00      	nop

        /* Restore interrupts.  */
        TX_RESTORE

        /* Put return status into the thread control block.  */
        thread_ptr -> tx_thread_suspend_status =  NX_SUCCESS;
 8010242:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8010244:	2200      	movs	r2, #0
 8010246:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84

        /* Resume thread.  */
        _tx_thread_system_resume(thread_ptr);
 801024a:	6b78      	ldr	r0, [r7, #52]	; 0x34
 801024c:	f004 fd6c 	bl	8014d28 <_tx_thread_system_resume>
 8010250:	e054      	b.n	80102fc <_nx_udp_packet_receive+0x3d4>
            return;
        }
#endif /* NX_ENABLE_LOW_WATERMARK */

        /* Place the packet at the end of the socket's receive queue.  */
        if (socket_ptr -> nx_udp_socket_receive_head)
 8010252:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8010254:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 8010256:	2b00      	cmp	r3, #0
 8010258:	d03c      	beq.n	80102d4 <_nx_udp_packet_receive+0x3ac>
        {

            /* Add the new packet to a nonempty list.  */
            (socket_ptr -> nx_udp_socket_receive_tail) -> nx_packet_queue_next =  packet_ptr;
 801025a:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 801025c:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 801025e:	683a      	ldr	r2, [r7, #0]
 8010260:	61da      	str	r2, [r3, #28]
            socket_ptr -> nx_udp_socket_receive_tail =  packet_ptr;
 8010262:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8010264:	683a      	ldr	r2, [r7, #0]
 8010266:	649a      	str	r2, [r3, #72]	; 0x48
            packet_ptr -> nx_packet_queue_next =        NX_NULL;
 8010268:	683b      	ldr	r3, [r7, #0]
 801026a:	2200      	movs	r2, #0
 801026c:	61da      	str	r2, [r3, #28]

            /* Increment the number of packets queued.  */
            socket_ptr -> nx_udp_socket_receive_count++;
 801026e:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8010270:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 8010272:	1c5a      	adds	r2, r3, #1
 8010274:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8010276:	63da      	str	r2, [r3, #60]	; 0x3c

            /* Determine if the maximum queue depth has been reached.  */
            if (socket_ptr -> nx_udp_socket_receive_count >
 8010278:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 801027a:	6bda      	ldr	r2, [r3, #60]	; 0x3c
                socket_ptr -> nx_udp_socket_queue_maximum)
 801027c:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 801027e:	6c1b      	ldr	r3, [r3, #64]	; 0x40
            if (socket_ptr -> nx_udp_socket_receive_count >
 8010280:	429a      	cmp	r2, r3
 8010282:	d921      	bls.n	80102c8 <_nx_udp_packet_receive+0x3a0>
            {

                /* We have exceeded the queue depth, so remove the first item
                   in the queue (which is the oldest).  */
                packet_ptr =  socket_ptr -> nx_udp_socket_receive_head;
 8010284:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8010286:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 8010288:	603b      	str	r3, [r7, #0]
                socket_ptr -> nx_udp_socket_receive_head =  packet_ptr -> nx_packet_queue_next;
 801028a:	683b      	ldr	r3, [r7, #0]
 801028c:	69da      	ldr	r2, [r3, #28]
 801028e:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8010290:	645a      	str	r2, [r3, #68]	; 0x44

                /* Decrement the number of packets queued.  */
                socket_ptr -> nx_udp_socket_receive_count--;
 8010292:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8010294:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 8010296:	1e5a      	subs	r2, r3, #1
 8010298:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 801029a:	63da      	str	r2, [r3, #60]	; 0x3c

#ifndef NX_DISABLE_UDP_INFO

                /* Increment the total UDP receive packets dropped count.  */
                ip_ptr -> nx_ip_udp_receive_packets_dropped++;
 801029c:	687b      	ldr	r3, [r7, #4]
 801029e:	f8d3 30a0 	ldr.w	r3, [r3, #160]	; 0xa0
 80102a2:	1c5a      	adds	r2, r3, #1
 80102a4:	687b      	ldr	r3, [r7, #4]
 80102a6:	f8c3 20a0 	str.w	r2, [r3, #160]	; 0xa0

                /* Increment the total UDP receive packets dropped count for this socket.  */
                socket_ptr -> nx_udp_socket_packets_dropped++;
 80102aa:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 80102ac:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 80102ae:	1c5a      	adds	r2, r3, #1
 80102b0:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 80102b2:	625a      	str	r2, [r3, #36]	; 0x24
 80102b4:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 80102b6:	617b      	str	r3, [r7, #20]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 80102b8:	697b      	ldr	r3, [r7, #20]
 80102ba:	f383 8810 	msr	PRIMASK, r3
}
 80102be:	bf00      	nop

                /* Restore interrupts.  */
                TX_RESTORE

                /* Release the packet.  */
                _nx_packet_release(packet_ptr);
 80102c0:	6838      	ldr	r0, [r7, #0]
 80102c2:	f7fc f8a1 	bl	800c408 <_nx_packet_release>
 80102c6:	e019      	b.n	80102fc <_nx_udp_packet_receive+0x3d4>
 80102c8:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 80102ca:	613b      	str	r3, [r7, #16]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 80102cc:	693b      	ldr	r3, [r7, #16]
 80102ce:	f383 8810 	msr	PRIMASK, r3
}
 80102d2:	e013      	b.n	80102fc <_nx_udp_packet_receive+0x3d4>
        }
        else
        {

            /* Add the new packet to an empty list.  */
            socket_ptr -> nx_udp_socket_receive_head =  packet_ptr;
 80102d4:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 80102d6:	683a      	ldr	r2, [r7, #0]
 80102d8:	645a      	str	r2, [r3, #68]	; 0x44
            socket_ptr -> nx_udp_socket_receive_tail =  packet_ptr;
 80102da:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 80102dc:	683a      	ldr	r2, [r7, #0]
 80102de:	649a      	str	r2, [r3, #72]	; 0x48
            packet_ptr -> nx_packet_queue_next =        NX_NULL;
 80102e0:	683b      	ldr	r3, [r7, #0]
 80102e2:	2200      	movs	r2, #0
 80102e4:	61da      	str	r2, [r3, #28]

            /* Increment the number of packets queued.  */
            socket_ptr -> nx_udp_socket_receive_count++;
 80102e6:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 80102e8:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 80102ea:	1c5a      	adds	r2, r3, #1
 80102ec:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 80102ee:	63da      	str	r2, [r3, #60]	; 0x3c
 80102f0:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 80102f2:	60fb      	str	r3, [r7, #12]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 80102f4:	68fb      	ldr	r3, [r7, #12]
 80102f6:	f383 8810 	msr	PRIMASK, r3
}
 80102fa:	bf00      	nop
        /* Add debug information. */
        NX_PACKET_DEBUG(NX_PACKET_UDP_RECEIVE_QUEUE, __LINE__, packet_ptr);
    }

    /* Determine if there is a socket receive notification function specified.  */
    if (receive_callback)
 80102fc:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 80102fe:	2b00      	cmp	r3, #0
 8010300:	d002      	beq.n	8010308 <_nx_udp_packet_receive+0x3e0>
    {

        /* Yes, notification is requested.  Call the application's receive notification
           function for this socket.  */
        (receive_callback)(socket_ptr);
 8010302:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8010304:	6cf8      	ldr	r0, [r7, #76]	; 0x4c
 8010306:	4798      	blx	r3
    }
}
 8010308:	3750      	adds	r7, #80	; 0x50
 801030a:	46bd      	mov	sp, r7
 801030c:	bd80      	pop	{r7, pc}
 801030e:	bf00      	nop
 8010310:	24031c5c 	.word	0x24031c5c

08010314 <_nx_udp_receive_cleanup>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
VOID  _nx_udp_receive_cleanup(TX_THREAD *thread_ptr NX_CLEANUP_PARAMETER)
{
 8010314:	b580      	push	{r7, lr}
 8010316:	b088      	sub	sp, #32
 8010318:	af00      	add	r7, sp, #0
 801031a:	6078      	str	r0, [r7, #4]
 801031c:	6039      	str	r1, [r7, #0]
NX_UDP_SOCKET *socket_ptr;  /* Working socket pointer  */

    NX_CLEANUP_EXTENSION

    /* Setup pointer to UDP socket control block.  */
    socket_ptr =  (NX_UDP_SOCKET *)thread_ptr -> tx_thread_suspend_control_block;
 801031e:	687b      	ldr	r3, [r7, #4]
 8010320:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 8010322:	61fb      	str	r3, [r7, #28]
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 8010324:	f3ef 8310 	mrs	r3, PRIMASK
 8010328:	617b      	str	r3, [r7, #20]
    return(posture);
 801032a:	697b      	ldr	r3, [r7, #20]
    int_posture = __get_interrupt_posture();
 801032c:	613b      	str	r3, [r7, #16]
    __asm__ volatile ("CPSID i" : : : "memory");
 801032e:	b672      	cpsid	i
    return(int_posture);
 8010330:	693b      	ldr	r3, [r7, #16]

    /* Disable interrupts to remove the suspended thread from the UDP socket.  */
    TX_DISABLE
 8010332:	61bb      	str	r3, [r7, #24]

    /* Determine if the cleanup is still required.  */
    if ((thread_ptr -> tx_thread_suspend_cleanup) && (socket_ptr) &&
 8010334:	687b      	ldr	r3, [r7, #4]
 8010336:	6e9b      	ldr	r3, [r3, #104]	; 0x68
 8010338:	2b00      	cmp	r3, #0
 801033a:	d03d      	beq.n	80103b8 <_nx_udp_receive_cleanup+0xa4>
 801033c:	69fb      	ldr	r3, [r7, #28]
 801033e:	2b00      	cmp	r3, #0
 8010340:	d03a      	beq.n	80103b8 <_nx_udp_receive_cleanup+0xa4>
        (socket_ptr -> nx_udp_socket_id == NX_UDP_ID))
 8010342:	69fb      	ldr	r3, [r7, #28]
 8010344:	681b      	ldr	r3, [r3, #0]
    if ((thread_ptr -> tx_thread_suspend_cleanup) && (socket_ptr) &&
 8010346:	4a21      	ldr	r2, [pc, #132]	; (80103cc <_nx_udp_receive_cleanup+0xb8>)
 8010348:	4293      	cmp	r3, r2
 801034a:	d135      	bne.n	80103b8 <_nx_udp_receive_cleanup+0xa4>
    {

        /* Yes, we still have thread suspension!  */

        /* Clear the suspension cleanup flag.  */
        thread_ptr -> tx_thread_suspend_cleanup =  TX_NULL;
 801034c:	687b      	ldr	r3, [r7, #4]
 801034e:	2200      	movs	r2, #0
 8010350:	669a      	str	r2, [r3, #104]	; 0x68

        /* Remove the suspended thread from the list.  */

        /* See if this is the only suspended thread on the list.  */
        if (thread_ptr == thread_ptr -> tx_thread_suspended_next)
 8010352:	687b      	ldr	r3, [r7, #4]
 8010354:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 8010356:	687a      	ldr	r2, [r7, #4]
 8010358:	429a      	cmp	r2, r3
 801035a:	d103      	bne.n	8010364 <_nx_udp_receive_cleanup+0x50>
        {

            /* Yes, the only suspended thread.  */

            /* Update the head pointer.  */
            socket_ptr -> nx_udp_socket_receive_suspension_list =  NX_NULL;
 801035c:	69fb      	ldr	r3, [r7, #28]
 801035e:	2200      	movs	r2, #0
 8010360:	659a      	str	r2, [r3, #88]	; 0x58
 8010362:	e00d      	b.n	8010380 <_nx_udp_receive_cleanup+0x6c>
        {

            /* At least one more thread is on the same suspension list.  */

            /* Update the list head pointer.  */
            socket_ptr -> nx_udp_socket_receive_suspension_list =  thread_ptr -> tx_thread_suspended_next;
 8010364:	687b      	ldr	r3, [r7, #4]
 8010366:	6f1a      	ldr	r2, [r3, #112]	; 0x70
 8010368:	69fb      	ldr	r3, [r7, #28]
 801036a:	659a      	str	r2, [r3, #88]	; 0x58

            /* Update the links of the adjacent threads.  */
            (thread_ptr -> tx_thread_suspended_next) -> tx_thread_suspended_previous =
 801036c:	687b      	ldr	r3, [r7, #4]
 801036e:	6f1b      	ldr	r3, [r3, #112]	; 0x70
                thread_ptr -> tx_thread_suspended_previous;
 8010370:	687a      	ldr	r2, [r7, #4]
 8010372:	6f52      	ldr	r2, [r2, #116]	; 0x74
            (thread_ptr -> tx_thread_suspended_next) -> tx_thread_suspended_previous =
 8010374:	675a      	str	r2, [r3, #116]	; 0x74
            (thread_ptr -> tx_thread_suspended_previous) -> tx_thread_suspended_next =
 8010376:	687b      	ldr	r3, [r7, #4]
 8010378:	6f5b      	ldr	r3, [r3, #116]	; 0x74
                thread_ptr -> tx_thread_suspended_next;
 801037a:	687a      	ldr	r2, [r7, #4]
 801037c:	6f12      	ldr	r2, [r2, #112]	; 0x70
            (thread_ptr -> tx_thread_suspended_previous) -> tx_thread_suspended_next =
 801037e:	671a      	str	r2, [r3, #112]	; 0x70
        }

        /* Decrement the suspension count.  */
        socket_ptr -> nx_udp_socket_receive_suspended_count--;
 8010380:	69fb      	ldr	r3, [r7, #28]
 8010382:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
 8010384:	1e5a      	subs	r2, r3, #1
 8010386:	69fb      	ldr	r3, [r7, #28]
 8010388:	65da      	str	r2, [r3, #92]	; 0x5c

        /* Now we need to determine if this cleanup is from a terminate, timeout,
           or from a wait abort.  */
        if (thread_ptr -> tx_thread_state == TX_TCP_IP)
 801038a:	687b      	ldr	r3, [r7, #4]
 801038c:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 801038e:	2b0c      	cmp	r3, #12
 8010390:	d112      	bne.n	80103b8 <_nx_udp_receive_cleanup+0xa4>

            /* Thread still suspended on the UDP socket.  Setup return error status and
               resume the thread.  */

            /* Setup return status.  */
            thread_ptr -> tx_thread_suspend_status =  NX_NO_PACKET;
 8010392:	687b      	ldr	r3, [r7, #4]
 8010394:	2201      	movs	r2, #1
 8010396:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84

            /* Temporarily disable preemption.  */
            _tx_thread_preempt_disable++;
 801039a:	4b0d      	ldr	r3, [pc, #52]	; (80103d0 <_nx_udp_receive_cleanup+0xbc>)
 801039c:	681b      	ldr	r3, [r3, #0]
 801039e:	3301      	adds	r3, #1
 80103a0:	4a0b      	ldr	r2, [pc, #44]	; (80103d0 <_nx_udp_receive_cleanup+0xbc>)
 80103a2:	6013      	str	r3, [r2, #0]
 80103a4:	69bb      	ldr	r3, [r7, #24]
 80103a6:	60fb      	str	r3, [r7, #12]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 80103a8:	68fb      	ldr	r3, [r7, #12]
 80103aa:	f383 8810 	msr	PRIMASK, r3
}
 80103ae:	bf00      	nop
            TX_RESTORE

            /* Resume the thread!  Check for preemption even though we are executing
               from the system timer thread right now which normally executes at the
               highest priority.  */
            _tx_thread_system_resume(thread_ptr);
 80103b0:	6878      	ldr	r0, [r7, #4]
 80103b2:	f004 fcb9 	bl	8014d28 <_tx_thread_system_resume>

            /* Finished, just return.  */
            return;
 80103b6:	e005      	b.n	80103c4 <_nx_udp_receive_cleanup+0xb0>
 80103b8:	69bb      	ldr	r3, [r7, #24]
 80103ba:	60bb      	str	r3, [r7, #8]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 80103bc:	68bb      	ldr	r3, [r7, #8]
 80103be:	f383 8810 	msr	PRIMASK, r3
}
 80103c2:	bf00      	nop
        }
    }

    /* Restore interrupts.  */
    TX_RESTORE
}
 80103c4:	3720      	adds	r7, #32
 80103c6:	46bd      	mov	sp, r7
 80103c8:	bd80      	pop	{r7, pc}
 80103ca:	bf00      	nop
 80103cc:	55445020 	.word	0x55445020
 80103d0:	24031c5c 	.word	0x24031c5c

080103d4 <_nx_udp_socket_bind>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
UINT  _nx_udp_socket_bind(NX_UDP_SOCKET *socket_ptr, UINT  port, ULONG wait_option)
{
 80103d4:	b580      	push	{r7, lr}
 80103d6:	b090      	sub	sp, #64	; 0x40
 80103d8:	af00      	add	r7, sp, #0
 80103da:	60f8      	str	r0, [r7, #12]
 80103dc:	60b9      	str	r1, [r7, #8]
 80103de:	607a      	str	r2, [r7, #4]
NX_UDP_SOCKET *search_ptr;
NX_UDP_SOCKET *end_ptr;


    /* Setup the pointer to the associated IP instance.  */
    ip_ptr =  socket_ptr -> nx_udp_socket_ip_ptr;
 80103e0:	68fb      	ldr	r3, [r7, #12]
 80103e2:	68db      	ldr	r3, [r3, #12]
 80103e4:	63bb      	str	r3, [r7, #56]	; 0x38
    /* If trace is enabled, insert this event into the trace buffer.  */
    NX_TRACE_IN_LINE_INSERT(NX_TRACE_UDP_SOCKET_BIND, ip_ptr, socket_ptr, port, wait_option, NX_TRACE_UDP_EVENTS, 0, 0);

    /* Obtain the IP mutex so we can figure out whether or not the port has already
       been bound to.  */
    tx_mutex_get(&(ip_ptr -> nx_ip_protection), TX_WAIT_FOREVER);
 80103e6:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 80103e8:	f503 739e 	add.w	r3, r3, #316	; 0x13c
 80103ec:	f04f 31ff 	mov.w	r1, #4294967295
 80103f0:	4618      	mov	r0, r3
 80103f2:	f002 fcbf 	bl	8012d74 <_tx_mutex_get>

    /* Determine if the socket has already been bound to port or if a socket bind is
       already pending from another thread.  */
    if ((socket_ptr -> nx_udp_socket_bound_next) ||
 80103f6:	68fb      	ldr	r3, [r7, #12]
 80103f8:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 80103fa:	2b00      	cmp	r3, #0
 80103fc:	d103      	bne.n	8010406 <_nx_udp_socket_bind+0x32>
        (socket_ptr -> nx_udp_socket_bind_in_progress))
 80103fe:	68fb      	ldr	r3, [r7, #12]
 8010400:	6d5b      	ldr	r3, [r3, #84]	; 0x54
    if ((socket_ptr -> nx_udp_socket_bound_next) ||
 8010402:	2b00      	cmp	r3, #0
 8010404:	d007      	beq.n	8010416 <_nx_udp_socket_bind+0x42>
    {

        /* Release the protection mutex.  */
        tx_mutex_put(&(ip_ptr -> nx_ip_protection));
 8010406:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8010408:	f503 739e 	add.w	r3, r3, #316	; 0x13c
 801040c:	4618      	mov	r0, r3
 801040e:	f002 ff29 	bl	8013264 <_tx_mutex_put>

        /* Return an already bound error code.  */
        return(NX_ALREADY_BOUND);
 8010412:	2322      	movs	r3, #34	; 0x22
 8010414:	e0f7      	b.n	8010606 <_nx_udp_socket_bind+0x232>
    }

    /* Determine if the port needs to be allocated.  */
    if (port == NX_ANY_PORT)
 8010416:	68bb      	ldr	r3, [r7, #8]
 8010418:	2b00      	cmp	r3, #0
 801041a:	d11e      	bne.n	801045a <_nx_udp_socket_bind+0x86>
    {

        /* Call the find routine to allocate a UDP port.  */
        port = NX_SEARCH_PORT_START + (UINT)(NX_RAND() % ((NX_MAX_PORT + 1) - NX_SEARCH_PORT_START));
 801041c:	f00f ff4a 	bl	80202b4 <rand>
 8010420:	4603      	mov	r3, r0
 8010422:	425a      	negs	r2, r3
 8010424:	f3c3 030d 	ubfx	r3, r3, #0, #14
 8010428:	f3c2 020d 	ubfx	r2, r2, #0, #14
 801042c:	bf58      	it	pl
 801042e:	4253      	negpl	r3, r2
 8010430:	f503 4340 	add.w	r3, r3, #49152	; 0xc000
 8010434:	60bb      	str	r3, [r7, #8]
        if (_nx_udp_free_port_find(ip_ptr, port, &port) != NX_SUCCESS)
 8010436:	68bb      	ldr	r3, [r7, #8]
 8010438:	f107 0208 	add.w	r2, r7, #8
 801043c:	4619      	mov	r1, r3
 801043e:	6bb8      	ldr	r0, [r7, #56]	; 0x38
 8010440:	f7ff fcf8 	bl	800fe34 <_nx_udp_free_port_find>
 8010444:	4603      	mov	r3, r0
 8010446:	2b00      	cmp	r3, #0
 8010448:	d007      	beq.n	801045a <_nx_udp_socket_bind+0x86>
        {

            /* Release the protection mutex.  */
            tx_mutex_put(&(ip_ptr -> nx_ip_protection));
 801044a:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 801044c:	f503 739e 	add.w	r3, r3, #316	; 0x13c
 8010450:	4618      	mov	r0, r3
 8010452:	f002 ff07 	bl	8013264 <_tx_mutex_put>

            /* There was no free port, return an error code.  */
            return(NX_NO_FREE_PORTS);
 8010456:	2345      	movs	r3, #69	; 0x45
 8010458:	e0d5      	b.n	8010606 <_nx_udp_socket_bind+0x232>
        }
    }
#endif

    /* Save the port number in the UDP socket structure.  */
    socket_ptr -> nx_udp_socket_port =  port;
 801045a:	68ba      	ldr	r2, [r7, #8]
 801045c:	68fb      	ldr	r3, [r7, #12]
 801045e:	609a      	str	r2, [r3, #8]

    /* Calculate the hash index in the UDP port array of the associated IP instance.  */
    index =  (UINT)((port + (port >> 8)) & NX_UDP_PORT_TABLE_MASK);
 8010460:	68bb      	ldr	r3, [r7, #8]
 8010462:	0a1a      	lsrs	r2, r3, #8
 8010464:	68bb      	ldr	r3, [r7, #8]
 8010466:	4413      	add	r3, r2
 8010468:	f003 031f 	and.w	r3, r3, #31
 801046c:	637b      	str	r3, [r7, #52]	; 0x34

    /* Pickup the head of the UDP ports bound list.  */
    search_ptr =  ip_ptr -> nx_ip_udp_port_table[index];
 801046e:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8010470:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 8010472:	32e0      	adds	r2, #224	; 0xe0
 8010474:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 8010478:	63fb      	str	r3, [r7, #60]	; 0x3c

    /* Determine if we need to perform a list search.  */
    if (search_ptr)
 801047a:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 801047c:	2b00      	cmp	r3, #0
 801047e:	d00f      	beq.n	80104a0 <_nx_udp_socket_bind+0xcc>
    {

        /* Walk through the circular list of UDP sockets that are already
           bound.  */
        end_ptr = search_ptr;
 8010480:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8010482:	633b      	str	r3, [r7, #48]	; 0x30
        do
        {

            /* Determine if this entry is the same as the requested port.  */
            if (search_ptr -> nx_udp_socket_port == port)
 8010484:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8010486:	689a      	ldr	r2, [r3, #8]
 8010488:	68bb      	ldr	r3, [r7, #8]
 801048a:	429a      	cmp	r2, r3
 801048c:	d007      	beq.n	801049e <_nx_udp_socket_bind+0xca>
                /* Yes, the port has already been allocated.  */
                break;
            }

            /* Move to the next entry in the list.  */
            search_ptr =  search_ptr -> nx_udp_socket_bound_next;
 801048e:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8010490:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 8010492:	63fb      	str	r3, [r7, #60]	; 0x3c
        } while (search_ptr != end_ptr);
 8010494:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 8010496:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8010498:	429a      	cmp	r2, r3
 801049a:	d1f3      	bne.n	8010484 <_nx_udp_socket_bind+0xb0>
 801049c:	e000      	b.n	80104a0 <_nx_udp_socket_bind+0xcc>
                break;
 801049e:	bf00      	nop
    }

    /* Now determine if the port is available.  */
    if ((search_ptr == NX_NULL) || (search_ptr -> nx_udp_socket_port != port))
 80104a0:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 80104a2:	2b00      	cmp	r3, #0
 80104a4:	d004      	beq.n	80104b0 <_nx_udp_socket_bind+0xdc>
 80104a6:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 80104a8:	689a      	ldr	r2, [r3, #8]
 80104aa:	68bb      	ldr	r3, [r7, #8]
 80104ac:	429a      	cmp	r2, r3
 80104ae:	d043      	beq.n	8010538 <_nx_udp_socket_bind+0x164>
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 80104b0:	f3ef 8310 	mrs	r3, PRIMASK
 80104b4:	627b      	str	r3, [r7, #36]	; 0x24
    return(posture);
 80104b6:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    int_posture = __get_interrupt_posture();
 80104b8:	623b      	str	r3, [r7, #32]
    __asm__ volatile ("CPSID i" : : : "memory");
 80104ba:	b672      	cpsid	i
    return(int_posture);
 80104bc:	6a3b      	ldr	r3, [r7, #32]
    {

        /* Place this UDP socket structure on the list of bound ports.  */

        /* Disable interrupts.  */
        TX_DISABLE
 80104be:	62fb      	str	r3, [r7, #44]	; 0x2c

        /* Determine if the list is NULL.  */
        if (search_ptr)
 80104c0:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 80104c2:	2b00      	cmp	r3, #0
 80104c4:	d01e      	beq.n	8010504 <_nx_udp_socket_bind+0x130>
        {

            /* There are already sockets on this list... just add this one
               to the end.  */
            socket_ptr -> nx_udp_socket_bound_next =       ip_ptr -> nx_ip_udp_port_table[index];
 80104c6:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 80104c8:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 80104ca:	32e0      	adds	r2, #224	; 0xe0
 80104cc:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 80104d0:	68fb      	ldr	r3, [r7, #12]
 80104d2:	64da      	str	r2, [r3, #76]	; 0x4c
            socket_ptr -> nx_udp_socket_bound_previous =   (ip_ptr -> nx_ip_udp_port_table[index]) -> nx_udp_socket_bound_previous;
 80104d4:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 80104d6:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 80104d8:	32e0      	adds	r2, #224	; 0xe0
 80104da:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 80104de:	6d1a      	ldr	r2, [r3, #80]	; 0x50
 80104e0:	68fb      	ldr	r3, [r7, #12]
 80104e2:	651a      	str	r2, [r3, #80]	; 0x50
            ((ip_ptr -> nx_ip_udp_port_table[index]) -> nx_udp_socket_bound_previous) -> nx_udp_socket_bound_next = socket_ptr;
 80104e4:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 80104e6:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 80104e8:	32e0      	adds	r2, #224	; 0xe0
 80104ea:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 80104ee:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 80104f0:	68fa      	ldr	r2, [r7, #12]
 80104f2:	64da      	str	r2, [r3, #76]	; 0x4c
            (ip_ptr -> nx_ip_udp_port_table[index]) -> nx_udp_socket_bound_previous =   socket_ptr;
 80104f4:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 80104f6:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 80104f8:	32e0      	adds	r2, #224	; 0xe0
 80104fa:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 80104fe:	68fa      	ldr	r2, [r7, #12]
 8010500:	651a      	str	r2, [r3, #80]	; 0x50
 8010502:	e00b      	b.n	801051c <_nx_udp_socket_bind+0x148>
        else
        {

            /* Nothing is on the UDP port list.  Add this UDP socket to an
               empty list.  */
            socket_ptr -> nx_udp_socket_bound_next =      socket_ptr;
 8010504:	68fb      	ldr	r3, [r7, #12]
 8010506:	68fa      	ldr	r2, [r7, #12]
 8010508:	64da      	str	r2, [r3, #76]	; 0x4c
            socket_ptr -> nx_udp_socket_bound_previous =  socket_ptr;
 801050a:	68fb      	ldr	r3, [r7, #12]
 801050c:	68fa      	ldr	r2, [r7, #12]
 801050e:	651a      	str	r2, [r3, #80]	; 0x50
            ip_ptr -> nx_ip_udp_port_table[index] =       socket_ptr;
 8010510:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8010512:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 8010514:	32e0      	adds	r2, #224	; 0xe0
 8010516:	68f9      	ldr	r1, [r7, #12]
 8010518:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
 801051c:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 801051e:	61fb      	str	r3, [r7, #28]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 8010520:	69fb      	ldr	r3, [r7, #28]
 8010522:	f383 8810 	msr	PRIMASK, r3
}
 8010526:	bf00      	nop

        /* Restore interrupts.  */
        TX_RESTORE

        /* Release the mutex protection.  */
        tx_mutex_put(&(ip_ptr -> nx_ip_protection));
 8010528:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 801052a:	f503 739e 	add.w	r3, r3, #316	; 0x13c
 801052e:	4618      	mov	r0, r3
 8010530:	f002 fe98 	bl	8013264 <_tx_mutex_put>

        /* Return success to the caller.  */
        return(NX_SUCCESS);
 8010534:	2300      	movs	r3, #0
 8010536:	e066      	b.n	8010606 <_nx_udp_socket_bind+0x232>
    }
    else if (wait_option)
 8010538:	687b      	ldr	r3, [r7, #4]
 801053a:	2b00      	cmp	r3, #0
 801053c:	d05c      	beq.n	80105f8 <_nx_udp_socket_bind+0x224>
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 801053e:	f3ef 8310 	mrs	r3, PRIMASK
 8010542:	61bb      	str	r3, [r7, #24]
    return(posture);
 8010544:	69bb      	ldr	r3, [r7, #24]
    int_posture = __get_interrupt_posture();
 8010546:	617b      	str	r3, [r7, #20]
    __asm__ volatile ("CPSID i" : : : "memory");
 8010548:	b672      	cpsid	i
    return(int_posture);
 801054a:	697b      	ldr	r3, [r7, #20]
    {

        /* Prepare for suspension of this thread.  */

        /* Disable interrupts.  */
        TX_DISABLE
 801054c:	62fb      	str	r3, [r7, #44]	; 0x2c

        /* Pickup thread pointer.  */
        thread_ptr =  _tx_thread_current_ptr;
 801054e:	4b30      	ldr	r3, [pc, #192]	; (8010610 <_nx_udp_socket_bind+0x23c>)
 8010550:	681b      	ldr	r3, [r3, #0]
 8010552:	62bb      	str	r3, [r7, #40]	; 0x28

        /* Setup cleanup routine pointer.  */
        thread_ptr -> tx_thread_suspend_cleanup =  _nx_udp_bind_cleanup;
 8010554:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8010556:	4a2f      	ldr	r2, [pc, #188]	; (8010614 <_nx_udp_socket_bind+0x240>)
 8010558:	669a      	str	r2, [r3, #104]	; 0x68

        /* Setup cleanup information, i.e. this socket control
           block.  */
        thread_ptr -> tx_thread_suspend_control_block =  (void *)socket_ptr;
 801055a:	6abb      	ldr	r3, [r7, #40]	; 0x28
 801055c:	68fa      	ldr	r2, [r7, #12]
 801055e:	66da      	str	r2, [r3, #108]	; 0x6c

        /* Also remember the socket that has bound to the port, since the thread
           is going to be suspended on that socket.  */
        socket_ptr -> nx_udp_socket_bound_previous =  search_ptr;
 8010560:	68fb      	ldr	r3, [r7, #12]
 8010562:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 8010564:	651a      	str	r2, [r3, #80]	; 0x50

        /* Set the socket bind in progress flag (thread pointer).  */
        socket_ptr -> nx_udp_socket_bind_in_progress =  thread_ptr;
 8010566:	68fb      	ldr	r3, [r7, #12]
 8010568:	6aba      	ldr	r2, [r7, #40]	; 0x28
 801056a:	655a      	str	r2, [r3, #84]	; 0x54

        /* Setup suspension list.  */
        if (search_ptr -> nx_udp_socket_bind_suspension_list)
 801056c:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 801056e:	6e1b      	ldr	r3, [r3, #96]	; 0x60
 8010570:	2b00      	cmp	r3, #0
 8010572:	d012      	beq.n	801059a <_nx_udp_socket_bind+0x1c6>
        {

            /* This list is not NULL, add current thread to the end. */
            thread_ptr -> tx_thread_suspended_next =       search_ptr -> nx_udp_socket_bind_suspension_list;
 8010574:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8010576:	6e1a      	ldr	r2, [r3, #96]	; 0x60
 8010578:	6abb      	ldr	r3, [r7, #40]	; 0x28
 801057a:	671a      	str	r2, [r3, #112]	; 0x70
            thread_ptr -> tx_thread_suspended_previous =  (search_ptr -> nx_udp_socket_bind_suspension_list) -> tx_thread_suspended_previous;
 801057c:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 801057e:	6e1b      	ldr	r3, [r3, #96]	; 0x60
 8010580:	6f5a      	ldr	r2, [r3, #116]	; 0x74
 8010582:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8010584:	675a      	str	r2, [r3, #116]	; 0x74
            ((search_ptr -> nx_udp_socket_bind_suspension_list) -> tx_thread_suspended_previous) -> tx_thread_suspended_next =  thread_ptr;
 8010586:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8010588:	6e1b      	ldr	r3, [r3, #96]	; 0x60
 801058a:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 801058c:	6aba      	ldr	r2, [r7, #40]	; 0x28
 801058e:	671a      	str	r2, [r3, #112]	; 0x70
            (search_ptr -> nx_udp_socket_bind_suspension_list) -> tx_thread_suspended_previous =   thread_ptr;
 8010590:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8010592:	6e1b      	ldr	r3, [r3, #96]	; 0x60
 8010594:	6aba      	ldr	r2, [r7, #40]	; 0x28
 8010596:	675a      	str	r2, [r3, #116]	; 0x74
 8010598:	e008      	b.n	80105ac <_nx_udp_socket_bind+0x1d8>
        else
        {

            /* No other threads are suspended.  Setup the head pointer and
               just setup this threads pointers to itself.  */
            search_ptr -> nx_udp_socket_bind_suspension_list =         thread_ptr;
 801059a:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 801059c:	6aba      	ldr	r2, [r7, #40]	; 0x28
 801059e:	661a      	str	r2, [r3, #96]	; 0x60
            thread_ptr -> tx_thread_suspended_next =                   thread_ptr;
 80105a0:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80105a2:	6aba      	ldr	r2, [r7, #40]	; 0x28
 80105a4:	671a      	str	r2, [r3, #112]	; 0x70
            thread_ptr -> tx_thread_suspended_previous =               thread_ptr;
 80105a6:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80105a8:	6aba      	ldr	r2, [r7, #40]	; 0x28
 80105aa:	675a      	str	r2, [r3, #116]	; 0x74
        }

        /* Increment the suspended thread count.  */
        search_ptr -> nx_udp_socket_bind_suspended_count++;
 80105ac:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 80105ae:	6e5b      	ldr	r3, [r3, #100]	; 0x64
 80105b0:	1c5a      	adds	r2, r3, #1
 80105b2:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 80105b4:	665a      	str	r2, [r3, #100]	; 0x64

        /* Set the state to suspended.  */
        thread_ptr -> tx_thread_state =  TX_TCP_IP;
 80105b6:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80105b8:	220c      	movs	r2, #12
 80105ba:	631a      	str	r2, [r3, #48]	; 0x30

        /* Set the suspending flag.  */
        thread_ptr -> tx_thread_suspending =  TX_TRUE;
 80105bc:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80105be:	2201      	movs	r2, #1
 80105c0:	639a      	str	r2, [r3, #56]	; 0x38

        /* Temporarily disable preemption.  */
        _tx_thread_preempt_disable++;
 80105c2:	4b15      	ldr	r3, [pc, #84]	; (8010618 <_nx_udp_socket_bind+0x244>)
 80105c4:	681b      	ldr	r3, [r3, #0]
 80105c6:	3301      	adds	r3, #1
 80105c8:	4a13      	ldr	r2, [pc, #76]	; (8010618 <_nx_udp_socket_bind+0x244>)
 80105ca:	6013      	str	r3, [r2, #0]

        /* Save the timeout value.  */
        thread_ptr -> tx_thread_timer.tx_timer_internal_remaining_ticks =  wait_option;
 80105cc:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80105ce:	687a      	ldr	r2, [r7, #4]
 80105d0:	64da      	str	r2, [r3, #76]	; 0x4c
 80105d2:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 80105d4:	613b      	str	r3, [r7, #16]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 80105d6:	693b      	ldr	r3, [r7, #16]
 80105d8:	f383 8810 	msr	PRIMASK, r3
}
 80105dc:	bf00      	nop

        /* Restore interrupts.  */
        TX_RESTORE

        /* Release the mutex protection.  */
        tx_mutex_put(&(ip_ptr -> nx_ip_protection));
 80105de:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 80105e0:	f503 739e 	add.w	r3, r3, #316	; 0x13c
 80105e4:	4618      	mov	r0, r3
 80105e6:	f002 fe3d 	bl	8013264 <_tx_mutex_put>

        /* Call actual thread suspension routine.  */
        _tx_thread_system_suspend(thread_ptr);
 80105ea:	6ab8      	ldr	r0, [r7, #40]	; 0x28
 80105ec:	f004 fc9c 	bl	8014f28 <_tx_thread_system_suspend>

        /* Return the completion status.  */
        return(thread_ptr -> tx_thread_suspend_status);
 80105f0:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80105f2:	f8d3 3084 	ldr.w	r3, [r3, #132]	; 0x84
 80105f6:	e006      	b.n	8010606 <_nx_udp_socket_bind+0x232>
    }
    else
    {

        /* Release the IP protection.  */
        tx_mutex_put(&(ip_ptr -> nx_ip_protection));
 80105f8:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 80105fa:	f503 739e 	add.w	r3, r3, #316	; 0x13c
 80105fe:	4618      	mov	r0, r3
 8010600:	f002 fe30 	bl	8013264 <_tx_mutex_put>

        /* Return the port unavailable error.  */
        return(NX_PORT_UNAVAILABLE);
 8010604:	2323      	movs	r3, #35	; 0x23
    }
}
 8010606:	4618      	mov	r0, r3
 8010608:	3740      	adds	r7, #64	; 0x40
 801060a:	46bd      	mov	sp, r7
 801060c:	bd80      	pop	{r7, pc}
 801060e:	bf00      	nop
 8010610:	24031bc4 	.word	0x24031bc4
 8010614:	0800fd45 	.word	0x0800fd45
 8010618:	24031c5c 	.word	0x24031c5c

0801061c <_nx_udp_socket_create>:
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
UINT  _nx_udp_socket_create(NX_IP *ip_ptr, NX_UDP_SOCKET *socket_ptr, CHAR *name,
                            ULONG type_of_service, ULONG fragment, UINT time_to_live, ULONG queue_maximum)
{
 801061c:	b580      	push	{r7, lr}
 801061e:	b08a      	sub	sp, #40	; 0x28
 8010620:	af00      	add	r7, sp, #0
 8010622:	60f8      	str	r0, [r7, #12]
 8010624:	60b9      	str	r1, [r7, #8]
 8010626:	607a      	str	r2, [r7, #4]
 8010628:	603b      	str	r3, [r7, #0]

NX_UDP_SOCKET *tail_ptr;


    /* Initialize the TCP control block to zero.  */
    memset((void *)socket_ptr, 0, sizeof(NX_UDP_SOCKET));
 801062a:	2278      	movs	r2, #120	; 0x78
 801062c:	2100      	movs	r1, #0
 801062e:	68b8      	ldr	r0, [r7, #8]
 8010630:	f00f f924 	bl	801f87c <memset>

    /* Fill in the basic information in the new UDP socket structure.  */

    /* Remember the associated IP structure.  */
    socket_ptr -> nx_udp_socket_ip_ptr =  ip_ptr;
 8010634:	68bb      	ldr	r3, [r7, #8]
 8010636:	68fa      	ldr	r2, [r7, #12]
 8010638:	60da      	str	r2, [r3, #12]

    /* Save the UDP socket's name.  */
    socket_ptr -> nx_udp_socket_name =  name;
 801063a:	68bb      	ldr	r3, [r7, #8]
 801063c:	687a      	ldr	r2, [r7, #4]
 801063e:	605a      	str	r2, [r3, #4]

    /* Save the type of service input parameter.  */
    socket_ptr -> nx_udp_socket_type_of_service =  type_of_service;
 8010640:	68bb      	ldr	r3, [r7, #8]
 8010642:	683a      	ldr	r2, [r7, #0]
 8010644:	62da      	str	r2, [r3, #44]	; 0x2c

    /* Save the fragment input parameter.  */
    socket_ptr -> nx_udp_socket_fragment_enable =  fragment & NX_DONT_FRAGMENT;
 8010646:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8010648:	f403 4280 	and.w	r2, r3, #16384	; 0x4000
 801064c:	68bb      	ldr	r3, [r7, #8]
 801064e:	635a      	str	r2, [r3, #52]	; 0x34

    /* Save the time-to-live input parameter.  */
    socket_ptr -> nx_udp_socket_time_to_live =  time_to_live;
 8010650:	68bb      	ldr	r3, [r7, #8]
 8010652:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 8010654:	631a      	str	r2, [r3, #48]	; 0x30

    /* By default, have UDP checksum logic enabled.  To disable checksum logic, the
       application must call the nx_udp_checksum disable function for this UDP socket.  */
    socket_ptr -> nx_udp_socket_disable_checksum =  NX_FALSE;
 8010656:	68bb      	ldr	r3, [r7, #8]
 8010658:	2200      	movs	r2, #0
 801065a:	639a      	str	r2, [r3, #56]	; 0x38

    /* Clear the socket bind in progress flag.  */
    socket_ptr -> nx_udp_socket_bind_in_progress =  NX_FALSE;
 801065c:	68bb      	ldr	r3, [r7, #8]
 801065e:	2200      	movs	r2, #0
 8010660:	655a      	str	r2, [r3, #84]	; 0x54

    /* Set various list pointers to NULL.  */
    socket_ptr -> nx_udp_socket_bound_next =            NX_NULL;
 8010662:	68bb      	ldr	r3, [r7, #8]
 8010664:	2200      	movs	r2, #0
 8010666:	64da      	str	r2, [r3, #76]	; 0x4c
    socket_ptr -> nx_udp_socket_bound_previous =        NX_NULL;
 8010668:	68bb      	ldr	r3, [r7, #8]
 801066a:	2200      	movs	r2, #0
 801066c:	651a      	str	r2, [r3, #80]	; 0x50
    socket_ptr -> nx_udp_socket_bind_suspension_list =  NX_NULL;
 801066e:	68bb      	ldr	r3, [r7, #8]
 8010670:	2200      	movs	r2, #0
 8010672:	661a      	str	r2, [r3, #96]	; 0x60
    socket_ptr -> nx_udp_socket_bind_suspended_count =  0;
 8010674:	68bb      	ldr	r3, [r7, #8]
 8010676:	2200      	movs	r2, #0
 8010678:	665a      	str	r2, [r3, #100]	; 0x64

    /* Initialize the receive queue parameters.  */
    socket_ptr -> nx_udp_socket_receive_count =         0;
 801067a:	68bb      	ldr	r3, [r7, #8]
 801067c:	2200      	movs	r2, #0
 801067e:	63da      	str	r2, [r3, #60]	; 0x3c
    socket_ptr -> nx_udp_socket_queue_maximum =         queue_maximum;
 8010680:	68bb      	ldr	r3, [r7, #8]
 8010682:	6bba      	ldr	r2, [r7, #56]	; 0x38
 8010684:	641a      	str	r2, [r3, #64]	; 0x40
    socket_ptr -> nx_udp_socket_receive_head =          NX_NULL;
 8010686:	68bb      	ldr	r3, [r7, #8]
 8010688:	2200      	movs	r2, #0
 801068a:	645a      	str	r2, [r3, #68]	; 0x44
    socket_ptr -> nx_udp_socket_receive_tail =          NX_NULL;
 801068c:	68bb      	ldr	r3, [r7, #8]
 801068e:	2200      	movs	r2, #0
 8010690:	649a      	str	r2, [r3, #72]	; 0x48

    /* Clear the receive notify function pointer.  */
    socket_ptr -> nx_udp_receive_callback =             NX_NULL;
 8010692:	68bb      	ldr	r3, [r7, #8]
 8010694:	2200      	movs	r2, #0
 8010696:	671a      	str	r2, [r3, #112]	; 0x70

    /* If trace is enabled, insert this event into the trace buffer.  */
    NX_TRACE_IN_LINE_INSERT(NX_TRACE_UDP_SOCKET_CREATE, ip_ptr, socket_ptr, type_of_service, queue_maximum, NX_TRACE_IP_EVENTS, 0, 0);

    /* Obtain the IP mutex so we can add socket to IP structure.  */
    tx_mutex_get(&(ip_ptr -> nx_ip_protection), TX_WAIT_FOREVER);
 8010698:	68fb      	ldr	r3, [r7, #12]
 801069a:	f503 739e 	add.w	r3, r3, #316	; 0x13c
 801069e:	f04f 31ff 	mov.w	r1, #4294967295
 80106a2:	4618      	mov	r0, r3
 80106a4:	f002 fb66 	bl	8012d74 <_tx_mutex_get>
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 80106a8:	f3ef 8310 	mrs	r3, PRIMASK
 80106ac:	61fb      	str	r3, [r7, #28]
    return(posture);
 80106ae:	69fb      	ldr	r3, [r7, #28]
    int_posture = __get_interrupt_posture();
 80106b0:	61bb      	str	r3, [r7, #24]
    __asm__ volatile ("CPSID i" : : : "memory");
 80106b2:	b672      	cpsid	i
    return(int_posture);
 80106b4:	69bb      	ldr	r3, [r7, #24]

    /* Disable interrupts while we link the new UDP socket to the IP structure.  */
    TX_DISABLE
 80106b6:	627b      	str	r3, [r7, #36]	; 0x24

    /* Load the UDP ID field in the UDP control block.  */
    socket_ptr -> nx_udp_socket_id =  NX_UDP_ID;
 80106b8:	68bb      	ldr	r3, [r7, #8]
 80106ba:	4a1f      	ldr	r2, [pc, #124]	; (8010738 <_nx_udp_socket_create+0x11c>)
 80106bc:	601a      	str	r2, [r3, #0]

    /* Place the new UDP control block on the list of created UDP sockets for this IP.  First,
       check for an empty list.  */
    if (ip_ptr -> nx_ip_udp_created_sockets_ptr)
 80106be:	68fb      	ldr	r3, [r7, #12]
 80106c0:	f8d3 3400 	ldr.w	r3, [r3, #1024]	; 0x400
 80106c4:	2b00      	cmp	r3, #0
 80106c6:	d015      	beq.n	80106f4 <_nx_udp_socket_create+0xd8>
    {

        /* Pickup tail pointer.  */
        tail_ptr =  (ip_ptr -> nx_ip_udp_created_sockets_ptr) -> nx_udp_socket_created_previous;
 80106c8:	68fb      	ldr	r3, [r7, #12]
 80106ca:	f8d3 3400 	ldr.w	r3, [r3, #1024]	; 0x400
 80106ce:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 80106d0:	623b      	str	r3, [r7, #32]

        /* Place the new UDP socket control block in the list.  */
        (ip_ptr -> nx_ip_udp_created_sockets_ptr) -> nx_udp_socket_created_previous =  socket_ptr;
 80106d2:	68fb      	ldr	r3, [r7, #12]
 80106d4:	f8d3 3400 	ldr.w	r3, [r3, #1024]	; 0x400
 80106d8:	68ba      	ldr	r2, [r7, #8]
 80106da:	66da      	str	r2, [r3, #108]	; 0x6c
        tail_ptr ->  nx_udp_socket_created_next =  socket_ptr;
 80106dc:	6a3b      	ldr	r3, [r7, #32]
 80106de:	68ba      	ldr	r2, [r7, #8]
 80106e0:	669a      	str	r2, [r3, #104]	; 0x68

        /* Setup this UDP socket's created links.  */
        socket_ptr -> nx_udp_socket_created_previous =  tail_ptr;
 80106e2:	68bb      	ldr	r3, [r7, #8]
 80106e4:	6a3a      	ldr	r2, [r7, #32]
 80106e6:	66da      	str	r2, [r3, #108]	; 0x6c
        socket_ptr -> nx_udp_socket_created_next =      ip_ptr -> nx_ip_udp_created_sockets_ptr;
 80106e8:	68fb      	ldr	r3, [r7, #12]
 80106ea:	f8d3 2400 	ldr.w	r2, [r3, #1024]	; 0x400
 80106ee:	68bb      	ldr	r3, [r7, #8]
 80106f0:	669a      	str	r2, [r3, #104]	; 0x68
 80106f2:	e009      	b.n	8010708 <_nx_udp_socket_create+0xec>
    }
    else
    {

        /* The created UDP socket list is empty.  Add UDP socket control block to empty list.  */
        ip_ptr -> nx_ip_udp_created_sockets_ptr =       socket_ptr;
 80106f4:	68fb      	ldr	r3, [r7, #12]
 80106f6:	68ba      	ldr	r2, [r7, #8]
 80106f8:	f8c3 2400 	str.w	r2, [r3, #1024]	; 0x400
        socket_ptr -> nx_udp_socket_created_previous =  socket_ptr;
 80106fc:	68bb      	ldr	r3, [r7, #8]
 80106fe:	68ba      	ldr	r2, [r7, #8]
 8010700:	66da      	str	r2, [r3, #108]	; 0x6c
        socket_ptr -> nx_udp_socket_created_next =      socket_ptr;
 8010702:	68bb      	ldr	r3, [r7, #8]
 8010704:	68ba      	ldr	r2, [r7, #8]
 8010706:	669a      	str	r2, [r3, #104]	; 0x68
    }

    /* Increment the created UDP socket counter.  */
    ip_ptr -> nx_ip_udp_created_sockets_count++;
 8010708:	68fb      	ldr	r3, [r7, #12]
 801070a:	f8d3 3404 	ldr.w	r3, [r3, #1028]	; 0x404
 801070e:	1c5a      	adds	r2, r3, #1
 8010710:	68fb      	ldr	r3, [r7, #12]
 8010712:	f8c3 2404 	str.w	r2, [r3, #1028]	; 0x404
 8010716:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8010718:	617b      	str	r3, [r7, #20]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 801071a:	697b      	ldr	r3, [r7, #20]
 801071c:	f383 8810 	msr	PRIMASK, r3
}
 8010720:	bf00      	nop

    /* Restore previous interrupt posture.  */
    TX_RESTORE

    /* Release the IP protection mutex.  */
    tx_mutex_put(&(ip_ptr -> nx_ip_protection));
 8010722:	68fb      	ldr	r3, [r7, #12]
 8010724:	f503 739e 	add.w	r3, r3, #316	; 0x13c
 8010728:	4618      	mov	r0, r3
 801072a:	f002 fd9b 	bl	8013264 <_tx_mutex_put>

    /* Return successful completion.  */
    return(NX_SUCCESS);
 801072e:	2300      	movs	r3, #0
}
 8010730:	4618      	mov	r0, r3
 8010732:	3728      	adds	r7, #40	; 0x28
 8010734:	46bd      	mov	sp, r7
 8010736:	bd80      	pop	{r7, pc}
 8010738:	55445020 	.word	0x55445020

0801073c <_nx_udp_socket_delete>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
UINT  _nx_udp_socket_delete(NX_UDP_SOCKET *socket_ptr)
{
 801073c:	b580      	push	{r7, lr}
 801073e:	b088      	sub	sp, #32
 8010740:	af00      	add	r7, sp, #0
 8010742:	6078      	str	r0, [r7, #4]

NX_IP *ip_ptr;


    /* Setup the pointer to the associated IP instance.  */
    ip_ptr =  socket_ptr -> nx_udp_socket_ip_ptr;
 8010744:	687b      	ldr	r3, [r7, #4]
 8010746:	68db      	ldr	r3, [r3, #12]
 8010748:	61fb      	str	r3, [r7, #28]

    /* If trace is enabled, insert this event into the trace buffer.  */
    NX_TRACE_IN_LINE_INSERT(NX_TRACE_UDP_SOCKET_DELETE, ip_ptr, socket_ptr, 0, 0, NX_TRACE_UDP_EVENTS, 0, 0);

    /* Obtain the IP mutex so we can process the socket delete request.  */
    tx_mutex_get(&(ip_ptr -> nx_ip_protection), TX_WAIT_FOREVER);
 801074a:	69fb      	ldr	r3, [r7, #28]
 801074c:	f503 739e 	add.w	r3, r3, #316	; 0x13c
 8010750:	f04f 31ff 	mov.w	r1, #4294967295
 8010754:	4618      	mov	r0, r3
 8010756:	f002 fb0d 	bl	8012d74 <_tx_mutex_get>

    /* Determine if the socket is still bound to port.  */
    if (socket_ptr -> nx_udp_socket_bound_next)
 801075a:	687b      	ldr	r3, [r7, #4]
 801075c:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 801075e:	2b00      	cmp	r3, #0
 8010760:	d007      	beq.n	8010772 <_nx_udp_socket_delete+0x36>
    {

        /* Release the protection mutex.  */
        tx_mutex_put(&(ip_ptr -> nx_ip_protection));
 8010762:	69fb      	ldr	r3, [r7, #28]
 8010764:	f503 739e 	add.w	r3, r3, #316	; 0x13c
 8010768:	4618      	mov	r0, r3
 801076a:	f002 fd7b 	bl	8013264 <_tx_mutex_put>

        /* Return a still bound error code.  */
        return(NX_STILL_BOUND);
 801076e:	2342      	movs	r3, #66	; 0x42
 8010770:	e03f      	b.n	80107f2 <_nx_udp_socket_delete+0xb6>
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 8010772:	f3ef 8310 	mrs	r3, PRIMASK
 8010776:	617b      	str	r3, [r7, #20]
    return(posture);
 8010778:	697b      	ldr	r3, [r7, #20]
    int_posture = __get_interrupt_posture();
 801077a:	613b      	str	r3, [r7, #16]
    __asm__ volatile ("CPSID i" : : : "memory");
 801077c:	b672      	cpsid	i
    return(int_posture);
 801077e:	693b      	ldr	r3, [r7, #16]
    }

    /* Disable interrupts.  */
    TX_DISABLE
 8010780:	61bb      	str	r3, [r7, #24]

    /* Now, remove the UDP socket from the created socket list.  */

    /* Clear the socket ID to make it invalid.  */
    socket_ptr -> nx_udp_socket_id =  0;
 8010782:	687b      	ldr	r3, [r7, #4]
 8010784:	2200      	movs	r2, #0
 8010786:	601a      	str	r2, [r3, #0]

    /* See if the socket is the only one on the list.  */
    if (socket_ptr == socket_ptr -> nx_udp_socket_created_next)
 8010788:	687b      	ldr	r3, [r7, #4]
 801078a:	6e9b      	ldr	r3, [r3, #104]	; 0x68
 801078c:	687a      	ldr	r2, [r7, #4]
 801078e:	429a      	cmp	r2, r3
 8010790:	d104      	bne.n	801079c <_nx_udp_socket_delete+0x60>
    {

        /* Only created socket, just set the created list to NULL.  */
        ip_ptr -> nx_ip_udp_created_sockets_ptr =  NX_NULL;
 8010792:	69fb      	ldr	r3, [r7, #28]
 8010794:	2200      	movs	r2, #0
 8010796:	f8c3 2400 	str.w	r2, [r3, #1024]	; 0x400
 801079a:	e014      	b.n	80107c6 <_nx_udp_socket_delete+0x8a>
    }
    else
    {

        /* Link-up the neighbors.  */
        (socket_ptr -> nx_udp_socket_created_next) -> nx_udp_socket_created_previous =
 801079c:	687b      	ldr	r3, [r7, #4]
 801079e:	6e9b      	ldr	r3, [r3, #104]	; 0x68
            socket_ptr -> nx_udp_socket_created_previous;
 80107a0:	687a      	ldr	r2, [r7, #4]
 80107a2:	6ed2      	ldr	r2, [r2, #108]	; 0x6c
        (socket_ptr -> nx_udp_socket_created_next) -> nx_udp_socket_created_previous =
 80107a4:	66da      	str	r2, [r3, #108]	; 0x6c
        (socket_ptr -> nx_udp_socket_created_previous) -> nx_udp_socket_created_next =
 80107a6:	687b      	ldr	r3, [r7, #4]
 80107a8:	6edb      	ldr	r3, [r3, #108]	; 0x6c
            socket_ptr -> nx_udp_socket_created_next;
 80107aa:	687a      	ldr	r2, [r7, #4]
 80107ac:	6e92      	ldr	r2, [r2, #104]	; 0x68
        (socket_ptr -> nx_udp_socket_created_previous) -> nx_udp_socket_created_next =
 80107ae:	669a      	str	r2, [r3, #104]	; 0x68

        /* See if we have to update the created list head pointer.  */
        if (ip_ptr -> nx_ip_udp_created_sockets_ptr == socket_ptr)
 80107b0:	69fb      	ldr	r3, [r7, #28]
 80107b2:	f8d3 3400 	ldr.w	r3, [r3, #1024]	; 0x400
 80107b6:	687a      	ldr	r2, [r7, #4]
 80107b8:	429a      	cmp	r2, r3
 80107ba:	d104      	bne.n	80107c6 <_nx_udp_socket_delete+0x8a>
        {

            /* Yes, move the head pointer to the next link. */
            ip_ptr -> nx_ip_udp_created_sockets_ptr =  socket_ptr -> nx_udp_socket_created_next;
 80107bc:	687b      	ldr	r3, [r7, #4]
 80107be:	6e9a      	ldr	r2, [r3, #104]	; 0x68
 80107c0:	69fb      	ldr	r3, [r7, #28]
 80107c2:	f8c3 2400 	str.w	r2, [r3, #1024]	; 0x400
        }
    }

    /* Decrease the created sockets count.  */
    ip_ptr -> nx_ip_udp_created_sockets_count--;
 80107c6:	69fb      	ldr	r3, [r7, #28]
 80107c8:	f8d3 3404 	ldr.w	r3, [r3, #1028]	; 0x404
 80107cc:	1e5a      	subs	r2, r3, #1
 80107ce:	69fb      	ldr	r3, [r7, #28]
 80107d0:	f8c3 2404 	str.w	r2, [r3, #1028]	; 0x404
 80107d4:	69bb      	ldr	r3, [r7, #24]
 80107d6:	60fb      	str	r3, [r7, #12]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 80107d8:	68fb      	ldr	r3, [r7, #12]
 80107da:	f383 8810 	msr	PRIMASK, r3
}
 80107de:	bf00      	nop

    /* If trace is enabled, unregister this object.  */
    NX_TRACE_OBJECT_UNREGISTER(socket_ptr);

    /* Release the IP protection mutex.  */
    tx_mutex_put(&(ip_ptr -> nx_ip_protection));
 80107e0:	69fb      	ldr	r3, [r7, #28]
 80107e2:	f503 739e 	add.w	r3, r3, #316	; 0x13c
 80107e6:	4618      	mov	r0, r3
 80107e8:	f002 fd3c 	bl	8013264 <_tx_mutex_put>

    /* Check for preemption.  */
    _tx_thread_system_preempt_check();
 80107ec:	f004 fa62 	bl	8014cb4 <_tx_thread_system_preempt_check>

    /* Return success.  */
    return(NX_SUCCESS);
 80107f0:	2300      	movs	r3, #0
}
 80107f2:	4618      	mov	r0, r3
 80107f4:	3720      	adds	r7, #32
 80107f6:	46bd      	mov	sp, r7
 80107f8:	bd80      	pop	{r7, pc}
	...

080107fc <_nx_udp_socket_receive>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
UINT  _nx_udp_socket_receive(NX_UDP_SOCKET *socket_ptr, NX_PACKET **packet_ptr, ULONG wait_option)
{
 80107fc:	b580      	push	{r7, lr}
 80107fe:	b098      	sub	sp, #96	; 0x60
 8010800:	af02      	add	r7, sp, #8
 8010802:	60f8      	str	r0, [r7, #12]
 8010804:	60b9      	str	r1, [r7, #8]
 8010806:	607a      	str	r2, [r7, #4]

    /* If trace is enabled, insert this event into the trace buffer.  */
    NX_TRACE_IN_LINE_INSERT(NX_TRACE_UDP_SOCKET_RECEIVE, socket_ptr -> nx_udp_socket_ip_ptr, socket_ptr, 0, 0, NX_TRACE_UDP_EVENTS, &trace_event, &trace_timestamp);

    /* Set the return pointer to NULL initially.  */
    *packet_ptr =   NX_NULL;
 8010808:	68bb      	ldr	r3, [r7, #8]
 801080a:	2200      	movs	r2, #0
 801080c:	601a      	str	r2, [r3, #0]
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 801080e:	f3ef 8310 	mrs	r3, PRIMASK
 8010812:	633b      	str	r3, [r7, #48]	; 0x30
    return(posture);
 8010814:	6b3b      	ldr	r3, [r7, #48]	; 0x30
    int_posture = __get_interrupt_posture();
 8010816:	62fb      	str	r3, [r7, #44]	; 0x2c
    __asm__ volatile ("CPSID i" : : : "memory");
 8010818:	b672      	cpsid	i
    return(int_posture);
 801081a:	6afb      	ldr	r3, [r7, #44]	; 0x2c
    /* Loop to retrieve a packet from the interface.  */
    for (;;)
    {

        /* Lockout interrupts.  */
        TX_DISABLE
 801081c:	64fb      	str	r3, [r7, #76]	; 0x4c

        /* Determine if the socket is currently bound.  */
        if (!socket_ptr ->  nx_udp_socket_bound_next)
 801081e:	68fb      	ldr	r3, [r7, #12]
 8010820:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 8010822:	2b00      	cmp	r3, #0
 8010824:	d107      	bne.n	8010836 <_nx_udp_socket_receive+0x3a>
 8010826:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8010828:	62bb      	str	r3, [r7, #40]	; 0x28
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 801082a:	6abb      	ldr	r3, [r7, #40]	; 0x28
 801082c:	f383 8810 	msr	PRIMASK, r3
}
 8010830:	bf00      	nop

            /* Restore interrupts.  */
            TX_RESTORE

            /* Socket is not bound, return an error message.  */
            return(NX_NOT_BOUND);
 8010832:	2324      	movs	r3, #36	; 0x24
 8010834:	e12a      	b.n	8010a8c <_nx_udp_socket_receive+0x290>
        }

        /* Determine if there is a packet already queued up for this socket.  */
        if (socket_ptr -> nx_udp_socket_receive_head)
 8010836:	68fb      	ldr	r3, [r7, #12]
 8010838:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 801083a:	2b00      	cmp	r3, #0
 801083c:	d01a      	beq.n	8010874 <_nx_udp_socket_receive+0x78>
        {

            /* Yes, there is a packet waiting.  */

            /* Remove it and place it in the thread's destination.  */
            *packet_ptr =  socket_ptr -> nx_udp_socket_receive_head;
 801083e:	68fb      	ldr	r3, [r7, #12]
 8010840:	6c5a      	ldr	r2, [r3, #68]	; 0x44
 8010842:	68bb      	ldr	r3, [r7, #8]
 8010844:	601a      	str	r2, [r3, #0]
            socket_ptr -> nx_udp_socket_receive_head =  (*packet_ptr) -> nx_packet_queue_next;
 8010846:	68bb      	ldr	r3, [r7, #8]
 8010848:	681b      	ldr	r3, [r3, #0]
 801084a:	69da      	ldr	r2, [r3, #28]
 801084c:	68fb      	ldr	r3, [r7, #12]
 801084e:	645a      	str	r2, [r3, #68]	; 0x44

            /* If this was the last packet, set the tail pointer to NULL.  */
            if (socket_ptr -> nx_udp_socket_receive_head == NX_NULL)
 8010850:	68fb      	ldr	r3, [r7, #12]
 8010852:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 8010854:	2b00      	cmp	r3, #0
 8010856:	d102      	bne.n	801085e <_nx_udp_socket_receive+0x62>
            {
                socket_ptr -> nx_udp_socket_receive_tail =  NX_NULL;
 8010858:	68fb      	ldr	r3, [r7, #12]
 801085a:	2200      	movs	r2, #0
 801085c:	649a      	str	r2, [r3, #72]	; 0x48
            }

            /* Decrease the queued packet count.  */
            socket_ptr -> nx_udp_socket_receive_count--;
 801085e:	68fb      	ldr	r3, [r7, #12]
 8010860:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 8010862:	1e5a      	subs	r2, r3, #1
 8010864:	68fb      	ldr	r3, [r7, #12]
 8010866:	63da      	str	r2, [r3, #60]	; 0x3c
 8010868:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 801086a:	627b      	str	r3, [r7, #36]	; 0x24
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 801086c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801086e:	f383 8810 	msr	PRIMASK, r3
}
 8010872:	e05e      	b.n	8010932 <_nx_udp_socket_receive+0x136>
        }
        else
        {

            /* Determine if the request specifies suspension.  */
            if (wait_option)
 8010874:	687b      	ldr	r3, [r7, #4]
 8010876:	2b00      	cmp	r3, #0
 8010878:	d050      	beq.n	801091c <_nx_udp_socket_receive+0x120>
            {

                /* Prepare for suspension of this thread.  */

                /* Pickup thread pointer.  */
                thread_ptr =  _tx_thread_current_ptr;
 801087a:	4b86      	ldr	r3, [pc, #536]	; (8010a94 <_nx_udp_socket_receive+0x298>)
 801087c:	681b      	ldr	r3, [r3, #0]
 801087e:	64bb      	str	r3, [r7, #72]	; 0x48

                /* Setup cleanup routine pointer.  */
                thread_ptr -> tx_thread_suspend_cleanup =  _nx_udp_receive_cleanup;
 8010880:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 8010882:	4a85      	ldr	r2, [pc, #532]	; (8010a98 <_nx_udp_socket_receive+0x29c>)
 8010884:	669a      	str	r2, [r3, #104]	; 0x68

                /* Setup cleanup information, i.e. this pool control
                   block.  */
                thread_ptr -> tx_thread_suspend_control_block =  (void *)socket_ptr;
 8010886:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 8010888:	68fa      	ldr	r2, [r7, #12]
 801088a:	66da      	str	r2, [r3, #108]	; 0x6c

                /* Save the return packet pointer address as well.  */
                thread_ptr -> tx_thread_additional_suspend_info =  (void *)packet_ptr;
 801088c:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 801088e:	68ba      	ldr	r2, [r7, #8]
 8010890:	67da      	str	r2, [r3, #124]	; 0x7c

                /* Setup suspension list.  */
                if (socket_ptr -> nx_udp_socket_receive_suspension_list)
 8010892:	68fb      	ldr	r3, [r7, #12]
 8010894:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 8010896:	2b00      	cmp	r3, #0
 8010898:	d012      	beq.n	80108c0 <_nx_udp_socket_receive+0xc4>
                {

                    /* This list is not NULL, add current thread to the end. */
                    thread_ptr -> tx_thread_suspended_next =
                        socket_ptr -> nx_udp_socket_receive_suspension_list;
 801089a:	68fb      	ldr	r3, [r7, #12]
 801089c:	6d9a      	ldr	r2, [r3, #88]	; 0x58
                    thread_ptr -> tx_thread_suspended_next =
 801089e:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 80108a0:	671a      	str	r2, [r3, #112]	; 0x70
                    thread_ptr -> tx_thread_suspended_previous =
                        (socket_ptr -> nx_udp_socket_receive_suspension_list) -> tx_thread_suspended_previous;
 80108a2:	68fb      	ldr	r3, [r7, #12]
 80108a4:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 80108a6:	6f5a      	ldr	r2, [r3, #116]	; 0x74
                    thread_ptr -> tx_thread_suspended_previous =
 80108a8:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 80108aa:	675a      	str	r2, [r3, #116]	; 0x74
                    ((socket_ptr -> nx_udp_socket_receive_suspension_list) -> tx_thread_suspended_previous) -> tx_thread_suspended_next =
 80108ac:	68fb      	ldr	r3, [r7, #12]
 80108ae:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 80108b0:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 80108b2:	6cba      	ldr	r2, [r7, #72]	; 0x48
 80108b4:	671a      	str	r2, [r3, #112]	; 0x70
                        thread_ptr;
                    (socket_ptr -> nx_udp_socket_receive_suspension_list) -> tx_thread_suspended_previous =   thread_ptr;
 80108b6:	68fb      	ldr	r3, [r7, #12]
 80108b8:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 80108ba:	6cba      	ldr	r2, [r7, #72]	; 0x48
 80108bc:	675a      	str	r2, [r3, #116]	; 0x74
 80108be:	e008      	b.n	80108d2 <_nx_udp_socket_receive+0xd6>
                else
                {

                    /* No other threads are suspended.  Setup the head pointer and
                       just setup this threads pointers to itself.  */
                    socket_ptr -> nx_udp_socket_receive_suspension_list =   thread_ptr;
 80108c0:	68fb      	ldr	r3, [r7, #12]
 80108c2:	6cba      	ldr	r2, [r7, #72]	; 0x48
 80108c4:	659a      	str	r2, [r3, #88]	; 0x58
                    thread_ptr -> tx_thread_suspended_next              =   thread_ptr;
 80108c6:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 80108c8:	6cba      	ldr	r2, [r7, #72]	; 0x48
 80108ca:	671a      	str	r2, [r3, #112]	; 0x70
                    thread_ptr -> tx_thread_suspended_previous          =   thread_ptr;
 80108cc:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 80108ce:	6cba      	ldr	r2, [r7, #72]	; 0x48
 80108d0:	675a      	str	r2, [r3, #116]	; 0x74
                }

                /* Increment the suspended thread count.  */
                socket_ptr -> nx_udp_socket_receive_suspended_count++;
 80108d2:	68fb      	ldr	r3, [r7, #12]
 80108d4:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
 80108d6:	1c5a      	adds	r2, r3, #1
 80108d8:	68fb      	ldr	r3, [r7, #12]
 80108da:	65da      	str	r2, [r3, #92]	; 0x5c

                /* Set the state to suspended.  */
                thread_ptr -> tx_thread_state =  TX_TCP_IP;
 80108dc:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 80108de:	220c      	movs	r2, #12
 80108e0:	631a      	str	r2, [r3, #48]	; 0x30

                /* Set the suspending flag.  */
                thread_ptr -> tx_thread_suspending =  TX_TRUE;
 80108e2:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 80108e4:	2201      	movs	r2, #1
 80108e6:	639a      	str	r2, [r3, #56]	; 0x38

                /* Temporarily disable preemption.  */
                _tx_thread_preempt_disable++;
 80108e8:	4b6c      	ldr	r3, [pc, #432]	; (8010a9c <_nx_udp_socket_receive+0x2a0>)
 80108ea:	681b      	ldr	r3, [r3, #0]
 80108ec:	3301      	adds	r3, #1
 80108ee:	4a6b      	ldr	r2, [pc, #428]	; (8010a9c <_nx_udp_socket_receive+0x2a0>)
 80108f0:	6013      	str	r3, [r2, #0]

                /* Save the timeout value.  */
                thread_ptr -> tx_thread_timer.tx_timer_internal_remaining_ticks =  wait_option;
 80108f2:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 80108f4:	687a      	ldr	r2, [r7, #4]
 80108f6:	64da      	str	r2, [r3, #76]	; 0x4c
 80108f8:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 80108fa:	623b      	str	r3, [r7, #32]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 80108fc:	6a3b      	ldr	r3, [r7, #32]
 80108fe:	f383 8810 	msr	PRIMASK, r3
}
 8010902:	bf00      	nop

                /* Restore interrupts.  */
                TX_RESTORE

                /* Call actual thread suspension routine.  */
                _tx_thread_system_suspend(thread_ptr);
 8010904:	6cb8      	ldr	r0, [r7, #72]	; 0x48
 8010906:	f004 fb0f 	bl	8014f28 <_tx_thread_system_suspend>

                /* Determine if a packet was received successfully.  */
                if (thread_ptr -> tx_thread_suspend_status != NX_SUCCESS)
 801090a:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 801090c:	f8d3 3084 	ldr.w	r3, [r3, #132]	; 0x84
 8010910:	2b00      	cmp	r3, #0
 8010912:	d00e      	beq.n	8010932 <_nx_udp_socket_receive+0x136>
                {

                    /* If not, just return the error code.  */
                    return(thread_ptr -> tx_thread_suspend_status);
 8010914:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 8010916:	f8d3 3084 	ldr.w	r3, [r3, #132]	; 0x84
 801091a:	e0b7      	b.n	8010a8c <_nx_udp_socket_receive+0x290>
 801091c:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 801091e:	61fb      	str	r3, [r7, #28]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 8010920:	69fb      	ldr	r3, [r7, #28]
 8010922:	f383 8810 	msr	PRIMASK, r3
}
 8010926:	bf00      	nop

                /* Restore interrupts.  */
                TX_RESTORE

                /* Set the return pointer to NULL in case it was set but released due to checksum error.  */
                *packet_ptr =   NX_NULL;
 8010928:	68bb      	ldr	r3, [r7, #8]
 801092a:	2200      	movs	r2, #0
 801092c:	601a      	str	r2, [r3, #0]

                /* Immediate return, return error completion.  */
                return(NX_NO_PACKET);
 801092e:	2301      	movs	r3, #1
 8010930:	e0ac      	b.n	8010a8c <_nx_udp_socket_receive+0x290>

            /* Determine if we need to compute the UDP checksum.  If it is disabled for this socket
               or if the UDP packet has a zero in the checksum field (indicating it was not computed
               by the sender, skip the checksum processing.  */
            /*lint -e{927} -e{826} suppress cast of pointer to pointer, since it is necessary  */
            temp_ptr =  (ULONG *)(*packet_ptr) -> nx_packet_prepend_ptr;
 8010932:	68bb      	ldr	r3, [r7, #8]
 8010934:	681b      	ldr	r3, [r3, #0]
 8010936:	689b      	ldr	r3, [r3, #8]
 8010938:	647b      	str	r3, [r7, #68]	; 0x44
            if ((!socket_ptr -> nx_udp_socket_disable_checksum && (*(temp_ptr + 1) & NX_LOWER_16_MASK)) || /* per-socket checksum is not disabled, and the checksum field is not zero*/
 801093a:	68fb      	ldr	r3, [r7, #12]
 801093c:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 801093e:	2b00      	cmp	r3, #0
 8010940:	d105      	bne.n	801094e <_nx_udp_socket_receive+0x152>
 8010942:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8010944:	3304      	adds	r3, #4
 8010946:	681b      	ldr	r3, [r3, #0]
 8010948:	b29b      	uxth	r3, r3
 801094a:	2b00      	cmp	r3, #0
 801094c:	d106      	bne.n	801095c <_nx_udp_socket_receive+0x160>
                ((*packet_ptr) -> nx_packet_ip_version == NX_IP_VERSION_V6))                               /* It is IPv6 packet */
 801094e:	68bb      	ldr	r3, [r7, #8]
 8010950:	681b      	ldr	r3, [r3, #0]
 8010952:	f893 302c 	ldrb.w	r3, [r3, #44]	; 0x2c
            if ((!socket_ptr -> nx_udp_socket_disable_checksum && (*(temp_ptr + 1) & NX_LOWER_16_MASK)) || /* per-socket checksum is not disabled, and the checksum field is not zero*/
 8010956:	2b06      	cmp	r3, #6
 8010958:	f040 8089 	bne.w	8010a6e <_nx_udp_socket_receive+0x272>
            {
            ULONG         *ip_src_addr = NX_NULL, *ip_dest_addr = NX_NULL;
 801095c:	2300      	movs	r3, #0
 801095e:	657b      	str	r3, [r7, #84]	; 0x54
 8010960:	2300      	movs	r3, #0
 8010962:	653b      	str	r3, [r7, #80]	; 0x50
            ULONG          checksum;
            NX_PACKET     *current_ptr = *packet_ptr;
 8010964:	68bb      	ldr	r3, [r7, #8]
 8010966:	681b      	ldr	r3, [r3, #0]
 8010968:	643b      	str	r3, [r7, #64]	; 0x40
#ifdef NX_LITTLE_ENDIAN
            NX_UDP_HEADER *udp_header_ptr;

                /*lint -e{927} -e{826} suppress cast of pointer to pointer, since it is necessary  */
                udp_header_ptr = (NX_UDP_HEADER *)(current_ptr -> nx_packet_prepend_ptr);
 801096a:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 801096c:	689b      	ldr	r3, [r3, #8]
 801096e:	63fb      	str	r3, [r7, #60]	; 0x3c
#endif /* NX_LITTLE_ENDIAN */

#ifndef NX_DISABLE_IPV4
                if (current_ptr -> nx_packet_ip_version == NX_IP_VERSION_V4)
 8010970:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8010972:	f893 302c 	ldrb.w	r3, [r3, #44]	; 0x2c
 8010976:	2b04      	cmp	r3, #4
 8010978:	d108      	bne.n	801098c <_nx_udp_socket_receive+0x190>
                {
                NX_IPV4_HEADER *ipv4_header;

                    /*lint -e{927} -e{826} suppress cast of pointer to pointer, since it is necessary  */
                    ipv4_header = (NX_IPV4_HEADER *)(current_ptr -> nx_packet_ip_header);
 801097a:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 801097c:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 801097e:	63bb      	str	r3, [r7, #56]	; 0x38
                    ip_src_addr = &(ipv4_header -> nx_ip_header_source_ip);
 8010980:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8010982:	330c      	adds	r3, #12
 8010984:	657b      	str	r3, [r7, #84]	; 0x54
                    ip_dest_addr = &(ipv4_header -> nx_ip_header_destination_ip);
 8010986:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8010988:	3310      	adds	r3, #16
 801098a:	653b      	str	r3, [r7, #80]	; 0x50

#endif /* FEATURE_NX_IPV6 */

#ifdef NX_LITTLE_ENDIAN
                /* Restore UDP header to network byte order */
                NX_CHANGE_ULONG_ENDIAN(udp_header_ptr -> nx_udp_header_word_0);
 801098c:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 801098e:	681b      	ldr	r3, [r3, #0]
 8010990:	ba1a      	rev	r2, r3
 8010992:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8010994:	601a      	str	r2, [r3, #0]
                NX_CHANGE_ULONG_ENDIAN(udp_header_ptr -> nx_udp_header_word_1);
 8010996:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8010998:	685b      	ldr	r3, [r3, #4]
 801099a:	ba1a      	rev	r2, r3
 801099c:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 801099e:	605a      	str	r2, [r3, #4]
#endif /* NX_LITTLE_ENDIAN */

                /* nx_ip_checksum_compute takes care of both even number length and odd number length */
                /* Compute the checksum of the first packet */
                checksum = _nx_ip_checksum_compute(current_ptr, NX_PROTOCOL_UDP,
                                                   (UINT)current_ptr -> nx_packet_length,
 80109a0:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 80109a2:	6a5a      	ldr	r2, [r3, #36]	; 0x24
                checksum = _nx_ip_checksum_compute(current_ptr, NX_PROTOCOL_UDP,
 80109a4:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 80109a6:	9300      	str	r3, [sp, #0]
 80109a8:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 80109aa:	2111      	movs	r1, #17
 80109ac:	6c38      	ldr	r0, [r7, #64]	; 0x40
 80109ae:	f7f9 f93b 	bl	8009c28 <_nx_ip_checksum_compute>
 80109b2:	4603      	mov	r3, r0
 80109b4:	637b      	str	r3, [r7, #52]	; 0x34
                                                   ip_src_addr,
                                                   ip_dest_addr);

#ifdef NX_LITTLE_ENDIAN
                /* Convert UDP header to host byte order */
                NX_CHANGE_ULONG_ENDIAN(udp_header_ptr -> nx_udp_header_word_0);
 80109b6:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 80109b8:	681b      	ldr	r3, [r3, #0]
 80109ba:	ba1a      	rev	r2, r3
 80109bc:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 80109be:	601a      	str	r2, [r3, #0]
                NX_CHANGE_ULONG_ENDIAN(udp_header_ptr -> nx_udp_header_word_1);
 80109c0:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 80109c2:	685b      	ldr	r3, [r3, #4]
 80109c4:	ba1a      	rev	r2, r3
 80109c6:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 80109c8:	605a      	str	r2, [r3, #4]
#endif /* NX_LITTLE_ENDIAN */

                /* Perform the one's complement processing on the checksum.  */
                checksum =  NX_LOWER_16_MASK & ~checksum;
 80109ca:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 80109cc:	43db      	mvns	r3, r3
 80109ce:	b29b      	uxth	r3, r3
 80109d0:	637b      	str	r3, [r7, #52]	; 0x34

                /* Determine if it is valid.  */
                if (checksum == 0)
 80109d2:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 80109d4:	2b00      	cmp	r3, #0
 80109d6:	d049      	beq.n	8010a6c <_nx_udp_socket_receive+0x270>
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 80109d8:	f3ef 8310 	mrs	r3, PRIMASK
 80109dc:	617b      	str	r3, [r7, #20]
    return(posture);
 80109de:	697b      	ldr	r3, [r7, #20]
    int_posture = __get_interrupt_posture();
 80109e0:	613b      	str	r3, [r7, #16]
    __asm__ volatile ("CPSID i" : : : "memory");
 80109e2:	b672      	cpsid	i
    return(int_posture);
 80109e4:	693b      	ldr	r3, [r7, #16]
                {

#ifndef NX_DISABLE_UDP_INFO

                    /* Disable interrupts.  */
                    TX_DISABLE
 80109e6:	64fb      	str	r3, [r7, #76]	; 0x4c

                    /* Increment the UDP checksum error count.  */
                    (socket_ptr -> nx_udp_socket_ip_ptr) -> nx_ip_udp_checksum_errors++;
 80109e8:	68fb      	ldr	r3, [r7, #12]
 80109ea:	68db      	ldr	r3, [r3, #12]
 80109ec:	f8d3 20a4 	ldr.w	r2, [r3, #164]	; 0xa4
 80109f0:	3201      	adds	r2, #1
 80109f2:	f8c3 20a4 	str.w	r2, [r3, #164]	; 0xa4

                    /* Increment the UDP invalid packets error count.  */
                    (socket_ptr -> nx_udp_socket_ip_ptr) -> nx_ip_udp_invalid_packets++;
 80109f6:	68fb      	ldr	r3, [r7, #12]
 80109f8:	68db      	ldr	r3, [r3, #12]
 80109fa:	f8d3 2098 	ldr.w	r2, [r3, #152]	; 0x98
 80109fe:	3201      	adds	r2, #1
 8010a00:	f8c3 2098 	str.w	r2, [r3, #152]	; 0x98

                    /* Increment the UDP checksum error count for this socket.  */
                    socket_ptr -> nx_udp_socket_checksum_errors++;
 8010a04:	68fb      	ldr	r3, [r7, #12]
 8010a06:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8010a08:	1c5a      	adds	r2, r3, #1
 8010a0a:	68fb      	ldr	r3, [r7, #12]
 8010a0c:	629a      	str	r2, [r3, #40]	; 0x28

                    /* Decrement the total UDP receive packets count.  */
                    (socket_ptr -> nx_udp_socket_ip_ptr) -> nx_ip_udp_packets_received--;
 8010a0e:	68fb      	ldr	r3, [r7, #12]
 8010a10:	68db      	ldr	r3, [r3, #12]
 8010a12:	f8d3 2090 	ldr.w	r2, [r3, #144]	; 0x90
 8010a16:	3a01      	subs	r2, #1
 8010a18:	f8c3 2090 	str.w	r2, [r3, #144]	; 0x90

                    /* Decrement the total UDP receive bytes.  */
                    (socket_ptr -> nx_udp_socket_ip_ptr) -> nx_ip_udp_bytes_received -=  (*packet_ptr) -> nx_packet_length - (ULONG)sizeof(NX_UDP_HEADER);
 8010a1c:	68fb      	ldr	r3, [r7, #12]
 8010a1e:	68db      	ldr	r3, [r3, #12]
 8010a20:	f8d3 2094 	ldr.w	r2, [r3, #148]	; 0x94
 8010a24:	68bb      	ldr	r3, [r7, #8]
 8010a26:	681b      	ldr	r3, [r3, #0]
 8010a28:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8010a2a:	1ad2      	subs	r2, r2, r3
 8010a2c:	68fb      	ldr	r3, [r7, #12]
 8010a2e:	68db      	ldr	r3, [r3, #12]
 8010a30:	3208      	adds	r2, #8
 8010a32:	f8c3 2094 	str.w	r2, [r3, #148]	; 0x94

                    /* Decrement the total UDP receive packets count.  */
                    socket_ptr -> nx_udp_socket_packets_received--;
 8010a36:	68fb      	ldr	r3, [r7, #12]
 8010a38:	699b      	ldr	r3, [r3, #24]
 8010a3a:	1e5a      	subs	r2, r3, #1
 8010a3c:	68fb      	ldr	r3, [r7, #12]
 8010a3e:	619a      	str	r2, [r3, #24]

                    /* Decrement the total UDP receive bytes.  */
                    socket_ptr -> nx_udp_socket_bytes_received -=  (*packet_ptr) -> nx_packet_length - (ULONG)sizeof(NX_UDP_HEADER);
 8010a40:	68fb      	ldr	r3, [r7, #12]
 8010a42:	69da      	ldr	r2, [r3, #28]
 8010a44:	68bb      	ldr	r3, [r7, #8]
 8010a46:	681b      	ldr	r3, [r3, #0]
 8010a48:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8010a4a:	1ad3      	subs	r3, r2, r3
 8010a4c:	f103 0208 	add.w	r2, r3, #8
 8010a50:	68fb      	ldr	r3, [r7, #12]
 8010a52:	61da      	str	r2, [r3, #28]
 8010a54:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8010a56:	61bb      	str	r3, [r7, #24]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 8010a58:	69bb      	ldr	r3, [r7, #24]
 8010a5a:	f383 8810 	msr	PRIMASK, r3
}
 8010a5e:	bf00      	nop
                    /* Restore interrupts.  */
                    TX_RESTORE
#endif

                    /* Bad UDP checksum.  Release the packet. */
                    _nx_packet_release(*packet_ptr);
 8010a60:	68bb      	ldr	r3, [r7, #8]
 8010a62:	681b      	ldr	r3, [r3, #0]
 8010a64:	4618      	mov	r0, r3
 8010a66:	f7fb fccf 	bl	800c408 <_nx_packet_release>
        TX_DISABLE
 8010a6a:	e6d0      	b.n	801080e <_nx_udp_socket_receive+0x12>
                    break;
 8010a6c:	bf00      	nop
    /* At this point, we have a valid UDP packet for the caller.  */

    /* Remove the UDP header.  */

    /* Decrease the packet length.  */
    (*packet_ptr) -> nx_packet_length =  (*packet_ptr) -> nx_packet_length - (ULONG)sizeof(NX_UDP_HEADER);
 8010a6e:	68bb      	ldr	r3, [r7, #8]
 8010a70:	681b      	ldr	r3, [r3, #0]
 8010a72:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 8010a74:	68bb      	ldr	r3, [r7, #8]
 8010a76:	681b      	ldr	r3, [r3, #0]
 8010a78:	3a08      	subs	r2, #8
 8010a7a:	625a      	str	r2, [r3, #36]	; 0x24

    /* Position past the UDP header pointer.  */
    (*packet_ptr) -> nx_packet_prepend_ptr =   (*packet_ptr) -> nx_packet_prepend_ptr + sizeof(NX_UDP_HEADER);
 8010a7c:	68bb      	ldr	r3, [r7, #8]
 8010a7e:	681b      	ldr	r3, [r3, #0]
 8010a80:	689a      	ldr	r2, [r3, #8]
 8010a82:	68bb      	ldr	r3, [r7, #8]
 8010a84:	681b      	ldr	r3, [r3, #0]
 8010a86:	3208      	adds	r2, #8
 8010a88:	609a      	str	r2, [r3, #8]

    /* Update the trace event with the status.  */
    NX_TRACE_EVENT_UPDATE(trace_event, trace_timestamp, NX_TRACE_UDP_SOCKET_RECEIVE, 0, 0, *packet_ptr, (*packet_ptr) -> nx_packet_length);

    /* Return a successful status to the caller.  */
    return(NX_SUCCESS);
 8010a8a:	2300      	movs	r3, #0
}
 8010a8c:	4618      	mov	r0, r3
 8010a8e:	3758      	adds	r7, #88	; 0x58
 8010a90:	46bd      	mov	sp, r7
 8010a92:	bd80      	pop	{r7, pc}
 8010a94:	24031bc4 	.word	0x24031bc4
 8010a98:	08010315 	.word	0x08010315
 8010a9c:	24031c5c 	.word	0x24031c5c

08010aa0 <_nx_udp_socket_receive_notify>:
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
UINT  _nx_udp_socket_receive_notify(NX_UDP_SOCKET *socket_ptr,
                                    VOID (*udp_receive_notify)(NX_UDP_SOCKET *socket_ptr))
{
 8010aa0:	b480      	push	{r7}
 8010aa2:	b087      	sub	sp, #28
 8010aa4:	af00      	add	r7, sp, #0
 8010aa6:	6078      	str	r0, [r7, #4]
 8010aa8:	6039      	str	r1, [r7, #0]
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 8010aaa:	f3ef 8310 	mrs	r3, PRIMASK
 8010aae:	60fb      	str	r3, [r7, #12]
    return(posture);
 8010ab0:	68fb      	ldr	r3, [r7, #12]
    int_posture = __get_interrupt_posture();
 8010ab2:	60bb      	str	r3, [r7, #8]
    __asm__ volatile ("CPSID i" : : : "memory");
 8010ab4:	b672      	cpsid	i
    return(int_posture);
 8010ab6:	68bb      	ldr	r3, [r7, #8]
TX_INTERRUPT_SAVE_AREA


    /* Disable interrupts.  */
    TX_DISABLE
 8010ab8:	617b      	str	r3, [r7, #20]

    /* Setup the receive notify function pointer.  */
    socket_ptr -> nx_udp_receive_callback =  udp_receive_notify;
 8010aba:	687b      	ldr	r3, [r7, #4]
 8010abc:	683a      	ldr	r2, [r7, #0]
 8010abe:	671a      	str	r2, [r3, #112]	; 0x70
 8010ac0:	697b      	ldr	r3, [r7, #20]
 8010ac2:	613b      	str	r3, [r7, #16]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 8010ac4:	693b      	ldr	r3, [r7, #16]
 8010ac6:	f383 8810 	msr	PRIMASK, r3
}
 8010aca:	bf00      	nop

    /* If trace is enabled, insert this event into the trace buffer.  */
    NX_TRACE_IN_LINE_INSERT(NX_TRACE_UDP_SOCKET_RECEIVE_NOTIFY, socket_ptr -> nx_udp_socket_ip_ptr, socket_ptr, udp_receive_notify, 0, NX_TRACE_UDP_EVENTS, 0, 0);

    /* Return successful completion.  */
    return(NX_SUCCESS);
 8010acc:	2300      	movs	r3, #0
}
 8010ace:	4618      	mov	r0, r3
 8010ad0:	371c      	adds	r7, #28
 8010ad2:	46bd      	mov	sp, r7
 8010ad4:	f85d 7b04 	ldr.w	r7, [sp], #4
 8010ad8:	4770      	bx	lr

08010ada <_nx_udp_socket_send>:
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
UINT  _nx_udp_socket_send(NX_UDP_SOCKET *socket_ptr, NX_PACKET *packet_ptr,
                          ULONG ip_address, UINT port)
{
 8010ada:	b580      	push	{r7, lr}
 8010adc:	b088      	sub	sp, #32
 8010ade:	af00      	add	r7, sp, #0
 8010ae0:	60f8      	str	r0, [r7, #12]
 8010ae2:	60b9      	str	r1, [r7, #8]
 8010ae4:	607a      	str	r2, [r7, #4]
 8010ae6:	603b      	str	r3, [r7, #0]
UINT        status;

NXD_ADDRESS dual_ip_address;

    /* build up the IP Address structure. */
    dual_ip_address.nxd_ip_version = NX_IP_VERSION_V4;
 8010ae8:	2304      	movs	r3, #4
 8010aea:	617b      	str	r3, [r7, #20]
    dual_ip_address.nxd_ip_address.v4 = ip_address;
 8010aec:	687b      	ldr	r3, [r7, #4]
 8010aee:	61bb      	str	r3, [r7, #24]

    /* Call the actual udp socket send routine. */
    status = _nxd_udp_socket_send(socket_ptr, packet_ptr, &dual_ip_address, port);
 8010af0:	f107 0214 	add.w	r2, r7, #20
 8010af4:	683b      	ldr	r3, [r7, #0]
 8010af6:	68b9      	ldr	r1, [r7, #8]
 8010af8:	68f8      	ldr	r0, [r7, #12]
 8010afa:	f000 fa08 	bl	8010f0e <_nxd_udp_socket_send>
 8010afe:	61f8      	str	r0, [r7, #28]

    return(status);
 8010b00:	69fb      	ldr	r3, [r7, #28]
    NX_PARAMETER_NOT_USED(ip_address);
    NX_PARAMETER_NOT_USED(port);

    return(NX_NOT_SUPPORTED);
#endif /* NX_DISABLE_IPV4 */
}
 8010b02:	4618      	mov	r0, r3
 8010b04:	3720      	adds	r7, #32
 8010b06:	46bd      	mov	sp, r7
 8010b08:	bd80      	pop	{r7, pc}

08010b0a <_nx_udp_socket_source_send>:
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
UINT  _nx_udp_socket_source_send(NX_UDP_SOCKET *socket_ptr, NX_PACKET *packet_ptr,
                                 ULONG ip_address, UINT port, UINT address_index)
{
 8010b0a:	b580      	push	{r7, lr}
 8010b0c:	b086      	sub	sp, #24
 8010b0e:	af00      	add	r7, sp, #0
 8010b10:	60f8      	str	r0, [r7, #12]
 8010b12:	60b9      	str	r1, [r7, #8]
 8010b14:	607a      	str	r2, [r7, #4]
 8010b16:	603b      	str	r3, [r7, #0]
UINT   status;
NX_IP *ip_ptr;


    /* Setup the pointer to the associated IP instance.  */
    ip_ptr =  socket_ptr -> nx_udp_socket_ip_ptr;
 8010b18:	68fb      	ldr	r3, [r7, #12]
 8010b1a:	68db      	ldr	r3, [r3, #12]
 8010b1c:	617b      	str	r3, [r7, #20]

    /* Store interface information into the packet structure. */
    packet_ptr -> nx_packet_address.nx_packet_interface_ptr = &(ip_ptr -> nx_ip_interface[address_index]);
 8010b1e:	6a3b      	ldr	r3, [r7, #32]
 8010b20:	224c      	movs	r2, #76	; 0x4c
 8010b22:	fb02 f303 	mul.w	r3, r2, r3
 8010b26:	f503 63e4 	add.w	r3, r3, #1824	; 0x720
 8010b2a:	697a      	ldr	r2, [r7, #20]
 8010b2c:	441a      	add	r2, r3
 8010b2e:	68bb      	ldr	r3, [r7, #8]
 8010b30:	631a      	str	r2, [r3, #48]	; 0x30

    /* Call udp_socket_send service */
    status = _nx_udp_socket_send(socket_ptr, packet_ptr, ip_address, port);
 8010b32:	683b      	ldr	r3, [r7, #0]
 8010b34:	687a      	ldr	r2, [r7, #4]
 8010b36:	68b9      	ldr	r1, [r7, #8]
 8010b38:	68f8      	ldr	r0, [r7, #12]
 8010b3a:	f7ff ffce 	bl	8010ada <_nx_udp_socket_send>
 8010b3e:	6138      	str	r0, [r7, #16]

    return(status);
 8010b40:	693b      	ldr	r3, [r7, #16]
}
 8010b42:	4618      	mov	r0, r3
 8010b44:	3718      	adds	r7, #24
 8010b46:	46bd      	mov	sp, r7
 8010b48:	bd80      	pop	{r7, pc}
	...

08010b4c <_nx_udp_socket_unbind>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
UINT  _nx_udp_socket_unbind(NX_UDP_SOCKET *socket_ptr)
{
 8010b4c:	b580      	push	{r7, lr}
 8010b4e:	b094      	sub	sp, #80	; 0x50
 8010b50:	af00      	add	r7, sp, #0
 8010b52:	6078      	str	r0, [r7, #4]
NX_PACKET     *packet_ptr;
NX_PACKET     *next_packet_ptr;


    /* Setup the pointer to the associated IP instance.  */
    ip_ptr =  socket_ptr -> nx_udp_socket_ip_ptr;
 8010b54:	687b      	ldr	r3, [r7, #4]
 8010b56:	68db      	ldr	r3, [r3, #12]
 8010b58:	647b      	str	r3, [r7, #68]	; 0x44
    /* If trace is enabled, insert this event into the trace buffer.  */
    NX_TRACE_IN_LINE_INSERT(NX_TRACE_UDP_SOCKET_UNBIND, ip_ptr, socket_ptr, socket_ptr -> nx_udp_socket_port, 0, NX_TRACE_UDP_EVENTS, 0, 0);

    /* Obtain the IP mutex so we can figure out whether or not the port has already
       been bound to.  */
    tx_mutex_get(&(ip_ptr -> nx_ip_protection), TX_WAIT_FOREVER);
 8010b5a:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8010b5c:	f503 739e 	add.w	r3, r3, #316	; 0x13c
 8010b60:	f04f 31ff 	mov.w	r1, #4294967295
 8010b64:	4618      	mov	r0, r3
 8010b66:	f002 f905 	bl	8012d74 <_tx_mutex_get>

    /* Determine if the socket is bound to port.  */
    if (!socket_ptr -> nx_udp_socket_bound_next)
 8010b6a:	687b      	ldr	r3, [r7, #4]
 8010b6c:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 8010b6e:	2b00      	cmp	r3, #0
 8010b70:	d119      	bne.n	8010ba6 <_nx_udp_socket_unbind+0x5a>
    {

        /* Determine if there is a special condition for the socket not being in
           a bound condition...  i.e. the socket is in a pending-to-be-bound condition
           in a call from a different thread.  */
        if (socket_ptr -> nx_udp_socket_bind_in_progress)
 8010b72:	687b      	ldr	r3, [r7, #4]
 8010b74:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 8010b76:	2b00      	cmp	r3, #0
 8010b78:	d00d      	beq.n	8010b96 <_nx_udp_socket_unbind+0x4a>
        {

            /* Execute the bind suspension cleanup routine.  */
            _nx_udp_bind_cleanup(socket_ptr -> nx_udp_socket_bind_in_progress NX_CLEANUP_ARGUMENT);
 8010b7a:	687b      	ldr	r3, [r7, #4]
 8010b7c:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 8010b7e:	2100      	movs	r1, #0
 8010b80:	4618      	mov	r0, r3
 8010b82:	f7ff f8df 	bl	800fd44 <_nx_udp_bind_cleanup>

            /* Release the protection mutex.  */
            tx_mutex_put(&(ip_ptr -> nx_ip_protection));
 8010b86:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8010b88:	f503 739e 	add.w	r3, r3, #316	; 0x13c
 8010b8c:	4618      	mov	r0, r3
 8010b8e:	f002 fb69 	bl	8013264 <_tx_mutex_put>

            /* Return success.  */
            return(NX_SUCCESS);
 8010b92:	2300      	movs	r3, #0
 8010b94:	e135      	b.n	8010e02 <_nx_udp_socket_unbind+0x2b6>
        }
        else
        {

            /* Release the protection mutex.  */
            tx_mutex_put(&(ip_ptr -> nx_ip_protection));
 8010b96:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8010b98:	f503 739e 	add.w	r3, r3, #316	; 0x13c
 8010b9c:	4618      	mov	r0, r3
 8010b9e:	f002 fb61 	bl	8013264 <_tx_mutex_put>

            /* Return a not bound error code.  */
            return(NX_NOT_BOUND);
 8010ba2:	2324      	movs	r3, #36	; 0x24
 8010ba4:	e12d      	b.n	8010e02 <_nx_udp_socket_unbind+0x2b6>

    /* Otherwise, the socket is bound.  We need to remove this socket from the
       port and check for any other UDP socket bind requests that are queued.  */

    /* Pickup the port number in the UDP socket structure.  */
    port =  socket_ptr -> nx_udp_socket_port;
 8010ba6:	687b      	ldr	r3, [r7, #4]
 8010ba8:	689b      	ldr	r3, [r3, #8]
 8010baa:	643b      	str	r3, [r7, #64]	; 0x40

    /* Calculate the hash index in the UDP port array of the associated IP instance.  */
    index =  (UINT)((port + (port >> 8)) & NX_UDP_PORT_TABLE_MASK);
 8010bac:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8010bae:	0a1a      	lsrs	r2, r3, #8
 8010bb0:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8010bb2:	4413      	add	r3, r2
 8010bb4:	f003 031f 	and.w	r3, r3, #31
 8010bb8:	63fb      	str	r3, [r7, #60]	; 0x3c
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 8010bba:	f3ef 8310 	mrs	r3, PRIMASK
 8010bbe:	62fb      	str	r3, [r7, #44]	; 0x2c
    return(posture);
 8010bc0:	6afb      	ldr	r3, [r7, #44]	; 0x2c
    int_posture = __get_interrupt_posture();
 8010bc2:	62bb      	str	r3, [r7, #40]	; 0x28
    __asm__ volatile ("CPSID i" : : : "memory");
 8010bc4:	b672      	cpsid	i
    return(int_posture);
 8010bc6:	6abb      	ldr	r3, [r7, #40]	; 0x28

    /* Disable interrupts while we unlink the current socket.  */
    TX_DISABLE
 8010bc8:	63bb      	str	r3, [r7, #56]	; 0x38

    /* Determine if this is the only socket bound on this port list.  */
    if (socket_ptr -> nx_udp_socket_bound_next == socket_ptr)
 8010bca:	687b      	ldr	r3, [r7, #4]
 8010bcc:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 8010bce:	687a      	ldr	r2, [r7, #4]
 8010bd0:	429a      	cmp	r2, r3
 8010bd2:	d109      	bne.n	8010be8 <_nx_udp_socket_unbind+0x9c>
    {

        /* Yes, this is the only socket on the port list.  */

        /* Clear the list head pointer and the next pointer in the socket.  */
        ip_ptr -> nx_ip_udp_port_table[index] =   NX_NULL;
 8010bd4:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8010bd6:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 8010bd8:	32e0      	adds	r2, #224	; 0xe0
 8010bda:	2100      	movs	r1, #0
 8010bdc:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
        socket_ptr -> nx_udp_socket_bound_next =  NX_NULL;
 8010be0:	687b      	ldr	r3, [r7, #4]
 8010be2:	2200      	movs	r2, #0
 8010be4:	64da      	str	r2, [r3, #76]	; 0x4c
 8010be6:	e01b      	b.n	8010c20 <_nx_udp_socket_unbind+0xd4>
    {

        /* Relink the neighbors of this UDP socket.  */

        /* Update the links of the adjacent sockets.  */
        (socket_ptr -> nx_udp_socket_bound_next) -> nx_udp_socket_bound_previous =
 8010be8:	687b      	ldr	r3, [r7, #4]
 8010bea:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
            socket_ptr -> nx_udp_socket_bound_previous;
 8010bec:	687a      	ldr	r2, [r7, #4]
 8010bee:	6d12      	ldr	r2, [r2, #80]	; 0x50
        (socket_ptr -> nx_udp_socket_bound_next) -> nx_udp_socket_bound_previous =
 8010bf0:	651a      	str	r2, [r3, #80]	; 0x50
        (socket_ptr -> nx_udp_socket_bound_previous) -> nx_udp_socket_bound_next =
 8010bf2:	687b      	ldr	r3, [r7, #4]
 8010bf4:	6d1b      	ldr	r3, [r3, #80]	; 0x50
            socket_ptr -> nx_udp_socket_bound_next;
 8010bf6:	687a      	ldr	r2, [r7, #4]
 8010bf8:	6cd2      	ldr	r2, [r2, #76]	; 0x4c
        (socket_ptr -> nx_udp_socket_bound_previous) -> nx_udp_socket_bound_next =
 8010bfa:	64da      	str	r2, [r3, #76]	; 0x4c

        /* Determine if the head of the port list points to the socket being removed.
           If so, we need to move the head pointer.  */
        if (ip_ptr -> nx_ip_udp_port_table[index] == socket_ptr)
 8010bfc:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8010bfe:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 8010c00:	32e0      	adds	r2, #224	; 0xe0
 8010c02:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 8010c06:	687a      	ldr	r2, [r7, #4]
 8010c08:	429a      	cmp	r2, r3
 8010c0a:	d106      	bne.n	8010c1a <_nx_udp_socket_unbind+0xce>
        {

            /* Yes, we need to move the port list head pointer.  */
            ip_ptr -> nx_ip_udp_port_table[index] =  socket_ptr -> nx_udp_socket_bound_next;
 8010c0c:	687b      	ldr	r3, [r7, #4]
 8010c0e:	6cd9      	ldr	r1, [r3, #76]	; 0x4c
 8010c10:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8010c12:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 8010c14:	32e0      	adds	r2, #224	; 0xe0
 8010c16:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
        }

        /* Clear the next pointer in the socket to indicate it is no longer bound.  */
        socket_ptr -> nx_udp_socket_bound_next =  NX_NULL;
 8010c1a:	687b      	ldr	r3, [r7, #4]
 8010c1c:	2200      	movs	r2, #0
 8010c1e:	64da      	str	r2, [r3, #76]	; 0x4c
 8010c20:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8010c22:	627b      	str	r3, [r7, #36]	; 0x24
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 8010c24:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8010c26:	f383 8810 	msr	PRIMASK, r3
}
 8010c2a:	bf00      	nop
    /* Restore interrupts.  */
    TX_RESTORE

    /* The socket is off the bound list...  we need to check for queued packets and possible
       receive suspension.  We need to clean up either of these conditions.  */
    if (socket_ptr -> nx_udp_socket_receive_count)
 8010c2c:	687b      	ldr	r3, [r7, #4]
 8010c2e:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 8010c30:	2b00      	cmp	r3, #0
 8010c32:	d01b      	beq.n	8010c6c <_nx_udp_socket_unbind+0x120>
    {

        /* Setup packet pointer.  */
        packet_ptr =  socket_ptr -> nx_udp_socket_receive_head;
 8010c34:	687b      	ldr	r3, [r7, #4]
 8010c36:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 8010c38:	64bb      	str	r3, [r7, #72]	; 0x48

        /* Clear the head and the tail pointers.  */
        socket_ptr -> nx_udp_socket_receive_head =  NX_NULL;
 8010c3a:	687b      	ldr	r3, [r7, #4]
 8010c3c:	2200      	movs	r2, #0
 8010c3e:	645a      	str	r2, [r3, #68]	; 0x44
        socket_ptr -> nx_udp_socket_receive_tail =  NX_NULL;
 8010c40:	687b      	ldr	r3, [r7, #4]
 8010c42:	2200      	movs	r2, #0
 8010c44:	649a      	str	r2, [r3, #72]	; 0x48

        /* Loop to clear all the packets out.  */
        while (socket_ptr -> nx_udp_socket_receive_count)
 8010c46:	e00c      	b.n	8010c62 <_nx_udp_socket_unbind+0x116>
        {

            /* Pickup the next queued packet.  */
            next_packet_ptr =  packet_ptr -> nx_packet_queue_next;
 8010c48:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 8010c4a:	69db      	ldr	r3, [r3, #28]
 8010c4c:	637b      	str	r3, [r7, #52]	; 0x34

            /* Release the packet.  */
            _nx_packet_release(packet_ptr);
 8010c4e:	6cb8      	ldr	r0, [r7, #72]	; 0x48
 8010c50:	f7fb fbda 	bl	800c408 <_nx_packet_release>

            /* Move to the next packet.  */
            packet_ptr =  next_packet_ptr;
 8010c54:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8010c56:	64bb      	str	r3, [r7, #72]	; 0x48

            /* Decrease the queued packet count.  */
            socket_ptr -> nx_udp_socket_receive_count--;
 8010c58:	687b      	ldr	r3, [r7, #4]
 8010c5a:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 8010c5c:	1e5a      	subs	r2, r3, #1
 8010c5e:	687b      	ldr	r3, [r7, #4]
 8010c60:	63da      	str	r2, [r3, #60]	; 0x3c
        while (socket_ptr -> nx_udp_socket_receive_count)
 8010c62:	687b      	ldr	r3, [r7, #4]
 8010c64:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 8010c66:	2b00      	cmp	r3, #0
 8010c68:	d1ee      	bne.n	8010c48 <_nx_udp_socket_unbind+0xfc>
 8010c6a:	e035      	b.n	8010cd8 <_nx_udp_socket_unbind+0x18c>
        }
    }
    else if (socket_ptr -> nx_udp_socket_receive_suspended_count)
 8010c6c:	687b      	ldr	r3, [r7, #4]
 8010c6e:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
 8010c70:	2b00      	cmp	r3, #0
 8010c72:	d031      	beq.n	8010cd8 <_nx_udp_socket_unbind+0x18c>
    {

        /* Clear out all threads suspended on this socket.  */

        /* Pickup the first suspended thread.  */
        thread_ptr =  socket_ptr -> nx_udp_socket_receive_suspension_list;
 8010c74:	687b      	ldr	r3, [r7, #4]
 8010c76:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 8010c78:	64fb      	str	r3, [r7, #76]	; 0x4c

        /* Clear the thread receive suspension list.  */
        socket_ptr -> nx_udp_socket_receive_suspension_list =  NX_NULL;
 8010c7a:	687b      	ldr	r3, [r7, #4]
 8010c7c:	2200      	movs	r2, #0
 8010c7e:	659a      	str	r2, [r3, #88]	; 0x58

        /* Walk through the queue list to resume any and all threads suspended
           on this queue.  */
        while (socket_ptr -> nx_udp_socket_receive_suspended_count)
 8010c80:	e026      	b.n	8010cd0 <_nx_udp_socket_unbind+0x184>
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 8010c82:	f3ef 8310 	mrs	r3, PRIMASK
 8010c86:	61fb      	str	r3, [r7, #28]
    return(posture);
 8010c88:	69fb      	ldr	r3, [r7, #28]
    int_posture = __get_interrupt_posture();
 8010c8a:	61bb      	str	r3, [r7, #24]
    __asm__ volatile ("CPSID i" : : : "memory");
 8010c8c:	b672      	cpsid	i
    return(int_posture);
 8010c8e:	69bb      	ldr	r3, [r7, #24]
        {

            /* Lockout interrupts.  */
            TX_DISABLE
 8010c90:	63bb      	str	r3, [r7, #56]	; 0x38

            /* Clear the cleanup pointer, this prevents the timeout from doing
               anything.  */
            thread_ptr -> tx_thread_suspend_cleanup =  TX_NULL;
 8010c92:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8010c94:	2200      	movs	r2, #0
 8010c96:	669a      	str	r2, [r3, #104]	; 0x68

            /* Temporarily disable preemption again.  */
            _tx_thread_preempt_disable++;
 8010c98:	4b5c      	ldr	r3, [pc, #368]	; (8010e0c <_nx_udp_socket_unbind+0x2c0>)
 8010c9a:	681b      	ldr	r3, [r3, #0]
 8010c9c:	3301      	adds	r3, #1
 8010c9e:	4a5b      	ldr	r2, [pc, #364]	; (8010e0c <_nx_udp_socket_unbind+0x2c0>)
 8010ca0:	6013      	str	r3, [r2, #0]
 8010ca2:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8010ca4:	623b      	str	r3, [r7, #32]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 8010ca6:	6a3b      	ldr	r3, [r7, #32]
 8010ca8:	f383 8810 	msr	PRIMASK, r3
}
 8010cac:	bf00      	nop

            /* Restore interrupts.  */
            TX_RESTORE

            /* Set the return status in the thread to NX_SOCKET_UNBOUND.  */
            thread_ptr -> tx_thread_suspend_status =  NX_SOCKET_UNBOUND;
 8010cae:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8010cb0:	2226      	movs	r2, #38	; 0x26
 8010cb2:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84

            /* Move the thread pointer ahead.  */
            thread_ptr =  thread_ptr -> tx_thread_suspended_next;
 8010cb6:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8010cb8:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 8010cba:	64fb      	str	r3, [r7, #76]	; 0x4c

            /* Resume the thread.  */
            _tx_thread_system_resume(thread_ptr -> tx_thread_suspended_previous);
 8010cbc:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8010cbe:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 8010cc0:	4618      	mov	r0, r3
 8010cc2:	f004 f831 	bl	8014d28 <_tx_thread_system_resume>

            /* Decrease the suspended count.  */
            socket_ptr -> nx_udp_socket_receive_suspended_count--;
 8010cc6:	687b      	ldr	r3, [r7, #4]
 8010cc8:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
 8010cca:	1e5a      	subs	r2, r3, #1
 8010ccc:	687b      	ldr	r3, [r7, #4]
 8010cce:	65da      	str	r2, [r3, #92]	; 0x5c
        while (socket_ptr -> nx_udp_socket_receive_suspended_count)
 8010cd0:	687b      	ldr	r3, [r7, #4]
 8010cd2:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
 8010cd4:	2b00      	cmp	r3, #0
 8010cd6:	d1d4      	bne.n	8010c82 <_nx_udp_socket_unbind+0x136>
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 8010cd8:	f3ef 8310 	mrs	r3, PRIMASK
 8010cdc:	617b      	str	r3, [r7, #20]
    return(posture);
 8010cde:	697b      	ldr	r3, [r7, #20]
    int_posture = __get_interrupt_posture();
 8010ce0:	613b      	str	r3, [r7, #16]
    __asm__ volatile ("CPSID i" : : : "memory");
 8010ce2:	b672      	cpsid	i
    return(int_posture);
 8010ce4:	693b      	ldr	r3, [r7, #16]
        }
    }

    /* Disable interrupts again.  */
    TX_DISABLE
 8010ce6:	63bb      	str	r3, [r7, #56]	; 0x38

    /* Determine if there are any threads suspended on trying to bind to the
       same port.  */
    thread_ptr =  socket_ptr -> nx_udp_socket_bind_suspension_list;
 8010ce8:	687b      	ldr	r3, [r7, #4]
 8010cea:	6e1b      	ldr	r3, [r3, #96]	; 0x60
 8010cec:	64fb      	str	r3, [r7, #76]	; 0x4c
    if (thread_ptr)
 8010cee:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8010cf0:	2b00      	cmp	r3, #0
 8010cf2:	d079      	beq.n	8010de8 <_nx_udp_socket_unbind+0x29c>
    {

        /* Remove the suspended thread from the list.  */

        /* See if this is the only suspended thread on the list.  */
        if (thread_ptr == thread_ptr -> tx_thread_suspended_next)
 8010cf4:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8010cf6:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 8010cf8:	6cfa      	ldr	r2, [r7, #76]	; 0x4c
 8010cfa:	429a      	cmp	r2, r3
 8010cfc:	d103      	bne.n	8010d06 <_nx_udp_socket_unbind+0x1ba>
        {

            /* Yes, the only suspended thread.  */

            /* Update the head pointer.  */
            socket_ptr -> nx_udp_socket_bind_suspension_list =  NX_NULL;
 8010cfe:	687b      	ldr	r3, [r7, #4]
 8010d00:	2200      	movs	r2, #0
 8010d02:	661a      	str	r2, [r3, #96]	; 0x60
 8010d04:	e00d      	b.n	8010d22 <_nx_udp_socket_unbind+0x1d6>
        {

            /* At least one more thread is on the same expiration list.  */

            /* Update the list head pointer.  */
            socket_ptr -> nx_udp_socket_bind_suspension_list =  thread_ptr -> tx_thread_suspended_next;
 8010d06:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8010d08:	6f1a      	ldr	r2, [r3, #112]	; 0x70
 8010d0a:	687b      	ldr	r3, [r7, #4]
 8010d0c:	661a      	str	r2, [r3, #96]	; 0x60

            /* Update the links of the adjacent threads.  */
            (thread_ptr -> tx_thread_suspended_next) -> tx_thread_suspended_previous =
 8010d0e:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8010d10:	6f1b      	ldr	r3, [r3, #112]	; 0x70
                thread_ptr -> tx_thread_suspended_previous;
 8010d12:	6cfa      	ldr	r2, [r7, #76]	; 0x4c
 8010d14:	6f52      	ldr	r2, [r2, #116]	; 0x74
            (thread_ptr -> tx_thread_suspended_next) -> tx_thread_suspended_previous =
 8010d16:	675a      	str	r2, [r3, #116]	; 0x74
            (thread_ptr -> tx_thread_suspended_previous) -> tx_thread_suspended_next =
 8010d18:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8010d1a:	6f5b      	ldr	r3, [r3, #116]	; 0x74
                thread_ptr -> tx_thread_suspended_next;
 8010d1c:	6cfa      	ldr	r2, [r7, #76]	; 0x4c
 8010d1e:	6f12      	ldr	r2, [r2, #112]	; 0x70
            (thread_ptr -> tx_thread_suspended_previous) -> tx_thread_suspended_next =
 8010d20:	671a      	str	r2, [r3, #112]	; 0x70
        }

        /* Decrement the suspension count.  */
        socket_ptr -> nx_udp_socket_bind_suspended_count--;
 8010d22:	687b      	ldr	r3, [r7, #4]
 8010d24:	6e5b      	ldr	r3, [r3, #100]	; 0x64
 8010d26:	1e5a      	subs	r2, r3, #1
 8010d28:	687b      	ldr	r3, [r7, #4]
 8010d2a:	665a      	str	r2, [r3, #100]	; 0x64

        /* Pickup the new socket structure to link to the port list.  */
        new_socket_ptr =  (NX_UDP_SOCKET *)thread_ptr -> tx_thread_suspend_control_block;
 8010d2c:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8010d2e:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 8010d30:	633b      	str	r3, [r7, #48]	; 0x30

        /* Clear the new socket's bind in progress flag.  */
        new_socket_ptr -> nx_udp_socket_bind_in_progress =  NX_NULL;
 8010d32:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8010d34:	2200      	movs	r2, #0
 8010d36:	655a      	str	r2, [r3, #84]	; 0x54

        /* Inherit the suspension list from the previously bound socket.  */
        new_socket_ptr -> nx_udp_socket_bind_suspension_list =
            socket_ptr -> nx_udp_socket_bind_suspension_list;
 8010d38:	687b      	ldr	r3, [r7, #4]
 8010d3a:	6e1a      	ldr	r2, [r3, #96]	; 0x60
        new_socket_ptr -> nx_udp_socket_bind_suspension_list =
 8010d3c:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8010d3e:	661a      	str	r2, [r3, #96]	; 0x60
        socket_ptr -> nx_udp_socket_bind_suspension_list =  NX_NULL;
 8010d40:	687b      	ldr	r3, [r7, #4]
 8010d42:	2200      	movs	r2, #0
 8010d44:	661a      	str	r2, [r3, #96]	; 0x60

        /* Link the new socket to the bound list.  */
        if (ip_ptr -> nx_ip_udp_port_table[index])
 8010d46:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8010d48:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 8010d4a:	32e0      	adds	r2, #224	; 0xe0
 8010d4c:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 8010d50:	2b00      	cmp	r3, #0
 8010d52:	d01e      	beq.n	8010d92 <_nx_udp_socket_unbind+0x246>
        {

            /* There are already sockets on this list... just add this one
               to the end.  */
            new_socket_ptr -> nx_udp_socket_bound_next =
                ip_ptr -> nx_ip_udp_port_table[index];
 8010d54:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8010d56:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 8010d58:	32e0      	adds	r2, #224	; 0xe0
 8010d5a:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
            new_socket_ptr -> nx_udp_socket_bound_next =
 8010d5e:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8010d60:	64da      	str	r2, [r3, #76]	; 0x4c
            new_socket_ptr -> nx_udp_socket_bound_previous =
                (ip_ptr -> nx_ip_udp_port_table[index]) -> nx_udp_socket_bound_previous;
 8010d62:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8010d64:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 8010d66:	32e0      	adds	r2, #224	; 0xe0
 8010d68:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 8010d6c:	6d1a      	ldr	r2, [r3, #80]	; 0x50
            new_socket_ptr -> nx_udp_socket_bound_previous =
 8010d6e:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8010d70:	651a      	str	r2, [r3, #80]	; 0x50
            ((ip_ptr -> nx_ip_udp_port_table[index]) -> nx_udp_socket_bound_previous) -> nx_udp_socket_bound_next =
 8010d72:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8010d74:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 8010d76:	32e0      	adds	r2, #224	; 0xe0
 8010d78:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 8010d7c:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 8010d7e:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 8010d80:	64da      	str	r2, [r3, #76]	; 0x4c
                new_socket_ptr;
            (ip_ptr -> nx_ip_udp_port_table[index]) -> nx_udp_socket_bound_previous =   new_socket_ptr;
 8010d82:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8010d84:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 8010d86:	32e0      	adds	r2, #224	; 0xe0
 8010d88:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 8010d8c:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 8010d8e:	651a      	str	r2, [r3, #80]	; 0x50
 8010d90:	e00b      	b.n	8010daa <_nx_udp_socket_unbind+0x25e>
        else
        {

            /* Nothing is on the UDP port list.  Add this UDP socket to an
               empty list.  */
            new_socket_ptr -> nx_udp_socket_bound_next =      new_socket_ptr;
 8010d92:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8010d94:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 8010d96:	64da      	str	r2, [r3, #76]	; 0x4c
            new_socket_ptr -> nx_udp_socket_bound_previous =  new_socket_ptr;
 8010d98:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8010d9a:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 8010d9c:	651a      	str	r2, [r3, #80]	; 0x50
            ip_ptr -> nx_ip_udp_port_table[index] =           new_socket_ptr;
 8010d9e:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8010da0:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 8010da2:	32e0      	adds	r2, #224	; 0xe0
 8010da4:	6b39      	ldr	r1, [r7, #48]	; 0x30
 8010da6:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
        }

        /* Prepare for resumption of the first thread.  */

        /* Clear cleanup routine to avoid timeout.  */
        thread_ptr -> tx_thread_suspend_cleanup =  TX_NULL;
 8010daa:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8010dac:	2200      	movs	r2, #0
 8010dae:	669a      	str	r2, [r3, #104]	; 0x68

        /* Temporarily disable preemption.  */
        _tx_thread_preempt_disable++;
 8010db0:	4b16      	ldr	r3, [pc, #88]	; (8010e0c <_nx_udp_socket_unbind+0x2c0>)
 8010db2:	681b      	ldr	r3, [r3, #0]
 8010db4:	3301      	adds	r3, #1
 8010db6:	4a15      	ldr	r2, [pc, #84]	; (8010e0c <_nx_udp_socket_unbind+0x2c0>)
 8010db8:	6013      	str	r3, [r2, #0]
 8010dba:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8010dbc:	60fb      	str	r3, [r7, #12]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 8010dbe:	68fb      	ldr	r3, [r7, #12]
 8010dc0:	f383 8810 	msr	PRIMASK, r3
}
 8010dc4:	bf00      	nop

        /* Restore interrupts.  */
        TX_RESTORE

        /* Put return status into the thread control block.  */
        thread_ptr -> tx_thread_suspend_status =  NX_SUCCESS;
 8010dc6:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8010dc8:	2200      	movs	r2, #0
 8010dca:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84

        /* Release the mutex protection.  */
        tx_mutex_put(&(ip_ptr -> nx_ip_protection));
 8010dce:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8010dd0:	f503 739e 	add.w	r3, r3, #316	; 0x13c
 8010dd4:	4618      	mov	r0, r3
 8010dd6:	f002 fa45 	bl	8013264 <_tx_mutex_put>

        /* Resume thread.  */
        _tx_thread_system_resume(thread_ptr);
 8010dda:	6cf8      	ldr	r0, [r7, #76]	; 0x4c
 8010ddc:	f003 ffa4 	bl	8014d28 <_tx_thread_system_resume>
        /* Return success to the caller.  */
        return(NX_SUCCESS);
    }

    /* Check for preemption.  */
    _tx_thread_system_preempt_check();
 8010de0:	f003 ff68 	bl	8014cb4 <_tx_thread_system_preempt_check>

    /* Return success.  */
    return(NX_SUCCESS);
 8010de4:	2300      	movs	r3, #0
 8010de6:	e00c      	b.n	8010e02 <_nx_udp_socket_unbind+0x2b6>
 8010de8:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8010dea:	60bb      	str	r3, [r7, #8]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 8010dec:	68bb      	ldr	r3, [r7, #8]
 8010dee:	f383 8810 	msr	PRIMASK, r3
}
 8010df2:	bf00      	nop
        tx_mutex_put(&(ip_ptr -> nx_ip_protection));
 8010df4:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8010df6:	f503 739e 	add.w	r3, r3, #316	; 0x13c
 8010dfa:	4618      	mov	r0, r3
 8010dfc:	f002 fa32 	bl	8013264 <_tx_mutex_put>
        return(NX_SUCCESS);
 8010e00:	2300      	movs	r3, #0
}
 8010e02:	4618      	mov	r0, r3
 8010e04:	3750      	adds	r7, #80	; 0x50
 8010e06:	46bd      	mov	sp, r7
 8010e08:	bd80      	pop	{r7, pc}
 8010e0a:	bf00      	nop
 8010e0c:	24031c5c 	.word	0x24031c5c

08010e10 <_nx_utility_string_length_check>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
UINT  _nx_utility_string_length_check(CHAR *input_string, UINT *string_length, UINT max_string_length)
{
 8010e10:	b480      	push	{r7}
 8010e12:	b087      	sub	sp, #28
 8010e14:	af00      	add	r7, sp, #0
 8010e16:	60f8      	str	r0, [r7, #12]
 8010e18:	60b9      	str	r1, [r7, #8]
 8010e1a:	607a      	str	r2, [r7, #4]

UINT    i;


    /* Check for invalid input pointers.  */
    if (input_string == NX_NULL)
 8010e1c:	68fb      	ldr	r3, [r7, #12]
 8010e1e:	2b00      	cmp	r3, #0
 8010e20:	d101      	bne.n	8010e26 <_nx_utility_string_length_check+0x16>
    {
        return(NX_PTR_ERROR);
 8010e22:	2307      	movs	r3, #7
 8010e24:	e018      	b.n	8010e58 <_nx_utility_string_length_check+0x48>
    }

    /* Traverse the string.  */
    for (i = 0; input_string[i]; i++)
 8010e26:	2300      	movs	r3, #0
 8010e28:	617b      	str	r3, [r7, #20]
 8010e2a:	e008      	b.n	8010e3e <_nx_utility_string_length_check+0x2e>
    {

        /* Check if the string length is bigger than the max string length.  */
        if (i >= max_string_length)
 8010e2c:	697a      	ldr	r2, [r7, #20]
 8010e2e:	687b      	ldr	r3, [r7, #4]
 8010e30:	429a      	cmp	r2, r3
 8010e32:	d301      	bcc.n	8010e38 <_nx_utility_string_length_check+0x28>
        {
            return(NX_SIZE_ERROR);
 8010e34:	2309      	movs	r3, #9
 8010e36:	e00f      	b.n	8010e58 <_nx_utility_string_length_check+0x48>
    for (i = 0; input_string[i]; i++)
 8010e38:	697b      	ldr	r3, [r7, #20]
 8010e3a:	3301      	adds	r3, #1
 8010e3c:	617b      	str	r3, [r7, #20]
 8010e3e:	68fa      	ldr	r2, [r7, #12]
 8010e40:	697b      	ldr	r3, [r7, #20]
 8010e42:	4413      	add	r3, r2
 8010e44:	781b      	ldrb	r3, [r3, #0]
 8010e46:	2b00      	cmp	r3, #0
 8010e48:	d1f0      	bne.n	8010e2c <_nx_utility_string_length_check+0x1c>
    }

    /* Return the string length if string_length is not NULL.
       String_length being NULL indicates the caller needs to check for string 
       length within the max_string_length. */
    if (string_length)
 8010e4a:	68bb      	ldr	r3, [r7, #8]
 8010e4c:	2b00      	cmp	r3, #0
 8010e4e:	d002      	beq.n	8010e56 <_nx_utility_string_length_check+0x46>
    {
        *string_length = i;
 8010e50:	68bb      	ldr	r3, [r7, #8]
 8010e52:	697a      	ldr	r2, [r7, #20]
 8010e54:	601a      	str	r2, [r3, #0]
    }

    /* Return success.  */
    return(NX_SUCCESS);
 8010e56:	2300      	movs	r3, #0
}
 8010e58:	4618      	mov	r0, r3
 8010e5a:	371c      	adds	r7, #28
 8010e5c:	46bd      	mov	sp, r7
 8010e5e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8010e62:	4770      	bx	lr

08010e64 <_nxd_udp_packet_info_extract>:
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
UINT  _nxd_udp_packet_info_extract(NX_PACKET *packet_ptr, NXD_ADDRESS *ip_address,
                                   UINT *protocol, UINT *port, UINT *interface_index)
{
 8010e64:	b480      	push	{r7}
 8010e66:	b089      	sub	sp, #36	; 0x24
 8010e68:	af00      	add	r7, sp, #0
 8010e6a:	60f8      	str	r0, [r7, #12]
 8010e6c:	60b9      	str	r1, [r7, #8]
 8010e6e:	607a      	str	r2, [r7, #4]
 8010e70:	603b      	str	r3, [r7, #0]
#ifdef FEATURE_NX_IPV6
NX_IPV6_HEADER *ipv6_header;
#endif /* FEATURE_NX_IPV6 */


    if (ip_address)
 8010e72:	68bb      	ldr	r3, [r7, #8]
 8010e74:	2b00      	cmp	r3, #0
 8010e76:	d011      	beq.n	8010e9c <_nxd_udp_packet_info_extract+0x38>
    {

#ifndef NX_DISABLE_IPV4
        if (packet_ptr -> nx_packet_ip_version == NX_IP_VERSION_V4)
 8010e78:	68fb      	ldr	r3, [r7, #12]
 8010e7a:	f893 302c 	ldrb.w	r3, [r3, #44]	; 0x2c
 8010e7e:	2b04      	cmp	r3, #4
 8010e80:	d10a      	bne.n	8010e98 <_nxd_udp_packet_info_extract+0x34>
        {

            /*lint -e{927} -e{826} suppress cast of pointer to pointer, since it is necessary  */
            ipv4_header = (NX_IPV4_HEADER *)packet_ptr -> nx_packet_ip_header;
 8010e82:	68fb      	ldr	r3, [r7, #12]
 8010e84:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8010e86:	61fb      	str	r3, [r7, #28]

            ip_address -> nxd_ip_version = NX_IP_VERSION_V4;
 8010e88:	68bb      	ldr	r3, [r7, #8]
 8010e8a:	2204      	movs	r2, #4
 8010e8c:	601a      	str	r2, [r3, #0]

            /* At this point, the IP address in the IPv4 header is in host byte order. */
            ip_address -> nxd_ip_address.v4 = ipv4_header -> nx_ip_header_source_ip;
 8010e8e:	69fb      	ldr	r3, [r7, #28]
 8010e90:	68da      	ldr	r2, [r3, #12]
 8010e92:	68bb      	ldr	r3, [r7, #8]
 8010e94:	605a      	str	r2, [r3, #4]
 8010e96:	e001      	b.n	8010e9c <_nxd_udp_packet_info_extract+0x38>
        else
#endif /* FEATURE_NX_IPV6 */
        {

            /* Invalid IP version . */
            return(NX_INVALID_PACKET);
 8010e98:	2312      	movs	r3, #18
 8010e9a:	e032      	b.n	8010f02 <_nxd_udp_packet_info_extract+0x9e>
        }
    }

    /* Build an address to the current top of the packet.  */
    /*lint -e{927} -e{826} suppress cast of pointer to pointer, since it is necessary  */
    temp_ptr =  (ULONG *)packet_ptr -> nx_packet_prepend_ptr;
 8010e9c:	68fb      	ldr	r3, [r7, #12]
 8010e9e:	689b      	ldr	r3, [r3, #8]
 8010ea0:	61bb      	str	r3, [r7, #24]

    /* Pickup the source port.  */
    source_port =  (UINT)(*(temp_ptr - 2) >> NX_SHIFT_BY_16);
 8010ea2:	69bb      	ldr	r3, [r7, #24]
 8010ea4:	3b08      	subs	r3, #8
 8010ea6:	681b      	ldr	r3, [r3, #0]
 8010ea8:	0c1b      	lsrs	r3, r3, #16
 8010eaa:	617b      	str	r3, [r7, #20]
    if (port != NX_NULL)
 8010eac:	683b      	ldr	r3, [r7, #0]
 8010eae:	2b00      	cmp	r3, #0
 8010eb0:	d002      	beq.n	8010eb8 <_nxd_udp_packet_info_extract+0x54>
    {
        *port = source_port;
 8010eb2:	683b      	ldr	r3, [r7, #0]
 8010eb4:	697a      	ldr	r2, [r7, #20]
 8010eb6:	601a      	str	r2, [r3, #0]
    }

    if (protocol != NX_NULL)
 8010eb8:	687b      	ldr	r3, [r7, #4]
 8010eba:	2b00      	cmp	r3, #0
 8010ebc:	d002      	beq.n	8010ec4 <_nxd_udp_packet_info_extract+0x60>
    {
        *protocol = 0x11;
 8010ebe:	687b      	ldr	r3, [r7, #4]
 8010ec0:	2211      	movs	r2, #17
 8010ec2:	601a      	str	r2, [r3, #0]
    }

    /* If trace is enabled, insert this event into the trace buffer.  */
    NX_TRACE_IN_LINE_INSERT(NX_TRACE_UDP_SOURCE_EXTRACT, packet_ptr, address, source_port, 0, NX_TRACE_PACKET_EVENTS, 0, 0);

    if (interface_index == NX_NULL)
 8010ec4:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8010ec6:	2b00      	cmp	r3, #0
 8010ec8:	d101      	bne.n	8010ece <_nxd_udp_packet_info_extract+0x6a>
    {
        return(NX_SUCCESS);
 8010eca:	2300      	movs	r3, #0
 8010ecc:	e019      	b.n	8010f02 <_nxd_udp_packet_info_extract+0x9e>
    }

    /* Search for interface index number.  Initialize interface value as
       invalid (0xFFFFFFFF).  Once we find valid interface, we will update
       the returned value. */
    *interface_index = 0xFFFFFFFF;
 8010ece:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8010ed0:	f04f 32ff 	mov.w	r2, #4294967295
 8010ed4:	601a      	str	r2, [r3, #0]

    if (packet_ptr -> nx_packet_ip_version == NX_IP_VERSION_V4)
 8010ed6:	68fb      	ldr	r3, [r7, #12]
 8010ed8:	f893 302c 	ldrb.w	r3, [r3, #44]	; 0x2c
 8010edc:	2b04      	cmp	r3, #4
 8010ede:	d106      	bne.n	8010eee <_nxd_udp_packet_info_extract+0x8a>
    {
        nx_interface = packet_ptr -> nx_packet_address.nx_packet_interface_ptr;
 8010ee0:	68fb      	ldr	r3, [r7, #12]
 8010ee2:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8010ee4:	613b      	str	r3, [r7, #16]
    else
    {
        return(NX_SUCCESS);
    }

    if (nx_interface == NX_NULL)
 8010ee6:	693b      	ldr	r3, [r7, #16]
 8010ee8:	2b00      	cmp	r3, #0
 8010eea:	d104      	bne.n	8010ef6 <_nxd_udp_packet_info_extract+0x92>
 8010eec:	e001      	b.n	8010ef2 <_nxd_udp_packet_info_extract+0x8e>
        return(NX_SUCCESS);
 8010eee:	2300      	movs	r3, #0
 8010ef0:	e007      	b.n	8010f02 <_nxd_udp_packet_info_extract+0x9e>
    {

        /* No interface attached.  Done here, and return success. */
        return(NX_SUCCESS);
 8010ef2:	2300      	movs	r3, #0
 8010ef4:	e005      	b.n	8010f02 <_nxd_udp_packet_info_extract+0x9e>
    }

    *interface_index = (UINT)nx_interface -> nx_interface_index;
 8010ef6:	693b      	ldr	r3, [r7, #16]
 8010ef8:	79db      	ldrb	r3, [r3, #7]
 8010efa:	461a      	mov	r2, r3
 8010efc:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8010efe:	601a      	str	r2, [r3, #0]

    return(NX_SUCCESS);
 8010f00:	2300      	movs	r3, #0
}
 8010f02:	4618      	mov	r0, r3
 8010f04:	3724      	adds	r7, #36	; 0x24
 8010f06:	46bd      	mov	sp, r7
 8010f08:	f85d 7b04 	ldr.w	r7, [sp], #4
 8010f0c:	4770      	bx	lr

08010f0e <_nxd_udp_socket_send>:
/**************************************************************************/
UINT  _nxd_udp_socket_send(NX_UDP_SOCKET *socket_ptr,
                           NX_PACKET     *packet_ptr,
                           NXD_ADDRESS   *ip_address,
                           UINT           port)
{
 8010f0e:	b590      	push	{r4, r7, lr}
 8010f10:	b095      	sub	sp, #84	; 0x54
 8010f12:	af04      	add	r7, sp, #16
 8010f14:	60f8      	str	r0, [r7, #12]
 8010f16:	60b9      	str	r1, [r7, #8]
 8010f18:	607a      	str	r2, [r7, #4]
 8010f1a:	603b      	str	r3, [r7, #0]
TX_INTERRUPT_SAVE_AREA

NX_IP         *ip_ptr;
NX_UDP_HEADER *udp_header_ptr;
ULONG         *ip_src_addr = NX_NULL, *ip_dest_addr = NX_NULL;
 8010f1c:	2300      	movs	r3, #0
 8010f1e:	63fb      	str	r3, [r7, #60]	; 0x3c
 8010f20:	2300      	movs	r3, #0
 8010f22:	63bb      	str	r3, [r7, #56]	; 0x38
#ifndef NX_DISABLE_IPV4
ULONG          next_hop_address = 0;
 8010f24:	2300      	movs	r3, #0
 8010f26:	613b      	str	r3, [r7, #16]
#endif /* !NX_DISABLE_IPV4  */
#if !defined(NX_DISABLE_IPV4) || (defined(FEATURE_NX_IPV6) && defined(NX_ENABLE_INTERFACE_CAPABILITY))
NX_INTERFACE  *interface_ptr = NX_NULL;
 8010f28:	2300      	movs	r3, #0
 8010f2a:	633b      	str	r3, [r7, #48]	; 0x30
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 8010f2c:	f3ef 8310 	mrs	r3, PRIMASK
 8010f30:	623b      	str	r3, [r7, #32]
    return(posture);
 8010f32:	6a3b      	ldr	r3, [r7, #32]
    int_posture = __get_interrupt_posture();
 8010f34:	61fb      	str	r3, [r7, #28]
    __asm__ volatile ("CPSID i" : : : "memory");
 8010f36:	b672      	cpsid	i
    return(int_posture);
 8010f38:	69fb      	ldr	r3, [r7, #28]
    /* Disable UDP TX checksum. */
    compute_checksum = 0;
#endif /* NX_DISABLE_UDP_TX_CHECKSUM */

    /* Lockout interrupts.  */
    TX_DISABLE
 8010f3a:	62fb      	str	r3, [r7, #44]	; 0x2c

    /* Add debug information. */
    NX_PACKET_DEBUG(__FILE__, __LINE__, packet_ptr);

    /* Determine if the socket is currently bound to a UDP port.  */
    if (!socket_ptr ->  nx_udp_socket_bound_next)
 8010f3c:	68fb      	ldr	r3, [r7, #12]
 8010f3e:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 8010f40:	2b00      	cmp	r3, #0
 8010f42:	d107      	bne.n	8010f54 <_nxd_udp_socket_send+0x46>
 8010f44:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8010f46:	61bb      	str	r3, [r7, #24]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 8010f48:	69bb      	ldr	r3, [r7, #24]
 8010f4a:	f383 8810 	msr	PRIMASK, r3
}
 8010f4e:	bf00      	nop

        /* Restore interrupts.  */
        TX_RESTORE

        /* Socket is not bound, return an error message.  */
        return(NX_NOT_BOUND);
 8010f50:	2324      	movs	r3, #36	; 0x24
 8010f52:	e0c1      	b.n	80110d8 <_nxd_udp_socket_send+0x1ca>
    }

    /* Pickup the important information from the socket.  */

    /* Set up the pointer to the associated IP instance.  */
    ip_ptr =  socket_ptr -> nx_udp_socket_ip_ptr;
 8010f54:	68fb      	ldr	r3, [r7, #12]
 8010f56:	68db      	ldr	r3, [r3, #12]
 8010f58:	62bb      	str	r3, [r7, #40]	; 0x28
 8010f5a:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8010f5c:	617b      	str	r3, [r7, #20]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 8010f5e:	697b      	ldr	r3, [r7, #20]
 8010f60:	f383 8810 	msr	PRIMASK, r3
}
 8010f64:	bf00      	nop

    /* Restore interrupts.  */
    TX_RESTORE

#ifndef NX_DISABLE_IPV4
    if (ip_address -> nxd_ip_version == NX_IP_VERSION_V4)
 8010f66:	687b      	ldr	r3, [r7, #4]
 8010f68:	681b      	ldr	r3, [r3, #0]
 8010f6a:	2b04      	cmp	r3, #4
 8010f6c:	d118      	bne.n	8010fa0 <_nxd_udp_socket_send+0x92>
    {

        /* Look for a suitable interface. */
        _nx_ip_route_find(ip_ptr, ip_address -> nxd_ip_address.v4, &packet_ptr -> nx_packet_address.nx_packet_interface_ptr,
 8010f6e:	687b      	ldr	r3, [r7, #4]
 8010f70:	6859      	ldr	r1, [r3, #4]
 8010f72:	68bb      	ldr	r3, [r7, #8]
 8010f74:	f103 0230 	add.w	r2, r3, #48	; 0x30
 8010f78:	f107 0310 	add.w	r3, r7, #16
 8010f7c:	6ab8      	ldr	r0, [r7, #40]	; 0x28
 8010f7e:	f7f9 ff49 	bl	800ae14 <_nx_ip_route_find>
                          &next_hop_address);

        /* Check the packet interface.  */
        if (!packet_ptr -> nx_packet_address.nx_packet_interface_ptr)
 8010f82:	68bb      	ldr	r3, [r7, #8]
 8010f84:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8010f86:	2b00      	cmp	r3, #0
 8010f88:	d101      	bne.n	8010f8e <_nxd_udp_socket_send+0x80>
        {

            /* None found; return the error status. */
            return(NX_IP_ADDRESS_ERROR);
 8010f8a:	2321      	movs	r3, #33	; 0x21
 8010f8c:	e0a4      	b.n	80110d8 <_nxd_udp_socket_send+0x1ca>
        }

        interface_ptr = packet_ptr -> nx_packet_address.nx_packet_interface_ptr;
 8010f8e:	68bb      	ldr	r3, [r7, #8]
 8010f90:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8010f92:	633b      	str	r3, [r7, #48]	; 0x30

        /* Fill in the IP src/dest address */
        ip_dest_addr = &ip_address -> nxd_ip_address.v4;
 8010f94:	687b      	ldr	r3, [r7, #4]
 8010f96:	3304      	adds	r3, #4
 8010f98:	63bb      	str	r3, [r7, #56]	; 0x38
        ip_src_addr = &interface_ptr -> nx_interface_ip_address;
 8010f9a:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8010f9c:	3314      	adds	r3, #20
 8010f9e:	63fb      	str	r3, [r7, #60]	; 0x3c
        }
    }
#endif /* NX_IPSEC_ENABLE */

    /* Prepend the UDP header to the packet.  First, make room for the UDP header.  */
    packet_ptr -> nx_packet_prepend_ptr =  packet_ptr -> nx_packet_prepend_ptr - sizeof(NX_UDP_HEADER);
 8010fa0:	68bb      	ldr	r3, [r7, #8]
 8010fa2:	689b      	ldr	r3, [r3, #8]
 8010fa4:	f1a3 0208 	sub.w	r2, r3, #8
 8010fa8:	68bb      	ldr	r3, [r7, #8]
 8010faa:	609a      	str	r2, [r3, #8]

    /* Set the correct IP version. */
    packet_ptr -> nx_packet_ip_version = (UCHAR)(ip_address -> nxd_ip_version);
 8010fac:	687b      	ldr	r3, [r7, #4]
 8010fae:	681b      	ldr	r3, [r3, #0]
 8010fb0:	b2da      	uxtb	r2, r3
 8010fb2:	68bb      	ldr	r3, [r7, #8]
 8010fb4:	f883 202c 	strb.w	r2, [r3, #44]	; 0x2c

#ifndef NX_DISABLE_UDP_INFO
    /* Increment the total UDP packets sent count.  */
    ip_ptr -> nx_ip_udp_packets_sent++;
 8010fb8:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8010fba:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
 8010fbe:	1c5a      	adds	r2, r3, #1
 8010fc0:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8010fc2:	f8c3 2088 	str.w	r2, [r3, #136]	; 0x88

    /* Increment the total UDP bytes sent.  */
    ip_ptr -> nx_ip_udp_bytes_sent +=  packet_ptr -> nx_packet_length;
 8010fc6:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8010fc8:	f8d3 208c 	ldr.w	r2, [r3, #140]	; 0x8c
 8010fcc:	68bb      	ldr	r3, [r7, #8]
 8010fce:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8010fd0:	441a      	add	r2, r3
 8010fd2:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8010fd4:	f8c3 208c 	str.w	r2, [r3, #140]	; 0x8c

    /* Increment the total UDP packets sent count for this socket.  */
    socket_ptr -> nx_udp_socket_packets_sent++;
 8010fd8:	68fb      	ldr	r3, [r7, #12]
 8010fda:	691b      	ldr	r3, [r3, #16]
 8010fdc:	1c5a      	adds	r2, r3, #1
 8010fde:	68fb      	ldr	r3, [r7, #12]
 8010fe0:	611a      	str	r2, [r3, #16]

    /* Increment the total UDP bytes sent for this socket.  */
    socket_ptr -> nx_udp_socket_bytes_sent +=  packet_ptr -> nx_packet_length;
 8010fe2:	68fb      	ldr	r3, [r7, #12]
 8010fe4:	695a      	ldr	r2, [r3, #20]
 8010fe6:	68bb      	ldr	r3, [r7, #8]
 8010fe8:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8010fea:	441a      	add	r2, r3
 8010fec:	68fb      	ldr	r3, [r7, #12]
 8010fee:	615a      	str	r2, [r3, #20]
#endif

    /* Increase the packet length.  */
    packet_ptr -> nx_packet_length =  packet_ptr -> nx_packet_length + (ULONG)sizeof(NX_UDP_HEADER);
 8010ff0:	68bb      	ldr	r3, [r7, #8]
 8010ff2:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8010ff4:	f103 0208 	add.w	r2, r3, #8
 8010ff8:	68bb      	ldr	r3, [r7, #8]
 8010ffa:	625a      	str	r2, [r3, #36]	; 0x24

    /* Setup the UDP header pointer.  */
    /*lint -e{927} -e{826} suppress cast of pointer to pointer, since it is necessary  */
    udp_header_ptr =  (NX_UDP_HEADER *)packet_ptr -> nx_packet_prepend_ptr;
 8010ffc:	68bb      	ldr	r3, [r7, #8]
 8010ffe:	689b      	ldr	r3, [r3, #8]
 8011000:	627b      	str	r3, [r7, #36]	; 0x24

    /* Build the first 32-bit word of the UDP header.  */
    udp_header_ptr -> nx_udp_header_word_0 =
        (((ULONG)socket_ptr -> nx_udp_socket_port) << NX_SHIFT_BY_16) | (ULONG)port;
 8011002:	68fb      	ldr	r3, [r7, #12]
 8011004:	689b      	ldr	r3, [r3, #8]
 8011006:	041a      	lsls	r2, r3, #16
 8011008:	683b      	ldr	r3, [r7, #0]
 801100a:	431a      	orrs	r2, r3
    udp_header_ptr -> nx_udp_header_word_0 =
 801100c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801100e:	601a      	str	r2, [r3, #0]

    /* Build the second 32-bit word of the UDP header.  */
    udp_header_ptr -> nx_udp_header_word_1 =  (packet_ptr -> nx_packet_length << NX_SHIFT_BY_16);
 8011010:	68bb      	ldr	r3, [r7, #8]
 8011012:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8011014:	041a      	lsls	r2, r3, #16
 8011016:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8011018:	605a      	str	r2, [r3, #4]
    /* If trace is enabled, insert this event into the trace buffer.  */
    NX_TRACE_IN_LINE_INSERT(NX_TRACE_INTERNAL_UDP_SEND, ip_ptr, socket_ptr, packet_ptr, udp_header_ptr -> nx_udp_header_word_0, NX_TRACE_INTERNAL_EVENTS, 0, 0);

    /* Endian swapping logic.  If NX_LITTLE_ENDIAN is specified, these macros will
       swap the endian of the UDP header.  */
    NX_CHANGE_ULONG_ENDIAN(udp_header_ptr -> nx_udp_header_word_0);
 801101a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801101c:	681b      	ldr	r3, [r3, #0]
 801101e:	ba1a      	rev	r2, r3
 8011020:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8011022:	601a      	str	r2, [r3, #0]
    NX_CHANGE_ULONG_ENDIAN(udp_header_ptr -> nx_udp_header_word_1);
 8011024:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8011026:	685b      	ldr	r3, [r3, #4]
 8011028:	ba1a      	rev	r2, r3
 801102a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801102c:	605a      	str	r2, [r3, #4]
       Note that with IPv6, UDP packet checksum is mandatory. However if the underly device
       driver is able to compute UDP checksum in hardware, let the driver handle the checksum
       computation.
     */

    if ((!socket_ptr -> nx_udp_socket_disable_checksum) ||
 801102e:	68fb      	ldr	r3, [r7, #12]
 8011030:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 8011032:	2b00      	cmp	r3, #0
 8011034:	d003      	beq.n	801103e <_nxd_udp_socket_send+0x130>
        (ip_address -> nxd_ip_version == NX_IP_VERSION_V6))
 8011036:	687b      	ldr	r3, [r7, #4]
 8011038:	681b      	ldr	r3, [r3, #0]
    if ((!socket_ptr -> nx_udp_socket_disable_checksum) ||
 801103a:	2b06      	cmp	r3, #6
 801103c:	d124      	bne.n	8011088 <_nxd_udp_socket_send+0x17a>
        ULONG checksum;

            /* Yes, we need to compute the UDP checksum.  */
            checksum = _nx_ip_checksum_compute(packet_ptr,
                                               NX_PROTOCOL_UDP,
                                               (UINT)packet_ptr -> nx_packet_length,
 801103e:	68bb      	ldr	r3, [r7, #8]
 8011040:	6a5a      	ldr	r2, [r3, #36]	; 0x24
            checksum = _nx_ip_checksum_compute(packet_ptr,
 8011042:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8011044:	9300      	str	r3, [sp, #0]
 8011046:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8011048:	2111      	movs	r1, #17
 801104a:	68b8      	ldr	r0, [r7, #8]
 801104c:	f7f8 fdec 	bl	8009c28 <_nx_ip_checksum_compute>
 8011050:	4603      	mov	r3, r0
 8011052:	637b      	str	r3, [r7, #52]	; 0x34
                                               ip_src_addr,
                                               ip_dest_addr);
            checksum = ~checksum & NX_LOWER_16_MASK;
 8011054:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8011056:	43db      	mvns	r3, r3
 8011058:	b29b      	uxth	r3, r3
 801105a:	637b      	str	r3, [r7, #52]	; 0x34

            /* If the computed checksum is zero, it will be transmitted as all ones. */
            /* RFC 768, page 2. */
            if (checksum == 0)
 801105c:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 801105e:	2b00      	cmp	r3, #0
 8011060:	d102      	bne.n	8011068 <_nxd_udp_socket_send+0x15a>
            {
                checksum = 0xFFFF;
 8011062:	f64f 73ff 	movw	r3, #65535	; 0xffff
 8011066:	637b      	str	r3, [r7, #52]	; 0x34
            }

            NX_CHANGE_ULONG_ENDIAN(udp_header_ptr -> nx_udp_header_word_1);
 8011068:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801106a:	685b      	ldr	r3, [r3, #4]
 801106c:	ba1a      	rev	r2, r3
 801106e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8011070:	605a      	str	r2, [r3, #4]

            udp_header_ptr -> nx_udp_header_word_1 = udp_header_ptr -> nx_udp_header_word_1 | checksum;
 8011072:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8011074:	685a      	ldr	r2, [r3, #4]
 8011076:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8011078:	431a      	orrs	r2, r3
 801107a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801107c:	605a      	str	r2, [r3, #4]

            NX_CHANGE_ULONG_ENDIAN(udp_header_ptr -> nx_udp_header_word_1);
 801107e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8011080:	685b      	ldr	r3, [r3, #4]
 8011082:	ba1a      	rev	r2, r3
 8011084:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8011086:	605a      	str	r2, [r3, #4]
        }
#endif
    }

    /* Get mutex protection.  */
    tx_mutex_get(&(ip_ptr -> nx_ip_protection), TX_WAIT_FOREVER);
 8011088:	6abb      	ldr	r3, [r7, #40]	; 0x28
 801108a:	f503 739e 	add.w	r3, r3, #316	; 0x13c
 801108e:	f04f 31ff 	mov.w	r1, #4294967295
 8011092:	4618      	mov	r0, r3
 8011094:	f001 fe6e 	bl	8012d74 <_tx_mutex_get>

#ifndef NX_DISABLE_IPV4
    /* Send the UDP packet to the IPv4 component.  */
    if (ip_address -> nxd_ip_version == NX_IP_VERSION_V4)
 8011098:	687b      	ldr	r3, [r7, #4]
 801109a:	681b      	ldr	r3, [r3, #0]
 801109c:	2b04      	cmp	r3, #4
 801109e:	d114      	bne.n	80110ca <_nxd_udp_socket_send+0x1bc>
    {

        /*lint -e{644} suppress variable might not be initialized, since "next_hop_address" was initialized in _nx_ip_route_find. */
        _nx_ip_packet_send(ip_ptr, packet_ptr, ip_address -> nxd_ip_address.v4,
 80110a0:	687b      	ldr	r3, [r7, #4]
 80110a2:	6858      	ldr	r0, [r3, #4]
 80110a4:	68fb      	ldr	r3, [r7, #12]
 80110a6:	6adc      	ldr	r4, [r3, #44]	; 0x2c
                           socket_ptr -> nx_udp_socket_type_of_service,
                           socket_ptr -> nx_udp_socket_time_to_live,
 80110a8:	68fb      	ldr	r3, [r7, #12]
 80110aa:	6b1b      	ldr	r3, [r3, #48]	; 0x30
        _nx_ip_packet_send(ip_ptr, packet_ptr, ip_address -> nxd_ip_address.v4,
 80110ac:	68fa      	ldr	r2, [r7, #12]
 80110ae:	6b52      	ldr	r2, [r2, #52]	; 0x34
 80110b0:	6939      	ldr	r1, [r7, #16]
 80110b2:	9103      	str	r1, [sp, #12]
 80110b4:	9202      	str	r2, [sp, #8]
 80110b6:	f44f 1288 	mov.w	r2, #1114112	; 0x110000
 80110ba:	9201      	str	r2, [sp, #4]
 80110bc:	9300      	str	r3, [sp, #0]
 80110be:	4623      	mov	r3, r4
 80110c0:	4602      	mov	r2, r0
 80110c2:	68b9      	ldr	r1, [r7, #8]
 80110c4:	6ab8      	ldr	r0, [r7, #40]	; 0x28
 80110c6:	f7f9 fe33 	bl	800ad30 <_nx_ip_packet_send>
                             ip_dest_addr);
    }
#endif /* FEATURE_NX_IPV6 */

    /* Release mutex protection.  */
    tx_mutex_put(&(ip_ptr -> nx_ip_protection));
 80110ca:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80110cc:	f503 739e 	add.w	r3, r3, #316	; 0x13c
 80110d0:	4618      	mov	r0, r3
 80110d2:	f002 f8c7 	bl	8013264 <_tx_mutex_put>

    /* Return a successful status.  */
    return(NX_SUCCESS);
 80110d6:	2300      	movs	r3, #0
}
 80110d8:	4618      	mov	r0, r3
 80110da:	3744      	adds	r7, #68	; 0x44
 80110dc:	46bd      	mov	sp, r7
 80110de:	bd90      	pop	{r4, r7, pc}

080110e0 <_nxe_arp_enable>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
UINT  _nxe_arp_enable(NX_IP *ip_ptr, VOID *arp_cache_memory, ULONG arp_cache_size)
{
 80110e0:	b580      	push	{r7, lr}
 80110e2:	b088      	sub	sp, #32
 80110e4:	af00      	add	r7, sp, #0
 80110e6:	60f8      	str	r0, [r7, #12]
 80110e8:	60b9      	str	r1, [r7, #8]
 80110ea:	607a      	str	r2, [r7, #4]
#ifndef NX_DISABLE_IPV4
UINT status;


    /* Check for invalid input pointers.  */
    if ((ip_ptr == NX_NULL) || (ip_ptr -> nx_ip_id != NX_IP_ID) || (arp_cache_memory == NX_NULL))
 80110ec:	68fb      	ldr	r3, [r7, #12]
 80110ee:	2b00      	cmp	r3, #0
 80110f0:	d007      	beq.n	8011102 <_nxe_arp_enable+0x22>
 80110f2:	68fb      	ldr	r3, [r7, #12]
 80110f4:	681b      	ldr	r3, [r3, #0]
 80110f6:	4a1c      	ldr	r2, [pc, #112]	; (8011168 <_nxe_arp_enable+0x88>)
 80110f8:	4293      	cmp	r3, r2
 80110fa:	d102      	bne.n	8011102 <_nxe_arp_enable+0x22>
 80110fc:	68bb      	ldr	r3, [r7, #8]
 80110fe:	2b00      	cmp	r3, #0
 8011100:	d101      	bne.n	8011106 <_nxe_arp_enable+0x26>
    {
        return(NX_PTR_ERROR);
 8011102:	2307      	movs	r3, #7
 8011104:	e02c      	b.n	8011160 <_nxe_arp_enable+0x80>
    }

    /* Check to see if ARP is already enabled.  */
    if (ip_ptr -> nx_ip_arp_allocate)
 8011106:	68fb      	ldr	r3, [r7, #12]
 8011108:	f8d3 36e4 	ldr.w	r3, [r3, #1764]	; 0x6e4
 801110c:	2b00      	cmp	r3, #0
 801110e:	d001      	beq.n	8011114 <_nxe_arp_enable+0x34>
    {
        return(NX_ALREADY_ENABLED);
 8011110:	2315      	movs	r3, #21
 8011112:	e025      	b.n	8011160 <_nxe_arp_enable+0x80>
    }

    /* Check for invalid ARP cache size.  */
    if (arp_cache_size < sizeof(NX_ARP))
 8011114:	687b      	ldr	r3, [r7, #4]
 8011116:	2b33      	cmp	r3, #51	; 0x33
 8011118:	d801      	bhi.n	801111e <_nxe_arp_enable+0x3e>
    {
        return(NX_SIZE_ERROR);
 801111a:	2309      	movs	r3, #9
 801111c:	e020      	b.n	8011160 <_nxe_arp_enable+0x80>
    __asm__ volatile (" MRS  %0,IPSR ": "=r" (ipsr_value) );
 801111e:	f3ef 8305 	mrs	r3, IPSR
 8011122:	61bb      	str	r3, [r7, #24]
    return(ipsr_value);
 8011124:	69ba      	ldr	r2, [r7, #24]
    }

    /* Check for appropriate caller.  */
    NX_INIT_AND_THREADS_CALLER_CHECKING
 8011126:	4b11      	ldr	r3, [pc, #68]	; (801116c <_nxe_arp_enable+0x8c>)
 8011128:	681b      	ldr	r3, [r3, #0]
 801112a:	4313      	orrs	r3, r2
 801112c:	2b00      	cmp	r3, #0
 801112e:	d009      	beq.n	8011144 <_nxe_arp_enable+0x64>
    __asm__ volatile (" MRS  %0,IPSR ": "=r" (ipsr_value) );
 8011130:	f3ef 8305 	mrs	r3, IPSR
 8011134:	617b      	str	r3, [r7, #20]
    return(ipsr_value);
 8011136:	697a      	ldr	r2, [r7, #20]
 8011138:	4b0c      	ldr	r3, [pc, #48]	; (801116c <_nxe_arp_enable+0x8c>)
 801113a:	681b      	ldr	r3, [r3, #0]
 801113c:	4313      	orrs	r3, r2
 801113e:	f1b3 3ff0 	cmp.w	r3, #4042322160	; 0xf0f0f0f0
 8011142:	d304      	bcc.n	801114e <_nxe_arp_enable+0x6e>
 8011144:	4b0a      	ldr	r3, [pc, #40]	; (8011170 <_nxe_arp_enable+0x90>)
 8011146:	681b      	ldr	r3, [r3, #0]
 8011148:	4a0a      	ldr	r2, [pc, #40]	; (8011174 <_nxe_arp_enable+0x94>)
 801114a:	4293      	cmp	r3, r2
 801114c:	d101      	bne.n	8011152 <_nxe_arp_enable+0x72>
 801114e:	2311      	movs	r3, #17
 8011150:	e006      	b.n	8011160 <_nxe_arp_enable+0x80>

    /* Call actual ARP enable function.  */
    status =  _nx_arp_enable(ip_ptr, arp_cache_memory, arp_cache_size);
 8011152:	687a      	ldr	r2, [r7, #4]
 8011154:	68b9      	ldr	r1, [r7, #8]
 8011156:	68f8      	ldr	r0, [r7, #12]
 8011158:	f7f7 fb70 	bl	800883c <_nx_arp_enable>
 801115c:	61f8      	str	r0, [r7, #28]

    /* Return completion status.  */
    return(status);
 801115e:	69fb      	ldr	r3, [r7, #28]
    NX_PARAMETER_NOT_USED(arp_cache_memory);
    NX_PARAMETER_NOT_USED(arp_cache_size);

    return(NX_NOT_SUPPORTED);
#endif /* !NX_DISABLE_IPV4  */
}
 8011160:	4618      	mov	r0, r3
 8011162:	3720      	adds	r7, #32
 8011164:	46bd      	mov	sp, r7
 8011166:	bd80      	pop	{r7, pc}
 8011168:	49502020 	.word	0x49502020
 801116c:	24000078 	.word	0x24000078
 8011170:	24031bc4 	.word	0x24031bc4
 8011174:	24031d0c 	.word	0x24031d0c

08011178 <_nxe_icmp_enable>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
UINT  _nxe_icmp_enable(NX_IP *ip_ptr)
{
 8011178:	b580      	push	{r7, lr}
 801117a:	b086      	sub	sp, #24
 801117c:	af00      	add	r7, sp, #0
 801117e:	6078      	str	r0, [r7, #4]
#ifndef NX_DISABLE_IPV4
UINT status;


    /* Check for invalid input pointers.  */
    if ((ip_ptr == NX_NULL) || (ip_ptr -> nx_ip_id != NX_IP_ID))
 8011180:	687b      	ldr	r3, [r7, #4]
 8011182:	2b00      	cmp	r3, #0
 8011184:	d004      	beq.n	8011190 <_nxe_icmp_enable+0x18>
 8011186:	687b      	ldr	r3, [r7, #4]
 8011188:	681b      	ldr	r3, [r3, #0]
 801118a:	4a17      	ldr	r2, [pc, #92]	; (80111e8 <_nxe_icmp_enable+0x70>)
 801118c:	4293      	cmp	r3, r2
 801118e:	d001      	beq.n	8011194 <_nxe_icmp_enable+0x1c>
    {
        return(NX_PTR_ERROR);
 8011190:	2307      	movs	r3, #7
 8011192:	e025      	b.n	80111e0 <_nxe_icmp_enable+0x68>
    }

    /* Check to see if ICMP is enabled.  */
    if (ip_ptr -> nx_ip_icmp_packet_receive)
 8011194:	687b      	ldr	r3, [r7, #4]
 8011196:	f8d3 3368 	ldr.w	r3, [r3, #872]	; 0x368
 801119a:	2b00      	cmp	r3, #0
 801119c:	d001      	beq.n	80111a2 <_nxe_icmp_enable+0x2a>
    {
        return(NX_ALREADY_ENABLED);
 801119e:	2315      	movs	r3, #21
 80111a0:	e01e      	b.n	80111e0 <_nxe_icmp_enable+0x68>
    __asm__ volatile (" MRS  %0,IPSR ": "=r" (ipsr_value) );
 80111a2:	f3ef 8305 	mrs	r3, IPSR
 80111a6:	613b      	str	r3, [r7, #16]
    return(ipsr_value);
 80111a8:	693a      	ldr	r2, [r7, #16]
    }

    /* Check for appropriate caller.  */
    NX_INIT_AND_THREADS_CALLER_CHECKING
 80111aa:	4b10      	ldr	r3, [pc, #64]	; (80111ec <_nxe_icmp_enable+0x74>)
 80111ac:	681b      	ldr	r3, [r3, #0]
 80111ae:	4313      	orrs	r3, r2
 80111b0:	2b00      	cmp	r3, #0
 80111b2:	d009      	beq.n	80111c8 <_nxe_icmp_enable+0x50>
    __asm__ volatile (" MRS  %0,IPSR ": "=r" (ipsr_value) );
 80111b4:	f3ef 8305 	mrs	r3, IPSR
 80111b8:	60fb      	str	r3, [r7, #12]
    return(ipsr_value);
 80111ba:	68fa      	ldr	r2, [r7, #12]
 80111bc:	4b0b      	ldr	r3, [pc, #44]	; (80111ec <_nxe_icmp_enable+0x74>)
 80111be:	681b      	ldr	r3, [r3, #0]
 80111c0:	4313      	orrs	r3, r2
 80111c2:	f1b3 3ff0 	cmp.w	r3, #4042322160	; 0xf0f0f0f0
 80111c6:	d304      	bcc.n	80111d2 <_nxe_icmp_enable+0x5a>
 80111c8:	4b09      	ldr	r3, [pc, #36]	; (80111f0 <_nxe_icmp_enable+0x78>)
 80111ca:	681b      	ldr	r3, [r3, #0]
 80111cc:	4a09      	ldr	r2, [pc, #36]	; (80111f4 <_nxe_icmp_enable+0x7c>)
 80111ce:	4293      	cmp	r3, r2
 80111d0:	d101      	bne.n	80111d6 <_nxe_icmp_enable+0x5e>
 80111d2:	2311      	movs	r3, #17
 80111d4:	e004      	b.n	80111e0 <_nxe_icmp_enable+0x68>

    /* Call actual ICMP enable function.  */
    status =  _nx_icmp_enable(ip_ptr);
 80111d6:	6878      	ldr	r0, [r7, #4]
 80111d8:	f7f8 f932 	bl	8009440 <_nx_icmp_enable>
 80111dc:	6178      	str	r0, [r7, #20]

    /* Return completion status.  */
    return(status);
 80111de:	697b      	ldr	r3, [r7, #20]
#else /* NX_DISABLE_IPV4  */
    NX_PARAMETER_NOT_USED(ip_ptr);

    return(NX_NOT_SUPPORTED);
#endif /* !NX_DISABLE_IPV4  */
}
 80111e0:	4618      	mov	r0, r3
 80111e2:	3718      	adds	r7, #24
 80111e4:	46bd      	mov	sp, r7
 80111e6:	bd80      	pop	{r7, pc}
 80111e8:	49502020 	.word	0x49502020
 80111ec:	24000078 	.word	0x24000078
 80111f0:	24031bc4 	.word	0x24031bc4
 80111f4:	24031d0c 	.word	0x24031d0c

080111f8 <_nxe_ip_address_change_notify>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
UINT  _nxe_ip_address_change_notify(NX_IP *ip_ptr, VOID (*ip_address_change_notify)(NX_IP *, VOID *), VOID *additional_info)
{
 80111f8:	b580      	push	{r7, lr}
 80111fa:	b088      	sub	sp, #32
 80111fc:	af00      	add	r7, sp, #0
 80111fe:	60f8      	str	r0, [r7, #12]
 8011200:	60b9      	str	r1, [r7, #8]
 8011202:	607a      	str	r2, [r7, #4]
#ifndef NX_DISABLE_IPV4
UINT status;


    /* Check for invalid input pointers.  */
    if ((ip_ptr == NX_NULL) || (ip_ptr -> nx_ip_id != NX_IP_ID))
 8011204:	68fb      	ldr	r3, [r7, #12]
 8011206:	2b00      	cmp	r3, #0
 8011208:	d004      	beq.n	8011214 <_nxe_ip_address_change_notify+0x1c>
 801120a:	68fb      	ldr	r3, [r7, #12]
 801120c:	681b      	ldr	r3, [r3, #0]
 801120e:	4a15      	ldr	r2, [pc, #84]	; (8011264 <_nxe_ip_address_change_notify+0x6c>)
 8011210:	4293      	cmp	r3, r2
 8011212:	d001      	beq.n	8011218 <_nxe_ip_address_change_notify+0x20>
    {
        return(NX_PTR_ERROR);
 8011214:	2307      	movs	r3, #7
 8011216:	e020      	b.n	801125a <_nxe_ip_address_change_notify+0x62>
    __asm__ volatile (" MRS  %0,IPSR ": "=r" (ipsr_value) );
 8011218:	f3ef 8305 	mrs	r3, IPSR
 801121c:	61bb      	str	r3, [r7, #24]
    return(ipsr_value);
 801121e:	69ba      	ldr	r2, [r7, #24]
    }

    /* Check for appropriate caller.  */
    NX_INIT_AND_THREADS_CALLER_CHECKING
 8011220:	4b11      	ldr	r3, [pc, #68]	; (8011268 <_nxe_ip_address_change_notify+0x70>)
 8011222:	681b      	ldr	r3, [r3, #0]
 8011224:	4313      	orrs	r3, r2
 8011226:	2b00      	cmp	r3, #0
 8011228:	d009      	beq.n	801123e <_nxe_ip_address_change_notify+0x46>
    __asm__ volatile (" MRS  %0,IPSR ": "=r" (ipsr_value) );
 801122a:	f3ef 8305 	mrs	r3, IPSR
 801122e:	617b      	str	r3, [r7, #20]
    return(ipsr_value);
 8011230:	697a      	ldr	r2, [r7, #20]
 8011232:	4b0d      	ldr	r3, [pc, #52]	; (8011268 <_nxe_ip_address_change_notify+0x70>)
 8011234:	681b      	ldr	r3, [r3, #0]
 8011236:	4313      	orrs	r3, r2
 8011238:	f1b3 3ff0 	cmp.w	r3, #4042322160	; 0xf0f0f0f0
 801123c:	d304      	bcc.n	8011248 <_nxe_ip_address_change_notify+0x50>
 801123e:	4b0b      	ldr	r3, [pc, #44]	; (801126c <_nxe_ip_address_change_notify+0x74>)
 8011240:	681b      	ldr	r3, [r3, #0]
 8011242:	4a0b      	ldr	r2, [pc, #44]	; (8011270 <_nxe_ip_address_change_notify+0x78>)
 8011244:	4293      	cmp	r3, r2
 8011246:	d101      	bne.n	801124c <_nxe_ip_address_change_notify+0x54>
 8011248:	2311      	movs	r3, #17
 801124a:	e006      	b.n	801125a <_nxe_ip_address_change_notify+0x62>

    /* Call actual IP address change notify function.  */
    status =  _nx_ip_address_change_notify(ip_ptr, ip_address_change_notify, additional_info);
 801124c:	687a      	ldr	r2, [r7, #4]
 801124e:	68b9      	ldr	r1, [r7, #8]
 8011250:	68f8      	ldr	r0, [r7, #12]
 8011252:	f7f8 fc89 	bl	8009b68 <_nx_ip_address_change_notify>
 8011256:	61f8      	str	r0, [r7, #28]

    /* Return completion status.  */
    return(status);
 8011258:	69fb      	ldr	r3, [r7, #28]
    NX_PARAMETER_NOT_USED(ip_address_change_notify);
    NX_PARAMETER_NOT_USED(additional_info);

    return(NX_NOT_SUPPORTED);
#endif /* !NX_DISABLE_IPV4  */
}
 801125a:	4618      	mov	r0, r3
 801125c:	3720      	adds	r7, #32
 801125e:	46bd      	mov	sp, r7
 8011260:	bd80      	pop	{r7, pc}
 8011262:	bf00      	nop
 8011264:	49502020 	.word	0x49502020
 8011268:	24000078 	.word	0x24000078
 801126c:	24031bc4 	.word	0x24031bc4
 8011270:	24031d0c 	.word	0x24031d0c

08011274 <_nxe_ip_address_get>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
UINT  _nxe_ip_address_get(NX_IP *ip_ptr, ULONG *ip_address, ULONG *network_mask)
{
 8011274:	b580      	push	{r7, lr}
 8011276:	b088      	sub	sp, #32
 8011278:	af00      	add	r7, sp, #0
 801127a:	60f8      	str	r0, [r7, #12]
 801127c:	60b9      	str	r1, [r7, #8]
 801127e:	607a      	str	r2, [r7, #4]
#ifndef NX_DISABLE_IPV4
UINT status;


    /* Check for invalid input pointers.  */
    if ((ip_ptr == NX_NULL) || (ip_ptr -> nx_ip_id != NX_IP_ID) || (ip_address == NX_NULL) || (network_mask == NX_NULL))
 8011280:	68fb      	ldr	r3, [r7, #12]
 8011282:	2b00      	cmp	r3, #0
 8011284:	d00a      	beq.n	801129c <_nxe_ip_address_get+0x28>
 8011286:	68fb      	ldr	r3, [r7, #12]
 8011288:	681b      	ldr	r3, [r3, #0]
 801128a:	4a18      	ldr	r2, [pc, #96]	; (80112ec <_nxe_ip_address_get+0x78>)
 801128c:	4293      	cmp	r3, r2
 801128e:	d105      	bne.n	801129c <_nxe_ip_address_get+0x28>
 8011290:	68bb      	ldr	r3, [r7, #8]
 8011292:	2b00      	cmp	r3, #0
 8011294:	d002      	beq.n	801129c <_nxe_ip_address_get+0x28>
 8011296:	687b      	ldr	r3, [r7, #4]
 8011298:	2b00      	cmp	r3, #0
 801129a:	d101      	bne.n	80112a0 <_nxe_ip_address_get+0x2c>
    {
        return(NX_PTR_ERROR);
 801129c:	2307      	movs	r3, #7
 801129e:	e020      	b.n	80112e2 <_nxe_ip_address_get+0x6e>
    __asm__ volatile (" MRS  %0,IPSR ": "=r" (ipsr_value) );
 80112a0:	f3ef 8305 	mrs	r3, IPSR
 80112a4:	61bb      	str	r3, [r7, #24]
    return(ipsr_value);
 80112a6:	69ba      	ldr	r2, [r7, #24]
    }

    /* Check for appropriate caller.  */
    NX_INIT_AND_THREADS_CALLER_CHECKING
 80112a8:	4b11      	ldr	r3, [pc, #68]	; (80112f0 <_nxe_ip_address_get+0x7c>)
 80112aa:	681b      	ldr	r3, [r3, #0]
 80112ac:	4313      	orrs	r3, r2
 80112ae:	2b00      	cmp	r3, #0
 80112b0:	d009      	beq.n	80112c6 <_nxe_ip_address_get+0x52>
    __asm__ volatile (" MRS  %0,IPSR ": "=r" (ipsr_value) );
 80112b2:	f3ef 8305 	mrs	r3, IPSR
 80112b6:	617b      	str	r3, [r7, #20]
    return(ipsr_value);
 80112b8:	697a      	ldr	r2, [r7, #20]
 80112ba:	4b0d      	ldr	r3, [pc, #52]	; (80112f0 <_nxe_ip_address_get+0x7c>)
 80112bc:	681b      	ldr	r3, [r3, #0]
 80112be:	4313      	orrs	r3, r2
 80112c0:	f1b3 3ff0 	cmp.w	r3, #4042322160	; 0xf0f0f0f0
 80112c4:	d304      	bcc.n	80112d0 <_nxe_ip_address_get+0x5c>
 80112c6:	4b0b      	ldr	r3, [pc, #44]	; (80112f4 <_nxe_ip_address_get+0x80>)
 80112c8:	681b      	ldr	r3, [r3, #0]
 80112ca:	4a0b      	ldr	r2, [pc, #44]	; (80112f8 <_nxe_ip_address_get+0x84>)
 80112cc:	4293      	cmp	r3, r2
 80112ce:	d101      	bne.n	80112d4 <_nxe_ip_address_get+0x60>
 80112d0:	2311      	movs	r3, #17
 80112d2:	e006      	b.n	80112e2 <_nxe_ip_address_get+0x6e>

    /* Call actual IP address get function.  */
    status =  _nx_ip_address_get(ip_ptr, ip_address, network_mask);
 80112d4:	687a      	ldr	r2, [r7, #4]
 80112d6:	68b9      	ldr	r1, [r7, #8]
 80112d8:	68f8      	ldr	r0, [r7, #12]
 80112da:	f7f8 fc74 	bl	8009bc6 <_nx_ip_address_get>
 80112de:	61f8      	str	r0, [r7, #28]

    /* Return completion status.  */
    return(status);
 80112e0:	69fb      	ldr	r3, [r7, #28]
    NX_PARAMETER_NOT_USED(ip_address);
    NX_PARAMETER_NOT_USED(network_mask);

    return(NX_NOT_SUPPORTED);
#endif /* !NX_DISABLE_IPV4  */
}
 80112e2:	4618      	mov	r0, r3
 80112e4:	3720      	adds	r7, #32
 80112e6:	46bd      	mov	sp, r7
 80112e8:	bd80      	pop	{r7, pc}
 80112ea:	bf00      	nop
 80112ec:	49502020 	.word	0x49502020
 80112f0:	24000078 	.word	0x24000078
 80112f4:	24031bc4 	.word	0x24031bc4
 80112f8:	24031d0c 	.word	0x24031d0c

080112fc <_nxe_ip_create>:
/*                                                                        */
/**************************************************************************/
UINT  _nxe_ip_create(NX_IP *ip_ptr, CHAR *name, ULONG ip_address, ULONG network_mask,
                     NX_PACKET_POOL *default_pool, VOID (*ip_link_driver)(struct NX_IP_DRIVER_STRUCT *),
                     VOID *memory_ptr, ULONG memory_size, UINT priority, UINT ip_control_block_size)
{
 80112fc:	b580      	push	{r7, lr}
 80112fe:	b092      	sub	sp, #72	; 0x48
 8011300:	af06      	add	r7, sp, #24
 8011302:	60f8      	str	r0, [r7, #12]
 8011304:	60b9      	str	r1, [r7, #8]
 8011306:	607a      	str	r2, [r7, #4]
 8011308:	603b      	str	r3, [r7, #0]

UINT       status;
UINT       old_threshold = 0;
 801130a:	2300      	movs	r3, #0
 801130c:	613b      	str	r3, [r7, #16]
UCHAR     *end_stack;
TX_THREAD *current_thread;


    /* Check for invalid input pointers.  */
    if ((ip_ptr == NX_NULL) || (default_pool == NX_NULL) ||
 801130e:	68fb      	ldr	r3, [r7, #12]
 8011310:	2b00      	cmp	r3, #0
 8011312:	d012      	beq.n	801133a <_nxe_ip_create+0x3e>
 8011314:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8011316:	2b00      	cmp	r3, #0
 8011318:	d00f      	beq.n	801133a <_nxe_ip_create+0x3e>
        (default_pool -> nx_packet_pool_id != NX_PACKET_POOL_ID) || (ip_link_driver == NX_NULL) ||
 801131a:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 801131c:	681b      	ldr	r3, [r3, #0]
    if ((ip_ptr == NX_NULL) || (default_pool == NX_NULL) ||
 801131e:	4a59      	ldr	r2, [pc, #356]	; (8011484 <_nxe_ip_create+0x188>)
 8011320:	4293      	cmp	r3, r2
 8011322:	d10a      	bne.n	801133a <_nxe_ip_create+0x3e>
        (default_pool -> nx_packet_pool_id != NX_PACKET_POOL_ID) || (ip_link_driver == NX_NULL) ||
 8011324:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8011326:	2b00      	cmp	r3, #0
 8011328:	d007      	beq.n	801133a <_nxe_ip_create+0x3e>
 801132a:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 801132c:	2b00      	cmp	r3, #0
 801132e:	d004      	beq.n	801133a <_nxe_ip_create+0x3e>
        (memory_ptr == NX_NULL) || (ip_control_block_size != (UINT)sizeof(NX_IP)))
 8011330:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8011332:	f640 02a4 	movw	r2, #2212	; 0x8a4
 8011336:	4293      	cmp	r3, r2
 8011338:	d001      	beq.n	801133e <_nxe_ip_create+0x42>
    {
        return(NX_PTR_ERROR);
 801133a:	2307      	movs	r3, #7
 801133c:	e09d      	b.n	801147a <_nxe_ip_create+0x17e>
    }

    /* Check for a memory size error.  */
    if (memory_size < TX_MINIMUM_STACK)
 801133e:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8011340:	2bc7      	cmp	r3, #199	; 0xc7
 8011342:	d801      	bhi.n	8011348 <_nxe_ip_create+0x4c>
    {
        return(NX_SIZE_ERROR);
 8011344:	2309      	movs	r3, #9
 8011346:	e098      	b.n	801147a <_nxe_ip_create+0x17e>
    }

    /* Check the priority specified.  */
    if (priority >= TX_MAX_PRIORITIES)
 8011348:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 801134a:	2b1f      	cmp	r3, #31
 801134c:	d901      	bls.n	8011352 <_nxe_ip_create+0x56>
    {
        return(NX_OPTION_ERROR);
 801134e:	230a      	movs	r3, #10
 8011350:	e093      	b.n	801147a <_nxe_ip_create+0x17e>
    }

    /* Calculate the end of the stack area.  */
    end_stack =  ((UCHAR *)memory_ptr) + (memory_size - 1);
 8011352:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8011354:	3b01      	subs	r3, #1
 8011356:	6c3a      	ldr	r2, [r7, #64]	; 0x40
 8011358:	4413      	add	r3, r2
 801135a:	627b      	str	r3, [r7, #36]	; 0x24

    /* Pickup current thread pointer.  */
    current_thread =  tx_thread_identify();
 801135c:	f003 fa4a 	bl	80147f4 <_tx_thread_identify>
 8011360:	6238      	str	r0, [r7, #32]

    /* Disable preemption temporarily.  */
    if (current_thread)
 8011362:	6a3b      	ldr	r3, [r7, #32]
 8011364:	2b00      	cmp	r3, #0
 8011366:	d006      	beq.n	8011376 <_nxe_ip_create+0x7a>
    {
        tx_thread_preemption_change(current_thread, 0, &old_threshold);
 8011368:	f107 0310 	add.w	r3, r7, #16
 801136c:	461a      	mov	r2, r3
 801136e:	2100      	movs	r1, #0
 8011370:	6a38      	ldr	r0, [r7, #32]
 8011372:	f003 fa99 	bl	80148a8 <_tx_thread_preemption_change>
    }

    /* Loop to check for the IP instance already created.  */
    created_ip =     _nx_ip_created_ptr;
 8011376:	4b44      	ldr	r3, [pc, #272]	; (8011488 <_nxe_ip_create+0x18c>)
 8011378:	681b      	ldr	r3, [r3, #0]
 801137a:	62fb      	str	r3, [r7, #44]	; 0x2c
    created_count =  _nx_ip_created_count;
 801137c:	4b43      	ldr	r3, [pc, #268]	; (801148c <_nxe_ip_create+0x190>)
 801137e:	681b      	ldr	r3, [r3, #0]
 8011380:	62bb      	str	r3, [r7, #40]	; 0x28
    while (created_count--)
 8011382:	e02b      	b.n	80113dc <_nxe_ip_create+0xe0>
    {

        /* Is the new ip already created?  */
        /*lint -e{946} suppress pointer subtraction, since it is necessary. */
        if ((ip_ptr == created_ip) ||
 8011384:	68fa      	ldr	r2, [r7, #12]
 8011386:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8011388:	429a      	cmp	r2, r3
 801138a:	d017      	beq.n	80113bc <_nxe_ip_create+0xc0>
            ((memory_ptr >= created_ip -> nx_ip_thread.tx_thread_stack_start) && (memory_ptr < created_ip -> nx_ip_thread.tx_thread_stack_end)) ||
 801138c:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 801138e:	f8d3 31a4 	ldr.w	r3, [r3, #420]	; 0x1a4
        if ((ip_ptr == created_ip) ||
 8011392:	6c3a      	ldr	r2, [r7, #64]	; 0x40
 8011394:	429a      	cmp	r2, r3
 8011396:	d305      	bcc.n	80113a4 <_nxe_ip_create+0xa8>
            ((memory_ptr >= created_ip -> nx_ip_thread.tx_thread_stack_start) && (memory_ptr < created_ip -> nx_ip_thread.tx_thread_stack_end)) ||
 8011398:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 801139a:	f8d3 31a8 	ldr.w	r3, [r3, #424]	; 0x1a8
 801139e:	6c3a      	ldr	r2, [r7, #64]	; 0x40
 80113a0:	429a      	cmp	r2, r3
 80113a2:	d30b      	bcc.n	80113bc <_nxe_ip_create+0xc0>
            ((((VOID *)end_stack)  >= created_ip -> nx_ip_thread.tx_thread_stack_start) && (((VOID *)end_stack)  < created_ip -> nx_ip_thread.tx_thread_stack_end)))
 80113a4:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 80113a6:	f8d3 31a4 	ldr.w	r3, [r3, #420]	; 0x1a4
            ((memory_ptr >= created_ip -> nx_ip_thread.tx_thread_stack_start) && (memory_ptr < created_ip -> nx_ip_thread.tx_thread_stack_end)) ||
 80113aa:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 80113ac:	429a      	cmp	r2, r3
 80113ae:	d311      	bcc.n	80113d4 <_nxe_ip_create+0xd8>
            ((((VOID *)end_stack)  >= created_ip -> nx_ip_thread.tx_thread_stack_start) && (((VOID *)end_stack)  < created_ip -> nx_ip_thread.tx_thread_stack_end)))
 80113b0:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 80113b2:	f8d3 31a8 	ldr.w	r3, [r3, #424]	; 0x1a8
 80113b6:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 80113b8:	429a      	cmp	r2, r3
 80113ba:	d20b      	bcs.n	80113d4 <_nxe_ip_create+0xd8>
        {

            /* Restore preemption.  */
            if (current_thread)
 80113bc:	6a3b      	ldr	r3, [r7, #32]
 80113be:	2b00      	cmp	r3, #0
 80113c0:	d006      	beq.n	80113d0 <_nxe_ip_create+0xd4>
            {

                /*lint -e{644} suppress variable might not be initialized, since "old_threshold" was initialized by previous tx_thread_preemption_change. */
                tx_thread_preemption_change(current_thread, old_threshold, &old_threshold);
 80113c2:	693b      	ldr	r3, [r7, #16]
 80113c4:	f107 0210 	add.w	r2, r7, #16
 80113c8:	4619      	mov	r1, r3
 80113ca:	6a38      	ldr	r0, [r7, #32]
 80113cc:	f003 fa6c 	bl	80148a8 <_tx_thread_preemption_change>
            }

            /* Duplicate ip created, return an error!  */
            return(NX_PTR_ERROR);
 80113d0:	2307      	movs	r3, #7
 80113d2:	e052      	b.n	801147a <_nxe_ip_create+0x17e>
        }

        /* Move to next entry.  */
        created_ip =  created_ip -> nx_ip_created_next;
 80113d4:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 80113d6:	f8d3 3710 	ldr.w	r3, [r3, #1808]	; 0x710
 80113da:	62fb      	str	r3, [r7, #44]	; 0x2c
    while (created_count--)
 80113dc:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80113de:	1e5a      	subs	r2, r3, #1
 80113e0:	62ba      	str	r2, [r7, #40]	; 0x28
 80113e2:	2b00      	cmp	r3, #0
 80113e4:	d1ce      	bne.n	8011384 <_nxe_ip_create+0x88>
    }

    /* Restore preemption.  */
    if (current_thread)
 80113e6:	6a3b      	ldr	r3, [r7, #32]
 80113e8:	2b00      	cmp	r3, #0
 80113ea:	d006      	beq.n	80113fa <_nxe_ip_create+0xfe>
    {

        /*lint -e{644} suppress variable might not be initialized, since "old_threshold" was initialized by previous tx_thread_preemption_change. */
        tx_thread_preemption_change(current_thread, old_threshold, &old_threshold);
 80113ec:	693b      	ldr	r3, [r7, #16]
 80113ee:	f107 0210 	add.w	r2, r7, #16
 80113f2:	4619      	mov	r1, r3
 80113f4:	6a38      	ldr	r0, [r7, #32]
 80113f6:	f003 fa57 	bl	80148a8 <_tx_thread_preemption_change>
    }

    /* Check for invalid IP address.  Note that Interface with DHCP enabled
       would start with 0.0.0.0.  Therefore the 0 IP address is allowed. */
    if ((ip_address != 0) &&
 80113fa:	687b      	ldr	r3, [r7, #4]
 80113fc:	2b00      	cmp	r3, #0
 80113fe:	d010      	beq.n	8011422 <_nxe_ip_create+0x126>
        ((ip_address & NX_IP_CLASS_A_MASK) != NX_IP_CLASS_A_TYPE) &&
 8011400:	687b      	ldr	r3, [r7, #4]
    if ((ip_address != 0) &&
 8011402:	2b00      	cmp	r3, #0
 8011404:	da0d      	bge.n	8011422 <_nxe_ip_create+0x126>
        ((ip_address & NX_IP_CLASS_B_MASK) != NX_IP_CLASS_B_TYPE) &&
 8011406:	687b      	ldr	r3, [r7, #4]
 8011408:	f003 4340 	and.w	r3, r3, #3221225472	; 0xc0000000
        ((ip_address & NX_IP_CLASS_A_MASK) != NX_IP_CLASS_A_TYPE) &&
 801140c:	f1b3 4f00 	cmp.w	r3, #2147483648	; 0x80000000
 8011410:	d007      	beq.n	8011422 <_nxe_ip_create+0x126>
        ((ip_address & NX_IP_CLASS_C_MASK) != NX_IP_CLASS_C_TYPE))
 8011412:	687b      	ldr	r3, [r7, #4]
 8011414:	f003 4360 	and.w	r3, r3, #3758096384	; 0xe0000000
        ((ip_address & NX_IP_CLASS_B_MASK) != NX_IP_CLASS_B_TYPE) &&
 8011418:	f1b3 4f40 	cmp.w	r3, #3221225472	; 0xc0000000
 801141c:	d001      	beq.n	8011422 <_nxe_ip_create+0x126>
    {
        return(NX_IP_ADDRESS_ERROR);
 801141e:	2321      	movs	r3, #33	; 0x21
 8011420:	e02b      	b.n	801147a <_nxe_ip_create+0x17e>
    __asm__ volatile (" MRS  %0,IPSR ": "=r" (ipsr_value) );
 8011422:	f3ef 8305 	mrs	r3, IPSR
 8011426:	61bb      	str	r3, [r7, #24]
    return(ipsr_value);
 8011428:	69ba      	ldr	r2, [r7, #24]
    }

    /* Check for appropriate caller.  */
    NX_INIT_AND_THREADS_CALLER_CHECKING
 801142a:	4b19      	ldr	r3, [pc, #100]	; (8011490 <_nxe_ip_create+0x194>)
 801142c:	681b      	ldr	r3, [r3, #0]
 801142e:	4313      	orrs	r3, r2
 8011430:	2b00      	cmp	r3, #0
 8011432:	d009      	beq.n	8011448 <_nxe_ip_create+0x14c>
    __asm__ volatile (" MRS  %0,IPSR ": "=r" (ipsr_value) );
 8011434:	f3ef 8305 	mrs	r3, IPSR
 8011438:	617b      	str	r3, [r7, #20]
    return(ipsr_value);
 801143a:	697a      	ldr	r2, [r7, #20]
 801143c:	4b14      	ldr	r3, [pc, #80]	; (8011490 <_nxe_ip_create+0x194>)
 801143e:	681b      	ldr	r3, [r3, #0]
 8011440:	4313      	orrs	r3, r2
 8011442:	f1b3 3ff0 	cmp.w	r3, #4042322160	; 0xf0f0f0f0
 8011446:	d304      	bcc.n	8011452 <_nxe_ip_create+0x156>
 8011448:	4b12      	ldr	r3, [pc, #72]	; (8011494 <_nxe_ip_create+0x198>)
 801144a:	681b      	ldr	r3, [r3, #0]
 801144c:	4a12      	ldr	r2, [pc, #72]	; (8011498 <_nxe_ip_create+0x19c>)
 801144e:	4293      	cmp	r3, r2
 8011450:	d101      	bne.n	8011456 <_nxe_ip_create+0x15a>
 8011452:	2311      	movs	r3, #17
 8011454:	e011      	b.n	801147a <_nxe_ip_create+0x17e>

    /* Call actual IP instance create function.  */
    status =  _nx_ip_create(ip_ptr, name, ip_address, network_mask, default_pool, ip_link_driver,
 8011456:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 8011458:	9304      	str	r3, [sp, #16]
 801145a:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 801145c:	9303      	str	r3, [sp, #12]
 801145e:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8011460:	9302      	str	r3, [sp, #8]
 8011462:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8011464:	9301      	str	r3, [sp, #4]
 8011466:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8011468:	9300      	str	r3, [sp, #0]
 801146a:	683b      	ldr	r3, [r7, #0]
 801146c:	687a      	ldr	r2, [r7, #4]
 801146e:	68b9      	ldr	r1, [r7, #8]
 8011470:	68f8      	ldr	r0, [r7, #12]
 8011472:	f7f8 fcc5 	bl	8009e00 <_nx_ip_create>
 8011476:	61f8      	str	r0, [r7, #28]
                            memory_ptr, memory_size, priority);

    /* Return completion status.  */
    return(status);
 8011478:	69fb      	ldr	r3, [r7, #28]
}
 801147a:	4618      	mov	r0, r3
 801147c:	3730      	adds	r7, #48	; 0x30
 801147e:	46bd      	mov	sp, r7
 8011480:	bd80      	pop	{r7, pc}
 8011482:	bf00      	nop
 8011484:	5041434b 	.word	0x5041434b
 8011488:	24000b08 	.word	0x24000b08
 801148c:	24000b0c 	.word	0x24000b0c
 8011490:	24000078 	.word	0x24000078
 8011494:	24031bc4 	.word	0x24031bc4
 8011498:	24031d0c 	.word	0x24031d0c

0801149c <_nxe_ip_interface_address_mapping_configure>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
UINT  _nxe_ip_interface_address_mapping_configure(NX_IP *ip_ptr, UINT interface_index, UINT mapping_needed)
{
 801149c:	b580      	push	{r7, lr}
 801149e:	b088      	sub	sp, #32
 80114a0:	af00      	add	r7, sp, #0
 80114a2:	60f8      	str	r0, [r7, #12]
 80114a4:	60b9      	str	r1, [r7, #8]
 80114a6:	607a      	str	r2, [r7, #4]

UINT status;

    /* Check for invalid input pointers.  */
    if ((ip_ptr == NX_NULL) || (ip_ptr -> nx_ip_id != NX_IP_ID))
 80114a8:	68fb      	ldr	r3, [r7, #12]
 80114aa:	2b00      	cmp	r3, #0
 80114ac:	d004      	beq.n	80114b8 <_nxe_ip_interface_address_mapping_configure+0x1c>
 80114ae:	68fb      	ldr	r3, [r7, #12]
 80114b0:	681b      	ldr	r3, [r3, #0]
 80114b2:	4a17      	ldr	r2, [pc, #92]	; (8011510 <_nxe_ip_interface_address_mapping_configure+0x74>)
 80114b4:	4293      	cmp	r3, r2
 80114b6:	d001      	beq.n	80114bc <_nxe_ip_interface_address_mapping_configure+0x20>
    {
        return(NX_PTR_ERROR);
 80114b8:	2307      	movs	r3, #7
 80114ba:	e025      	b.n	8011508 <_nxe_ip_interface_address_mapping_configure+0x6c>
    }

    /* Check for invalid interface index */
    if (interface_index >= NX_MAX_PHYSICAL_INTERFACES)
 80114bc:	68bb      	ldr	r3, [r7, #8]
 80114be:	2b03      	cmp	r3, #3
 80114c0:	d901      	bls.n	80114c6 <_nxe_ip_interface_address_mapping_configure+0x2a>
    {
        return(NX_INVALID_INTERFACE);
 80114c2:	234c      	movs	r3, #76	; 0x4c
 80114c4:	e020      	b.n	8011508 <_nxe_ip_interface_address_mapping_configure+0x6c>
    __asm__ volatile (" MRS  %0,IPSR ": "=r" (ipsr_value) );
 80114c6:	f3ef 8305 	mrs	r3, IPSR
 80114ca:	61bb      	str	r3, [r7, #24]
    return(ipsr_value);
 80114cc:	69ba      	ldr	r2, [r7, #24]
    }

    /* Check for appropriate caller.  */
    NX_INIT_AND_THREADS_CALLER_CHECKING
 80114ce:	4b11      	ldr	r3, [pc, #68]	; (8011514 <_nxe_ip_interface_address_mapping_configure+0x78>)
 80114d0:	681b      	ldr	r3, [r3, #0]
 80114d2:	4313      	orrs	r3, r2
 80114d4:	2b00      	cmp	r3, #0
 80114d6:	d009      	beq.n	80114ec <_nxe_ip_interface_address_mapping_configure+0x50>
    __asm__ volatile (" MRS  %0,IPSR ": "=r" (ipsr_value) );
 80114d8:	f3ef 8305 	mrs	r3, IPSR
 80114dc:	617b      	str	r3, [r7, #20]
    return(ipsr_value);
 80114de:	697a      	ldr	r2, [r7, #20]
 80114e0:	4b0c      	ldr	r3, [pc, #48]	; (8011514 <_nxe_ip_interface_address_mapping_configure+0x78>)
 80114e2:	681b      	ldr	r3, [r3, #0]
 80114e4:	4313      	orrs	r3, r2
 80114e6:	f1b3 3ff0 	cmp.w	r3, #4042322160	; 0xf0f0f0f0
 80114ea:	d304      	bcc.n	80114f6 <_nxe_ip_interface_address_mapping_configure+0x5a>
 80114ec:	4b0a      	ldr	r3, [pc, #40]	; (8011518 <_nxe_ip_interface_address_mapping_configure+0x7c>)
 80114ee:	681b      	ldr	r3, [r3, #0]
 80114f0:	4a0a      	ldr	r2, [pc, #40]	; (801151c <_nxe_ip_interface_address_mapping_configure+0x80>)
 80114f2:	4293      	cmp	r3, r2
 80114f4:	d101      	bne.n	80114fa <_nxe_ip_interface_address_mapping_configure+0x5e>
 80114f6:	2311      	movs	r3, #17
 80114f8:	e006      	b.n	8011508 <_nxe_ip_interface_address_mapping_configure+0x6c>

    status = _nx_ip_interface_address_mapping_configure(ip_ptr, interface_index, mapping_needed);
 80114fa:	687a      	ldr	r2, [r7, #4]
 80114fc:	68b9      	ldr	r1, [r7, #8]
 80114fe:	68f8      	ldr	r0, [r7, #12]
 8011500:	f7f9 fae8 	bl	800aad4 <_nx_ip_interface_address_mapping_configure>
 8011504:	61f8      	str	r0, [r7, #28]

    /* Return completion status.  */
    return(status);
 8011506:	69fb      	ldr	r3, [r7, #28]
}
 8011508:	4618      	mov	r0, r3
 801150a:	3720      	adds	r7, #32
 801150c:	46bd      	mov	sp, r7
 801150e:	bd80      	pop	{r7, pc}
 8011510:	49502020 	.word	0x49502020
 8011514:	24000078 	.word	0x24000078
 8011518:	24031bc4 	.word	0x24031bc4
 801151c:	24031d0c 	.word	0x24031d0c

08011520 <_nxe_packet_pool_create>:
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
UINT  _nxe_packet_pool_create(NX_PACKET_POOL *pool_ptr, CHAR *name_ptr, ULONG payload_size,
                              VOID *pool_start, ULONG pool_size, UINT pool_control_block_size)
{
 8011520:	b580      	push	{r7, lr}
 8011522:	b094      	sub	sp, #80	; 0x50
 8011524:	af02      	add	r7, sp, #8
 8011526:	60f8      	str	r0, [r7, #12]
 8011528:	60b9      	str	r1, [r7, #8]
 801152a:	607a      	str	r2, [r7, #4]
 801152c:	603b      	str	r3, [r7, #0]

UINT            status;
ULONG           rounded_payload_size;
ULONG           rounded_pool_size;
ULONG           header_size;
UINT            old_threshold = 0;
 801152e:	2300      	movs	r3, #0
 8011530:	613b      	str	r3, [r7, #16]
VOID           *rounded_pool_start;
TX_THREAD      *current_thread;


    /* Check for invalid input pointers.  */
    if ((pool_ptr == NX_NULL) || (pool_start == NX_NULL) || (pool_control_block_size != (UINT)sizeof(NX_PACKET_POOL)))
 8011532:	68fb      	ldr	r3, [r7, #12]
 8011534:	2b00      	cmp	r3, #0
 8011536:	d005      	beq.n	8011544 <_nxe_packet_pool_create+0x24>
 8011538:	683b      	ldr	r3, [r7, #0]
 801153a:	2b00      	cmp	r3, #0
 801153c:	d002      	beq.n	8011544 <_nxe_packet_pool_create+0x24>
 801153e:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 8011540:	2b3c      	cmp	r3, #60	; 0x3c
 8011542:	d001      	beq.n	8011548 <_nxe_packet_pool_create+0x28>
    {
        return(NX_PTR_ERROR);
 8011544:	2307      	movs	r3, #7
 8011546:	e0a7      	b.n	8011698 <_nxe_packet_pool_create+0x178>
    }

    /* Align the starting address to four bytes. */
    /*lint -e{923} suppress cast between ULONG and pointer.  */
    rounded_pool_start = (VOID *)((((ALIGN_TYPE)pool_start + NX_PACKET_ALIGNMENT  - 1) / NX_PACKET_ALIGNMENT) * NX_PACKET_ALIGNMENT);
 8011548:	683b      	ldr	r3, [r7, #0]
 801154a:	3303      	adds	r3, #3
 801154c:	f023 0303 	bic.w	r3, r3, #3
 8011550:	63fb      	str	r3, [r7, #60]	; 0x3c

    /* Round the pool size down to something that is evenly divisible by alignment.  */
    /*lint -e{923} suppress cast between ULONG and pointer.  */
    rounded_pool_size = (ULONG)(((pool_size - ((ALIGN_TYPE)rounded_pool_start - (ALIGN_TYPE)pool_start)) / NX_PACKET_ALIGNMENT) * NX_PACKET_ALIGNMENT);
 8011552:	683a      	ldr	r2, [r7, #0]
 8011554:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8011556:	1ad2      	subs	r2, r2, r3
 8011558:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 801155a:	4413      	add	r3, r2
 801155c:	f023 0303 	bic.w	r3, r3, #3
 8011560:	63bb      	str	r3, [r7, #56]	; 0x38

    /* Calculate the address of payload. */
    /*lint -e{923} suppress cast between ULONG and pointer.  */
    payload_address = (CHAR *)((ALIGN_TYPE)rounded_pool_start + sizeof(NX_PACKET));
 8011562:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8011564:	3338      	adds	r3, #56	; 0x38
 8011566:	637b      	str	r3, [r7, #52]	; 0x34

    /* Align the address of payload. */
    /*lint -e{923} suppress cast between ULONG and pointer.  */
    payload_address = (CHAR *)((((ALIGN_TYPE)payload_address + NX_PACKET_ALIGNMENT  - 1) / NX_PACKET_ALIGNMENT) * NX_PACKET_ALIGNMENT);
 8011568:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 801156a:	3303      	adds	r3, #3
 801156c:	f023 0303 	bic.w	r3, r3, #3
 8011570:	637b      	str	r3, [r7, #52]	; 0x34

    /* Calculate the header size. */
    /*lint -e{923} suppress cast between ULONG and pointer.  */
    header_size = (ULONG)((ALIGN_TYPE)payload_address - (ALIGN_TYPE)rounded_pool_start);
 8011572:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 8011574:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8011576:	1ad3      	subs	r3, r2, r3
 8011578:	633b      	str	r3, [r7, #48]	; 0x30

    /* Round the packet size up to something that helps guarantee proper alignment for header and payload.  */
    rounded_payload_size =  (ULONG)(((header_size + payload_size + NX_PACKET_ALIGNMENT  - 1) / NX_PACKET_ALIGNMENT) * NX_PACKET_ALIGNMENT - header_size);
 801157a:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 801157c:	687b      	ldr	r3, [r7, #4]
 801157e:	4413      	add	r3, r2
 8011580:	3303      	adds	r3, #3
 8011582:	f023 0203 	bic.w	r2, r3, #3
 8011586:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8011588:	1ad3      	subs	r3, r2, r3
 801158a:	62fb      	str	r3, [r7, #44]	; 0x2c

    /* Check for an invalid pool and payload size.  */
    if ((pool_size <= NX_PACKET_ALIGNMENT) || (!payload_size) ||
 801158c:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 801158e:	2b04      	cmp	r3, #4
 8011590:	d908      	bls.n	80115a4 <_nxe_packet_pool_create+0x84>
 8011592:	687b      	ldr	r3, [r7, #4]
 8011594:	2b00      	cmp	r3, #0
 8011596:	d005      	beq.n	80115a4 <_nxe_packet_pool_create+0x84>
        ((rounded_payload_size + header_size) > rounded_pool_size))
 8011598:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 801159a:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801159c:	4413      	add	r3, r2
    if ((pool_size <= NX_PACKET_ALIGNMENT) || (!payload_size) ||
 801159e:	6bba      	ldr	r2, [r7, #56]	; 0x38
 80115a0:	429a      	cmp	r2, r3
 80115a2:	d201      	bcs.n	80115a8 <_nxe_packet_pool_create+0x88>
    {
        return(NX_SIZE_ERROR);
 80115a4:	2309      	movs	r3, #9
 80115a6:	e077      	b.n	8011698 <_nxe_packet_pool_create+0x178>
    }

    /* Calculate the end of the pool memory area.  */
    end_memory =  ((CHAR *)pool_start) + (pool_size - 1);
 80115a8:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 80115aa:	3b01      	subs	r3, #1
 80115ac:	683a      	ldr	r2, [r7, #0]
 80115ae:	4413      	add	r3, r2
 80115b0:	62bb      	str	r3, [r7, #40]	; 0x28

    /* Pickup current thread pointer.  */
    current_thread =  tx_thread_identify();
 80115b2:	f003 f91f 	bl	80147f4 <_tx_thread_identify>
 80115b6:	6278      	str	r0, [r7, #36]	; 0x24

    /* Disable preemption temporarily.  */
    if (current_thread)
 80115b8:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80115ba:	2b00      	cmp	r3, #0
 80115bc:	d006      	beq.n	80115cc <_nxe_packet_pool_create+0xac>
    {
        tx_thread_preemption_change(current_thread, 0, &old_threshold);
 80115be:	f107 0310 	add.w	r3, r7, #16
 80115c2:	461a      	mov	r2, r3
 80115c4:	2100      	movs	r1, #0
 80115c6:	6a78      	ldr	r0, [r7, #36]	; 0x24
 80115c8:	f003 f96e 	bl	80148a8 <_tx_thread_preemption_change>
    }

    /* Loop to check for the pool instance already created.  */
    created_pool =   _nx_packet_pool_created_ptr;
 80115cc:	4b34      	ldr	r3, [pc, #208]	; (80116a0 <_nxe_packet_pool_create+0x180>)
 80115ce:	681b      	ldr	r3, [r3, #0]
 80115d0:	647b      	str	r3, [r7, #68]	; 0x44
    created_count =  _nx_packet_pool_created_count;
 80115d2:	4b34      	ldr	r3, [pc, #208]	; (80116a4 <_nxe_packet_pool_create+0x184>)
 80115d4:	681b      	ldr	r3, [r3, #0]
 80115d6:	643b      	str	r3, [r7, #64]	; 0x40
    while (created_count--)
 80115d8:	e02b      	b.n	8011632 <_nxe_packet_pool_create+0x112>
    {

        /* Calculate the created pool's end of memory.  */
        created_end =  created_pool -> nx_packet_pool_start + (created_pool -> nx_packet_pool_size - 1);
 80115da:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 80115dc:	6a1a      	ldr	r2, [r3, #32]
 80115de:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 80115e0:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 80115e2:	3b01      	subs	r3, #1
 80115e4:	4413      	add	r3, r2
 80115e6:	61fb      	str	r3, [r7, #28]

        /* Is the new pool already created?  */
        /*lint -e{946} suppress pointer subtraction, since it is necessary. */
        if ((pool_ptr == created_pool) ||
 80115e8:	68fa      	ldr	r2, [r7, #12]
 80115ea:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 80115ec:	429a      	cmp	r2, r3
 80115ee:	d011      	beq.n	8011614 <_nxe_packet_pool_create+0xf4>
            ((pool_start >= (VOID *)created_pool -> nx_packet_pool_start) && (pool_start < (VOID *)created_end)) ||
 80115f0:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 80115f2:	6a1b      	ldr	r3, [r3, #32]
        if ((pool_ptr == created_pool) ||
 80115f4:	683a      	ldr	r2, [r7, #0]
 80115f6:	429a      	cmp	r2, r3
 80115f8:	d303      	bcc.n	8011602 <_nxe_packet_pool_create+0xe2>
            ((pool_start >= (VOID *)created_pool -> nx_packet_pool_start) && (pool_start < (VOID *)created_end)) ||
 80115fa:	683a      	ldr	r2, [r7, #0]
 80115fc:	69fb      	ldr	r3, [r7, #28]
 80115fe:	429a      	cmp	r2, r3
 8011600:	d308      	bcc.n	8011614 <_nxe_packet_pool_create+0xf4>
            ((end_memory  >= created_pool -> nx_packet_pool_start) && (end_memory  < created_end)))
 8011602:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8011604:	6a1b      	ldr	r3, [r3, #32]
            ((pool_start >= (VOID *)created_pool -> nx_packet_pool_start) && (pool_start < (VOID *)created_end)) ||
 8011606:	6aba      	ldr	r2, [r7, #40]	; 0x28
 8011608:	429a      	cmp	r2, r3
 801160a:	d30f      	bcc.n	801162c <_nxe_packet_pool_create+0x10c>
            ((end_memory  >= created_pool -> nx_packet_pool_start) && (end_memory  < created_end)))
 801160c:	6aba      	ldr	r2, [r7, #40]	; 0x28
 801160e:	69fb      	ldr	r3, [r7, #28]
 8011610:	429a      	cmp	r2, r3
 8011612:	d20b      	bcs.n	801162c <_nxe_packet_pool_create+0x10c>
        {

            /* Restore preemption.  */
            if (current_thread)
 8011614:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8011616:	2b00      	cmp	r3, #0
 8011618:	d006      	beq.n	8011628 <_nxe_packet_pool_create+0x108>
            {

                /*lint -e{644} suppress variable might not be initialized, since "old_threshold" was initialized by previous tx_thread_preemption_change. */
                tx_thread_preemption_change(current_thread, old_threshold, &old_threshold);
 801161a:	693b      	ldr	r3, [r7, #16]
 801161c:	f107 0210 	add.w	r2, r7, #16
 8011620:	4619      	mov	r1, r3
 8011622:	6a78      	ldr	r0, [r7, #36]	; 0x24
 8011624:	f003 f940 	bl	80148a8 <_tx_thread_preemption_change>
            }

            /* Duplicate packet pool created, return an error!  */
            return(NX_PTR_ERROR);
 8011628:	2307      	movs	r3, #7
 801162a:	e035      	b.n	8011698 <_nxe_packet_pool_create+0x178>
        }

        /* Move to next entry.  */
        created_pool =  created_pool -> nx_packet_pool_created_next;
 801162c:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 801162e:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8011630:	647b      	str	r3, [r7, #68]	; 0x44
    while (created_count--)
 8011632:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8011634:	1e5a      	subs	r2, r3, #1
 8011636:	643a      	str	r2, [r7, #64]	; 0x40
 8011638:	2b00      	cmp	r3, #0
 801163a:	d1ce      	bne.n	80115da <_nxe_packet_pool_create+0xba>
    }

    /* Restore preemption.  */
    if (current_thread)
 801163c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801163e:	2b00      	cmp	r3, #0
 8011640:	d006      	beq.n	8011650 <_nxe_packet_pool_create+0x130>
    {
        tx_thread_preemption_change(current_thread, old_threshold, &old_threshold);
 8011642:	693b      	ldr	r3, [r7, #16]
 8011644:	f107 0210 	add.w	r2, r7, #16
 8011648:	4619      	mov	r1, r3
 801164a:	6a78      	ldr	r0, [r7, #36]	; 0x24
 801164c:	f003 f92c 	bl	80148a8 <_tx_thread_preemption_change>
    __asm__ volatile (" MRS  %0,IPSR ": "=r" (ipsr_value) );
 8011650:	f3ef 8305 	mrs	r3, IPSR
 8011654:	61bb      	str	r3, [r7, #24]
    return(ipsr_value);
 8011656:	69ba      	ldr	r2, [r7, #24]
    }

    /* Check for appropriate caller.  */
    NX_INIT_AND_THREADS_CALLER_CHECKING
 8011658:	4b13      	ldr	r3, [pc, #76]	; (80116a8 <_nxe_packet_pool_create+0x188>)
 801165a:	681b      	ldr	r3, [r3, #0]
 801165c:	4313      	orrs	r3, r2
 801165e:	2b00      	cmp	r3, #0
 8011660:	d009      	beq.n	8011676 <_nxe_packet_pool_create+0x156>
    __asm__ volatile (" MRS  %0,IPSR ": "=r" (ipsr_value) );
 8011662:	f3ef 8305 	mrs	r3, IPSR
 8011666:	617b      	str	r3, [r7, #20]
    return(ipsr_value);
 8011668:	697a      	ldr	r2, [r7, #20]
 801166a:	4b0f      	ldr	r3, [pc, #60]	; (80116a8 <_nxe_packet_pool_create+0x188>)
 801166c:	681b      	ldr	r3, [r3, #0]
 801166e:	4313      	orrs	r3, r2
 8011670:	f1b3 3ff0 	cmp.w	r3, #4042322160	; 0xf0f0f0f0
 8011674:	d304      	bcc.n	8011680 <_nxe_packet_pool_create+0x160>
 8011676:	4b0d      	ldr	r3, [pc, #52]	; (80116ac <_nxe_packet_pool_create+0x18c>)
 8011678:	681b      	ldr	r3, [r3, #0]
 801167a:	4a0d      	ldr	r2, [pc, #52]	; (80116b0 <_nxe_packet_pool_create+0x190>)
 801167c:	4293      	cmp	r3, r2
 801167e:	d101      	bne.n	8011684 <_nxe_packet_pool_create+0x164>
 8011680:	2311      	movs	r3, #17
 8011682:	e009      	b.n	8011698 <_nxe_packet_pool_create+0x178>

    /* Call actual packet pool create function.  */
    status =  _nx_packet_pool_create(pool_ptr, name_ptr, payload_size, pool_start, pool_size);
 8011684:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 8011686:	9300      	str	r3, [sp, #0]
 8011688:	683b      	ldr	r3, [r7, #0]
 801168a:	687a      	ldr	r2, [r7, #4]
 801168c:	68b9      	ldr	r1, [r7, #8]
 801168e:	68f8      	ldr	r0, [r7, #12]
 8011690:	f7fa fd4e 	bl	800c130 <_nx_packet_pool_create>
 8011694:	6238      	str	r0, [r7, #32]

    /* Return completion status.  */
    return(status);
 8011696:	6a3b      	ldr	r3, [r7, #32]
}
 8011698:	4618      	mov	r0, r3
 801169a:	3748      	adds	r7, #72	; 0x48
 801169c:	46bd      	mov	sp, r7
 801169e:	bd80      	pop	{r7, pc}
 80116a0:	24000b10 	.word	0x24000b10
 80116a4:	24000b14 	.word	0x24000b14
 80116a8:	24000078 	.word	0x24000078
 80116ac:	24031bc4 	.word	0x24031bc4
 80116b0:	24031d0c 	.word	0x24031d0c

080116b4 <_nxe_packet_release>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
UINT  _nxe_packet_release(NX_PACKET **packet_ptr_ptr)
{
 80116b4:	b580      	push	{r7, lr}
 80116b6:	b084      	sub	sp, #16
 80116b8:	af00      	add	r7, sp, #0
 80116ba:	6078      	str	r0, [r7, #4]
UINT       status;
NX_PACKET *packet_ptr;


    /* Setup packet pointer.  */
    packet_ptr =  *packet_ptr_ptr;
 80116bc:	687b      	ldr	r3, [r7, #4]
 80116be:	681b      	ldr	r3, [r3, #0]
 80116c0:	60fb      	str	r3, [r7, #12]

    /* Simple integrity check on the packet.  */
    if ((packet_ptr == NX_NULL) || (packet_ptr -> nx_packet_pool_owner == NX_NULL) ||
 80116c2:	68fb      	ldr	r3, [r7, #12]
 80116c4:	2b00      	cmp	r3, #0
 80116c6:	d009      	beq.n	80116dc <_nxe_packet_release+0x28>
 80116c8:	68fb      	ldr	r3, [r7, #12]
 80116ca:	681b      	ldr	r3, [r3, #0]
 80116cc:	2b00      	cmp	r3, #0
 80116ce:	d005      	beq.n	80116dc <_nxe_packet_release+0x28>
        ((packet_ptr -> nx_packet_pool_owner) -> nx_packet_pool_id != NX_PACKET_POOL_ID))
 80116d0:	68fb      	ldr	r3, [r7, #12]
 80116d2:	681b      	ldr	r3, [r3, #0]
 80116d4:	681b      	ldr	r3, [r3, #0]
    if ((packet_ptr == NX_NULL) || (packet_ptr -> nx_packet_pool_owner == NX_NULL) ||
 80116d6:	4a12      	ldr	r2, [pc, #72]	; (8011720 <_nxe_packet_release+0x6c>)
 80116d8:	4293      	cmp	r3, r2
 80116da:	d001      	beq.n	80116e0 <_nxe_packet_release+0x2c>
    {

        return(NX_PTR_ERROR);
 80116dc:	2307      	movs	r3, #7
 80116de:	e01a      	b.n	8011716 <_nxe_packet_release+0x62>
    }

    /* Check for an invalid packet prepend pointer.  */
    /*lint -e{946} suppress pointer subtraction, since it is necessary. */
    if (packet_ptr -> nx_packet_prepend_ptr < packet_ptr -> nx_packet_data_start)
 80116e0:	68fb      	ldr	r3, [r7, #12]
 80116e2:	689a      	ldr	r2, [r3, #8]
 80116e4:	68fb      	ldr	r3, [r7, #12]
 80116e6:	691b      	ldr	r3, [r3, #16]
 80116e8:	429a      	cmp	r2, r3
 80116ea:	d201      	bcs.n	80116f0 <_nxe_packet_release+0x3c>
    {
        return(NX_UNDERFLOW);
 80116ec:	2302      	movs	r3, #2
 80116ee:	e012      	b.n	8011716 <_nxe_packet_release+0x62>
    }

    /* Check for an invalid packet append pointer.  */
    /*lint -e{946} suppress pointer subtraction, since it is necessary. */
    if (packet_ptr -> nx_packet_append_ptr > packet_ptr -> nx_packet_data_end)
 80116f0:	68fb      	ldr	r3, [r7, #12]
 80116f2:	68da      	ldr	r2, [r3, #12]
 80116f4:	68fb      	ldr	r3, [r7, #12]
 80116f6:	695b      	ldr	r3, [r3, #20]
 80116f8:	429a      	cmp	r2, r3
 80116fa:	d901      	bls.n	8011700 <_nxe_packet_release+0x4c>
    {
        return(NX_OVERFLOW);
 80116fc:	2303      	movs	r3, #3
 80116fe:	e00a      	b.n	8011716 <_nxe_packet_release+0x62>
    }

    /* Call actual packet release function.  */
    status =  _nx_packet_release(packet_ptr);
 8011700:	68f8      	ldr	r0, [r7, #12]
 8011702:	f7fa fe81 	bl	800c408 <_nx_packet_release>
 8011706:	60b8      	str	r0, [r7, #8]

    /* Determine if the packet release was successful.  */
    if (status == NX_SUCCESS)
 8011708:	68bb      	ldr	r3, [r7, #8]
 801170a:	2b00      	cmp	r3, #0
 801170c:	d102      	bne.n	8011714 <_nxe_packet_release+0x60>
    {

        /* Yes, now clear the application's packet pointer so it can't be accidentally
           used again by the application.  This is only done when error checking is
           enabled.  */
        *packet_ptr_ptr =  NX_NULL;
 801170e:	687b      	ldr	r3, [r7, #4]
 8011710:	2200      	movs	r2, #0
 8011712:	601a      	str	r2, [r3, #0]
    }

    /* Return completion status.  */
    return(status);
 8011714:	68bb      	ldr	r3, [r7, #8]
}
 8011716:	4618      	mov	r0, r3
 8011718:	3710      	adds	r7, #16
 801171a:	46bd      	mov	sp, r7
 801171c:	bd80      	pop	{r7, pc}
 801171e:	bf00      	nop
 8011720:	5041434b 	.word	0x5041434b

08011724 <_nxe_tcp_enable>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
UINT  _nxe_tcp_enable(NX_IP *ip_ptr)
{
 8011724:	b580      	push	{r7, lr}
 8011726:	b086      	sub	sp, #24
 8011728:	af00      	add	r7, sp, #0
 801172a:	6078      	str	r0, [r7, #4]

UINT status;


    /* Check for invalid input pointers.  */
    if ((ip_ptr == NX_NULL) || (ip_ptr -> nx_ip_id != NX_IP_ID))
 801172c:	687b      	ldr	r3, [r7, #4]
 801172e:	2b00      	cmp	r3, #0
 8011730:	d004      	beq.n	801173c <_nxe_tcp_enable+0x18>
 8011732:	687b      	ldr	r3, [r7, #4]
 8011734:	681b      	ldr	r3, [r3, #0]
 8011736:	4a15      	ldr	r2, [pc, #84]	; (801178c <_nxe_tcp_enable+0x68>)
 8011738:	4293      	cmp	r3, r2
 801173a:	d001      	beq.n	8011740 <_nxe_tcp_enable+0x1c>
    {
        return(NX_PTR_ERROR);
 801173c:	2307      	movs	r3, #7
 801173e:	e020      	b.n	8011782 <_nxe_tcp_enable+0x5e>
    }

    /* Check to see if TCP is already enabled.  */
    if (ip_ptr -> nx_ip_tcp_packet_receive)
 8011740:	687b      	ldr	r3, [r7, #4]
 8011742:	f8d3 3494 	ldr.w	r3, [r3, #1172]	; 0x494
 8011746:	2b00      	cmp	r3, #0
 8011748:	d001      	beq.n	801174e <_nxe_tcp_enable+0x2a>
    {
        return(NX_ALREADY_ENABLED);
 801174a:	2315      	movs	r3, #21
 801174c:	e019      	b.n	8011782 <_nxe_tcp_enable+0x5e>
    __asm__ volatile (" MRS  %0,IPSR ": "=r" (ipsr_value) );
 801174e:	f3ef 8305 	mrs	r3, IPSR
 8011752:	613b      	str	r3, [r7, #16]
    return(ipsr_value);
 8011754:	693a      	ldr	r2, [r7, #16]
    }

    /* Check for appropriate caller.  */
    NX_NOT_ISR_CALLER_CHECKING
 8011756:	4b0e      	ldr	r3, [pc, #56]	; (8011790 <_nxe_tcp_enable+0x6c>)
 8011758:	681b      	ldr	r3, [r3, #0]
 801175a:	4313      	orrs	r3, r2
 801175c:	2b00      	cmp	r3, #0
 801175e:	d00b      	beq.n	8011778 <_nxe_tcp_enable+0x54>
    __asm__ volatile (" MRS  %0,IPSR ": "=r" (ipsr_value) );
 8011760:	f3ef 8305 	mrs	r3, IPSR
 8011764:	60fb      	str	r3, [r7, #12]
    return(ipsr_value);
 8011766:	68fa      	ldr	r2, [r7, #12]
 8011768:	4b09      	ldr	r3, [pc, #36]	; (8011790 <_nxe_tcp_enable+0x6c>)
 801176a:	681b      	ldr	r3, [r3, #0]
 801176c:	4313      	orrs	r3, r2
 801176e:	f1b3 3ff0 	cmp.w	r3, #4042322160	; 0xf0f0f0f0
 8011772:	d201      	bcs.n	8011778 <_nxe_tcp_enable+0x54>
 8011774:	2311      	movs	r3, #17
 8011776:	e004      	b.n	8011782 <_nxe_tcp_enable+0x5e>

    /* Call actual TCP enable function.  */
    status =  _nx_tcp_enable(ip_ptr);
 8011778:	6878      	ldr	r0, [r7, #4]
 801177a:	f7fb fa75 	bl	800cc68 <_nx_tcp_enable>
 801177e:	6178      	str	r0, [r7, #20]

    /* Return completion status.  */
    return(status);
 8011780:	697b      	ldr	r3, [r7, #20]
}
 8011782:	4618      	mov	r0, r3
 8011784:	3718      	adds	r7, #24
 8011786:	46bd      	mov	sp, r7
 8011788:	bd80      	pop	{r7, pc}
 801178a:	bf00      	nop
 801178c:	49502020 	.word	0x49502020
 8011790:	24000078 	.word	0x24000078

08011794 <_nxe_udp_enable>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
UINT  _nxe_udp_enable(NX_IP *ip_ptr)
{
 8011794:	b580      	push	{r7, lr}
 8011796:	b086      	sub	sp, #24
 8011798:	af00      	add	r7, sp, #0
 801179a:	6078      	str	r0, [r7, #4]

UINT status;


    /* Check for invalid input pointers.  */
    if ((ip_ptr == NX_NULL) || (ip_ptr -> nx_ip_id != NX_IP_ID))
 801179c:	687b      	ldr	r3, [r7, #4]
 801179e:	2b00      	cmp	r3, #0
 80117a0:	d004      	beq.n	80117ac <_nxe_udp_enable+0x18>
 80117a2:	687b      	ldr	r3, [r7, #4]
 80117a4:	681b      	ldr	r3, [r3, #0]
 80117a6:	4a15      	ldr	r2, [pc, #84]	; (80117fc <_nxe_udp_enable+0x68>)
 80117a8:	4293      	cmp	r3, r2
 80117aa:	d001      	beq.n	80117b0 <_nxe_udp_enable+0x1c>
    {
        return(NX_PTR_ERROR);
 80117ac:	2307      	movs	r3, #7
 80117ae:	e020      	b.n	80117f2 <_nxe_udp_enable+0x5e>
    }

    /* Check to see if UDP is enabled.  */
    if (ip_ptr -> nx_ip_udp_packet_receive)
 80117b0:	687b      	ldr	r3, [r7, #4]
 80117b2:	f8d3 3408 	ldr.w	r3, [r3, #1032]	; 0x408
 80117b6:	2b00      	cmp	r3, #0
 80117b8:	d001      	beq.n	80117be <_nxe_udp_enable+0x2a>
    {
        return(NX_ALREADY_ENABLED);
 80117ba:	2315      	movs	r3, #21
 80117bc:	e019      	b.n	80117f2 <_nxe_udp_enable+0x5e>
    __asm__ volatile (" MRS  %0,IPSR ": "=r" (ipsr_value) );
 80117be:	f3ef 8305 	mrs	r3, IPSR
 80117c2:	613b      	str	r3, [r7, #16]
    return(ipsr_value);
 80117c4:	693a      	ldr	r2, [r7, #16]
    }

    /* Check for appropriate caller.  */
    NX_NOT_ISR_CALLER_CHECKING
 80117c6:	4b0e      	ldr	r3, [pc, #56]	; (8011800 <_nxe_udp_enable+0x6c>)
 80117c8:	681b      	ldr	r3, [r3, #0]
 80117ca:	4313      	orrs	r3, r2
 80117cc:	2b00      	cmp	r3, #0
 80117ce:	d00b      	beq.n	80117e8 <_nxe_udp_enable+0x54>
    __asm__ volatile (" MRS  %0,IPSR ": "=r" (ipsr_value) );
 80117d0:	f3ef 8305 	mrs	r3, IPSR
 80117d4:	60fb      	str	r3, [r7, #12]
    return(ipsr_value);
 80117d6:	68fa      	ldr	r2, [r7, #12]
 80117d8:	4b09      	ldr	r3, [pc, #36]	; (8011800 <_nxe_udp_enable+0x6c>)
 80117da:	681b      	ldr	r3, [r3, #0]
 80117dc:	4313      	orrs	r3, r2
 80117de:	f1b3 3ff0 	cmp.w	r3, #4042322160	; 0xf0f0f0f0
 80117e2:	d201      	bcs.n	80117e8 <_nxe_udp_enable+0x54>
 80117e4:	2311      	movs	r3, #17
 80117e6:	e004      	b.n	80117f2 <_nxe_udp_enable+0x5e>

    /* Call actual UDP enable function.  */
    status =  _nx_udp_enable(ip_ptr);
 80117e8:	6878      	ldr	r0, [r7, #4]
 80117ea:	f7fe fb11 	bl	800fe10 <_nx_udp_enable>
 80117ee:	6178      	str	r0, [r7, #20]

    /* Return completion status.  */
    return(status);
 80117f0:	697b      	ldr	r3, [r7, #20]
}
 80117f2:	4618      	mov	r0, r3
 80117f4:	3718      	adds	r7, #24
 80117f6:	46bd      	mov	sp, r7
 80117f8:	bd80      	pop	{r7, pc}
 80117fa:	bf00      	nop
 80117fc:	49502020 	.word	0x49502020
 8011800:	24000078 	.word	0x24000078

08011804 <txfr_free>:

    return p;
}

void txfr_free(void *p)
{
 8011804:	b580      	push	{r7, lr}
 8011806:	b084      	sub	sp, #16
 8011808:	af00      	add	r7, sp, #0
 801180a:	6078      	str	r0, [r7, #4]
    UINT ret;

    if(txfr_heap_initialized == 1u) {
 801180c:	4b06      	ldr	r3, [pc, #24]	; (8011828 <txfr_free+0x24>)
 801180e:	681b      	ldr	r3, [r3, #0]
 8011810:	2b01      	cmp	r3, #1
 8011812:	d104      	bne.n	801181e <txfr_free+0x1a>
        ret = tx_byte_release(p);
 8011814:	6878      	ldr	r0, [r7, #4]
 8011816:	f004 facf 	bl	8015db8 <_txe_byte_release>
 801181a:	60f8      	str	r0, [r7, #12]
        if(ret != TX_SUCCESS) {
            TX_FREERTOS_ASSERT_FAIL();
        }
    }

    return;
 801181c:	bf00      	nop
 801181e:	bf00      	nop
}
 8011820:	3710      	adds	r7, #16
 8011822:	46bd      	mov	sp, r7
 8011824:	bd80      	pop	{r7, pc}
 8011826:	bf00      	nop
 8011828:	24031b88 	.word	0x24031b88

0801182c <txfr_idle_task_entry>:

#if (INCLUDE_vTaskDelete == 1)
static void txfr_idle_task_entry(ULONG id)
{
 801182c:	b580      	push	{r7, lr}
 801182e:	b088      	sub	sp, #32
 8011830:	af00      	add	r7, sp, #0
 8011832:	6078      	str	r0, [r7, #4]
    UINT ret;
    TX_INTERRUPT_SAVE_AREA;


    for(;;) {
        ret = tx_semaphore_get(&txfr_idle_sem, TX_WAIT_FOREVER);
 8011834:	f04f 31ff 	mov.w	r1, #4294967295
 8011838:	481e      	ldr	r0, [pc, #120]	; (80118b4 <txfr_idle_task_entry+0x88>)
 801183a:	f004 fff3 	bl	8016824 <_txe_semaphore_get>
 801183e:	61f8      	str	r0, [r7, #28]
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 8011840:	f3ef 8310 	mrs	r3, PRIMASK
 8011844:	613b      	str	r3, [r7, #16]
    return(posture);
 8011846:	693b      	ldr	r3, [r7, #16]
    int_posture = __get_interrupt_posture();
 8011848:	60fb      	str	r3, [r7, #12]
    __asm__ volatile ("CPSID i" : : : "memory");
 801184a:	b672      	cpsid	i
    return(int_posture);
 801184c:	68fb      	ldr	r3, [r7, #12]
        if(ret != TX_SUCCESS) {
            TX_FREERTOS_ASSERT_FAIL();
        }

        TX_DISABLE;
 801184e:	61bb      	str	r3, [r7, #24]
        p_task = p_delete_task_head;
 8011850:	4b19      	ldr	r3, [pc, #100]	; (80118b8 <txfr_idle_task_entry+0x8c>)
 8011852:	681b      	ldr	r3, [r3, #0]
 8011854:	617b      	str	r3, [r7, #20]

        if(p_task != NULL) {
 8011856:	697b      	ldr	r3, [r7, #20]
 8011858:	2b00      	cmp	r3, #0
 801185a:	d003      	beq.n	8011864 <txfr_idle_task_entry+0x38>
            p_delete_task_head = p_task->p_next;
 801185c:	697b      	ldr	r3, [r7, #20]
 801185e:	681b      	ldr	r3, [r3, #0]
 8011860:	4a15      	ldr	r2, [pc, #84]	; (80118b8 <txfr_idle_task_entry+0x8c>)
 8011862:	6013      	str	r3, [r2, #0]
        }
        g_txfr_task_count--;
 8011864:	4b15      	ldr	r3, [pc, #84]	; (80118bc <txfr_idle_task_entry+0x90>)
 8011866:	681b      	ldr	r3, [r3, #0]
 8011868:	3b01      	subs	r3, #1
 801186a:	4a14      	ldr	r2, [pc, #80]	; (80118bc <txfr_idle_task_entry+0x90>)
 801186c:	6013      	str	r3, [r2, #0]
 801186e:	69bb      	ldr	r3, [r7, #24]
 8011870:	60bb      	str	r3, [r7, #8]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 8011872:	68bb      	ldr	r3, [r7, #8]
 8011874:	f383 8810 	msr	PRIMASK, r3
}
 8011878:	bf00      	nop
        TX_RESTORE;

        if(p_task != NULL) {
 801187a:	697b      	ldr	r3, [r7, #20]
 801187c:	2b00      	cmp	r3, #0
 801187e:	d0d9      	beq.n	8011834 <txfr_idle_task_entry+0x8>

            // Make sure the task is terminated, which may return an error if that's already the case so the return value is ignored.
            (void)tx_thread_terminate(&p_task->thread);
 8011880:	697b      	ldr	r3, [r7, #20]
 8011882:	3304      	adds	r3, #4
 8011884:	4618      	mov	r0, r3
 8011886:	f005 f985 	bl	8016b94 <_txe_thread_terminate>

            ret = tx_thread_delete(&p_task->thread);
 801188a:	697b      	ldr	r3, [r7, #20]
 801188c:	3304      	adds	r3, #4
 801188e:	4618      	mov	r0, r3
 8011890:	f005 f91a 	bl	8016ac8 <_txe_thread_delete>
 8011894:	61f8      	str	r0, [r7, #28]
            if(ret != TX_SUCCESS) {
                TX_FREERTOS_ASSERT_FAIL();
            }

            ret = tx_semaphore_delete(&p_task->notification_sem);
 8011896:	697b      	ldr	r3, [r7, #20]
 8011898:	33cc      	adds	r3, #204	; 0xcc
 801189a:	4618      	mov	r0, r3
 801189c:	f004 ff84 	bl	80167a8 <_txe_semaphore_delete>
 80118a0:	61f8      	str	r0, [r7, #28]
            if(ret != TX_SUCCESS) {
                TX_FREERTOS_ASSERT_FAIL();
            }

            if(p_task->allocated == 1u) {
 80118a2:	697b      	ldr	r3, [r7, #20]
 80118a4:	f893 30f0 	ldrb.w	r3, [r3, #240]	; 0xf0
 80118a8:	2b01      	cmp	r3, #1
 80118aa:	d1c3      	bne.n	8011834 <txfr_idle_task_entry+0x8>
                txfr_free(p_task);
 80118ac:	6978      	ldr	r0, [r7, #20]
 80118ae:	f7ff ffa9 	bl	8011804 <txfr_free>
        ret = tx_semaphore_get(&txfr_idle_sem, TX_WAIT_FOREVER);
 80118b2:	e7bf      	b.n	8011834 <txfr_idle_task_entry+0x8>
 80118b4:	24000df0 	.word	0x24000df0
 80118b8:	24000e0c 	.word	0x24000e0c
 80118bc:	24000e10 	.word	0x24000e10

080118c0 <tx_freertos_init>:
    // Empty tx_application_define() to support auto initialization.
}
#endif // #if (TX_FREERTOS_AUTO_INIT == 1)

UINT tx_freertos_init(void)
{
 80118c0:	b580      	push	{r7, lr}
 80118c2:	b08a      	sub	sp, #40	; 0x28
 80118c4:	af08      	add	r7, sp, #32
    UINT ret;

#ifdef configTOTAL_HEAP_SIZE
    if(configTOTAL_HEAP_SIZE > 0u) {
        ret = tx_byte_pool_create(&txfr_heap, "txfr_byte_pool", txfr_heap_mem, configTOTAL_HEAP_SIZE);
 80118c6:	2334      	movs	r3, #52	; 0x34
 80118c8:	9300      	str	r3, [sp, #0]
 80118ca:	4b1d      	ldr	r3, [pc, #116]	; (8011940 <tx_freertos_init+0x80>)
 80118cc:	4a1d      	ldr	r2, [pc, #116]	; (8011944 <tx_freertos_init+0x84>)
 80118ce:	491e      	ldr	r1, [pc, #120]	; (8011948 <tx_freertos_init+0x88>)
 80118d0:	481e      	ldr	r0, [pc, #120]	; (801194c <tx_freertos_init+0x8c>)
 80118d2:	f004 f9d1 	bl	8015c78 <_txe_byte_pool_create>
 80118d6:	6078      	str	r0, [r7, #4]
        if(ret != TX_SUCCESS) {
 80118d8:	687b      	ldr	r3, [r7, #4]
 80118da:	2b00      	cmp	r3, #0
 80118dc:	d001      	beq.n	80118e2 <tx_freertos_init+0x22>
            return ret;
 80118de:	687b      	ldr	r3, [r7, #4]
 80118e0:	e02a      	b.n	8011938 <tx_freertos_init+0x78>
        }
        txfr_heap_initialized = 1u;
 80118e2:	4b1b      	ldr	r3, [pc, #108]	; (8011950 <tx_freertos_init+0x90>)
 80118e4:	2201      	movs	r2, #1
 80118e6:	601a      	str	r2, [r3, #0]
    }
#endif

#if (INCLUDE_vTaskDelete == 1)
    ret = tx_semaphore_create(&txfr_idle_sem, "txfr_idle_semaphore", 0u);
 80118e8:	231c      	movs	r3, #28
 80118ea:	2200      	movs	r2, #0
 80118ec:	4919      	ldr	r1, [pc, #100]	; (8011954 <tx_freertos_init+0x94>)
 80118ee:	481a      	ldr	r0, [pc, #104]	; (8011958 <tx_freertos_init+0x98>)
 80118f0:	f004 fec4 	bl	801667c <_txe_semaphore_create>
 80118f4:	6078      	str	r0, [r7, #4]
    if(ret != TX_SUCCESS) {
 80118f6:	687b      	ldr	r3, [r7, #4]
 80118f8:	2b00      	cmp	r3, #0
 80118fa:	d001      	beq.n	8011900 <tx_freertos_init+0x40>
        return ret;
 80118fc:	687b      	ldr	r3, [r7, #4]
 80118fe:	e01b      	b.n	8011938 <tx_freertos_init+0x78>
    }

    ret = tx_thread_create(&txfr_idle_task, "txfr_idle_task", txfr_idle_task_entry, 0u,
 8011900:	23b4      	movs	r3, #180	; 0xb4
 8011902:	9306      	str	r3, [sp, #24]
 8011904:	2301      	movs	r3, #1
 8011906:	9305      	str	r3, [sp, #20]
 8011908:	2300      	movs	r3, #0
 801190a:	9304      	str	r3, [sp, #16]
 801190c:	231f      	movs	r3, #31
 801190e:	9303      	str	r3, [sp, #12]
 8011910:	231f      	movs	r3, #31
 8011912:	9302      	str	r3, [sp, #8]
 8011914:	f44f 7300 	mov.w	r3, #512	; 0x200
 8011918:	9301      	str	r3, [sp, #4]
 801191a:	4b10      	ldr	r3, [pc, #64]	; (801195c <tx_freertos_init+0x9c>)
 801191c:	9300      	str	r3, [sp, #0]
 801191e:	2300      	movs	r3, #0
 8011920:	4a0f      	ldr	r2, [pc, #60]	; (8011960 <tx_freertos_init+0xa0>)
 8011922:	4910      	ldr	r1, [pc, #64]	; (8011964 <tx_freertos_init+0xa4>)
 8011924:	4810      	ldr	r0, [pc, #64]	; (8011968 <tx_freertos_init+0xa8>)
 8011926:	f004 ffdd 	bl	80168e4 <_txe_thread_create>
 801192a:	6078      	str	r0, [r7, #4]
            txfr_idle_stack, sizeof(txfr_idle_stack), TX_MAX_PRIORITIES - 1u, TX_MAX_PRIORITIES - 1u, 0u, TX_AUTO_START);
    if(ret != TX_SUCCESS) {
 801192c:	687b      	ldr	r3, [r7, #4]
 801192e:	2b00      	cmp	r3, #0
 8011930:	d001      	beq.n	8011936 <tx_freertos_init+0x76>
        return ret;
 8011932:	687b      	ldr	r3, [r7, #4]
 8011934:	e000      	b.n	8011938 <tx_freertos_init+0x78>
    }
#endif // #if (INCLUDE_vTaskDelete == 1)

    return TX_SUCCESS;
 8011936:	2300      	movs	r3, #0
}
 8011938:	4618      	mov	r0, r3
 801193a:	3708      	adds	r7, #8
 801193c:	46bd      	mov	sp, r7
 801193e:	bd80      	pop	{r7, pc}
 8011940:	00030d40 	.word	0x00030d40
 8011944:	24000e14 	.word	0x24000e14
 8011948:	08021e34 	.word	0x08021e34
 801194c:	24031b54 	.word	0x24031b54
 8011950:	24031b88 	.word	0x24031b88
 8011954:	08021e44 	.word	0x08021e44
 8011958:	24000df0 	.word	0x24000df0
 801195c:	24000bf0 	.word	0x24000bf0
 8011960:	0801182d 	.word	0x0801182d
 8011964:	08021e58 	.word	0x08021e58
 8011968:	24000b3c 	.word	0x24000b3c

0801196c <_tx_byte_allocate>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
UINT  _tx_byte_allocate(TX_BYTE_POOL *pool_ptr, VOID **memory_ptr, ULONG memory_size,  ULONG wait_option)
{
 801196c:	b580      	push	{r7, lr}
 801196e:	b096      	sub	sp, #88	; 0x58
 8011970:	af00      	add	r7, sp, #0
 8011972:	60f8      	str	r0, [r7, #12]
 8011974:	60b9      	str	r1, [r7, #8]
 8011976:	607a      	str	r2, [r7, #4]
 8011978:	603b      	str	r3, [r7, #0]
#endif


    /* Round the memory size up to the next size that is evenly divisible by
       an ALIGN_TYPE (this is typically a 32-bit ULONG).  This guarantees proper alignment.  */
    memory_size = (((memory_size + (sizeof(ALIGN_TYPE)))-((ALIGN_TYPE) 1))/(sizeof(ALIGN_TYPE))) * (sizeof(ALIGN_TYPE));
 801197a:	687b      	ldr	r3, [r7, #4]
 801197c:	3303      	adds	r3, #3
 801197e:	f023 0303 	bic.w	r3, r3, #3
 8011982:	607b      	str	r3, [r7, #4]
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 8011984:	f3ef 8310 	mrs	r3, PRIMASK
 8011988:	637b      	str	r3, [r7, #52]	; 0x34
    return(posture);
 801198a:	6b7b      	ldr	r3, [r7, #52]	; 0x34
    int_posture = __get_interrupt_posture();
 801198c:	633b      	str	r3, [r7, #48]	; 0x30
    __asm__ volatile ("CPSID i" : : : "memory");
 801198e:	b672      	cpsid	i
    return(int_posture);
 8011990:	6b3b      	ldr	r3, [r7, #48]	; 0x30

    /* Disable interrupts.  */
    TX_DISABLE
 8011992:	657b      	str	r3, [r7, #84]	; 0x54

    /* Pickup thread pointer.  */
    TX_THREAD_GET_CURRENT(thread_ptr)
 8011994:	4b55      	ldr	r3, [pc, #340]	; (8011aec <_tx_byte_allocate+0x180>)
 8011996:	681b      	ldr	r3, [r3, #0]
 8011998:	64bb      	str	r3, [r7, #72]	; 0x48
    lower_tbu =  *((ULONG *) (log_entry_ptr + TX_EL_EVENT_TIME_LOWER_OFFSET));
    upper_tbu =  *((ULONG *) (log_entry_ptr + TX_EL_EVENT_TIME_UPPER_OFFSET));
#endif

    /* Set the search finished flag to false.  */
    finished =  TX_FALSE;
 801199a:	2300      	movs	r3, #0
 801199c:	64fb      	str	r3, [r7, #76]	; 0x4c
    /* Loop to handle cases where the owner of the pool changed.  */
    do
    {

        /* Indicate that this thread is the current owner.  */
        pool_ptr -> tx_byte_pool_owner =  thread_ptr;
 801199e:	68fb      	ldr	r3, [r7, #12]
 80119a0:	6cba      	ldr	r2, [r7, #72]	; 0x48
 80119a2:	621a      	str	r2, [r3, #32]
 80119a4:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 80119a6:	627b      	str	r3, [r7, #36]	; 0x24
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 80119a8:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80119aa:	f383 8810 	msr	PRIMASK, r3
}
 80119ae:	bf00      	nop
        /* Restore interrupts.  */
        TX_RESTORE

        /* At this point, the executing thread owns the pool and can perform a search
           for free memory.  */
        work_ptr =  _tx_byte_pool_search(pool_ptr, memory_size);
 80119b0:	6879      	ldr	r1, [r7, #4]
 80119b2:	68f8      	ldr	r0, [r7, #12]
 80119b4:	f000 f9b2 	bl	8011d1c <_tx_byte_pool_search>
 80119b8:	6478      	str	r0, [r7, #68]	; 0x44
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 80119ba:	f3ef 8310 	mrs	r3, PRIMASK
 80119be:	62fb      	str	r3, [r7, #44]	; 0x2c
    return(posture);
 80119c0:	6afb      	ldr	r3, [r7, #44]	; 0x2c
    int_posture = __get_interrupt_posture();
 80119c2:	62bb      	str	r3, [r7, #40]	; 0x28
    __asm__ volatile ("CPSID i" : : : "memory");
 80119c4:	b672      	cpsid	i
    return(int_posture);
 80119c6:	6abb      	ldr	r3, [r7, #40]	; 0x28

        /* Optional processing extension.  */
        TX_BYTE_ALLOCATE_EXTENSION

        /* Lockout interrupts.  */
        TX_DISABLE
 80119c8:	657b      	str	r3, [r7, #84]	; 0x54

        /* Determine if we are finished.  */
        if (work_ptr != TX_NULL)
 80119ca:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 80119cc:	2b00      	cmp	r3, #0
 80119ce:	d002      	beq.n	80119d6 <_tx_byte_allocate+0x6a>
        {
        
            /* Yes, we have found a block the search is finished.  */
            finished =  TX_TRUE;
 80119d0:	2301      	movs	r3, #1
 80119d2:	64fb      	str	r3, [r7, #76]	; 0x4c
 80119d4:	e006      	b.n	80119e4 <_tx_byte_allocate+0x78>
        }
        else
        {
        
            /* No block was found, does this thread still own the pool?  */
            if (pool_ptr -> tx_byte_pool_owner == thread_ptr)
 80119d6:	68fb      	ldr	r3, [r7, #12]
 80119d8:	6a1b      	ldr	r3, [r3, #32]
 80119da:	6cba      	ldr	r2, [r7, #72]	; 0x48
 80119dc:	429a      	cmp	r2, r3
 80119de:	d101      	bne.n	80119e4 <_tx_byte_allocate+0x78>
            {
            
                /* Yes, then we have looked through the entire pool and haven't found the memory.  */
                finished =  TX_TRUE;
 80119e0:	2301      	movs	r3, #1
 80119e2:	64fb      	str	r3, [r7, #76]	; 0x4c
            }
        }

    } while (finished == TX_FALSE);
 80119e4:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 80119e6:	2b00      	cmp	r3, #0
 80119e8:	d0d9      	beq.n	801199e <_tx_byte_allocate+0x32>

    /* Copy the pointer into the return destination.  */
    *memory_ptr =  (VOID *) work_ptr;
 80119ea:	68bb      	ldr	r3, [r7, #8]
 80119ec:	6c7a      	ldr	r2, [r7, #68]	; 0x44
 80119ee:	601a      	str	r2, [r3, #0]

    /* Determine if memory was found.  */
    if (work_ptr != TX_NULL)
 80119f0:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 80119f2:	2b00      	cmp	r3, #0
 80119f4:	d008      	beq.n	8011a08 <_tx_byte_allocate+0x9c>
 80119f6:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 80119f8:	623b      	str	r3, [r7, #32]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 80119fa:	6a3b      	ldr	r3, [r7, #32]
 80119fc:	f383 8810 	msr	PRIMASK, r3
}
 8011a00:	bf00      	nop

        /* Restore interrupts.  */
        TX_RESTORE
        
        /* Set the status to success.  */
        status =  TX_SUCCESS;
 8011a02:	2300      	movs	r3, #0
 8011a04:	653b      	str	r3, [r7, #80]	; 0x50
 8011a06:	e06c      	b.n	8011ae2 <_tx_byte_allocate+0x176>
    {

        /* No memory of sufficient size was found...  */

        /* Determine if the request specifies suspension.  */
        if (wait_option != TX_NO_WAIT)
 8011a08:	683b      	ldr	r3, [r7, #0]
 8011a0a:	2b00      	cmp	r3, #0
 8011a0c:	d061      	beq.n	8011ad2 <_tx_byte_allocate+0x166>
        {

            /* Determine if the preempt disable flag is non-zero.  */
            if (_tx_thread_preempt_disable != ((UINT) 0))
 8011a0e:	4b38      	ldr	r3, [pc, #224]	; (8011af0 <_tx_byte_allocate+0x184>)
 8011a10:	681b      	ldr	r3, [r3, #0]
 8011a12:	2b00      	cmp	r3, #0
 8011a14:	d007      	beq.n	8011a26 <_tx_byte_allocate+0xba>
            {

                /* Suspension is not allowed if the preempt disable flag is non-zero at this point - return error completion.  */
                status =  TX_NO_MEMORY;
 8011a16:	2310      	movs	r3, #16
 8011a18:	653b      	str	r3, [r7, #80]	; 0x50
 8011a1a:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 8011a1c:	61fb      	str	r3, [r7, #28]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 8011a1e:	69fb      	ldr	r3, [r7, #28]
 8011a20:	f383 8810 	msr	PRIMASK, r3
}
 8011a24:	e05d      	b.n	8011ae2 <_tx_byte_allocate+0x176>
                /* Increment the number of suspensions on this pool.  */
                pool_ptr -> tx_byte_pool_performance_suspension_count++;
#endif

                /* Setup cleanup routine pointer.  */
                thread_ptr -> tx_thread_suspend_cleanup =  &(_tx_byte_pool_cleanup);
 8011a26:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 8011a28:	4a32      	ldr	r2, [pc, #200]	; (8011af4 <_tx_byte_allocate+0x188>)
 8011a2a:	669a      	str	r2, [r3, #104]	; 0x68

                /* Setup cleanup information, i.e. this pool control
                   block.  */
                thread_ptr -> tx_thread_suspend_control_block =  (VOID *) pool_ptr;
 8011a2c:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 8011a2e:	68fa      	ldr	r2, [r7, #12]
 8011a30:	66da      	str	r2, [r3, #108]	; 0x6c

                /* Save the return memory pointer address as well.  */
                thread_ptr -> tx_thread_additional_suspend_info =  (VOID *) memory_ptr;
 8011a32:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 8011a34:	68ba      	ldr	r2, [r7, #8]
 8011a36:	67da      	str	r2, [r3, #124]	; 0x7c

                /* Save the byte size requested.  */
                thread_ptr -> tx_thread_suspend_info =  memory_size;
 8011a38:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 8011a3a:	687a      	ldr	r2, [r7, #4]
 8011a3c:	679a      	str	r2, [r3, #120]	; 0x78

#ifndef TX_NOT_INTERRUPTABLE

                /* Increment the suspension sequence number, which is used to identify
                   this suspension event.  */
                thread_ptr -> tx_thread_suspension_sequence++;
 8011a3e:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 8011a40:	f8d3 30ac 	ldr.w	r3, [r3, #172]	; 0xac
 8011a44:	1c5a      	adds	r2, r3, #1
 8011a46:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 8011a48:	f8c3 20ac 	str.w	r2, [r3, #172]	; 0xac
#endif

                /* Pickup the number of suspended threads.  */
                suspended_count =  pool_ptr -> tx_byte_pool_suspended_count;
 8011a4c:	68fb      	ldr	r3, [r7, #12]
 8011a4e:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8011a50:	643b      	str	r3, [r7, #64]	; 0x40

                /* Increment the suspension count.  */
                (pool_ptr -> tx_byte_pool_suspended_count)++;
 8011a52:	68fb      	ldr	r3, [r7, #12]
 8011a54:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8011a56:	1c5a      	adds	r2, r3, #1
 8011a58:	68fb      	ldr	r3, [r7, #12]
 8011a5a:	629a      	str	r2, [r3, #40]	; 0x28
            
                /* Setup suspension list.  */
                if (suspended_count == TX_NO_SUSPENSIONS)
 8011a5c:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8011a5e:	2b00      	cmp	r3, #0
 8011a60:	d109      	bne.n	8011a76 <_tx_byte_allocate+0x10a>
                {

                    /* No other threads are suspended.  Setup the head pointer and
                       just setup this threads pointers to itself.  */
                    pool_ptr -> tx_byte_pool_suspension_list =      thread_ptr;
 8011a62:	68fb      	ldr	r3, [r7, #12]
 8011a64:	6cba      	ldr	r2, [r7, #72]	; 0x48
 8011a66:	625a      	str	r2, [r3, #36]	; 0x24
                    thread_ptr -> tx_thread_suspended_next =        thread_ptr;
 8011a68:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 8011a6a:	6cba      	ldr	r2, [r7, #72]	; 0x48
 8011a6c:	671a      	str	r2, [r3, #112]	; 0x70
                    thread_ptr -> tx_thread_suspended_previous =    thread_ptr;
 8011a6e:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 8011a70:	6cba      	ldr	r2, [r7, #72]	; 0x48
 8011a72:	675a      	str	r2, [r3, #116]	; 0x74
 8011a74:	e011      	b.n	8011a9a <_tx_byte_allocate+0x12e>
                }
                else
                {

                    /* This list is not NULL, add current thread to the end. */
                    next_thread =                                   pool_ptr -> tx_byte_pool_suspension_list;
 8011a76:	68fb      	ldr	r3, [r7, #12]
 8011a78:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8011a7a:	63fb      	str	r3, [r7, #60]	; 0x3c
                    thread_ptr -> tx_thread_suspended_next =        next_thread;
 8011a7c:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 8011a7e:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 8011a80:	671a      	str	r2, [r3, #112]	; 0x70
                    previous_thread =                               next_thread -> tx_thread_suspended_previous;
 8011a82:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8011a84:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 8011a86:	63bb      	str	r3, [r7, #56]	; 0x38
                    thread_ptr -> tx_thread_suspended_previous =    previous_thread;
 8011a88:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 8011a8a:	6bba      	ldr	r2, [r7, #56]	; 0x38
 8011a8c:	675a      	str	r2, [r3, #116]	; 0x74
                    previous_thread -> tx_thread_suspended_next =   thread_ptr;
 8011a8e:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8011a90:	6cba      	ldr	r2, [r7, #72]	; 0x48
 8011a92:	671a      	str	r2, [r3, #112]	; 0x70
                    next_thread -> tx_thread_suspended_previous =   thread_ptr;
 8011a94:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8011a96:	6cba      	ldr	r2, [r7, #72]	; 0x48
 8011a98:	675a      	str	r2, [r3, #116]	; 0x74
                }

                /* Set the state to suspended.  */
                thread_ptr -> tx_thread_state =       TX_BYTE_MEMORY;
 8011a9a:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 8011a9c:	2209      	movs	r2, #9
 8011a9e:	631a      	str	r2, [r3, #48]	; 0x30
                /* Restore interrupts.  */
                TX_RESTORE
#else

                /* Set the suspending flag.  */
                thread_ptr -> tx_thread_suspending =  TX_TRUE;
 8011aa0:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 8011aa2:	2201      	movs	r2, #1
 8011aa4:	639a      	str	r2, [r3, #56]	; 0x38

                /* Setup the timeout period.  */
                thread_ptr -> tx_thread_timer.tx_timer_internal_remaining_ticks =  wait_option;
 8011aa6:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 8011aa8:	683a      	ldr	r2, [r7, #0]
 8011aaa:	64da      	str	r2, [r3, #76]	; 0x4c

                /* Temporarily disable preemption.  */
                _tx_thread_preempt_disable++;
 8011aac:	4b10      	ldr	r3, [pc, #64]	; (8011af0 <_tx_byte_allocate+0x184>)
 8011aae:	681b      	ldr	r3, [r3, #0]
 8011ab0:	3301      	adds	r3, #1
 8011ab2:	4a0f      	ldr	r2, [pc, #60]	; (8011af0 <_tx_byte_allocate+0x184>)
 8011ab4:	6013      	str	r3, [r2, #0]
 8011ab6:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 8011ab8:	61bb      	str	r3, [r7, #24]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 8011aba:	69bb      	ldr	r3, [r7, #24]
 8011abc:	f383 8810 	msr	PRIMASK, r3
}
 8011ac0:	bf00      	nop

                /* Restore interrupts.  */
                TX_RESTORE

                /* Call actual thread suspension routine.  */
                _tx_thread_system_suspend(thread_ptr);
 8011ac2:	6cb8      	ldr	r0, [r7, #72]	; 0x48
 8011ac4:	f003 fa30 	bl	8014f28 <_tx_thread_system_suspend>
                    *((ULONG *) (log_entry_ptr + TX_EL_EVENT_INFO_4_OFFSET)) =  (ULONG) *memory_ptr;
                }
#endif

                /* Return the completion status.  */
                status =  thread_ptr -> tx_thread_suspend_status;
 8011ac8:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 8011aca:	f8d3 3084 	ldr.w	r3, [r3, #132]	; 0x84
 8011ace:	653b      	str	r3, [r7, #80]	; 0x50
 8011ad0:	e007      	b.n	8011ae2 <_tx_byte_allocate+0x176>
 8011ad2:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 8011ad4:	617b      	str	r3, [r7, #20]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 8011ad6:	697b      	ldr	r3, [r7, #20]
 8011ad8:	f383 8810 	msr	PRIMASK, r3
}
 8011adc:	bf00      	nop
    
            /* Restore interrupts.  */
            TX_RESTORE

            /* Immediate return, return error completion.  */
            status =  TX_NO_MEMORY;
 8011ade:	2310      	movs	r3, #16
 8011ae0:	653b      	str	r3, [r7, #80]	; 0x50
        }
    }

    /* Return completion status.  */
    return(status);
 8011ae2:	6d3b      	ldr	r3, [r7, #80]	; 0x50
}
 8011ae4:	4618      	mov	r0, r3
 8011ae6:	3758      	adds	r7, #88	; 0x58
 8011ae8:	46bd      	mov	sp, r7
 8011aea:	bd80      	pop	{r7, pc}
 8011aec:	24031bc4 	.word	0x24031bc4
 8011af0:	24031c5c 	.word	0x24031c5c
 8011af4:	08011af9 	.word	0x08011af9

08011af8 <_tx_byte_pool_cleanup>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
VOID  _tx_byte_pool_cleanup(TX_THREAD *thread_ptr, ULONG suspension_sequence)
{
 8011af8:	b580      	push	{r7, lr}
 8011afa:	b08e      	sub	sp, #56	; 0x38
 8011afc:	af00      	add	r7, sp, #0
 8011afe:	6078      	str	r0, [r7, #4]
 8011b00:	6039      	str	r1, [r7, #0]
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 8011b02:	f3ef 8310 	mrs	r3, PRIMASK
 8011b06:	623b      	str	r3, [r7, #32]
    return(posture);
 8011b08:	6a3b      	ldr	r3, [r7, #32]
    int_posture = __get_interrupt_posture();
 8011b0a:	61fb      	str	r3, [r7, #28]
    __asm__ volatile ("CPSID i" : : : "memory");
 8011b0c:	b672      	cpsid	i
    return(int_posture);
 8011b0e:	69fb      	ldr	r3, [r7, #28]

    
#ifndef TX_NOT_INTERRUPTABLE

    /* Disable interrupts to remove the suspended thread from the byte pool.  */
    TX_DISABLE
 8011b10:	637b      	str	r3, [r7, #52]	; 0x34

    /* Determine if the cleanup is still required.  */
    if (thread_ptr -> tx_thread_suspend_cleanup == &(_tx_byte_pool_cleanup))
 8011b12:	687b      	ldr	r3, [r7, #4]
 8011b14:	6e9b      	ldr	r3, [r3, #104]	; 0x68
 8011b16:	4a33      	ldr	r2, [pc, #204]	; (8011be4 <_tx_byte_pool_cleanup+0xec>)
 8011b18:	4293      	cmp	r3, r2
 8011b1a:	d158      	bne.n	8011bce <_tx_byte_pool_cleanup+0xd6>
    {
    
        /* Check for valid suspension sequence.  */
        if (suspension_sequence == thread_ptr -> tx_thread_suspension_sequence)
 8011b1c:	687b      	ldr	r3, [r7, #4]
 8011b1e:	f8d3 30ac 	ldr.w	r3, [r3, #172]	; 0xac
 8011b22:	683a      	ldr	r2, [r7, #0]
 8011b24:	429a      	cmp	r2, r3
 8011b26:	d152      	bne.n	8011bce <_tx_byte_pool_cleanup+0xd6>
        {

            /* Setup pointer to byte pool control block.  */
            pool_ptr =  TX_VOID_TO_BYTE_POOL_POINTER_CONVERT(thread_ptr -> tx_thread_suspend_control_block);
 8011b28:	687b      	ldr	r3, [r7, #4]
 8011b2a:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 8011b2c:	633b      	str	r3, [r7, #48]	; 0x30

            /* Check for a NULL byte pool pointer.  */
            if (pool_ptr != TX_NULL)
 8011b2e:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8011b30:	2b00      	cmp	r3, #0
 8011b32:	d04c      	beq.n	8011bce <_tx_byte_pool_cleanup+0xd6>
            {
            
                /* Check for valid pool ID.  */
                if (pool_ptr -> tx_byte_pool_id == TX_BYTE_POOL_ID)
 8011b34:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8011b36:	681b      	ldr	r3, [r3, #0]
 8011b38:	4a2b      	ldr	r2, [pc, #172]	; (8011be8 <_tx_byte_pool_cleanup+0xf0>)
 8011b3a:	4293      	cmp	r3, r2
 8011b3c:	d147      	bne.n	8011bce <_tx_byte_pool_cleanup+0xd6>
                {

                    /* Determine if there are any thread suspensions.  */
                    if (pool_ptr -> tx_byte_pool_suspended_count != TX_NO_SUSPENSIONS)
 8011b3e:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8011b40:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8011b42:	2b00      	cmp	r3, #0
 8011b44:	d043      	beq.n	8011bce <_tx_byte_pool_cleanup+0xd6>
                        /* Setup pointer to byte pool control block.  */
                        pool_ptr =  TX_VOID_TO_BYTE_POOL_POINTER_CONVERT(thread_ptr -> tx_thread_suspend_control_block);
#endif

                        /* Thread suspended for memory... Clear the suspension cleanup flag.  */
                        thread_ptr -> tx_thread_suspend_cleanup =  TX_NULL;
 8011b46:	687b      	ldr	r3, [r7, #4]
 8011b48:	2200      	movs	r2, #0
 8011b4a:	669a      	str	r2, [r3, #104]	; 0x68

                        /* Decrement the suspension count.  */
                        pool_ptr -> tx_byte_pool_suspended_count--;
 8011b4c:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8011b4e:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8011b50:	1e5a      	subs	r2, r3, #1
 8011b52:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8011b54:	629a      	str	r2, [r3, #40]	; 0x28
            
                        /* Pickup the suspended count.  */
                        suspended_count =  pool_ptr -> tx_byte_pool_suspended_count;
 8011b56:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8011b58:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8011b5a:	62fb      	str	r3, [r7, #44]	; 0x2c

                        /* Remove the suspended thread from the list.  */
    
                        /* See if this is the only suspended thread on the list.  */
                        if (suspended_count == TX_NO_SUSPENSIONS)
 8011b5c:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8011b5e:	2b00      	cmp	r3, #0
 8011b60:	d103      	bne.n	8011b6a <_tx_byte_pool_cleanup+0x72>
                        {

                            /* Yes, the only suspended thread.  */
    
                            /* Update the head pointer.  */
                            pool_ptr -> tx_byte_pool_suspension_list =  TX_NULL;
 8011b62:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8011b64:	2200      	movs	r2, #0
 8011b66:	625a      	str	r2, [r3, #36]	; 0x24
 8011b68:	e013      	b.n	8011b92 <_tx_byte_pool_cleanup+0x9a>
                        {

                            /* At least one more thread is on the same suspension list.  */

                            /* Update the links of the adjacent threads.  */
                            next_thread =                                   thread_ptr -> tx_thread_suspended_next;
 8011b6a:	687b      	ldr	r3, [r7, #4]
 8011b6c:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 8011b6e:	62bb      	str	r3, [r7, #40]	; 0x28
                            previous_thread =                               thread_ptr -> tx_thread_suspended_previous;
 8011b70:	687b      	ldr	r3, [r7, #4]
 8011b72:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 8011b74:	627b      	str	r3, [r7, #36]	; 0x24
                            next_thread -> tx_thread_suspended_previous =   previous_thread;
 8011b76:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8011b78:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8011b7a:	675a      	str	r2, [r3, #116]	; 0x74
                            previous_thread -> tx_thread_suspended_next =   next_thread;
 8011b7c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8011b7e:	6aba      	ldr	r2, [r7, #40]	; 0x28
 8011b80:	671a      	str	r2, [r3, #112]	; 0x70

                            /* Determine if we need to update the head pointer.  */
                            if (pool_ptr -> tx_byte_pool_suspension_list == thread_ptr)
 8011b82:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8011b84:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8011b86:	687a      	ldr	r2, [r7, #4]
 8011b88:	429a      	cmp	r2, r3
 8011b8a:	d102      	bne.n	8011b92 <_tx_byte_pool_cleanup+0x9a>
                            {
            
                                /* Update the list head pointer.  */
                                pool_ptr -> tx_byte_pool_suspension_list =      next_thread;
 8011b8c:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8011b8e:	6aba      	ldr	r2, [r7, #40]	; 0x28
 8011b90:	625a      	str	r2, [r3, #36]	; 0x24
                            }
                        }

                        /* Now we need to determine if this cleanup is from a terminate, timeout,
                           or from a wait abort.  */
                        if (thread_ptr -> tx_thread_state == TX_BYTE_MEMORY)
 8011b92:	687b      	ldr	r3, [r7, #4]
 8011b94:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8011b96:	2b09      	cmp	r3, #9
 8011b98:	d119      	bne.n	8011bce <_tx_byte_pool_cleanup+0xd6>
                            /* Increment the number of timeouts on this byte pool.  */
                            pool_ptr -> tx_byte_pool_performance_timeout_count++;
#endif

                            /* Setup return status.  */
                            thread_ptr -> tx_thread_suspend_status =  TX_NO_MEMORY;
 8011b9a:	687b      	ldr	r3, [r7, #4]
 8011b9c:	2210      	movs	r2, #16
 8011b9e:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84
                            /* Resume the thread!  */
                            _tx_thread_system_ni_resume(thread_ptr);
#else

                            /* Temporarily disable preemption.  */
                            _tx_thread_preempt_disable++;
 8011ba2:	4b12      	ldr	r3, [pc, #72]	; (8011bec <_tx_byte_pool_cleanup+0xf4>)
 8011ba4:	681b      	ldr	r3, [r3, #0]
 8011ba6:	3301      	adds	r3, #1
 8011ba8:	4a10      	ldr	r2, [pc, #64]	; (8011bec <_tx_byte_pool_cleanup+0xf4>)
 8011baa:	6013      	str	r3, [r2, #0]
 8011bac:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8011bae:	613b      	str	r3, [r7, #16]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 8011bb0:	693b      	ldr	r3, [r7, #16]
 8011bb2:	f383 8810 	msr	PRIMASK, r3
}
 8011bb6:	bf00      	nop

                            /* Restore interrupts.  */
                            TX_RESTORE

                            /* Resume the thread!  */
                            _tx_thread_system_resume(thread_ptr);
 8011bb8:	6878      	ldr	r0, [r7, #4]
 8011bba:	f003 f8b5 	bl	8014d28 <_tx_thread_system_resume>
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 8011bbe:	f3ef 8310 	mrs	r3, PRIMASK
 8011bc2:	61bb      	str	r3, [r7, #24]
    return(posture);
 8011bc4:	69bb      	ldr	r3, [r7, #24]
    int_posture = __get_interrupt_posture();
 8011bc6:	617b      	str	r3, [r7, #20]
    __asm__ volatile ("CPSID i" : : : "memory");
 8011bc8:	b672      	cpsid	i
    return(int_posture);
 8011bca:	697b      	ldr	r3, [r7, #20]

                            /* Disable interrupts.  */
                            TX_DISABLE
 8011bcc:	637b      	str	r3, [r7, #52]	; 0x34
 8011bce:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8011bd0:	60fb      	str	r3, [r7, #12]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 8011bd2:	68fb      	ldr	r3, [r7, #12]
 8011bd4:	f383 8810 	msr	PRIMASK, r3
}
 8011bd8:	bf00      	nop
    }

    /* Restore interrupts.  */
    TX_RESTORE
#endif
}
 8011bda:	bf00      	nop
 8011bdc:	3738      	adds	r7, #56	; 0x38
 8011bde:	46bd      	mov	sp, r7
 8011be0:	bd80      	pop	{r7, pc}
 8011be2:	bf00      	nop
 8011be4:	08011af9 	.word	0x08011af9
 8011be8:	42595445 	.word	0x42595445
 8011bec:	24031c5c 	.word	0x24031c5c

08011bf0 <_tx_byte_pool_create>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
UINT  _tx_byte_pool_create(TX_BYTE_POOL *pool_ptr, CHAR *name_ptr, VOID *pool_start, ULONG pool_size)
{
 8011bf0:	b580      	push	{r7, lr}
 8011bf2:	b08e      	sub	sp, #56	; 0x38
 8011bf4:	af00      	add	r7, sp, #0
 8011bf6:	60f8      	str	r0, [r7, #12]
 8011bf8:	60b9      	str	r1, [r7, #8]
 8011bfa:	607a      	str	r2, [r7, #4]
 8011bfc:	603b      	str	r3, [r7, #0]
TX_BYTE_POOL        *previous_pool;
ALIGN_TYPE          *free_ptr;


    /* Initialize the byte pool control block to all zeros.  */
    TX_MEMSET(pool_ptr, 0, (sizeof(TX_BYTE_POOL)));
 8011bfe:	2234      	movs	r2, #52	; 0x34
 8011c00:	2100      	movs	r1, #0
 8011c02:	68f8      	ldr	r0, [r7, #12]
 8011c04:	f00d fe3a 	bl	801f87c <memset>

    /* Round the pool size down to something that is evenly divisible by 
       an ULONG.  */
    pool_size =   (pool_size/(sizeof(ALIGN_TYPE))) * (sizeof(ALIGN_TYPE));
 8011c08:	683b      	ldr	r3, [r7, #0]
 8011c0a:	f023 0303 	bic.w	r3, r3, #3
 8011c0e:	603b      	str	r3, [r7, #0]

    /* Setup the basic byte pool fields.  */
    pool_ptr -> tx_byte_pool_name =              name_ptr;
 8011c10:	68fb      	ldr	r3, [r7, #12]
 8011c12:	68ba      	ldr	r2, [r7, #8]
 8011c14:	605a      	str	r2, [r3, #4]

    /* Save the start and size of the pool.  */
    pool_ptr -> tx_byte_pool_start =   TX_VOID_TO_UCHAR_POINTER_CONVERT(pool_start);
 8011c16:	68fb      	ldr	r3, [r7, #12]
 8011c18:	687a      	ldr	r2, [r7, #4]
 8011c1a:	619a      	str	r2, [r3, #24]
    pool_ptr -> tx_byte_pool_size =    pool_size;
 8011c1c:	68fb      	ldr	r3, [r7, #12]
 8011c1e:	683a      	ldr	r2, [r7, #0]
 8011c20:	61da      	str	r2, [r3, #28]

    /* Setup memory list to the beginning as well as the search pointer.  */
    pool_ptr -> tx_byte_pool_list =    TX_VOID_TO_UCHAR_POINTER_CONVERT(pool_start);
 8011c22:	68fb      	ldr	r3, [r7, #12]
 8011c24:	687a      	ldr	r2, [r7, #4]
 8011c26:	611a      	str	r2, [r3, #16]
    pool_ptr -> tx_byte_pool_search =  TX_VOID_TO_UCHAR_POINTER_CONVERT(pool_start);
 8011c28:	68fb      	ldr	r3, [r7, #12]
 8011c2a:	687a      	ldr	r2, [r7, #4]
 8011c2c:	615a      	str	r2, [r3, #20]

    /* Initially, the pool will have two blocks.  One large block at the 
       beginning that is available and a small allocated block at the end
       of the pool that is there just for the algorithm.  Be sure to count
       the available block's header in the available bytes count.  */
    pool_ptr -> tx_byte_pool_available =   pool_size - ((sizeof(VOID *)) + (sizeof(ALIGN_TYPE)));
 8011c2e:	683b      	ldr	r3, [r7, #0]
 8011c30:	f1a3 0208 	sub.w	r2, r3, #8
 8011c34:	68fb      	ldr	r3, [r7, #12]
 8011c36:	609a      	str	r2, [r3, #8]
    pool_ptr -> tx_byte_pool_fragments =   ((UINT) 2);
 8011c38:	68fb      	ldr	r3, [r7, #12]
 8011c3a:	2202      	movs	r2, #2
 8011c3c:	60da      	str	r2, [r3, #12]
    /* Each block contains a "next" pointer that points to the next block in the pool followed by a ALIGN_TYPE
       field that contains either the constant TX_BYTE_BLOCK_FREE (if the block is free) or a pointer to the
       owning pool (if the block is allocated).  */
    
    /* Calculate the end of the pool's memory area.  */
    block_ptr =  TX_VOID_TO_UCHAR_POINTER_CONVERT(pool_start);
 8011c3e:	687b      	ldr	r3, [r7, #4]
 8011c40:	637b      	str	r3, [r7, #52]	; 0x34
    block_ptr =  TX_UCHAR_POINTER_ADD(block_ptr, pool_size);
 8011c42:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 8011c44:	683b      	ldr	r3, [r7, #0]
 8011c46:	4413      	add	r3, r2
 8011c48:	637b      	str	r3, [r7, #52]	; 0x34

    /* Backup the end of the pool pointer and build the pre-allocated block.  */
    block_ptr =  TX_UCHAR_POINTER_SUB(block_ptr, (sizeof(ALIGN_TYPE)));
 8011c4a:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8011c4c:	3b04      	subs	r3, #4
 8011c4e:	637b      	str	r3, [r7, #52]	; 0x34

    /* Cast the pool pointer into a ULONG.  */
    temp_ptr =             TX_BYTE_POOL_TO_UCHAR_POINTER_CONVERT(pool_ptr);
 8011c50:	68fb      	ldr	r3, [r7, #12]
 8011c52:	633b      	str	r3, [r7, #48]	; 0x30
    block_indirect_ptr =   TX_UCHAR_TO_INDIRECT_UCHAR_POINTER_CONVERT(block_ptr);
 8011c54:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8011c56:	62fb      	str	r3, [r7, #44]	; 0x2c
    *block_indirect_ptr =  temp_ptr;
 8011c58:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8011c5a:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 8011c5c:	601a      	str	r2, [r3, #0]

    block_ptr =            TX_UCHAR_POINTER_SUB(block_ptr, (sizeof(UCHAR *)));
 8011c5e:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8011c60:	3b04      	subs	r3, #4
 8011c62:	637b      	str	r3, [r7, #52]	; 0x34
    block_indirect_ptr =   TX_UCHAR_TO_INDIRECT_UCHAR_POINTER_CONVERT(block_ptr);
 8011c64:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8011c66:	62fb      	str	r3, [r7, #44]	; 0x2c
    *block_indirect_ptr =  TX_VOID_TO_UCHAR_POINTER_CONVERT(pool_start);
 8011c68:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8011c6a:	687a      	ldr	r2, [r7, #4]
 8011c6c:	601a      	str	r2, [r3, #0]

    /* Now setup the large available block in the pool.  */
    temp_ptr =             TX_VOID_TO_UCHAR_POINTER_CONVERT(pool_start);
 8011c6e:	687b      	ldr	r3, [r7, #4]
 8011c70:	633b      	str	r3, [r7, #48]	; 0x30
    block_indirect_ptr =   TX_UCHAR_TO_INDIRECT_UCHAR_POINTER_CONVERT(temp_ptr);
 8011c72:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8011c74:	62fb      	str	r3, [r7, #44]	; 0x2c
    *block_indirect_ptr =  block_ptr;
 8011c76:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8011c78:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 8011c7a:	601a      	str	r2, [r3, #0]
    block_ptr =            TX_VOID_TO_UCHAR_POINTER_CONVERT(pool_start);
 8011c7c:	687b      	ldr	r3, [r7, #4]
 8011c7e:	637b      	str	r3, [r7, #52]	; 0x34
    block_ptr =            TX_UCHAR_POINTER_ADD(block_ptr, (sizeof(UCHAR *)));
 8011c80:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8011c82:	3304      	adds	r3, #4
 8011c84:	637b      	str	r3, [r7, #52]	; 0x34
    free_ptr =             TX_UCHAR_TO_ALIGN_TYPE_POINTER_CONVERT(block_ptr);
 8011c86:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8011c88:	62bb      	str	r3, [r7, #40]	; 0x28
    *free_ptr =            TX_BYTE_BLOCK_FREE;
 8011c8a:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8011c8c:	4a1f      	ldr	r2, [pc, #124]	; (8011d0c <_tx_byte_pool_create+0x11c>)
 8011c8e:	601a      	str	r2, [r3, #0]

    /* Clear the owner id.  */
    pool_ptr -> tx_byte_pool_owner =  TX_NULL;
 8011c90:	68fb      	ldr	r3, [r7, #12]
 8011c92:	2200      	movs	r2, #0
 8011c94:	621a      	str	r2, [r3, #32]
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 8011c96:	f3ef 8310 	mrs	r3, PRIMASK
 8011c9a:	61bb      	str	r3, [r7, #24]
    return(posture);
 8011c9c:	69bb      	ldr	r3, [r7, #24]
    int_posture = __get_interrupt_posture();
 8011c9e:	617b      	str	r3, [r7, #20]
    __asm__ volatile ("CPSID i" : : : "memory");
 8011ca0:	b672      	cpsid	i
    return(int_posture);
 8011ca2:	697b      	ldr	r3, [r7, #20]

    /* Disable interrupts to place the byte pool on the created list.  */
    TX_DISABLE
 8011ca4:	627b      	str	r3, [r7, #36]	; 0x24

    /* Setup the byte pool ID to make it valid.  */
    pool_ptr -> tx_byte_pool_id =  TX_BYTE_POOL_ID;
 8011ca6:	68fb      	ldr	r3, [r7, #12]
 8011ca8:	4a19      	ldr	r2, [pc, #100]	; (8011d10 <_tx_byte_pool_create+0x120>)
 8011caa:	601a      	str	r2, [r3, #0]

    /* Place the byte pool on the list of created byte pools.  First,
       check for an empty list.  */
    if (_tx_byte_pool_created_count == TX_EMPTY)
 8011cac:	4b19      	ldr	r3, [pc, #100]	; (8011d14 <_tx_byte_pool_create+0x124>)
 8011cae:	681b      	ldr	r3, [r3, #0]
 8011cb0:	2b00      	cmp	r3, #0
 8011cb2:	d109      	bne.n	8011cc8 <_tx_byte_pool_create+0xd8>
    {

        /* The created byte pool list is empty.  Add byte pool to empty list.  */
        _tx_byte_pool_created_ptr =                  pool_ptr;
 8011cb4:	4a18      	ldr	r2, [pc, #96]	; (8011d18 <_tx_byte_pool_create+0x128>)
 8011cb6:	68fb      	ldr	r3, [r7, #12]
 8011cb8:	6013      	str	r3, [r2, #0]
        pool_ptr -> tx_byte_pool_created_next =      pool_ptr;
 8011cba:	68fb      	ldr	r3, [r7, #12]
 8011cbc:	68fa      	ldr	r2, [r7, #12]
 8011cbe:	62da      	str	r2, [r3, #44]	; 0x2c
        pool_ptr -> tx_byte_pool_created_previous =  pool_ptr;
 8011cc0:	68fb      	ldr	r3, [r7, #12]
 8011cc2:	68fa      	ldr	r2, [r7, #12]
 8011cc4:	631a      	str	r2, [r3, #48]	; 0x30
 8011cc6:	e011      	b.n	8011cec <_tx_byte_pool_create+0xfc>
    }
    else
    {

        /* This list is not NULL, add to the end of the list.  */
        next_pool =      _tx_byte_pool_created_ptr;
 8011cc8:	4b13      	ldr	r3, [pc, #76]	; (8011d18 <_tx_byte_pool_create+0x128>)
 8011cca:	681b      	ldr	r3, [r3, #0]
 8011ccc:	623b      	str	r3, [r7, #32]
        previous_pool =  next_pool -> tx_byte_pool_created_previous;
 8011cce:	6a3b      	ldr	r3, [r7, #32]
 8011cd0:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8011cd2:	61fb      	str	r3, [r7, #28]

        /* Place the new byte pool in the list.  */
        next_pool -> tx_byte_pool_created_previous =  pool_ptr;
 8011cd4:	6a3b      	ldr	r3, [r7, #32]
 8011cd6:	68fa      	ldr	r2, [r7, #12]
 8011cd8:	631a      	str	r2, [r3, #48]	; 0x30
        previous_pool -> tx_byte_pool_created_next =  pool_ptr;
 8011cda:	69fb      	ldr	r3, [r7, #28]
 8011cdc:	68fa      	ldr	r2, [r7, #12]
 8011cde:	62da      	str	r2, [r3, #44]	; 0x2c

        /* Setup this byte pool's created links.  */
        pool_ptr -> tx_byte_pool_created_previous =  previous_pool;
 8011ce0:	68fb      	ldr	r3, [r7, #12]
 8011ce2:	69fa      	ldr	r2, [r7, #28]
 8011ce4:	631a      	str	r2, [r3, #48]	; 0x30
        pool_ptr -> tx_byte_pool_created_next =      next_pool;
 8011ce6:	68fb      	ldr	r3, [r7, #12]
 8011ce8:	6a3a      	ldr	r2, [r7, #32]
 8011cea:	62da      	str	r2, [r3, #44]	; 0x2c
    }

    /* Increment the number of created byte pools.  */
    _tx_byte_pool_created_count++;
 8011cec:	4b09      	ldr	r3, [pc, #36]	; (8011d14 <_tx_byte_pool_create+0x124>)
 8011cee:	681b      	ldr	r3, [r3, #0]
 8011cf0:	3301      	adds	r3, #1
 8011cf2:	4a08      	ldr	r2, [pc, #32]	; (8011d14 <_tx_byte_pool_create+0x124>)
 8011cf4:	6013      	str	r3, [r2, #0]
 8011cf6:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8011cf8:	613b      	str	r3, [r7, #16]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 8011cfa:	693b      	ldr	r3, [r7, #16]
 8011cfc:	f383 8810 	msr	PRIMASK, r3
}
 8011d00:	bf00      	nop

    /* Restore interrupts.  */
    TX_RESTORE

    /* Return TX_SUCCESS.  */
    return(TX_SUCCESS);
 8011d02:	2300      	movs	r3, #0
}
 8011d04:	4618      	mov	r0, r3
 8011d06:	3738      	adds	r7, #56	; 0x38
 8011d08:	46bd      	mov	sp, r7
 8011d0a:	bd80      	pop	{r7, pc}
 8011d0c:	ffffeeee 	.word	0xffffeeee
 8011d10:	42595445 	.word	0x42595445
 8011d14:	24031bb8 	.word	0x24031bb8
 8011d18:	24031bb4 	.word	0x24031bb4

08011d1c <_tx_byte_pool_search>:
/*                                            calculation,                */
/*                                            resulting in version 6.1.7  */
/*                                                                        */
/**************************************************************************/
UCHAR  *_tx_byte_pool_search(TX_BYTE_POOL *pool_ptr, ULONG memory_size)
{
 8011d1c:	b480      	push	{r7}
 8011d1e:	b097      	sub	sp, #92	; 0x5c
 8011d20:	af00      	add	r7, sp, #0
 8011d22:	6078      	str	r0, [r7, #4]
 8011d24:	6039      	str	r1, [r7, #0]
UCHAR           *next_ptr;
UCHAR           **this_block_link_ptr;
UCHAR           **next_block_link_ptr;
ULONG           available_bytes;
UINT            examine_blocks;
UINT            first_free_block_found =  TX_FALSE;
 8011d26:	2300      	movs	r3, #0
 8011d28:	647b      	str	r3, [r7, #68]	; 0x44
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 8011d2a:	f3ef 8310 	mrs	r3, PRIMASK
 8011d2e:	627b      	str	r3, [r7, #36]	; 0x24
    return(posture);
 8011d30:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    int_posture = __get_interrupt_posture();
 8011d32:	623b      	str	r3, [r7, #32]
    __asm__ volatile ("CPSID i" : : : "memory");
 8011d34:	b672      	cpsid	i
    return(int_posture);
 8011d36:	6a3b      	ldr	r3, [r7, #32]
UCHAR           *work_ptr;
ULONG           total_theoretical_available;


    /* Disable interrupts.  */
    TX_DISABLE
 8011d38:	657b      	str	r3, [r7, #84]	; 0x54

    /* First, determine if there are enough bytes in the pool.  */
    /* Theoretical bytes available = free bytes + ((fragments-2) * overhead of each block) */
    total_theoretical_available = pool_ptr -> tx_byte_pool_available + ((pool_ptr -> tx_byte_pool_fragments - 2) * ((sizeof(UCHAR *)) + (sizeof(ALIGN_TYPE))));
 8011d3a:	687b      	ldr	r3, [r7, #4]
 8011d3c:	689a      	ldr	r2, [r3, #8]
 8011d3e:	687b      	ldr	r3, [r7, #4]
 8011d40:	68db      	ldr	r3, [r3, #12]
 8011d42:	3b02      	subs	r3, #2
 8011d44:	00db      	lsls	r3, r3, #3
 8011d46:	4413      	add	r3, r2
 8011d48:	643b      	str	r3, [r7, #64]	; 0x40
    if (memory_size >= total_theoretical_available)
 8011d4a:	683a      	ldr	r2, [r7, #0]
 8011d4c:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8011d4e:	429a      	cmp	r2, r3
 8011d50:	d308      	bcc.n	8011d64 <_tx_byte_pool_search+0x48>
 8011d52:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 8011d54:	61fb      	str	r3, [r7, #28]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 8011d56:	69fb      	ldr	r3, [r7, #28]
 8011d58:	f383 8810 	msr	PRIMASK, r3
}
 8011d5c:	bf00      	nop

        /* Restore interrupts.  */
        TX_RESTORE

        /* Not enough memory, return a NULL pointer.  */
        current_ptr =  TX_NULL;
 8011d5e:	2300      	movs	r3, #0
 8011d60:	653b      	str	r3, [r7, #80]	; 0x50
 8011d62:	e0dd      	b.n	8011f20 <_tx_byte_pool_search+0x204>
    }
    else
    {

        /* Pickup thread pointer.  */
        TX_THREAD_GET_CURRENT(thread_ptr)
 8011d64:	4b72      	ldr	r3, [pc, #456]	; (8011f30 <_tx_byte_pool_search+0x214>)
 8011d66:	681b      	ldr	r3, [r3, #0]
 8011d68:	63fb      	str	r3, [r7, #60]	; 0x3c

        /* Setup ownership of the byte pool.  */
        pool_ptr -> tx_byte_pool_owner =  thread_ptr;
 8011d6a:	687b      	ldr	r3, [r7, #4]
 8011d6c:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 8011d6e:	621a      	str	r2, [r3, #32]

        /* Walk through the memory pool in search for a large enough block.  */
        current_ptr =      pool_ptr -> tx_byte_pool_search;
 8011d70:	687b      	ldr	r3, [r7, #4]
 8011d72:	695b      	ldr	r3, [r3, #20]
 8011d74:	653b      	str	r3, [r7, #80]	; 0x50
        examine_blocks =   pool_ptr -> tx_byte_pool_fragments + ((UINT) 1);
 8011d76:	687b      	ldr	r3, [r7, #4]
 8011d78:	68db      	ldr	r3, [r3, #12]
 8011d7a:	3301      	adds	r3, #1
 8011d7c:	64bb      	str	r3, [r7, #72]	; 0x48
        available_bytes =  ((ULONG) 0);
 8011d7e:	2300      	movs	r3, #0
 8011d80:	64fb      	str	r3, [r7, #76]	; 0x4c
            /* Increment the number of fragments searched on this pool.  */
            pool_ptr -> tx_byte_pool_performance_search_count++;
#endif

            /* Check to see if this block is free.  */
            work_ptr =  TX_UCHAR_POINTER_ADD(current_ptr, (sizeof(UCHAR *)));
 8011d82:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 8011d84:	3304      	adds	r3, #4
 8011d86:	63bb      	str	r3, [r7, #56]	; 0x38
            free_ptr =  TX_UCHAR_TO_ALIGN_TYPE_POINTER_CONVERT(work_ptr);
 8011d88:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8011d8a:	637b      	str	r3, [r7, #52]	; 0x34
            if ((*free_ptr) == TX_BYTE_BLOCK_FREE)
 8011d8c:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8011d8e:	681b      	ldr	r3, [r3, #0]
 8011d90:	4a68      	ldr	r2, [pc, #416]	; (8011f34 <_tx_byte_pool_search+0x218>)
 8011d92:	4293      	cmp	r3, r2
 8011d94:	d143      	bne.n	8011e1e <_tx_byte_pool_search+0x102>
            {

                /* Determine if this is the first free block.  */
                if (first_free_block_found == TX_FALSE)
 8011d96:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8011d98:	2b00      	cmp	r3, #0
 8011d9a:	d104      	bne.n	8011da6 <_tx_byte_pool_search+0x8a>
                {
                    /* This is the first free block.  */
                    pool_ptr->tx_byte_pool_search =  current_ptr;
 8011d9c:	687b      	ldr	r3, [r7, #4]
 8011d9e:	6d3a      	ldr	r2, [r7, #80]	; 0x50
 8011da0:	615a      	str	r2, [r3, #20]

                    /* Set the flag to indicate we have found the first free
                       block.  */
                    first_free_block_found =  TX_TRUE;
 8011da2:	2301      	movs	r3, #1
 8011da4:	647b      	str	r3, [r7, #68]	; 0x44
                }

                /* Block is free, see if it is large enough.  */

                /* Pickup the next block's pointer.  */
                this_block_link_ptr =  TX_UCHAR_TO_INDIRECT_UCHAR_POINTER_CONVERT(current_ptr);
 8011da6:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 8011da8:	633b      	str	r3, [r7, #48]	; 0x30
                next_ptr =             *this_block_link_ptr;
 8011daa:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8011dac:	681b      	ldr	r3, [r3, #0]
 8011dae:	62fb      	str	r3, [r7, #44]	; 0x2c

                /* Calculate the number of bytes available in this block.  */
                available_bytes =   TX_UCHAR_POINTER_DIF(next_ptr, current_ptr);
 8011db0:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 8011db2:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 8011db4:	1ad3      	subs	r3, r2, r3
 8011db6:	64fb      	str	r3, [r7, #76]	; 0x4c
                available_bytes =   available_bytes - ((sizeof(UCHAR *)) + (sizeof(ALIGN_TYPE)));
 8011db8:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8011dba:	3b08      	subs	r3, #8
 8011dbc:	64fb      	str	r3, [r7, #76]	; 0x4c

                /* If this is large enough, we are done because our first-fit algorithm
                   has been satisfied!  */
                if (available_bytes >= memory_size)
 8011dbe:	6cfa      	ldr	r2, [r7, #76]	; 0x4c
 8011dc0:	683b      	ldr	r3, [r7, #0]
 8011dc2:	429a      	cmp	r2, r3
 8011dc4:	d257      	bcs.n	8011e76 <_tx_byte_pool_search+0x15a>
                }
                else
                {

                    /* Clear the available bytes variable.  */
                    available_bytes =  ((ULONG) 0);
 8011dc6:	2300      	movs	r3, #0
 8011dc8:	64fb      	str	r3, [r7, #76]	; 0x4c

                    /* Not enough memory, check to see if the neighbor is
                       free and can be merged.  */
                    work_ptr =  TX_UCHAR_POINTER_ADD(next_ptr, (sizeof(UCHAR *)));
 8011dca:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8011dcc:	3304      	adds	r3, #4
 8011dce:	63bb      	str	r3, [r7, #56]	; 0x38
                    free_ptr =  TX_UCHAR_TO_ALIGN_TYPE_POINTER_CONVERT(work_ptr);
 8011dd0:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8011dd2:	637b      	str	r3, [r7, #52]	; 0x34
                    if ((*free_ptr) == TX_BYTE_BLOCK_FREE)
 8011dd4:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8011dd6:	681b      	ldr	r3, [r3, #0]
 8011dd8:	4a56      	ldr	r2, [pc, #344]	; (8011f34 <_tx_byte_pool_search+0x218>)
 8011dda:	4293      	cmp	r3, r2
 8011ddc:	d113      	bne.n	8011e06 <_tx_byte_pool_search+0xea>
                    {

                        /* Yes, neighbor block can be merged!  This is quickly accomplished
                           by updating the current block with the next blocks pointer.  */
                        next_block_link_ptr =  TX_UCHAR_TO_INDIRECT_UCHAR_POINTER_CONVERT(next_ptr);
 8011dde:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8011de0:	62bb      	str	r3, [r7, #40]	; 0x28
                        *this_block_link_ptr =  *next_block_link_ptr;
 8011de2:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8011de4:	681a      	ldr	r2, [r3, #0]
 8011de6:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8011de8:	601a      	str	r2, [r3, #0]

                        /* Reduce the fragment total.  We don't need to increase the bytes
                           available because all free headers are also included in the available
                           count.  */
                        pool_ptr -> tx_byte_pool_fragments--;
 8011dea:	687b      	ldr	r3, [r7, #4]
 8011dec:	68db      	ldr	r3, [r3, #12]
 8011dee:	1e5a      	subs	r2, r3, #1
 8011df0:	687b      	ldr	r3, [r7, #4]
 8011df2:	60da      	str	r2, [r3, #12]
                        /* Increment the number of blocks merged on this pool.  */
                        pool_ptr -> tx_byte_pool_performance_merge_count++;
#endif

                        /* See if the search pointer is affected.  */
                        if (pool_ptr -> tx_byte_pool_search ==  next_ptr)
 8011df4:	687b      	ldr	r3, [r7, #4]
 8011df6:	695b      	ldr	r3, [r3, #20]
 8011df8:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 8011dfa:	429a      	cmp	r2, r3
 8011dfc:	d114      	bne.n	8011e28 <_tx_byte_pool_search+0x10c>
                        {
                            /* Yes, update the search pointer.   */
                            pool_ptr -> tx_byte_pool_search =  current_ptr;
 8011dfe:	687b      	ldr	r3, [r7, #4]
 8011e00:	6d3a      	ldr	r2, [r7, #80]	; 0x50
 8011e02:	615a      	str	r2, [r3, #20]
 8011e04:	e010      	b.n	8011e28 <_tx_byte_pool_search+0x10c>
                        }
                    }
                    else
                    {
                        /* Neighbor is not free so we can skip over it!  */
                        next_block_link_ptr =  TX_UCHAR_TO_INDIRECT_UCHAR_POINTER_CONVERT(next_ptr);
 8011e06:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8011e08:	62bb      	str	r3, [r7, #40]	; 0x28
                        current_ptr =  *next_block_link_ptr;
 8011e0a:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8011e0c:	681b      	ldr	r3, [r3, #0]
 8011e0e:	653b      	str	r3, [r7, #80]	; 0x50

                        /* Decrement the examined block count to account for this one.  */
                        if (examine_blocks != ((UINT) 0))
 8011e10:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 8011e12:	2b00      	cmp	r3, #0
 8011e14:	d008      	beq.n	8011e28 <_tx_byte_pool_search+0x10c>
                        {
                            examine_blocks--;
 8011e16:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 8011e18:	3b01      	subs	r3, #1
 8011e1a:	64bb      	str	r3, [r7, #72]	; 0x48
 8011e1c:	e004      	b.n	8011e28 <_tx_byte_pool_search+0x10c>
            }
            else
            {

                /* Block is not free, move to next block.  */
                this_block_link_ptr =  TX_UCHAR_TO_INDIRECT_UCHAR_POINTER_CONVERT(current_ptr);
 8011e1e:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 8011e20:	633b      	str	r3, [r7, #48]	; 0x30
                current_ptr =  *this_block_link_ptr;
 8011e22:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8011e24:	681b      	ldr	r3, [r3, #0]
 8011e26:	653b      	str	r3, [r7, #80]	; 0x50
            }

            /* Another block has been searched... decrement counter.  */
            if (examine_blocks != ((UINT) 0))
 8011e28:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 8011e2a:	2b00      	cmp	r3, #0
 8011e2c:	d002      	beq.n	8011e34 <_tx_byte_pool_search+0x118>
            {

                examine_blocks--;
 8011e2e:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 8011e30:	3b01      	subs	r3, #1
 8011e32:	64bb      	str	r3, [r7, #72]	; 0x48
 8011e34:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 8011e36:	613b      	str	r3, [r7, #16]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 8011e38:	693b      	ldr	r3, [r7, #16]
 8011e3a:	f383 8810 	msr	PRIMASK, r3
}
 8011e3e:	bf00      	nop
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 8011e40:	f3ef 8310 	mrs	r3, PRIMASK
 8011e44:	61bb      	str	r3, [r7, #24]
    return(posture);
 8011e46:	69bb      	ldr	r3, [r7, #24]
    int_posture = __get_interrupt_posture();
 8011e48:	617b      	str	r3, [r7, #20]
    __asm__ volatile ("CPSID i" : : : "memory");
 8011e4a:	b672      	cpsid	i
    return(int_posture);
 8011e4c:	697b      	ldr	r3, [r7, #20]

            /* Restore interrupts temporarily.  */
            TX_RESTORE

            /* Disable interrupts.  */
            TX_DISABLE
 8011e4e:	657b      	str	r3, [r7, #84]	; 0x54

            /* Determine if anything has changed in terms of pool ownership.  */
            if (pool_ptr -> tx_byte_pool_owner != thread_ptr)
 8011e50:	687b      	ldr	r3, [r7, #4]
 8011e52:	6a1b      	ldr	r3, [r3, #32]
 8011e54:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 8011e56:	429a      	cmp	r2, r3
 8011e58:	d009      	beq.n	8011e6e <_tx_byte_pool_search+0x152>
            {

                /* Pool changed ownership in the brief period interrupts were
                   enabled.  Reset the search.  */
                current_ptr =      pool_ptr -> tx_byte_pool_search;
 8011e5a:	687b      	ldr	r3, [r7, #4]
 8011e5c:	695b      	ldr	r3, [r3, #20]
 8011e5e:	653b      	str	r3, [r7, #80]	; 0x50
                examine_blocks =   pool_ptr -> tx_byte_pool_fragments + ((UINT) 1);
 8011e60:	687b      	ldr	r3, [r7, #4]
 8011e62:	68db      	ldr	r3, [r3, #12]
 8011e64:	3301      	adds	r3, #1
 8011e66:	64bb      	str	r3, [r7, #72]	; 0x48

                /* Setup our ownership again.  */
                pool_ptr -> tx_byte_pool_owner =  thread_ptr;
 8011e68:	687b      	ldr	r3, [r7, #4]
 8011e6a:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 8011e6c:	621a      	str	r2, [r3, #32]
            }
        } while(examine_blocks != ((UINT) 0));
 8011e6e:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 8011e70:	2b00      	cmp	r3, #0
 8011e72:	d186      	bne.n	8011d82 <_tx_byte_pool_search+0x66>
 8011e74:	e000      	b.n	8011e78 <_tx_byte_pool_search+0x15c>
                    break;
 8011e76:	bf00      	nop

        /* Determine if a block was found.  If so, determine if it needs to be
           split.  */
        if (available_bytes != ((ULONG) 0))
 8011e78:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8011e7a:	2b00      	cmp	r3, #0
 8011e7c:	d048      	beq.n	8011f10 <_tx_byte_pool_search+0x1f4>
        {

            /* Determine if we need to split this block.  */
            if ((available_bytes - memory_size) >= ((ULONG) TX_BYTE_BLOCK_MIN))
 8011e7e:	6cfa      	ldr	r2, [r7, #76]	; 0x4c
 8011e80:	683b      	ldr	r3, [r7, #0]
 8011e82:	1ad3      	subs	r3, r2, r3
 8011e84:	2b13      	cmp	r3, #19
 8011e86:	d91e      	bls.n	8011ec6 <_tx_byte_pool_search+0x1aa>
            {

                /* Split the block.  */
                next_ptr =  TX_UCHAR_POINTER_ADD(current_ptr, (memory_size + ((sizeof(UCHAR *)) + (sizeof(ALIGN_TYPE)))));
 8011e88:	683b      	ldr	r3, [r7, #0]
 8011e8a:	3308      	adds	r3, #8
 8011e8c:	6d3a      	ldr	r2, [r7, #80]	; 0x50
 8011e8e:	4413      	add	r3, r2
 8011e90:	62fb      	str	r3, [r7, #44]	; 0x2c

                /* Setup the new free block.  */
                next_block_link_ptr =   TX_UCHAR_TO_INDIRECT_UCHAR_POINTER_CONVERT(next_ptr);
 8011e92:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8011e94:	62bb      	str	r3, [r7, #40]	; 0x28
                this_block_link_ptr =   TX_UCHAR_TO_INDIRECT_UCHAR_POINTER_CONVERT(current_ptr);
 8011e96:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 8011e98:	633b      	str	r3, [r7, #48]	; 0x30
                *next_block_link_ptr =  *this_block_link_ptr;
 8011e9a:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8011e9c:	681a      	ldr	r2, [r3, #0]
 8011e9e:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8011ea0:	601a      	str	r2, [r3, #0]
                work_ptr =              TX_UCHAR_POINTER_ADD(next_ptr, (sizeof(UCHAR *)));
 8011ea2:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8011ea4:	3304      	adds	r3, #4
 8011ea6:	63bb      	str	r3, [r7, #56]	; 0x38
                free_ptr =              TX_UCHAR_TO_ALIGN_TYPE_POINTER_CONVERT(work_ptr);
 8011ea8:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8011eaa:	637b      	str	r3, [r7, #52]	; 0x34
                *free_ptr =             TX_BYTE_BLOCK_FREE;
 8011eac:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8011eae:	4a21      	ldr	r2, [pc, #132]	; (8011f34 <_tx_byte_pool_search+0x218>)
 8011eb0:	601a      	str	r2, [r3, #0]

                /* Increase the total fragment counter.  */
                pool_ptr -> tx_byte_pool_fragments++;
 8011eb2:	687b      	ldr	r3, [r7, #4]
 8011eb4:	68db      	ldr	r3, [r3, #12]
 8011eb6:	1c5a      	adds	r2, r3, #1
 8011eb8:	687b      	ldr	r3, [r7, #4]
 8011eba:	60da      	str	r2, [r3, #12]

                /* Update the current pointer to point at the newly created block.  */
                *this_block_link_ptr =  next_ptr;
 8011ebc:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8011ebe:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 8011ec0:	601a      	str	r2, [r3, #0]

                /* Set available equal to memory size for subsequent calculation.  */
                available_bytes =  memory_size;
 8011ec2:	683b      	ldr	r3, [r7, #0]
 8011ec4:	64fb      	str	r3, [r7, #76]	; 0x4c
                pool_ptr -> tx_byte_pool_performance_split_count++;
#endif
            }

            /* In any case, mark the current block as allocated.  */
            work_ptr =              TX_UCHAR_POINTER_ADD(current_ptr, (sizeof(UCHAR *)));
 8011ec6:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 8011ec8:	3304      	adds	r3, #4
 8011eca:	63bb      	str	r3, [r7, #56]	; 0x38
            this_block_link_ptr =   TX_UCHAR_TO_INDIRECT_UCHAR_POINTER_CONVERT(work_ptr);
 8011ecc:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8011ece:	633b      	str	r3, [r7, #48]	; 0x30
            *this_block_link_ptr =  TX_BYTE_POOL_TO_UCHAR_POINTER_CONVERT(pool_ptr);
 8011ed0:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8011ed2:	687a      	ldr	r2, [r7, #4]
 8011ed4:	601a      	str	r2, [r3, #0]

            /* Reduce the number of available bytes in the pool.  */
            pool_ptr -> tx_byte_pool_available =  (pool_ptr -> tx_byte_pool_available - available_bytes) - ((sizeof(UCHAR *)) + (sizeof(ALIGN_TYPE)));
 8011ed6:	687b      	ldr	r3, [r7, #4]
 8011ed8:	689a      	ldr	r2, [r3, #8]
 8011eda:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8011edc:	1ad3      	subs	r3, r2, r3
 8011ede:	f1a3 0208 	sub.w	r2, r3, #8
 8011ee2:	687b      	ldr	r3, [r7, #4]
 8011ee4:	609a      	str	r2, [r3, #8]

            /* Determine if the search pointer needs to be updated. This is only done
               if the search pointer matches the block to be returned.  */
            if (current_ptr == pool_ptr -> tx_byte_pool_search)
 8011ee6:	687b      	ldr	r3, [r7, #4]
 8011ee8:	695b      	ldr	r3, [r3, #20]
 8011eea:	6d3a      	ldr	r2, [r7, #80]	; 0x50
 8011eec:	429a      	cmp	r2, r3
 8011eee:	d105      	bne.n	8011efc <_tx_byte_pool_search+0x1e0>
            {

                /* Yes, update the search pointer to the next block.  */
                this_block_link_ptr =   TX_UCHAR_TO_INDIRECT_UCHAR_POINTER_CONVERT(current_ptr);
 8011ef0:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 8011ef2:	633b      	str	r3, [r7, #48]	; 0x30
                pool_ptr -> tx_byte_pool_search =  *this_block_link_ptr;
 8011ef4:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8011ef6:	681a      	ldr	r2, [r3, #0]
 8011ef8:	687b      	ldr	r3, [r7, #4]
 8011efa:	615a      	str	r2, [r3, #20]
 8011efc:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 8011efe:	60fb      	str	r3, [r7, #12]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 8011f00:	68fb      	ldr	r3, [r7, #12]
 8011f02:	f383 8810 	msr	PRIMASK, r3
}
 8011f06:	bf00      	nop

            /* Restore interrupts.  */
            TX_RESTORE

            /* Adjust the pointer for the application.  */
            current_ptr =  TX_UCHAR_POINTER_ADD(current_ptr, (((sizeof(UCHAR *)) + (sizeof(ALIGN_TYPE)))));
 8011f08:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 8011f0a:	3308      	adds	r3, #8
 8011f0c:	653b      	str	r3, [r7, #80]	; 0x50
 8011f0e:	e007      	b.n	8011f20 <_tx_byte_pool_search+0x204>
 8011f10:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 8011f12:	60bb      	str	r3, [r7, #8]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 8011f14:	68bb      	ldr	r3, [r7, #8]
 8011f16:	f383 8810 	msr	PRIMASK, r3
}
 8011f1a:	bf00      	nop

            /* Restore interrupts.  */
            TX_RESTORE

            /* Set current pointer to NULL to indicate nothing was found.  */
            current_ptr =  TX_NULL;
 8011f1c:	2300      	movs	r3, #0
 8011f1e:	653b      	str	r3, [r7, #80]	; 0x50
        }
    }

    /* Return the search pointer.  */
    return(current_ptr);
 8011f20:	6d3b      	ldr	r3, [r7, #80]	; 0x50
}
 8011f22:	4618      	mov	r0, r3
 8011f24:	375c      	adds	r7, #92	; 0x5c
 8011f26:	46bd      	mov	sp, r7
 8011f28:	f85d 7b04 	ldr.w	r7, [sp], #4
 8011f2c:	4770      	bx	lr
 8011f2e:	bf00      	nop
 8011f30:	24031bc4 	.word	0x24031bc4
 8011f34:	ffffeeee 	.word	0xffffeeee

08011f38 <_tx_byte_release>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
UINT  _tx_byte_release(VOID *memory_ptr)
{
 8011f38:	b580      	push	{r7, lr}
 8011f3a:	b09e      	sub	sp, #120	; 0x78
 8011f3c:	af00      	add	r7, sp, #0
 8011f3e:	6078      	str	r0, [r7, #4]
UCHAR               **block_link_ptr;
UCHAR               **suspend_info_ptr;


    /* Default to successful status.  */
    status =  TX_SUCCESS;
 8011f40:	2300      	movs	r3, #0
 8011f42:	673b      	str	r3, [r7, #112]	; 0x70
    
    /* Set the pool pointer to NULL.  */
    pool_ptr =  TX_NULL;
 8011f44:	2300      	movs	r3, #0
 8011f46:	66fb      	str	r3, [r7, #108]	; 0x6c
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 8011f48:	f3ef 8310 	mrs	r3, PRIMASK
 8011f4c:	637b      	str	r3, [r7, #52]	; 0x34
    return(posture);
 8011f4e:	6b7b      	ldr	r3, [r7, #52]	; 0x34
    int_posture = __get_interrupt_posture();
 8011f50:	633b      	str	r3, [r7, #48]	; 0x30
    __asm__ volatile ("CPSID i" : : : "memory");
 8011f52:	b672      	cpsid	i
    return(int_posture);
 8011f54:	6b3b      	ldr	r3, [r7, #48]	; 0x30

    /* Lockout interrupts.  */
    TX_DISABLE
 8011f56:	677b      	str	r3, [r7, #116]	; 0x74

    /* Determine if the memory pointer is valid.  */
    work_ptr =  TX_VOID_TO_UCHAR_POINTER_CONVERT(memory_ptr);
 8011f58:	687b      	ldr	r3, [r7, #4]
 8011f5a:	66bb      	str	r3, [r7, #104]	; 0x68
    if (work_ptr != TX_NULL)
 8011f5c:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 8011f5e:	2b00      	cmp	r3, #0
 8011f60:	d027      	beq.n	8011fb2 <_tx_byte_release+0x7a>
    {
        
        /* Back off the memory pointer to pickup its header.  */
        work_ptr =  TX_UCHAR_POINTER_SUB(work_ptr, ((sizeof(UCHAR *)) + (sizeof(ALIGN_TYPE))));
 8011f62:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 8011f64:	3b08      	subs	r3, #8
 8011f66:	66bb      	str	r3, [r7, #104]	; 0x68

        /* There is a pointer, pickup the pool pointer address.  */
        temp_ptr =  TX_UCHAR_POINTER_ADD(work_ptr, (sizeof(UCHAR *)));
 8011f68:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 8011f6a:	3304      	adds	r3, #4
 8011f6c:	667b      	str	r3, [r7, #100]	; 0x64
        free_ptr =  TX_UCHAR_TO_ALIGN_TYPE_POINTER_CONVERT(temp_ptr);
 8011f6e:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 8011f70:	663b      	str	r3, [r7, #96]	; 0x60
        if ((*free_ptr) != TX_BYTE_BLOCK_FREE)
 8011f72:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 8011f74:	681b      	ldr	r3, [r3, #0]
 8011f76:	4a7e      	ldr	r2, [pc, #504]	; (8012170 <_tx_byte_release+0x238>)
 8011f78:	4293      	cmp	r3, r2
 8011f7a:	d017      	beq.n	8011fac <_tx_byte_release+0x74>
        {

            /* Pickup the pool pointer.  */
            temp_ptr =  TX_UCHAR_POINTER_ADD(work_ptr, (sizeof(UCHAR *)));
 8011f7c:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 8011f7e:	3304      	adds	r3, #4
 8011f80:	667b      	str	r3, [r7, #100]	; 0x64
            byte_pool_ptr =  TX_UCHAR_TO_INDIRECT_BYTE_POOL_POINTER(temp_ptr);
 8011f82:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 8011f84:	65fb      	str	r3, [r7, #92]	; 0x5c
            pool_ptr =  *byte_pool_ptr;
 8011f86:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 8011f88:	681b      	ldr	r3, [r3, #0]
 8011f8a:	66fb      	str	r3, [r7, #108]	; 0x6c

            /* See if we have a valid pool pointer.  */
            if (pool_ptr == TX_NULL)
 8011f8c:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 8011f8e:	2b00      	cmp	r3, #0
 8011f90:	d102      	bne.n	8011f98 <_tx_byte_release+0x60>
            {
                
                /* Return pointer error.  */
                status =  TX_PTR_ERROR;
 8011f92:	2303      	movs	r3, #3
 8011f94:	673b      	str	r3, [r7, #112]	; 0x70
 8011f96:	e00e      	b.n	8011fb6 <_tx_byte_release+0x7e>
            }
            else
            {

                /* See if we have a valid pool.  */
                if (pool_ptr -> tx_byte_pool_id != TX_BYTE_POOL_ID)
 8011f98:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 8011f9a:	681b      	ldr	r3, [r3, #0]
 8011f9c:	4a75      	ldr	r2, [pc, #468]	; (8012174 <_tx_byte_release+0x23c>)
 8011f9e:	4293      	cmp	r3, r2
 8011fa0:	d009      	beq.n	8011fb6 <_tx_byte_release+0x7e>
                {
                
                    /* Return pointer error.  */
                    status =  TX_PTR_ERROR;
 8011fa2:	2303      	movs	r3, #3
 8011fa4:	673b      	str	r3, [r7, #112]	; 0x70
                    
                    /* Reset the pool pointer is NULL.  */
                    pool_ptr =  TX_NULL;
 8011fa6:	2300      	movs	r3, #0
 8011fa8:	66fb      	str	r3, [r7, #108]	; 0x6c
 8011faa:	e004      	b.n	8011fb6 <_tx_byte_release+0x7e>
        }
        else
        {

            /* Return pointer error.  */
            status =  TX_PTR_ERROR;
 8011fac:	2303      	movs	r3, #3
 8011fae:	673b      	str	r3, [r7, #112]	; 0x70
 8011fb0:	e001      	b.n	8011fb6 <_tx_byte_release+0x7e>
    }
    else
    {

        /* Return pointer error.  */
        status =  TX_PTR_ERROR;
 8011fb2:	2303      	movs	r3, #3
 8011fb4:	673b      	str	r3, [r7, #112]	; 0x70
    }

    /* Determine if the pointer is valid.  */
    if (pool_ptr == TX_NULL)
 8011fb6:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 8011fb8:	2b00      	cmp	r3, #0
 8011fba:	d105      	bne.n	8011fc8 <_tx_byte_release+0x90>
 8011fbc:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 8011fbe:	62fb      	str	r3, [r7, #44]	; 0x2c
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 8011fc0:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8011fc2:	f383 8810 	msr	PRIMASK, r3
}
 8011fc6:	e0cd      	b.n	8012164 <_tx_byte_release+0x22c>
    {
    
        /* At this point, we know that the pointer is valid.  */

        /* Pickup thread pointer.  */
        TX_THREAD_GET_CURRENT(thread_ptr)
 8011fc8:	4b6b      	ldr	r3, [pc, #428]	; (8012178 <_tx_byte_release+0x240>)
 8011fca:	681b      	ldr	r3, [r3, #0]
 8011fcc:	65bb      	str	r3, [r7, #88]	; 0x58

        /* Indicate that this thread is the current owner.  */
        pool_ptr -> tx_byte_pool_owner =  thread_ptr;
 8011fce:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 8011fd0:	6dba      	ldr	r2, [r7, #88]	; 0x58
 8011fd2:	621a      	str	r2, [r3, #32]

        /* Log this kernel call.  */
        TX_EL_BYTE_RELEASE_INSERT

        /* Release the memory.  */
        temp_ptr =   TX_UCHAR_POINTER_ADD(work_ptr, (sizeof(UCHAR *)));
 8011fd4:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 8011fd6:	3304      	adds	r3, #4
 8011fd8:	667b      	str	r3, [r7, #100]	; 0x64
        free_ptr =   TX_UCHAR_TO_ALIGN_TYPE_POINTER_CONVERT(temp_ptr);
 8011fda:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 8011fdc:	663b      	str	r3, [r7, #96]	; 0x60
        *free_ptr =  TX_BYTE_BLOCK_FREE;
 8011fde:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 8011fe0:	4a63      	ldr	r2, [pc, #396]	; (8012170 <_tx_byte_release+0x238>)
 8011fe2:	601a      	str	r2, [r3, #0]

        /* Update the number of available bytes in the pool.  */
        block_link_ptr =  TX_UCHAR_TO_INDIRECT_UCHAR_POINTER_CONVERT(work_ptr);
 8011fe4:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 8011fe6:	657b      	str	r3, [r7, #84]	; 0x54
        next_block_ptr =  *block_link_ptr;
 8011fe8:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 8011fea:	681b      	ldr	r3, [r3, #0]
 8011fec:	653b      	str	r3, [r7, #80]	; 0x50
        pool_ptr -> tx_byte_pool_available =  
            pool_ptr -> tx_byte_pool_available + TX_UCHAR_POINTER_DIF(next_block_ptr, work_ptr);
 8011fee:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 8011ff0:	689b      	ldr	r3, [r3, #8]
 8011ff2:	6d39      	ldr	r1, [r7, #80]	; 0x50
 8011ff4:	6eba      	ldr	r2, [r7, #104]	; 0x68
 8011ff6:	1a8a      	subs	r2, r1, r2
 8011ff8:	441a      	add	r2, r3
        pool_ptr -> tx_byte_pool_available =  
 8011ffa:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 8011ffc:	609a      	str	r2, [r3, #8]

        /* Determine if the free block is prior to current search pointer.  */
        if (work_ptr < (pool_ptr -> tx_byte_pool_search))
 8011ffe:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 8012000:	695b      	ldr	r3, [r3, #20]
 8012002:	6eba      	ldr	r2, [r7, #104]	; 0x68
 8012004:	429a      	cmp	r2, r3
 8012006:	d202      	bcs.n	801200e <_tx_byte_release+0xd6>
        {

            /* Yes, update the search pointer to the released block.  */
            pool_ptr -> tx_byte_pool_search =  work_ptr;
 8012008:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 801200a:	6eba      	ldr	r2, [r7, #104]	; 0x68
 801200c:	615a      	str	r2, [r3, #20]
        }

        /* Determine if there are threads suspended on this byte pool.  */
        if (pool_ptr -> tx_byte_pool_suspended_count != TX_NO_SUSPENSIONS)
 801200e:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 8012010:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8012012:	2b00      	cmp	r3, #0
 8012014:	f000 80a0 	beq.w	8012158 <_tx_byte_release+0x220>
        {
                
            /* Now examine the suspension list to find threads waiting for 
               memory.  Maybe it is now available!  */
            while (pool_ptr -> tx_byte_pool_suspended_count != TX_NO_SUSPENSIONS)
 8012018:	e08e      	b.n	8012138 <_tx_byte_release+0x200>
            {

                /* Pickup the first suspended thread pointer.  */
                susp_thread_ptr =  pool_ptr -> tx_byte_pool_suspension_list;
 801201a:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 801201c:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 801201e:	64fb      	str	r3, [r7, #76]	; 0x4c

                /* Pickup the size of the memory the thread is requesting.  */
                memory_size =  susp_thread_ptr -> tx_thread_suspend_info;
 8012020:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8012022:	6f9b      	ldr	r3, [r3, #120]	; 0x78
 8012024:	64bb      	str	r3, [r7, #72]	; 0x48
 8012026:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 8012028:	623b      	str	r3, [r7, #32]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 801202a:	6a3b      	ldr	r3, [r7, #32]
 801202c:	f383 8810 	msr	PRIMASK, r3
}
 8012030:	bf00      	nop

                /* Restore interrupts.  */
                TX_RESTORE

                /* See if the request can be satisfied.  */
                work_ptr =  _tx_byte_pool_search(pool_ptr, memory_size);
 8012032:	6cb9      	ldr	r1, [r7, #72]	; 0x48
 8012034:	6ef8      	ldr	r0, [r7, #108]	; 0x6c
 8012036:	f7ff fe71 	bl	8011d1c <_tx_byte_pool_search>
 801203a:	66b8      	str	r0, [r7, #104]	; 0x68
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 801203c:	f3ef 8310 	mrs	r3, PRIMASK
 8012040:	62bb      	str	r3, [r7, #40]	; 0x28
    return(posture);
 8012042:	6abb      	ldr	r3, [r7, #40]	; 0x28
    int_posture = __get_interrupt_posture();
 8012044:	627b      	str	r3, [r7, #36]	; 0x24
    __asm__ volatile ("CPSID i" : : : "memory");
 8012046:	b672      	cpsid	i
    return(int_posture);
 8012048:	6a7b      	ldr	r3, [r7, #36]	; 0x24

                /* Optional processing extension.  */
                TX_BYTE_RELEASE_EXTENSION

                /* Disable interrupts.  */
                TX_DISABLE
 801204a:	677b      	str	r3, [r7, #116]	; 0x74

                /* Indicate that this thread is the current owner.  */
                pool_ptr -> tx_byte_pool_owner =  thread_ptr;
 801204c:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 801204e:	6dba      	ldr	r2, [r7, #88]	; 0x58
 8012050:	621a      	str	r2, [r3, #32]

                /* If there is not enough memory, break this loop!  */
                if (work_ptr == TX_NULL)
 8012052:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 8012054:	2b00      	cmp	r3, #0
 8012056:	d075      	beq.n	8012144 <_tx_byte_release+0x20c>
                  /* Break out of the loop.  */
                    break;
                }

                /* Check to make sure the thread is still suspended.  */
                if (susp_thread_ptr ==  pool_ptr -> tx_byte_pool_suspension_list)
 8012058:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 801205a:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 801205c:	6cfa      	ldr	r2, [r7, #76]	; 0x4c
 801205e:	429a      	cmp	r2, r3
 8012060:	d147      	bne.n	80120f2 <_tx_byte_release+0x1ba>
                {

                    /* Also, makes sure the memory size is the same.  */
                    if (susp_thread_ptr -> tx_thread_suspend_info == memory_size)
 8012062:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8012064:	6f9b      	ldr	r3, [r3, #120]	; 0x78
 8012066:	6cba      	ldr	r2, [r7, #72]	; 0x48
 8012068:	429a      	cmp	r2, r3
 801206a:	d142      	bne.n	80120f2 <_tx_byte_release+0x1ba>
                    {
                  
                        /* Remove the suspended thread from the list.  */

                        /* Decrement the number of threads suspended.  */
                        pool_ptr -> tx_byte_pool_suspended_count--;
 801206c:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 801206e:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8012070:	1e5a      	subs	r2, r3, #1
 8012072:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 8012074:	629a      	str	r2, [r3, #40]	; 0x28

                        /* Pickup the suspended count.  */
                        suspended_count =  pool_ptr -> tx_byte_pool_suspended_count;
 8012076:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 8012078:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 801207a:	647b      	str	r3, [r7, #68]	; 0x44

                        /* See if this is the only suspended thread on the list.  */
                        if (suspended_count == TX_NO_SUSPENSIONS)
 801207c:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 801207e:	2b00      	cmp	r3, #0
 8012080:	d103      	bne.n	801208a <_tx_byte_release+0x152>
                        {

                            /* Yes, the only suspended thread.  */

                            /* Update the head pointer.  */
                            pool_ptr -> tx_byte_pool_suspension_list =  TX_NULL;
 8012082:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 8012084:	2200      	movs	r2, #0
 8012086:	625a      	str	r2, [r3, #36]	; 0x24
 8012088:	e00e      	b.n	80120a8 <_tx_byte_release+0x170>
                        {

                            /* At least one more thread is on the same expiration list.  */

                            /* Update the list head pointer.  */
                            next_thread =                                susp_thread_ptr -> tx_thread_suspended_next;
 801208a:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 801208c:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 801208e:	643b      	str	r3, [r7, #64]	; 0x40
                            pool_ptr -> tx_byte_pool_suspension_list =   next_thread;
 8012090:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 8012092:	6c3a      	ldr	r2, [r7, #64]	; 0x40
 8012094:	625a      	str	r2, [r3, #36]	; 0x24

                            /* Update the links of the adjacent threads.  */
                            previous_thread =                              susp_thread_ptr -> tx_thread_suspended_previous;
 8012096:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8012098:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 801209a:	63fb      	str	r3, [r7, #60]	; 0x3c
                            next_thread -> tx_thread_suspended_previous =  previous_thread;
 801209c:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 801209e:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 80120a0:	675a      	str	r2, [r3, #116]	; 0x74
                            previous_thread -> tx_thread_suspended_next =  next_thread;
 80120a2:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 80120a4:	6c3a      	ldr	r2, [r7, #64]	; 0x40
 80120a6:	671a      	str	r2, [r3, #112]	; 0x70
                        }

                        /* Prepare for resumption of the thread.  */

                        /* Clear cleanup routine to avoid timeout.  */
                        susp_thread_ptr -> tx_thread_suspend_cleanup =  TX_NULL;
 80120a8:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 80120aa:	2200      	movs	r2, #0
 80120ac:	669a      	str	r2, [r3, #104]	; 0x68

                        /* Return this block pointer to the suspended thread waiting for
                           a block.  */
                        suspend_info_ptr =   TX_VOID_TO_INDIRECT_UCHAR_POINTER_CONVERT(susp_thread_ptr -> tx_thread_additional_suspend_info);
 80120ae:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 80120b0:	6fdb      	ldr	r3, [r3, #124]	; 0x7c
 80120b2:	63bb      	str	r3, [r7, #56]	; 0x38
                        *suspend_info_ptr =  work_ptr;
 80120b4:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 80120b6:	6eba      	ldr	r2, [r7, #104]	; 0x68
 80120b8:	601a      	str	r2, [r3, #0]

                        /* Clear the memory pointer to indicate that it was given to the suspended thread.  */
                        work_ptr =  TX_NULL;
 80120ba:	2300      	movs	r3, #0
 80120bc:	66bb      	str	r3, [r7, #104]	; 0x68
                        
                        /* Put return status into the thread control block.  */
                        susp_thread_ptr -> tx_thread_suspend_status =  TX_SUCCESS;
 80120be:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 80120c0:	2200      	movs	r2, #0
 80120c2:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84

                        /* Restore interrupts.  */
                        TX_RESTORE
#else
                        /* Temporarily disable preemption.  */
                        _tx_thread_preempt_disable++;
 80120c6:	4b2d      	ldr	r3, [pc, #180]	; (801217c <_tx_byte_release+0x244>)
 80120c8:	681b      	ldr	r3, [r3, #0]
 80120ca:	3301      	adds	r3, #1
 80120cc:	4a2b      	ldr	r2, [pc, #172]	; (801217c <_tx_byte_release+0x244>)
 80120ce:	6013      	str	r3, [r2, #0]
 80120d0:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 80120d2:	617b      	str	r3, [r7, #20]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 80120d4:	697b      	ldr	r3, [r7, #20]
 80120d6:	f383 8810 	msr	PRIMASK, r3
}
 80120da:	bf00      	nop

                        /* Restore interrupts.  */
                        TX_RESTORE

                        /* Resume thread.  */
                        _tx_thread_system_resume(susp_thread_ptr);
 80120dc:	6cf8      	ldr	r0, [r7, #76]	; 0x4c
 80120de:	f002 fe23 	bl	8014d28 <_tx_thread_system_resume>
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 80120e2:	f3ef 8310 	mrs	r3, PRIMASK
 80120e6:	61fb      	str	r3, [r7, #28]
    return(posture);
 80120e8:	69fb      	ldr	r3, [r7, #28]
    int_posture = __get_interrupt_posture();
 80120ea:	61bb      	str	r3, [r7, #24]
    __asm__ volatile ("CPSID i" : : : "memory");
 80120ec:	b672      	cpsid	i
    return(int_posture);
 80120ee:	69bb      	ldr	r3, [r7, #24]
#endif

                        /* Lockout interrupts.  */
                        TX_DISABLE
 80120f0:	677b      	str	r3, [r7, #116]	; 0x74
                    }
                }
                    
                /* Determine if the memory was given to the suspended thread.  */
                if (work_ptr != TX_NULL)
 80120f2:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 80120f4:	2b00      	cmp	r3, #0
 80120f6:	d01f      	beq.n	8012138 <_tx_byte_release+0x200>
                
                    /* No, it wasn't given to the suspended thread.  */

                    /* Put the memory back on the available list since this thread is no longer
                       suspended.  */
                    work_ptr =  TX_UCHAR_POINTER_SUB(work_ptr, (((sizeof(UCHAR *)) + (sizeof(ALIGN_TYPE)))));
 80120f8:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 80120fa:	3b08      	subs	r3, #8
 80120fc:	66bb      	str	r3, [r7, #104]	; 0x68
                    temp_ptr =  TX_UCHAR_POINTER_ADD(work_ptr, (sizeof(UCHAR *)));
 80120fe:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 8012100:	3304      	adds	r3, #4
 8012102:	667b      	str	r3, [r7, #100]	; 0x64
                    free_ptr =  TX_UCHAR_TO_ALIGN_TYPE_POINTER_CONVERT(temp_ptr);
 8012104:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 8012106:	663b      	str	r3, [r7, #96]	; 0x60
                    *free_ptr =  TX_BYTE_BLOCK_FREE;
 8012108:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 801210a:	4a19      	ldr	r2, [pc, #100]	; (8012170 <_tx_byte_release+0x238>)
 801210c:	601a      	str	r2, [r3, #0]

                    /* Update the number of available bytes in the pool.  */
                    block_link_ptr =  TX_UCHAR_TO_INDIRECT_UCHAR_POINTER_CONVERT(work_ptr);
 801210e:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 8012110:	657b      	str	r3, [r7, #84]	; 0x54
                    next_block_ptr =  *block_link_ptr;
 8012112:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 8012114:	681b      	ldr	r3, [r3, #0]
 8012116:	653b      	str	r3, [r7, #80]	; 0x50
                    pool_ptr -> tx_byte_pool_available =  
                        pool_ptr -> tx_byte_pool_available + TX_UCHAR_POINTER_DIF(next_block_ptr, work_ptr);
 8012118:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 801211a:	689b      	ldr	r3, [r3, #8]
 801211c:	6d39      	ldr	r1, [r7, #80]	; 0x50
 801211e:	6eba      	ldr	r2, [r7, #104]	; 0x68
 8012120:	1a8a      	subs	r2, r1, r2
 8012122:	441a      	add	r2, r3
                    pool_ptr -> tx_byte_pool_available =  
 8012124:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 8012126:	609a      	str	r2, [r3, #8]

                    /* Determine if the current pointer is before the search pointer.  */
                    if (work_ptr < (pool_ptr -> tx_byte_pool_search))
 8012128:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 801212a:	695b      	ldr	r3, [r3, #20]
 801212c:	6eba      	ldr	r2, [r7, #104]	; 0x68
 801212e:	429a      	cmp	r2, r3
 8012130:	d202      	bcs.n	8012138 <_tx_byte_release+0x200>
                    {

                        /* Yes, update the search pointer.  */
                        pool_ptr -> tx_byte_pool_search =  work_ptr;
 8012132:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 8012134:	6eba      	ldr	r2, [r7, #104]	; 0x68
 8012136:	615a      	str	r2, [r3, #20]
            while (pool_ptr -> tx_byte_pool_suspended_count != TX_NO_SUSPENSIONS)
 8012138:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 801213a:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 801213c:	2b00      	cmp	r3, #0
 801213e:	f47f af6c 	bne.w	801201a <_tx_byte_release+0xe2>
 8012142:	e000      	b.n	8012146 <_tx_byte_release+0x20e>
                    break;
 8012144:	bf00      	nop
 8012146:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 8012148:	613b      	str	r3, [r7, #16]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 801214a:	693b      	ldr	r3, [r7, #16]
 801214c:	f383 8810 	msr	PRIMASK, r3
}
 8012150:	bf00      	nop
            
            /* Restore interrupts.  */
            TX_RESTORE

            /* Check for preemption.  */
            _tx_thread_system_preempt_check();
 8012152:	f002 fdaf 	bl	8014cb4 <_tx_thread_system_preempt_check>
 8012156:	e005      	b.n	8012164 <_tx_byte_release+0x22c>
 8012158:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 801215a:	60fb      	str	r3, [r7, #12]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 801215c:	68fb      	ldr	r3, [r7, #12]
 801215e:	f383 8810 	msr	PRIMASK, r3
}
 8012162:	bf00      	nop
            TX_RESTORE
        }
    }

    /* Return completion status.  */
    return(status);
 8012164:	6f3b      	ldr	r3, [r7, #112]	; 0x70
}
 8012166:	4618      	mov	r0, r3
 8012168:	3778      	adds	r7, #120	; 0x78
 801216a:	46bd      	mov	sp, r7
 801216c:	bd80      	pop	{r7, pc}
 801216e:	bf00      	nop
 8012170:	ffffeeee 	.word	0xffffeeee
 8012174:	42595445 	.word	0x42595445
 8012178:	24031bc4 	.word	0x24031bc4
 801217c:	24031c5c 	.word	0x24031c5c

08012180 <_tx_event_flags_cleanup>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
VOID  _tx_event_flags_cleanup(TX_THREAD  *thread_ptr, ULONG suspension_sequence)
{
 8012180:	b580      	push	{r7, lr}
 8012182:	b08e      	sub	sp, #56	; 0x38
 8012184:	af00      	add	r7, sp, #0
 8012186:	6078      	str	r0, [r7, #4]
 8012188:	6039      	str	r1, [r7, #0]
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 801218a:	f3ef 8310 	mrs	r3, PRIMASK
 801218e:	61fb      	str	r3, [r7, #28]
    return(posture);
 8012190:	69fb      	ldr	r3, [r7, #28]
    int_posture = __get_interrupt_posture();
 8012192:	61bb      	str	r3, [r7, #24]
    __asm__ volatile ("CPSID i" : : : "memory");
 8012194:	b672      	cpsid	i
    return(int_posture);
 8012196:	69bb      	ldr	r3, [r7, #24]


#ifndef TX_NOT_INTERRUPTABLE

    /* Disable interrupts to remove the suspended thread from the event flags group.  */
    TX_DISABLE
 8012198:	637b      	str	r3, [r7, #52]	; 0x34

    /* Determine if the cleanup is still required.  */
    if (thread_ptr -> tx_thread_suspend_cleanup == &(_tx_event_flags_cleanup))
 801219a:	687b      	ldr	r3, [r7, #4]
 801219c:	6e9b      	ldr	r3, [r3, #104]	; 0x68
 801219e:	4a38      	ldr	r2, [pc, #224]	; (8012280 <_tx_event_flags_cleanup+0x100>)
 80121a0:	4293      	cmp	r3, r2
 80121a2:	d162      	bne.n	801226a <_tx_event_flags_cleanup+0xea>
    {

        /* Check for valid suspension sequence.  */
        if (suspension_sequence == thread_ptr -> tx_thread_suspension_sequence)
 80121a4:	687b      	ldr	r3, [r7, #4]
 80121a6:	f8d3 30ac 	ldr.w	r3, [r3, #172]	; 0xac
 80121aa:	683a      	ldr	r2, [r7, #0]
 80121ac:	429a      	cmp	r2, r3
 80121ae:	d15c      	bne.n	801226a <_tx_event_flags_cleanup+0xea>
        {

            /* Setup pointer to event flags control block.  */
            group_ptr =  TX_VOID_TO_EVENT_FLAGS_POINTER_CONVERT(thread_ptr -> tx_thread_suspend_control_block);
 80121b0:	687b      	ldr	r3, [r7, #4]
 80121b2:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 80121b4:	633b      	str	r3, [r7, #48]	; 0x30
    
            /* Check for a NULL event flags control block pointer.  */
            if (group_ptr != TX_NULL)
 80121b6:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 80121b8:	2b00      	cmp	r3, #0
 80121ba:	d056      	beq.n	801226a <_tx_event_flags_cleanup+0xea>
            {
                
                /* Is the group pointer ID valid?  */
                if (group_ptr -> tx_event_flags_group_id == TX_EVENT_FLAGS_ID)
 80121bc:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 80121be:	681b      	ldr	r3, [r3, #0]
 80121c0:	4a30      	ldr	r2, [pc, #192]	; (8012284 <_tx_event_flags_cleanup+0x104>)
 80121c2:	4293      	cmp	r3, r2
 80121c4:	d151      	bne.n	801226a <_tx_event_flags_cleanup+0xea>
                {

                    /* Determine if there are any thread suspensions.  */
                    if (group_ptr -> tx_event_flags_group_suspended_count != TX_NO_SUSPENSIONS)
 80121c6:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 80121c8:	695b      	ldr	r3, [r3, #20]
 80121ca:	2b00      	cmp	r3, #0
 80121cc:	d04d      	beq.n	801226a <_tx_event_flags_cleanup+0xea>
#endif

                        /* Yes, we still have thread suspension!  */

                        /* Clear the suspension cleanup flag.  */
                        thread_ptr -> tx_thread_suspend_cleanup =  TX_NULL;
 80121ce:	687b      	ldr	r3, [r7, #4]
 80121d0:	2200      	movs	r2, #0
 80121d2:	669a      	str	r2, [r3, #104]	; 0x68

                        /* Pickup the suspended count.  */
                        suspended_count =  group_ptr -> tx_event_flags_group_suspended_count;
 80121d4:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 80121d6:	695b      	ldr	r3, [r3, #20]
 80121d8:	62fb      	str	r3, [r7, #44]	; 0x2c

                        /* Pickup the suspension head.  */
                        suspension_head =  group_ptr -> tx_event_flags_group_suspension_list;
 80121da:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 80121dc:	691b      	ldr	r3, [r3, #16]
 80121de:	62bb      	str	r3, [r7, #40]	; 0x28

                        /* Determine if the cleanup is being done while a set operation was interrupted.  If the 
                           suspended count is non-zero and the suspension head is NULL, the list is being processed
                           and cannot be touched from here. The suspension list removal will instead take place 
                           inside the event flag set code.  */
                        if (suspension_head != TX_NULL)
 80121e0:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80121e2:	2b00      	cmp	r3, #0
 80121e4:	d020      	beq.n	8012228 <_tx_event_flags_cleanup+0xa8>
                        {

                            /* Remove the suspended thread from the list.  */

                            /* Decrement the local suspension count.  */
                            suspended_count--;
 80121e6:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 80121e8:	3b01      	subs	r3, #1
 80121ea:	62fb      	str	r3, [r7, #44]	; 0x2c
              
                            /* Store the updated suspended count.  */
                            group_ptr -> tx_event_flags_group_suspended_count =  suspended_count;
 80121ec:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 80121ee:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 80121f0:	615a      	str	r2, [r3, #20]

                            /* See if this is the only suspended thread on the list.  */
                            if (suspended_count == TX_NO_SUSPENSIONS)
 80121f2:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 80121f4:	2b00      	cmp	r3, #0
 80121f6:	d103      	bne.n	8012200 <_tx_event_flags_cleanup+0x80>
                            {

                                /* Yes, the only suspended thread.  */
        
                                /* Update the head pointer.  */
                                group_ptr -> tx_event_flags_group_suspension_list =  TX_NULL;
 80121f8:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 80121fa:	2200      	movs	r2, #0
 80121fc:	611a      	str	r2, [r3, #16]
 80121fe:	e016      	b.n	801222e <_tx_event_flags_cleanup+0xae>
                            {

                                /* At least one more thread is on the same suspension list.  */
    
                                /* Update the links of the adjacent threads.  */
                                next_thread =                                  thread_ptr -> tx_thread_suspended_next;
 8012200:	687b      	ldr	r3, [r7, #4]
 8012202:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 8012204:	627b      	str	r3, [r7, #36]	; 0x24
                                previous_thread =                              thread_ptr -> tx_thread_suspended_previous;
 8012206:	687b      	ldr	r3, [r7, #4]
 8012208:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 801220a:	623b      	str	r3, [r7, #32]
                                next_thread -> tx_thread_suspended_previous =  previous_thread;
 801220c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801220e:	6a3a      	ldr	r2, [r7, #32]
 8012210:	675a      	str	r2, [r3, #116]	; 0x74
                                previous_thread -> tx_thread_suspended_next =  next_thread;
 8012212:	6a3b      	ldr	r3, [r7, #32]
 8012214:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8012216:	671a      	str	r2, [r3, #112]	; 0x70
                
                                /* Determine if we need to update the head pointer.  */
                                if (suspension_head == thread_ptr)
 8012218:	6aba      	ldr	r2, [r7, #40]	; 0x28
 801221a:	687b      	ldr	r3, [r7, #4]
 801221c:	429a      	cmp	r2, r3
 801221e:	d106      	bne.n	801222e <_tx_event_flags_cleanup+0xae>
                                {
                
                                    /* Update the list head pointer.  */
                                    group_ptr -> tx_event_flags_group_suspension_list =  next_thread;
 8012220:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8012222:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8012224:	611a      	str	r2, [r3, #16]
 8012226:	e002      	b.n	801222e <_tx_event_flags_cleanup+0xae>
                        }
                        else
                        {
                        
                            /* In this case, the search pointer in an interrupted event flag set must be reset.  */
                            group_ptr -> tx_event_flags_group_reset_search =  TX_TRUE;
 8012228:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801222a:	2201      	movs	r2, #1
 801222c:	60da      	str	r2, [r3, #12]
                        }

                        /* Now we need to determine if this cleanup is from a terminate, timeout,
                           or from a wait abort.  */
                        if (thread_ptr -> tx_thread_state == TX_EVENT_FLAG)
 801222e:	687b      	ldr	r3, [r7, #4]
 8012230:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8012232:	2b07      	cmp	r3, #7
 8012234:	d119      	bne.n	801226a <_tx_event_flags_cleanup+0xea>
                            /* Increment the number of timeouts on this event flags group.  */
                            group_ptr -> tx_event_flags_group____performance_timeout_count++;
#endif

                            /* Setup return status.  */
                            thread_ptr -> tx_thread_suspend_status =  TX_NO_EVENTS;
 8012236:	687b      	ldr	r3, [r7, #4]
 8012238:	2207      	movs	r2, #7
 801223a:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84
                            /* Resume the thread!  */
                            _tx_thread_system_ni_resume(thread_ptr);
#else

                           /* Temporarily disable preemption.  */
                            _tx_thread_preempt_disable++;
 801223e:	4b12      	ldr	r3, [pc, #72]	; (8012288 <_tx_event_flags_cleanup+0x108>)
 8012240:	681b      	ldr	r3, [r3, #0]
 8012242:	3301      	adds	r3, #1
 8012244:	4a10      	ldr	r2, [pc, #64]	; (8012288 <_tx_event_flags_cleanup+0x108>)
 8012246:	6013      	str	r3, [r2, #0]
 8012248:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 801224a:	60fb      	str	r3, [r7, #12]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 801224c:	68fb      	ldr	r3, [r7, #12]
 801224e:	f383 8810 	msr	PRIMASK, r3
}
 8012252:	bf00      	nop
                            TX_RESTORE

                            /* Resume the thread!  Check for preemption even though we are executing 
                               from the system timer thread right now which normally executes at the 
                               highest priority.  */
                            _tx_thread_system_resume(thread_ptr);
 8012254:	6878      	ldr	r0, [r7, #4]
 8012256:	f002 fd67 	bl	8014d28 <_tx_thread_system_resume>
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 801225a:	f3ef 8310 	mrs	r3, PRIMASK
 801225e:	617b      	str	r3, [r7, #20]
    return(posture);
 8012260:	697b      	ldr	r3, [r7, #20]
    int_posture = __get_interrupt_posture();
 8012262:	613b      	str	r3, [r7, #16]
    __asm__ volatile ("CPSID i" : : : "memory");
 8012264:	b672      	cpsid	i
    return(int_posture);
 8012266:	693b      	ldr	r3, [r7, #16]

                            /* Disable interrupts.  */
                            TX_DISABLE
 8012268:	637b      	str	r3, [r7, #52]	; 0x34
 801226a:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 801226c:	60bb      	str	r3, [r7, #8]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 801226e:	68bb      	ldr	r3, [r7, #8]
 8012270:	f383 8810 	msr	PRIMASK, r3
}
 8012274:	bf00      	nop
    }

    /* Restore interrupts.  */
    TX_RESTORE
#endif
}
 8012276:	bf00      	nop
 8012278:	3738      	adds	r7, #56	; 0x38
 801227a:	46bd      	mov	sp, r7
 801227c:	bd80      	pop	{r7, pc}
 801227e:	bf00      	nop
 8012280:	08012181 	.word	0x08012181
 8012284:	4456444e 	.word	0x4456444e
 8012288:	24031c5c 	.word	0x24031c5c

0801228c <_tx_event_flags_create>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
UINT  _tx_event_flags_create(TX_EVENT_FLAGS_GROUP *group_ptr, CHAR *name_ptr)
{
 801228c:	b580      	push	{r7, lr}
 801228e:	b088      	sub	sp, #32
 8012290:	af00      	add	r7, sp, #0
 8012292:	6078      	str	r0, [r7, #4]
 8012294:	6039      	str	r1, [r7, #0]
TX_EVENT_FLAGS_GROUP    *next_group;
TX_EVENT_FLAGS_GROUP    *previous_group;


    /* Initialize event flags control block to all zeros.  */
    TX_MEMSET(group_ptr, 0, (sizeof(TX_EVENT_FLAGS_GROUP)));
 8012296:	2224      	movs	r2, #36	; 0x24
 8012298:	2100      	movs	r1, #0
 801229a:	6878      	ldr	r0, [r7, #4]
 801229c:	f00d faee 	bl	801f87c <memset>

    /* Setup the basic event flags group fields.  */
    group_ptr -> tx_event_flags_group_name =             name_ptr;
 80122a0:	687b      	ldr	r3, [r7, #4]
 80122a2:	683a      	ldr	r2, [r7, #0]
 80122a4:	605a      	str	r2, [r3, #4]
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 80122a6:	f3ef 8310 	mrs	r3, PRIMASK
 80122aa:	613b      	str	r3, [r7, #16]
    return(posture);
 80122ac:	693b      	ldr	r3, [r7, #16]
    int_posture = __get_interrupt_posture();
 80122ae:	60fb      	str	r3, [r7, #12]
    __asm__ volatile ("CPSID i" : : : "memory");
 80122b0:	b672      	cpsid	i
    return(int_posture);
 80122b2:	68fb      	ldr	r3, [r7, #12]
    
    /* Disable interrupts to put the event flags group on the created list.  */
    TX_DISABLE
 80122b4:	61fb      	str	r3, [r7, #28]

    /* Setup the event flags ID to make it valid.  */
    group_ptr -> tx_event_flags_group_id =  TX_EVENT_FLAGS_ID;
 80122b6:	687b      	ldr	r3, [r7, #4]
 80122b8:	4a18      	ldr	r2, [pc, #96]	; (801231c <_tx_event_flags_create+0x90>)
 80122ba:	601a      	str	r2, [r3, #0]

    /* Place the group on the list of created event flag groups.  First,
       check for an empty list.  */
    if (_tx_event_flags_created_count == TX_EMPTY)
 80122bc:	4b18      	ldr	r3, [pc, #96]	; (8012320 <_tx_event_flags_create+0x94>)
 80122be:	681b      	ldr	r3, [r3, #0]
 80122c0:	2b00      	cmp	r3, #0
 80122c2:	d109      	bne.n	80122d8 <_tx_event_flags_create+0x4c>
    {

        /* The created event flags list is empty.  Add event flag group to empty list.  */
        _tx_event_flags_created_ptr =                         group_ptr;
 80122c4:	4a17      	ldr	r2, [pc, #92]	; (8012324 <_tx_event_flags_create+0x98>)
 80122c6:	687b      	ldr	r3, [r7, #4]
 80122c8:	6013      	str	r3, [r2, #0]
        group_ptr -> tx_event_flags_group_created_next =      group_ptr;
 80122ca:	687b      	ldr	r3, [r7, #4]
 80122cc:	687a      	ldr	r2, [r7, #4]
 80122ce:	619a      	str	r2, [r3, #24]
        group_ptr -> tx_event_flags_group_created_previous =  group_ptr;
 80122d0:	687b      	ldr	r3, [r7, #4]
 80122d2:	687a      	ldr	r2, [r7, #4]
 80122d4:	61da      	str	r2, [r3, #28]
 80122d6:	e011      	b.n	80122fc <_tx_event_flags_create+0x70>
    }
    else
    {

        /* This list is not NULL, add to the end of the list.  */
        next_group =      _tx_event_flags_created_ptr;
 80122d8:	4b12      	ldr	r3, [pc, #72]	; (8012324 <_tx_event_flags_create+0x98>)
 80122da:	681b      	ldr	r3, [r3, #0]
 80122dc:	61bb      	str	r3, [r7, #24]
        previous_group =  next_group -> tx_event_flags_group_created_previous;
 80122de:	69bb      	ldr	r3, [r7, #24]
 80122e0:	69db      	ldr	r3, [r3, #28]
 80122e2:	617b      	str	r3, [r7, #20]

        /* Place the new event flag group in the list.  */
        next_group -> tx_event_flags_group_created_previous =  group_ptr;
 80122e4:	69bb      	ldr	r3, [r7, #24]
 80122e6:	687a      	ldr	r2, [r7, #4]
 80122e8:	61da      	str	r2, [r3, #28]
        previous_group -> tx_event_flags_group_created_next =  group_ptr;
 80122ea:	697b      	ldr	r3, [r7, #20]
 80122ec:	687a      	ldr	r2, [r7, #4]
 80122ee:	619a      	str	r2, [r3, #24]

        /* Setup this group's created links.  */
        group_ptr -> tx_event_flags_group_created_previous =  previous_group;
 80122f0:	687b      	ldr	r3, [r7, #4]
 80122f2:	697a      	ldr	r2, [r7, #20]
 80122f4:	61da      	str	r2, [r3, #28]
        group_ptr -> tx_event_flags_group_created_next =      next_group;
 80122f6:	687b      	ldr	r3, [r7, #4]
 80122f8:	69ba      	ldr	r2, [r7, #24]
 80122fa:	619a      	str	r2, [r3, #24]
    }

    /* Increment the number of created event flag groups.  */
    _tx_event_flags_created_count++;
 80122fc:	4b08      	ldr	r3, [pc, #32]	; (8012320 <_tx_event_flags_create+0x94>)
 80122fe:	681b      	ldr	r3, [r3, #0]
 8012300:	3301      	adds	r3, #1
 8012302:	4a07      	ldr	r2, [pc, #28]	; (8012320 <_tx_event_flags_create+0x94>)
 8012304:	6013      	str	r3, [r2, #0]
 8012306:	69fb      	ldr	r3, [r7, #28]
 8012308:	60bb      	str	r3, [r7, #8]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 801230a:	68bb      	ldr	r3, [r7, #8]
 801230c:	f383 8810 	msr	PRIMASK, r3
}
 8012310:	bf00      	nop

    /* Restore interrupts.  */
    TX_RESTORE

    /* Return TX_SUCCESS.  */
    return(TX_SUCCESS);
 8012312:	2300      	movs	r3, #0
}
 8012314:	4618      	mov	r0, r3
 8012316:	3720      	adds	r7, #32
 8012318:	46bd      	mov	sp, r7
 801231a:	bd80      	pop	{r7, pc}
 801231c:	4456444e 	.word	0x4456444e
 8012320:	24031ba0 	.word	0x24031ba0
 8012324:	24031b9c 	.word	0x24031b9c

08012328 <_tx_event_flags_get>:
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
UINT  _tx_event_flags_get(TX_EVENT_FLAGS_GROUP *group_ptr, ULONG requested_flags,
                    UINT get_option, ULONG *actual_flags_ptr, ULONG wait_option)
{
 8012328:	b580      	push	{r7, lr}
 801232a:	b096      	sub	sp, #88	; 0x58
 801232c:	af00      	add	r7, sp, #0
 801232e:	60f8      	str	r0, [r7, #12]
 8012330:	60b9      	str	r1, [r7, #8]
 8012332:	607a      	str	r2, [r7, #4]
 8012334:	603b      	str	r3, [r7, #0]
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 8012336:	f3ef 8310 	mrs	r3, PRIMASK
 801233a:	627b      	str	r3, [r7, #36]	; 0x24
    return(posture);
 801233c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    int_posture = __get_interrupt_posture();
 801233e:	623b      	str	r3, [r7, #32]
    __asm__ volatile ("CPSID i" : : : "memory");
 8012340:	b672      	cpsid	i
    return(int_posture);
 8012342:	6a3b      	ldr	r3, [r7, #32]
UINT            interrupted_set_request;
#endif


    /* Disable interrupts to examine the event flags group.  */
    TX_DISABLE
 8012344:	657b      	str	r3, [r7, #84]	; 0x54

    /* Log this kernel call.  */
    TX_EL_EVENT_FLAGS_GET_INSERT

    /* Pickup current flags.  */
    current_flags =  group_ptr -> tx_event_flags_group_current;
 8012346:	68fb      	ldr	r3, [r7, #12]
 8012348:	689b      	ldr	r3, [r3, #8]
 801234a:	64fb      	str	r3, [r7, #76]	; 0x4c

    /* Apply the event flag option mask.  */
    and_request =  (get_option & TX_AND);
 801234c:	687b      	ldr	r3, [r7, #4]
 801234e:	f003 0302 	and.w	r3, r3, #2
 8012352:	643b      	str	r3, [r7, #64]	; 0x40
    }

#else

    /* Pickup delayed clear flags.  */
    delayed_clear_flags =  group_ptr -> tx_event_flags_group_delayed_clear;
 8012354:	68fb      	ldr	r3, [r7, #12]
 8012356:	6a1b      	ldr	r3, [r3, #32]
 8012358:	63fb      	str	r3, [r7, #60]	; 0x3c

    /* Determine if there are any delayed clear operations pending.  */
    if (delayed_clear_flags != ((ULONG) 0))
 801235a:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 801235c:	2b00      	cmp	r3, #0
 801235e:	d004      	beq.n	801236a <_tx_event_flags_get+0x42>
    {

        /* Yes, apply them to the current flags.  */
        current_flags =  current_flags & (~delayed_clear_flags);
 8012360:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8012362:	43db      	mvns	r3, r3
 8012364:	6cfa      	ldr	r2, [r7, #76]	; 0x4c
 8012366:	4013      	ands	r3, r2
 8012368:	64fb      	str	r3, [r7, #76]	; 0x4c
    }

    /* Check for AND condition. All flags must be present to satisfy request.  */
    if (and_request == TX_AND)
 801236a:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 801236c:	2b02      	cmp	r3, #2
 801236e:	d10a      	bne.n	8012386 <_tx_event_flags_get+0x5e>
    {
    
        /* AND request is present.  */
        
        /* Calculate the flags present.  */
        flags_satisfied =  (current_flags & requested_flags);
 8012370:	6cfa      	ldr	r2, [r7, #76]	; 0x4c
 8012372:	68bb      	ldr	r3, [r7, #8]
 8012374:	4013      	ands	r3, r2
 8012376:	64bb      	str	r3, [r7, #72]	; 0x48
        
        /* Determine if they satisfy the AND request.  */
        if (flags_satisfied != requested_flags)
 8012378:	6cba      	ldr	r2, [r7, #72]	; 0x48
 801237a:	68bb      	ldr	r3, [r7, #8]
 801237c:	429a      	cmp	r2, r3
 801237e:	d006      	beq.n	801238e <_tx_event_flags_get+0x66>
        {
        
            /* No, not all the requested flags are present. Clear the flags present variable.  */
            flags_satisfied =  ((ULONG) 0);
 8012380:	2300      	movs	r3, #0
 8012382:	64bb      	str	r3, [r7, #72]	; 0x48
 8012384:	e003      	b.n	801238e <_tx_event_flags_get+0x66>
    else
    {

        /* OR request is present. Simply AND together the requested flags and the current flags
           to see if any are present.  */
        flags_satisfied =  (current_flags & requested_flags);
 8012386:	6cfa      	ldr	r2, [r7, #76]	; 0x4c
 8012388:	68bb      	ldr	r3, [r7, #8]
 801238a:	4013      	ands	r3, r2
 801238c:	64bb      	str	r3, [r7, #72]	; 0x48
    }
    
    /* Determine if the request is satisfied.  */
    if (flags_satisfied != ((ULONG) 0))
 801238e:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 8012390:	2b00      	cmp	r3, #0
 8012392:	d029      	beq.n	80123e8 <_tx_event_flags_get+0xc0>
    {

        /* Yes, this request can be handled immediately.  */

        /* Return the actual event flags that satisfied the request.  */
        *actual_flags_ptr =  current_flags;
 8012394:	683b      	ldr	r3, [r7, #0]
 8012396:	6cfa      	ldr	r2, [r7, #76]	; 0x4c
 8012398:	601a      	str	r2, [r3, #0]

        /* Pickup the clear bit.  */
        clear_request =  (get_option & TX_EVENT_FLAGS_CLEAR_MASK);
 801239a:	687b      	ldr	r3, [r7, #4]
 801239c:	f003 0301 	and.w	r3, r3, #1
 80123a0:	62bb      	str	r3, [r7, #40]	; 0x28

        /* Determine whether or not clearing needs to take place.  */
        if (clear_request == TX_TRUE)
 80123a2:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80123a4:	2b01      	cmp	r3, #1
 80123a6:	d11c      	bne.n	80123e2 <_tx_event_flags_get+0xba>
        {

            /* Set interrupted set request flag to false.  */
            interrupted_set_request =  TX_FALSE;
 80123a8:	2300      	movs	r3, #0
 80123aa:	647b      	str	r3, [r7, #68]	; 0x44

            /* Determine if the suspension list is being processed by an interrupted
               set request.  */
            if (group_ptr -> tx_event_flags_group_suspended_count != TX_NO_SUSPENSIONS)
 80123ac:	68fb      	ldr	r3, [r7, #12]
 80123ae:	695b      	ldr	r3, [r3, #20]
 80123b0:	2b00      	cmp	r3, #0
 80123b2:	d005      	beq.n	80123c0 <_tx_event_flags_get+0x98>
            {
            
                if (group_ptr -> tx_event_flags_group_suspension_list == TX_NULL)
 80123b4:	68fb      	ldr	r3, [r7, #12]
 80123b6:	691b      	ldr	r3, [r3, #16]
 80123b8:	2b00      	cmp	r3, #0
 80123ba:	d101      	bne.n	80123c0 <_tx_event_flags_get+0x98>
                {

                    /* Set the interrupted set request flag.  */
                    interrupted_set_request =  TX_TRUE;
 80123bc:	2301      	movs	r3, #1
 80123be:	647b      	str	r3, [r7, #68]	; 0x44
                }
            }

            /* Was a set request interrupted?  */
            if (interrupted_set_request == TX_TRUE)
 80123c0:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 80123c2:	2b01      	cmp	r3, #1
 80123c4:	d106      	bne.n	80123d4 <_tx_event_flags_get+0xac>
                /* A previous set operation is was interrupted, we need to defer the
                   event clearing until the set operation is complete.  */

                /* Remember the events to clear.  */
                group_ptr -> tx_event_flags_group_delayed_clear =  
                                        group_ptr -> tx_event_flags_group_delayed_clear | requested_flags;
 80123c6:	68fb      	ldr	r3, [r7, #12]
 80123c8:	6a1a      	ldr	r2, [r3, #32]
 80123ca:	68bb      	ldr	r3, [r7, #8]
 80123cc:	431a      	orrs	r2, r3
                group_ptr -> tx_event_flags_group_delayed_clear =  
 80123ce:	68fb      	ldr	r3, [r7, #12]
 80123d0:	621a      	str	r2, [r3, #32]
 80123d2:	e006      	b.n	80123e2 <_tx_event_flags_get+0xba>
            else
            {

                /* Yes, clear the flags that satisfied this request.  */
                group_ptr -> tx_event_flags_group_current =
                                        group_ptr -> tx_event_flags_group_current & ~requested_flags;
 80123d4:	68fb      	ldr	r3, [r7, #12]
 80123d6:	689a      	ldr	r2, [r3, #8]
 80123d8:	68bb      	ldr	r3, [r7, #8]
 80123da:	43db      	mvns	r3, r3
 80123dc:	401a      	ands	r2, r3
                group_ptr -> tx_event_flags_group_current =
 80123de:	68fb      	ldr	r3, [r7, #12]
 80123e0:	609a      	str	r2, [r3, #8]
            }
        }

        /* Set status to success.  */
        status =  TX_SUCCESS;
 80123e2:	2300      	movs	r3, #0
 80123e4:	653b      	str	r3, [r7, #80]	; 0x50
 80123e6:	e070      	b.n	80124ca <_tx_event_flags_get+0x1a2>
#endif
    else
    {

        /* Determine if the request specifies suspension.  */
        if (wait_option != TX_NO_WAIT)
 80123e8:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 80123ea:	2b00      	cmp	r3, #0
 80123ec:	d06b      	beq.n	80124c6 <_tx_event_flags_get+0x19e>
        {

            /* Determine if the preempt disable flag is non-zero.  */
            if (_tx_thread_preempt_disable != ((UINT) 0))
 80123ee:	4b3c      	ldr	r3, [pc, #240]	; (80124e0 <_tx_event_flags_get+0x1b8>)
 80123f0:	681b      	ldr	r3, [r3, #0]
 80123f2:	2b00      	cmp	r3, #0
 80123f4:	d002      	beq.n	80123fc <_tx_event_flags_get+0xd4>
            {
            
                /* Suspension is not allowed if the preempt disable flag is non-zero at this point, return error completion.  */
                status =  TX_NO_EVENTS;
 80123f6:	2307      	movs	r3, #7
 80123f8:	653b      	str	r3, [r7, #80]	; 0x50
 80123fa:	e066      	b.n	80124ca <_tx_event_flags_get+0x1a2>
                /* Increment the number of event flags suspensions on this semaphore.  */
                group_ptr -> tx_event_flags_group___performance_suspension_count++;
#endif
            
                /* Pickup thread pointer.  */
                TX_THREAD_GET_CURRENT(thread_ptr)
 80123fc:	4b39      	ldr	r3, [pc, #228]	; (80124e4 <_tx_event_flags_get+0x1bc>)
 80123fe:	681b      	ldr	r3, [r3, #0]
 8012400:	63bb      	str	r3, [r7, #56]	; 0x38

                /* Setup cleanup routine pointer.  */
                thread_ptr -> tx_thread_suspend_cleanup =  &(_tx_event_flags_cleanup);
 8012402:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8012404:	4a38      	ldr	r2, [pc, #224]	; (80124e8 <_tx_event_flags_get+0x1c0>)
 8012406:	669a      	str	r2, [r3, #104]	; 0x68

                /* Remember which event flags we are looking for.  */
                thread_ptr -> tx_thread_suspend_info =  requested_flags;
 8012408:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 801240a:	68ba      	ldr	r2, [r7, #8]
 801240c:	679a      	str	r2, [r3, #120]	; 0x78

                /* Save the get option as well.  */
                thread_ptr -> tx_thread_suspend_option =  get_option;
 801240e:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8012410:	687a      	ldr	r2, [r7, #4]
 8012412:	f8c3 2080 	str.w	r2, [r3, #128]	; 0x80

                /* Save the destination for the current events.  */
                thread_ptr -> tx_thread_additional_suspend_info =  (VOID *) actual_flags_ptr;
 8012416:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8012418:	683a      	ldr	r2, [r7, #0]
 801241a:	67da      	str	r2, [r3, #124]	; 0x7c

                /* Setup cleanup information, i.e. this event flags group control
                   block.  */
                thread_ptr -> tx_thread_suspend_control_block =  (VOID *) group_ptr;
 801241c:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 801241e:	68fa      	ldr	r2, [r7, #12]
 8012420:	66da      	str	r2, [r3, #108]	; 0x6c

#ifndef TX_NOT_INTERRUPTABLE

                /* Increment the suspension sequence number, which is used to identify
                   this suspension event.  */
                thread_ptr -> tx_thread_suspension_sequence++;
 8012422:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8012424:	f8d3 30ac 	ldr.w	r3, [r3, #172]	; 0xac
 8012428:	1c5a      	adds	r2, r3, #1
 801242a:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 801242c:	f8c3 20ac 	str.w	r2, [r3, #172]	; 0xac
#endif

                /* Pickup the suspended count.  */
                suspended_count =  group_ptr -> tx_event_flags_group_suspended_count;
 8012430:	68fb      	ldr	r3, [r7, #12]
 8012432:	695b      	ldr	r3, [r3, #20]
 8012434:	637b      	str	r3, [r7, #52]	; 0x34
            
                /* Setup suspension list.  */
                if (suspended_count == TX_NO_SUSPENSIONS)
 8012436:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8012438:	2b00      	cmp	r3, #0
 801243a:	d109      	bne.n	8012450 <_tx_event_flags_get+0x128>
                {

                    /* No other threads are suspended.  Setup the head pointer and
                       just setup this threads pointers to itself.  */
                    group_ptr -> tx_event_flags_group_suspension_list =   thread_ptr;
 801243c:	68fb      	ldr	r3, [r7, #12]
 801243e:	6bba      	ldr	r2, [r7, #56]	; 0x38
 8012440:	611a      	str	r2, [r3, #16]
                    thread_ptr -> tx_thread_suspended_next =              thread_ptr;
 8012442:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8012444:	6bba      	ldr	r2, [r7, #56]	; 0x38
 8012446:	671a      	str	r2, [r3, #112]	; 0x70
                    thread_ptr -> tx_thread_suspended_previous =          thread_ptr;
 8012448:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 801244a:	6bba      	ldr	r2, [r7, #56]	; 0x38
 801244c:	675a      	str	r2, [r3, #116]	; 0x74
 801244e:	e011      	b.n	8012474 <_tx_event_flags_get+0x14c>
                }
                else
                {

                    /* This list is not NULL, add current thread to the end. */
                    next_thread =                                   group_ptr -> tx_event_flags_group_suspension_list;
 8012450:	68fb      	ldr	r3, [r7, #12]
 8012452:	691b      	ldr	r3, [r3, #16]
 8012454:	633b      	str	r3, [r7, #48]	; 0x30
                    thread_ptr -> tx_thread_suspended_next =        next_thread;
 8012456:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8012458:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 801245a:	671a      	str	r2, [r3, #112]	; 0x70
                    previous_thread =                               next_thread -> tx_thread_suspended_previous;
 801245c:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801245e:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 8012460:	62fb      	str	r3, [r7, #44]	; 0x2c
                    thread_ptr -> tx_thread_suspended_previous =    previous_thread;
 8012462:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8012464:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 8012466:	675a      	str	r2, [r3, #116]	; 0x74
                    previous_thread -> tx_thread_suspended_next =   thread_ptr;
 8012468:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 801246a:	6bba      	ldr	r2, [r7, #56]	; 0x38
 801246c:	671a      	str	r2, [r3, #112]	; 0x70
                    next_thread -> tx_thread_suspended_previous =   thread_ptr;
 801246e:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8012470:	6bba      	ldr	r2, [r7, #56]	; 0x38
 8012472:	675a      	str	r2, [r3, #116]	; 0x74
                }

                /* Increment the number of threads suspended.  */
                group_ptr -> tx_event_flags_group_suspended_count++;
 8012474:	68fb      	ldr	r3, [r7, #12]
 8012476:	695b      	ldr	r3, [r3, #20]
 8012478:	1c5a      	adds	r2, r3, #1
 801247a:	68fb      	ldr	r3, [r7, #12]
 801247c:	615a      	str	r2, [r3, #20]
            
                /* Set the state to suspended.  */
                thread_ptr -> tx_thread_state =    TX_EVENT_FLAG;
 801247e:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8012480:	2207      	movs	r2, #7
 8012482:	631a      	str	r2, [r3, #48]	; 0x30
                /* Return the completion status.  */
                status =  thread_ptr -> tx_thread_suspend_status;
#else

                /* Set the suspending flag.  */
                thread_ptr -> tx_thread_suspending =  TX_TRUE;
 8012484:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8012486:	2201      	movs	r2, #1
 8012488:	639a      	str	r2, [r3, #56]	; 0x38

                /* Setup the timeout period.  */
                thread_ptr -> tx_thread_timer.tx_timer_internal_remaining_ticks =  wait_option;
 801248a:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 801248c:	6e3a      	ldr	r2, [r7, #96]	; 0x60
 801248e:	64da      	str	r2, [r3, #76]	; 0x4c

                /* Temporarily disable preemption.  */
                _tx_thread_preempt_disable++;
 8012490:	4b13      	ldr	r3, [pc, #76]	; (80124e0 <_tx_event_flags_get+0x1b8>)
 8012492:	681b      	ldr	r3, [r3, #0]
 8012494:	3301      	adds	r3, #1
 8012496:	4a12      	ldr	r2, [pc, #72]	; (80124e0 <_tx_event_flags_get+0x1b8>)
 8012498:	6013      	str	r3, [r2, #0]
 801249a:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 801249c:	617b      	str	r3, [r7, #20]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 801249e:	697b      	ldr	r3, [r7, #20]
 80124a0:	f383 8810 	msr	PRIMASK, r3
}
 80124a4:	bf00      	nop

                /* Restore interrupts.  */
                TX_RESTORE

                /* Call actual thread suspension routine.  */
                _tx_thread_system_suspend(thread_ptr);
 80124a6:	6bb8      	ldr	r0, [r7, #56]	; 0x38
 80124a8:	f002 fd3e 	bl	8014f28 <_tx_thread_system_suspend>
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 80124ac:	f3ef 8310 	mrs	r3, PRIMASK
 80124b0:	61fb      	str	r3, [r7, #28]
    return(posture);
 80124b2:	69fb      	ldr	r3, [r7, #28]
    int_posture = __get_interrupt_posture();
 80124b4:	61bb      	str	r3, [r7, #24]
    __asm__ volatile ("CPSID i" : : : "memory");
 80124b6:	b672      	cpsid	i
    return(int_posture);
 80124b8:	69bb      	ldr	r3, [r7, #24]
    
                /* Disable interrupts.  */
                TX_DISABLE
 80124ba:	657b      	str	r3, [r7, #84]	; 0x54
              
                /* Return the completion status.  */
                status =  thread_ptr -> tx_thread_suspend_status;
 80124bc:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 80124be:	f8d3 3084 	ldr.w	r3, [r3, #132]	; 0x84
 80124c2:	653b      	str	r3, [r7, #80]	; 0x50
 80124c4:	e001      	b.n	80124ca <_tx_event_flags_get+0x1a2>
        }
        else
        {
            
            /* Immediate return, return error completion.  */
            status =  TX_NO_EVENTS;
 80124c6:	2307      	movs	r3, #7
 80124c8:	653b      	str	r3, [r7, #80]	; 0x50
 80124ca:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 80124cc:	613b      	str	r3, [r7, #16]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 80124ce:	693b      	ldr	r3, [r7, #16]
 80124d0:	f383 8810 	msr	PRIMASK, r3
}
 80124d4:	bf00      	nop

    /* Restore interrupts.  */
    TX_RESTORE

    /* Return completion status.  */
    return(status);
 80124d6:	6d3b      	ldr	r3, [r7, #80]	; 0x50
}
 80124d8:	4618      	mov	r0, r3
 80124da:	3758      	adds	r7, #88	; 0x58
 80124dc:	46bd      	mov	sp, r7
 80124de:	bd80      	pop	{r7, pc}
 80124e0:	24031c5c 	.word	0x24031c5c
 80124e4:	24031bc4 	.word	0x24031bc4
 80124e8:	08012181 	.word	0x08012181

080124ec <_tx_event_flags_set>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
UINT  _tx_event_flags_set(TX_EVENT_FLAGS_GROUP *group_ptr, ULONG flags_to_set, UINT set_option)
{
 80124ec:	b580      	push	{r7, lr}
 80124ee:	b0a6      	sub	sp, #152	; 0x98
 80124f0:	af00      	add	r7, sp, #0
 80124f2:	60f8      	str	r0, [r7, #12]
 80124f4:	60b9      	str	r1, [r7, #8]
 80124f6:	607a      	str	r2, [r7, #4]
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 80124f8:	f3ef 8310 	mrs	r3, PRIMASK
 80124fc:	64fb      	str	r3, [r7, #76]	; 0x4c
    return(posture);
 80124fe:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
    int_posture = __get_interrupt_posture();
 8012500:	64bb      	str	r3, [r7, #72]	; 0x48
    __asm__ volatile ("CPSID i" : : : "memory");
 8012502:	b672      	cpsid	i
    return(int_posture);
 8012504:	6cbb      	ldr	r3, [r7, #72]	; 0x48
VOID            (*events_set_notify)(struct TX_EVENT_FLAGS_GROUP_STRUCT *notify_group_ptr);
#endif


    /* Disable interrupts to remove the semaphore from the created list.  */
    TX_DISABLE
 8012506:	f8c7 3094 	str.w	r3, [r7, #148]	; 0x94

    /* Log this kernel call.  */
    TX_EL_EVENT_FLAGS_SET_INSERT

    /* Determine how to set this group's event flags.  */
    if ((set_option & TX_EVENT_FLAGS_AND_MASK) == TX_AND)
 801250a:	687b      	ldr	r3, [r7, #4]
 801250c:	f003 0302 	and.w	r3, r3, #2
 8012510:	2b00      	cmp	r3, #0
 8012512:	d023      	beq.n	801255c <_tx_event_flags_set+0x70>
    {

#ifndef TX_NOT_INTERRUPTABLE

        /* Set interrupted set request flag to false.  */
        interrupted_set_request =  TX_FALSE;
 8012514:	2300      	movs	r3, #0
 8012516:	673b      	str	r3, [r7, #112]	; 0x70

        /* Determine if the suspension list is being processed by an interrupted
           set request.  */
        if (group_ptr -> tx_event_flags_group_suspended_count != TX_NO_SUSPENSIONS)
 8012518:	68fb      	ldr	r3, [r7, #12]
 801251a:	695b      	ldr	r3, [r3, #20]
 801251c:	2b00      	cmp	r3, #0
 801251e:	d005      	beq.n	801252c <_tx_event_flags_set+0x40>
        {
            
            if (group_ptr -> tx_event_flags_group_suspension_list == TX_NULL)
 8012520:	68fb      	ldr	r3, [r7, #12]
 8012522:	691b      	ldr	r3, [r3, #16]
 8012524:	2b00      	cmp	r3, #0
 8012526:	d101      	bne.n	801252c <_tx_event_flags_set+0x40>
            {

                /* Set the interrupted set request flag.  */
                interrupted_set_request =  TX_TRUE;
 8012528:	2301      	movs	r3, #1
 801252a:	673b      	str	r3, [r7, #112]	; 0x70
            }
        }

        /* Was a set request interrupted?  */
        if (interrupted_set_request == TX_TRUE)
 801252c:	6f3b      	ldr	r3, [r7, #112]	; 0x70
 801252e:	2b01      	cmp	r3, #1
 8012530:	d107      	bne.n	8012542 <_tx_event_flags_set+0x56>
            /* A previous set operation was interrupted, we need to defer the
               event clearing until the set operation is complete.  */

            /* Remember the events to clear.  */
            group_ptr -> tx_event_flags_group_delayed_clear =  
                                        group_ptr -> tx_event_flags_group_delayed_clear | ~flags_to_set;
 8012532:	68fb      	ldr	r3, [r7, #12]
 8012534:	6a1a      	ldr	r2, [r3, #32]
 8012536:	68bb      	ldr	r3, [r7, #8]
 8012538:	43db      	mvns	r3, r3
 801253a:	431a      	orrs	r2, r3
            group_ptr -> tx_event_flags_group_delayed_clear =  
 801253c:	68fb      	ldr	r3, [r7, #12]
 801253e:	621a      	str	r2, [r3, #32]
 8012540:	e005      	b.n	801254e <_tx_event_flags_set+0x62>

            /* Previous set operation was not interrupted, simply clear the 
               specified flags by "ANDing" the flags into the current events 
               of the group.  */
            group_ptr -> tx_event_flags_group_current =
                group_ptr -> tx_event_flags_group_current & flags_to_set;
 8012542:	68fb      	ldr	r3, [r7, #12]
 8012544:	689a      	ldr	r2, [r3, #8]
 8012546:	68bb      	ldr	r3, [r7, #8]
 8012548:	401a      	ands	r2, r3
            group_ptr -> tx_event_flags_group_current =
 801254a:	68fb      	ldr	r3, [r7, #12]
 801254c:	609a      	str	r2, [r3, #8]
 801254e:	f8d7 3094 	ldr.w	r3, [r7, #148]	; 0x94
 8012552:	647b      	str	r3, [r7, #68]	; 0x44
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 8012554:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8012556:	f383 8810 	msr	PRIMASK, r3
}
 801255a:	e1d4      	b.n	8012906 <_tx_event_flags_set+0x41a>
        events_set_notify =  group_ptr -> tx_event_flags_group_set_notify;
#endif

        /* "OR" the flags into the current events of the group.  */
        group_ptr -> tx_event_flags_group_current =
            group_ptr -> tx_event_flags_group_current | flags_to_set;
 801255c:	68fb      	ldr	r3, [r7, #12]
 801255e:	689a      	ldr	r2, [r3, #8]
 8012560:	68bb      	ldr	r3, [r7, #8]
 8012562:	431a      	orrs	r2, r3
        group_ptr -> tx_event_flags_group_current =
 8012564:	68fb      	ldr	r3, [r7, #12]
 8012566:	609a      	str	r2, [r3, #8]

#ifndef TX_NOT_INTERRUPTABLE

        /* Determine if there are any delayed flags to clear.  */
        if (group_ptr -> tx_event_flags_group_delayed_clear != ((ULONG) 0))
 8012568:	68fb      	ldr	r3, [r7, #12]
 801256a:	6a1b      	ldr	r3, [r3, #32]
 801256c:	2b00      	cmp	r3, #0
 801256e:	d006      	beq.n	801257e <_tx_event_flags_set+0x92>
        {

            /* Yes, we need to neutralize the delayed clearing as well.  */
            group_ptr -> tx_event_flags_group_delayed_clear =  
                                        group_ptr -> tx_event_flags_group_delayed_clear & ~flags_to_set;
 8012570:	68fb      	ldr	r3, [r7, #12]
 8012572:	6a1a      	ldr	r2, [r3, #32]
 8012574:	68bb      	ldr	r3, [r7, #8]
 8012576:	43db      	mvns	r3, r3
 8012578:	401a      	ands	r2, r3
            group_ptr -> tx_event_flags_group_delayed_clear =  
 801257a:	68fb      	ldr	r3, [r7, #12]
 801257c:	621a      	str	r2, [r3, #32]
        }
#endif

        /* Clear the preempt check flag.  */
        preempt_check =  TX_FALSE;
 801257e:	2300      	movs	r3, #0
 8012580:	677b      	str	r3, [r7, #116]	; 0x74

        /* Pickup the thread suspended count.  */
        suspended_count =  group_ptr -> tx_event_flags_group_suspended_count;
 8012582:	68fb      	ldr	r3, [r7, #12]
 8012584:	695b      	ldr	r3, [r3, #20]
 8012586:	f8c7 3080 	str.w	r3, [r7, #128]	; 0x80

        /* Determine if there are any threads suspended on the event flag group.  */
        if (group_ptr -> tx_event_flags_group_suspension_list != TX_NULL)
 801258a:	68fb      	ldr	r3, [r7, #12]
 801258c:	691b      	ldr	r3, [r3, #16]
 801258e:	2b00      	cmp	r3, #0
 8012590:	f000 81a6 	beq.w	80128e0 <_tx_event_flags_set+0x3f4>
        {

            /* Determine if there is just a single thread waiting on the event 
               flag group.  */
            if (suspended_count == ((UINT) 1))
 8012594:	f8d7 3080 	ldr.w	r3, [r7, #128]	; 0x80
 8012598:	2b01      	cmp	r3, #1
 801259a:	d169      	bne.n	8012670 <_tx_event_flags_set+0x184>

                /* Single thread waiting for event flags.  Bypass the multiple thread
                   logic.  */

                /* Setup thread pointer.  */
                thread_ptr =  group_ptr -> tx_event_flags_group_suspension_list;
 801259c:	68fb      	ldr	r3, [r7, #12]
 801259e:	691b      	ldr	r3, [r3, #16]
 80125a0:	f8c7 3090 	str.w	r3, [r7, #144]	; 0x90

                /* Pickup the current event flags.  */
                current_event_flags =  group_ptr -> tx_event_flags_group_current;
 80125a4:	68fb      	ldr	r3, [r7, #12]
 80125a6:	689b      	ldr	r3, [r3, #8]
 80125a8:	67fb      	str	r3, [r7, #124]	; 0x7c
            
                /* Pickup the suspend information.  */
                requested_flags =  thread_ptr -> tx_thread_suspend_info;
 80125aa:	f8d7 3090 	ldr.w	r3, [r7, #144]	; 0x90
 80125ae:	6f9b      	ldr	r3, [r3, #120]	; 0x78
 80125b0:	66bb      	str	r3, [r7, #104]	; 0x68

                /* Pickup the suspend option.  */
                get_option =  thread_ptr -> tx_thread_suspend_option;
 80125b2:	f8d7 3090 	ldr.w	r3, [r7, #144]	; 0x90
 80125b6:	f8d3 3080 	ldr.w	r3, [r3, #128]	; 0x80
 80125ba:	667b      	str	r3, [r7, #100]	; 0x64

                /* Isolate the AND selection.  */
                and_request =  (get_option & TX_AND);
 80125bc:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 80125be:	f003 0302 	and.w	r3, r3, #2
 80125c2:	663b      	str	r3, [r7, #96]	; 0x60

                /* Check for AND condition. All flags must be present to satisfy request.  */
                if (and_request == TX_AND)
 80125c4:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 80125c6:	2b02      	cmp	r3, #2
 80125c8:	d10a      	bne.n	80125e0 <_tx_event_flags_set+0xf4>
                {
    
                    /* AND request is present.  */
        
                    /* Calculate the flags present.  */
                    flags_satisfied =  (current_event_flags & requested_flags);
 80125ca:	6ffa      	ldr	r2, [r7, #124]	; 0x7c
 80125cc:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 80125ce:	4013      	ands	r3, r2
 80125d0:	67bb      	str	r3, [r7, #120]	; 0x78
        
                    /* Determine if they satisfy the AND request.  */
                    if (flags_satisfied != requested_flags)
 80125d2:	6fba      	ldr	r2, [r7, #120]	; 0x78
 80125d4:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 80125d6:	429a      	cmp	r2, r3
 80125d8:	d006      	beq.n	80125e8 <_tx_event_flags_set+0xfc>
                    {
        
                        /* No, not all the requested flags are present. Clear the flags present variable.  */
                        flags_satisfied =  ((ULONG) 0);
 80125da:	2300      	movs	r3, #0
 80125dc:	67bb      	str	r3, [r7, #120]	; 0x78
 80125de:	e003      	b.n	80125e8 <_tx_event_flags_set+0xfc>
                }
                else
                {

                    /* OR request is present. Simply or the requested flags and the current flags.  */
                    flags_satisfied =  (current_event_flags & requested_flags);
 80125e0:	6ffa      	ldr	r2, [r7, #124]	; 0x7c
 80125e2:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 80125e4:	4013      	ands	r3, r2
 80125e6:	67bb      	str	r3, [r7, #120]	; 0x78
                }
    
                /* Determine if the request is satisfied.  */
                if (flags_satisfied != ((ULONG) 0))
 80125e8:	6fbb      	ldr	r3, [r7, #120]	; 0x78
 80125ea:	2b00      	cmp	r3, #0
 80125ec:	f000 817f 	beq.w	80128ee <_tx_event_flags_set+0x402>

                    /* Yes, resume the thread and apply any event flag
                       clearing.  */

                    /* Set the preempt check flag.  */
                    preempt_check =  TX_TRUE;
 80125f0:	2301      	movs	r3, #1
 80125f2:	677b      	str	r3, [r7, #116]	; 0x74

                    /* Return the actual event flags that satisfied the request.  */
                    suspend_info_ptr =   TX_VOID_TO_ULONG_POINTER_CONVERT(thread_ptr -> tx_thread_additional_suspend_info);
 80125f4:	f8d7 3090 	ldr.w	r3, [r7, #144]	; 0x90
 80125f8:	6fdb      	ldr	r3, [r3, #124]	; 0x7c
 80125fa:	65fb      	str	r3, [r7, #92]	; 0x5c
                    *suspend_info_ptr =  current_event_flags;
 80125fc:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 80125fe:	6ffa      	ldr	r2, [r7, #124]	; 0x7c
 8012600:	601a      	str	r2, [r3, #0]

                    /* Pickup the clear bit.  */
                    clear_request =  (get_option & TX_EVENT_FLAGS_CLEAR_MASK);
 8012602:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 8012604:	f003 0301 	and.w	r3, r3, #1
 8012608:	65bb      	str	r3, [r7, #88]	; 0x58

                    /* Determine whether or not clearing needs to take place.  */
                    if (clear_request == TX_TRUE)
 801260a:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 801260c:	2b01      	cmp	r3, #1
 801260e:	d106      	bne.n	801261e <_tx_event_flags_set+0x132>
                    {

                        /* Yes, clear the flags that satisfied this request.  */
                        group_ptr -> tx_event_flags_group_current =  group_ptr -> tx_event_flags_group_current & (~requested_flags);
 8012610:	68fb      	ldr	r3, [r7, #12]
 8012612:	689a      	ldr	r2, [r3, #8]
 8012614:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 8012616:	43db      	mvns	r3, r3
 8012618:	401a      	ands	r2, r3
 801261a:	68fb      	ldr	r3, [r7, #12]
 801261c:	609a      	str	r2, [r3, #8]
                    }

                    /* Clear the suspension information in the event flag group.  */
                    group_ptr -> tx_event_flags_group_suspension_list =  TX_NULL;
 801261e:	68fb      	ldr	r3, [r7, #12]
 8012620:	2200      	movs	r2, #0
 8012622:	611a      	str	r2, [r3, #16]
                    group_ptr -> tx_event_flags_group_suspended_count =  TX_NO_SUSPENSIONS;
 8012624:	68fb      	ldr	r3, [r7, #12]
 8012626:	2200      	movs	r2, #0
 8012628:	615a      	str	r2, [r3, #20]

                    /* Clear cleanup routine to avoid timeout.  */
                    thread_ptr -> tx_thread_suspend_cleanup =  TX_NULL;
 801262a:	f8d7 3090 	ldr.w	r3, [r7, #144]	; 0x90
 801262e:	2200      	movs	r2, #0
 8012630:	669a      	str	r2, [r3, #104]	; 0x68

                    /* Put return status into the thread control block.  */
                    thread_ptr -> tx_thread_suspend_status =  TX_SUCCESS;
 8012632:	f8d7 3090 	ldr.w	r3, [r7, #144]	; 0x90
 8012636:	2200      	movs	r2, #0
 8012638:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84
                    /* Resume the thread!  */
                    _tx_thread_system_ni_resume(thread_ptr);
#else

                    /* Temporarily disable preemption.  */
                    _tx_thread_preempt_disable++;
 801263c:	4ba7      	ldr	r3, [pc, #668]	; (80128dc <_tx_event_flags_set+0x3f0>)
 801263e:	681b      	ldr	r3, [r3, #0]
 8012640:	3301      	adds	r3, #1
 8012642:	4aa6      	ldr	r2, [pc, #664]	; (80128dc <_tx_event_flags_set+0x3f0>)
 8012644:	6013      	str	r3, [r2, #0]
 8012646:	f8d7 3094 	ldr.w	r3, [r7, #148]	; 0x94
 801264a:	63bb      	str	r3, [r7, #56]	; 0x38
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 801264c:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 801264e:	f383 8810 	msr	PRIMASK, r3
}
 8012652:	bf00      	nop

                    /* Restore interrupts.  */
                    TX_RESTORE

                    /* Resume thread.  */
                    _tx_thread_system_resume(thread_ptr);
 8012654:	f8d7 0090 	ldr.w	r0, [r7, #144]	; 0x90
 8012658:	f002 fb66 	bl	8014d28 <_tx_thread_system_resume>
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 801265c:	f3ef 8310 	mrs	r3, PRIMASK
 8012660:	643b      	str	r3, [r7, #64]	; 0x40
    return(posture);
 8012662:	6c3b      	ldr	r3, [r7, #64]	; 0x40
    int_posture = __get_interrupt_posture();
 8012664:	63fb      	str	r3, [r7, #60]	; 0x3c
    __asm__ volatile ("CPSID i" : : : "memory");
 8012666:	b672      	cpsid	i
    return(int_posture);
 8012668:	6bfb      	ldr	r3, [r7, #60]	; 0x3c

                    /* Disable interrupts to remove the semaphore from the created list.  */
                    TX_DISABLE
 801266a:	f8c7 3094 	str.w	r3, [r7, #148]	; 0x94
 801266e:	e13e      	b.n	80128ee <_tx_event_flags_set+0x402>

                /* Otherwise, the event flag requests of multiple threads must be 
                   examined.  */

                /* Setup thread pointer, keep a local copy of the head pointer.  */
                suspended_list =  group_ptr -> tx_event_flags_group_suspension_list;
 8012670:	68fb      	ldr	r3, [r7, #12]
 8012672:	691b      	ldr	r3, [r3, #16]
 8012674:	f8c7 3084 	str.w	r3, [r7, #132]	; 0x84
                thread_ptr =      suspended_list;
 8012678:	f8d7 3084 	ldr.w	r3, [r7, #132]	; 0x84
 801267c:	f8c7 3090 	str.w	r3, [r7, #144]	; 0x90

                /* Clear the suspended list head pointer to thwart manipulation of
                   the list in ISR's while we are processing here.  */
                group_ptr -> tx_event_flags_group_suspension_list =  TX_NULL;
 8012680:	68fb      	ldr	r3, [r7, #12]
 8012682:	2200      	movs	r2, #0
 8012684:	611a      	str	r2, [r3, #16]
        
                /* Setup the satisfied thread pointers.  */
                satisfied_list =  TX_NULL;
 8012686:	2300      	movs	r3, #0
 8012688:	f8c7 308c 	str.w	r3, [r7, #140]	; 0x8c
                last_satisfied =  TX_NULL;
 801268c:	2300      	movs	r3, #0
 801268e:	f8c7 3088 	str.w	r3, [r7, #136]	; 0x88

                /* Pickup the current event flags.  */
                current_event_flags =  group_ptr -> tx_event_flags_group_current;
 8012692:	68fb      	ldr	r3, [r7, #12]
 8012694:	689b      	ldr	r3, [r3, #8]
 8012696:	67fb      	str	r3, [r7, #124]	; 0x7c

                /* Disable preemption while we process the suspended list.  */
                _tx_thread_preempt_disable++;
 8012698:	4b90      	ldr	r3, [pc, #576]	; (80128dc <_tx_event_flags_set+0x3f0>)
 801269a:	681b      	ldr	r3, [r3, #0]
 801269c:	3301      	adds	r3, #1
 801269e:	4a8f      	ldr	r2, [pc, #572]	; (80128dc <_tx_event_flags_set+0x3f0>)
 80126a0:	6013      	str	r3, [r2, #0]
 80126a2:	f8d7 3094 	ldr.w	r3, [r7, #148]	; 0x94
 80126a6:	62fb      	str	r3, [r7, #44]	; 0x2c
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 80126a8:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 80126aa:	f383 8810 	msr	PRIMASK, r3
}
 80126ae:	bf00      	nop
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 80126b0:	f3ef 8310 	mrs	r3, PRIMASK
 80126b4:	637b      	str	r3, [r7, #52]	; 0x34
    return(posture);
 80126b6:	6b7b      	ldr	r3, [r7, #52]	; 0x34
    int_posture = __get_interrupt_posture();
 80126b8:	633b      	str	r3, [r7, #48]	; 0x30
    __asm__ volatile ("CPSID i" : : : "memory");
 80126ba:	b672      	cpsid	i
    return(int_posture);
 80126bc:	6b3b      	ldr	r3, [r7, #48]	; 0x30

                    /* Restore interrupts temporarily.  */
                    TX_RESTORE

                    /* Disable interrupts again.  */
                    TX_DISABLE
 80126be:	f8c7 3094 	str.w	r3, [r7, #148]	; 0x94
#endif

                    /* Determine if we need to reset the search.  */
                    if (group_ptr -> tx_event_flags_group_reset_search != TX_FALSE)
 80126c2:	68fb      	ldr	r3, [r7, #12]
 80126c4:	68db      	ldr	r3, [r3, #12]
 80126c6:	2b00      	cmp	r3, #0
 80126c8:	d00f      	beq.n	80126ea <_tx_event_flags_set+0x1fe>
                    {

                        /* Clear the reset search flag.  */
                        group_ptr -> tx_event_flags_group_reset_search =  TX_FALSE;
 80126ca:	68fb      	ldr	r3, [r7, #12]
 80126cc:	2200      	movs	r2, #0
 80126ce:	60da      	str	r2, [r3, #12]

                        /* Move the thread pointer to the beginning of the search list.  */
                        thread_ptr =  suspended_list;
 80126d0:	f8d7 3084 	ldr.w	r3, [r7, #132]	; 0x84
 80126d4:	f8c7 3090 	str.w	r3, [r7, #144]	; 0x90

                        /* Reset the suspended count.  */
                        suspended_count =  group_ptr -> tx_event_flags_group_suspended_count;
 80126d8:	68fb      	ldr	r3, [r7, #12]
 80126da:	695b      	ldr	r3, [r3, #20]
 80126dc:	f8c7 3080 	str.w	r3, [r7, #128]	; 0x80

                        /* Update the current events with any new ones that might
                           have been set in a nested set events call from an ISR.  */
                        current_event_flags =  current_event_flags | group_ptr -> tx_event_flags_group_current;
 80126e0:	68fb      	ldr	r3, [r7, #12]
 80126e2:	689b      	ldr	r3, [r3, #8]
 80126e4:	6ffa      	ldr	r2, [r7, #124]	; 0x7c
 80126e6:	4313      	orrs	r3, r2
 80126e8:	67fb      	str	r3, [r7, #124]	; 0x7c
                    }

                    /* Save next thread pointer.  */
                    next_thread_ptr =  thread_ptr -> tx_thread_suspended_next;
 80126ea:	f8d7 3090 	ldr.w	r3, [r7, #144]	; 0x90
 80126ee:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 80126f0:	66fb      	str	r3, [r7, #108]	; 0x6c

                    /* Pickup the suspend information.  */
                    requested_flags =  thread_ptr -> tx_thread_suspend_info;
 80126f2:	f8d7 3090 	ldr.w	r3, [r7, #144]	; 0x90
 80126f6:	6f9b      	ldr	r3, [r3, #120]	; 0x78
 80126f8:	66bb      	str	r3, [r7, #104]	; 0x68

                    /* Pickup this thread's suspension get option.  */
                    get_option =  thread_ptr -> tx_thread_suspend_option;
 80126fa:	f8d7 3090 	ldr.w	r3, [r7, #144]	; 0x90
 80126fe:	f8d3 3080 	ldr.w	r3, [r3, #128]	; 0x80
 8012702:	667b      	str	r3, [r7, #100]	; 0x64

                    /* Isolate the AND selection.  */
                    and_request =  (get_option & TX_AND);
 8012704:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 8012706:	f003 0302 	and.w	r3, r3, #2
 801270a:	663b      	str	r3, [r7, #96]	; 0x60

                    /* Check for AND condition. All flags must be present to satisfy request.  */
                    if (and_request == TX_AND)
 801270c:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 801270e:	2b02      	cmp	r3, #2
 8012710:	d10a      	bne.n	8012728 <_tx_event_flags_set+0x23c>
                    {
    
                        /* AND request is present.  */
        
                        /* Calculate the flags present.  */
                        flags_satisfied =  (current_event_flags & requested_flags);
 8012712:	6ffa      	ldr	r2, [r7, #124]	; 0x7c
 8012714:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 8012716:	4013      	ands	r3, r2
 8012718:	67bb      	str	r3, [r7, #120]	; 0x78
        
                        /* Determine if they satisfy the AND request.  */
                        if (flags_satisfied != requested_flags)
 801271a:	6fba      	ldr	r2, [r7, #120]	; 0x78
 801271c:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 801271e:	429a      	cmp	r2, r3
 8012720:	d006      	beq.n	8012730 <_tx_event_flags_set+0x244>
                        {
        
                            /* No, not all the requested flags are present. Clear the flags present variable.  */
                            flags_satisfied =  ((ULONG) 0);
 8012722:	2300      	movs	r3, #0
 8012724:	67bb      	str	r3, [r7, #120]	; 0x78
 8012726:	e003      	b.n	8012730 <_tx_event_flags_set+0x244>
                    }
                    else
                    {

                        /* OR request is present. Simply or the requested flags and the current flags.  */
                        flags_satisfied =  (current_event_flags & requested_flags);
 8012728:	6ffa      	ldr	r2, [r7, #124]	; 0x7c
 801272a:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 801272c:	4013      	ands	r3, r2
 801272e:	67bb      	str	r3, [r7, #120]	; 0x78
                    }
    
                    /* Check to see if the thread had a timeout or wait abort during the event search processing.  
                       If so, just set the flags satisfied to ensure the processing here removes the thread from 
                       the suspension list.  */
                    if (thread_ptr -> tx_thread_state != TX_EVENT_FLAG)
 8012730:	f8d7 3090 	ldr.w	r3, [r7, #144]	; 0x90
 8012734:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8012736:	2b07      	cmp	r3, #7
 8012738:	d001      	beq.n	801273e <_tx_event_flags_set+0x252>
                    {
            
                       /* Simply set the satisfied flags to 1 in order to remove the thread from the suspension list.  */
                        flags_satisfied =  ((ULONG) 1);
 801273a:	2301      	movs	r3, #1
 801273c:	67bb      	str	r3, [r7, #120]	; 0x78
                    }

                    /* Determine if the request is satisfied.  */
                    if (flags_satisfied != ((ULONG) 0))
 801273e:	6fbb      	ldr	r3, [r7, #120]	; 0x78
 8012740:	2b00      	cmp	r3, #0
 8012742:	d06b      	beq.n	801281c <_tx_event_flags_set+0x330>
                    {

                        /* Yes, this request can be handled now.  */

                        /* Set the preempt check flag.  */
                        preempt_check =  TX_TRUE;
 8012744:	2301      	movs	r3, #1
 8012746:	677b      	str	r3, [r7, #116]	; 0x74
    
                        /* Determine if the thread is still suspended on the event flag group. If not, a wait
                           abort must have been done from an ISR.  */
                        if (thread_ptr -> tx_thread_state == TX_EVENT_FLAG)
 8012748:	f8d7 3090 	ldr.w	r3, [r7, #144]	; 0x90
 801274c:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 801274e:	2b07      	cmp	r3, #7
 8012750:	d11d      	bne.n	801278e <_tx_event_flags_set+0x2a2>
                        {

                            /* Return the actual event flags that satisfied the request.  */
                            suspend_info_ptr =   TX_VOID_TO_ULONG_POINTER_CONVERT(thread_ptr -> tx_thread_additional_suspend_info);
 8012752:	f8d7 3090 	ldr.w	r3, [r7, #144]	; 0x90
 8012756:	6fdb      	ldr	r3, [r3, #124]	; 0x7c
 8012758:	65fb      	str	r3, [r7, #92]	; 0x5c
                            *suspend_info_ptr =  current_event_flags;
 801275a:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 801275c:	6ffa      	ldr	r2, [r7, #124]	; 0x7c
 801275e:	601a      	str	r2, [r3, #0]

                            /* Pickup the clear bit.  */
                            clear_request =  (get_option & TX_EVENT_FLAGS_CLEAR_MASK);
 8012760:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 8012762:	f003 0301 	and.w	r3, r3, #1
 8012766:	65bb      	str	r3, [r7, #88]	; 0x58

                            /* Determine whether or not clearing needs to take place.  */
                            if (clear_request == TX_TRUE)
 8012768:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 801276a:	2b01      	cmp	r3, #1
 801276c:	d106      	bne.n	801277c <_tx_event_flags_set+0x290>
                            {
                
                                /* Yes, clear the flags that satisfied this request.  */
                                group_ptr -> tx_event_flags_group_current =  group_ptr -> tx_event_flags_group_current & ~requested_flags;
 801276e:	68fb      	ldr	r3, [r7, #12]
 8012770:	689a      	ldr	r2, [r3, #8]
 8012772:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 8012774:	43db      	mvns	r3, r3
 8012776:	401a      	ands	r2, r3
 8012778:	68fb      	ldr	r3, [r7, #12]
 801277a:	609a      	str	r2, [r3, #8]
                            }
            
                            /* Prepare for resumption of the first thread.  */

                            /* Clear cleanup routine to avoid timeout.  */
                            thread_ptr -> tx_thread_suspend_cleanup =  TX_NULL;
 801277c:	f8d7 3090 	ldr.w	r3, [r7, #144]	; 0x90
 8012780:	2200      	movs	r2, #0
 8012782:	669a      	str	r2, [r3, #104]	; 0x68

                            /* Put return status into the thread control block.  */
                            thread_ptr -> tx_thread_suspend_status =  TX_SUCCESS;
 8012784:	f8d7 3090 	ldr.w	r3, [r7, #144]	; 0x90
 8012788:	2200      	movs	r2, #0
 801278a:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84

                        /* We need to remove the thread from the suspension list and place it in the
                           expired list.  */

                        /* See if this is the only suspended thread on the list.  */
                        if (thread_ptr == thread_ptr -> tx_thread_suspended_next)
 801278e:	f8d7 3090 	ldr.w	r3, [r7, #144]	; 0x90
 8012792:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 8012794:	f8d7 2090 	ldr.w	r2, [r7, #144]	; 0x90
 8012798:	429a      	cmp	r2, r3
 801279a:	d103      	bne.n	80127a4 <_tx_event_flags_set+0x2b8>
                        {

                            /* Yes, the only suspended thread.  */

                            /* Update the head pointer.  */
                            suspended_list =  TX_NULL;
 801279c:	2300      	movs	r3, #0
 801279e:	f8c7 3084 	str.w	r3, [r7, #132]	; 0x84
 80127a2:	e018      	b.n	80127d6 <_tx_event_flags_set+0x2ea>
                        {

                            /* At least one more thread is on the same expiration list.  */

                            /* Update the links of the adjacent threads.  */
                            next_thread =                                  thread_ptr -> tx_thread_suspended_next;
 80127a4:	f8d7 3090 	ldr.w	r3, [r7, #144]	; 0x90
 80127a8:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 80127aa:	657b      	str	r3, [r7, #84]	; 0x54
                            previous_thread =                              thread_ptr -> tx_thread_suspended_previous;
 80127ac:	f8d7 3090 	ldr.w	r3, [r7, #144]	; 0x90
 80127b0:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 80127b2:	653b      	str	r3, [r7, #80]	; 0x50
                            next_thread -> tx_thread_suspended_previous =  previous_thread;
 80127b4:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 80127b6:	6d3a      	ldr	r2, [r7, #80]	; 0x50
 80127b8:	675a      	str	r2, [r3, #116]	; 0x74
                            previous_thread -> tx_thread_suspended_next =  next_thread;
 80127ba:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 80127bc:	6d7a      	ldr	r2, [r7, #84]	; 0x54
 80127be:	671a      	str	r2, [r3, #112]	; 0x70

                            /* Update the list head pointer, if removing the head of the
                               list.  */
                            if (suspended_list == thread_ptr)
 80127c0:	f8d7 2084 	ldr.w	r2, [r7, #132]	; 0x84
 80127c4:	f8d7 3090 	ldr.w	r3, [r7, #144]	; 0x90
 80127c8:	429a      	cmp	r2, r3
 80127ca:	d104      	bne.n	80127d6 <_tx_event_flags_set+0x2ea>
                            {
                                
                                /* Yes, head pointer needs to be updated.  */
                                suspended_list =  thread_ptr -> tx_thread_suspended_next;
 80127cc:	f8d7 3090 	ldr.w	r3, [r7, #144]	; 0x90
 80127d0:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 80127d2:	f8c7 3084 	str.w	r3, [r7, #132]	; 0x84
                            }
                        }

                        /* Decrement the suspension count.  */
                        group_ptr -> tx_event_flags_group_suspended_count--;
 80127d6:	68fb      	ldr	r3, [r7, #12]
 80127d8:	695b      	ldr	r3, [r3, #20]
 80127da:	1e5a      	subs	r2, r3, #1
 80127dc:	68fb      	ldr	r3, [r7, #12]
 80127de:	615a      	str	r2, [r3, #20]

                        /* Place this thread on the expired list.  */
                        if (satisfied_list == TX_NULL)
 80127e0:	f8d7 308c 	ldr.w	r3, [r7, #140]	; 0x8c
 80127e4:	2b00      	cmp	r3, #0
 80127e6:	d10c      	bne.n	8012802 <_tx_event_flags_set+0x316>
                        {

                            /* First thread on the satisfied list.  */
                            satisfied_list =  thread_ptr;
 80127e8:	f8d7 3090 	ldr.w	r3, [r7, #144]	; 0x90
 80127ec:	f8c7 308c 	str.w	r3, [r7, #140]	; 0x8c
                            last_satisfied =  thread_ptr;
 80127f0:	f8d7 3090 	ldr.w	r3, [r7, #144]	; 0x90
 80127f4:	f8c7 3088 	str.w	r3, [r7, #136]	; 0x88
    
                            /* Setup initial next pointer.  */
                            thread_ptr -> tx_thread_suspended_next =  TX_NULL;
 80127f8:	f8d7 3090 	ldr.w	r3, [r7, #144]	; 0x90
 80127fc:	2200      	movs	r2, #0
 80127fe:	671a      	str	r2, [r3, #112]	; 0x70
 8012800:	e00c      	b.n	801281c <_tx_event_flags_set+0x330>
                        {

                            /* Not the first thread on the satisfied list.  */
                
                            /* Link it up at the end.  */
                            last_satisfied -> tx_thread_suspended_next =  thread_ptr;
 8012802:	f8d7 3088 	ldr.w	r3, [r7, #136]	; 0x88
 8012806:	f8d7 2090 	ldr.w	r2, [r7, #144]	; 0x90
 801280a:	671a      	str	r2, [r3, #112]	; 0x70
                            thread_ptr -> tx_thread_suspended_next =      TX_NULL;
 801280c:	f8d7 3090 	ldr.w	r3, [r7, #144]	; 0x90
 8012810:	2200      	movs	r2, #0
 8012812:	671a      	str	r2, [r3, #112]	; 0x70
                            last_satisfied =                              thread_ptr;
 8012814:	f8d7 3090 	ldr.w	r3, [r7, #144]	; 0x90
 8012818:	f8c7 3088 	str.w	r3, [r7, #136]	; 0x88
                        }
                    }

                    /* Copy next thread pointer to working thread ptr.  */
                    thread_ptr =  next_thread_ptr;
 801281c:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 801281e:	f8c7 3090 	str.w	r3, [r7, #144]	; 0x90

                    /* Decrement the suspension count.  */
                    suspended_count--;
 8012822:	f8d7 3080 	ldr.w	r3, [r7, #128]	; 0x80
 8012826:	3b01      	subs	r3, #1
 8012828:	f8c7 3080 	str.w	r3, [r7, #128]	; 0x80
            
                } while (suspended_count != TX_NO_SUSPENSIONS);
 801282c:	f8d7 3080 	ldr.w	r3, [r7, #128]	; 0x80
 8012830:	2b00      	cmp	r3, #0
 8012832:	f47f af36 	bne.w	80126a2 <_tx_event_flags_set+0x1b6>

                /* Setup the group's suspension list head again.  */
                group_ptr -> tx_event_flags_group_suspension_list =  suspended_list;
 8012836:	68fb      	ldr	r3, [r7, #12]
 8012838:	f8d7 2084 	ldr.w	r2, [r7, #132]	; 0x84
 801283c:	611a      	str	r2, [r3, #16]

#ifndef TX_NOT_INTERRUPTABLE

                /* Determine if there is any delayed event clearing to perform.  */
                if (group_ptr -> tx_event_flags_group_delayed_clear != ((ULONG) 0))
 801283e:	68fb      	ldr	r3, [r7, #12]
 8012840:	6a1b      	ldr	r3, [r3, #32]
 8012842:	2b00      	cmp	r3, #0
 8012844:	d00a      	beq.n	801285c <_tx_event_flags_set+0x370>
                {

                    /* Perform the delayed event clearing.  */
                    group_ptr -> tx_event_flags_group_current =
                        group_ptr -> tx_event_flags_group_current & ~(group_ptr -> tx_event_flags_group_delayed_clear);
 8012846:	68fb      	ldr	r3, [r7, #12]
 8012848:	689a      	ldr	r2, [r3, #8]
 801284a:	68fb      	ldr	r3, [r7, #12]
 801284c:	6a1b      	ldr	r3, [r3, #32]
 801284e:	43db      	mvns	r3, r3
 8012850:	401a      	ands	r2, r3
                    group_ptr -> tx_event_flags_group_current =
 8012852:	68fb      	ldr	r3, [r7, #12]
 8012854:	609a      	str	r2, [r3, #8]

                    /* Clear the delayed event flag clear value.  */
                    group_ptr -> tx_event_flags_group_delayed_clear =  ((ULONG) 0);
 8012856:	68fb      	ldr	r3, [r7, #12]
 8012858:	2200      	movs	r2, #0
 801285a:	621a      	str	r2, [r3, #32]
 801285c:	f8d7 3094 	ldr.w	r3, [r7, #148]	; 0x94
 8012860:	62bb      	str	r3, [r7, #40]	; 0x28
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 8012862:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8012864:	f383 8810 	msr	PRIMASK, r3
}
 8012868:	bf00      	nop

                /* Restore interrupts.  */
                TX_RESTORE

                /* Walk through the satisfied list, setup initial thread pointer. */
                thread_ptr =  satisfied_list;
 801286a:	f8d7 308c 	ldr.w	r3, [r7, #140]	; 0x8c
 801286e:	f8c7 3090 	str.w	r3, [r7, #144]	; 0x90
                while(thread_ptr != TX_NULL)
 8012872:	e01f      	b.n	80128b4 <_tx_event_flags_set+0x3c8>
                {
    
                    /* Get next pointer first.  */
                    next_thread_ptr =  thread_ptr -> tx_thread_suspended_next;
 8012874:	f8d7 3090 	ldr.w	r3, [r7, #144]	; 0x90
 8012878:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 801287a:	66fb      	str	r3, [r7, #108]	; 0x6c
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 801287c:	f3ef 8310 	mrs	r3, PRIMASK
 8012880:	623b      	str	r3, [r7, #32]
    return(posture);
 8012882:	6a3b      	ldr	r3, [r7, #32]
    int_posture = __get_interrupt_posture();
 8012884:	61fb      	str	r3, [r7, #28]
    __asm__ volatile ("CPSID i" : : : "memory");
 8012886:	b672      	cpsid	i
    return(int_posture);
 8012888:	69fb      	ldr	r3, [r7, #28]

                    /* Disable interrupts.  */
                    TX_DISABLE
 801288a:	f8c7 3094 	str.w	r3, [r7, #148]	; 0x94
                    /* Restore interrupts.  */
                    TX_RESTORE
#else

                    /* Disable preemption again.  */
                    _tx_thread_preempt_disable++;
 801288e:	4b13      	ldr	r3, [pc, #76]	; (80128dc <_tx_event_flags_set+0x3f0>)
 8012890:	681b      	ldr	r3, [r3, #0]
 8012892:	3301      	adds	r3, #1
 8012894:	4a11      	ldr	r2, [pc, #68]	; (80128dc <_tx_event_flags_set+0x3f0>)
 8012896:	6013      	str	r3, [r2, #0]
 8012898:	f8d7 3094 	ldr.w	r3, [r7, #148]	; 0x94
 801289c:	627b      	str	r3, [r7, #36]	; 0x24
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 801289e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80128a0:	f383 8810 	msr	PRIMASK, r3
}
 80128a4:	bf00      	nop

                    /* Restore interrupt posture.  */
                    TX_RESTORE

                    /* Resume the thread.  */
                    _tx_thread_system_resume(thread_ptr);
 80128a6:	f8d7 0090 	ldr.w	r0, [r7, #144]	; 0x90
 80128aa:	f002 fa3d 	bl	8014d28 <_tx_thread_system_resume>
#endif

                    /* Move next thread to current.  */
                    thread_ptr =  next_thread_ptr;
 80128ae:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 80128b0:	f8c7 3090 	str.w	r3, [r7, #144]	; 0x90
                while(thread_ptr != TX_NULL)
 80128b4:	f8d7 3090 	ldr.w	r3, [r7, #144]	; 0x90
 80128b8:	2b00      	cmp	r3, #0
 80128ba:	d1db      	bne.n	8012874 <_tx_event_flags_set+0x388>
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 80128bc:	f3ef 8310 	mrs	r3, PRIMASK
 80128c0:	61bb      	str	r3, [r7, #24]
    return(posture);
 80128c2:	69bb      	ldr	r3, [r7, #24]
    int_posture = __get_interrupt_posture();
 80128c4:	617b      	str	r3, [r7, #20]
    __asm__ volatile ("CPSID i" : : : "memory");
 80128c6:	b672      	cpsid	i
    return(int_posture);
 80128c8:	697b      	ldr	r3, [r7, #20]
                }

                /* Disable interrupts.  */
                TX_DISABLE
 80128ca:	f8c7 3094 	str.w	r3, [r7, #148]	; 0x94

                /* Release thread preemption disable.  */
                _tx_thread_preempt_disable--;
 80128ce:	4b03      	ldr	r3, [pc, #12]	; (80128dc <_tx_event_flags_set+0x3f0>)
 80128d0:	681b      	ldr	r3, [r3, #0]
 80128d2:	3b01      	subs	r3, #1
 80128d4:	4a01      	ldr	r2, [pc, #4]	; (80128dc <_tx_event_flags_set+0x3f0>)
 80128d6:	6013      	str	r3, [r2, #0]
 80128d8:	e009      	b.n	80128ee <_tx_event_flags_set+0x402>
 80128da:	bf00      	nop
 80128dc:	24031c5c 	.word	0x24031c5c
        }
        else
        {

            /* Determine if we need to set the reset search field.  */
            if (group_ptr -> tx_event_flags_group_suspended_count != TX_NO_SUSPENSIONS)
 80128e0:	68fb      	ldr	r3, [r7, #12]
 80128e2:	695b      	ldr	r3, [r3, #20]
 80128e4:	2b00      	cmp	r3, #0
 80128e6:	d002      	beq.n	80128ee <_tx_event_flags_set+0x402>
            {
                    
                /* We interrupted a search of an event flag group suspension
                   list.  Make sure we reset the search.  */
                group_ptr -> tx_event_flags_group_reset_search =  TX_TRUE;
 80128e8:	68fb      	ldr	r3, [r7, #12]
 80128ea:	2201      	movs	r2, #1
 80128ec:	60da      	str	r2, [r3, #12]
 80128ee:	f8d7 3094 	ldr.w	r3, [r7, #148]	; 0x94
 80128f2:	613b      	str	r3, [r7, #16]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 80128f4:	693b      	ldr	r3, [r7, #16]
 80128f6:	f383 8810 	msr	PRIMASK, r3
}
 80128fa:	bf00      	nop
            (events_set_notify)(group_ptr);
        }
#endif

        /* Determine if a check for preemption is necessary.  */
        if (preempt_check == TX_TRUE)
 80128fc:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 80128fe:	2b01      	cmp	r3, #1
 8012900:	d101      	bne.n	8012906 <_tx_event_flags_set+0x41a>
        {

            /* Yes, one or more threads were resumed, check for preemption.  */
            _tx_thread_system_preempt_check();
 8012902:	f002 f9d7 	bl	8014cb4 <_tx_thread_system_preempt_check>
        }
    }

    /* Return completion status.  */
    return(TX_SUCCESS);
 8012906:	2300      	movs	r3, #0
}
 8012908:	4618      	mov	r0, r3
 801290a:	3798      	adds	r7, #152	; 0x98
 801290c:	46bd      	mov	sp, r7
 801290e:	bd80      	pop	{r7, pc}

08012910 <_tx_initialize_high_level>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
VOID    _tx_initialize_high_level(VOID)
{
 8012910:	b580      	push	{r7, lr}
 8012912:	af00      	add	r7, sp, #0

    /* Initialize the event log, if enabled.  */
    TX_EL_INITIALIZE

    /* Call the thread control initialization function.  */
    _tx_thread_initialize();
 8012914:	f001 ff8c 	bl	8014830 <_tx_thread_initialize>

#ifndef TX_NO_TIMER

    /* Call the timer control initialization function.  */
    _tx_timer_initialize();
 8012918:	f002 ff26 	bl	8015768 <_tx_timer_initialize>
#endif

#ifndef TX_DISABLE_REDUNDANT_CLEARING

    /* Call the semaphore initialization function.  */
    _tx_semaphore_initialize();
 801291c:	4b12      	ldr	r3, [pc, #72]	; (8012968 <_tx_initialize_high_level+0x58>)
 801291e:	2200      	movs	r2, #0
 8012920:	601a      	str	r2, [r3, #0]
 8012922:	4b12      	ldr	r3, [pc, #72]	; (801296c <_tx_initialize_high_level+0x5c>)
 8012924:	2200      	movs	r2, #0
 8012926:	601a      	str	r2, [r3, #0]

    /* Call the queue initialization function.  */
    _tx_queue_initialize();
 8012928:	4b11      	ldr	r3, [pc, #68]	; (8012970 <_tx_initialize_high_level+0x60>)
 801292a:	2200      	movs	r2, #0
 801292c:	601a      	str	r2, [r3, #0]
 801292e:	4b11      	ldr	r3, [pc, #68]	; (8012974 <_tx_initialize_high_level+0x64>)
 8012930:	2200      	movs	r2, #0
 8012932:	601a      	str	r2, [r3, #0]

    /* Call the event flag initialization function.  */
    _tx_event_flags_initialize();
 8012934:	4b10      	ldr	r3, [pc, #64]	; (8012978 <_tx_initialize_high_level+0x68>)
 8012936:	2200      	movs	r2, #0
 8012938:	601a      	str	r2, [r3, #0]
 801293a:	4b10      	ldr	r3, [pc, #64]	; (801297c <_tx_initialize_high_level+0x6c>)
 801293c:	2200      	movs	r2, #0
 801293e:	601a      	str	r2, [r3, #0]

    /* Call the block pool initialization function.  */
    _tx_block_pool_initialize();
 8012940:	4b0f      	ldr	r3, [pc, #60]	; (8012980 <_tx_initialize_high_level+0x70>)
 8012942:	2200      	movs	r2, #0
 8012944:	601a      	str	r2, [r3, #0]
 8012946:	4b0f      	ldr	r3, [pc, #60]	; (8012984 <_tx_initialize_high_level+0x74>)
 8012948:	2200      	movs	r2, #0
 801294a:	601a      	str	r2, [r3, #0]

    /* Call the byte pool initialization function.  */
    _tx_byte_pool_initialize();
 801294c:	4b0e      	ldr	r3, [pc, #56]	; (8012988 <_tx_initialize_high_level+0x78>)
 801294e:	2200      	movs	r2, #0
 8012950:	601a      	str	r2, [r3, #0]
 8012952:	4b0e      	ldr	r3, [pc, #56]	; (801298c <_tx_initialize_high_level+0x7c>)
 8012954:	2200      	movs	r2, #0
 8012956:	601a      	str	r2, [r3, #0]

    /* Call the mutex initialization function.  */
    _tx_mutex_initialize();
 8012958:	4b0d      	ldr	r3, [pc, #52]	; (8012990 <_tx_initialize_high_level+0x80>)
 801295a:	2200      	movs	r2, #0
 801295c:	601a      	str	r2, [r3, #0]
 801295e:	4b0d      	ldr	r3, [pc, #52]	; (8012994 <_tx_initialize_high_level+0x84>)
 8012960:	2200      	movs	r2, #0
 8012962:	601a      	str	r2, [r3, #0]
#endif
}
 8012964:	bf00      	nop
 8012966:	bd80      	pop	{r7, pc}
 8012968:	24031b8c 	.word	0x24031b8c
 801296c:	24031b90 	.word	0x24031b90
 8012970:	24031b94 	.word	0x24031b94
 8012974:	24031b98 	.word	0x24031b98
 8012978:	24031b9c 	.word	0x24031b9c
 801297c:	24031ba0 	.word	0x24031ba0
 8012980:	24031bac 	.word	0x24031bac
 8012984:	24031bb0 	.word	0x24031bb0
 8012988:	24031bb4 	.word	0x24031bb4
 801298c:	24031bb8 	.word	0x24031bb8
 8012990:	24031ba4 	.word	0x24031ba4
 8012994:	24031ba8 	.word	0x24031ba8

08012998 <_tx_initialize_kernel_enter>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
VOID  _tx_initialize_kernel_enter(VOID)
{
 8012998:	b580      	push	{r7, lr}
 801299a:	af00      	add	r7, sp, #0

    /* Determine if the compiler has pre-initialized ThreadX.  */
    if (_tx_thread_system_state != TX_INITIALIZE_ALMOST_DONE)
 801299c:	4b10      	ldr	r3, [pc, #64]	; (80129e0 <_tx_initialize_kernel_enter+0x48>)
 801299e:	681b      	ldr	r3, [r3, #0]
 80129a0:	f113 3f0f 	cmn.w	r3, #252645135	; 0xf0f0f0f
 80129a4:	d00c      	beq.n	80129c0 <_tx_initialize_kernel_enter+0x28>
        /* No, the initialization still needs to take place.  */

        /* Ensure that the system state variable is set to indicate 
           initialization is in progress.  Note that this variable is 
           later used to represent interrupt nesting.  */
        _tx_thread_system_state =  TX_INITIALIZE_IN_PROGRESS;
 80129a6:	4b0e      	ldr	r3, [pc, #56]	; (80129e0 <_tx_initialize_kernel_enter+0x48>)
 80129a8:	f04f 32f0 	mov.w	r2, #4042322160	; 0xf0f0f0f0
 80129ac:	601a      	str	r2, [r3, #0]
        /* Call any port specific preprocessing.  */
        TX_PORT_SPECIFIC_PRE_INITIALIZATION

        /* Invoke the low-level initialization to handle all processor specific
           initialization issues.  */
        _tx_initialize_low_level();
 80129ae:	f7ed fc97 	bl	80002e0 <_tx_initialize_low_level>
    
        /* Invoke the high-level initialization to exercise all of the 
           ThreadX components and the application's initialization 
           function.  */
        _tx_initialize_high_level();
 80129b2:	f7ff ffad 	bl	8012910 <_tx_initialize_high_level>

        /* Call any port specific post-processing.  */
        TX_PORT_SPECIFIC_POST_INITIALIZATION
 80129b6:	4b0b      	ldr	r3, [pc, #44]	; (80129e4 <_tx_initialize_kernel_enter+0x4c>)
 80129b8:	681b      	ldr	r3, [r3, #0]
 80129ba:	3301      	adds	r3, #1
 80129bc:	4a09      	ldr	r2, [pc, #36]	; (80129e4 <_tx_initialize_kernel_enter+0x4c>)
 80129be:	6013      	str	r3, [r2, #0]
    TX_INITIALIZE_KERNEL_ENTER_EXTENSION

    /* Ensure that the system state variable is set to indicate 
       initialization is in progress.  Note that this variable is 
       later used to represent interrupt nesting.  */
    _tx_thread_system_state =  TX_INITIALIZE_IN_PROGRESS;
 80129c0:	4b07      	ldr	r3, [pc, #28]	; (80129e0 <_tx_initialize_kernel_enter+0x48>)
 80129c2:	f04f 32f0 	mov.w	r2, #4042322160	; 0xf0f0f0f0
 80129c6:	601a      	str	r2, [r3, #0]

    /* Call the application provided initialization function.  Pass the
       first available memory address to it.  */
    tx_application_define(_tx_initialize_unused_memory);
 80129c8:	4b07      	ldr	r3, [pc, #28]	; (80129e8 <_tx_initialize_kernel_enter+0x50>)
 80129ca:	681b      	ldr	r3, [r3, #0]
 80129cc:	4618      	mov	r0, r3
 80129ce:	f7ed ff89 	bl	80008e4 <tx_application_define>

    /* Set the system state in preparation for entering the thread 
       scheduler.  */
    _tx_thread_system_state =  TX_INITIALIZE_IS_FINISHED;
 80129d2:	4b03      	ldr	r3, [pc, #12]	; (80129e0 <_tx_initialize_kernel_enter+0x48>)
 80129d4:	2200      	movs	r2, #0
 80129d6:	601a      	str	r2, [r3, #0]

    /* Call any port specific pre-scheduler processing.  */
    TX_PORT_SPECIFIC_PRE_SCHEDULER_INITIALIZATION

    /* Enter the scheduling loop to start executing threads!  */
    _tx_thread_schedule();
 80129d8:	f7ed fcc2 	bl	8000360 <_tx_thread_schedule>
#ifdef TX_SAFETY_CRITICAL

    /* If we ever get here, raise safety critical exception.  */
    TX_SAFETY_CRITICAL_EXCEPTION(__FILE__, __LINE__, 0);
#endif
}
 80129dc:	bf00      	nop
 80129de:	bd80      	pop	{r7, pc}
 80129e0:	24000078 	.word	0x24000078
 80129e4:	24031c5c 	.word	0x24031c5c
 80129e8:	24031bbc 	.word	0x24031bbc

080129ec <_tx_mutex_cleanup>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
VOID  _tx_mutex_cleanup(TX_THREAD  *thread_ptr, ULONG suspension_sequence)
{
 80129ec:	b580      	push	{r7, lr}
 80129ee:	b08e      	sub	sp, #56	; 0x38
 80129f0:	af00      	add	r7, sp, #0
 80129f2:	6078      	str	r0, [r7, #4]
 80129f4:	6039      	str	r1, [r7, #0]
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 80129f6:	f3ef 8310 	mrs	r3, PRIMASK
 80129fa:	623b      	str	r3, [r7, #32]
    return(posture);
 80129fc:	6a3b      	ldr	r3, [r7, #32]
    int_posture = __get_interrupt_posture();
 80129fe:	61fb      	str	r3, [r7, #28]
    __asm__ volatile ("CPSID i" : : : "memory");
 8012a00:	b672      	cpsid	i
    return(int_posture);
 8012a02:	69fb      	ldr	r3, [r7, #28]


#ifndef TX_NOT_INTERRUPTABLE

    /* Disable interrupts to remove the suspended thread from the mutex.  */
    TX_DISABLE
 8012a04:	637b      	str	r3, [r7, #52]	; 0x34

    /* Determine if the cleanup is still required.  */
    if (thread_ptr -> tx_thread_suspend_cleanup == &(_tx_mutex_cleanup))
 8012a06:	687b      	ldr	r3, [r7, #4]
 8012a08:	6e9b      	ldr	r3, [r3, #104]	; 0x68
 8012a0a:	4a33      	ldr	r2, [pc, #204]	; (8012ad8 <_tx_mutex_cleanup+0xec>)
 8012a0c:	4293      	cmp	r3, r2
 8012a0e:	d158      	bne.n	8012ac2 <_tx_mutex_cleanup+0xd6>
    {

        /* Check for valid suspension sequence.  */
        if (suspension_sequence == thread_ptr -> tx_thread_suspension_sequence)
 8012a10:	687b      	ldr	r3, [r7, #4]
 8012a12:	f8d3 30ac 	ldr.w	r3, [r3, #172]	; 0xac
 8012a16:	683a      	ldr	r2, [r7, #0]
 8012a18:	429a      	cmp	r2, r3
 8012a1a:	d152      	bne.n	8012ac2 <_tx_mutex_cleanup+0xd6>
        {
   
            /* Setup pointer to mutex control block.  */
            mutex_ptr =  TX_VOID_TO_MUTEX_POINTER_CONVERT(thread_ptr -> tx_thread_suspend_control_block);
 8012a1c:	687b      	ldr	r3, [r7, #4]
 8012a1e:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 8012a20:	633b      	str	r3, [r7, #48]	; 0x30
    
            /* Check for NULL mutex pointer.  */
            if (mutex_ptr != TX_NULL)
 8012a22:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8012a24:	2b00      	cmp	r3, #0
 8012a26:	d04c      	beq.n	8012ac2 <_tx_mutex_cleanup+0xd6>
            {
    
                /* Determine if the mutex ID is valid.  */
                if (mutex_ptr -> tx_mutex_id == TX_MUTEX_ID)
 8012a28:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8012a2a:	681b      	ldr	r3, [r3, #0]
 8012a2c:	4a2b      	ldr	r2, [pc, #172]	; (8012adc <_tx_mutex_cleanup+0xf0>)
 8012a2e:	4293      	cmp	r3, r2
 8012a30:	d147      	bne.n	8012ac2 <_tx_mutex_cleanup+0xd6>
                {

                    /* Determine if there are any thread suspensions.  */
                    if (mutex_ptr -> tx_mutex_suspended_count != TX_NO_SUSPENSIONS)
 8012a32:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8012a34:	69db      	ldr	r3, [r3, #28]
 8012a36:	2b00      	cmp	r3, #0
 8012a38:	d043      	beq.n	8012ac2 <_tx_mutex_cleanup+0xd6>
#endif

                        /* Yes, we still have thread suspension!  */

                        /* Clear the suspension cleanup flag.  */
                        thread_ptr -> tx_thread_suspend_cleanup =  TX_NULL;
 8012a3a:	687b      	ldr	r3, [r7, #4]
 8012a3c:	2200      	movs	r2, #0
 8012a3e:	669a      	str	r2, [r3, #104]	; 0x68

                        /* Decrement the suspension count.  */
                        mutex_ptr -> tx_mutex_suspended_count--;
 8012a40:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8012a42:	69db      	ldr	r3, [r3, #28]
 8012a44:	1e5a      	subs	r2, r3, #1
 8012a46:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8012a48:	61da      	str	r2, [r3, #28]

                        /* Pickup the suspended count.  */
                        suspended_count =  mutex_ptr -> tx_mutex_suspended_count;
 8012a4a:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8012a4c:	69db      	ldr	r3, [r3, #28]
 8012a4e:	62fb      	str	r3, [r7, #44]	; 0x2c

                        /* Remove the suspended thread from the list.  */
    
                        /* See if this is the only suspended thread on the list.  */
                        if (suspended_count == TX_NO_SUSPENSIONS)
 8012a50:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8012a52:	2b00      	cmp	r3, #0
 8012a54:	d103      	bne.n	8012a5e <_tx_mutex_cleanup+0x72>
                        {

                            /* Yes, the only suspended thread.  */

                            /* Update the head pointer.  */
                            mutex_ptr -> tx_mutex_suspension_list =  TX_NULL;
 8012a56:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8012a58:	2200      	movs	r2, #0
 8012a5a:	619a      	str	r2, [r3, #24]
 8012a5c:	e013      	b.n	8012a86 <_tx_mutex_cleanup+0x9a>
                        {

                            /* At least one more thread is on the same suspension list.  */
    
                            /* Update the links of the adjacent threads.  */
                            next_thread =                                   thread_ptr -> tx_thread_suspended_next;
 8012a5e:	687b      	ldr	r3, [r7, #4]
 8012a60:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 8012a62:	62bb      	str	r3, [r7, #40]	; 0x28
                            previous_thread =                               thread_ptr -> tx_thread_suspended_previous;
 8012a64:	687b      	ldr	r3, [r7, #4]
 8012a66:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 8012a68:	627b      	str	r3, [r7, #36]	; 0x24
                            next_thread -> tx_thread_suspended_previous =   previous_thread;
 8012a6a:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8012a6c:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8012a6e:	675a      	str	r2, [r3, #116]	; 0x74
                            previous_thread -> tx_thread_suspended_next =   next_thread;
 8012a70:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8012a72:	6aba      	ldr	r2, [r7, #40]	; 0x28
 8012a74:	671a      	str	r2, [r3, #112]	; 0x70

                            /* Determine if we need to update the head pointer.  */
                            if (mutex_ptr -> tx_mutex_suspension_list == thread_ptr)
 8012a76:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8012a78:	699b      	ldr	r3, [r3, #24]
 8012a7a:	687a      	ldr	r2, [r7, #4]
 8012a7c:	429a      	cmp	r2, r3
 8012a7e:	d102      	bne.n	8012a86 <_tx_mutex_cleanup+0x9a>
                            {
            
                                /* Update the list head pointer.  */
                                mutex_ptr -> tx_mutex_suspension_list =         next_thread;
 8012a80:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8012a82:	6aba      	ldr	r2, [r7, #40]	; 0x28
 8012a84:	619a      	str	r2, [r3, #24]
                            }
                        }
 
                        /* Now we need to determine if this cleanup is from a terminate, timeout,
                           or from a wait abort.  */
                        if (thread_ptr -> tx_thread_state == TX_MUTEX_SUSP)
 8012a86:	687b      	ldr	r3, [r7, #4]
 8012a88:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8012a8a:	2b0d      	cmp	r3, #13
 8012a8c:	d119      	bne.n	8012ac2 <_tx_mutex_cleanup+0xd6>
                            /* Increment the number of timeouts on this semaphore.  */
                            mutex_ptr -> tx_mutex_performance_timeout_count++;
#endif

                            /* Setup return status.  */
                            thread_ptr -> tx_thread_suspend_status =  TX_NOT_AVAILABLE;
 8012a8e:	687b      	ldr	r3, [r7, #4]
 8012a90:	221d      	movs	r2, #29
 8012a92:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84
                            /* Resume the thread!  */
                            _tx_thread_system_ni_resume(thread_ptr);
#else

                            /* Temporarily disable preemption.  */
                            _tx_thread_preempt_disable++;
 8012a96:	4b12      	ldr	r3, [pc, #72]	; (8012ae0 <_tx_mutex_cleanup+0xf4>)
 8012a98:	681b      	ldr	r3, [r3, #0]
 8012a9a:	3301      	adds	r3, #1
 8012a9c:	4a10      	ldr	r2, [pc, #64]	; (8012ae0 <_tx_mutex_cleanup+0xf4>)
 8012a9e:	6013      	str	r3, [r2, #0]
 8012aa0:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8012aa2:	613b      	str	r3, [r7, #16]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 8012aa4:	693b      	ldr	r3, [r7, #16]
 8012aa6:	f383 8810 	msr	PRIMASK, r3
}
 8012aaa:	bf00      	nop

                            /* Restore interrupts.  */
                            TX_RESTORE
    
                            /* Resume the thread!  */
                            _tx_thread_system_resume(thread_ptr);
 8012aac:	6878      	ldr	r0, [r7, #4]
 8012aae:	f002 f93b 	bl	8014d28 <_tx_thread_system_resume>
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 8012ab2:	f3ef 8310 	mrs	r3, PRIMASK
 8012ab6:	61bb      	str	r3, [r7, #24]
    return(posture);
 8012ab8:	69bb      	ldr	r3, [r7, #24]
    int_posture = __get_interrupt_posture();
 8012aba:	617b      	str	r3, [r7, #20]
    __asm__ volatile ("CPSID i" : : : "memory");
 8012abc:	b672      	cpsid	i
    return(int_posture);
 8012abe:	697b      	ldr	r3, [r7, #20]

                            /* Disable interrupts.  */
                            TX_DISABLE
 8012ac0:	637b      	str	r3, [r7, #52]	; 0x34
 8012ac2:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8012ac4:	60fb      	str	r3, [r7, #12]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 8012ac6:	68fb      	ldr	r3, [r7, #12]
 8012ac8:	f383 8810 	msr	PRIMASK, r3
}
 8012acc:	bf00      	nop
    }
    
    /* Restore interrupts.  */
    TX_RESTORE
#endif
}
 8012ace:	bf00      	nop
 8012ad0:	3738      	adds	r7, #56	; 0x38
 8012ad2:	46bd      	mov	sp, r7
 8012ad4:	bd80      	pop	{r7, pc}
 8012ad6:	bf00      	nop
 8012ad8:	080129ed 	.word	0x080129ed
 8012adc:	4d555445 	.word	0x4d555445
 8012ae0:	24031c5c 	.word	0x24031c5c

08012ae4 <_tx_mutex_thread_release>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
VOID  _tx_mutex_thread_release(TX_THREAD  *thread_ptr)
{
 8012ae4:	b580      	push	{r7, lr}
 8012ae6:	b08a      	sub	sp, #40	; 0x28
 8012ae8:	af00      	add	r7, sp, #0
 8012aea:	6078      	str	r0, [r7, #4]
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 8012aec:	f3ef 8310 	mrs	r3, PRIMASK
 8012af0:	61fb      	str	r3, [r7, #28]
    return(posture);
 8012af2:	69fb      	ldr	r3, [r7, #28]
    int_posture = __get_interrupt_posture();
 8012af4:	61bb      	str	r3, [r7, #24]
    __asm__ volatile ("CPSID i" : : : "memory");
 8012af6:	b672      	cpsid	i
    return(int_posture);
 8012af8:	69bb      	ldr	r3, [r7, #24]
UINT        status;
#endif


    /* Disable interrupts.  */
    TX_DISABLE
 8012afa:	627b      	str	r3, [r7, #36]	; 0x24
    
    /* Temporarily disable preemption.  */
    _tx_thread_preempt_disable++;
 8012afc:	4b1a      	ldr	r3, [pc, #104]	; (8012b68 <_tx_mutex_thread_release+0x84>)
 8012afe:	681b      	ldr	r3, [r3, #0]
 8012b00:	3301      	adds	r3, #1
 8012b02:	4a19      	ldr	r2, [pc, #100]	; (8012b68 <_tx_mutex_thread_release+0x84>)
 8012b04:	6013      	str	r3, [r2, #0]
    /* Loop to look at all the mutexes.  */
    do
    {
    
        /* Pickup the mutex head pointer.  */
        mutex_ptr =  thread_ptr -> tx_thread_owned_mutex_list;
 8012b06:	687b      	ldr	r3, [r7, #4]
 8012b08:	f8d3 30a4 	ldr.w	r3, [r3, #164]	; 0xa4
 8012b0c:	623b      	str	r3, [r7, #32]

        /* Determine if there is a mutex.  */
        if (mutex_ptr != TX_NULL)
 8012b0e:	6a3b      	ldr	r3, [r7, #32]
 8012b10:	2b00      	cmp	r3, #0
 8012b12:	d017      	beq.n	8012b44 <_tx_mutex_thread_release+0x60>
        {
        
            /* Yes, set the ownership count to 1.  */
            mutex_ptr -> tx_mutex_ownership_count =  ((UINT) 1);
 8012b14:	6a3b      	ldr	r3, [r7, #32]
 8012b16:	2201      	movs	r2, #1
 8012b18:	609a      	str	r2, [r3, #8]
 8012b1a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8012b1c:	60fb      	str	r3, [r7, #12]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 8012b1e:	68fb      	ldr	r3, [r7, #12]
 8012b20:	f383 8810 	msr	PRIMASK, r3
}
 8012b24:	bf00      	nop
            do
            {
                status =  _tx_mutex_put(mutex_ptr);
            } while (status != TX_SUCCESS);
#else
            _tx_mutex_put(mutex_ptr);
 8012b26:	6a38      	ldr	r0, [r7, #32]
 8012b28:	f000 fb9c 	bl	8013264 <_tx_mutex_put>
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 8012b2c:	f3ef 8310 	mrs	r3, PRIMASK
 8012b30:	617b      	str	r3, [r7, #20]
    return(posture);
 8012b32:	697b      	ldr	r3, [r7, #20]
    int_posture = __get_interrupt_posture();
 8012b34:	613b      	str	r3, [r7, #16]
    __asm__ volatile ("CPSID i" : : : "memory");
 8012b36:	b672      	cpsid	i
    return(int_posture);
 8012b38:	693b      	ldr	r3, [r7, #16]
#endif

            /* Disable interrupts.  */
            TX_DISABLE
 8012b3a:	627b      	str	r3, [r7, #36]	; 0x24

            /* Move to the next mutex.  */
            mutex_ptr =  thread_ptr -> tx_thread_owned_mutex_list;
 8012b3c:	687b      	ldr	r3, [r7, #4]
 8012b3e:	f8d3 30a4 	ldr.w	r3, [r3, #164]	; 0xa4
 8012b42:	623b      	str	r3, [r7, #32]
        }
    } while (mutex_ptr != TX_NULL);
 8012b44:	6a3b      	ldr	r3, [r7, #32]
 8012b46:	2b00      	cmp	r3, #0
 8012b48:	d1dd      	bne.n	8012b06 <_tx_mutex_thread_release+0x22>
    
    /* Restore preemption.  */
    _tx_thread_preempt_disable--;
 8012b4a:	4b07      	ldr	r3, [pc, #28]	; (8012b68 <_tx_mutex_thread_release+0x84>)
 8012b4c:	681b      	ldr	r3, [r3, #0]
 8012b4e:	3b01      	subs	r3, #1
 8012b50:	4a05      	ldr	r2, [pc, #20]	; (8012b68 <_tx_mutex_thread_release+0x84>)
 8012b52:	6013      	str	r3, [r2, #0]
 8012b54:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8012b56:	60bb      	str	r3, [r7, #8]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 8012b58:	68bb      	ldr	r3, [r7, #8]
 8012b5a:	f383 8810 	msr	PRIMASK, r3
}
 8012b5e:	bf00      	nop
    
    /* Restore interrupts.  */
    TX_RESTORE
}
 8012b60:	bf00      	nop
 8012b62:	3728      	adds	r7, #40	; 0x28
 8012b64:	46bd      	mov	sp, r7
 8012b66:	bd80      	pop	{r7, pc}
 8012b68:	24031c5c 	.word	0x24031c5c

08012b6c <_tx_mutex_create>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
UINT  _tx_mutex_create(TX_MUTEX *mutex_ptr, CHAR *name_ptr, UINT inherit)
{
 8012b6c:	b580      	push	{r7, lr}
 8012b6e:	b08a      	sub	sp, #40	; 0x28
 8012b70:	af00      	add	r7, sp, #0
 8012b72:	60f8      	str	r0, [r7, #12]
 8012b74:	60b9      	str	r1, [r7, #8]
 8012b76:	607a      	str	r2, [r7, #4]
TX_MUTEX        *next_mutex;
TX_MUTEX        *previous_mutex;


    /* Initialize mutex control block to all zeros.  */
    TX_MEMSET(mutex_ptr, 0, (sizeof(TX_MUTEX)));
 8012b78:	2234      	movs	r2, #52	; 0x34
 8012b7a:	2100      	movs	r1, #0
 8012b7c:	68f8      	ldr	r0, [r7, #12]
 8012b7e:	f00c fe7d 	bl	801f87c <memset>

    /* Setup the basic mutex fields.  */
    mutex_ptr -> tx_mutex_name =             name_ptr;
 8012b82:	68fb      	ldr	r3, [r7, #12]
 8012b84:	68ba      	ldr	r2, [r7, #8]
 8012b86:	605a      	str	r2, [r3, #4]
    mutex_ptr -> tx_mutex_inherit =          inherit;
 8012b88:	68fb      	ldr	r3, [r7, #12]
 8012b8a:	687a      	ldr	r2, [r7, #4]
 8012b8c:	611a      	str	r2, [r3, #16]
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 8012b8e:	f3ef 8310 	mrs	r3, PRIMASK
 8012b92:	61bb      	str	r3, [r7, #24]
    return(posture);
 8012b94:	69bb      	ldr	r3, [r7, #24]
    int_posture = __get_interrupt_posture();
 8012b96:	617b      	str	r3, [r7, #20]
    __asm__ volatile ("CPSID i" : : : "memory");
 8012b98:	b672      	cpsid	i
    return(int_posture);
 8012b9a:	697b      	ldr	r3, [r7, #20]
    
    /* Disable interrupts to place the mutex on the created list.  */
    TX_DISABLE
 8012b9c:	627b      	str	r3, [r7, #36]	; 0x24

    /* Setup the mutex ID to make it valid.  */
    mutex_ptr -> tx_mutex_id =  TX_MUTEX_ID;
 8012b9e:	68fb      	ldr	r3, [r7, #12]
 8012ba0:	4a1a      	ldr	r2, [pc, #104]	; (8012c0c <_tx_mutex_create+0xa0>)
 8012ba2:	601a      	str	r2, [r3, #0]

    /* Setup the thread mutex release function pointer.  */
    _tx_thread_mutex_release =  &(_tx_mutex_thread_release);
 8012ba4:	4b1a      	ldr	r3, [pc, #104]	; (8012c10 <_tx_mutex_create+0xa4>)
 8012ba6:	4a1b      	ldr	r2, [pc, #108]	; (8012c14 <_tx_mutex_create+0xa8>)
 8012ba8:	601a      	str	r2, [r3, #0]

    /* Place the mutex on the list of created mutexes.  First,
       check for an empty list.  */
    if (_tx_mutex_created_count == TX_EMPTY)
 8012baa:	4b1b      	ldr	r3, [pc, #108]	; (8012c18 <_tx_mutex_create+0xac>)
 8012bac:	681b      	ldr	r3, [r3, #0]
 8012bae:	2b00      	cmp	r3, #0
 8012bb0:	d109      	bne.n	8012bc6 <_tx_mutex_create+0x5a>
    {

        /* The created mutex list is empty.  Add mutex to empty list.  */
        _tx_mutex_created_ptr =                   mutex_ptr;
 8012bb2:	4a1a      	ldr	r2, [pc, #104]	; (8012c1c <_tx_mutex_create+0xb0>)
 8012bb4:	68fb      	ldr	r3, [r7, #12]
 8012bb6:	6013      	str	r3, [r2, #0]
        mutex_ptr -> tx_mutex_created_next =      mutex_ptr;
 8012bb8:	68fb      	ldr	r3, [r7, #12]
 8012bba:	68fa      	ldr	r2, [r7, #12]
 8012bbc:	621a      	str	r2, [r3, #32]
        mutex_ptr -> tx_mutex_created_previous =  mutex_ptr;
 8012bbe:	68fb      	ldr	r3, [r7, #12]
 8012bc0:	68fa      	ldr	r2, [r7, #12]
 8012bc2:	625a      	str	r2, [r3, #36]	; 0x24
 8012bc4:	e011      	b.n	8012bea <_tx_mutex_create+0x7e>
    }
    else
    {

        /* This list is not NULL, add to the end of the list.  */
        next_mutex =      _tx_mutex_created_ptr;
 8012bc6:	4b15      	ldr	r3, [pc, #84]	; (8012c1c <_tx_mutex_create+0xb0>)
 8012bc8:	681b      	ldr	r3, [r3, #0]
 8012bca:	623b      	str	r3, [r7, #32]
        previous_mutex =  next_mutex -> tx_mutex_created_previous;
 8012bcc:	6a3b      	ldr	r3, [r7, #32]
 8012bce:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8012bd0:	61fb      	str	r3, [r7, #28]

        /* Place the new mutex in the list.  */
        next_mutex -> tx_mutex_created_previous =  mutex_ptr;
 8012bd2:	6a3b      	ldr	r3, [r7, #32]
 8012bd4:	68fa      	ldr	r2, [r7, #12]
 8012bd6:	625a      	str	r2, [r3, #36]	; 0x24
        previous_mutex -> tx_mutex_created_next =  mutex_ptr;
 8012bd8:	69fb      	ldr	r3, [r7, #28]
 8012bda:	68fa      	ldr	r2, [r7, #12]
 8012bdc:	621a      	str	r2, [r3, #32]

        /* Setup this mutex's next and previous created links.  */
        mutex_ptr -> tx_mutex_created_previous =  previous_mutex;
 8012bde:	68fb      	ldr	r3, [r7, #12]
 8012be0:	69fa      	ldr	r2, [r7, #28]
 8012be2:	625a      	str	r2, [r3, #36]	; 0x24
        mutex_ptr -> tx_mutex_created_next =      next_mutex;
 8012be4:	68fb      	ldr	r3, [r7, #12]
 8012be6:	6a3a      	ldr	r2, [r7, #32]
 8012be8:	621a      	str	r2, [r3, #32]
    }

    /* Increment the ownership count.  */
    _tx_mutex_created_count++;
 8012bea:	4b0b      	ldr	r3, [pc, #44]	; (8012c18 <_tx_mutex_create+0xac>)
 8012bec:	681b      	ldr	r3, [r3, #0]
 8012bee:	3301      	adds	r3, #1
 8012bf0:	4a09      	ldr	r2, [pc, #36]	; (8012c18 <_tx_mutex_create+0xac>)
 8012bf2:	6013      	str	r3, [r2, #0]
 8012bf4:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8012bf6:	613b      	str	r3, [r7, #16]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 8012bf8:	693b      	ldr	r3, [r7, #16]
 8012bfa:	f383 8810 	msr	PRIMASK, r3
}
 8012bfe:	bf00      	nop

    /* Restore interrupts.  */
    TX_RESTORE

    /* Return TX_SUCCESS.  */
    return(TX_SUCCESS);
 8012c00:	2300      	movs	r3, #0
}
 8012c02:	4618      	mov	r0, r3
 8012c04:	3728      	adds	r7, #40	; 0x28
 8012c06:	46bd      	mov	sp, r7
 8012c08:	bd80      	pop	{r7, pc}
 8012c0a:	bf00      	nop
 8012c0c:	4d555445 	.word	0x4d555445
 8012c10:	24031c60 	.word	0x24031c60
 8012c14:	08012ae5 	.word	0x08012ae5
 8012c18:	24031ba8 	.word	0x24031ba8
 8012c1c:	24031ba4 	.word	0x24031ba4

08012c20 <_tx_mutex_delete>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
UINT  _tx_mutex_delete(TX_MUTEX *mutex_ptr)
{
 8012c20:	b580      	push	{r7, lr}
 8012c22:	b096      	sub	sp, #88	; 0x58
 8012c24:	af00      	add	r7, sp, #0
 8012c26:	6078      	str	r0, [r7, #4]
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 8012c28:	f3ef 8310 	mrs	r3, PRIMASK
 8012c2c:	63bb      	str	r3, [r7, #56]	; 0x38
    return(posture);
 8012c2e:	6bbb      	ldr	r3, [r7, #56]	; 0x38
    int_posture = __get_interrupt_posture();
 8012c30:	637b      	str	r3, [r7, #52]	; 0x34
    __asm__ volatile ("CPSID i" : : : "memory");
 8012c32:	b672      	cpsid	i
    return(int_posture);
 8012c34:	6b7b      	ldr	r3, [r7, #52]	; 0x34
#ifdef TX_MISRA_ENABLE
UINT            status;
#endif

    /* Disable interrupts to remove the mutex from the created list.  */
    TX_DISABLE
 8012c36:	657b      	str	r3, [r7, #84]	; 0x54

    /* Log this kernel call.  */
    TX_EL_MUTEX_DELETE_INSERT

    /* Clear the mutex ID to make it invalid.  */
    mutex_ptr -> tx_mutex_id =  TX_CLEAR_ID;
 8012c38:	687b      	ldr	r3, [r7, #4]
 8012c3a:	2200      	movs	r2, #0
 8012c3c:	601a      	str	r2, [r3, #0]

    /* Decrement the created count.  */
    _tx_mutex_created_count--;
 8012c3e:	4b4a      	ldr	r3, [pc, #296]	; (8012d68 <_tx_mutex_delete+0x148>)
 8012c40:	681b      	ldr	r3, [r3, #0]
 8012c42:	3b01      	subs	r3, #1
 8012c44:	4a48      	ldr	r2, [pc, #288]	; (8012d68 <_tx_mutex_delete+0x148>)
 8012c46:	6013      	str	r3, [r2, #0]
    
    /* See if the mutex is the only one on the list.  */
    if (_tx_mutex_created_count == TX_EMPTY)
 8012c48:	4b47      	ldr	r3, [pc, #284]	; (8012d68 <_tx_mutex_delete+0x148>)
 8012c4a:	681b      	ldr	r3, [r3, #0]
 8012c4c:	2b00      	cmp	r3, #0
 8012c4e:	d103      	bne.n	8012c58 <_tx_mutex_delete+0x38>
    {

        /* Only created mutex, just set the created list to NULL.  */
        _tx_mutex_created_ptr =  TX_NULL;
 8012c50:	4b46      	ldr	r3, [pc, #280]	; (8012d6c <_tx_mutex_delete+0x14c>)
 8012c52:	2200      	movs	r2, #0
 8012c54:	601a      	str	r2, [r3, #0]
 8012c56:	e013      	b.n	8012c80 <_tx_mutex_delete+0x60>
    }
    else
    {

        /* Link-up the neighbors.  */
        next_mutex =                               mutex_ptr -> tx_mutex_created_next;
 8012c58:	687b      	ldr	r3, [r7, #4]
 8012c5a:	6a1b      	ldr	r3, [r3, #32]
 8012c5c:	64bb      	str	r3, [r7, #72]	; 0x48
        previous_mutex =                           mutex_ptr -> tx_mutex_created_previous;
 8012c5e:	687b      	ldr	r3, [r7, #4]
 8012c60:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8012c62:	647b      	str	r3, [r7, #68]	; 0x44
        next_mutex -> tx_mutex_created_previous =  previous_mutex;
 8012c64:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 8012c66:	6c7a      	ldr	r2, [r7, #68]	; 0x44
 8012c68:	625a      	str	r2, [r3, #36]	; 0x24
        previous_mutex -> tx_mutex_created_next =  next_mutex;
 8012c6a:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8012c6c:	6cba      	ldr	r2, [r7, #72]	; 0x48
 8012c6e:	621a      	str	r2, [r3, #32]

        /* See if we have to update the created list head pointer.  */
        if (_tx_mutex_created_ptr == mutex_ptr)
 8012c70:	4b3e      	ldr	r3, [pc, #248]	; (8012d6c <_tx_mutex_delete+0x14c>)
 8012c72:	681b      	ldr	r3, [r3, #0]
 8012c74:	687a      	ldr	r2, [r7, #4]
 8012c76:	429a      	cmp	r2, r3
 8012c78:	d102      	bne.n	8012c80 <_tx_mutex_delete+0x60>
        {
        
            /* Yes, move the head pointer to the next link. */
            _tx_mutex_created_ptr =  next_mutex;
 8012c7a:	4a3c      	ldr	r2, [pc, #240]	; (8012d6c <_tx_mutex_delete+0x14c>)
 8012c7c:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 8012c7e:	6013      	str	r3, [r2, #0]
        }
    }

    /* Temporarily disable preemption.  */
    _tx_thread_preempt_disable++;
 8012c80:	4b3b      	ldr	r3, [pc, #236]	; (8012d70 <_tx_mutex_delete+0x150>)
 8012c82:	681b      	ldr	r3, [r3, #0]
 8012c84:	3301      	adds	r3, #1
 8012c86:	4a3a      	ldr	r2, [pc, #232]	; (8012d70 <_tx_mutex_delete+0x150>)
 8012c88:	6013      	str	r3, [r2, #0]

    /* Pickup the suspension information.  */
    thread_ptr =                             mutex_ptr -> tx_mutex_suspension_list;
 8012c8a:	687b      	ldr	r3, [r7, #4]
 8012c8c:	699b      	ldr	r3, [r3, #24]
 8012c8e:	653b      	str	r3, [r7, #80]	; 0x50
    mutex_ptr -> tx_mutex_suspension_list =  TX_NULL;
 8012c90:	687b      	ldr	r3, [r7, #4]
 8012c92:	2200      	movs	r2, #0
 8012c94:	619a      	str	r2, [r3, #24]
    suspended_count =                        mutex_ptr -> tx_mutex_suspended_count;
 8012c96:	687b      	ldr	r3, [r7, #4]
 8012c98:	69db      	ldr	r3, [r3, #28]
 8012c9a:	64fb      	str	r3, [r7, #76]	; 0x4c
    mutex_ptr -> tx_mutex_suspended_count =  TX_NO_SUSPENSIONS;
 8012c9c:	687b      	ldr	r3, [r7, #4]
 8012c9e:	2200      	movs	r2, #0
 8012ca0:	61da      	str	r2, [r3, #28]


    /* Determine if the mutex is currently on a thread's ownership list.  */

    /* Setup pointer to owner of mutex.  */
    owner_thread =  mutex_ptr -> tx_mutex_owner;
 8012ca2:	687b      	ldr	r3, [r7, #4]
 8012ca4:	68db      	ldr	r3, [r3, #12]
 8012ca6:	643b      	str	r3, [r7, #64]	; 0x40

    /* Determine if there is a valid thread pointer.  */
    if (owner_thread != TX_NULL)
 8012ca8:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8012caa:	2b00      	cmp	r3, #0
 8012cac:	d013      	beq.n	8012cd6 <_tx_mutex_delete+0xb6>
    {

        /* Yes, remove this mutex from the owned list.  */
        
        /* Set the ownership count to 1.  */
        mutex_ptr -> tx_mutex_ownership_count =  ((UINT) 1);
 8012cae:	687b      	ldr	r3, [r7, #4]
 8012cb0:	2201      	movs	r2, #1
 8012cb2:	609a      	str	r2, [r3, #8]
 8012cb4:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 8012cb6:	62bb      	str	r3, [r7, #40]	; 0x28
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 8012cb8:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8012cba:	f383 8810 	msr	PRIMASK, r3
}
 8012cbe:	bf00      	nop
        do
        {
            status =  _tx_mutex_put(mutex_ptr);
        } while (status != TX_SUCCESS);
#else
        _tx_mutex_put(mutex_ptr);
 8012cc0:	6878      	ldr	r0, [r7, #4]
 8012cc2:	f000 facf 	bl	8013264 <_tx_mutex_put>
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 8012cc6:	f3ef 8310 	mrs	r3, PRIMASK
 8012cca:	633b      	str	r3, [r7, #48]	; 0x30
    return(posture);
 8012ccc:	6b3b      	ldr	r3, [r7, #48]	; 0x30
    int_posture = __get_interrupt_posture();
 8012cce:	62fb      	str	r3, [r7, #44]	; 0x2c
    __asm__ volatile ("CPSID i" : : : "memory");
 8012cd0:	b672      	cpsid	i
    return(int_posture);
 8012cd2:	6afb      	ldr	r3, [r7, #44]	; 0x2c
#endif

        /* Disable interrupts.  */
        TX_DISABLE
 8012cd4:	657b      	str	r3, [r7, #84]	; 0x54
 8012cd6:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 8012cd8:	627b      	str	r3, [r7, #36]	; 0x24
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 8012cda:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8012cdc:	f383 8810 	msr	PRIMASK, r3
}
 8012ce0:	bf00      	nop
    /* Restore interrupts.  */
    TX_RESTORE

    /* Walk through the mutex list to resume any and all threads suspended
       on this mutex.  */
    while (suspended_count != ((ULONG) 0))
 8012ce2:	e024      	b.n	8012d2e <_tx_mutex_delete+0x10e>
    {
      
        /* Decrement the suspension count.  */
        suspended_count--;
 8012ce4:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8012ce6:	3b01      	subs	r3, #1
 8012ce8:	64fb      	str	r3, [r7, #76]	; 0x4c
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 8012cea:	f3ef 8310 	mrs	r3, PRIMASK
 8012cee:	61fb      	str	r3, [r7, #28]
    return(posture);
 8012cf0:	69fb      	ldr	r3, [r7, #28]
    int_posture = __get_interrupt_posture();
 8012cf2:	61bb      	str	r3, [r7, #24]
    __asm__ volatile ("CPSID i" : : : "memory");
 8012cf4:	b672      	cpsid	i
    return(int_posture);
 8012cf6:	69bb      	ldr	r3, [r7, #24]
      
        /* Lockout interrupts.  */
        TX_DISABLE
 8012cf8:	657b      	str	r3, [r7, #84]	; 0x54

        /* Clear the cleanup pointer, this prevents the timeout from doing 
           anything.  */
        thread_ptr -> tx_thread_suspend_cleanup =  TX_NULL;
 8012cfa:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 8012cfc:	2200      	movs	r2, #0
 8012cfe:	669a      	str	r2, [r3, #104]	; 0x68

        /* Set the return status in the thread to TX_DELETED.  */
        thread_ptr -> tx_thread_suspend_status =  TX_DELETED;
 8012d00:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 8012d02:	2201      	movs	r2, #1
 8012d04:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84

        /* Move the thread pointer ahead.  */
        next_thread =  thread_ptr -> tx_thread_suspended_next;
 8012d08:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 8012d0a:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 8012d0c:	63fb      	str	r3, [r7, #60]	; 0x3c
        /* Restore interrupts.  */
        TX_RESTORE
#else

        /* Temporarily disable preemption again.  */
        _tx_thread_preempt_disable++;
 8012d0e:	4b18      	ldr	r3, [pc, #96]	; (8012d70 <_tx_mutex_delete+0x150>)
 8012d10:	681b      	ldr	r3, [r3, #0]
 8012d12:	3301      	adds	r3, #1
 8012d14:	4a16      	ldr	r2, [pc, #88]	; (8012d70 <_tx_mutex_delete+0x150>)
 8012d16:	6013      	str	r3, [r2, #0]
 8012d18:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 8012d1a:	623b      	str	r3, [r7, #32]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 8012d1c:	6a3b      	ldr	r3, [r7, #32]
 8012d1e:	f383 8810 	msr	PRIMASK, r3
}
 8012d22:	bf00      	nop

        /* Restore interrupts.  */
        TX_RESTORE
    
        /* Resume the thread.  */
        _tx_thread_system_resume(thread_ptr);
 8012d24:	6d38      	ldr	r0, [r7, #80]	; 0x50
 8012d26:	f001 ffff 	bl	8014d28 <_tx_thread_system_resume>
#endif

        /* Move to next thread.  */
        thread_ptr =  next_thread;
 8012d2a:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8012d2c:	653b      	str	r3, [r7, #80]	; 0x50
    while (suspended_count != ((ULONG) 0))
 8012d2e:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8012d30:	2b00      	cmp	r3, #0
 8012d32:	d1d7      	bne.n	8012ce4 <_tx_mutex_delete+0xc4>
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 8012d34:	f3ef 8310 	mrs	r3, PRIMASK
 8012d38:	613b      	str	r3, [r7, #16]
    return(posture);
 8012d3a:	693b      	ldr	r3, [r7, #16]
    int_posture = __get_interrupt_posture();
 8012d3c:	60fb      	str	r3, [r7, #12]
    __asm__ volatile ("CPSID i" : : : "memory");
 8012d3e:	b672      	cpsid	i
    return(int_posture);
 8012d40:	68fb      	ldr	r3, [r7, #12]

    /* Execute Port-Specific completion processing. If needed, it is typically defined in tx_port.h.  */
    TX_MUTEX_DELETE_PORT_COMPLETION(mutex_ptr)

    /* Disable interrupts.  */
    TX_DISABLE
 8012d42:	657b      	str	r3, [r7, #84]	; 0x54

    /* Release previous preempt disable.  */
    _tx_thread_preempt_disable--;
 8012d44:	4b0a      	ldr	r3, [pc, #40]	; (8012d70 <_tx_mutex_delete+0x150>)
 8012d46:	681b      	ldr	r3, [r3, #0]
 8012d48:	3b01      	subs	r3, #1
 8012d4a:	4a09      	ldr	r2, [pc, #36]	; (8012d70 <_tx_mutex_delete+0x150>)
 8012d4c:	6013      	str	r3, [r2, #0]
 8012d4e:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 8012d50:	617b      	str	r3, [r7, #20]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 8012d52:	697b      	ldr	r3, [r7, #20]
 8012d54:	f383 8810 	msr	PRIMASK, r3
}
 8012d58:	bf00      	nop

    /* Restore interrupts.  */
    TX_RESTORE

    /* Check for preemption.  */
    _tx_thread_system_preempt_check();
 8012d5a:	f001 ffab 	bl	8014cb4 <_tx_thread_system_preempt_check>

    /* Return TX_SUCCESS.  */
    return(TX_SUCCESS);
 8012d5e:	2300      	movs	r3, #0
}
 8012d60:	4618      	mov	r0, r3
 8012d62:	3758      	adds	r7, #88	; 0x58
 8012d64:	46bd      	mov	sp, r7
 8012d66:	bd80      	pop	{r7, pc}
 8012d68:	24031ba8 	.word	0x24031ba8
 8012d6c:	24031ba4 	.word	0x24031ba4
 8012d70:	24031c5c 	.word	0x24031c5c

08012d74 <_tx_mutex_get>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
UINT  _tx_mutex_get(TX_MUTEX *mutex_ptr, ULONG wait_option)
{
 8012d74:	b580      	push	{r7, lr}
 8012d76:	b092      	sub	sp, #72	; 0x48
 8012d78:	af00      	add	r7, sp, #0
 8012d7a:	6078      	str	r0, [r7, #4]
 8012d7c:	6039      	str	r1, [r7, #0]
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 8012d7e:	f3ef 8310 	mrs	r3, PRIMASK
 8012d82:	627b      	str	r3, [r7, #36]	; 0x24
    return(posture);
 8012d84:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    int_posture = __get_interrupt_posture();
 8012d86:	623b      	str	r3, [r7, #32]
    __asm__ volatile ("CPSID i" : : : "memory");
 8012d88:	b672      	cpsid	i
    return(int_posture);
 8012d8a:	6a3b      	ldr	r3, [r7, #32]
TX_THREAD       *previous_thread;
UINT            status;


    /* Disable interrupts to get an instance from the mutex.  */
    TX_DISABLE
 8012d8c:	643b      	str	r3, [r7, #64]	; 0x40

    /* Log this kernel call.  */
    TX_EL_MUTEX_GET_INSERT

    /* Pickup thread pointer.  */
    TX_THREAD_GET_CURRENT(thread_ptr)
 8012d8e:	4b7a      	ldr	r3, [pc, #488]	; (8012f78 <_tx_mutex_get+0x204>)
 8012d90:	681b      	ldr	r3, [r3, #0]
 8012d92:	63fb      	str	r3, [r7, #60]	; 0x3c

    /* Determine if this mutex is available.  */
    if (mutex_ptr -> tx_mutex_ownership_count == ((UINT) 0))
 8012d94:	687b      	ldr	r3, [r7, #4]
 8012d96:	689b      	ldr	r3, [r3, #8]
 8012d98:	2b00      	cmp	r3, #0
 8012d9a:	d144      	bne.n	8012e26 <_tx_mutex_get+0xb2>
    {

        /* Set the ownership count to 1.  */
        mutex_ptr -> tx_mutex_ownership_count =  ((UINT) 1);
 8012d9c:	687b      	ldr	r3, [r7, #4]
 8012d9e:	2201      	movs	r2, #1
 8012da0:	609a      	str	r2, [r3, #8]

        /* Remember that the calling thread owns the mutex.  */
        mutex_ptr -> tx_mutex_owner =  thread_ptr;
 8012da2:	687b      	ldr	r3, [r7, #4]
 8012da4:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 8012da6:	60da      	str	r2, [r3, #12]

        /* Determine if the thread pointer is valid.  */
        if (thread_ptr != TX_NULL)
 8012da8:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8012daa:	2b00      	cmp	r3, #0
 8012dac:	d032      	beq.n	8012e14 <_tx_mutex_get+0xa0>
        {

            /* Determine if priority inheritance is required.  */
            if (mutex_ptr -> tx_mutex_inherit == TX_TRUE)
 8012dae:	687b      	ldr	r3, [r7, #4]
 8012db0:	691b      	ldr	r3, [r3, #16]
 8012db2:	2b01      	cmp	r3, #1
 8012db4:	d106      	bne.n	8012dc4 <_tx_mutex_get+0x50>
            {
         
                /* Remember the current priority of thread.  */
                mutex_ptr -> tx_mutex_original_priority =   thread_ptr -> tx_thread_priority;
 8012db6:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8012db8:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 8012dba:	687b      	ldr	r3, [r7, #4]
 8012dbc:	615a      	str	r2, [r3, #20]

                /* Setup the highest priority waiting thread.  */
                mutex_ptr -> tx_mutex_highest_priority_waiting =  ((UINT) TX_MAX_PRIORITIES);
 8012dbe:	687b      	ldr	r3, [r7, #4]
 8012dc0:	2220      	movs	r2, #32
 8012dc2:	629a      	str	r2, [r3, #40]	; 0x28
            }

            /* Pickup next mutex pointer, which is the head of the list.  */
            next_mutex =  thread_ptr -> tx_thread_owned_mutex_list;
 8012dc4:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8012dc6:	f8d3 30a4 	ldr.w	r3, [r3, #164]	; 0xa4
 8012dca:	62fb      	str	r3, [r7, #44]	; 0x2c

            /* Determine if this thread owns any other mutexes that have priority inheritance.  */
            if (next_mutex != TX_NULL)
 8012dcc:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8012dce:	2b00      	cmp	r3, #0
 8012dd0:	d00f      	beq.n	8012df2 <_tx_mutex_get+0x7e>
            {

                /* Non-empty list. Link up the mutex.  */

                /* Pickup the next and previous mutex pointer.  */
                previous_mutex =  next_mutex -> tx_mutex_owned_previous;
 8012dd2:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8012dd4:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8012dd6:	62bb      	str	r3, [r7, #40]	; 0x28

                /* Place the owned mutex in the list.  */
                next_mutex -> tx_mutex_owned_previous =  mutex_ptr;
 8012dd8:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8012dda:	687a      	ldr	r2, [r7, #4]
 8012ddc:	631a      	str	r2, [r3, #48]	; 0x30
                previous_mutex -> tx_mutex_owned_next =  mutex_ptr;
 8012dde:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8012de0:	687a      	ldr	r2, [r7, #4]
 8012de2:	62da      	str	r2, [r3, #44]	; 0x2c

                /* Setup this mutex's next and previous created links.  */
                mutex_ptr -> tx_mutex_owned_previous =  previous_mutex;
 8012de4:	687b      	ldr	r3, [r7, #4]
 8012de6:	6aba      	ldr	r2, [r7, #40]	; 0x28
 8012de8:	631a      	str	r2, [r3, #48]	; 0x30
                mutex_ptr -> tx_mutex_owned_next =      next_mutex;
 8012dea:	687b      	ldr	r3, [r7, #4]
 8012dec:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 8012dee:	62da      	str	r2, [r3, #44]	; 0x2c
 8012df0:	e009      	b.n	8012e06 <_tx_mutex_get+0x92>
            }
            else
            {

                /* The owned mutex list is empty.  Add mutex to empty list.  */
                thread_ptr -> tx_thread_owned_mutex_list =     mutex_ptr;
 8012df2:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8012df4:	687a      	ldr	r2, [r7, #4]
 8012df6:	f8c3 20a4 	str.w	r2, [r3, #164]	; 0xa4
                mutex_ptr -> tx_mutex_owned_next =             mutex_ptr;
 8012dfa:	687b      	ldr	r3, [r7, #4]
 8012dfc:	687a      	ldr	r2, [r7, #4]
 8012dfe:	62da      	str	r2, [r3, #44]	; 0x2c
                mutex_ptr -> tx_mutex_owned_previous =         mutex_ptr;
 8012e00:	687b      	ldr	r3, [r7, #4]
 8012e02:	687a      	ldr	r2, [r7, #4]
 8012e04:	631a      	str	r2, [r3, #48]	; 0x30
            }

            /* Increment the number of mutexes owned counter.  */
            thread_ptr -> tx_thread_owned_mutex_count++;
 8012e06:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8012e08:	f8d3 30a0 	ldr.w	r3, [r3, #160]	; 0xa0
 8012e0c:	1c5a      	adds	r2, r3, #1
 8012e0e:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8012e10:	f8c3 20a0 	str.w	r2, [r3, #160]	; 0xa0
 8012e14:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8012e16:	61fb      	str	r3, [r7, #28]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 8012e18:	69fb      	ldr	r3, [r7, #28]
 8012e1a:	f383 8810 	msr	PRIMASK, r3
}
 8012e1e:	bf00      	nop

        /* Restore interrupts.  */
        TX_RESTORE

        /* Return success.  */
        status =  TX_SUCCESS;
 8012e20:	2300      	movs	r3, #0
 8012e22:	647b      	str	r3, [r7, #68]	; 0x44
 8012e24:	e0a2      	b.n	8012f6c <_tx_mutex_get+0x1f8>
    }

    /* Otherwise, see if the owning thread is trying to obtain the same mutex.  */
    else if (mutex_ptr -> tx_mutex_owner == thread_ptr)
 8012e26:	687b      	ldr	r3, [r7, #4]
 8012e28:	68db      	ldr	r3, [r3, #12]
 8012e2a:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 8012e2c:	429a      	cmp	r2, r3
 8012e2e:	d10d      	bne.n	8012e4c <_tx_mutex_get+0xd8>
    {

        /* The owning thread is requesting the mutex again, just 
           increment the ownership count.  */
        mutex_ptr -> tx_mutex_ownership_count++;
 8012e30:	687b      	ldr	r3, [r7, #4]
 8012e32:	689b      	ldr	r3, [r3, #8]
 8012e34:	1c5a      	adds	r2, r3, #1
 8012e36:	687b      	ldr	r3, [r7, #4]
 8012e38:	609a      	str	r2, [r3, #8]
 8012e3a:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8012e3c:	61bb      	str	r3, [r7, #24]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 8012e3e:	69bb      	ldr	r3, [r7, #24]
 8012e40:	f383 8810 	msr	PRIMASK, r3
}
 8012e44:	bf00      	nop

        /* Restore interrupts.  */
        TX_RESTORE

        /* Return success.  */
        status =  TX_SUCCESS;
 8012e46:	2300      	movs	r3, #0
 8012e48:	647b      	str	r3, [r7, #68]	; 0x44
 8012e4a:	e08f      	b.n	8012f6c <_tx_mutex_get+0x1f8>
    }
    else
    {

        /* Determine if the request specifies suspension.  */
        if (wait_option != TX_NO_WAIT)
 8012e4c:	683b      	ldr	r3, [r7, #0]
 8012e4e:	2b00      	cmp	r3, #0
 8012e50:	f000 8084 	beq.w	8012f5c <_tx_mutex_get+0x1e8>
        {

            /* Determine if the preempt disable flag is non-zero.  */
            if (_tx_thread_preempt_disable != ((UINT) 0))
 8012e54:	4b49      	ldr	r3, [pc, #292]	; (8012f7c <_tx_mutex_get+0x208>)
 8012e56:	681b      	ldr	r3, [r3, #0]
 8012e58:	2b00      	cmp	r3, #0
 8012e5a:	d008      	beq.n	8012e6e <_tx_mutex_get+0xfa>
 8012e5c:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8012e5e:	617b      	str	r3, [r7, #20]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 8012e60:	697b      	ldr	r3, [r7, #20]
 8012e62:	f383 8810 	msr	PRIMASK, r3
}
 8012e66:	bf00      	nop

                /* Restore interrupts.  */
                TX_RESTORE

                /* Suspension is not allowed if the preempt disable flag is non-zero at this point - return error completion.  */
                status =  TX_NOT_AVAILABLE;
 8012e68:	231d      	movs	r3, #29
 8012e6a:	647b      	str	r3, [r7, #68]	; 0x44
 8012e6c:	e07e      	b.n	8012f6c <_tx_mutex_get+0x1f8>
            {

                /* Prepare for suspension of this thread.  */

                /* Pickup the mutex owner.  */
                mutex_owner =  mutex_ptr -> tx_mutex_owner;
 8012e6e:	687b      	ldr	r3, [r7, #4]
 8012e70:	68db      	ldr	r3, [r3, #12]
 8012e72:	63bb      	str	r3, [r7, #56]	; 0x38
#endif
                }
#endif

                /* Setup cleanup routine pointer.  */
                thread_ptr -> tx_thread_suspend_cleanup =  &(_tx_mutex_cleanup);
 8012e74:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8012e76:	4a42      	ldr	r2, [pc, #264]	; (8012f80 <_tx_mutex_get+0x20c>)
 8012e78:	669a      	str	r2, [r3, #104]	; 0x68

                /* Setup cleanup information, i.e. this mutex control
                   block.  */
                thread_ptr -> tx_thread_suspend_control_block =  (VOID *) mutex_ptr;
 8012e7a:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8012e7c:	687a      	ldr	r2, [r7, #4]
 8012e7e:	66da      	str	r2, [r3, #108]	; 0x6c

#ifndef TX_NOT_INTERRUPTABLE

                /* Increment the suspension sequence number, which is used to identify
                   this suspension event.  */
                thread_ptr -> tx_thread_suspension_sequence++;
 8012e80:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8012e82:	f8d3 30ac 	ldr.w	r3, [r3, #172]	; 0xac
 8012e86:	1c5a      	adds	r2, r3, #1
 8012e88:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8012e8a:	f8c3 20ac 	str.w	r2, [r3, #172]	; 0xac
#endif

                /* Setup suspension list.  */
                if (mutex_ptr -> tx_mutex_suspended_count == TX_NO_SUSPENSIONS)
 8012e8e:	687b      	ldr	r3, [r7, #4]
 8012e90:	69db      	ldr	r3, [r3, #28]
 8012e92:	2b00      	cmp	r3, #0
 8012e94:	d109      	bne.n	8012eaa <_tx_mutex_get+0x136>
                {

                    /* No other threads are suspended.  Setup the head pointer and
                       just setup this threads pointers to itself.  */
                    mutex_ptr -> tx_mutex_suspension_list =         thread_ptr;
 8012e96:	687b      	ldr	r3, [r7, #4]
 8012e98:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 8012e9a:	619a      	str	r2, [r3, #24]
                    thread_ptr -> tx_thread_suspended_next =        thread_ptr;
 8012e9c:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8012e9e:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 8012ea0:	671a      	str	r2, [r3, #112]	; 0x70
                    thread_ptr -> tx_thread_suspended_previous =    thread_ptr;
 8012ea2:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8012ea4:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 8012ea6:	675a      	str	r2, [r3, #116]	; 0x74
 8012ea8:	e011      	b.n	8012ece <_tx_mutex_get+0x15a>
                }
                else
                {

                    /* This list is not NULL, add current thread to the end. */
                    next_thread =                                   mutex_ptr -> tx_mutex_suspension_list;
 8012eaa:	687b      	ldr	r3, [r7, #4]
 8012eac:	699b      	ldr	r3, [r3, #24]
 8012eae:	637b      	str	r3, [r7, #52]	; 0x34
                    thread_ptr -> tx_thread_suspended_next =        next_thread;
 8012eb0:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8012eb2:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 8012eb4:	671a      	str	r2, [r3, #112]	; 0x70
                    previous_thread =                               next_thread -> tx_thread_suspended_previous;
 8012eb6:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8012eb8:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 8012eba:	633b      	str	r3, [r7, #48]	; 0x30
                    thread_ptr -> tx_thread_suspended_previous =    previous_thread;
 8012ebc:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8012ebe:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 8012ec0:	675a      	str	r2, [r3, #116]	; 0x74
                    previous_thread -> tx_thread_suspended_next =   thread_ptr;
 8012ec2:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8012ec4:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 8012ec6:	671a      	str	r2, [r3, #112]	; 0x70
                    next_thread -> tx_thread_suspended_previous =   thread_ptr;
 8012ec8:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8012eca:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 8012ecc:	675a      	str	r2, [r3, #116]	; 0x74
                }
            
                /* Increment the suspension count.  */
                mutex_ptr -> tx_mutex_suspended_count++;
 8012ece:	687b      	ldr	r3, [r7, #4]
 8012ed0:	69db      	ldr	r3, [r3, #28]
 8012ed2:	1c5a      	adds	r2, r3, #1
 8012ed4:	687b      	ldr	r3, [r7, #4]
 8012ed6:	61da      	str	r2, [r3, #28]

                /* Set the state to suspended.  */
                thread_ptr -> tx_thread_state =    TX_MUTEX_SUSP;
 8012ed8:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8012eda:	220d      	movs	r2, #13
 8012edc:	631a      	str	r2, [r3, #48]	; 0x30
                /* Restore interrupts.  */
                TX_RESTORE
#else

                /* Set the suspending flag.  */
                thread_ptr -> tx_thread_suspending =  TX_TRUE;
 8012ede:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8012ee0:	2201      	movs	r2, #1
 8012ee2:	639a      	str	r2, [r3, #56]	; 0x38

                /* Setup the timeout period.  */
                thread_ptr -> tx_thread_timer.tx_timer_internal_remaining_ticks =  wait_option;
 8012ee4:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8012ee6:	683a      	ldr	r2, [r7, #0]
 8012ee8:	64da      	str	r2, [r3, #76]	; 0x4c

                /* Temporarily disable preemption.  */
                _tx_thread_preempt_disable++;
 8012eea:	4b24      	ldr	r3, [pc, #144]	; (8012f7c <_tx_mutex_get+0x208>)
 8012eec:	681b      	ldr	r3, [r3, #0]
 8012eee:	3301      	adds	r3, #1
 8012ef0:	4a22      	ldr	r2, [pc, #136]	; (8012f7c <_tx_mutex_get+0x208>)
 8012ef2:	6013      	str	r3, [r2, #0]
 8012ef4:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8012ef6:	613b      	str	r3, [r7, #16]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 8012ef8:	693b      	ldr	r3, [r7, #16]
 8012efa:	f383 8810 	msr	PRIMASK, r3
}
 8012efe:	bf00      	nop
                /* Restore interrupts.  */
                TX_RESTORE

                /* Determine if we need to raise the priority of the thread 
                   owning the mutex.  */
                if (mutex_ptr -> tx_mutex_inherit == TX_TRUE)
 8012f00:	687b      	ldr	r3, [r7, #4]
 8012f02:	691b      	ldr	r3, [r3, #16]
 8012f04:	2b01      	cmp	r3, #1
 8012f06:	d121      	bne.n	8012f4c <_tx_mutex_get+0x1d8>
                {

                    /* Determine if this is the highest priority to raise for this mutex.  */
                    if (mutex_ptr -> tx_mutex_highest_priority_waiting > thread_ptr -> tx_thread_priority)
 8012f08:	687b      	ldr	r3, [r7, #4]
 8012f0a:	6a9a      	ldr	r2, [r3, #40]	; 0x28
 8012f0c:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8012f0e:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8012f10:	429a      	cmp	r2, r3
 8012f12:	d903      	bls.n	8012f1c <_tx_mutex_get+0x1a8>
                    {

                        /* Remember this priority.  */
                        mutex_ptr -> tx_mutex_highest_priority_waiting =  thread_ptr -> tx_thread_priority;
 8012f14:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8012f16:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 8012f18:	687b      	ldr	r3, [r7, #4]
 8012f1a:	629a      	str	r2, [r3, #40]	; 0x28
                    }

                    /* Determine if we have to update inherit priority level of the mutex owner.  */
                    if (thread_ptr -> tx_thread_priority < mutex_owner -> tx_thread_inherit_priority)
 8012f1c:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8012f1e:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 8012f20:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8012f22:	f8d3 309c 	ldr.w	r3, [r3, #156]	; 0x9c
 8012f26:	429a      	cmp	r2, r3
 8012f28:	d204      	bcs.n	8012f34 <_tx_mutex_get+0x1c0>
                    {
                    
                        /* Remember the new priority inheritance priority.  */
                        mutex_owner -> tx_thread_inherit_priority =  thread_ptr -> tx_thread_priority;
 8012f2a:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8012f2c:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 8012f2e:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8012f30:	f8c3 209c 	str.w	r2, [r3, #156]	; 0x9c
                    }

                    /* Priority inheritance is requested, check to see if the thread that owns the mutex is lower priority.  */
                    if (mutex_owner -> tx_thread_priority > thread_ptr -> tx_thread_priority)
 8012f34:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8012f36:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 8012f38:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8012f3a:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8012f3c:	429a      	cmp	r2, r3
 8012f3e:	d905      	bls.n	8012f4c <_tx_mutex_get+0x1d8>
                    {

                        /* Yes, raise the suspended, owning thread's priority to that
                           of the current thread.  */
                        _tx_mutex_priority_change(mutex_owner, thread_ptr -> tx_thread_priority);
 8012f40:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8012f42:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8012f44:	4619      	mov	r1, r3
 8012f46:	6bb8      	ldr	r0, [r7, #56]	; 0x38
 8012f48:	f000 f8ce 	bl	80130e8 <_tx_mutex_priority_change>
#endif
                    }
                }

                /* Call actual thread suspension routine.  */
                _tx_thread_system_suspend(thread_ptr);
 8012f4c:	6bf8      	ldr	r0, [r7, #60]	; 0x3c
 8012f4e:	f001 ffeb 	bl	8014f28 <_tx_thread_system_suspend>
#endif
                /* Return the completion status.  */
                status =  thread_ptr -> tx_thread_suspend_status;
 8012f52:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8012f54:	f8d3 3084 	ldr.w	r3, [r3, #132]	; 0x84
 8012f58:	647b      	str	r3, [r7, #68]	; 0x44
 8012f5a:	e007      	b.n	8012f6c <_tx_mutex_get+0x1f8>
 8012f5c:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8012f5e:	60fb      	str	r3, [r7, #12]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 8012f60:	68fb      	ldr	r3, [r7, #12]
 8012f62:	f383 8810 	msr	PRIMASK, r3
}
 8012f66:	bf00      	nop

            /* Restore interrupts.  */
            TX_RESTORE

            /* Immediate return, return error completion.  */
            status =  TX_NOT_AVAILABLE;
 8012f68:	231d      	movs	r3, #29
 8012f6a:	647b      	str	r3, [r7, #68]	; 0x44
        }
    }

    /* Return completion status.  */
    return(status);
 8012f6c:	6c7b      	ldr	r3, [r7, #68]	; 0x44
}
 8012f6e:	4618      	mov	r0, r3
 8012f70:	3748      	adds	r7, #72	; 0x48
 8012f72:	46bd      	mov	sp, r7
 8012f74:	bd80      	pop	{r7, pc}
 8012f76:	bf00      	nop
 8012f78:	24031bc4 	.word	0x24031bc4
 8012f7c:	24031c5c 	.word	0x24031c5c
 8012f80:	080129ed 	.word	0x080129ed

08012f84 <_tx_mutex_prioritize>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
UINT  _tx_mutex_prioritize(TX_MUTEX *mutex_ptr)
{
 8012f84:	b580      	push	{r7, lr}
 8012f86:	b092      	sub	sp, #72	; 0x48
 8012f88:	af00      	add	r7, sp, #0
 8012f8a:	6078      	str	r0, [r7, #4]
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 8012f8c:	f3ef 8310 	mrs	r3, PRIMASK
 8012f90:	627b      	str	r3, [r7, #36]	; 0x24
    return(posture);
 8012f92:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    int_posture = __get_interrupt_posture();
 8012f94:	623b      	str	r3, [r7, #32]
    __asm__ volatile ("CPSID i" : : : "memory");
 8012f96:	b672      	cpsid	i
    return(int_posture);
 8012f98:	6a3b      	ldr	r3, [r7, #32]
UINT            status;
#endif


    /* Disable interrupts.  */
    TX_DISABLE
 8012f9a:	647b      	str	r3, [r7, #68]	; 0x44

    /* Log this kernel call.  */
    TX_EL_MUTEX_PRIORITIZE_INSERT

    /* Pickup the suspended count.  */
    suspended_count =  mutex_ptr -> tx_mutex_suspended_count;
 8012f9c:	687b      	ldr	r3, [r7, #4]
 8012f9e:	69db      	ldr	r3, [r3, #28]
 8012fa0:	637b      	str	r3, [r7, #52]	; 0x34

    /* Determine if there are fewer than 2 suspended threads.  */
    if (suspended_count < ((UINT) 2))
 8012fa2:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8012fa4:	2b01      	cmp	r3, #1
 8012fa6:	d805      	bhi.n	8012fb4 <_tx_mutex_prioritize+0x30>
 8012fa8:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8012faa:	61fb      	str	r3, [r7, #28]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 8012fac:	69fb      	ldr	r3, [r7, #28]
 8012fae:	f383 8810 	msr	PRIMASK, r3
}
 8012fb2:	e092      	b.n	80130da <_tx_mutex_prioritize+0x156>
        /* Restore interrupts.  */
        TX_RESTORE
    }

    /* Determine if there how many threads are suspended on this mutex.  */
    else if (suspended_count == ((UINT) 2))
 8012fb4:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8012fb6:	2b02      	cmp	r3, #2
 8012fb8:	d114      	bne.n	8012fe4 <_tx_mutex_prioritize+0x60>
    {

        /* Pickup the head pointer and the next pointer.  */
        head_ptr =  mutex_ptr -> tx_mutex_suspension_list;
 8012fba:	687b      	ldr	r3, [r7, #4]
 8012fbc:	699b      	ldr	r3, [r3, #24]
 8012fbe:	63bb      	str	r3, [r7, #56]	; 0x38
        next_thread =  head_ptr -> tx_thread_suspended_next;
 8012fc0:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8012fc2:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 8012fc4:	62fb      	str	r3, [r7, #44]	; 0x2c

        /* Determine if the next suspended thread has a higher priority.  */
        if ((next_thread -> tx_thread_priority) < (head_ptr -> tx_thread_priority))
 8012fc6:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8012fc8:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 8012fca:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8012fcc:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8012fce:	429a      	cmp	r2, r3
 8012fd0:	d202      	bcs.n	8012fd8 <_tx_mutex_prioritize+0x54>
        {

            /* Yes, move the list head to the next thread.  */
            mutex_ptr -> tx_mutex_suspension_list =  next_thread;
 8012fd2:	687b      	ldr	r3, [r7, #4]
 8012fd4:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 8012fd6:	619a      	str	r2, [r3, #24]
 8012fd8:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8012fda:	61bb      	str	r3, [r7, #24]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 8012fdc:	69bb      	ldr	r3, [r7, #24]
 8012fde:	f383 8810 	msr	PRIMASK, r3
}
 8012fe2:	e07a      	b.n	80130da <_tx_mutex_prioritize+0x156>
    }
    else
    {

        /* Remember the suspension count and head pointer.  */
        head_ptr =   mutex_ptr -> tx_mutex_suspension_list;
 8012fe4:	687b      	ldr	r3, [r7, #4]
 8012fe6:	699b      	ldr	r3, [r3, #24]
 8012fe8:	63bb      	str	r3, [r7, #56]	; 0x38

        /* Default the highest priority thread to the thread at the front of the list.  */
        priority_thread_ptr =  head_ptr;
 8012fea:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8012fec:	63fb      	str	r3, [r7, #60]	; 0x3c

        /* Setup search pointer.  */
        thread_ptr =  priority_thread_ptr -> tx_thread_suspended_next;
 8012fee:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8012ff0:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 8012ff2:	643b      	str	r3, [r7, #64]	; 0x40

        /* Disable preemption.  */
        _tx_thread_preempt_disable++;
 8012ff4:	4b3b      	ldr	r3, [pc, #236]	; (80130e4 <_tx_mutex_prioritize+0x160>)
 8012ff6:	681b      	ldr	r3, [r3, #0]
 8012ff8:	3301      	adds	r3, #1
 8012ffa:	4a3a      	ldr	r2, [pc, #232]	; (80130e4 <_tx_mutex_prioritize+0x160>)
 8012ffc:	6013      	str	r3, [r2, #0]

        /* Set the list changed flag to false.  */
        list_changed =  TX_FALSE;
 8012ffe:	2300      	movs	r3, #0
 8013000:	633b      	str	r3, [r7, #48]	; 0x30
        /* Search through the list to find the highest priority thread.  */
        do
        {

            /* Is the current thread higher priority?  */
            if (thread_ptr -> tx_thread_priority < priority_thread_ptr -> tx_thread_priority)
 8013002:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8013004:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 8013006:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8013008:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 801300a:	429a      	cmp	r2, r3
 801300c:	d201      	bcs.n	8013012 <_tx_mutex_prioritize+0x8e>
            {

                /* Yes, remember that this thread is the highest priority.  */
                priority_thread_ptr =  thread_ptr;
 801300e:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8013010:	63fb      	str	r3, [r7, #60]	; 0x3c
 8013012:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8013014:	60fb      	str	r3, [r7, #12]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 8013016:	68fb      	ldr	r3, [r7, #12]
 8013018:	f383 8810 	msr	PRIMASK, r3
}
 801301c:	bf00      	nop
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 801301e:	f3ef 8310 	mrs	r3, PRIMASK
 8013022:	617b      	str	r3, [r7, #20]
    return(posture);
 8013024:	697b      	ldr	r3, [r7, #20]
    int_posture = __get_interrupt_posture();
 8013026:	613b      	str	r3, [r7, #16]
    __asm__ volatile ("CPSID i" : : : "memory");
 8013028:	b672      	cpsid	i
    return(int_posture);
 801302a:	693b      	ldr	r3, [r7, #16]

            /* Restore interrupts temporarily.  */
            TX_RESTORE

            /* Disable interrupts again.  */
            TX_DISABLE
 801302c:	647b      	str	r3, [r7, #68]	; 0x44

            /* Determine if any changes to the list have occurred while 
               interrupts were enabled.  */
              
            /* Is the list head the same?  */
            if (head_ptr != mutex_ptr -> tx_mutex_suspension_list)
 801302e:	687b      	ldr	r3, [r7, #4]
 8013030:	699b      	ldr	r3, [r3, #24]
 8013032:	6bba      	ldr	r2, [r7, #56]	; 0x38
 8013034:	429a      	cmp	r2, r3
 8013036:	d002      	beq.n	801303e <_tx_mutex_prioritize+0xba>
            {
            
                /* The list head has changed, set the list changed flag.  */
                list_changed =  TX_TRUE;
 8013038:	2301      	movs	r3, #1
 801303a:	633b      	str	r3, [r7, #48]	; 0x30
 801303c:	e006      	b.n	801304c <_tx_mutex_prioritize+0xc8>
            }
            else
            {
            
                /* Is the suspended count the same?  */
                if (suspended_count != mutex_ptr -> tx_mutex_suspended_count)
 801303e:	687b      	ldr	r3, [r7, #4]
 8013040:	69db      	ldr	r3, [r3, #28]
 8013042:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 8013044:	429a      	cmp	r2, r3
 8013046:	d001      	beq.n	801304c <_tx_mutex_prioritize+0xc8>
                {
              
                    /* The list head has changed, set the list changed flag.  */
                    list_changed =  TX_TRUE;
 8013048:	2301      	movs	r3, #1
 801304a:	633b      	str	r3, [r7, #48]	; 0x30
                }
            }
             
            /* Determine if the list has changed.  */
            if (list_changed == TX_FALSE)
 801304c:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801304e:	2b00      	cmp	r3, #0
 8013050:	d103      	bne.n	801305a <_tx_mutex_prioritize+0xd6>
            {

                /* Move the thread pointer to the next thread.  */
                thread_ptr =  thread_ptr -> tx_thread_suspended_next;
 8013052:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8013054:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 8013056:	643b      	str	r3, [r7, #64]	; 0x40
 8013058:	e00c      	b.n	8013074 <_tx_mutex_prioritize+0xf0>
            }
            else
            {

                /* Remember the suspension count and head pointer.  */
                head_ptr =   mutex_ptr -> tx_mutex_suspension_list;
 801305a:	687b      	ldr	r3, [r7, #4]
 801305c:	699b      	ldr	r3, [r3, #24]
 801305e:	63bb      	str	r3, [r7, #56]	; 0x38
                suspended_count =  mutex_ptr -> tx_mutex_suspended_count;
 8013060:	687b      	ldr	r3, [r7, #4]
 8013062:	69db      	ldr	r3, [r3, #28]
 8013064:	637b      	str	r3, [r7, #52]	; 0x34

                /* Default the highest priority thread to the thread at the front of the list.  */
                priority_thread_ptr =  head_ptr;
 8013066:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8013068:	63fb      	str	r3, [r7, #60]	; 0x3c

                /* Setup search pointer.  */
                thread_ptr =  priority_thread_ptr -> tx_thread_suspended_next;
 801306a:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 801306c:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 801306e:	643b      	str	r3, [r7, #64]	; 0x40

                /* Reset the list changed flag.  */
                list_changed =  TX_FALSE;
 8013070:	2300      	movs	r3, #0
 8013072:	633b      	str	r3, [r7, #48]	; 0x30
            }

        } while (thread_ptr != head_ptr);
 8013074:	6c3a      	ldr	r2, [r7, #64]	; 0x40
 8013076:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8013078:	429a      	cmp	r2, r3
 801307a:	d1c2      	bne.n	8013002 <_tx_mutex_prioritize+0x7e>

        /* Release preemption.  */
        _tx_thread_preempt_disable--;
 801307c:	4b19      	ldr	r3, [pc, #100]	; (80130e4 <_tx_mutex_prioritize+0x160>)
 801307e:	681b      	ldr	r3, [r3, #0]
 8013080:	3b01      	subs	r3, #1
 8013082:	4a18      	ldr	r2, [pc, #96]	; (80130e4 <_tx_mutex_prioritize+0x160>)
 8013084:	6013      	str	r3, [r2, #0]

        /* Now determine if the highest priority thread is at the front 
           of the list.  */
        if (priority_thread_ptr != head_ptr)
 8013086:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 8013088:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 801308a:	429a      	cmp	r2, r3
 801308c:	d01d      	beq.n	80130ca <_tx_mutex_prioritize+0x146>
            /* No, we need to move the highest priority suspended thread to the 
               front of the list.  */

            /* First, remove the highest priority thread by updating the
               adjacent suspended threads.  */
            next_thread =                                  priority_thread_ptr -> tx_thread_suspended_next;
 801308e:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8013090:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 8013092:	62fb      	str	r3, [r7, #44]	; 0x2c
            previous_thread =                              priority_thread_ptr -> tx_thread_suspended_previous;
 8013094:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8013096:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 8013098:	62bb      	str	r3, [r7, #40]	; 0x28
            next_thread -> tx_thread_suspended_previous =  previous_thread;
 801309a:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 801309c:	6aba      	ldr	r2, [r7, #40]	; 0x28
 801309e:	675a      	str	r2, [r3, #116]	; 0x74
            previous_thread -> tx_thread_suspended_next =  next_thread;
 80130a0:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80130a2:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 80130a4:	671a      	str	r2, [r3, #112]	; 0x70

            /* Now, link the highest priority thread at the front of the list.  */
            previous_thread =                                      head_ptr -> tx_thread_suspended_previous;
 80130a6:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 80130a8:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 80130aa:	62bb      	str	r3, [r7, #40]	; 0x28
            priority_thread_ptr -> tx_thread_suspended_next =      head_ptr;
 80130ac:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 80130ae:	6bba      	ldr	r2, [r7, #56]	; 0x38
 80130b0:	671a      	str	r2, [r3, #112]	; 0x70
            priority_thread_ptr -> tx_thread_suspended_previous =  previous_thread;
 80130b2:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 80130b4:	6aba      	ldr	r2, [r7, #40]	; 0x28
 80130b6:	675a      	str	r2, [r3, #116]	; 0x74
            previous_thread -> tx_thread_suspended_next =          priority_thread_ptr;
 80130b8:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80130ba:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 80130bc:	671a      	str	r2, [r3, #112]	; 0x70
            head_ptr -> tx_thread_suspended_previous =             priority_thread_ptr;
 80130be:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 80130c0:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 80130c2:	675a      	str	r2, [r3, #116]	; 0x74

            /* Move the list head pointer to the highest priority suspended thread.  */
            mutex_ptr -> tx_mutex_suspension_list =  priority_thread_ptr;
 80130c4:	687b      	ldr	r3, [r7, #4]
 80130c6:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 80130c8:	619a      	str	r2, [r3, #24]
 80130ca:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 80130cc:	60bb      	str	r3, [r7, #8]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 80130ce:	68bb      	ldr	r3, [r7, #8]
 80130d0:	f383 8810 	msr	PRIMASK, r3
}
 80130d4:	bf00      	nop

        /* Restore interrupts.  */
        TX_RESTORE

        /* Check for preemption.  */
        _tx_thread_system_preempt_check();
 80130d6:	f001 fded 	bl	8014cb4 <_tx_thread_system_preempt_check>
    /* Return completion status.  */
    return(status);
#else

    /* Return successful completion.  */
    return(TX_SUCCESS);
 80130da:	2300      	movs	r3, #0
#endif
}
 80130dc:	4618      	mov	r0, r3
 80130de:	3748      	adds	r7, #72	; 0x48
 80130e0:	46bd      	mov	sp, r7
 80130e2:	bd80      	pop	{r7, pc}
 80130e4:	24031c5c 	.word	0x24031c5c

080130e8 <_tx_mutex_priority_change>:
/*                                            priority rather than next,  */
/*                                            resulting in version 6.1.6  */
/*                                                                        */
/**************************************************************************/
VOID  _tx_mutex_priority_change(TX_THREAD *thread_ptr, UINT new_priority)
{
 80130e8:	b580      	push	{r7, lr}
 80130ea:	b090      	sub	sp, #64	; 0x40
 80130ec:	af00      	add	r7, sp, #0
 80130ee:	6078      	str	r0, [r7, #4]
 80130f0:	6039      	str	r1, [r7, #0]
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 80130f2:	f3ef 8310 	mrs	r3, PRIMASK
 80130f6:	62fb      	str	r3, [r7, #44]	; 0x2c
    return(posture);
 80130f8:	6afb      	ldr	r3, [r7, #44]	; 0x2c
    int_posture = __get_interrupt_posture();
 80130fa:	62bb      	str	r3, [r7, #40]	; 0x28
    __asm__ volatile ("CPSID i" : : : "memory");
 80130fc:	b672      	cpsid	i
    return(int_posture);
 80130fe:	6abb      	ldr	r3, [r7, #40]	; 0x28


#ifndef TX_NOT_INTERRUPTABLE

    /* Lockout interrupts while the thread is being suspended.  */
    TX_DISABLE
 8013100:	63fb      	str	r3, [r7, #60]	; 0x3c
#endif

    /* Determine if this thread is currently ready.  */
    if (thread_ptr -> tx_thread_state != TX_READY)
 8013102:	687b      	ldr	r3, [r7, #4]
 8013104:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8013106:	2b00      	cmp	r3, #0
 8013108:	d017      	beq.n	801313a <_tx_mutex_priority_change+0x52>
    {

        /* Change thread priority to the new mutex priority-inheritance priority.  */
        thread_ptr -> tx_thread_priority =  new_priority;
 801310a:	687b      	ldr	r3, [r7, #4]
 801310c:	683a      	ldr	r2, [r7, #0]
 801310e:	62da      	str	r2, [r3, #44]	; 0x2c
            
        /* Determine how to setup the thread's preemption-threshold.  */
        if (thread_ptr -> tx_thread_user_preempt_threshold < new_priority)
 8013110:	687b      	ldr	r3, [r7, #4]
 8013112:	f8d3 3098 	ldr.w	r3, [r3, #152]	; 0x98
 8013116:	683a      	ldr	r2, [r7, #0]
 8013118:	429a      	cmp	r2, r3
 801311a:	d905      	bls.n	8013128 <_tx_mutex_priority_change+0x40>
        {
        
            /* Change thread preemption-threshold to the user's preemption-threshold.  */
            thread_ptr -> tx_thread_preempt_threshold =  thread_ptr -> tx_thread_user_preempt_threshold;
 801311c:	687b      	ldr	r3, [r7, #4]
 801311e:	f8d3 2098 	ldr.w	r2, [r3, #152]	; 0x98
 8013122:	687b      	ldr	r3, [r7, #4]
 8013124:	63da      	str	r2, [r3, #60]	; 0x3c
 8013126:	e002      	b.n	801312e <_tx_mutex_priority_change+0x46>
        }
        else
        {
        
            /* Change the thread preemption-threshold to the new threshold.  */
            thread_ptr -> tx_thread_preempt_threshold =  new_priority;
 8013128:	687b      	ldr	r3, [r7, #4]
 801312a:	683a      	ldr	r2, [r7, #0]
 801312c:	63da      	str	r2, [r3, #60]	; 0x3c
 801312e:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8013130:	627b      	str	r3, [r7, #36]	; 0x24
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 8013132:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8013134:	f383 8810 	msr	PRIMASK, r3
}
 8013138:	e089      	b.n	801324e <_tx_mutex_priority_change+0x166>
    }
    else
    {

        /* Pickup the next thread to execute.  */
        execute_ptr =  _tx_thread_execute_ptr;
 801313a:	4b47      	ldr	r3, [pc, #284]	; (8013258 <_tx_mutex_priority_change+0x170>)
 801313c:	681b      	ldr	r3, [r3, #0]
 801313e:	63bb      	str	r3, [r7, #56]	; 0x38

        /* Save the original priority.  */
        original_priority =  thread_ptr -> tx_thread_priority;
 8013140:	687b      	ldr	r3, [r7, #4]
 8013142:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8013144:	637b      	str	r3, [r7, #52]	; 0x34
        /* Decrement the preempt disable flag.  */
        _tx_thread_preempt_disable--;
#else

        /* Increment the preempt disable flag.  */
        _tx_thread_preempt_disable =  _tx_thread_preempt_disable + ((UINT) 2);
 8013146:	4b45      	ldr	r3, [pc, #276]	; (801325c <_tx_mutex_priority_change+0x174>)
 8013148:	681b      	ldr	r3, [r3, #0]
 801314a:	3302      	adds	r3, #2
 801314c:	4a43      	ldr	r2, [pc, #268]	; (801325c <_tx_mutex_priority_change+0x174>)
 801314e:	6013      	str	r3, [r2, #0]

        /* Set the state to priority change.  */
        thread_ptr -> tx_thread_state =    TX_PRIORITY_CHANGE;
 8013150:	687b      	ldr	r3, [r7, #4]
 8013152:	220e      	movs	r2, #14
 8013154:	631a      	str	r2, [r3, #48]	; 0x30

        /* Set the suspending flag. */
        thread_ptr -> tx_thread_suspending =  TX_TRUE;
 8013156:	687b      	ldr	r3, [r7, #4]
 8013158:	2201      	movs	r2, #1
 801315a:	639a      	str	r2, [r3, #56]	; 0x38

        /* Setup the timeout period.  */
        thread_ptr -> tx_thread_timer.tx_timer_internal_remaining_ticks =  ((ULONG) 0);
 801315c:	687b      	ldr	r3, [r7, #4]
 801315e:	2200      	movs	r2, #0
 8013160:	64da      	str	r2, [r3, #76]	; 0x4c
 8013162:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8013164:	61bb      	str	r3, [r7, #24]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 8013166:	69bb      	ldr	r3, [r7, #24]
 8013168:	f383 8810 	msr	PRIMASK, r3
}
 801316c:	bf00      	nop
        /* Restore interrupts.  */
        TX_RESTORE

        /* The thread is ready and must first be removed from the list.  Call the 
           system suspend function to accomplish this.  */
        _tx_thread_system_suspend(thread_ptr);
 801316e:	6878      	ldr	r0, [r7, #4]
 8013170:	f001 feda 	bl	8014f28 <_tx_thread_system_suspend>
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 8013174:	f3ef 8310 	mrs	r3, PRIMASK
 8013178:	623b      	str	r3, [r7, #32]
    return(posture);
 801317a:	6a3b      	ldr	r3, [r7, #32]
    int_posture = __get_interrupt_posture();
 801317c:	61fb      	str	r3, [r7, #28]
    __asm__ volatile ("CPSID i" : : : "memory");
 801317e:	b672      	cpsid	i
    return(int_posture);
 8013180:	69fb      	ldr	r3, [r7, #28]

        /* Disable interrupts.  */
        TX_DISABLE
 8013182:	63fb      	str	r3, [r7, #60]	; 0x3c

        /* At this point, the preempt disable flag is still set, so we still have 
           protection against all preemption.  */

        /* Change thread priority to the new mutex priority-inheritance priority.  */
        thread_ptr -> tx_thread_priority =  new_priority;
 8013184:	687b      	ldr	r3, [r7, #4]
 8013186:	683a      	ldr	r2, [r7, #0]
 8013188:	62da      	str	r2, [r3, #44]	; 0x2c
            
        /* Determine how to setup the thread's preemption-threshold.  */
        if (thread_ptr -> tx_thread_user_preempt_threshold < new_priority)
 801318a:	687b      	ldr	r3, [r7, #4]
 801318c:	f8d3 3098 	ldr.w	r3, [r3, #152]	; 0x98
 8013190:	683a      	ldr	r2, [r7, #0]
 8013192:	429a      	cmp	r2, r3
 8013194:	d905      	bls.n	80131a2 <_tx_mutex_priority_change+0xba>
        {
        
            /* Change thread preemption-threshold to the user's preemption-threshold.  */
            thread_ptr -> tx_thread_preempt_threshold =  thread_ptr -> tx_thread_user_preempt_threshold;
 8013196:	687b      	ldr	r3, [r7, #4]
 8013198:	f8d3 2098 	ldr.w	r2, [r3, #152]	; 0x98
 801319c:	687b      	ldr	r3, [r7, #4]
 801319e:	63da      	str	r2, [r3, #60]	; 0x3c
 80131a0:	e002      	b.n	80131a8 <_tx_mutex_priority_change+0xc0>
        }
        else
        {
        
            /* Change the thread preemption-threshold to the new threshold.  */
            thread_ptr -> tx_thread_preempt_threshold =  new_priority;
 80131a2:	687b      	ldr	r3, [r7, #4]
 80131a4:	683a      	ldr	r2, [r7, #0]
 80131a6:	63da      	str	r2, [r3, #60]	; 0x3c
 80131a8:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 80131aa:	60fb      	str	r3, [r7, #12]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 80131ac:	68fb      	ldr	r3, [r7, #12]
 80131ae:	f383 8810 	msr	PRIMASK, r3
}
 80131b2:	bf00      	nop

        /* Restore interrupts.  */
        TX_RESTORE

        /* Resume the thread with the new priority.  */
        _tx_thread_system_resume(thread_ptr);
 80131b4:	6878      	ldr	r0, [r7, #4]
 80131b6:	f001 fdb7 	bl	8014d28 <_tx_thread_system_resume>
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 80131ba:	f3ef 8310 	mrs	r3, PRIMASK
 80131be:	617b      	str	r3, [r7, #20]
    return(posture);
 80131c0:	697b      	ldr	r3, [r7, #20]
    int_posture = __get_interrupt_posture();
 80131c2:	613b      	str	r3, [r7, #16]
    __asm__ volatile ("CPSID i" : : : "memory");
 80131c4:	b672      	cpsid	i
    return(int_posture);
 80131c6:	693b      	ldr	r3, [r7, #16]
        TX_MUTEX_PRIORITY_CHANGE_EXTENSION

#ifndef TX_NOT_INTERRUPTABLE

        /* Disable interrupts.  */
        TX_DISABLE
 80131c8:	63fb      	str	r3, [r7, #60]	; 0x3c
#endif
        
        /* Pickup the next thread to execute.  */
        next_execute_ptr =  _tx_thread_execute_ptr;
 80131ca:	4b23      	ldr	r3, [pc, #140]	; (8013258 <_tx_mutex_priority_change+0x170>)
 80131cc:	681b      	ldr	r3, [r3, #0]
 80131ce:	633b      	str	r3, [r7, #48]	; 0x30

        /* Determine if this thread is not the next thread to execute.  */
        if (thread_ptr != next_execute_ptr)
 80131d0:	687a      	ldr	r2, [r7, #4]
 80131d2:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 80131d4:	429a      	cmp	r2, r3
 80131d6:	d034      	beq.n	8013242 <_tx_mutex_priority_change+0x15a>
        {
        
            /* Make sure the thread is still ready.  */
            if (thread_ptr -> tx_thread_state == TX_READY)
 80131d8:	687b      	ldr	r3, [r7, #4]
 80131da:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 80131dc:	2b00      	cmp	r3, #0
 80131de:	d130      	bne.n	8013242 <_tx_mutex_priority_change+0x15a>
            {

                /* Now check and see if this thread has an equal or higher priority.  */
                if (thread_ptr -> tx_thread_priority <= next_execute_ptr -> tx_thread_priority)
 80131e0:	687b      	ldr	r3, [r7, #4]
 80131e2:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 80131e4:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 80131e6:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 80131e8:	429a      	cmp	r2, r3
 80131ea:	d811      	bhi.n	8013210 <_tx_mutex_priority_change+0x128>
                {

                    /* Now determine if this thread was the previously executing thread.  */
                    if (thread_ptr == execute_ptr)
 80131ec:	687a      	ldr	r2, [r7, #4]
 80131ee:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 80131f0:	429a      	cmp	r2, r3
 80131f2:	d126      	bne.n	8013242 <_tx_mutex_priority_change+0x15a>

                        /* Yes, this thread was previously executing before we temporarily suspended and resumed
                           it in order to change the priority. A lower or same priority thread cannot be the next thread
                           to execute in this case since this thread really didn't suspend.  Simply reset the execute
                           pointer to this thread.  */
                        _tx_thread_execute_ptr =  thread_ptr;
 80131f4:	4a18      	ldr	r2, [pc, #96]	; (8013258 <_tx_mutex_priority_change+0x170>)
 80131f6:	687b      	ldr	r3, [r7, #4]
 80131f8:	6013      	str	r3, [r2, #0]

                        /* Determine if we moved to a lower priority. If so, move the thread to the front of its priority list.  */
                        if (original_priority < new_priority)
 80131fa:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 80131fc:	683b      	ldr	r3, [r7, #0]
 80131fe:	429a      	cmp	r2, r3
 8013200:	d21f      	bcs.n	8013242 <_tx_mutex_priority_change+0x15a>
                        {
                        
                            /* Ensure that this thread is placed at the front of the priority list.  */
                            _tx_thread_priority_list[thread_ptr -> tx_thread_priority] =  thread_ptr;
 8013202:	687b      	ldr	r3, [r7, #4]
 8013204:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8013206:	4916      	ldr	r1, [pc, #88]	; (8013260 <_tx_mutex_priority_change+0x178>)
 8013208:	687a      	ldr	r2, [r7, #4]
 801320a:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
 801320e:	e018      	b.n	8013242 <_tx_mutex_priority_change+0x15a>
                }
                else
                {

                    /* Now determine if this thread's preemption-threshold needs to be enforced.  */
                    if (thread_ptr -> tx_thread_preempt_threshold < thread_ptr -> tx_thread_priority)
 8013210:	687b      	ldr	r3, [r7, #4]
 8013212:	6bda      	ldr	r2, [r3, #60]	; 0x3c
 8013214:	687b      	ldr	r3, [r7, #4]
 8013216:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8013218:	429a      	cmp	r2, r3
 801321a:	d212      	bcs.n	8013242 <_tx_mutex_priority_change+0x15a>
                    {

                        /* Yes, preemption-threshold is in force for this thread. */

                        /* Compare the next thread to execute thread's priority against the thread's preemption-threshold.  */
                        if (thread_ptr -> tx_thread_preempt_threshold <= next_execute_ptr -> tx_thread_priority)
 801321c:	687b      	ldr	r3, [r7, #4]
 801321e:	6bda      	ldr	r2, [r3, #60]	; 0x3c
 8013220:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8013222:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8013224:	429a      	cmp	r2, r3
 8013226:	d80c      	bhi.n	8013242 <_tx_mutex_priority_change+0x15a>
                        {
                
                            /* We must swap execute pointers to enforce the preemption-threshold of a thread coming out of
                               priority inheritance.  */
                            _tx_thread_execute_ptr =  thread_ptr;
 8013228:	4a0b      	ldr	r2, [pc, #44]	; (8013258 <_tx_mutex_priority_change+0x170>)
 801322a:	687b      	ldr	r3, [r7, #4]
 801322c:	6013      	str	r3, [r2, #0]

                            /* Determine if we moved to a lower priority. If so, move the thread to the front of its priority list.  */
                            if (original_priority < new_priority)
 801322e:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 8013230:	683b      	ldr	r3, [r7, #0]
 8013232:	429a      	cmp	r2, r3
 8013234:	d205      	bcs.n	8013242 <_tx_mutex_priority_change+0x15a>
                            {
                        
                                /* Ensure that this thread is placed at the front of the priority list.  */
                                _tx_thread_priority_list[thread_ptr -> tx_thread_priority] =  thread_ptr;
 8013236:	687b      	ldr	r3, [r7, #4]
 8013238:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 801323a:	4909      	ldr	r1, [pc, #36]	; (8013260 <_tx_mutex_priority_change+0x178>)
 801323c:	687a      	ldr	r2, [r7, #4]
 801323e:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
 8013242:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8013244:	60bb      	str	r3, [r7, #8]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 8013246:	68bb      	ldr	r3, [r7, #8]
 8013248:	f383 8810 	msr	PRIMASK, r3
}
 801324c:	bf00      	nop
        
        /* Restore interrupts.  */
        TX_RESTORE
#endif
    }
}
 801324e:	bf00      	nop
 8013250:	3740      	adds	r7, #64	; 0x40
 8013252:	46bd      	mov	sp, r7
 8013254:	bd80      	pop	{r7, pc}
 8013256:	bf00      	nop
 8013258:	24031bc8 	.word	0x24031bc8
 801325c:	24031c5c 	.word	0x24031c5c
 8013260:	24031bdc 	.word	0x24031bdc

08013264 <_tx_mutex_put>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
UINT  _tx_mutex_put(TX_MUTEX *mutex_ptr)
{
 8013264:	b580      	push	{r7, lr}
 8013266:	b0a6      	sub	sp, #152	; 0x98
 8013268:	af00      	add	r7, sp, #0
 801326a:	6078      	str	r0, [r7, #4]
TX_THREAD       *suspended_thread;
UINT            inheritance_priority;


    /* Setup status to indicate the processing is not complete.  */
    status =  TX_NOT_DONE;
 801326c:	2320      	movs	r3, #32
 801326e:	f8c7 3088 	str.w	r3, [r7, #136]	; 0x88
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 8013272:	f3ef 8310 	mrs	r3, PRIMASK
 8013276:	65fb      	str	r3, [r7, #92]	; 0x5c
    return(posture);
 8013278:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
    int_posture = __get_interrupt_posture();
 801327a:	65bb      	str	r3, [r7, #88]	; 0x58
    __asm__ volatile ("CPSID i" : : : "memory");
 801327c:	b672      	cpsid	i
    return(int_posture);
 801327e:	6dbb      	ldr	r3, [r7, #88]	; 0x58

    /* Disable interrupts to put an instance back to the mutex.  */
    TX_DISABLE
 8013280:	f8c7 3094 	str.w	r3, [r7, #148]	; 0x94

    /* Log this kernel call.  */
    TX_EL_MUTEX_PUT_INSERT

    /* Determine if this mutex is owned.  */
    if (mutex_ptr -> tx_mutex_ownership_count != ((UINT) 0))
 8013284:	687b      	ldr	r3, [r7, #4]
 8013286:	689b      	ldr	r3, [r3, #8]
 8013288:	2b00      	cmp	r3, #0
 801328a:	f000 81ff 	beq.w	801368c <_tx_mutex_put+0x428>
    {

        /* Pickup the owning thread pointer.  */
        thread_ptr =  mutex_ptr -> tx_mutex_owner;
 801328e:	687b      	ldr	r3, [r7, #4]
 8013290:	68db      	ldr	r3, [r3, #12]
 8013292:	67fb      	str	r3, [r7, #124]	; 0x7c

        /* Pickup thread pointer.  */
        TX_THREAD_GET_CURRENT(current_thread)
 8013294:	4ba3      	ldr	r3, [pc, #652]	; (8013524 <_tx_mutex_put+0x2c0>)
 8013296:	681b      	ldr	r3, [r3, #0]
 8013298:	67bb      	str	r3, [r7, #120]	; 0x78

        /* Check to see if the mutex is owned by the calling thread.  */
        if (mutex_ptr -> tx_mutex_owner != current_thread)
 801329a:	687b      	ldr	r3, [r7, #4]
 801329c:	68db      	ldr	r3, [r3, #12]
 801329e:	6fba      	ldr	r2, [r7, #120]	; 0x78
 80132a0:	429a      	cmp	r2, r3
 80132a2:	d00d      	beq.n	80132c0 <_tx_mutex_put+0x5c>
        {
        
            /* Determine if the preempt disable flag is set, indicating that 
               the caller is not the application but from ThreadX. In such
               cases, the thread mutex owner does not need to match.  */
            if (_tx_thread_preempt_disable == ((UINT) 0))
 80132a4:	4ba0      	ldr	r3, [pc, #640]	; (8013528 <_tx_mutex_put+0x2c4>)
 80132a6:	681b      	ldr	r3, [r3, #0]
 80132a8:	2b00      	cmp	r3, #0
 80132aa:	d109      	bne.n	80132c0 <_tx_mutex_put+0x5c>
 80132ac:	f8d7 3094 	ldr.w	r3, [r7, #148]	; 0x94
 80132b0:	657b      	str	r3, [r7, #84]	; 0x54
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 80132b2:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 80132b4:	f383 8810 	msr	PRIMASK, r3
}
 80132b8:	bf00      	nop

                /* Restore interrupts.  */
                TX_RESTORE

                /* Caller does not own the mutex.  */
                status =  TX_NOT_OWNED;
 80132ba:	231e      	movs	r3, #30
 80132bc:	f8c7 3088 	str.w	r3, [r7, #136]	; 0x88
            }
        }
        
        /* Determine if we should continue.  */
        if (status == TX_NOT_DONE)
 80132c0:	f8d7 3088 	ldr.w	r3, [r7, #136]	; 0x88
 80132c4:	2b20      	cmp	r3, #32
 80132c6:	f040 81eb 	bne.w	80136a0 <_tx_mutex_put+0x43c>
        {
    
            /* Decrement the mutex ownership count.  */
            mutex_ptr -> tx_mutex_ownership_count--;
 80132ca:	687b      	ldr	r3, [r7, #4]
 80132cc:	689b      	ldr	r3, [r3, #8]
 80132ce:	1e5a      	subs	r2, r3, #1
 80132d0:	687b      	ldr	r3, [r7, #4]
 80132d2:	609a      	str	r2, [r3, #8]

            /* Determine if the mutex is still owned by the current thread.  */
            if (mutex_ptr -> tx_mutex_ownership_count != ((UINT) 0))
 80132d4:	687b      	ldr	r3, [r7, #4]
 80132d6:	689b      	ldr	r3, [r3, #8]
 80132d8:	2b00      	cmp	r3, #0
 80132da:	d00a      	beq.n	80132f2 <_tx_mutex_put+0x8e>
 80132dc:	f8d7 3094 	ldr.w	r3, [r7, #148]	; 0x94
 80132e0:	653b      	str	r3, [r7, #80]	; 0x50
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 80132e2:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 80132e4:	f383 8810 	msr	PRIMASK, r3
}
 80132e8:	bf00      	nop

                /* Restore interrupts.  */
                TX_RESTORE

                /* Mutex is still owned, just return successful status.  */
                status =  TX_SUCCESS;
 80132ea:	2300      	movs	r3, #0
 80132ec:	f8c7 3088 	str.w	r3, [r7, #136]	; 0x88
 80132f0:	e1d6      	b.n	80136a0 <_tx_mutex_put+0x43c>
            }
            else
            {

                /* Check for a NULL thread pointer, which can only happen during initialization.   */
                if (thread_ptr == TX_NULL)
 80132f2:	6ffb      	ldr	r3, [r7, #124]	; 0x7c
 80132f4:	2b00      	cmp	r3, #0
 80132f6:	d10a      	bne.n	801330e <_tx_mutex_put+0xaa>
 80132f8:	f8d7 3094 	ldr.w	r3, [r7, #148]	; 0x94
 80132fc:	64fb      	str	r3, [r7, #76]	; 0x4c
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 80132fe:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8013300:	f383 8810 	msr	PRIMASK, r3
}
 8013304:	bf00      	nop

                    /* Restore interrupts.  */
                    TX_RESTORE

                    /* Mutex is now available, return successful status.  */
                    status =  TX_SUCCESS;
 8013306:	2300      	movs	r3, #0
 8013308:	f8c7 3088 	str.w	r3, [r7, #136]	; 0x88
 801330c:	e1c8      	b.n	80136a0 <_tx_mutex_put+0x43c>
                    /* The mutex is now available.   */
            
                    /* Remove this mutex from the owned mutex list.  */
                    
                    /* Decrement the ownership count.  */
                    thread_ptr -> tx_thread_owned_mutex_count--;
 801330e:	6ffb      	ldr	r3, [r7, #124]	; 0x7c
 8013310:	f8d3 30a0 	ldr.w	r3, [r3, #160]	; 0xa0
 8013314:	1e5a      	subs	r2, r3, #1
 8013316:	6ffb      	ldr	r3, [r7, #124]	; 0x7c
 8013318:	f8c3 20a0 	str.w	r2, [r3, #160]	; 0xa0

                    /* Determine if this mutex was the only one on the list.  */
                    if (thread_ptr -> tx_thread_owned_mutex_count == ((UINT) 0))
 801331c:	6ffb      	ldr	r3, [r7, #124]	; 0x7c
 801331e:	f8d3 30a0 	ldr.w	r3, [r3, #160]	; 0xa0
 8013322:	2b00      	cmp	r3, #0
 8013324:	d104      	bne.n	8013330 <_tx_mutex_put+0xcc>
                    {

                        /* Yes, the list is empty.  Simply set the head pointer to NULL.  */
                        thread_ptr -> tx_thread_owned_mutex_list =  TX_NULL;
 8013326:	6ffb      	ldr	r3, [r7, #124]	; 0x7c
 8013328:	2200      	movs	r2, #0
 801332a:	f8c3 20a4 	str.w	r2, [r3, #164]	; 0xa4
 801332e:	e019      	b.n	8013364 <_tx_mutex_put+0x100>
                    {

                        /* No, there are more mutexes on the list.  */

                        /* Link-up the neighbors.  */
                        next_mutex =                             mutex_ptr -> tx_mutex_owned_next;
 8013330:	687b      	ldr	r3, [r7, #4]
 8013332:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8013334:	f8c7 3084 	str.w	r3, [r7, #132]	; 0x84
                        previous_mutex =                         mutex_ptr -> tx_mutex_owned_previous;
 8013338:	687b      	ldr	r3, [r7, #4]
 801333a:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 801333c:	677b      	str	r3, [r7, #116]	; 0x74
                        next_mutex -> tx_mutex_owned_previous =  previous_mutex;
 801333e:	f8d7 3084 	ldr.w	r3, [r7, #132]	; 0x84
 8013342:	6f7a      	ldr	r2, [r7, #116]	; 0x74
 8013344:	631a      	str	r2, [r3, #48]	; 0x30
                        previous_mutex -> tx_mutex_owned_next =  next_mutex;
 8013346:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 8013348:	f8d7 2084 	ldr.w	r2, [r7, #132]	; 0x84
 801334c:	62da      	str	r2, [r3, #44]	; 0x2c

                        /* See if we have to update the created list head pointer.  */
                        if (thread_ptr -> tx_thread_owned_mutex_list == mutex_ptr)
 801334e:	6ffb      	ldr	r3, [r7, #124]	; 0x7c
 8013350:	f8d3 30a4 	ldr.w	r3, [r3, #164]	; 0xa4
 8013354:	687a      	ldr	r2, [r7, #4]
 8013356:	429a      	cmp	r2, r3
 8013358:	d104      	bne.n	8013364 <_tx_mutex_put+0x100>
                        {

                            /* Yes, move the head pointer to the next link. */
                            thread_ptr -> tx_thread_owned_mutex_list =  next_mutex;
 801335a:	6ffb      	ldr	r3, [r7, #124]	; 0x7c
 801335c:	f8d7 2084 	ldr.w	r2, [r7, #132]	; 0x84
 8013360:	f8c3 20a4 	str.w	r2, [r3, #164]	; 0xa4
                        }
                    }

                    /* Determine if the simple, non-suspension, non-priority inheritance case is present.  */
                    if (mutex_ptr -> tx_mutex_suspension_list == TX_NULL)
 8013364:	687b      	ldr	r3, [r7, #4]
 8013366:	699b      	ldr	r3, [r3, #24]
 8013368:	2b00      	cmp	r3, #0
 801336a:	d110      	bne.n	801338e <_tx_mutex_put+0x12a>
                    {
                    
                        /* Is this a priority inheritance mutex?  */
                        if (mutex_ptr -> tx_mutex_inherit == TX_FALSE)
 801336c:	687b      	ldr	r3, [r7, #4]
 801336e:	691b      	ldr	r3, [r3, #16]
 8013370:	2b00      	cmp	r3, #0
 8013372:	d10c      	bne.n	801338e <_tx_mutex_put+0x12a>
                        {

                            /* Yes, we are done - set the mutex owner to NULL.   */
                            mutex_ptr -> tx_mutex_owner =  TX_NULL;
 8013374:	687b      	ldr	r3, [r7, #4]
 8013376:	2200      	movs	r2, #0
 8013378:	60da      	str	r2, [r3, #12]
 801337a:	f8d7 3094 	ldr.w	r3, [r7, #148]	; 0x94
 801337e:	64bb      	str	r3, [r7, #72]	; 0x48
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 8013380:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 8013382:	f383 8810 	msr	PRIMASK, r3
}
 8013386:	bf00      	nop
                            
                            /* Restore interrupts.  */
                            TX_RESTORE

                            /* Mutex is now available, return successful status.  */
                            status =  TX_SUCCESS;
 8013388:	2300      	movs	r3, #0
 801338a:	f8c7 3088 	str.w	r3, [r7, #136]	; 0x88
                        }
                    }
                     
                    /* Determine if the processing is complete.  */
                    if (status == TX_NOT_DONE)
 801338e:	f8d7 3088 	ldr.w	r3, [r7, #136]	; 0x88
 8013392:	2b20      	cmp	r3, #32
 8013394:	f040 8184 	bne.w	80136a0 <_tx_mutex_put+0x43c>
                    {
   
                        /* Initialize original owner and thread priority.  */
                        old_owner =      TX_NULL;
 8013398:	2300      	movs	r3, #0
 801339a:	f8c7 3090 	str.w	r3, [r7, #144]	; 0x90
                        old_priority =   thread_ptr -> tx_thread_user_priority;
 801339e:	6ffb      	ldr	r3, [r7, #124]	; 0x7c
 80133a0:	f8d3 3094 	ldr.w	r3, [r3, #148]	; 0x94
 80133a4:	f8c7 308c 	str.w	r3, [r7, #140]	; 0x8c

                        /* Does this mutex support priority inheritance?  */
                        if (mutex_ptr -> tx_mutex_inherit == TX_TRUE)
 80133a8:	687b      	ldr	r3, [r7, #4]
 80133aa:	691b      	ldr	r3, [r3, #16]
 80133ac:	2b01      	cmp	r3, #1
 80133ae:	d155      	bne.n	801345c <_tx_mutex_put+0x1f8>
                        {

#ifndef TX_NOT_INTERRUPTABLE

                            /* Temporarily disable preemption.  */
                            _tx_thread_preempt_disable++;
 80133b0:	4b5d      	ldr	r3, [pc, #372]	; (8013528 <_tx_mutex_put+0x2c4>)
 80133b2:	681b      	ldr	r3, [r3, #0]
 80133b4:	3301      	adds	r3, #1
 80133b6:	4a5c      	ldr	r2, [pc, #368]	; (8013528 <_tx_mutex_put+0x2c4>)
 80133b8:	6013      	str	r3, [r2, #0]
 80133ba:	f8d7 3094 	ldr.w	r3, [r7, #148]	; 0x94
 80133be:	647b      	str	r3, [r7, #68]	; 0x44
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 80133c0:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 80133c2:	f383 8810 	msr	PRIMASK, r3
}
 80133c6:	bf00      	nop
                            /* Restore interrupts.  */
                            TX_RESTORE
#endif

                            /* Default the inheritance priority to disabled.  */
                            inheritance_priority =  ((UINT) TX_MAX_PRIORITIES);
 80133c8:	2320      	movs	r3, #32
 80133ca:	f8c7 3080 	str.w	r3, [r7, #128]	; 0x80
                            
                            /* Search the owned mutexes for this thread to determine the highest priority for this 
                               former mutex owner to return to.  */
                            next_mutex =  thread_ptr -> tx_thread_owned_mutex_list;
 80133ce:	6ffb      	ldr	r3, [r7, #124]	; 0x7c
 80133d0:	f8d3 30a4 	ldr.w	r3, [r3, #164]	; 0xa4
 80133d4:	f8c7 3084 	str.w	r3, [r7, #132]	; 0x84
                            while (next_mutex != TX_NULL)
 80133d8:	e01f      	b.n	801341a <_tx_mutex_put+0x1b6>
                            {

                                /* Does this mutex support priority inheritance?  */
                                if (next_mutex -> tx_mutex_inherit == TX_TRUE)
 80133da:	f8d7 3084 	ldr.w	r3, [r7, #132]	; 0x84
 80133de:	691b      	ldr	r3, [r3, #16]
 80133e0:	2b01      	cmp	r3, #1
 80133e2:	d10b      	bne.n	80133fc <_tx_mutex_put+0x198>
                                {
                            
                                    /* Determine if highest priority field of the mutex is higher than the priority to 
                                       restore.  */
                                    if (next_mutex -> tx_mutex_highest_priority_waiting < inheritance_priority)
 80133e4:	f8d7 3084 	ldr.w	r3, [r7, #132]	; 0x84
 80133e8:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 80133ea:	f8d7 2080 	ldr.w	r2, [r7, #128]	; 0x80
 80133ee:	429a      	cmp	r2, r3
 80133f0:	d904      	bls.n	80133fc <_tx_mutex_put+0x198>
                                    {

                                        /* Use this priority to return releasing thread to.  */
                                        inheritance_priority =   next_mutex -> tx_mutex_highest_priority_waiting;
 80133f2:	f8d7 3084 	ldr.w	r3, [r7, #132]	; 0x84
 80133f6:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 80133f8:	f8c7 3080 	str.w	r3, [r7, #128]	; 0x80
                                    }
                                }

                                /* Move mutex pointer to the next mutex in the list.  */
                                next_mutex =  next_mutex -> tx_mutex_owned_next;
 80133fc:	f8d7 3084 	ldr.w	r3, [r7, #132]	; 0x84
 8013400:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8013402:	f8c7 3084 	str.w	r3, [r7, #132]	; 0x84

                                /* Are we at the end of the list?  */
                                if (next_mutex == thread_ptr -> tx_thread_owned_mutex_list)
 8013406:	6ffb      	ldr	r3, [r7, #124]	; 0x7c
 8013408:	f8d3 30a4 	ldr.w	r3, [r3, #164]	; 0xa4
 801340c:	f8d7 2084 	ldr.w	r2, [r7, #132]	; 0x84
 8013410:	429a      	cmp	r2, r3
 8013412:	d102      	bne.n	801341a <_tx_mutex_put+0x1b6>
                                {
                            
                                    /* Yes, set the next mutex to NULL.  */
                                    next_mutex =  TX_NULL;
 8013414:	2300      	movs	r3, #0
 8013416:	f8c7 3084 	str.w	r3, [r7, #132]	; 0x84
                            while (next_mutex != TX_NULL)
 801341a:	f8d7 3084 	ldr.w	r3, [r7, #132]	; 0x84
 801341e:	2b00      	cmp	r3, #0
 8013420:	d1db      	bne.n	80133da <_tx_mutex_put+0x176>
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 8013422:	f3ef 8310 	mrs	r3, PRIMASK
 8013426:	643b      	str	r3, [r7, #64]	; 0x40
    return(posture);
 8013428:	6c3b      	ldr	r3, [r7, #64]	; 0x40
    int_posture = __get_interrupt_posture();
 801342a:	63fb      	str	r3, [r7, #60]	; 0x3c
    __asm__ volatile ("CPSID i" : : : "memory");
 801342c:	b672      	cpsid	i
    return(int_posture);
 801342e:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
                            }

#ifndef TX_NOT_INTERRUPTABLE

                            /* Disable interrupts.  */
                            TX_DISABLE
 8013430:	f8c7 3094 	str.w	r3, [r7, #148]	; 0x94

                            /* Undo the temporarily preemption disable.  */
                            _tx_thread_preempt_disable--;
 8013434:	4b3c      	ldr	r3, [pc, #240]	; (8013528 <_tx_mutex_put+0x2c4>)
 8013436:	681b      	ldr	r3, [r3, #0]
 8013438:	3b01      	subs	r3, #1
 801343a:	4a3b      	ldr	r2, [pc, #236]	; (8013528 <_tx_mutex_put+0x2c4>)
 801343c:	6013      	str	r3, [r2, #0]
#endif
                       
                            /* Set the inherit priority to that of the highest priority thread waiting on the mutex.  */
                            thread_ptr -> tx_thread_inherit_priority =  inheritance_priority;
 801343e:	6ffb      	ldr	r3, [r7, #124]	; 0x7c
 8013440:	f8d7 2080 	ldr.w	r2, [r7, #128]	; 0x80
 8013444:	f8c3 209c 	str.w	r2, [r3, #156]	; 0x9c
                                
                            /* Determine if the inheritance priority is less than the default old priority.  */
                            if (inheritance_priority < old_priority)
 8013448:	f8d7 2080 	ldr.w	r2, [r7, #128]	; 0x80
 801344c:	f8d7 308c 	ldr.w	r3, [r7, #140]	; 0x8c
 8013450:	429a      	cmp	r2, r3
 8013452:	d203      	bcs.n	801345c <_tx_mutex_put+0x1f8>
                            {
                            
                                /* Yes, update the old priority.  */
                                old_priority =  inheritance_priority;
 8013454:	f8d7 3080 	ldr.w	r3, [r7, #128]	; 0x80
 8013458:	f8c7 308c 	str.w	r3, [r7, #140]	; 0x8c
                            }
                        }

                        /* Determine if priority inheritance is in effect and there are one or more
                           threads suspended on the mutex.  */
                        if (mutex_ptr -> tx_mutex_suspended_count > ((UINT) 1))
 801345c:	687b      	ldr	r3, [r7, #4]
 801345e:	69db      	ldr	r3, [r3, #28]
 8013460:	2b01      	cmp	r3, #1
 8013462:	d920      	bls.n	80134a6 <_tx_mutex_put+0x242>
                        {

                            /* Is priority inheritance in effect?  */
                            if (mutex_ptr -> tx_mutex_inherit == TX_TRUE)
 8013464:	687b      	ldr	r3, [r7, #4]
 8013466:	691b      	ldr	r3, [r3, #16]
 8013468:	2b01      	cmp	r3, #1
 801346a:	d11c      	bne.n	80134a6 <_tx_mutex_put+0x242>
                                   at the front of the suspension list.  */

#ifndef TX_NOT_INTERRUPTABLE

                                /* Temporarily disable preemption.  */
                                _tx_thread_preempt_disable++;
 801346c:	4b2e      	ldr	r3, [pc, #184]	; (8013528 <_tx_mutex_put+0x2c4>)
 801346e:	681b      	ldr	r3, [r3, #0]
 8013470:	3301      	adds	r3, #1
 8013472:	4a2d      	ldr	r2, [pc, #180]	; (8013528 <_tx_mutex_put+0x2c4>)
 8013474:	6013      	str	r3, [r2, #0]
 8013476:	f8d7 3094 	ldr.w	r3, [r7, #148]	; 0x94
 801347a:	633b      	str	r3, [r7, #48]	; 0x30
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 801347c:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801347e:	f383 8810 	msr	PRIMASK, r3
}
 8013482:	bf00      	nop
                                do
                                {
                                    status =  _tx_mutex_prioritize(mutex_ptr);
                                } while (status != TX_SUCCESS);
#else
                                _tx_mutex_prioritize(mutex_ptr);
 8013484:	6878      	ldr	r0, [r7, #4]
 8013486:	f7ff fd7d 	bl	8012f84 <_tx_mutex_prioritize>
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 801348a:	f3ef 8310 	mrs	r3, PRIMASK
 801348e:	63bb      	str	r3, [r7, #56]	; 0x38
    return(posture);
 8013490:	6bbb      	ldr	r3, [r7, #56]	; 0x38
    int_posture = __get_interrupt_posture();
 8013492:	637b      	str	r3, [r7, #52]	; 0x34
    __asm__ volatile ("CPSID i" : : : "memory");
 8013494:	b672      	cpsid	i
    return(int_posture);
 8013496:	6b7b      	ldr	r3, [r7, #52]	; 0x34
                                TX_MUTEX_PUT_EXTENSION_1

#ifndef TX_NOT_INTERRUPTABLE

                                /* Disable interrupts.  */
                                TX_DISABLE
 8013498:	f8c7 3094 	str.w	r3, [r7, #148]	; 0x94

                                /* Back off the preemption disable.  */
                                _tx_thread_preempt_disable--;
 801349c:	4b22      	ldr	r3, [pc, #136]	; (8013528 <_tx_mutex_put+0x2c4>)
 801349e:	681b      	ldr	r3, [r3, #0]
 80134a0:	3b01      	subs	r3, #1
 80134a2:	4a21      	ldr	r2, [pc, #132]	; (8013528 <_tx_mutex_put+0x2c4>)
 80134a4:	6013      	str	r3, [r2, #0]
#endif
                            }
                        }

                        /* Now determine if there are any threads still waiting on the mutex.  */
                        if (mutex_ptr -> tx_mutex_suspension_list == TX_NULL)
 80134a6:	687b      	ldr	r3, [r7, #4]
 80134a8:	699b      	ldr	r3, [r3, #24]
 80134aa:	2b00      	cmp	r3, #0
 80134ac:	d13e      	bne.n	801352c <_tx_mutex_put+0x2c8>
                            /* No, there are no longer any threads waiting on the mutex.  */

#ifndef TX_NOT_INTERRUPTABLE

                            /* Temporarily disable preemption.  */
                            _tx_thread_preempt_disable++;
 80134ae:	4b1e      	ldr	r3, [pc, #120]	; (8013528 <_tx_mutex_put+0x2c4>)
 80134b0:	681b      	ldr	r3, [r3, #0]
 80134b2:	3301      	adds	r3, #1
 80134b4:	4a1c      	ldr	r2, [pc, #112]	; (8013528 <_tx_mutex_put+0x2c4>)
 80134b6:	6013      	str	r3, [r2, #0]
 80134b8:	f8d7 3094 	ldr.w	r3, [r7, #148]	; 0x94
 80134bc:	62fb      	str	r3, [r7, #44]	; 0x2c
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 80134be:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 80134c0:	f383 8810 	msr	PRIMASK, r3
}
 80134c4:	bf00      	nop
                            /* Mutex is not owned, but it is possible that a thread that 
                               caused a priority inheritance to occur is no longer waiting
                               on the mutex.  */

                            /* Setup the highest priority waiting thread.  */
                            mutex_ptr -> tx_mutex_highest_priority_waiting =  (UINT) TX_MAX_PRIORITIES;
 80134c6:	687b      	ldr	r3, [r7, #4]
 80134c8:	2220      	movs	r2, #32
 80134ca:	629a      	str	r2, [r3, #40]	; 0x28
  
                            /* Determine if we need to restore priority.  */
                            if ((mutex_ptr -> tx_mutex_owner) -> tx_thread_priority != old_priority)
 80134cc:	687b      	ldr	r3, [r7, #4]
 80134ce:	68db      	ldr	r3, [r3, #12]
 80134d0:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 80134d2:	f8d7 208c 	ldr.w	r2, [r7, #140]	; 0x8c
 80134d6:	429a      	cmp	r2, r3
 80134d8:	d006      	beq.n	80134e8 <_tx_mutex_put+0x284>
                            {
                      
                                /* Yes, restore the priority of thread.  */
                                _tx_mutex_priority_change(mutex_ptr -> tx_mutex_owner, old_priority);
 80134da:	687b      	ldr	r3, [r7, #4]
 80134dc:	68db      	ldr	r3, [r3, #12]
 80134de:	f8d7 108c 	ldr.w	r1, [r7, #140]	; 0x8c
 80134e2:	4618      	mov	r0, r3
 80134e4:	f7ff fe00 	bl	80130e8 <_tx_mutex_priority_change>
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 80134e8:	f3ef 8310 	mrs	r3, PRIMASK
 80134ec:	627b      	str	r3, [r7, #36]	; 0x24
    return(posture);
 80134ee:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    int_posture = __get_interrupt_posture();
 80134f0:	623b      	str	r3, [r7, #32]
    __asm__ volatile ("CPSID i" : : : "memory");
 80134f2:	b672      	cpsid	i
    return(int_posture);
 80134f4:	6a3b      	ldr	r3, [r7, #32]
                            }

#ifndef TX_NOT_INTERRUPTABLE

                            /* Disable interrupts again.  */
                            TX_DISABLE
 80134f6:	f8c7 3094 	str.w	r3, [r7, #148]	; 0x94

                            /* Back off the preemption disable.  */
                            _tx_thread_preempt_disable--;
 80134fa:	4b0b      	ldr	r3, [pc, #44]	; (8013528 <_tx_mutex_put+0x2c4>)
 80134fc:	681b      	ldr	r3, [r3, #0]
 80134fe:	3b01      	subs	r3, #1
 8013500:	4a09      	ldr	r2, [pc, #36]	; (8013528 <_tx_mutex_put+0x2c4>)
 8013502:	6013      	str	r3, [r2, #0]
#endif

                            /* Set the mutex owner to NULL.  */
                            mutex_ptr -> tx_mutex_owner =  TX_NULL;
 8013504:	687b      	ldr	r3, [r7, #4]
 8013506:	2200      	movs	r2, #0
 8013508:	60da      	str	r2, [r3, #12]
 801350a:	f8d7 3094 	ldr.w	r3, [r7, #148]	; 0x94
 801350e:	62bb      	str	r3, [r7, #40]	; 0x28
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 8013510:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8013512:	f383 8810 	msr	PRIMASK, r3
}
 8013516:	bf00      	nop

                            /* Restore interrupts.  */
                            TX_RESTORE

                            /* Check for preemption.  */
                            _tx_thread_system_preempt_check();
 8013518:	f001 fbcc 	bl	8014cb4 <_tx_thread_system_preempt_check>

                            /* Set status to success.  */
                            status =  TX_SUCCESS;
 801351c:	2300      	movs	r3, #0
 801351e:	f8c7 3088 	str.w	r3, [r7, #136]	; 0x88
 8013522:	e0bd      	b.n	80136a0 <_tx_mutex_put+0x43c>
 8013524:	24031bc4 	.word	0x24031bc4
 8013528:	24031c5c 	.word	0x24031c5c
                        }
                        else
                        {

                            /* Pickup the thread at the front of the suspension list.  */
                            thread_ptr =  mutex_ptr -> tx_mutex_suspension_list;
 801352c:	687b      	ldr	r3, [r7, #4]
 801352e:	699b      	ldr	r3, [r3, #24]
 8013530:	67fb      	str	r3, [r7, #124]	; 0x7c

                            /* Save the previous ownership information, if inheritance is
                               in effect.  */
                            if (mutex_ptr -> tx_mutex_inherit == TX_TRUE)
 8013532:	687b      	ldr	r3, [r7, #4]
 8013534:	691b      	ldr	r3, [r3, #16]
 8013536:	2b01      	cmp	r3, #1
 8013538:	d10a      	bne.n	8013550 <_tx_mutex_put+0x2ec>
                            {

                                /* Remember the old mutex owner.  */
                                old_owner =  mutex_ptr -> tx_mutex_owner;
 801353a:	687b      	ldr	r3, [r7, #4]
 801353c:	68db      	ldr	r3, [r3, #12]
 801353e:	f8c7 3090 	str.w	r3, [r7, #144]	; 0x90
        
                                /* Setup owner thread priority information.  */
                                mutex_ptr -> tx_mutex_original_priority =   thread_ptr -> tx_thread_priority;
 8013542:	6ffb      	ldr	r3, [r7, #124]	; 0x7c
 8013544:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 8013546:	687b      	ldr	r3, [r7, #4]
 8013548:	615a      	str	r2, [r3, #20]

                                /* Setup the highest priority waiting thread.  */
                                mutex_ptr -> tx_mutex_highest_priority_waiting =  (UINT) TX_MAX_PRIORITIES;
 801354a:	687b      	ldr	r3, [r7, #4]
 801354c:	2220      	movs	r2, #32
 801354e:	629a      	str	r2, [r3, #40]	; 0x28
                            }

                            /* Determine how many mutexes are owned by this thread.  */
                            owned_count =  thread_ptr -> tx_thread_owned_mutex_count;
 8013550:	6ffb      	ldr	r3, [r7, #124]	; 0x7c
 8013552:	f8d3 30a0 	ldr.w	r3, [r3, #160]	; 0xa0
 8013556:	673b      	str	r3, [r7, #112]	; 0x70

                            /* Determine if this thread owns any other mutexes that have priority inheritance.  */
                            if (owned_count == ((UINT) 0))
 8013558:	6f3b      	ldr	r3, [r7, #112]	; 0x70
 801355a:	2b00      	cmp	r3, #0
 801355c:	d10a      	bne.n	8013574 <_tx_mutex_put+0x310>
                            {

                                /* The owned mutex list is empty.  Add mutex to empty list.  */
                                thread_ptr -> tx_thread_owned_mutex_list =     mutex_ptr;
 801355e:	6ffb      	ldr	r3, [r7, #124]	; 0x7c
 8013560:	687a      	ldr	r2, [r7, #4]
 8013562:	f8c3 20a4 	str.w	r2, [r3, #164]	; 0xa4
                                mutex_ptr -> tx_mutex_owned_next =             mutex_ptr;
 8013566:	687b      	ldr	r3, [r7, #4]
 8013568:	687a      	ldr	r2, [r7, #4]
 801356a:	62da      	str	r2, [r3, #44]	; 0x2c
                                mutex_ptr -> tx_mutex_owned_previous =         mutex_ptr;
 801356c:	687b      	ldr	r3, [r7, #4]
 801356e:	687a      	ldr	r2, [r7, #4]
 8013570:	631a      	str	r2, [r3, #48]	; 0x30
 8013572:	e016      	b.n	80135a2 <_tx_mutex_put+0x33e>
                            {

                                /* Non-empty list. Link up the mutex.  */

                                /* Pickup tail pointer.  */
                                next_mutex =                            thread_ptr -> tx_thread_owned_mutex_list;
 8013574:	6ffb      	ldr	r3, [r7, #124]	; 0x7c
 8013576:	f8d3 30a4 	ldr.w	r3, [r3, #164]	; 0xa4
 801357a:	f8c7 3084 	str.w	r3, [r7, #132]	; 0x84
                                previous_mutex =                        next_mutex -> tx_mutex_owned_previous;
 801357e:	f8d7 3084 	ldr.w	r3, [r7, #132]	; 0x84
 8013582:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8013584:	677b      	str	r3, [r7, #116]	; 0x74

                                /* Place the owned mutex in the list.  */
                                next_mutex -> tx_mutex_owned_previous =  mutex_ptr;
 8013586:	f8d7 3084 	ldr.w	r3, [r7, #132]	; 0x84
 801358a:	687a      	ldr	r2, [r7, #4]
 801358c:	631a      	str	r2, [r3, #48]	; 0x30
                                previous_mutex -> tx_mutex_owned_next =  mutex_ptr;
 801358e:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 8013590:	687a      	ldr	r2, [r7, #4]
 8013592:	62da      	str	r2, [r3, #44]	; 0x2c

                                /* Setup this mutex's next and previous created links.  */
                                mutex_ptr -> tx_mutex_owned_previous =   previous_mutex;
 8013594:	687b      	ldr	r3, [r7, #4]
 8013596:	6f7a      	ldr	r2, [r7, #116]	; 0x74
 8013598:	631a      	str	r2, [r3, #48]	; 0x30
                                mutex_ptr -> tx_mutex_owned_next =       next_mutex;
 801359a:	687b      	ldr	r3, [r7, #4]
 801359c:	f8d7 2084 	ldr.w	r2, [r7, #132]	; 0x84
 80135a0:	62da      	str	r2, [r3, #44]	; 0x2c
                            }

                            /* Increment the number of mutexes owned counter.  */
                            thread_ptr -> tx_thread_owned_mutex_count =  owned_count + ((UINT) 1);
 80135a2:	6f3b      	ldr	r3, [r7, #112]	; 0x70
 80135a4:	1c5a      	adds	r2, r3, #1
 80135a6:	6ffb      	ldr	r3, [r7, #124]	; 0x7c
 80135a8:	f8c3 20a0 	str.w	r2, [r3, #160]	; 0xa0

                            /* Mark the Mutex as owned and fill in the corresponding information.  */
                            mutex_ptr -> tx_mutex_ownership_count =  (UINT) 1;
 80135ac:	687b      	ldr	r3, [r7, #4]
 80135ae:	2201      	movs	r2, #1
 80135b0:	609a      	str	r2, [r3, #8]
                            mutex_ptr -> tx_mutex_owner =            thread_ptr;
 80135b2:	687b      	ldr	r3, [r7, #4]
 80135b4:	6ffa      	ldr	r2, [r7, #124]	; 0x7c
 80135b6:	60da      	str	r2, [r3, #12]

                            /* Remove the suspended thread from the list.  */

                            /* Decrement the suspension count.  */
                            mutex_ptr -> tx_mutex_suspended_count--;
 80135b8:	687b      	ldr	r3, [r7, #4]
 80135ba:	69db      	ldr	r3, [r3, #28]
 80135bc:	1e5a      	subs	r2, r3, #1
 80135be:	687b      	ldr	r3, [r7, #4]
 80135c0:	61da      	str	r2, [r3, #28]
                
                            /* Pickup the suspended count.  */
                            suspended_count =  mutex_ptr -> tx_mutex_suspended_count;
 80135c2:	687b      	ldr	r3, [r7, #4]
 80135c4:	69db      	ldr	r3, [r3, #28]
 80135c6:	66fb      	str	r3, [r7, #108]	; 0x6c

                            /* See if this is the only suspended thread on the list.  */
                            if (suspended_count == TX_NO_SUSPENSIONS)
 80135c8:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 80135ca:	2b00      	cmp	r3, #0
 80135cc:	d103      	bne.n	80135d6 <_tx_mutex_put+0x372>
                            {

                                /* Yes, the only suspended thread.  */
    
                                /* Update the head pointer.  */
                                mutex_ptr -> tx_mutex_suspension_list =  TX_NULL;
 80135ce:	687b      	ldr	r3, [r7, #4]
 80135d0:	2200      	movs	r2, #0
 80135d2:	619a      	str	r2, [r3, #24]
 80135d4:	e00e      	b.n	80135f4 <_tx_mutex_put+0x390>
                            {

                                /* At least one more thread is on the same expiration list.  */

                                /* Update the list head pointer.  */
                                next_thread =                                  thread_ptr -> tx_thread_suspended_next;
 80135d6:	6ffb      	ldr	r3, [r7, #124]	; 0x7c
 80135d8:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 80135da:	66bb      	str	r3, [r7, #104]	; 0x68
                                mutex_ptr -> tx_mutex_suspension_list =        next_thread;
 80135dc:	687b      	ldr	r3, [r7, #4]
 80135de:	6eba      	ldr	r2, [r7, #104]	; 0x68
 80135e0:	619a      	str	r2, [r3, #24]

                                /* Update the links of the adjacent threads.  */
                                previous_thread =                              thread_ptr -> tx_thread_suspended_previous;
 80135e2:	6ffb      	ldr	r3, [r7, #124]	; 0x7c
 80135e4:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 80135e6:	667b      	str	r3, [r7, #100]	; 0x64
                                next_thread -> tx_thread_suspended_previous =  previous_thread;
 80135e8:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 80135ea:	6e7a      	ldr	r2, [r7, #100]	; 0x64
 80135ec:	675a      	str	r2, [r3, #116]	; 0x74
                                previous_thread -> tx_thread_suspended_next =  next_thread;
 80135ee:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 80135f0:	6eba      	ldr	r2, [r7, #104]	; 0x68
 80135f2:	671a      	str	r2, [r3, #112]	; 0x70
                            }

                            /* Prepare for resumption of the first thread.  */

                            /* Clear cleanup routine to avoid timeout.  */
                            thread_ptr -> tx_thread_suspend_cleanup =  TX_NULL;
 80135f4:	6ffb      	ldr	r3, [r7, #124]	; 0x7c
 80135f6:	2200      	movs	r2, #0
 80135f8:	669a      	str	r2, [r3, #104]	; 0x68

                            /* Put return status into the thread control block.  */
                            thread_ptr -> tx_thread_suspend_status =  TX_SUCCESS;
 80135fa:	6ffb      	ldr	r3, [r7, #124]	; 0x7c
 80135fc:	2200      	movs	r2, #0
 80135fe:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84
                            /* Restore interrupts.  */
                            TX_RESTORE
#else

                            /* Temporarily disable preemption.  */
                            _tx_thread_preempt_disable++;
 8013602:	4b2a      	ldr	r3, [pc, #168]	; (80136ac <_tx_mutex_put+0x448>)
 8013604:	681b      	ldr	r3, [r3, #0]
 8013606:	3301      	adds	r3, #1
 8013608:	4a28      	ldr	r2, [pc, #160]	; (80136ac <_tx_mutex_put+0x448>)
 801360a:	6013      	str	r3, [r2, #0]
 801360c:	f8d7 3094 	ldr.w	r3, [r7, #148]	; 0x94
 8013610:	61fb      	str	r3, [r7, #28]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 8013612:	69fb      	ldr	r3, [r7, #28]
 8013614:	f383 8810 	msr	PRIMASK, r3
}
 8013618:	bf00      	nop

                            /* Restore interrupts.  */
                            TX_RESTORE

                            /* Determine if priority inheritance is enabled for this mutex.  */
                            if (mutex_ptr -> tx_mutex_inherit == TX_TRUE)
 801361a:	687b      	ldr	r3, [r7, #4]
 801361c:	691b      	ldr	r3, [r3, #16]
 801361e:	2b01      	cmp	r3, #1
 8013620:	d12d      	bne.n	801367e <_tx_mutex_put+0x41a>
                            {

                                /* Yes, priority inheritance is requested.  */
        
                                /* Determine if there are any more threads still suspended on the mutex.  */
                                if (mutex_ptr -> tx_mutex_suspended_count != TX_NO_SUSPENSIONS)
 8013622:	687b      	ldr	r3, [r7, #4]
 8013624:	69db      	ldr	r3, [r3, #28]
 8013626:	2b00      	cmp	r3, #0
 8013628:	d01c      	beq.n	8013664 <_tx_mutex_put+0x400>
                                    do
                                    {
                                        status =  _tx_mutex_prioritize(mutex_ptr);
                                    } while (status != TX_SUCCESS);
#else
                                    _tx_mutex_prioritize(mutex_ptr);
 801362a:	6878      	ldr	r0, [r7, #4]
 801362c:	f7ff fcaa 	bl	8012f84 <_tx_mutex_prioritize>
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 8013630:	f3ef 8310 	mrs	r3, PRIMASK
 8013634:	61bb      	str	r3, [r7, #24]
    return(posture);
 8013636:	69bb      	ldr	r3, [r7, #24]
    int_posture = __get_interrupt_posture();
 8013638:	617b      	str	r3, [r7, #20]
    __asm__ volatile ("CPSID i" : : : "memory");
 801363a:	b672      	cpsid	i
    return(int_posture);
 801363c:	697b      	ldr	r3, [r7, #20]

                                    /* Optional processing extension.  */
                                    TX_MUTEX_PUT_EXTENSION_2

                                    /* Disable interrupts.  */
                                    TX_DISABLE
 801363e:	f8c7 3094 	str.w	r3, [r7, #148]	; 0x94

                                    /* Determine if there still are threads suspended for this mutex.  */
                                    suspended_thread =  mutex_ptr -> tx_mutex_suspension_list;
 8013642:	687b      	ldr	r3, [r7, #4]
 8013644:	699b      	ldr	r3, [r3, #24]
 8013646:	663b      	str	r3, [r7, #96]	; 0x60
                                    if (suspended_thread != TX_NULL)
 8013648:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 801364a:	2b00      	cmp	r3, #0
 801364c:	d003      	beq.n	8013656 <_tx_mutex_put+0x3f2>
                                    {

                                        /* Setup the highest priority thread waiting on this mutex.  */
                                        mutex_ptr -> tx_mutex_highest_priority_waiting =  suspended_thread -> tx_thread_priority;
 801364e:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 8013650:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 8013652:	687b      	ldr	r3, [r7, #4]
 8013654:	629a      	str	r2, [r3, #40]	; 0x28
 8013656:	f8d7 3094 	ldr.w	r3, [r7, #148]	; 0x94
 801365a:	613b      	str	r3, [r7, #16]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 801365c:	693b      	ldr	r3, [r7, #16]
 801365e:	f383 8810 	msr	PRIMASK, r3
}
 8013662:	bf00      	nop

                                /* Restore previous priority needs to be restored after priority
                                   inheritance.  */
                    
                                /* Is the priority different?  */
                                if (old_owner -> tx_thread_priority != old_priority)
 8013664:	f8d7 3090 	ldr.w	r3, [r7, #144]	; 0x90
 8013668:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 801366a:	f8d7 208c 	ldr.w	r2, [r7, #140]	; 0x8c
 801366e:	429a      	cmp	r2, r3
 8013670:	d005      	beq.n	801367e <_tx_mutex_put+0x41a>
                                {
        
                                    /* Restore the priority of thread.  */
                                    _tx_mutex_priority_change(old_owner, old_priority);
 8013672:	f8d7 108c 	ldr.w	r1, [r7, #140]	; 0x8c
 8013676:	f8d7 0090 	ldr.w	r0, [r7, #144]	; 0x90
 801367a:	f7ff fd35 	bl	80130e8 <_tx_mutex_priority_change>
                                }
                            }

                            /* Resume thread.  */
                            _tx_thread_system_resume(thread_ptr);
 801367e:	6ff8      	ldr	r0, [r7, #124]	; 0x7c
 8013680:	f001 fb52 	bl	8014d28 <_tx_thread_system_resume>
#endif
                     
                            /* Return a successful status.  */
                            status =  TX_SUCCESS;
 8013684:	2300      	movs	r3, #0
 8013686:	f8c7 3088 	str.w	r3, [r7, #136]	; 0x88
 801368a:	e009      	b.n	80136a0 <_tx_mutex_put+0x43c>
 801368c:	f8d7 3094 	ldr.w	r3, [r7, #148]	; 0x94
 8013690:	60fb      	str	r3, [r7, #12]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 8013692:	68fb      	ldr	r3, [r7, #12]
 8013694:	f383 8810 	msr	PRIMASK, r3
}
 8013698:	bf00      	nop

        /* Restore interrupts.  */
        TX_RESTORE
    
        /* Caller does not own the mutex.  */
        status =  TX_NOT_OWNED;
 801369a:	231e      	movs	r3, #30
 801369c:	f8c7 3088 	str.w	r3, [r7, #136]	; 0x88
    }

    /* Return the completion status.  */
    return(status);
 80136a0:	f8d7 3088 	ldr.w	r3, [r7, #136]	; 0x88
}
 80136a4:	4618      	mov	r0, r3
 80136a6:	3798      	adds	r7, #152	; 0x98
 80136a8:	46bd      	mov	sp, r7
 80136aa:	bd80      	pop	{r7, pc}
 80136ac:	24031c5c 	.word	0x24031c5c

080136b0 <_tx_queue_cleanup>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
VOID  _tx_queue_cleanup(TX_THREAD  *thread_ptr, ULONG suspension_sequence)
{
 80136b0:	b580      	push	{r7, lr}
 80136b2:	b08e      	sub	sp, #56	; 0x38
 80136b4:	af00      	add	r7, sp, #0
 80136b6:	6078      	str	r0, [r7, #4]
 80136b8:	6039      	str	r1, [r7, #0]
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 80136ba:	f3ef 8310 	mrs	r3, PRIMASK
 80136be:	623b      	str	r3, [r7, #32]
    return(posture);
 80136c0:	6a3b      	ldr	r3, [r7, #32]
    int_posture = __get_interrupt_posture();
 80136c2:	61fb      	str	r3, [r7, #28]
    __asm__ volatile ("CPSID i" : : : "memory");
 80136c4:	b672      	cpsid	i
    return(int_posture);
 80136c6:	69fb      	ldr	r3, [r7, #28]

    
#ifndef TX_NOT_INTERRUPTABLE

    /* Disable interrupts to remove the suspended thread from the queue.  */
    TX_DISABLE
 80136c8:	637b      	str	r3, [r7, #52]	; 0x34

    /* Determine if the cleanup is still required.  */
    if (thread_ptr -> tx_thread_suspend_cleanup == &(_tx_queue_cleanup))
 80136ca:	687b      	ldr	r3, [r7, #4]
 80136cc:	6e9b      	ldr	r3, [r3, #104]	; 0x68
 80136ce:	4a37      	ldr	r2, [pc, #220]	; (80137ac <_tx_queue_cleanup+0xfc>)
 80136d0:	4293      	cmp	r3, r2
 80136d2:	d161      	bne.n	8013798 <_tx_queue_cleanup+0xe8>
    {
    
        /* Check for valid suspension sequence.  */
        if (suspension_sequence == thread_ptr -> tx_thread_suspension_sequence)
 80136d4:	687b      	ldr	r3, [r7, #4]
 80136d6:	f8d3 30ac 	ldr.w	r3, [r3, #172]	; 0xac
 80136da:	683a      	ldr	r2, [r7, #0]
 80136dc:	429a      	cmp	r2, r3
 80136de:	d15b      	bne.n	8013798 <_tx_queue_cleanup+0xe8>
        {

            /* Setup pointer to queue control block.  */
            queue_ptr =  TX_VOID_TO_QUEUE_POINTER_CONVERT(thread_ptr -> tx_thread_suspend_control_block);
 80136e0:	687b      	ldr	r3, [r7, #4]
 80136e2:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 80136e4:	633b      	str	r3, [r7, #48]	; 0x30

            /* Check for NULL queue pointer.  */
            if (queue_ptr != TX_NULL)
 80136e6:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 80136e8:	2b00      	cmp	r3, #0
 80136ea:	d055      	beq.n	8013798 <_tx_queue_cleanup+0xe8>
            {

                /* Is the queue ID valid?  */
                if (queue_ptr -> tx_queue_id == TX_QUEUE_ID)
 80136ec:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 80136ee:	681b      	ldr	r3, [r3, #0]
 80136f0:	4a2f      	ldr	r2, [pc, #188]	; (80137b0 <_tx_queue_cleanup+0x100>)
 80136f2:	4293      	cmp	r3, r2
 80136f4:	d150      	bne.n	8013798 <_tx_queue_cleanup+0xe8>
                {

                    /* Determine if there are any thread suspensions.  */
                    if (queue_ptr -> tx_queue_suspended_count != TX_NO_SUSPENSIONS)
 80136f6:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 80136f8:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 80136fa:	2b00      	cmp	r3, #0
 80136fc:	d04c      	beq.n	8013798 <_tx_queue_cleanup+0xe8>
#endif

                        /* Yes, we still have thread suspension!  */
    
                        /* Clear the suspension cleanup flag.  */
                        thread_ptr -> tx_thread_suspend_cleanup =  TX_NULL;
 80136fe:	687b      	ldr	r3, [r7, #4]
 8013700:	2200      	movs	r2, #0
 8013702:	669a      	str	r2, [r3, #104]	; 0x68

                        /* Decrement the suspended count.  */
                        queue_ptr -> tx_queue_suspended_count--;
 8013704:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8013706:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8013708:	1e5a      	subs	r2, r3, #1
 801370a:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801370c:	62da      	str	r2, [r3, #44]	; 0x2c

                        /* Pickup the suspended count.  */
                        suspended_count =  queue_ptr -> tx_queue_suspended_count;
 801370e:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8013710:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8013712:	62fb      	str	r3, [r7, #44]	; 0x2c

                        /* Remove the suspended thread from the list.  */

                        /* See if this is the only suspended thread on the list.  */
                        if (suspended_count == TX_NO_SUSPENSIONS)
 8013714:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8013716:	2b00      	cmp	r3, #0
 8013718:	d103      	bne.n	8013722 <_tx_queue_cleanup+0x72>
                        {

                            /* Yes, the only suspended thread.  */

                            /* Update the head pointer.  */
                            queue_ptr -> tx_queue_suspension_list =  TX_NULL;
 801371a:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801371c:	2200      	movs	r2, #0
 801371e:	629a      	str	r2, [r3, #40]	; 0x28
 8013720:	e013      	b.n	801374a <_tx_queue_cleanup+0x9a>
                        {

                            /* At least one more thread is on the same suspension list.  */

                            /* Update the links of the adjacent threads.  */
                            next_thread =                                   thread_ptr -> tx_thread_suspended_next;
 8013722:	687b      	ldr	r3, [r7, #4]
 8013724:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 8013726:	62bb      	str	r3, [r7, #40]	; 0x28
                            previous_thread =                               thread_ptr -> tx_thread_suspended_previous;
 8013728:	687b      	ldr	r3, [r7, #4]
 801372a:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 801372c:	627b      	str	r3, [r7, #36]	; 0x24
                            next_thread -> tx_thread_suspended_previous =   previous_thread;
 801372e:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8013730:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8013732:	675a      	str	r2, [r3, #116]	; 0x74
                            previous_thread -> tx_thread_suspended_next =   next_thread;
 8013734:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8013736:	6aba      	ldr	r2, [r7, #40]	; 0x28
 8013738:	671a      	str	r2, [r3, #112]	; 0x70

                            /* Determine if we need to update the head pointer.  */
                            if (queue_ptr -> tx_queue_suspension_list == thread_ptr)
 801373a:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801373c:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 801373e:	687a      	ldr	r2, [r7, #4]
 8013740:	429a      	cmp	r2, r3
 8013742:	d102      	bne.n	801374a <_tx_queue_cleanup+0x9a>
                            {

                                /* Update the list head pointer.  */
                                queue_ptr -> tx_queue_suspension_list =         next_thread;
 8013744:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8013746:	6aba      	ldr	r2, [r7, #40]	; 0x28
 8013748:	629a      	str	r2, [r3, #40]	; 0x28
                            }
                        }

                        /* Now we need to determine if this cleanup is from a terminate, timeout,
                           or from a wait abort.  */
                        if (thread_ptr -> tx_thread_state == TX_QUEUE_SUSP)
 801374a:	687b      	ldr	r3, [r7, #4]
 801374c:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 801374e:	2b05      	cmp	r3, #5
 8013750:	d122      	bne.n	8013798 <_tx_queue_cleanup+0xe8>
                            /* Increment the number of timeouts on this queue.  */
                            queue_ptr -> tx_queue_performance_timeout_count++;
#endif

                            /* Setup return status.  */
                            if (queue_ptr -> tx_queue_enqueued != TX_NO_MESSAGES)
 8013752:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8013754:	691b      	ldr	r3, [r3, #16]
 8013756:	2b00      	cmp	r3, #0
 8013758:	d004      	beq.n	8013764 <_tx_queue_cleanup+0xb4>
                            {
            
                                /* Queue full timeout!  */
                                thread_ptr -> tx_thread_suspend_status =  TX_QUEUE_FULL;
 801375a:	687b      	ldr	r3, [r7, #4]
 801375c:	220b      	movs	r2, #11
 801375e:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84
 8013762:	e003      	b.n	801376c <_tx_queue_cleanup+0xbc>
                            }
                            else
                            {
            
                                /* Queue empty timeout!  */
                                thread_ptr -> tx_thread_suspend_status =  TX_QUEUE_EMPTY;
 8013764:	687b      	ldr	r3, [r7, #4]
 8013766:	220a      	movs	r2, #10
 8013768:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84
                            /* Resume the thread!  */
                            _tx_thread_system_ni_resume(thread_ptr);
#else

                            /* Temporarily disable preemption.  */
                            _tx_thread_preempt_disable++;
 801376c:	4b11      	ldr	r3, [pc, #68]	; (80137b4 <_tx_queue_cleanup+0x104>)
 801376e:	681b      	ldr	r3, [r3, #0]
 8013770:	3301      	adds	r3, #1
 8013772:	4a10      	ldr	r2, [pc, #64]	; (80137b4 <_tx_queue_cleanup+0x104>)
 8013774:	6013      	str	r3, [r2, #0]
 8013776:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8013778:	613b      	str	r3, [r7, #16]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 801377a:	693b      	ldr	r3, [r7, #16]
 801377c:	f383 8810 	msr	PRIMASK, r3
}
 8013780:	bf00      	nop

                            /* Restore interrupts.  */
                            TX_RESTORE

                            /* Resume the thread!  */
                            _tx_thread_system_resume(thread_ptr);
 8013782:	6878      	ldr	r0, [r7, #4]
 8013784:	f001 fad0 	bl	8014d28 <_tx_thread_system_resume>
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 8013788:	f3ef 8310 	mrs	r3, PRIMASK
 801378c:	61bb      	str	r3, [r7, #24]
    return(posture);
 801378e:	69bb      	ldr	r3, [r7, #24]
    int_posture = __get_interrupt_posture();
 8013790:	617b      	str	r3, [r7, #20]
    __asm__ volatile ("CPSID i" : : : "memory");
 8013792:	b672      	cpsid	i
    return(int_posture);
 8013794:	697b      	ldr	r3, [r7, #20]

                            /* Disable interrupts.  */
                            TX_DISABLE
 8013796:	637b      	str	r3, [r7, #52]	; 0x34
 8013798:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 801379a:	60fb      	str	r3, [r7, #12]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 801379c:	68fb      	ldr	r3, [r7, #12]
 801379e:	f383 8810 	msr	PRIMASK, r3
}
 80137a2:	bf00      	nop
    }

    /* Restore interrupts.  */
    TX_RESTORE
#endif
}
 80137a4:	bf00      	nop
 80137a6:	3738      	adds	r7, #56	; 0x38
 80137a8:	46bd      	mov	sp, r7
 80137aa:	bd80      	pop	{r7, pc}
 80137ac:	080136b1 	.word	0x080136b1
 80137b0:	51554555 	.word	0x51554555
 80137b4:	24031c5c 	.word	0x24031c5c

080137b8 <_tx_queue_create>:
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
UINT  _tx_queue_create(TX_QUEUE *queue_ptr, CHAR *name_ptr, UINT message_size, 
                        VOID *queue_start, ULONG queue_size)
{
 80137b8:	b580      	push	{r7, lr}
 80137ba:	b08c      	sub	sp, #48	; 0x30
 80137bc:	af00      	add	r7, sp, #0
 80137be:	60f8      	str	r0, [r7, #12]
 80137c0:	60b9      	str	r1, [r7, #8]
 80137c2:	607a      	str	r2, [r7, #4]
 80137c4:	603b      	str	r3, [r7, #0]
TX_QUEUE        *next_queue;
TX_QUEUE        *previous_queue;


    /* Initialize queue control block to all zeros.  */
    TX_MEMSET(queue_ptr, 0, (sizeof(TX_QUEUE)));
 80137c6:	2238      	movs	r2, #56	; 0x38
 80137c8:	2100      	movs	r1, #0
 80137ca:	68f8      	ldr	r0, [r7, #12]
 80137cc:	f00c f856 	bl	801f87c <memset>

    /* Setup the basic queue fields.  */
    queue_ptr -> tx_queue_name =             name_ptr;
 80137d0:	68fb      	ldr	r3, [r7, #12]
 80137d2:	68ba      	ldr	r2, [r7, #8]
 80137d4:	605a      	str	r2, [r3, #4]
    
    /* Save the message size in the control block.  */
    queue_ptr -> tx_queue_message_size =  message_size;
 80137d6:	68fb      	ldr	r3, [r7, #12]
 80137d8:	687a      	ldr	r2, [r7, #4]
 80137da:	609a      	str	r2, [r3, #8]

    /* Determine how many messages will fit in the queue area and the number
       of ULONGs used.  */
    capacity =    (UINT) (queue_size / ((ULONG) (((ULONG) message_size) * (sizeof(ULONG)))));
 80137dc:	687b      	ldr	r3, [r7, #4]
 80137de:	009b      	lsls	r3, r3, #2
 80137e0:	6bba      	ldr	r2, [r7, #56]	; 0x38
 80137e2:	fbb2 f3f3 	udiv	r3, r2, r3
 80137e6:	62fb      	str	r3, [r7, #44]	; 0x2c
    used_words =  capacity * message_size;
 80137e8:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 80137ea:	687a      	ldr	r2, [r7, #4]
 80137ec:	fb02 f303 	mul.w	r3, r2, r3
 80137f0:	62bb      	str	r3, [r7, #40]	; 0x28

    /* Save the starting address and calculate the ending address of 
       the queue.  Note that the ending address is really one past the
       end!  */
    queue_ptr -> tx_queue_start =  TX_VOID_TO_ULONG_POINTER_CONVERT(queue_start);
 80137f2:	68fb      	ldr	r3, [r7, #12]
 80137f4:	683a      	ldr	r2, [r7, #0]
 80137f6:	619a      	str	r2, [r3, #24]
    queue_ptr -> tx_queue_end =    TX_ULONG_POINTER_ADD(queue_ptr -> tx_queue_start, used_words);
 80137f8:	68fb      	ldr	r3, [r7, #12]
 80137fa:	699a      	ldr	r2, [r3, #24]
 80137fc:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80137fe:	009b      	lsls	r3, r3, #2
 8013800:	441a      	add	r2, r3
 8013802:	68fb      	ldr	r3, [r7, #12]
 8013804:	61da      	str	r2, [r3, #28]

    /* Set the read and write pointers to the beginning of the queue
       area.  */
    queue_ptr -> tx_queue_read =   TX_VOID_TO_ULONG_POINTER_CONVERT(queue_start);
 8013806:	68fb      	ldr	r3, [r7, #12]
 8013808:	683a      	ldr	r2, [r7, #0]
 801380a:	621a      	str	r2, [r3, #32]
    queue_ptr -> tx_queue_write =  TX_VOID_TO_ULONG_POINTER_CONVERT(queue_start);
 801380c:	68fb      	ldr	r3, [r7, #12]
 801380e:	683a      	ldr	r2, [r7, #0]
 8013810:	625a      	str	r2, [r3, #36]	; 0x24

    /* Setup the number of enqueued messages and the number of message
       slots available in the queue.  */
    queue_ptr -> tx_queue_available_storage =  (UINT) capacity;
 8013812:	68fb      	ldr	r3, [r7, #12]
 8013814:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 8013816:	615a      	str	r2, [r3, #20]
    queue_ptr -> tx_queue_capacity =           (UINT) capacity;
 8013818:	68fb      	ldr	r3, [r7, #12]
 801381a:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 801381c:	60da      	str	r2, [r3, #12]
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 801381e:	f3ef 8310 	mrs	r3, PRIMASK
 8013822:	61bb      	str	r3, [r7, #24]
    return(posture);
 8013824:	69bb      	ldr	r3, [r7, #24]
    int_posture = __get_interrupt_posture();
 8013826:	617b      	str	r3, [r7, #20]
    __asm__ volatile ("CPSID i" : : : "memory");
 8013828:	b672      	cpsid	i
    return(int_posture);
 801382a:	697b      	ldr	r3, [r7, #20]

    /* Disable interrupts to put the queue on the created list.  */
    TX_DISABLE
 801382c:	627b      	str	r3, [r7, #36]	; 0x24

    /* Setup the queue ID to make it valid.  */
    queue_ptr -> tx_queue_id =  TX_QUEUE_ID;
 801382e:	68fb      	ldr	r3, [r7, #12]
 8013830:	4a18      	ldr	r2, [pc, #96]	; (8013894 <_tx_queue_create+0xdc>)
 8013832:	601a      	str	r2, [r3, #0]

    /* Place the queue on the list of created queues.  First,
       check for an empty list.  */
    if (_tx_queue_created_count == TX_EMPTY)
 8013834:	4b18      	ldr	r3, [pc, #96]	; (8013898 <_tx_queue_create+0xe0>)
 8013836:	681b      	ldr	r3, [r3, #0]
 8013838:	2b00      	cmp	r3, #0
 801383a:	d109      	bne.n	8013850 <_tx_queue_create+0x98>
    {

        /* The created queue list is empty.  Add queue to empty list.  */
        _tx_queue_created_ptr =                   queue_ptr;
 801383c:	4a17      	ldr	r2, [pc, #92]	; (801389c <_tx_queue_create+0xe4>)
 801383e:	68fb      	ldr	r3, [r7, #12]
 8013840:	6013      	str	r3, [r2, #0]
        queue_ptr -> tx_queue_created_next =      queue_ptr;
 8013842:	68fb      	ldr	r3, [r7, #12]
 8013844:	68fa      	ldr	r2, [r7, #12]
 8013846:	631a      	str	r2, [r3, #48]	; 0x30
        queue_ptr -> tx_queue_created_previous =  queue_ptr;
 8013848:	68fb      	ldr	r3, [r7, #12]
 801384a:	68fa      	ldr	r2, [r7, #12]
 801384c:	635a      	str	r2, [r3, #52]	; 0x34
 801384e:	e011      	b.n	8013874 <_tx_queue_create+0xbc>
    }
    else
    {

        /* This list is not NULL, add to the end of the list.  */
        next_queue =      _tx_queue_created_ptr;
 8013850:	4b12      	ldr	r3, [pc, #72]	; (801389c <_tx_queue_create+0xe4>)
 8013852:	681b      	ldr	r3, [r3, #0]
 8013854:	623b      	str	r3, [r7, #32]
        previous_queue =  next_queue -> tx_queue_created_previous;
 8013856:	6a3b      	ldr	r3, [r7, #32]
 8013858:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 801385a:	61fb      	str	r3, [r7, #28]

        /* Place the new queue in the list.  */
        next_queue -> tx_queue_created_previous =  queue_ptr;
 801385c:	6a3b      	ldr	r3, [r7, #32]
 801385e:	68fa      	ldr	r2, [r7, #12]
 8013860:	635a      	str	r2, [r3, #52]	; 0x34
        previous_queue -> tx_queue_created_next =  queue_ptr;
 8013862:	69fb      	ldr	r3, [r7, #28]
 8013864:	68fa      	ldr	r2, [r7, #12]
 8013866:	631a      	str	r2, [r3, #48]	; 0x30

        /* Setup this queues's created links.  */
        queue_ptr -> tx_queue_created_previous =  previous_queue;
 8013868:	68fb      	ldr	r3, [r7, #12]
 801386a:	69fa      	ldr	r2, [r7, #28]
 801386c:	635a      	str	r2, [r3, #52]	; 0x34
        queue_ptr -> tx_queue_created_next =      next_queue;
 801386e:	68fb      	ldr	r3, [r7, #12]
 8013870:	6a3a      	ldr	r2, [r7, #32]
 8013872:	631a      	str	r2, [r3, #48]	; 0x30
    }

    /* Increment the created queue count.  */
    _tx_queue_created_count++;
 8013874:	4b08      	ldr	r3, [pc, #32]	; (8013898 <_tx_queue_create+0xe0>)
 8013876:	681b      	ldr	r3, [r3, #0]
 8013878:	3301      	adds	r3, #1
 801387a:	4a07      	ldr	r2, [pc, #28]	; (8013898 <_tx_queue_create+0xe0>)
 801387c:	6013      	str	r3, [r2, #0]
 801387e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8013880:	613b      	str	r3, [r7, #16]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 8013882:	693b      	ldr	r3, [r7, #16]
 8013884:	f383 8810 	msr	PRIMASK, r3
}
 8013888:	bf00      	nop

    /* Restore interrupts.  */
    TX_RESTORE

    /* Return TX_SUCCESS.  */
    return(TX_SUCCESS);
 801388a:	2300      	movs	r3, #0
}
 801388c:	4618      	mov	r0, r3
 801388e:	3730      	adds	r7, #48	; 0x30
 8013890:	46bd      	mov	sp, r7
 8013892:	bd80      	pop	{r7, pc}
 8013894:	51554555 	.word	0x51554555
 8013898:	24031b98 	.word	0x24031b98
 801389c:	24031b94 	.word	0x24031b94

080138a0 <_tx_queue_delete>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
UINT  _tx_queue_delete(TX_QUEUE *queue_ptr)
{
 80138a0:	b580      	push	{r7, lr}
 80138a2:	b092      	sub	sp, #72	; 0x48
 80138a4:	af00      	add	r7, sp, #0
 80138a6:	6078      	str	r0, [r7, #4]
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 80138a8:	f3ef 8310 	mrs	r3, PRIMASK
 80138ac:	62fb      	str	r3, [r7, #44]	; 0x2c
    return(posture);
 80138ae:	6afb      	ldr	r3, [r7, #44]	; 0x2c
    int_posture = __get_interrupt_posture();
 80138b0:	62bb      	str	r3, [r7, #40]	; 0x28
    __asm__ volatile ("CPSID i" : : : "memory");
 80138b2:	b672      	cpsid	i
    return(int_posture);
 80138b4:	6abb      	ldr	r3, [r7, #40]	; 0x28
TX_QUEUE        *next_queue;
TX_QUEUE        *previous_queue;


    /* Disable interrupts to remove the queue from the created list.  */
    TX_DISABLE
 80138b6:	63fb      	str	r3, [r7, #60]	; 0x3c

    /* Log this kernel call.  */
    TX_EL_QUEUE_DELETE_INSERT

    /* Clear the queue ID to make it invalid.  */
    queue_ptr -> tx_queue_id =  TX_CLEAR_ID;
 80138b8:	687b      	ldr	r3, [r7, #4]
 80138ba:	2200      	movs	r2, #0
 80138bc:	601a      	str	r2, [r3, #0]

    /* Decrement the number of created queues.  */
    _tx_queue_created_count--;
 80138be:	4b3d      	ldr	r3, [pc, #244]	; (80139b4 <_tx_queue_delete+0x114>)
 80138c0:	681b      	ldr	r3, [r3, #0]
 80138c2:	3b01      	subs	r3, #1
 80138c4:	4a3b      	ldr	r2, [pc, #236]	; (80139b4 <_tx_queue_delete+0x114>)
 80138c6:	6013      	str	r3, [r2, #0]

    /* See if the queue is the only one on the list.  */
    if (_tx_queue_created_count == TX_EMPTY)
 80138c8:	4b3a      	ldr	r3, [pc, #232]	; (80139b4 <_tx_queue_delete+0x114>)
 80138ca:	681b      	ldr	r3, [r3, #0]
 80138cc:	2b00      	cmp	r3, #0
 80138ce:	d103      	bne.n	80138d8 <_tx_queue_delete+0x38>
    {

        /* Only created queue, just set the created list to NULL.  */
        _tx_queue_created_ptr =  TX_NULL;
 80138d0:	4b39      	ldr	r3, [pc, #228]	; (80139b8 <_tx_queue_delete+0x118>)
 80138d2:	2200      	movs	r2, #0
 80138d4:	601a      	str	r2, [r3, #0]
 80138d6:	e013      	b.n	8013900 <_tx_queue_delete+0x60>
    }
    else
    {

        /* Link-up the neighbors.  */
        next_queue =                               queue_ptr -> tx_queue_created_next;
 80138d8:	687b      	ldr	r3, [r7, #4]
 80138da:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 80138dc:	63bb      	str	r3, [r7, #56]	; 0x38
        previous_queue =                           queue_ptr -> tx_queue_created_previous;
 80138de:	687b      	ldr	r3, [r7, #4]
 80138e0:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 80138e2:	637b      	str	r3, [r7, #52]	; 0x34
        next_queue -> tx_queue_created_previous =  previous_queue;
 80138e4:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 80138e6:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 80138e8:	635a      	str	r2, [r3, #52]	; 0x34
        previous_queue -> tx_queue_created_next =  next_queue;
 80138ea:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 80138ec:	6bba      	ldr	r2, [r7, #56]	; 0x38
 80138ee:	631a      	str	r2, [r3, #48]	; 0x30

        /* See if we have to update the created list head pointer.  */
        if (_tx_queue_created_ptr == queue_ptr)
 80138f0:	4b31      	ldr	r3, [pc, #196]	; (80139b8 <_tx_queue_delete+0x118>)
 80138f2:	681b      	ldr	r3, [r3, #0]
 80138f4:	687a      	ldr	r2, [r7, #4]
 80138f6:	429a      	cmp	r2, r3
 80138f8:	d102      	bne.n	8013900 <_tx_queue_delete+0x60>
        {
        
            /* Yes, move the head pointer to the next link. */
            _tx_queue_created_ptr =  next_queue;
 80138fa:	4a2f      	ldr	r2, [pc, #188]	; (80139b8 <_tx_queue_delete+0x118>)
 80138fc:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 80138fe:	6013      	str	r3, [r2, #0]
        }
    }

    /* Temporarily disable preemption.  */
    _tx_thread_preempt_disable++;
 8013900:	4b2e      	ldr	r3, [pc, #184]	; (80139bc <_tx_queue_delete+0x11c>)
 8013902:	681b      	ldr	r3, [r3, #0]
 8013904:	3301      	adds	r3, #1
 8013906:	4a2d      	ldr	r2, [pc, #180]	; (80139bc <_tx_queue_delete+0x11c>)
 8013908:	6013      	str	r3, [r2, #0]

    /* Pickup the suspension information.  */
    thread_ptr =                             queue_ptr -> tx_queue_suspension_list;
 801390a:	687b      	ldr	r3, [r7, #4]
 801390c:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 801390e:	647b      	str	r3, [r7, #68]	; 0x44
    queue_ptr -> tx_queue_suspension_list =  TX_NULL;
 8013910:	687b      	ldr	r3, [r7, #4]
 8013912:	2200      	movs	r2, #0
 8013914:	629a      	str	r2, [r3, #40]	; 0x28
    suspended_count =                        queue_ptr -> tx_queue_suspended_count;
 8013916:	687b      	ldr	r3, [r7, #4]
 8013918:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 801391a:	643b      	str	r3, [r7, #64]	; 0x40
    queue_ptr -> tx_queue_suspended_count =  TX_NO_SUSPENSIONS;
 801391c:	687b      	ldr	r3, [r7, #4]
 801391e:	2200      	movs	r2, #0
 8013920:	62da      	str	r2, [r3, #44]	; 0x2c
 8013922:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8013924:	627b      	str	r3, [r7, #36]	; 0x24
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 8013926:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8013928:	f383 8810 	msr	PRIMASK, r3
}
 801392c:	bf00      	nop
    /* Restore interrupts.  */
    TX_RESTORE

    /* Walk through the queue list to resume any and all threads suspended
       on this queue.  */
    while (suspended_count != TX_NO_SUSPENSIONS)
 801392e:	e024      	b.n	801397a <_tx_queue_delete+0xda>
    {
      
        /* Decrement the suspension count.  */
        suspended_count--;
 8013930:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8013932:	3b01      	subs	r3, #1
 8013934:	643b      	str	r3, [r7, #64]	; 0x40
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 8013936:	f3ef 8310 	mrs	r3, PRIMASK
 801393a:	61fb      	str	r3, [r7, #28]
    return(posture);
 801393c:	69fb      	ldr	r3, [r7, #28]
    int_posture = __get_interrupt_posture();
 801393e:	61bb      	str	r3, [r7, #24]
    __asm__ volatile ("CPSID i" : : : "memory");
 8013940:	b672      	cpsid	i
    return(int_posture);
 8013942:	69bb      	ldr	r3, [r7, #24]

        /* Lockout interrupts.  */
        TX_DISABLE
 8013944:	63fb      	str	r3, [r7, #60]	; 0x3c

        /* Clear the cleanup pointer, this prevents the timeout from doing 
           anything.  */
        thread_ptr -> tx_thread_suspend_cleanup =  TX_NULL;
 8013946:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8013948:	2200      	movs	r2, #0
 801394a:	669a      	str	r2, [r3, #104]	; 0x68

        /* Set the return status in the thread to TX_DELETED.  */
        thread_ptr -> tx_thread_suspend_status =  TX_DELETED;
 801394c:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 801394e:	2201      	movs	r2, #1
 8013950:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84

        /* Move the thread pointer ahead.  */
        next_thread =  thread_ptr -> tx_thread_suspended_next;
 8013954:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8013956:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 8013958:	633b      	str	r3, [r7, #48]	; 0x30
        /* Restore interrupts.  */
        TX_RESTORE
#else

        /* Temporarily disable preemption again.  */
        _tx_thread_preempt_disable++;
 801395a:	4b18      	ldr	r3, [pc, #96]	; (80139bc <_tx_queue_delete+0x11c>)
 801395c:	681b      	ldr	r3, [r3, #0]
 801395e:	3301      	adds	r3, #1
 8013960:	4a16      	ldr	r2, [pc, #88]	; (80139bc <_tx_queue_delete+0x11c>)
 8013962:	6013      	str	r3, [r2, #0]
 8013964:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8013966:	623b      	str	r3, [r7, #32]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 8013968:	6a3b      	ldr	r3, [r7, #32]
 801396a:	f383 8810 	msr	PRIMASK, r3
}
 801396e:	bf00      	nop

        /* Restore interrupts.  */
        TX_RESTORE

        /* Resume the thread.  */
        _tx_thread_system_resume(thread_ptr);
 8013970:	6c78      	ldr	r0, [r7, #68]	; 0x44
 8013972:	f001 f9d9 	bl	8014d28 <_tx_thread_system_resume>
#endif

        /* Move to next thread.  */
        thread_ptr =  next_thread;
 8013976:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8013978:	647b      	str	r3, [r7, #68]	; 0x44
    while (suspended_count != TX_NO_SUSPENSIONS)
 801397a:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 801397c:	2b00      	cmp	r3, #0
 801397e:	d1d7      	bne.n	8013930 <_tx_queue_delete+0x90>
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 8013980:	f3ef 8310 	mrs	r3, PRIMASK
 8013984:	613b      	str	r3, [r7, #16]
    return(posture);
 8013986:	693b      	ldr	r3, [r7, #16]
    int_posture = __get_interrupt_posture();
 8013988:	60fb      	str	r3, [r7, #12]
    __asm__ volatile ("CPSID i" : : : "memory");
 801398a:	b672      	cpsid	i
    return(int_posture);
 801398c:	68fb      	ldr	r3, [r7, #12]

    /* Execute Port-Specific completion processing. If needed, it is typically defined in tx_port.h.  */
    TX_QUEUE_DELETE_PORT_COMPLETION(queue_ptr)

    /* Disable interrupts.  */
    TX_DISABLE
 801398e:	63fb      	str	r3, [r7, #60]	; 0x3c

    /* Release previous preempt disable.  */
    _tx_thread_preempt_disable--;
 8013990:	4b0a      	ldr	r3, [pc, #40]	; (80139bc <_tx_queue_delete+0x11c>)
 8013992:	681b      	ldr	r3, [r3, #0]
 8013994:	3b01      	subs	r3, #1
 8013996:	4a09      	ldr	r2, [pc, #36]	; (80139bc <_tx_queue_delete+0x11c>)
 8013998:	6013      	str	r3, [r2, #0]
 801399a:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 801399c:	617b      	str	r3, [r7, #20]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 801399e:	697b      	ldr	r3, [r7, #20]
 80139a0:	f383 8810 	msr	PRIMASK, r3
}
 80139a4:	bf00      	nop

    /* Restore interrupts.  */
    TX_RESTORE

    /* Check for preemption.  */
    _tx_thread_system_preempt_check();
 80139a6:	f001 f985 	bl	8014cb4 <_tx_thread_system_preempt_check>

    /* Return TX_SUCCESS.  */
    return(TX_SUCCESS);
 80139aa:	2300      	movs	r3, #0
}
 80139ac:	4618      	mov	r0, r3
 80139ae:	3748      	adds	r7, #72	; 0x48
 80139b0:	46bd      	mov	sp, r7
 80139b2:	bd80      	pop	{r7, pc}
 80139b4:	24031b98 	.word	0x24031b98
 80139b8:	24031b94 	.word	0x24031b94
 80139bc:	24031c5c 	.word	0x24031c5c

080139c0 <_tx_queue_flush>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
UINT  _tx_queue_flush(TX_QUEUE *queue_ptr)
{
 80139c0:	b580      	push	{r7, lr}
 80139c2:	b090      	sub	sp, #64	; 0x40
 80139c4:	af00      	add	r7, sp, #0
 80139c6:	6078      	str	r0, [r7, #4]
UINT            suspended_count;
TX_THREAD       *thread_ptr;


    /* Initialize the suspended count and list.  */
    suspended_count =  TX_NO_SUSPENSIONS;
 80139c8:	2300      	movs	r3, #0
 80139ca:	63bb      	str	r3, [r7, #56]	; 0x38
    suspension_list =  TX_NULL;
 80139cc:	2300      	movs	r3, #0
 80139ce:	63fb      	str	r3, [r7, #60]	; 0x3c
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 80139d0:	f3ef 8310 	mrs	r3, PRIMASK
 80139d4:	62fb      	str	r3, [r7, #44]	; 0x2c
    return(posture);
 80139d6:	6afb      	ldr	r3, [r7, #44]	; 0x2c
    int_posture = __get_interrupt_posture();
 80139d8:	62bb      	str	r3, [r7, #40]	; 0x28
    __asm__ volatile ("CPSID i" : : : "memory");
 80139da:	b672      	cpsid	i
    return(int_posture);
 80139dc:	6abb      	ldr	r3, [r7, #40]	; 0x28

    /* Disable interrupts to reset various queue parameters.  */
    TX_DISABLE
 80139de:	633b      	str	r3, [r7, #48]	; 0x30

    /* Log this kernel call.  */
    TX_EL_QUEUE_FLUSH_INSERT

    /* Determine if there is something on the queue.  */
    if (queue_ptr -> tx_queue_enqueued != TX_NO_MESSAGES)
 80139e0:	687b      	ldr	r3, [r7, #4]
 80139e2:	691b      	ldr	r3, [r3, #16]
 80139e4:	2b00      	cmp	r3, #0
 80139e6:	d023      	beq.n	8013a30 <_tx_queue_flush+0x70>
    {

        /* Yes, there is something in the queue.  */

        /* Reset the queue parameters to erase all of the queued messages.  */
        queue_ptr -> tx_queue_enqueued =           TX_NO_MESSAGES;
 80139e8:	687b      	ldr	r3, [r7, #4]
 80139ea:	2200      	movs	r2, #0
 80139ec:	611a      	str	r2, [r3, #16]
        queue_ptr -> tx_queue_available_storage =  queue_ptr -> tx_queue_capacity;
 80139ee:	687b      	ldr	r3, [r7, #4]
 80139f0:	68da      	ldr	r2, [r3, #12]
 80139f2:	687b      	ldr	r3, [r7, #4]
 80139f4:	615a      	str	r2, [r3, #20]
        queue_ptr -> tx_queue_read =               queue_ptr -> tx_queue_start;
 80139f6:	687b      	ldr	r3, [r7, #4]
 80139f8:	699a      	ldr	r2, [r3, #24]
 80139fa:	687b      	ldr	r3, [r7, #4]
 80139fc:	621a      	str	r2, [r3, #32]
        queue_ptr -> tx_queue_write =              queue_ptr -> tx_queue_start;
 80139fe:	687b      	ldr	r3, [r7, #4]
 8013a00:	699a      	ldr	r2, [r3, #24]
 8013a02:	687b      	ldr	r3, [r7, #4]
 8013a04:	625a      	str	r2, [r3, #36]	; 0x24

        /* Now determine if there are any threads suspended on a full queue.  */
        if (queue_ptr -> tx_queue_suspended_count != TX_NO_SUSPENSIONS)
 8013a06:	687b      	ldr	r3, [r7, #4]
 8013a08:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8013a0a:	2b00      	cmp	r3, #0
 8013a0c:	d010      	beq.n	8013a30 <_tx_queue_flush+0x70>

            /* Yes, there are threads suspended on this queue, they must be 
               resumed!  */

            /* Copy the information into temporary variables.  */
            suspension_list =  queue_ptr -> tx_queue_suspension_list;
 8013a0e:	687b      	ldr	r3, [r7, #4]
 8013a10:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8013a12:	63fb      	str	r3, [r7, #60]	; 0x3c
            suspended_count =  queue_ptr -> tx_queue_suspended_count;
 8013a14:	687b      	ldr	r3, [r7, #4]
 8013a16:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8013a18:	63bb      	str	r3, [r7, #56]	; 0x38

            /* Clear the queue variables.  */
            queue_ptr -> tx_queue_suspension_list =  TX_NULL;
 8013a1a:	687b      	ldr	r3, [r7, #4]
 8013a1c:	2200      	movs	r2, #0
 8013a1e:	629a      	str	r2, [r3, #40]	; 0x28
            queue_ptr -> tx_queue_suspended_count =  TX_NO_SUSPENSIONS;
 8013a20:	687b      	ldr	r3, [r7, #4]
 8013a22:	2200      	movs	r2, #0
 8013a24:	62da      	str	r2, [r3, #44]	; 0x2c

            /* Temporarily disable preemption.  */
            _tx_thread_preempt_disable++;
 8013a26:	4b2c      	ldr	r3, [pc, #176]	; (8013ad8 <_tx_queue_flush+0x118>)
 8013a28:	681b      	ldr	r3, [r3, #0]
 8013a2a:	3301      	adds	r3, #1
 8013a2c:	4a2a      	ldr	r2, [pc, #168]	; (8013ad8 <_tx_queue_flush+0x118>)
 8013a2e:	6013      	str	r3, [r2, #0]
 8013a30:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8013a32:	627b      	str	r3, [r7, #36]	; 0x24
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 8013a34:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8013a36:	f383 8810 	msr	PRIMASK, r3
}
 8013a3a:	bf00      	nop
    /* Restore interrupts.  */
    TX_RESTORE

    /* Walk through the queue list to resume any and all threads suspended
       on this queue.  */
    if (suspended_count != TX_NO_SUSPENSIONS)
 8013a3c:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8013a3e:	2b00      	cmp	r3, #0
 8013a40:	d044      	beq.n	8013acc <_tx_queue_flush+0x10c>
    {

        /* Pickup the thread to resume.  */
        thread_ptr =  suspension_list;
 8013a42:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8013a44:	637b      	str	r3, [r7, #52]	; 0x34
        while (suspended_count != ((ULONG) 0))
 8013a46:	e027      	b.n	8013a98 <_tx_queue_flush+0xd8>
        {
        
            /* Decrement the suspension count.  */
            suspended_count--;
 8013a48:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8013a4a:	3b01      	subs	r3, #1
 8013a4c:	63bb      	str	r3, [r7, #56]	; 0x38

            /* Check for a NULL thread pointer.  */
            if (thread_ptr == TX_NULL)
 8013a4e:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8013a50:	2b00      	cmp	r3, #0
 8013a52:	d025      	beq.n	8013aa0 <_tx_queue_flush+0xe0>
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 8013a54:	f3ef 8310 	mrs	r3, PRIMASK
 8013a58:	61fb      	str	r3, [r7, #28]
    return(posture);
 8013a5a:	69fb      	ldr	r3, [r7, #28]
    int_posture = __get_interrupt_posture();
 8013a5c:	61bb      	str	r3, [r7, #24]
    __asm__ volatile ("CPSID i" : : : "memory");
 8013a5e:	b672      	cpsid	i
    return(int_posture);
 8013a60:	69bb      	ldr	r3, [r7, #24]
            }

            /* Resume the next suspended thread.  */
            
            /* Lockout interrupts.  */
            TX_DISABLE
 8013a62:	633b      	str	r3, [r7, #48]	; 0x30

            /* Clear the cleanup pointer, this prevents the timeout from doing 
               anything.  */
            thread_ptr -> tx_thread_suspend_cleanup =  TX_NULL;
 8013a64:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8013a66:	2200      	movs	r2, #0
 8013a68:	669a      	str	r2, [r3, #104]	; 0x68

            /* Set the return status in the thread to TX_SUCCESS.  */
            thread_ptr -> tx_thread_suspend_status =  TX_SUCCESS;
 8013a6a:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8013a6c:	2200      	movs	r2, #0
 8013a6e:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84

            /* Move the thread pointer ahead.  */
            thread_ptr =  thread_ptr -> tx_thread_suspended_next;
 8013a72:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8013a74:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 8013a76:	637b      	str	r3, [r7, #52]	; 0x34
            /* Restore interrupts.  */
            TX_RESTORE
#else

            /* Temporarily disable preemption again.  */
            _tx_thread_preempt_disable++;
 8013a78:	4b17      	ldr	r3, [pc, #92]	; (8013ad8 <_tx_queue_flush+0x118>)
 8013a7a:	681b      	ldr	r3, [r3, #0]
 8013a7c:	3301      	adds	r3, #1
 8013a7e:	4a16      	ldr	r2, [pc, #88]	; (8013ad8 <_tx_queue_flush+0x118>)
 8013a80:	6013      	str	r3, [r2, #0]
 8013a82:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8013a84:	623b      	str	r3, [r7, #32]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 8013a86:	6a3b      	ldr	r3, [r7, #32]
 8013a88:	f383 8810 	msr	PRIMASK, r3
}
 8013a8c:	bf00      	nop

            /* Restore interrupts.  */
            TX_RESTORE
    
            /* Resume the thread.  */
            _tx_thread_system_resume(thread_ptr -> tx_thread_suspended_previous);
 8013a8e:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8013a90:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 8013a92:	4618      	mov	r0, r3
 8013a94:	f001 f948 	bl	8014d28 <_tx_thread_system_resume>
        while (suspended_count != ((ULONG) 0))
 8013a98:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8013a9a:	2b00      	cmp	r3, #0
 8013a9c:	d1d4      	bne.n	8013a48 <_tx_queue_flush+0x88>
 8013a9e:	e000      	b.n	8013aa2 <_tx_queue_flush+0xe2>
                break;
 8013aa0:	bf00      	nop
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 8013aa2:	f3ef 8310 	mrs	r3, PRIMASK
 8013aa6:	613b      	str	r3, [r7, #16]
    return(posture);
 8013aa8:	693b      	ldr	r3, [r7, #16]
    int_posture = __get_interrupt_posture();
 8013aaa:	60fb      	str	r3, [r7, #12]
    __asm__ volatile ("CPSID i" : : : "memory");
 8013aac:	b672      	cpsid	i
    return(int_posture);
 8013aae:	68fb      	ldr	r3, [r7, #12]
#endif
        }

        /* Disable interrupts.  */
        TX_DISABLE
 8013ab0:	633b      	str	r3, [r7, #48]	; 0x30

        /* Restore previous preempt posture.  */
        _tx_thread_preempt_disable--;
 8013ab2:	4b09      	ldr	r3, [pc, #36]	; (8013ad8 <_tx_queue_flush+0x118>)
 8013ab4:	681b      	ldr	r3, [r3, #0]
 8013ab6:	3b01      	subs	r3, #1
 8013ab8:	4a07      	ldr	r2, [pc, #28]	; (8013ad8 <_tx_queue_flush+0x118>)
 8013aba:	6013      	str	r3, [r2, #0]
 8013abc:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8013abe:	617b      	str	r3, [r7, #20]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 8013ac0:	697b      	ldr	r3, [r7, #20]
 8013ac2:	f383 8810 	msr	PRIMASK, r3
}
 8013ac6:	bf00      	nop

        /* Restore interrupts.  */
        TX_RESTORE

        /* Check for preemption.  */
        _tx_thread_system_preempt_check();
 8013ac8:	f001 f8f4 	bl	8014cb4 <_tx_thread_system_preempt_check>
    }

    /* Return TX_SUCCESS.  */
    return(TX_SUCCESS);
 8013acc:	2300      	movs	r3, #0
}
 8013ace:	4618      	mov	r0, r3
 8013ad0:	3740      	adds	r7, #64	; 0x40
 8013ad2:	46bd      	mov	sp, r7
 8013ad4:	bd80      	pop	{r7, pc}
 8013ad6:	bf00      	nop
 8013ad8:	24031c5c 	.word	0x24031c5c

08013adc <_tx_queue_receive>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
UINT  _tx_queue_receive(TX_QUEUE *queue_ptr, VOID *destination_ptr, ULONG wait_option)
{
 8013adc:	b580      	push	{r7, lr}
 8013ade:	b096      	sub	sp, #88	; 0x58
 8013ae0:	af00      	add	r7, sp, #0
 8013ae2:	60f8      	str	r0, [r7, #12]
 8013ae4:	60b9      	str	r1, [r7, #8]
 8013ae6:	607a      	str	r2, [r7, #4]
TX_THREAD       *previous_thread;
UINT            status;


    /* Default the status to TX_SUCCESS.  */
    status =  TX_SUCCESS;
 8013ae8:	2300      	movs	r3, #0
 8013aea:	64bb      	str	r3, [r7, #72]	; 0x48
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 8013aec:	f3ef 8310 	mrs	r3, PRIMASK
 8013af0:	633b      	str	r3, [r7, #48]	; 0x30
    return(posture);
 8013af2:	6b3b      	ldr	r3, [r7, #48]	; 0x30
    int_posture = __get_interrupt_posture();
 8013af4:	62fb      	str	r3, [r7, #44]	; 0x2c
    __asm__ volatile ("CPSID i" : : : "memory");
 8013af6:	b672      	cpsid	i
    return(int_posture);
 8013af8:	6afb      	ldr	r3, [r7, #44]	; 0x2c

    /* Disable interrupts to receive message from queue.  */
    TX_DISABLE
 8013afa:	647b      	str	r3, [r7, #68]	; 0x44

    /* Log this kernel call.  */
    TX_EL_QUEUE_RECEIVE_INSERT

    /* Pickup the thread suspension count.  */
    suspended_count =  queue_ptr -> tx_queue_suspended_count;
 8013afc:	68fb      	ldr	r3, [r7, #12]
 8013afe:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8013b00:	643b      	str	r3, [r7, #64]	; 0x40
    
    /* Determine if there is anything in the queue.  */
    if (queue_ptr -> tx_queue_enqueued != TX_NO_MESSAGES)
 8013b02:	68fb      	ldr	r3, [r7, #12]
 8013b04:	691b      	ldr	r3, [r3, #16]
 8013b06:	2b00      	cmp	r3, #0
 8013b08:	f000 8136 	beq.w	8013d78 <_tx_queue_receive+0x29c>
    {

        /* Determine if there are any suspensions.  */
        if (suspended_count == TX_NO_SUSPENSIONS)
 8013b0c:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8013b0e:	2b00      	cmp	r3, #0
 8013b10:	d13c      	bne.n	8013b8c <_tx_queue_receive+0xb0>
        {

            /* There is a message waiting in the queue and there are no suspensi.  */
            
            /* Setup source and destination pointers.  */
            source =       queue_ptr -> tx_queue_read;
 8013b12:	68fb      	ldr	r3, [r7, #12]
 8013b14:	6a1b      	ldr	r3, [r3, #32]
 8013b16:	657b      	str	r3, [r7, #84]	; 0x54
            destination =  TX_VOID_TO_ULONG_POINTER_CONVERT(destination_ptr);
 8013b18:	68bb      	ldr	r3, [r7, #8]
 8013b1a:	653b      	str	r3, [r7, #80]	; 0x50
            size =         queue_ptr -> tx_queue_message_size;
 8013b1c:	68fb      	ldr	r3, [r7, #12]
 8013b1e:	689b      	ldr	r3, [r3, #8]
 8013b20:	64fb      	str	r3, [r7, #76]	; 0x4c

            /* Copy message. Note that the source and destination pointers are 
               incremented by the macro.  */
            TX_QUEUE_MESSAGE_COPY(source, destination, size)
 8013b22:	6d7a      	ldr	r2, [r7, #84]	; 0x54
 8013b24:	1d13      	adds	r3, r2, #4
 8013b26:	657b      	str	r3, [r7, #84]	; 0x54
 8013b28:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 8013b2a:	1d19      	adds	r1, r3, #4
 8013b2c:	6539      	str	r1, [r7, #80]	; 0x50
 8013b2e:	6812      	ldr	r2, [r2, #0]
 8013b30:	601a      	str	r2, [r3, #0]
 8013b32:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8013b34:	2b01      	cmp	r3, #1
 8013b36:	d90e      	bls.n	8013b56 <_tx_queue_receive+0x7a>
 8013b38:	e007      	b.n	8013b4a <_tx_queue_receive+0x6e>
 8013b3a:	6d7a      	ldr	r2, [r7, #84]	; 0x54
 8013b3c:	1d13      	adds	r3, r2, #4
 8013b3e:	657b      	str	r3, [r7, #84]	; 0x54
 8013b40:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 8013b42:	1d19      	adds	r1, r3, #4
 8013b44:	6539      	str	r1, [r7, #80]	; 0x50
 8013b46:	6812      	ldr	r2, [r2, #0]
 8013b48:	601a      	str	r2, [r3, #0]
 8013b4a:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8013b4c:	3b01      	subs	r3, #1
 8013b4e:	64fb      	str	r3, [r7, #76]	; 0x4c
 8013b50:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8013b52:	2b00      	cmp	r3, #0
 8013b54:	d1f1      	bne.n	8013b3a <_tx_queue_receive+0x5e>

            /* Determine if we are at the end.  */
            if (source == queue_ptr -> tx_queue_end)
 8013b56:	68fb      	ldr	r3, [r7, #12]
 8013b58:	69db      	ldr	r3, [r3, #28]
 8013b5a:	6d7a      	ldr	r2, [r7, #84]	; 0x54
 8013b5c:	429a      	cmp	r2, r3
 8013b5e:	d102      	bne.n	8013b66 <_tx_queue_receive+0x8a>
            {

                /* Yes, wrap around to the beginning.  */
                source =  queue_ptr -> tx_queue_start;
 8013b60:	68fb      	ldr	r3, [r7, #12]
 8013b62:	699b      	ldr	r3, [r3, #24]
 8013b64:	657b      	str	r3, [r7, #84]	; 0x54
            }
        
            /* Setup the queue read pointer.   */
            queue_ptr -> tx_queue_read =  source;
 8013b66:	68fb      	ldr	r3, [r7, #12]
 8013b68:	6d7a      	ldr	r2, [r7, #84]	; 0x54
 8013b6a:	621a      	str	r2, [r3, #32]
        
            /* Increase the amount of available storage.  */
            queue_ptr -> tx_queue_available_storage++;
 8013b6c:	68fb      	ldr	r3, [r7, #12]
 8013b6e:	695b      	ldr	r3, [r3, #20]
 8013b70:	1c5a      	adds	r2, r3, #1
 8013b72:	68fb      	ldr	r3, [r7, #12]
 8013b74:	615a      	str	r2, [r3, #20]

            /* Decrease the enqueued count.  */
            queue_ptr -> tx_queue_enqueued--;
 8013b76:	68fb      	ldr	r3, [r7, #12]
 8013b78:	691b      	ldr	r3, [r3, #16]
 8013b7a:	1e5a      	subs	r2, r3, #1
 8013b7c:	68fb      	ldr	r3, [r7, #12]
 8013b7e:	611a      	str	r2, [r3, #16]
 8013b80:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8013b82:	62bb      	str	r3, [r7, #40]	; 0x28
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 8013b84:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8013b86:	f383 8810 	msr	PRIMASK, r3
}
 8013b8a:	e163      	b.n	8013e54 <_tx_queue_receive+0x378>
        {
        
            /* At this point we know the queue is full.  */

            /* Pickup thread suspension list head pointer.  */
            thread_ptr =  queue_ptr -> tx_queue_suspension_list;
 8013b8c:	68fb      	ldr	r3, [r7, #12]
 8013b8e:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8013b90:	63fb      	str	r3, [r7, #60]	; 0x3c

            /* Now determine if there is a queue front suspension active.   */
    
            /* Is the front suspension flag set?  */
            if (thread_ptr -> tx_thread_suspend_option == TX_TRUE)
 8013b92:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8013b94:	f8d3 3080 	ldr.w	r3, [r3, #128]	; 0x80
 8013b98:	2b01      	cmp	r3, #1
 8013b9a:	d153      	bne.n	8013c44 <_tx_queue_receive+0x168>
                /* Yes, a queue front suspension is present.  */

                /* Return the message associated with this suspension.  */

                /* Setup source and destination pointers.  */
                source =       TX_VOID_TO_ULONG_POINTER_CONVERT(thread_ptr -> tx_thread_additional_suspend_info);
 8013b9c:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8013b9e:	6fdb      	ldr	r3, [r3, #124]	; 0x7c
 8013ba0:	657b      	str	r3, [r7, #84]	; 0x54
                destination =  TX_VOID_TO_ULONG_POINTER_CONVERT(destination_ptr);
 8013ba2:	68bb      	ldr	r3, [r7, #8]
 8013ba4:	653b      	str	r3, [r7, #80]	; 0x50
                size =         queue_ptr -> tx_queue_message_size;
 8013ba6:	68fb      	ldr	r3, [r7, #12]
 8013ba8:	689b      	ldr	r3, [r3, #8]
 8013baa:	64fb      	str	r3, [r7, #76]	; 0x4c

                /* Copy message. Note that the source and destination pointers are 
                   incremented by the macro.  */
                TX_QUEUE_MESSAGE_COPY(source, destination, size)
 8013bac:	6d7a      	ldr	r2, [r7, #84]	; 0x54
 8013bae:	1d13      	adds	r3, r2, #4
 8013bb0:	657b      	str	r3, [r7, #84]	; 0x54
 8013bb2:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 8013bb4:	1d19      	adds	r1, r3, #4
 8013bb6:	6539      	str	r1, [r7, #80]	; 0x50
 8013bb8:	6812      	ldr	r2, [r2, #0]
 8013bba:	601a      	str	r2, [r3, #0]
 8013bbc:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8013bbe:	2b01      	cmp	r3, #1
 8013bc0:	d90e      	bls.n	8013be0 <_tx_queue_receive+0x104>
 8013bc2:	e007      	b.n	8013bd4 <_tx_queue_receive+0xf8>
 8013bc4:	6d7a      	ldr	r2, [r7, #84]	; 0x54
 8013bc6:	1d13      	adds	r3, r2, #4
 8013bc8:	657b      	str	r3, [r7, #84]	; 0x54
 8013bca:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 8013bcc:	1d19      	adds	r1, r3, #4
 8013bce:	6539      	str	r1, [r7, #80]	; 0x50
 8013bd0:	6812      	ldr	r2, [r2, #0]
 8013bd2:	601a      	str	r2, [r3, #0]
 8013bd4:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8013bd6:	3b01      	subs	r3, #1
 8013bd8:	64fb      	str	r3, [r7, #76]	; 0x4c
 8013bda:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8013bdc:	2b00      	cmp	r3, #0
 8013bde:	d1f1      	bne.n	8013bc4 <_tx_queue_receive+0xe8>

                /* Message is now in the caller's destination. See if this is the only suspended thread 
                   on the list.  */
                suspended_count--;
 8013be0:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8013be2:	3b01      	subs	r3, #1
 8013be4:	643b      	str	r3, [r7, #64]	; 0x40
                if (suspended_count == TX_NO_SUSPENSIONS)
 8013be6:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8013be8:	2b00      	cmp	r3, #0
 8013bea:	d103      	bne.n	8013bf4 <_tx_queue_receive+0x118>
                {

                    /* Yes, the only suspended thread.  */

                    /* Update the head pointer.  */
                    queue_ptr -> tx_queue_suspension_list =  TX_NULL;
 8013bec:	68fb      	ldr	r3, [r7, #12]
 8013bee:	2200      	movs	r2, #0
 8013bf0:	629a      	str	r2, [r3, #40]	; 0x28
 8013bf2:	e00e      	b.n	8013c12 <_tx_queue_receive+0x136>
                {

                    /* At least one more thread is on the same expiration list.  */

                    /* Update the list head pointer.  */
                    next_thread =                            thread_ptr -> tx_thread_suspended_next;
 8013bf4:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8013bf6:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 8013bf8:	63bb      	str	r3, [r7, #56]	; 0x38
                    queue_ptr -> tx_queue_suspension_list =  next_thread;
 8013bfa:	68fb      	ldr	r3, [r7, #12]
 8013bfc:	6bba      	ldr	r2, [r7, #56]	; 0x38
 8013bfe:	629a      	str	r2, [r3, #40]	; 0x28

                    /* Update the links of the adjacent threads.  */
                    previous_thread =                              thread_ptr -> tx_thread_suspended_previous;
 8013c00:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8013c02:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 8013c04:	637b      	str	r3, [r7, #52]	; 0x34
                    next_thread -> tx_thread_suspended_previous =  previous_thread;
 8013c06:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8013c08:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 8013c0a:	675a      	str	r2, [r3, #116]	; 0x74
                    previous_thread -> tx_thread_suspended_next =  next_thread;
 8013c0c:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8013c0e:	6bba      	ldr	r2, [r7, #56]	; 0x38
 8013c10:	671a      	str	r2, [r3, #112]	; 0x70
                }

                /* Decrement the suspension count.  */
                queue_ptr -> tx_queue_suspended_count =  suspended_count;
 8013c12:	68fb      	ldr	r3, [r7, #12]
 8013c14:	6c3a      	ldr	r2, [r7, #64]	; 0x40
 8013c16:	62da      	str	r2, [r3, #44]	; 0x2c

                /* Prepare for resumption of the first thread.  */

                /* Clear cleanup routine to avoid timeout.  */
                thread_ptr -> tx_thread_suspend_cleanup =  TX_NULL;
 8013c18:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8013c1a:	2200      	movs	r2, #0
 8013c1c:	669a      	str	r2, [r3, #104]	; 0x68

                /* Put return status into the thread control block.  */
                thread_ptr -> tx_thread_suspend_status =  TX_SUCCESS;
 8013c1e:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8013c20:	2200      	movs	r2, #0
 8013c22:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84
                /* Restore interrupts.  */
                TX_RESTORE
#else

                /* Temporarily disable preemption.  */
                _tx_thread_preempt_disable++;
 8013c26:	4b8e      	ldr	r3, [pc, #568]	; (8013e60 <_tx_queue_receive+0x384>)
 8013c28:	681b      	ldr	r3, [r3, #0]
 8013c2a:	3301      	adds	r3, #1
 8013c2c:	4a8c      	ldr	r2, [pc, #560]	; (8013e60 <_tx_queue_receive+0x384>)
 8013c2e:	6013      	str	r3, [r2, #0]
 8013c30:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8013c32:	627b      	str	r3, [r7, #36]	; 0x24
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 8013c34:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8013c36:	f383 8810 	msr	PRIMASK, r3
}
 8013c3a:	bf00      	nop

                /* Restore interrupts.  */
                TX_RESTORE

                /* Resume thread.  */
                _tx_thread_system_resume(thread_ptr);
 8013c3c:	6bf8      	ldr	r0, [r7, #60]	; 0x3c
 8013c3e:	f001 f873 	bl	8014d28 <_tx_thread_system_resume>
 8013c42:	e107      	b.n	8013e54 <_tx_queue_receive+0x378>
                /* At this point, we know that the queue is full and there 
                   are one or more threads suspended trying to send another
                   message to this queue.  */

                /* Setup source and destination pointers.  */
                source =       queue_ptr -> tx_queue_read;
 8013c44:	68fb      	ldr	r3, [r7, #12]
 8013c46:	6a1b      	ldr	r3, [r3, #32]
 8013c48:	657b      	str	r3, [r7, #84]	; 0x54
                destination =  TX_VOID_TO_ULONG_POINTER_CONVERT(destination_ptr);
 8013c4a:	68bb      	ldr	r3, [r7, #8]
 8013c4c:	653b      	str	r3, [r7, #80]	; 0x50
                size =         queue_ptr -> tx_queue_message_size;
 8013c4e:	68fb      	ldr	r3, [r7, #12]
 8013c50:	689b      	ldr	r3, [r3, #8]
 8013c52:	64fb      	str	r3, [r7, #76]	; 0x4c

                /* Copy message. Note that the source and destination pointers are 
                   incremented by the macro.  */
                TX_QUEUE_MESSAGE_COPY(source, destination, size)
 8013c54:	6d7a      	ldr	r2, [r7, #84]	; 0x54
 8013c56:	1d13      	adds	r3, r2, #4
 8013c58:	657b      	str	r3, [r7, #84]	; 0x54
 8013c5a:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 8013c5c:	1d19      	adds	r1, r3, #4
 8013c5e:	6539      	str	r1, [r7, #80]	; 0x50
 8013c60:	6812      	ldr	r2, [r2, #0]
 8013c62:	601a      	str	r2, [r3, #0]
 8013c64:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8013c66:	2b01      	cmp	r3, #1
 8013c68:	d90e      	bls.n	8013c88 <_tx_queue_receive+0x1ac>
 8013c6a:	e007      	b.n	8013c7c <_tx_queue_receive+0x1a0>
 8013c6c:	6d7a      	ldr	r2, [r7, #84]	; 0x54
 8013c6e:	1d13      	adds	r3, r2, #4
 8013c70:	657b      	str	r3, [r7, #84]	; 0x54
 8013c72:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 8013c74:	1d19      	adds	r1, r3, #4
 8013c76:	6539      	str	r1, [r7, #80]	; 0x50
 8013c78:	6812      	ldr	r2, [r2, #0]
 8013c7a:	601a      	str	r2, [r3, #0]
 8013c7c:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8013c7e:	3b01      	subs	r3, #1
 8013c80:	64fb      	str	r3, [r7, #76]	; 0x4c
 8013c82:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8013c84:	2b00      	cmp	r3, #0
 8013c86:	d1f1      	bne.n	8013c6c <_tx_queue_receive+0x190>

                /* Determine if we are at the end.  */
                if (source == queue_ptr -> tx_queue_end)
 8013c88:	68fb      	ldr	r3, [r7, #12]
 8013c8a:	69db      	ldr	r3, [r3, #28]
 8013c8c:	6d7a      	ldr	r2, [r7, #84]	; 0x54
 8013c8e:	429a      	cmp	r2, r3
 8013c90:	d102      	bne.n	8013c98 <_tx_queue_receive+0x1bc>
                {

                    /* Yes, wrap around to the beginning.  */
                    source =  queue_ptr -> tx_queue_start;
 8013c92:	68fb      	ldr	r3, [r7, #12]
 8013c94:	699b      	ldr	r3, [r3, #24]
 8013c96:	657b      	str	r3, [r7, #84]	; 0x54
                }

                /* Setup the queue read pointer.   */
                queue_ptr -> tx_queue_read =  source;
 8013c98:	68fb      	ldr	r3, [r7, #12]
 8013c9a:	6d7a      	ldr	r2, [r7, #84]	; 0x54
 8013c9c:	621a      	str	r2, [r3, #32]
  
                /* Disable preemption.  */
                _tx_thread_preempt_disable++;
 8013c9e:	4b70      	ldr	r3, [pc, #448]	; (8013e60 <_tx_queue_receive+0x384>)
 8013ca0:	681b      	ldr	r3, [r3, #0]
 8013ca2:	3301      	adds	r3, #1
 8013ca4:	4a6e      	ldr	r2, [pc, #440]	; (8013e60 <_tx_queue_receive+0x384>)
 8013ca6:	6013      	str	r3, [r2, #0]
                /* Disable interrupts again.  */
                TX_DISABLE
#endif

                /* Decrement the preemption disable variable.  */
                _tx_thread_preempt_disable--;
 8013ca8:	4b6d      	ldr	r3, [pc, #436]	; (8013e60 <_tx_queue_receive+0x384>)
 8013caa:	681b      	ldr	r3, [r3, #0]
 8013cac:	3b01      	subs	r3, #1
 8013cae:	4a6c      	ldr	r2, [pc, #432]	; (8013e60 <_tx_queue_receive+0x384>)
 8013cb0:	6013      	str	r3, [r2, #0]

                /* Setup source and destination pointers.  */
                source =       TX_VOID_TO_ULONG_POINTER_CONVERT(thread_ptr -> tx_thread_additional_suspend_info);
 8013cb2:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8013cb4:	6fdb      	ldr	r3, [r3, #124]	; 0x7c
 8013cb6:	657b      	str	r3, [r7, #84]	; 0x54
                destination =  queue_ptr -> tx_queue_write;
 8013cb8:	68fb      	ldr	r3, [r7, #12]
 8013cba:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8013cbc:	653b      	str	r3, [r7, #80]	; 0x50
                size =         queue_ptr -> tx_queue_message_size;
 8013cbe:	68fb      	ldr	r3, [r7, #12]
 8013cc0:	689b      	ldr	r3, [r3, #8]
 8013cc2:	64fb      	str	r3, [r7, #76]	; 0x4c

                /* Copy message. Note that the source and destination pointers are 
                   incremented by the macro.  */
                TX_QUEUE_MESSAGE_COPY(source, destination, size)
 8013cc4:	6d7a      	ldr	r2, [r7, #84]	; 0x54
 8013cc6:	1d13      	adds	r3, r2, #4
 8013cc8:	657b      	str	r3, [r7, #84]	; 0x54
 8013cca:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 8013ccc:	1d19      	adds	r1, r3, #4
 8013cce:	6539      	str	r1, [r7, #80]	; 0x50
 8013cd0:	6812      	ldr	r2, [r2, #0]
 8013cd2:	601a      	str	r2, [r3, #0]
 8013cd4:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8013cd6:	2b01      	cmp	r3, #1
 8013cd8:	d90e      	bls.n	8013cf8 <_tx_queue_receive+0x21c>
 8013cda:	e007      	b.n	8013cec <_tx_queue_receive+0x210>
 8013cdc:	6d7a      	ldr	r2, [r7, #84]	; 0x54
 8013cde:	1d13      	adds	r3, r2, #4
 8013ce0:	657b      	str	r3, [r7, #84]	; 0x54
 8013ce2:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 8013ce4:	1d19      	adds	r1, r3, #4
 8013ce6:	6539      	str	r1, [r7, #80]	; 0x50
 8013ce8:	6812      	ldr	r2, [r2, #0]
 8013cea:	601a      	str	r2, [r3, #0]
 8013cec:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8013cee:	3b01      	subs	r3, #1
 8013cf0:	64fb      	str	r3, [r7, #76]	; 0x4c
 8013cf2:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8013cf4:	2b00      	cmp	r3, #0
 8013cf6:	d1f1      	bne.n	8013cdc <_tx_queue_receive+0x200>

                /* Determine if we are at the end.  */
                if (destination == queue_ptr -> tx_queue_end)
 8013cf8:	68fb      	ldr	r3, [r7, #12]
 8013cfa:	69db      	ldr	r3, [r3, #28]
 8013cfc:	6d3a      	ldr	r2, [r7, #80]	; 0x50
 8013cfe:	429a      	cmp	r2, r3
 8013d00:	d102      	bne.n	8013d08 <_tx_queue_receive+0x22c>
                {
            
                    /* Yes, wrap around to the beginning.  */
                    destination =  queue_ptr -> tx_queue_start;
 8013d02:	68fb      	ldr	r3, [r7, #12]
 8013d04:	699b      	ldr	r3, [r3, #24]
 8013d06:	653b      	str	r3, [r7, #80]	; 0x50
                }

                /* Adjust the write pointer.  */
                queue_ptr -> tx_queue_write =  destination;
 8013d08:	68fb      	ldr	r3, [r7, #12]
 8013d0a:	6d3a      	ldr	r2, [r7, #80]	; 0x50
 8013d0c:	625a      	str	r2, [r3, #36]	; 0x24

                /* Pickup thread pointer.  */
                thread_ptr =  queue_ptr -> tx_queue_suspension_list;
 8013d0e:	68fb      	ldr	r3, [r7, #12]
 8013d10:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8013d12:	63fb      	str	r3, [r7, #60]	; 0x3c

                /* Message is now in the queue.  See if this is the only suspended thread 
                   on the list.  */
                suspended_count--;
 8013d14:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8013d16:	3b01      	subs	r3, #1
 8013d18:	643b      	str	r3, [r7, #64]	; 0x40
                if (suspended_count == TX_NO_SUSPENSIONS)
 8013d1a:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8013d1c:	2b00      	cmp	r3, #0
 8013d1e:	d103      	bne.n	8013d28 <_tx_queue_receive+0x24c>
                {

                  /* Yes, the only suspended thread.  */

                    /* Update the head pointer.  */
                    queue_ptr -> tx_queue_suspension_list =  TX_NULL;
 8013d20:	68fb      	ldr	r3, [r7, #12]
 8013d22:	2200      	movs	r2, #0
 8013d24:	629a      	str	r2, [r3, #40]	; 0x28
 8013d26:	e00e      	b.n	8013d46 <_tx_queue_receive+0x26a>
                {

                    /* At least one more thread is on the same expiration list.  */

                    /* Update the list head pointer.  */
                    next_thread =                            thread_ptr -> tx_thread_suspended_next;
 8013d28:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8013d2a:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 8013d2c:	63bb      	str	r3, [r7, #56]	; 0x38
                    queue_ptr -> tx_queue_suspension_list =  next_thread;
 8013d2e:	68fb      	ldr	r3, [r7, #12]
 8013d30:	6bba      	ldr	r2, [r7, #56]	; 0x38
 8013d32:	629a      	str	r2, [r3, #40]	; 0x28

                    /* Update the links of the adjacent threads.  */
                    previous_thread =                               thread_ptr -> tx_thread_suspended_previous;
 8013d34:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8013d36:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 8013d38:	637b      	str	r3, [r7, #52]	; 0x34
                    next_thread -> tx_thread_suspended_previous =   previous_thread;
 8013d3a:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8013d3c:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 8013d3e:	675a      	str	r2, [r3, #116]	; 0x74
                    previous_thread -> tx_thread_suspended_next =   next_thread;
 8013d40:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8013d42:	6bba      	ldr	r2, [r7, #56]	; 0x38
 8013d44:	671a      	str	r2, [r3, #112]	; 0x70
                }

                /* Decrement the suspension count.  */
                queue_ptr -> tx_queue_suspended_count =  suspended_count;
 8013d46:	68fb      	ldr	r3, [r7, #12]
 8013d48:	6c3a      	ldr	r2, [r7, #64]	; 0x40
 8013d4a:	62da      	str	r2, [r3, #44]	; 0x2c

                /* Prepare for resumption of the first thread.  */

                /* Clear cleanup routine to avoid timeout.  */
                thread_ptr -> tx_thread_suspend_cleanup =  TX_NULL;
 8013d4c:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8013d4e:	2200      	movs	r2, #0
 8013d50:	669a      	str	r2, [r3, #104]	; 0x68

                /* Put return status into the thread control block.  */
                thread_ptr -> tx_thread_suspend_status =  TX_SUCCESS;
 8013d52:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8013d54:	2200      	movs	r2, #0
 8013d56:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84
                /* Restore interrupts.  */
                TX_RESTORE
#else

                /* Temporarily disable preemption.  */
                _tx_thread_preempt_disable++;
 8013d5a:	4b41      	ldr	r3, [pc, #260]	; (8013e60 <_tx_queue_receive+0x384>)
 8013d5c:	681b      	ldr	r3, [r3, #0]
 8013d5e:	3301      	adds	r3, #1
 8013d60:	4a3f      	ldr	r2, [pc, #252]	; (8013e60 <_tx_queue_receive+0x384>)
 8013d62:	6013      	str	r3, [r2, #0]
 8013d64:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8013d66:	623b      	str	r3, [r7, #32]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 8013d68:	6a3b      	ldr	r3, [r7, #32]
 8013d6a:	f383 8810 	msr	PRIMASK, r3
}
 8013d6e:	bf00      	nop

                /* Restore interrupts.  */
                TX_RESTORE

                /* Resume thread.  */
                _tx_thread_system_resume(thread_ptr);
 8013d70:	6bf8      	ldr	r0, [r7, #60]	; 0x3c
 8013d72:	f000 ffd9 	bl	8014d28 <_tx_thread_system_resume>
 8013d76:	e06d      	b.n	8013e54 <_tx_queue_receive+0x378>
            }
        }
    }

    /* Determine if the request specifies suspension.  */
    else if (wait_option != TX_NO_WAIT)
 8013d78:	687b      	ldr	r3, [r7, #4]
 8013d7a:	2b00      	cmp	r3, #0
 8013d7c:	d062      	beq.n	8013e44 <_tx_queue_receive+0x368>
    {

        /* Determine if the preempt disable flag is non-zero.  */
        if (_tx_thread_preempt_disable != ((UINT) 0))
 8013d7e:	4b38      	ldr	r3, [pc, #224]	; (8013e60 <_tx_queue_receive+0x384>)
 8013d80:	681b      	ldr	r3, [r3, #0]
 8013d82:	2b00      	cmp	r3, #0
 8013d84:	d008      	beq.n	8013d98 <_tx_queue_receive+0x2bc>
 8013d86:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8013d88:	61fb      	str	r3, [r7, #28]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 8013d8a:	69fb      	ldr	r3, [r7, #28]
 8013d8c:	f383 8810 	msr	PRIMASK, r3
}
 8013d90:	bf00      	nop

            /* Restore interrupts.  */
            TX_RESTORE
           
            /* Suspension is not allowed if the preempt disable flag is non-zero at this point - return error completion.  */
            status =  TX_QUEUE_EMPTY;
 8013d92:	230a      	movs	r3, #10
 8013d94:	64bb      	str	r3, [r7, #72]	; 0x48
 8013d96:	e05d      	b.n	8013e54 <_tx_queue_receive+0x378>
            /* Increment the number of empty suspensions on this queue.  */
            queue_ptr -> tx_queue_performance_empty_suspension_count++;
#endif
            
            /* Pickup thread pointer.  */
            TX_THREAD_GET_CURRENT(thread_ptr)
 8013d98:	4b32      	ldr	r3, [pc, #200]	; (8013e64 <_tx_queue_receive+0x388>)
 8013d9a:	681b      	ldr	r3, [r3, #0]
 8013d9c:	63fb      	str	r3, [r7, #60]	; 0x3c

            /* Setup cleanup routine pointer.  */
            thread_ptr -> tx_thread_suspend_cleanup =  &(_tx_queue_cleanup);
 8013d9e:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8013da0:	4a31      	ldr	r2, [pc, #196]	; (8013e68 <_tx_queue_receive+0x38c>)
 8013da2:	669a      	str	r2, [r3, #104]	; 0x68

            /* Setup cleanup information, i.e. this queue control
               block and the source pointer.  */
            thread_ptr -> tx_thread_suspend_control_block =    (VOID *) queue_ptr;
 8013da4:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8013da6:	68fa      	ldr	r2, [r7, #12]
 8013da8:	66da      	str	r2, [r3, #108]	; 0x6c
            thread_ptr -> tx_thread_additional_suspend_info =  (VOID *) destination_ptr;
 8013daa:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8013dac:	68ba      	ldr	r2, [r7, #8]
 8013dae:	67da      	str	r2, [r3, #124]	; 0x7c
            thread_ptr -> tx_thread_suspend_option =           TX_FALSE;
 8013db0:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8013db2:	2200      	movs	r2, #0
 8013db4:	f8c3 2080 	str.w	r2, [r3, #128]	; 0x80

#ifndef TX_NOT_INTERRUPTABLE

            /* Increment the suspension sequence number, which is used to identify
               this suspension event.  */
            thread_ptr -> tx_thread_suspension_sequence++;
 8013db8:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8013dba:	f8d3 30ac 	ldr.w	r3, [r3, #172]	; 0xac
 8013dbe:	1c5a      	adds	r2, r3, #1
 8013dc0:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8013dc2:	f8c3 20ac 	str.w	r2, [r3, #172]	; 0xac
#endif

            /* Setup suspension list.  */
            if (suspended_count == TX_NO_SUSPENSIONS)
 8013dc6:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8013dc8:	2b00      	cmp	r3, #0
 8013dca:	d109      	bne.n	8013de0 <_tx_queue_receive+0x304>
            {

                /* No other threads are suspended.  Setup the head pointer and
                   just setup this threads pointers to itself.  */
                queue_ptr -> tx_queue_suspension_list =         thread_ptr;
 8013dcc:	68fb      	ldr	r3, [r7, #12]
 8013dce:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 8013dd0:	629a      	str	r2, [r3, #40]	; 0x28
                thread_ptr -> tx_thread_suspended_next =        thread_ptr;
 8013dd2:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8013dd4:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 8013dd6:	671a      	str	r2, [r3, #112]	; 0x70
                thread_ptr -> tx_thread_suspended_previous =    thread_ptr;
 8013dd8:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8013dda:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 8013ddc:	675a      	str	r2, [r3, #116]	; 0x74
 8013dde:	e011      	b.n	8013e04 <_tx_queue_receive+0x328>
            }
            else
            {

                /* This list is not NULL, add current thread to the end. */
                next_thread =                                   queue_ptr -> tx_queue_suspension_list;
 8013de0:	68fb      	ldr	r3, [r7, #12]
 8013de2:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8013de4:	63bb      	str	r3, [r7, #56]	; 0x38
                thread_ptr -> tx_thread_suspended_next =        next_thread;
 8013de6:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8013de8:	6bba      	ldr	r2, [r7, #56]	; 0x38
 8013dea:	671a      	str	r2, [r3, #112]	; 0x70
                previous_thread =                               next_thread -> tx_thread_suspended_previous;
 8013dec:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8013dee:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 8013df0:	637b      	str	r3, [r7, #52]	; 0x34
                thread_ptr -> tx_thread_suspended_previous =    previous_thread;
 8013df2:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8013df4:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 8013df6:	675a      	str	r2, [r3, #116]	; 0x74
                previous_thread -> tx_thread_suspended_next =   thread_ptr;
 8013df8:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8013dfa:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 8013dfc:	671a      	str	r2, [r3, #112]	; 0x70
                next_thread -> tx_thread_suspended_previous =   thread_ptr;
 8013dfe:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8013e00:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 8013e02:	675a      	str	r2, [r3, #116]	; 0x74
            }

            /* Increment the suspended thread count.  */
            queue_ptr -> tx_queue_suspended_count =  suspended_count + ((UINT) 1);
 8013e04:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8013e06:	1c5a      	adds	r2, r3, #1
 8013e08:	68fb      	ldr	r3, [r7, #12]
 8013e0a:	62da      	str	r2, [r3, #44]	; 0x2c

            /* Set the state to suspended.  */
            thread_ptr -> tx_thread_state =    TX_QUEUE_SUSP;
 8013e0c:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8013e0e:	2205      	movs	r2, #5
 8013e10:	631a      	str	r2, [r3, #48]	; 0x30
            /* Restore interrupts.  */
            TX_RESTORE
#else

            /* Set the suspending flag.  */
            thread_ptr -> tx_thread_suspending =  TX_TRUE;
 8013e12:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8013e14:	2201      	movs	r2, #1
 8013e16:	639a      	str	r2, [r3, #56]	; 0x38

            /* Setup the timeout period.  */
            thread_ptr -> tx_thread_timer.tx_timer_internal_remaining_ticks =  wait_option;
 8013e18:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8013e1a:	687a      	ldr	r2, [r7, #4]
 8013e1c:	64da      	str	r2, [r3, #76]	; 0x4c

            /* Temporarily disable preemption.  */
            _tx_thread_preempt_disable++;
 8013e1e:	4b10      	ldr	r3, [pc, #64]	; (8013e60 <_tx_queue_receive+0x384>)
 8013e20:	681b      	ldr	r3, [r3, #0]
 8013e22:	3301      	adds	r3, #1
 8013e24:	4a0e      	ldr	r2, [pc, #56]	; (8013e60 <_tx_queue_receive+0x384>)
 8013e26:	6013      	str	r3, [r2, #0]
 8013e28:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8013e2a:	61bb      	str	r3, [r7, #24]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 8013e2c:	69bb      	ldr	r3, [r7, #24]
 8013e2e:	f383 8810 	msr	PRIMASK, r3
}
 8013e32:	bf00      	nop

            /* Restore interrupts.  */
            TX_RESTORE

            /* Call actual thread suspension routine.  */
            _tx_thread_system_suspend(thread_ptr);
 8013e34:	6bf8      	ldr	r0, [r7, #60]	; 0x3c
 8013e36:	f001 f877 	bl	8014f28 <_tx_thread_system_suspend>
#endif

            /* Return the completion status.  */
            status =  thread_ptr -> tx_thread_suspend_status;
 8013e3a:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8013e3c:	f8d3 3084 	ldr.w	r3, [r3, #132]	; 0x84
 8013e40:	64bb      	str	r3, [r7, #72]	; 0x48
 8013e42:	e007      	b.n	8013e54 <_tx_queue_receive+0x378>
 8013e44:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8013e46:	617b      	str	r3, [r7, #20]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 8013e48:	697b      	ldr	r3, [r7, #20]
 8013e4a:	f383 8810 	msr	PRIMASK, r3
}
 8013e4e:	bf00      	nop

        /* Restore interrupts.  */
        TX_RESTORE
           
        /* Immediate return, return error completion.  */
        status =  TX_QUEUE_EMPTY;
 8013e50:	230a      	movs	r3, #10
 8013e52:	64bb      	str	r3, [r7, #72]	; 0x48
    }

    /* Return completion status.  */
    return(status);
 8013e54:	6cbb      	ldr	r3, [r7, #72]	; 0x48
}
 8013e56:	4618      	mov	r0, r3
 8013e58:	3758      	adds	r7, #88	; 0x58
 8013e5a:	46bd      	mov	sp, r7
 8013e5c:	bd80      	pop	{r7, pc}
 8013e5e:	bf00      	nop
 8013e60:	24031c5c 	.word	0x24031c5c
 8013e64:	24031bc4 	.word	0x24031bc4
 8013e68:	080136b1 	.word	0x080136b1

08013e6c <_tx_queue_send>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
UINT  _tx_queue_send(TX_QUEUE *queue_ptr, VOID *source_ptr, ULONG wait_option)
{
 8013e6c:	b580      	push	{r7, lr}
 8013e6e:	b094      	sub	sp, #80	; 0x50
 8013e70:	af00      	add	r7, sp, #0
 8013e72:	60f8      	str	r0, [r7, #12]
 8013e74:	60b9      	str	r1, [r7, #8]
 8013e76:	607a      	str	r2, [r7, #4]
VOID            (*queue_send_notify)(struct TX_QUEUE_STRUCT *notify_queue_ptr);
#endif


    /* Default the status to TX_SUCCESS.  */
    status =  TX_SUCCESS;
 8013e78:	2300      	movs	r3, #0
 8013e7a:	643b      	str	r3, [r7, #64]	; 0x40
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 8013e7c:	f3ef 8310 	mrs	r3, PRIMASK
 8013e80:	62bb      	str	r3, [r7, #40]	; 0x28
    return(posture);
 8013e82:	6abb      	ldr	r3, [r7, #40]	; 0x28
    int_posture = __get_interrupt_posture();
 8013e84:	627b      	str	r3, [r7, #36]	; 0x24
    __asm__ volatile ("CPSID i" : : : "memory");
 8013e86:	b672      	cpsid	i
    return(int_posture);
 8013e88:	6a7b      	ldr	r3, [r7, #36]	; 0x24

    /* Disable interrupts to place message in the queue.  */
    TX_DISABLE
 8013e8a:	63fb      	str	r3, [r7, #60]	; 0x3c

    /* Log this kernel call.  */
    TX_EL_QUEUE_SEND_INSERT

    /* Pickup the thread suspension count.  */
    suspended_count =  queue_ptr -> tx_queue_suspended_count;
 8013e8c:	68fb      	ldr	r3, [r7, #12]
 8013e8e:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8013e90:	63bb      	str	r3, [r7, #56]	; 0x38

    /* Determine if there is room in the queue.  */
    if (queue_ptr -> tx_queue_available_storage != TX_NO_MESSAGES)
 8013e92:	68fb      	ldr	r3, [r7, #12]
 8013e94:	695b      	ldr	r3, [r3, #20]
 8013e96:	2b00      	cmp	r3, #0
 8013e98:	f000 809b 	beq.w	8013fd2 <_tx_queue_send+0x166>
    {

        /* There is room for the message in the queue.  */

        /* Determine if there are suspended on this queue.  */
        if (suspended_count == TX_NO_SUSPENSIONS)
 8013e9c:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8013e9e:	2b00      	cmp	r3, #0
 8013ea0:	d13c      	bne.n	8013f1c <_tx_queue_send+0xb0>
        {
        
            /* No suspended threads, simply place the message in the queue.  */
            
            /* Reduce the amount of available storage.  */
            queue_ptr -> tx_queue_available_storage--;
 8013ea2:	68fb      	ldr	r3, [r7, #12]
 8013ea4:	695b      	ldr	r3, [r3, #20]
 8013ea6:	1e5a      	subs	r2, r3, #1
 8013ea8:	68fb      	ldr	r3, [r7, #12]
 8013eaa:	615a      	str	r2, [r3, #20]

            /* Increase the enqueued count.  */
            queue_ptr -> tx_queue_enqueued++;
 8013eac:	68fb      	ldr	r3, [r7, #12]
 8013eae:	691b      	ldr	r3, [r3, #16]
 8013eb0:	1c5a      	adds	r2, r3, #1
 8013eb2:	68fb      	ldr	r3, [r7, #12]
 8013eb4:	611a      	str	r2, [r3, #16]

            /* Setup source and destination pointers.  */
            source =       TX_VOID_TO_ULONG_POINTER_CONVERT(source_ptr);
 8013eb6:	68bb      	ldr	r3, [r7, #8]
 8013eb8:	64fb      	str	r3, [r7, #76]	; 0x4c
            destination =  queue_ptr -> tx_queue_write;
 8013eba:	68fb      	ldr	r3, [r7, #12]
 8013ebc:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8013ebe:	64bb      	str	r3, [r7, #72]	; 0x48
            size =         queue_ptr -> tx_queue_message_size;
 8013ec0:	68fb      	ldr	r3, [r7, #12]
 8013ec2:	689b      	ldr	r3, [r3, #8]
 8013ec4:	647b      	str	r3, [r7, #68]	; 0x44

            /* Copy message. Note that the source and destination pointers are 
               incremented by the macro.  */
            TX_QUEUE_MESSAGE_COPY(source, destination, size)
 8013ec6:	6cfa      	ldr	r2, [r7, #76]	; 0x4c
 8013ec8:	1d13      	adds	r3, r2, #4
 8013eca:	64fb      	str	r3, [r7, #76]	; 0x4c
 8013ecc:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 8013ece:	1d19      	adds	r1, r3, #4
 8013ed0:	64b9      	str	r1, [r7, #72]	; 0x48
 8013ed2:	6812      	ldr	r2, [r2, #0]
 8013ed4:	601a      	str	r2, [r3, #0]
 8013ed6:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8013ed8:	2b01      	cmp	r3, #1
 8013eda:	d90e      	bls.n	8013efa <_tx_queue_send+0x8e>
 8013edc:	e007      	b.n	8013eee <_tx_queue_send+0x82>
 8013ede:	6cfa      	ldr	r2, [r7, #76]	; 0x4c
 8013ee0:	1d13      	adds	r3, r2, #4
 8013ee2:	64fb      	str	r3, [r7, #76]	; 0x4c
 8013ee4:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 8013ee6:	1d19      	adds	r1, r3, #4
 8013ee8:	64b9      	str	r1, [r7, #72]	; 0x48
 8013eea:	6812      	ldr	r2, [r2, #0]
 8013eec:	601a      	str	r2, [r3, #0]
 8013eee:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8013ef0:	3b01      	subs	r3, #1
 8013ef2:	647b      	str	r3, [r7, #68]	; 0x44
 8013ef4:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8013ef6:	2b00      	cmp	r3, #0
 8013ef8:	d1f1      	bne.n	8013ede <_tx_queue_send+0x72>

            /* Determine if we are at the end.  */
            if (destination == queue_ptr -> tx_queue_end)
 8013efa:	68fb      	ldr	r3, [r7, #12]
 8013efc:	69db      	ldr	r3, [r3, #28]
 8013efe:	6cba      	ldr	r2, [r7, #72]	; 0x48
 8013f00:	429a      	cmp	r2, r3
 8013f02:	d102      	bne.n	8013f0a <_tx_queue_send+0x9e>
            {

                /* Yes, wrap around to the beginning.  */
                destination =  queue_ptr -> tx_queue_start;
 8013f04:	68fb      	ldr	r3, [r7, #12]
 8013f06:	699b      	ldr	r3, [r3, #24]
 8013f08:	64bb      	str	r3, [r7, #72]	; 0x48
            }

            /* Adjust the write pointer.  */
            queue_ptr -> tx_queue_write =  destination;
 8013f0a:	68fb      	ldr	r3, [r7, #12]
 8013f0c:	6cba      	ldr	r2, [r7, #72]	; 0x48
 8013f0e:	625a      	str	r2, [r3, #36]	; 0x24
 8013f10:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8013f12:	623b      	str	r3, [r7, #32]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 8013f14:	6a3b      	ldr	r3, [r7, #32]
 8013f16:	f383 8810 	msr	PRIMASK, r3
}
 8013f1a:	e0c8      	b.n	80140ae <_tx_queue_send+0x242>
            /* There is a thread suspended on an empty queue. Simply 
               copy the message to the suspended thread's destination
               pointer.  */

            /* Pickup the head of the suspension list.  */
            thread_ptr =  queue_ptr -> tx_queue_suspension_list;
 8013f1c:	68fb      	ldr	r3, [r7, #12]
 8013f1e:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8013f20:	637b      	str	r3, [r7, #52]	; 0x34

            /* See if this is the only suspended thread on the list.  */
            suspended_count--;
 8013f22:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8013f24:	3b01      	subs	r3, #1
 8013f26:	63bb      	str	r3, [r7, #56]	; 0x38
            if (suspended_count == TX_NO_SUSPENSIONS)
 8013f28:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8013f2a:	2b00      	cmp	r3, #0
 8013f2c:	d103      	bne.n	8013f36 <_tx_queue_send+0xca>
            {

                /* Yes, the only suspended thread.  */

                /* Update the head pointer.  */
                queue_ptr -> tx_queue_suspension_list =  TX_NULL;
 8013f2e:	68fb      	ldr	r3, [r7, #12]
 8013f30:	2200      	movs	r2, #0
 8013f32:	629a      	str	r2, [r3, #40]	; 0x28
 8013f34:	e012      	b.n	8013f5c <_tx_queue_send+0xf0>
            {

                /* At least one more thread is on the same expiration list.  */

                /* Update the list head pointer.  */
                queue_ptr -> tx_queue_suspension_list =  thread_ptr -> tx_thread_suspended_next;
 8013f36:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8013f38:	6f1a      	ldr	r2, [r3, #112]	; 0x70
 8013f3a:	68fb      	ldr	r3, [r7, #12]
 8013f3c:	629a      	str	r2, [r3, #40]	; 0x28

                /* Update the links of the adjacent threads.  */
                next_thread =                            thread_ptr -> tx_thread_suspended_next;
 8013f3e:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8013f40:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 8013f42:	633b      	str	r3, [r7, #48]	; 0x30
                queue_ptr -> tx_queue_suspension_list =  next_thread;
 8013f44:	68fb      	ldr	r3, [r7, #12]
 8013f46:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 8013f48:	629a      	str	r2, [r3, #40]	; 0x28

                /* Update the links of the adjacent threads.  */
                previous_thread =                               thread_ptr -> tx_thread_suspended_previous;
 8013f4a:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8013f4c:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 8013f4e:	62fb      	str	r3, [r7, #44]	; 0x2c
                next_thread -> tx_thread_suspended_previous =   previous_thread;
 8013f50:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8013f52:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 8013f54:	675a      	str	r2, [r3, #116]	; 0x74
                previous_thread -> tx_thread_suspended_next =   next_thread;
 8013f56:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8013f58:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 8013f5a:	671a      	str	r2, [r3, #112]	; 0x70
            }

            /* Decrement the suspension count.  */
            queue_ptr -> tx_queue_suspended_count =  suspended_count;
 8013f5c:	68fb      	ldr	r3, [r7, #12]
 8013f5e:	6bba      	ldr	r2, [r7, #56]	; 0x38
 8013f60:	62da      	str	r2, [r3, #44]	; 0x2c

            /* Prepare for resumption of the thread.  */

            /* Clear cleanup routine to avoid timeout.  */
            thread_ptr -> tx_thread_suspend_cleanup =  TX_NULL;
 8013f62:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8013f64:	2200      	movs	r2, #0
 8013f66:	669a      	str	r2, [r3, #104]	; 0x68

            /* Setup source and destination pointers.  */
            source =       TX_VOID_TO_ULONG_POINTER_CONVERT(source_ptr);
 8013f68:	68bb      	ldr	r3, [r7, #8]
 8013f6a:	64fb      	str	r3, [r7, #76]	; 0x4c
            destination =  TX_VOID_TO_ULONG_POINTER_CONVERT(thread_ptr -> tx_thread_additional_suspend_info);
 8013f6c:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8013f6e:	6fdb      	ldr	r3, [r3, #124]	; 0x7c
 8013f70:	64bb      	str	r3, [r7, #72]	; 0x48
            size =         queue_ptr -> tx_queue_message_size;
 8013f72:	68fb      	ldr	r3, [r7, #12]
 8013f74:	689b      	ldr	r3, [r3, #8]
 8013f76:	647b      	str	r3, [r7, #68]	; 0x44

            /* Copy message. Note that the source and destination pointers are 
               incremented by the macro.  */
            TX_QUEUE_MESSAGE_COPY(source, destination, size)
 8013f78:	6cfa      	ldr	r2, [r7, #76]	; 0x4c
 8013f7a:	1d13      	adds	r3, r2, #4
 8013f7c:	64fb      	str	r3, [r7, #76]	; 0x4c
 8013f7e:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 8013f80:	1d19      	adds	r1, r3, #4
 8013f82:	64b9      	str	r1, [r7, #72]	; 0x48
 8013f84:	6812      	ldr	r2, [r2, #0]
 8013f86:	601a      	str	r2, [r3, #0]
 8013f88:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8013f8a:	2b01      	cmp	r3, #1
 8013f8c:	d90e      	bls.n	8013fac <_tx_queue_send+0x140>
 8013f8e:	e007      	b.n	8013fa0 <_tx_queue_send+0x134>
 8013f90:	6cfa      	ldr	r2, [r7, #76]	; 0x4c
 8013f92:	1d13      	adds	r3, r2, #4
 8013f94:	64fb      	str	r3, [r7, #76]	; 0x4c
 8013f96:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 8013f98:	1d19      	adds	r1, r3, #4
 8013f9a:	64b9      	str	r1, [r7, #72]	; 0x48
 8013f9c:	6812      	ldr	r2, [r2, #0]
 8013f9e:	601a      	str	r2, [r3, #0]
 8013fa0:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8013fa2:	3b01      	subs	r3, #1
 8013fa4:	647b      	str	r3, [r7, #68]	; 0x44
 8013fa6:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8013fa8:	2b00      	cmp	r3, #0
 8013faa:	d1f1      	bne.n	8013f90 <_tx_queue_send+0x124>

            /* Put return status into the thread control block.  */
            thread_ptr -> tx_thread_suspend_status =  TX_SUCCESS;
 8013fac:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8013fae:	2200      	movs	r2, #0
 8013fb0:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84
            /* Restore interrupts.  */
            TX_RESTORE
#else

            /* Temporarily disable preemption.  */
            _tx_thread_preempt_disable++;
 8013fb4:	4b40      	ldr	r3, [pc, #256]	; (80140b8 <_tx_queue_send+0x24c>)
 8013fb6:	681b      	ldr	r3, [r3, #0]
 8013fb8:	3301      	adds	r3, #1
 8013fba:	4a3f      	ldr	r2, [pc, #252]	; (80140b8 <_tx_queue_send+0x24c>)
 8013fbc:	6013      	str	r3, [r2, #0]
 8013fbe:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8013fc0:	61fb      	str	r3, [r7, #28]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 8013fc2:	69fb      	ldr	r3, [r7, #28]
 8013fc4:	f383 8810 	msr	PRIMASK, r3
}
 8013fc8:	bf00      	nop

            /* Restore interrupts.  */
            TX_RESTORE

            /* Resume thread.  */
            _tx_thread_system_resume(thread_ptr);
 8013fca:	6b78      	ldr	r0, [r7, #52]	; 0x34
 8013fcc:	f000 feac 	bl	8014d28 <_tx_thread_system_resume>
 8013fd0:	e06d      	b.n	80140ae <_tx_queue_send+0x242>
#endif
        }
    }
    
    /* At this point, the queue is full. Determine if suspension is requested.  */
    else if (wait_option != TX_NO_WAIT)
 8013fd2:	687b      	ldr	r3, [r7, #4]
 8013fd4:	2b00      	cmp	r3, #0
 8013fd6:	d062      	beq.n	801409e <_tx_queue_send+0x232>
    {

        /* Determine if the preempt disable flag is non-zero.  */
        if (_tx_thread_preempt_disable != ((UINT) 0))
 8013fd8:	4b37      	ldr	r3, [pc, #220]	; (80140b8 <_tx_queue_send+0x24c>)
 8013fda:	681b      	ldr	r3, [r3, #0]
 8013fdc:	2b00      	cmp	r3, #0
 8013fde:	d008      	beq.n	8013ff2 <_tx_queue_send+0x186>
 8013fe0:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8013fe2:	61bb      	str	r3, [r7, #24]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 8013fe4:	69bb      	ldr	r3, [r7, #24]
 8013fe6:	f383 8810 	msr	PRIMASK, r3
}
 8013fea:	bf00      	nop

            /* Restore interrupts.  */
            TX_RESTORE

            /* Suspension is not allowed if the preempt disable flag is non-zero at this point - return error completion.  */
            status =  TX_QUEUE_FULL;
 8013fec:	230b      	movs	r3, #11
 8013fee:	643b      	str	r3, [r7, #64]	; 0x40
 8013ff0:	e05d      	b.n	80140ae <_tx_queue_send+0x242>
            /* Increment the number of full suspensions on this queue.  */
            queue_ptr -> tx_queue_performance_full_suspension_count++;
#endif
            
            /* Pickup thread pointer.  */
            TX_THREAD_GET_CURRENT(thread_ptr)
 8013ff2:	4b32      	ldr	r3, [pc, #200]	; (80140bc <_tx_queue_send+0x250>)
 8013ff4:	681b      	ldr	r3, [r3, #0]
 8013ff6:	637b      	str	r3, [r7, #52]	; 0x34

            /* Setup cleanup routine pointer.  */
            thread_ptr -> tx_thread_suspend_cleanup =  &(_tx_queue_cleanup);
 8013ff8:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8013ffa:	4a31      	ldr	r2, [pc, #196]	; (80140c0 <_tx_queue_send+0x254>)
 8013ffc:	669a      	str	r2, [r3, #104]	; 0x68

            /* Setup cleanup information, i.e. this queue control
               block and the source pointer.  */
            thread_ptr -> tx_thread_suspend_control_block =    (VOID *) queue_ptr;
 8013ffe:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8014000:	68fa      	ldr	r2, [r7, #12]
 8014002:	66da      	str	r2, [r3, #108]	; 0x6c
            thread_ptr -> tx_thread_additional_suspend_info =  (VOID *) source_ptr;
 8014004:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8014006:	68ba      	ldr	r2, [r7, #8]
 8014008:	67da      	str	r2, [r3, #124]	; 0x7c
            thread_ptr -> tx_thread_suspend_option =           TX_FALSE;
 801400a:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 801400c:	2200      	movs	r2, #0
 801400e:	f8c3 2080 	str.w	r2, [r3, #128]	; 0x80

#ifndef TX_NOT_INTERRUPTABLE

            /* Increment the suspension sequence number, which is used to identify
               this suspension event.  */
            thread_ptr -> tx_thread_suspension_sequence++;
 8014012:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8014014:	f8d3 30ac 	ldr.w	r3, [r3, #172]	; 0xac
 8014018:	1c5a      	adds	r2, r3, #1
 801401a:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 801401c:	f8c3 20ac 	str.w	r2, [r3, #172]	; 0xac
#endif

            /* Setup suspension list.  */
            if (suspended_count == TX_NO_SUSPENSIONS)
 8014020:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8014022:	2b00      	cmp	r3, #0
 8014024:	d109      	bne.n	801403a <_tx_queue_send+0x1ce>
            {

                /* No other threads are suspended.  Setup the head pointer and
                   just setup this threads pointers to itself.  */
                queue_ptr -> tx_queue_suspension_list =         thread_ptr;
 8014026:	68fb      	ldr	r3, [r7, #12]
 8014028:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 801402a:	629a      	str	r2, [r3, #40]	; 0x28
                thread_ptr -> tx_thread_suspended_next =        thread_ptr;
 801402c:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 801402e:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 8014030:	671a      	str	r2, [r3, #112]	; 0x70
                thread_ptr -> tx_thread_suspended_previous =    thread_ptr;
 8014032:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8014034:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 8014036:	675a      	str	r2, [r3, #116]	; 0x74
 8014038:	e011      	b.n	801405e <_tx_queue_send+0x1f2>
            }
            else
            {

                /* This list is not NULL, add current thread to the end. */
                next_thread =                                   queue_ptr -> tx_queue_suspension_list;
 801403a:	68fb      	ldr	r3, [r7, #12]
 801403c:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 801403e:	633b      	str	r3, [r7, #48]	; 0x30
                thread_ptr -> tx_thread_suspended_next =        next_thread;
 8014040:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8014042:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 8014044:	671a      	str	r2, [r3, #112]	; 0x70
                previous_thread =                               next_thread -> tx_thread_suspended_previous;
 8014046:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8014048:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 801404a:	62fb      	str	r3, [r7, #44]	; 0x2c
                thread_ptr -> tx_thread_suspended_previous =    previous_thread;
 801404c:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 801404e:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 8014050:	675a      	str	r2, [r3, #116]	; 0x74
                previous_thread -> tx_thread_suspended_next =   thread_ptr;
 8014052:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8014054:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 8014056:	671a      	str	r2, [r3, #112]	; 0x70
                next_thread -> tx_thread_suspended_previous =   thread_ptr;
 8014058:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801405a:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 801405c:	675a      	str	r2, [r3, #116]	; 0x74
            }

            /* Increment the suspended thread count.  */
            queue_ptr -> tx_queue_suspended_count =  suspended_count + ((UINT) 1);
 801405e:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8014060:	1c5a      	adds	r2, r3, #1
 8014062:	68fb      	ldr	r3, [r7, #12]
 8014064:	62da      	str	r2, [r3, #44]	; 0x2c

            /* Set the state to suspended.  */
            thread_ptr -> tx_thread_state =    TX_QUEUE_SUSP;
 8014066:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8014068:	2205      	movs	r2, #5
 801406a:	631a      	str	r2, [r3, #48]	; 0x30
            /* Restore interrupts.  */
            TX_RESTORE
#else

            /* Set the suspending flag.  */
            thread_ptr -> tx_thread_suspending =  TX_TRUE;
 801406c:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 801406e:	2201      	movs	r2, #1
 8014070:	639a      	str	r2, [r3, #56]	; 0x38

            /* Setup the timeout period.  */
            thread_ptr -> tx_thread_timer.tx_timer_internal_remaining_ticks =  wait_option;
 8014072:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8014074:	687a      	ldr	r2, [r7, #4]
 8014076:	64da      	str	r2, [r3, #76]	; 0x4c

            /* Temporarily disable preemption.  */
            _tx_thread_preempt_disable++;
 8014078:	4b0f      	ldr	r3, [pc, #60]	; (80140b8 <_tx_queue_send+0x24c>)
 801407a:	681b      	ldr	r3, [r3, #0]
 801407c:	3301      	adds	r3, #1
 801407e:	4a0e      	ldr	r2, [pc, #56]	; (80140b8 <_tx_queue_send+0x24c>)
 8014080:	6013      	str	r3, [r2, #0]
 8014082:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8014084:	617b      	str	r3, [r7, #20]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 8014086:	697b      	ldr	r3, [r7, #20]
 8014088:	f383 8810 	msr	PRIMASK, r3
}
 801408c:	bf00      	nop

            /* Restore interrupts.  */
            TX_RESTORE

            /* Call actual thread suspension routine.  */
            _tx_thread_system_suspend(thread_ptr);
 801408e:	6b78      	ldr	r0, [r7, #52]	; 0x34
 8014090:	f000 ff4a 	bl	8014f28 <_tx_thread_system_suspend>
                }
            }
#endif

            /* Return the completion status.  */
            status =  thread_ptr -> tx_thread_suspend_status;
 8014094:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8014096:	f8d3 3084 	ldr.w	r3, [r3, #132]	; 0x84
 801409a:	643b      	str	r3, [r7, #64]	; 0x40
 801409c:	e007      	b.n	80140ae <_tx_queue_send+0x242>
 801409e:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 80140a0:	613b      	str	r3, [r7, #16]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 80140a2:	693b      	ldr	r3, [r7, #16]
 80140a4:	f383 8810 	msr	PRIMASK, r3
}
 80140a8:	bf00      	nop

        /* Restore interrupts.  */
        TX_RESTORE

        /* Return error completion.  */
        status =  TX_QUEUE_FULL;
 80140aa:	230b      	movs	r3, #11
 80140ac:	643b      	str	r3, [r7, #64]	; 0x40
    }

    /* Return completion status.  */
    return(status);
 80140ae:	6c3b      	ldr	r3, [r7, #64]	; 0x40
}
 80140b0:	4618      	mov	r0, r3
 80140b2:	3750      	adds	r7, #80	; 0x50
 80140b4:	46bd      	mov	sp, r7
 80140b6:	bd80      	pop	{r7, pc}
 80140b8:	24031c5c 	.word	0x24031c5c
 80140bc:	24031bc4 	.word	0x24031bc4
 80140c0:	080136b1 	.word	0x080136b1

080140c4 <_tx_semaphore_cleanup>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
VOID  _tx_semaphore_cleanup(TX_THREAD *thread_ptr, ULONG suspension_sequence)
{
 80140c4:	b580      	push	{r7, lr}
 80140c6:	b08e      	sub	sp, #56	; 0x38
 80140c8:	af00      	add	r7, sp, #0
 80140ca:	6078      	str	r0, [r7, #4]
 80140cc:	6039      	str	r1, [r7, #0]
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 80140ce:	f3ef 8310 	mrs	r3, PRIMASK
 80140d2:	623b      	str	r3, [r7, #32]
    return(posture);
 80140d4:	6a3b      	ldr	r3, [r7, #32]
    int_posture = __get_interrupt_posture();
 80140d6:	61fb      	str	r3, [r7, #28]
    __asm__ volatile ("CPSID i" : : : "memory");
 80140d8:	b672      	cpsid	i
    return(int_posture);
 80140da:	69fb      	ldr	r3, [r7, #28]
    

#ifndef TX_NOT_INTERRUPTABLE

    /* Disable interrupts to remove the suspended thread from the semaphore.  */
    TX_DISABLE
 80140dc:	637b      	str	r3, [r7, #52]	; 0x34

    /* Determine if the cleanup is still required.  */
    if (thread_ptr -> tx_thread_suspend_cleanup == &(_tx_semaphore_cleanup))
 80140de:	687b      	ldr	r3, [r7, #4]
 80140e0:	6e9b      	ldr	r3, [r3, #104]	; 0x68
 80140e2:	4a33      	ldr	r2, [pc, #204]	; (80141b0 <_tx_semaphore_cleanup+0xec>)
 80140e4:	4293      	cmp	r3, r2
 80140e6:	d158      	bne.n	801419a <_tx_semaphore_cleanup+0xd6>
    {
    
        /* Check for valid suspension sequence.  */
        if (suspension_sequence == thread_ptr -> tx_thread_suspension_sequence)
 80140e8:	687b      	ldr	r3, [r7, #4]
 80140ea:	f8d3 30ac 	ldr.w	r3, [r3, #172]	; 0xac
 80140ee:	683a      	ldr	r2, [r7, #0]
 80140f0:	429a      	cmp	r2, r3
 80140f2:	d152      	bne.n	801419a <_tx_semaphore_cleanup+0xd6>
        {

            /* Setup pointer to semaphore control block.  */
            semaphore_ptr =  TX_VOID_TO_SEMAPHORE_POINTER_CONVERT(thread_ptr -> tx_thread_suspend_control_block);
 80140f4:	687b      	ldr	r3, [r7, #4]
 80140f6:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 80140f8:	633b      	str	r3, [r7, #48]	; 0x30

            /* Check for a NULL semaphore pointer.  */
            if (semaphore_ptr != TX_NULL)
 80140fa:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 80140fc:	2b00      	cmp	r3, #0
 80140fe:	d04c      	beq.n	801419a <_tx_semaphore_cleanup+0xd6>
            {

                /* Check for a valid semaphore ID.  */
                if (semaphore_ptr -> tx_semaphore_id == TX_SEMAPHORE_ID)
 8014100:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8014102:	681b      	ldr	r3, [r3, #0]
 8014104:	4a2b      	ldr	r2, [pc, #172]	; (80141b4 <_tx_semaphore_cleanup+0xf0>)
 8014106:	4293      	cmp	r3, r2
 8014108:	d147      	bne.n	801419a <_tx_semaphore_cleanup+0xd6>
                {

                    /* Determine if there are any thread suspensions.  */
                    if (semaphore_ptr -> tx_semaphore_suspended_count != TX_NO_SUSPENSIONS)
 801410a:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801410c:	691b      	ldr	r3, [r3, #16]
 801410e:	2b00      	cmp	r3, #0
 8014110:	d043      	beq.n	801419a <_tx_semaphore_cleanup+0xd6>
#endif
                
                        /* Yes, we still have thread suspension!  */

                        /* Clear the suspension cleanup flag.  */
                        thread_ptr -> tx_thread_suspend_cleanup =  TX_NULL;
 8014112:	687b      	ldr	r3, [r7, #4]
 8014114:	2200      	movs	r2, #0
 8014116:	669a      	str	r2, [r3, #104]	; 0x68

                        /* Decrement the suspended count.  */
                        semaphore_ptr -> tx_semaphore_suspended_count--;
 8014118:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801411a:	691b      	ldr	r3, [r3, #16]
 801411c:	1e5a      	subs	r2, r3, #1
 801411e:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8014120:	611a      	str	r2, [r3, #16]

                        /* Pickup the suspended count.  */
                        suspended_count =  semaphore_ptr -> tx_semaphore_suspended_count;
 8014122:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8014124:	691b      	ldr	r3, [r3, #16]
 8014126:	62fb      	str	r3, [r7, #44]	; 0x2c

                        /* Remove the suspended thread from the list.  */

                        /* See if this is the only suspended thread on the list.  */
                        if (suspended_count == TX_NO_SUSPENSIONS)
 8014128:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 801412a:	2b00      	cmp	r3, #0
 801412c:	d103      	bne.n	8014136 <_tx_semaphore_cleanup+0x72>
                        {

                            /* Yes, the only suspended thread.  */
    
                            /* Update the head pointer.  */
                            semaphore_ptr -> tx_semaphore_suspension_list =  TX_NULL;
 801412e:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8014130:	2200      	movs	r2, #0
 8014132:	60da      	str	r2, [r3, #12]
 8014134:	e013      	b.n	801415e <_tx_semaphore_cleanup+0x9a>
                        {

                            /* At least one more thread is on the same suspension list.  */

                            /* Update the links of the adjacent threads.  */
                            next_thread =                                   thread_ptr -> tx_thread_suspended_next;
 8014136:	687b      	ldr	r3, [r7, #4]
 8014138:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 801413a:	62bb      	str	r3, [r7, #40]	; 0x28
                            previous_thread =                               thread_ptr -> tx_thread_suspended_previous;
 801413c:	687b      	ldr	r3, [r7, #4]
 801413e:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 8014140:	627b      	str	r3, [r7, #36]	; 0x24
                            next_thread -> tx_thread_suspended_previous =   previous_thread;
 8014142:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8014144:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8014146:	675a      	str	r2, [r3, #116]	; 0x74
                            previous_thread -> tx_thread_suspended_next =   next_thread;
 8014148:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801414a:	6aba      	ldr	r2, [r7, #40]	; 0x28
 801414c:	671a      	str	r2, [r3, #112]	; 0x70
            
                            /* Determine if we need to update the head pointer.  */
                            if (semaphore_ptr -> tx_semaphore_suspension_list == thread_ptr)
 801414e:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8014150:	68db      	ldr	r3, [r3, #12]
 8014152:	687a      	ldr	r2, [r7, #4]
 8014154:	429a      	cmp	r2, r3
 8014156:	d102      	bne.n	801415e <_tx_semaphore_cleanup+0x9a>
                            {

                                /* Update the list head pointer.  */
                                semaphore_ptr -> tx_semaphore_suspension_list =   next_thread;
 8014158:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801415a:	6aba      	ldr	r2, [r7, #40]	; 0x28
 801415c:	60da      	str	r2, [r3, #12]
                            }
                        }

                        /* Now we need to determine if this cleanup is from a terminate, timeout,
                           or from a wait abort.  */
                        if (thread_ptr -> tx_thread_state == TX_SEMAPHORE_SUSP)
 801415e:	687b      	ldr	r3, [r7, #4]
 8014160:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8014162:	2b06      	cmp	r3, #6
 8014164:	d119      	bne.n	801419a <_tx_semaphore_cleanup+0xd6>
                            /* Increment the number of timeouts on this semaphore.  */
                            semaphore_ptr -> tx_semaphore_performance_timeout_count++;
#endif

                            /* Setup return status.  */
                            thread_ptr -> tx_thread_suspend_status =  TX_NO_INSTANCE;
 8014166:	687b      	ldr	r3, [r7, #4]
 8014168:	220d      	movs	r2, #13
 801416a:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84
                            /* Resume the thread!  */
                            _tx_thread_system_ni_resume(thread_ptr);
#else

                            /* Temporarily disable preemption.  */
                            _tx_thread_preempt_disable++;
 801416e:	4b12      	ldr	r3, [pc, #72]	; (80141b8 <_tx_semaphore_cleanup+0xf4>)
 8014170:	681b      	ldr	r3, [r3, #0]
 8014172:	3301      	adds	r3, #1
 8014174:	4a10      	ldr	r2, [pc, #64]	; (80141b8 <_tx_semaphore_cleanup+0xf4>)
 8014176:	6013      	str	r3, [r2, #0]
 8014178:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 801417a:	613b      	str	r3, [r7, #16]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 801417c:	693b      	ldr	r3, [r7, #16]
 801417e:	f383 8810 	msr	PRIMASK, r3
}
 8014182:	bf00      	nop

                            /* Restore interrupts.  */
                            TX_RESTORE

                            /* Resume the thread!  */
                            _tx_thread_system_resume(thread_ptr);
 8014184:	6878      	ldr	r0, [r7, #4]
 8014186:	f000 fdcf 	bl	8014d28 <_tx_thread_system_resume>
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 801418a:	f3ef 8310 	mrs	r3, PRIMASK
 801418e:	61bb      	str	r3, [r7, #24]
    return(posture);
 8014190:	69bb      	ldr	r3, [r7, #24]
    int_posture = __get_interrupt_posture();
 8014192:	617b      	str	r3, [r7, #20]
    __asm__ volatile ("CPSID i" : : : "memory");
 8014194:	b672      	cpsid	i
    return(int_posture);
 8014196:	697b      	ldr	r3, [r7, #20]

                            /* Disable interrupts.  */
                            TX_DISABLE
 8014198:	637b      	str	r3, [r7, #52]	; 0x34
 801419a:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 801419c:	60fb      	str	r3, [r7, #12]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 801419e:	68fb      	ldr	r3, [r7, #12]
 80141a0:	f383 8810 	msr	PRIMASK, r3
}
 80141a4:	bf00      	nop
    }

    /* Restore interrupts.  */
    TX_RESTORE
#endif
}
 80141a6:	bf00      	nop
 80141a8:	3738      	adds	r7, #56	; 0x38
 80141aa:	46bd      	mov	sp, r7
 80141ac:	bd80      	pop	{r7, pc}
 80141ae:	bf00      	nop
 80141b0:	080140c5 	.word	0x080140c5
 80141b4:	53454d41 	.word	0x53454d41
 80141b8:	24031c5c 	.word	0x24031c5c

080141bc <_tx_semaphore_create>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
UINT  _tx_semaphore_create(TX_SEMAPHORE *semaphore_ptr, CHAR *name_ptr, ULONG initial_count)
{
 80141bc:	b580      	push	{r7, lr}
 80141be:	b08a      	sub	sp, #40	; 0x28
 80141c0:	af00      	add	r7, sp, #0
 80141c2:	60f8      	str	r0, [r7, #12]
 80141c4:	60b9      	str	r1, [r7, #8]
 80141c6:	607a      	str	r2, [r7, #4]
TX_SEMAPHORE    *next_semaphore;
TX_SEMAPHORE    *previous_semaphore;


    /* Initialize semaphore control block to all zeros.  */
    TX_MEMSET(semaphore_ptr, 0, (sizeof(TX_SEMAPHORE)));
 80141c8:	221c      	movs	r2, #28
 80141ca:	2100      	movs	r1, #0
 80141cc:	68f8      	ldr	r0, [r7, #12]
 80141ce:	f00b fb55 	bl	801f87c <memset>

    /* Setup the basic semaphore fields.  */
    semaphore_ptr -> tx_semaphore_name =             name_ptr;
 80141d2:	68fb      	ldr	r3, [r7, #12]
 80141d4:	68ba      	ldr	r2, [r7, #8]
 80141d6:	605a      	str	r2, [r3, #4]
    semaphore_ptr -> tx_semaphore_count =            initial_count;
 80141d8:	68fb      	ldr	r3, [r7, #12]
 80141da:	687a      	ldr	r2, [r7, #4]
 80141dc:	609a      	str	r2, [r3, #8]
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 80141de:	f3ef 8310 	mrs	r3, PRIMASK
 80141e2:	61bb      	str	r3, [r7, #24]
    return(posture);
 80141e4:	69bb      	ldr	r3, [r7, #24]
    int_posture = __get_interrupt_posture();
 80141e6:	617b      	str	r3, [r7, #20]
    __asm__ volatile ("CPSID i" : : : "memory");
 80141e8:	b672      	cpsid	i
    return(int_posture);
 80141ea:	697b      	ldr	r3, [r7, #20]
    
    /* Disable interrupts to place the semaphore on the created list.  */
    TX_DISABLE
 80141ec:	627b      	str	r3, [r7, #36]	; 0x24

    /* Setup the semaphore ID to make it valid.  */
    semaphore_ptr -> tx_semaphore_id =  TX_SEMAPHORE_ID;
 80141ee:	68fb      	ldr	r3, [r7, #12]
 80141f0:	4a18      	ldr	r2, [pc, #96]	; (8014254 <_tx_semaphore_create+0x98>)
 80141f2:	601a      	str	r2, [r3, #0]

    /* Place the semaphore on the list of created semaphores.  First,
       check for an empty list.  */
    if (_tx_semaphore_created_count == TX_EMPTY)
 80141f4:	4b18      	ldr	r3, [pc, #96]	; (8014258 <_tx_semaphore_create+0x9c>)
 80141f6:	681b      	ldr	r3, [r3, #0]
 80141f8:	2b00      	cmp	r3, #0
 80141fa:	d109      	bne.n	8014210 <_tx_semaphore_create+0x54>
    {

        /* The created semaphore list is empty.  Add semaphore to empty list.  */
        _tx_semaphore_created_ptr =                       semaphore_ptr;
 80141fc:	4a17      	ldr	r2, [pc, #92]	; (801425c <_tx_semaphore_create+0xa0>)
 80141fe:	68fb      	ldr	r3, [r7, #12]
 8014200:	6013      	str	r3, [r2, #0]
        semaphore_ptr -> tx_semaphore_created_next =      semaphore_ptr;
 8014202:	68fb      	ldr	r3, [r7, #12]
 8014204:	68fa      	ldr	r2, [r7, #12]
 8014206:	615a      	str	r2, [r3, #20]
        semaphore_ptr -> tx_semaphore_created_previous =  semaphore_ptr;
 8014208:	68fb      	ldr	r3, [r7, #12]
 801420a:	68fa      	ldr	r2, [r7, #12]
 801420c:	619a      	str	r2, [r3, #24]
 801420e:	e011      	b.n	8014234 <_tx_semaphore_create+0x78>
    }
    else
    {

        /* This list is not NULL, add to the end of the list.  */
        next_semaphore =      _tx_semaphore_created_ptr;
 8014210:	4b12      	ldr	r3, [pc, #72]	; (801425c <_tx_semaphore_create+0xa0>)
 8014212:	681b      	ldr	r3, [r3, #0]
 8014214:	623b      	str	r3, [r7, #32]
        previous_semaphore =  next_semaphore -> tx_semaphore_created_previous;
 8014216:	6a3b      	ldr	r3, [r7, #32]
 8014218:	699b      	ldr	r3, [r3, #24]
 801421a:	61fb      	str	r3, [r7, #28]

        /* Place the new semaphore in the list.  */
        next_semaphore -> tx_semaphore_created_previous =  semaphore_ptr;
 801421c:	6a3b      	ldr	r3, [r7, #32]
 801421e:	68fa      	ldr	r2, [r7, #12]
 8014220:	619a      	str	r2, [r3, #24]
        previous_semaphore -> tx_semaphore_created_next =  semaphore_ptr;
 8014222:	69fb      	ldr	r3, [r7, #28]
 8014224:	68fa      	ldr	r2, [r7, #12]
 8014226:	615a      	str	r2, [r3, #20]

        /* Setup this semaphore's next and previous created links.  */
        semaphore_ptr -> tx_semaphore_created_previous =  previous_semaphore;
 8014228:	68fb      	ldr	r3, [r7, #12]
 801422a:	69fa      	ldr	r2, [r7, #28]
 801422c:	619a      	str	r2, [r3, #24]
        semaphore_ptr -> tx_semaphore_created_next =      next_semaphore;
 801422e:	68fb      	ldr	r3, [r7, #12]
 8014230:	6a3a      	ldr	r2, [r7, #32]
 8014232:	615a      	str	r2, [r3, #20]
    }
    
    /* Increment the created count.  */
    _tx_semaphore_created_count++;
 8014234:	4b08      	ldr	r3, [pc, #32]	; (8014258 <_tx_semaphore_create+0x9c>)
 8014236:	681b      	ldr	r3, [r3, #0]
 8014238:	3301      	adds	r3, #1
 801423a:	4a07      	ldr	r2, [pc, #28]	; (8014258 <_tx_semaphore_create+0x9c>)
 801423c:	6013      	str	r3, [r2, #0]
 801423e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8014240:	613b      	str	r3, [r7, #16]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 8014242:	693b      	ldr	r3, [r7, #16]
 8014244:	f383 8810 	msr	PRIMASK, r3
}
 8014248:	bf00      	nop

    /* Restore interrupts.  */
    TX_RESTORE

    /* Return TX_SUCCESS.  */
    return(TX_SUCCESS);
 801424a:	2300      	movs	r3, #0
}
 801424c:	4618      	mov	r0, r3
 801424e:	3728      	adds	r7, #40	; 0x28
 8014250:	46bd      	mov	sp, r7
 8014252:	bd80      	pop	{r7, pc}
 8014254:	53454d41 	.word	0x53454d41
 8014258:	24031b90 	.word	0x24031b90
 801425c:	24031b8c 	.word	0x24031b8c

08014260 <_tx_semaphore_delete>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
UINT  _tx_semaphore_delete(TX_SEMAPHORE *semaphore_ptr)
{
 8014260:	b580      	push	{r7, lr}
 8014262:	b092      	sub	sp, #72	; 0x48
 8014264:	af00      	add	r7, sp, #0
 8014266:	6078      	str	r0, [r7, #4]
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 8014268:	f3ef 8310 	mrs	r3, PRIMASK
 801426c:	62fb      	str	r3, [r7, #44]	; 0x2c
    return(posture);
 801426e:	6afb      	ldr	r3, [r7, #44]	; 0x2c
    int_posture = __get_interrupt_posture();
 8014270:	62bb      	str	r3, [r7, #40]	; 0x28
    __asm__ volatile ("CPSID i" : : : "memory");
 8014272:	b672      	cpsid	i
    return(int_posture);
 8014274:	6abb      	ldr	r3, [r7, #40]	; 0x28
TX_SEMAPHORE    *next_semaphore;
TX_SEMAPHORE    *previous_semaphore;


    /* Disable interrupts to remove the semaphore from the created list.  */
    TX_DISABLE
 8014276:	63fb      	str	r3, [r7, #60]	; 0x3c

    /* Log this kernel call.  */
    TX_EL_SEMAPHORE_DELETE_INSERT

    /* Clear the semaphore ID to make it invalid.  */
    semaphore_ptr -> tx_semaphore_id =  TX_CLEAR_ID;
 8014278:	687b      	ldr	r3, [r7, #4]
 801427a:	2200      	movs	r2, #0
 801427c:	601a      	str	r2, [r3, #0]

    /* Decrement the number of semaphores.  */
    _tx_semaphore_created_count--;
 801427e:	4b3d      	ldr	r3, [pc, #244]	; (8014374 <_tx_semaphore_delete+0x114>)
 8014280:	681b      	ldr	r3, [r3, #0]
 8014282:	3b01      	subs	r3, #1
 8014284:	4a3b      	ldr	r2, [pc, #236]	; (8014374 <_tx_semaphore_delete+0x114>)
 8014286:	6013      	str	r3, [r2, #0]

    /* See if the semaphore is the only one on the list.  */
    if (_tx_semaphore_created_count == TX_EMPTY)
 8014288:	4b3a      	ldr	r3, [pc, #232]	; (8014374 <_tx_semaphore_delete+0x114>)
 801428a:	681b      	ldr	r3, [r3, #0]
 801428c:	2b00      	cmp	r3, #0
 801428e:	d103      	bne.n	8014298 <_tx_semaphore_delete+0x38>
    {

        /* Only created semaphore, just set the created list to NULL.  */
        _tx_semaphore_created_ptr =  TX_NULL;
 8014290:	4b39      	ldr	r3, [pc, #228]	; (8014378 <_tx_semaphore_delete+0x118>)
 8014292:	2200      	movs	r2, #0
 8014294:	601a      	str	r2, [r3, #0]
 8014296:	e013      	b.n	80142c0 <_tx_semaphore_delete+0x60>
    }
    else
    {

        /* Link-up the neighbors.  */
        next_semaphore =                                   semaphore_ptr -> tx_semaphore_created_next;
 8014298:	687b      	ldr	r3, [r7, #4]
 801429a:	695b      	ldr	r3, [r3, #20]
 801429c:	63bb      	str	r3, [r7, #56]	; 0x38
        previous_semaphore =                               semaphore_ptr -> tx_semaphore_created_previous;
 801429e:	687b      	ldr	r3, [r7, #4]
 80142a0:	699b      	ldr	r3, [r3, #24]
 80142a2:	637b      	str	r3, [r7, #52]	; 0x34
        next_semaphore -> tx_semaphore_created_previous =  previous_semaphore;
 80142a4:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 80142a6:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 80142a8:	619a      	str	r2, [r3, #24]
        previous_semaphore -> tx_semaphore_created_next =  next_semaphore;
 80142aa:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 80142ac:	6bba      	ldr	r2, [r7, #56]	; 0x38
 80142ae:	615a      	str	r2, [r3, #20]

        /* See if we have to update the created list head pointer.  */
        if (_tx_semaphore_created_ptr == semaphore_ptr)
 80142b0:	4b31      	ldr	r3, [pc, #196]	; (8014378 <_tx_semaphore_delete+0x118>)
 80142b2:	681b      	ldr	r3, [r3, #0]
 80142b4:	687a      	ldr	r2, [r7, #4]
 80142b6:	429a      	cmp	r2, r3
 80142b8:	d102      	bne.n	80142c0 <_tx_semaphore_delete+0x60>
        {
                    
            /* Yes, move the head pointer to the next link. */
            _tx_semaphore_created_ptr =  next_semaphore;
 80142ba:	4a2f      	ldr	r2, [pc, #188]	; (8014378 <_tx_semaphore_delete+0x118>)
 80142bc:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 80142be:	6013      	str	r3, [r2, #0]
        }
    }

    /* Temporarily disable preemption.  */
    _tx_thread_preempt_disable++;
 80142c0:	4b2e      	ldr	r3, [pc, #184]	; (801437c <_tx_semaphore_delete+0x11c>)
 80142c2:	681b      	ldr	r3, [r3, #0]
 80142c4:	3301      	adds	r3, #1
 80142c6:	4a2d      	ldr	r2, [pc, #180]	; (801437c <_tx_semaphore_delete+0x11c>)
 80142c8:	6013      	str	r3, [r2, #0]

    /* Pickup the suspension information.  */
    thread_ptr =                                     semaphore_ptr -> tx_semaphore_suspension_list;
 80142ca:	687b      	ldr	r3, [r7, #4]
 80142cc:	68db      	ldr	r3, [r3, #12]
 80142ce:	647b      	str	r3, [r7, #68]	; 0x44
    semaphore_ptr -> tx_semaphore_suspension_list =  TX_NULL;
 80142d0:	687b      	ldr	r3, [r7, #4]
 80142d2:	2200      	movs	r2, #0
 80142d4:	60da      	str	r2, [r3, #12]
    suspended_count =                                semaphore_ptr -> tx_semaphore_suspended_count;
 80142d6:	687b      	ldr	r3, [r7, #4]
 80142d8:	691b      	ldr	r3, [r3, #16]
 80142da:	643b      	str	r3, [r7, #64]	; 0x40
    semaphore_ptr -> tx_semaphore_suspended_count =  TX_NO_SUSPENSIONS;
 80142dc:	687b      	ldr	r3, [r7, #4]
 80142de:	2200      	movs	r2, #0
 80142e0:	611a      	str	r2, [r3, #16]
 80142e2:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 80142e4:	627b      	str	r3, [r7, #36]	; 0x24
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 80142e6:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80142e8:	f383 8810 	msr	PRIMASK, r3
}
 80142ec:	bf00      	nop
    /* Restore interrupts.  */
    TX_RESTORE

    /* Walk through the semaphore list to resume any and all threads suspended
       on this semaphore.  */
    while (suspended_count != TX_NO_SUSPENSIONS)
 80142ee:	e024      	b.n	801433a <_tx_semaphore_delete+0xda>
    {
    
        /* Decrement the suspension count.  */
        suspended_count--;
 80142f0:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 80142f2:	3b01      	subs	r3, #1
 80142f4:	643b      	str	r3, [r7, #64]	; 0x40
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 80142f6:	f3ef 8310 	mrs	r3, PRIMASK
 80142fa:	61fb      	str	r3, [r7, #28]
    return(posture);
 80142fc:	69fb      	ldr	r3, [r7, #28]
    int_posture = __get_interrupt_posture();
 80142fe:	61bb      	str	r3, [r7, #24]
    __asm__ volatile ("CPSID i" : : : "memory");
 8014300:	b672      	cpsid	i
    return(int_posture);
 8014302:	69bb      	ldr	r3, [r7, #24]

        /* Lockout interrupts.  */
        TX_DISABLE
 8014304:	63fb      	str	r3, [r7, #60]	; 0x3c

        /* Clear the cleanup pointer, this prevents the timeout from doing 
           anything.  */
        thread_ptr -> tx_thread_suspend_cleanup =  TX_NULL;
 8014306:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8014308:	2200      	movs	r2, #0
 801430a:	669a      	str	r2, [r3, #104]	; 0x68

        /* Set the return status in the thread to TX_DELETED.  */
        thread_ptr -> tx_thread_suspend_status =  TX_DELETED;
 801430c:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 801430e:	2201      	movs	r2, #1
 8014310:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84

        /* Move the thread pointer ahead.  */
        next_thread =  thread_ptr -> tx_thread_suspended_next;
 8014314:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8014316:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 8014318:	633b      	str	r3, [r7, #48]	; 0x30
        /* Restore interrupts.  */
        TX_RESTORE
#else

        /* Temporarily disable preemption again.  */
        _tx_thread_preempt_disable++;
 801431a:	4b18      	ldr	r3, [pc, #96]	; (801437c <_tx_semaphore_delete+0x11c>)
 801431c:	681b      	ldr	r3, [r3, #0]
 801431e:	3301      	adds	r3, #1
 8014320:	4a16      	ldr	r2, [pc, #88]	; (801437c <_tx_semaphore_delete+0x11c>)
 8014322:	6013      	str	r3, [r2, #0]
 8014324:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8014326:	623b      	str	r3, [r7, #32]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 8014328:	6a3b      	ldr	r3, [r7, #32]
 801432a:	f383 8810 	msr	PRIMASK, r3
}
 801432e:	bf00      	nop

        /* Restore interrupts.  */
        TX_RESTORE
    
        /* Resume the thread.  */
        _tx_thread_system_resume(thread_ptr);
 8014330:	6c78      	ldr	r0, [r7, #68]	; 0x44
 8014332:	f000 fcf9 	bl	8014d28 <_tx_thread_system_resume>
#endif

        /* Move to next thread.  */
        thread_ptr =  next_thread;
 8014336:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8014338:	647b      	str	r3, [r7, #68]	; 0x44
    while (suspended_count != TX_NO_SUSPENSIONS)
 801433a:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 801433c:	2b00      	cmp	r3, #0
 801433e:	d1d7      	bne.n	80142f0 <_tx_semaphore_delete+0x90>
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 8014340:	f3ef 8310 	mrs	r3, PRIMASK
 8014344:	613b      	str	r3, [r7, #16]
    return(posture);
 8014346:	693b      	ldr	r3, [r7, #16]
    int_posture = __get_interrupt_posture();
 8014348:	60fb      	str	r3, [r7, #12]
    __asm__ volatile ("CPSID i" : : : "memory");
 801434a:	b672      	cpsid	i
    return(int_posture);
 801434c:	68fb      	ldr	r3, [r7, #12]

    /* Execute Port-Specific completion processing. If needed, it is typically defined in tx_port.h.  */
    TX_SEMAPHORE_DELETE_PORT_COMPLETION(semaphore_ptr)

    /* Disable interrupts.  */
    TX_DISABLE
 801434e:	63fb      	str	r3, [r7, #60]	; 0x3c

    /* Release previous preempt disable.  */
    _tx_thread_preempt_disable--;
 8014350:	4b0a      	ldr	r3, [pc, #40]	; (801437c <_tx_semaphore_delete+0x11c>)
 8014352:	681b      	ldr	r3, [r3, #0]
 8014354:	3b01      	subs	r3, #1
 8014356:	4a09      	ldr	r2, [pc, #36]	; (801437c <_tx_semaphore_delete+0x11c>)
 8014358:	6013      	str	r3, [r2, #0]
 801435a:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 801435c:	617b      	str	r3, [r7, #20]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 801435e:	697b      	ldr	r3, [r7, #20]
 8014360:	f383 8810 	msr	PRIMASK, r3
}
 8014364:	bf00      	nop

    /* Restore interrupts.  */
    TX_RESTORE

    /* Check for preemption.  */
    _tx_thread_system_preempt_check();
 8014366:	f000 fca5 	bl	8014cb4 <_tx_thread_system_preempt_check>

    /* Return TX_SUCCESS.  */
    return(TX_SUCCESS);
 801436a:	2300      	movs	r3, #0
}
 801436c:	4618      	mov	r0, r3
 801436e:	3748      	adds	r7, #72	; 0x48
 8014370:	46bd      	mov	sp, r7
 8014372:	bd80      	pop	{r7, pc}
 8014374:	24031b90 	.word	0x24031b90
 8014378:	24031b8c 	.word	0x24031b8c
 801437c:	24031c5c 	.word	0x24031c5c

08014380 <_tx_semaphore_get>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
UINT  _tx_semaphore_get(TX_SEMAPHORE *semaphore_ptr, ULONG wait_option)
{
 8014380:	b580      	push	{r7, lr}
 8014382:	b08e      	sub	sp, #56	; 0x38
 8014384:	af00      	add	r7, sp, #0
 8014386:	6078      	str	r0, [r7, #4]
 8014388:	6039      	str	r1, [r7, #0]
TX_THREAD       *previous_thread;
UINT            status;


    /* Default the status to TX_SUCCESS.  */
    status =  TX_SUCCESS;
 801438a:	2300      	movs	r3, #0
 801438c:	637b      	str	r3, [r7, #52]	; 0x34
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 801438e:	f3ef 8310 	mrs	r3, PRIMASK
 8014392:	623b      	str	r3, [r7, #32]
    return(posture);
 8014394:	6a3b      	ldr	r3, [r7, #32]
    int_posture = __get_interrupt_posture();
 8014396:	61fb      	str	r3, [r7, #28]
    __asm__ volatile ("CPSID i" : : : "memory");
 8014398:	b672      	cpsid	i
    return(int_posture);
 801439a:	69fb      	ldr	r3, [r7, #28]

    /* Disable interrupts to get an instance from the semaphore.  */
    TX_DISABLE
 801439c:	633b      	str	r3, [r7, #48]	; 0x30

    /* Log this kernel call.  */
    TX_EL_SEMAPHORE_GET_INSERT

    /* Determine if there is an instance of the semaphore.  */
    if (semaphore_ptr -> tx_semaphore_count != ((ULONG) 0))
 801439e:	687b      	ldr	r3, [r7, #4]
 80143a0:	689b      	ldr	r3, [r3, #8]
 80143a2:	2b00      	cmp	r3, #0
 80143a4:	d00a      	beq.n	80143bc <_tx_semaphore_get+0x3c>
    {

        /* Decrement the semaphore count.  */
        semaphore_ptr -> tx_semaphore_count--;
 80143a6:	687b      	ldr	r3, [r7, #4]
 80143a8:	689b      	ldr	r3, [r3, #8]
 80143aa:	1e5a      	subs	r2, r3, #1
 80143ac:	687b      	ldr	r3, [r7, #4]
 80143ae:	609a      	str	r2, [r3, #8]
 80143b0:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 80143b2:	61bb      	str	r3, [r7, #24]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 80143b4:	69bb      	ldr	r3, [r7, #24]
 80143b6:	f383 8810 	msr	PRIMASK, r3
}
 80143ba:	e068      	b.n	801448e <_tx_semaphore_get+0x10e>
        /* Restore interrupts.  */
        TX_RESTORE
    }

    /* Determine if the request specifies suspension.  */
    else if (wait_option != TX_NO_WAIT)
 80143bc:	683b      	ldr	r3, [r7, #0]
 80143be:	2b00      	cmp	r3, #0
 80143c0:	d05d      	beq.n	801447e <_tx_semaphore_get+0xfe>
    {

        /* Determine if the preempt disable flag is non-zero.  */
        if (_tx_thread_preempt_disable != ((UINT) 0))
 80143c2:	4b35      	ldr	r3, [pc, #212]	; (8014498 <_tx_semaphore_get+0x118>)
 80143c4:	681b      	ldr	r3, [r3, #0]
 80143c6:	2b00      	cmp	r3, #0
 80143c8:	d008      	beq.n	80143dc <_tx_semaphore_get+0x5c>
 80143ca:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 80143cc:	617b      	str	r3, [r7, #20]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 80143ce:	697b      	ldr	r3, [r7, #20]
 80143d0:	f383 8810 	msr	PRIMASK, r3
}
 80143d4:	bf00      	nop
    
            /* Restore interrupts.  */
            TX_RESTORE

            /* Suspension is not allowed if the preempt disable flag is non-zero at this point - return error completion.  */
            status =  TX_NO_INSTANCE;
 80143d6:	230d      	movs	r3, #13
 80143d8:	637b      	str	r3, [r7, #52]	; 0x34
 80143da:	e058      	b.n	801448e <_tx_semaphore_get+0x10e>
            /* Increment the number of suspensions on this semaphore.  */
            semaphore_ptr -> tx_semaphore_performance_suspension_count++;
#endif
            
            /* Pickup thread pointer.  */
            TX_THREAD_GET_CURRENT(thread_ptr)
 80143dc:	4b2f      	ldr	r3, [pc, #188]	; (801449c <_tx_semaphore_get+0x11c>)
 80143de:	681b      	ldr	r3, [r3, #0]
 80143e0:	62fb      	str	r3, [r7, #44]	; 0x2c

            /* Setup cleanup routine pointer.  */
            thread_ptr -> tx_thread_suspend_cleanup =  &(_tx_semaphore_cleanup);
 80143e2:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 80143e4:	4a2e      	ldr	r2, [pc, #184]	; (80144a0 <_tx_semaphore_get+0x120>)
 80143e6:	669a      	str	r2, [r3, #104]	; 0x68

            /* Setup cleanup information, i.e. this semaphore control
               block.  */
            thread_ptr -> tx_thread_suspend_control_block =  (VOID *) semaphore_ptr;
 80143e8:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 80143ea:	687a      	ldr	r2, [r7, #4]
 80143ec:	66da      	str	r2, [r3, #108]	; 0x6c

#ifndef TX_NOT_INTERRUPTABLE

            /* Increment the suspension sequence number, which is used to identify
               this suspension event.  */
            thread_ptr -> tx_thread_suspension_sequence++;
 80143ee:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 80143f0:	f8d3 30ac 	ldr.w	r3, [r3, #172]	; 0xac
 80143f4:	1c5a      	adds	r2, r3, #1
 80143f6:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 80143f8:	f8c3 20ac 	str.w	r2, [r3, #172]	; 0xac
#endif

            /* Setup suspension list.  */
            if (semaphore_ptr -> tx_semaphore_suspended_count == TX_NO_SUSPENSIONS)
 80143fc:	687b      	ldr	r3, [r7, #4]
 80143fe:	691b      	ldr	r3, [r3, #16]
 8014400:	2b00      	cmp	r3, #0
 8014402:	d109      	bne.n	8014418 <_tx_semaphore_get+0x98>
            {

                /* No other threads are suspended.  Setup the head pointer and
                   just setup this threads pointers to itself.  */
                semaphore_ptr -> tx_semaphore_suspension_list =         thread_ptr;
 8014404:	687b      	ldr	r3, [r7, #4]
 8014406:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 8014408:	60da      	str	r2, [r3, #12]
                thread_ptr -> tx_thread_suspended_next =                thread_ptr;
 801440a:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 801440c:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 801440e:	671a      	str	r2, [r3, #112]	; 0x70
                thread_ptr -> tx_thread_suspended_previous =            thread_ptr;
 8014410:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8014412:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 8014414:	675a      	str	r2, [r3, #116]	; 0x74
 8014416:	e011      	b.n	801443c <_tx_semaphore_get+0xbc>
            }
            else
            {

                /* This list is not NULL, add current thread to the end. */
                next_thread =                                   semaphore_ptr -> tx_semaphore_suspension_list;
 8014418:	687b      	ldr	r3, [r7, #4]
 801441a:	68db      	ldr	r3, [r3, #12]
 801441c:	62bb      	str	r3, [r7, #40]	; 0x28
                thread_ptr -> tx_thread_suspended_next =        next_thread;
 801441e:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8014420:	6aba      	ldr	r2, [r7, #40]	; 0x28
 8014422:	671a      	str	r2, [r3, #112]	; 0x70
                previous_thread =                               next_thread -> tx_thread_suspended_previous;
 8014424:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8014426:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 8014428:	627b      	str	r3, [r7, #36]	; 0x24
                thread_ptr -> tx_thread_suspended_previous =    previous_thread;
 801442a:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 801442c:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 801442e:	675a      	str	r2, [r3, #116]	; 0x74
                previous_thread -> tx_thread_suspended_next =   thread_ptr;
 8014430:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8014432:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 8014434:	671a      	str	r2, [r3, #112]	; 0x70
                next_thread -> tx_thread_suspended_previous =   thread_ptr;
 8014436:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8014438:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 801443a:	675a      	str	r2, [r3, #116]	; 0x74
            }

            /* Increment the number of suspensions.  */
            semaphore_ptr -> tx_semaphore_suspended_count++;
 801443c:	687b      	ldr	r3, [r7, #4]
 801443e:	691b      	ldr	r3, [r3, #16]
 8014440:	1c5a      	adds	r2, r3, #1
 8014442:	687b      	ldr	r3, [r7, #4]
 8014444:	611a      	str	r2, [r3, #16]

            /* Set the state to suspended.  */
            thread_ptr -> tx_thread_state =    TX_SEMAPHORE_SUSP;
 8014446:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8014448:	2206      	movs	r2, #6
 801444a:	631a      	str	r2, [r3, #48]	; 0x30
            /* Restore interrupts.  */
            TX_RESTORE
#else

            /* Set the suspending flag.  */
            thread_ptr -> tx_thread_suspending =  TX_TRUE;
 801444c:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 801444e:	2201      	movs	r2, #1
 8014450:	639a      	str	r2, [r3, #56]	; 0x38

            /* Setup the timeout period.  */
            thread_ptr -> tx_thread_timer.tx_timer_internal_remaining_ticks =  wait_option;
 8014452:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8014454:	683a      	ldr	r2, [r7, #0]
 8014456:	64da      	str	r2, [r3, #76]	; 0x4c

            /* Temporarily disable preemption.  */
            _tx_thread_preempt_disable++;
 8014458:	4b0f      	ldr	r3, [pc, #60]	; (8014498 <_tx_semaphore_get+0x118>)
 801445a:	681b      	ldr	r3, [r3, #0]
 801445c:	3301      	adds	r3, #1
 801445e:	4a0e      	ldr	r2, [pc, #56]	; (8014498 <_tx_semaphore_get+0x118>)
 8014460:	6013      	str	r3, [r2, #0]
 8014462:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8014464:	613b      	str	r3, [r7, #16]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 8014466:	693b      	ldr	r3, [r7, #16]
 8014468:	f383 8810 	msr	PRIMASK, r3
}
 801446c:	bf00      	nop

            /* Restore interrupts.  */
            TX_RESTORE

            /* Call actual thread suspension routine.  */
            _tx_thread_system_suspend(thread_ptr);
 801446e:	6af8      	ldr	r0, [r7, #44]	; 0x2c
 8014470:	f000 fd5a 	bl	8014f28 <_tx_thread_system_suspend>
#endif

            /* Return the completion status.  */
            status =  thread_ptr -> tx_thread_suspend_status;
 8014474:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8014476:	f8d3 3084 	ldr.w	r3, [r3, #132]	; 0x84
 801447a:	637b      	str	r3, [r7, #52]	; 0x34
 801447c:	e007      	b.n	801448e <_tx_semaphore_get+0x10e>
 801447e:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8014480:	60fb      	str	r3, [r7, #12]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 8014482:	68fb      	ldr	r3, [r7, #12]
 8014484:	f383 8810 	msr	PRIMASK, r3
}
 8014488:	bf00      	nop

        /* Restore interrupts.  */
        TX_RESTORE

        /* Immediate return, return error completion.  */
        status =  TX_NO_INSTANCE;
 801448a:	230d      	movs	r3, #13
 801448c:	637b      	str	r3, [r7, #52]	; 0x34
    }

    /* Return completion status.  */
    return(status);
 801448e:	6b7b      	ldr	r3, [r7, #52]	; 0x34
}
 8014490:	4618      	mov	r0, r3
 8014492:	3738      	adds	r7, #56	; 0x38
 8014494:	46bd      	mov	sp, r7
 8014496:	bd80      	pop	{r7, pc}
 8014498:	24031c5c 	.word	0x24031c5c
 801449c:	24031bc4 	.word	0x24031bc4
 80144a0:	080140c5 	.word	0x080140c5

080144a4 <_tx_semaphore_put>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
UINT  _tx_semaphore_put(TX_SEMAPHORE *semaphore_ptr)
{
 80144a4:	b580      	push	{r7, lr}
 80144a6:	b08c      	sub	sp, #48	; 0x30
 80144a8:	af00      	add	r7, sp, #0
 80144aa:	6078      	str	r0, [r7, #4]
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 80144ac:	f3ef 8310 	mrs	r3, PRIMASK
 80144b0:	61bb      	str	r3, [r7, #24]
    return(posture);
 80144b2:	69bb      	ldr	r3, [r7, #24]
    int_posture = __get_interrupt_posture();
 80144b4:	617b      	str	r3, [r7, #20]
    __asm__ volatile ("CPSID i" : : : "memory");
 80144b6:	b672      	cpsid	i
    return(int_posture);
 80144b8:	697b      	ldr	r3, [r7, #20]
TX_THREAD       *next_thread;
TX_THREAD       *previous_thread;


    /* Disable interrupts to put an instance back to the semaphore.  */
    TX_DISABLE
 80144ba:	62fb      	str	r3, [r7, #44]	; 0x2c

    /* Log this kernel call.  */
    TX_EL_SEMAPHORE_PUT_INSERT

    /* Pickup the number of suspended threads.  */
    suspended_count =  semaphore_ptr -> tx_semaphore_suspended_count;
 80144bc:	687b      	ldr	r3, [r7, #4]
 80144be:	691b      	ldr	r3, [r3, #16]
 80144c0:	62bb      	str	r3, [r7, #40]	; 0x28

    /* Determine if there are any threads suspended on the semaphore.  */
    if (suspended_count == TX_NO_SUSPENSIONS)
 80144c2:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80144c4:	2b00      	cmp	r3, #0
 80144c6:	d10a      	bne.n	80144de <_tx_semaphore_put+0x3a>
    {

        /* Increment the semaphore count.  */
        semaphore_ptr -> tx_semaphore_count++;
 80144c8:	687b      	ldr	r3, [r7, #4]
 80144ca:	689b      	ldr	r3, [r3, #8]
 80144cc:	1c5a      	adds	r2, r3, #1
 80144ce:	687b      	ldr	r3, [r7, #4]
 80144d0:	609a      	str	r2, [r3, #8]
 80144d2:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 80144d4:	613b      	str	r3, [r7, #16]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 80144d6:	693b      	ldr	r3, [r7, #16]
 80144d8:	f383 8810 	msr	PRIMASK, r3
}
 80144dc:	e033      	b.n	8014546 <_tx_semaphore_put+0xa2>
    {

        /* A thread is suspended on this semaphore.  */
        
        /* Pickup the pointer to the first suspended thread.  */
        thread_ptr =  semaphore_ptr -> tx_semaphore_suspension_list;
 80144de:	687b      	ldr	r3, [r7, #4]
 80144e0:	68db      	ldr	r3, [r3, #12]
 80144e2:	627b      	str	r3, [r7, #36]	; 0x24

        /* Remove the suspended thread from the list.  */

        /* See if this is the only suspended thread on the list.  */
        suspended_count--;
 80144e4:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80144e6:	3b01      	subs	r3, #1
 80144e8:	62bb      	str	r3, [r7, #40]	; 0x28
        if (suspended_count == TX_NO_SUSPENSIONS)
 80144ea:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80144ec:	2b00      	cmp	r3, #0
 80144ee:	d103      	bne.n	80144f8 <_tx_semaphore_put+0x54>
        {

            /* Yes, the only suspended thread.  */

            /* Update the head pointer.  */
            semaphore_ptr -> tx_semaphore_suspension_list =  TX_NULL;
 80144f0:	687b      	ldr	r3, [r7, #4]
 80144f2:	2200      	movs	r2, #0
 80144f4:	60da      	str	r2, [r3, #12]
 80144f6:	e00e      	b.n	8014516 <_tx_semaphore_put+0x72>
        {

            /* At least one more thread is on the same expiration list.  */

            /* Update the list head pointer.  */
            next_thread =                                     thread_ptr -> tx_thread_suspended_next;
 80144f8:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80144fa:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 80144fc:	623b      	str	r3, [r7, #32]
            semaphore_ptr -> tx_semaphore_suspension_list =   next_thread;
 80144fe:	687b      	ldr	r3, [r7, #4]
 8014500:	6a3a      	ldr	r2, [r7, #32]
 8014502:	60da      	str	r2, [r3, #12]

            /* Update the links of the adjacent threads.  */
            previous_thread =                               thread_ptr -> tx_thread_suspended_previous;
 8014504:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8014506:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 8014508:	61fb      	str	r3, [r7, #28]
            next_thread -> tx_thread_suspended_previous =   previous_thread;
 801450a:	6a3b      	ldr	r3, [r7, #32]
 801450c:	69fa      	ldr	r2, [r7, #28]
 801450e:	675a      	str	r2, [r3, #116]	; 0x74
            previous_thread -> tx_thread_suspended_next =   next_thread;
 8014510:	69fb      	ldr	r3, [r7, #28]
 8014512:	6a3a      	ldr	r2, [r7, #32]
 8014514:	671a      	str	r2, [r3, #112]	; 0x70
        }

        /* Decrement the suspension count.  */
        semaphore_ptr -> tx_semaphore_suspended_count =  suspended_count;
 8014516:	687b      	ldr	r3, [r7, #4]
 8014518:	6aba      	ldr	r2, [r7, #40]	; 0x28
 801451a:	611a      	str	r2, [r3, #16]

        /* Prepare for resumption of the first thread.  */

        /* Clear cleanup routine to avoid timeout.  */
        thread_ptr -> tx_thread_suspend_cleanup =  TX_NULL;
 801451c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801451e:	2200      	movs	r2, #0
 8014520:	669a      	str	r2, [r3, #104]	; 0x68
        /* Pickup the application notify function.  */
        semaphore_put_notify =  semaphore_ptr -> tx_semaphore_put_notify;
#endif

        /* Put return status into the thread control block.  */
        thread_ptr -> tx_thread_suspend_status =  TX_SUCCESS;
 8014522:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8014524:	2200      	movs	r2, #0
 8014526:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84
        /* Restore interrupts.  */
        TX_RESTORE
#else

        /* Temporarily disable preemption.  */
        _tx_thread_preempt_disable++;
 801452a:	4b09      	ldr	r3, [pc, #36]	; (8014550 <_tx_semaphore_put+0xac>)
 801452c:	681b      	ldr	r3, [r3, #0]
 801452e:	3301      	adds	r3, #1
 8014530:	4a07      	ldr	r2, [pc, #28]	; (8014550 <_tx_semaphore_put+0xac>)
 8014532:	6013      	str	r3, [r2, #0]
 8014534:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8014536:	60fb      	str	r3, [r7, #12]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 8014538:	68fb      	ldr	r3, [r7, #12]
 801453a:	f383 8810 	msr	PRIMASK, r3
}
 801453e:	bf00      	nop

        /* Restore interrupts.  */
        TX_RESTORE

        /* Resume thread.  */
        _tx_thread_system_resume(thread_ptr);
 8014540:	6a78      	ldr	r0, [r7, #36]	; 0x24
 8014542:	f000 fbf1 	bl	8014d28 <_tx_thread_system_resume>
        }
#endif
    }

    /* Return successful completion.  */
    return(TX_SUCCESS);
 8014546:	2300      	movs	r3, #0
}
 8014548:	4618      	mov	r0, r3
 801454a:	3730      	adds	r7, #48	; 0x30
 801454c:	46bd      	mov	sp, r7
 801454e:	bd80      	pop	{r7, pc}
 8014550:	24031c5c 	.word	0x24031c5c

08014554 <_tx_thread_create>:
/*                                                                        */
/**************************************************************************/
UINT  _tx_thread_create(TX_THREAD *thread_ptr, CHAR *name_ptr, VOID (*entry_function)(ULONG id), ULONG entry_input,
                            VOID *stack_start, ULONG stack_size, UINT priority, UINT preempt_threshold,
                            ULONG time_slice, UINT auto_start)
{
 8014554:	b580      	push	{r7, lr}
 8014556:	b092      	sub	sp, #72	; 0x48
 8014558:	af00      	add	r7, sp, #0
 801455a:	60f8      	str	r0, [r7, #12]
 801455c:	60b9      	str	r1, [r7, #8]
 801455e:	607a      	str	r2, [r7, #4]
 8014560:	603b      	str	r3, [r7, #0]
TX_INTERRUPT_SAVE_AREA

TX_THREAD               *next_thread;
TX_THREAD               *previous_thread;
TX_THREAD               *saved_thread_ptr;
UINT                    saved_threshold =  ((UINT) 0);
 8014562:	2300      	movs	r3, #0
 8014564:	643b      	str	r3, [r7, #64]	; 0x40
#ifndef TX_DISABLE_STACK_FILLING

    /* Set the thread stack to a pattern prior to creating the initial
       stack frame.  This pattern is used by the stack checking routines
       to see how much has been used.  */
    TX_MEMSET(stack_start, ((UCHAR) TX_STACK_FILL), stack_size);
 8014566:	6d7a      	ldr	r2, [r7, #84]	; 0x54
 8014568:	21ef      	movs	r1, #239	; 0xef
 801456a:	6d38      	ldr	r0, [r7, #80]	; 0x50
 801456c:	f00b f986 	bl	801f87c <memset>

    /* Prepare the thread control block prior to placing it on the created
       list.  */

    /* Initialize thread control block to all zeros.  */
    TX_MEMSET(thread_ptr, 0, (sizeof(TX_THREAD)));
 8014570:	22b4      	movs	r2, #180	; 0xb4
 8014572:	2100      	movs	r1, #0
 8014574:	68f8      	ldr	r0, [r7, #12]
 8014576:	f00b f981 	bl	801f87c <memset>

    /* Place the supplied parameters into the thread's control block.  */
    thread_ptr -> tx_thread_name =              name_ptr;
 801457a:	68fb      	ldr	r3, [r7, #12]
 801457c:	68ba      	ldr	r2, [r7, #8]
 801457e:	629a      	str	r2, [r3, #40]	; 0x28
    thread_ptr -> tx_thread_entry =             entry_function;
 8014580:	68fb      	ldr	r3, [r7, #12]
 8014582:	687a      	ldr	r2, [r7, #4]
 8014584:	645a      	str	r2, [r3, #68]	; 0x44
    thread_ptr -> tx_thread_entry_parameter =   entry_input;
 8014586:	68fb      	ldr	r3, [r7, #12]
 8014588:	683a      	ldr	r2, [r7, #0]
 801458a:	649a      	str	r2, [r3, #72]	; 0x48
    thread_ptr -> tx_thread_stack_start =       stack_start;
 801458c:	68fb      	ldr	r3, [r7, #12]
 801458e:	6d3a      	ldr	r2, [r7, #80]	; 0x50
 8014590:	60da      	str	r2, [r3, #12]
    thread_ptr -> tx_thread_stack_size =        stack_size;
 8014592:	68fb      	ldr	r3, [r7, #12]
 8014594:	6d7a      	ldr	r2, [r7, #84]	; 0x54
 8014596:	615a      	str	r2, [r3, #20]
    thread_ptr -> tx_thread_priority =          priority;
 8014598:	68fb      	ldr	r3, [r7, #12]
 801459a:	6dba      	ldr	r2, [r7, #88]	; 0x58
 801459c:	62da      	str	r2, [r3, #44]	; 0x2c
    thread_ptr -> tx_thread_user_priority =     priority;
 801459e:	68fb      	ldr	r3, [r7, #12]
 80145a0:	6dba      	ldr	r2, [r7, #88]	; 0x58
 80145a2:	f8c3 2094 	str.w	r2, [r3, #148]	; 0x94
    thread_ptr -> tx_thread_time_slice =        time_slice;
 80145a6:	68fb      	ldr	r3, [r7, #12]
 80145a8:	6e3a      	ldr	r2, [r7, #96]	; 0x60
 80145aa:	619a      	str	r2, [r3, #24]
    thread_ptr -> tx_thread_new_time_slice =    time_slice;
 80145ac:	68fb      	ldr	r3, [r7, #12]
 80145ae:	6e3a      	ldr	r2, [r7, #96]	; 0x60
 80145b0:	61da      	str	r2, [r3, #28]
    thread_ptr -> tx_thread_inherit_priority =  ((UINT) TX_MAX_PRIORITIES);
 80145b2:	68fb      	ldr	r3, [r7, #12]
 80145b4:	2220      	movs	r2, #32
 80145b6:	f8c3 209c 	str.w	r2, [r3, #156]	; 0x9c

    /* Calculate the end of the thread's stack area.  */
    temp_ptr =  TX_VOID_TO_UCHAR_POINTER_CONVERT(stack_start);
 80145ba:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 80145bc:	63fb      	str	r3, [r7, #60]	; 0x3c
    temp_ptr =  (TX_UCHAR_POINTER_ADD(temp_ptr, (stack_size - ((ULONG) 1))));
 80145be:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 80145c0:	3b01      	subs	r3, #1
 80145c2:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 80145c4:	4413      	add	r3, r2
 80145c6:	63fb      	str	r3, [r7, #60]	; 0x3c
    thread_ptr -> tx_thread_stack_end =         TX_UCHAR_TO_VOID_POINTER_CONVERT(temp_ptr);
 80145c8:	68fb      	ldr	r3, [r7, #12]
 80145ca:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 80145cc:	611a      	str	r2, [r3, #16]
    thread_ptr -> tx_thread_preempt_threshold =       preempt_threshold;
    thread_ptr -> tx_thread_user_preempt_threshold =  preempt_threshold;
#else

    /* Preemption-threshold is disabled, determine if preemption-threshold was required.  */
    if (priority != preempt_threshold)
 80145ce:	6dba      	ldr	r2, [r7, #88]	; 0x58
 80145d0:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 80145d2:	429a      	cmp	r2, r3
 80145d4:	d007      	beq.n	80145e6 <_tx_thread_create+0x92>
    {

        /* Preemption-threshold specified. Since specific preemption-threshold is not supported,
           disable all preemption.  */
        thread_ptr -> tx_thread_preempt_threshold =       ((UINT) 0);
 80145d6:	68fb      	ldr	r3, [r7, #12]
 80145d8:	2200      	movs	r2, #0
 80145da:	63da      	str	r2, [r3, #60]	; 0x3c
        thread_ptr -> tx_thread_user_preempt_threshold =  ((UINT) 0);
 80145dc:	68fb      	ldr	r3, [r7, #12]
 80145de:	2200      	movs	r2, #0
 80145e0:	f8c3 2098 	str.w	r2, [r3, #152]	; 0x98
 80145e4:	e006      	b.n	80145f4 <_tx_thread_create+0xa0>
    }
    else
    {

        /* Preemption-threshold is not specified, just setup with the priority.  */
        thread_ptr -> tx_thread_preempt_threshold =       priority;
 80145e6:	68fb      	ldr	r3, [r7, #12]
 80145e8:	6dba      	ldr	r2, [r7, #88]	; 0x58
 80145ea:	63da      	str	r2, [r3, #60]	; 0x3c
        thread_ptr -> tx_thread_user_preempt_threshold =  priority;
 80145ec:	68fb      	ldr	r3, [r7, #12]
 80145ee:	6dba      	ldr	r2, [r7, #88]	; 0x58
 80145f0:	f8c3 2098 	str.w	r2, [r3, #152]	; 0x98
    }
#endif

    /* Now fill in the values that are required for thread initialization.  */
    thread_ptr -> tx_thread_state =  TX_SUSPENDED;
 80145f4:	68fb      	ldr	r3, [r7, #12]
 80145f6:	2203      	movs	r2, #3
 80145f8:	631a      	str	r2, [r3, #48]	; 0x30

    /* Setup the necessary fields in the thread timer block.  */
    TX_THREAD_CREATE_TIMEOUT_SETUP(thread_ptr)
 80145fa:	68fb      	ldr	r3, [r7, #12]
 80145fc:	4a48      	ldr	r2, [pc, #288]	; (8014720 <_tx_thread_create+0x1cc>)
 80145fe:	655a      	str	r2, [r3, #84]	; 0x54
 8014600:	68fa      	ldr	r2, [r7, #12]
 8014602:	68fb      	ldr	r3, [r7, #12]
 8014604:	659a      	str	r2, [r3, #88]	; 0x58
    TX_THREAD_CREATE_INTERNAL_EXTENSION(thread_ptr)

    /* Call the target specific stack frame building routine to build the 
       thread's initial stack and to setup the actual stack pointer in the
       control block.  */
    _tx_thread_stack_build(thread_ptr, _tx_thread_shell_entry);
 8014606:	4947      	ldr	r1, [pc, #284]	; (8014724 <_tx_thread_create+0x1d0>)
 8014608:	68f8      	ldr	r0, [r7, #12]
 801460a:	f7eb ff09 	bl	8000420 <_tx_thread_stack_build>
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 801460e:	f3ef 8310 	mrs	r3, PRIMASK
 8014612:	62fb      	str	r3, [r7, #44]	; 0x2c
    return(posture);
 8014614:	6afb      	ldr	r3, [r7, #44]	; 0x2c
    int_posture = __get_interrupt_posture();
 8014616:	62bb      	str	r3, [r7, #40]	; 0x28
    __asm__ volatile ("CPSID i" : : : "memory");
 8014618:	b672      	cpsid	i
    return(int_posture);
 801461a:	6abb      	ldr	r3, [r7, #40]	; 0x28
    /* Setup the highest usage stack pointer.  */
    thread_ptr -> tx_thread_stack_highest_ptr =  thread_ptr -> tx_thread_stack_ptr;
#endif

    /* Prepare to make this thread a member of the created thread list.  */
    TX_DISABLE
 801461c:	63bb      	str	r3, [r7, #56]	; 0x38

    /* Load the thread ID field in the thread control block.  */
    thread_ptr -> tx_thread_id =  TX_THREAD_ID;
 801461e:	68fb      	ldr	r3, [r7, #12]
 8014620:	4a41      	ldr	r2, [pc, #260]	; (8014728 <_tx_thread_create+0x1d4>)
 8014622:	601a      	str	r2, [r3, #0]

    /* Place the thread on the list of created threads.  First,
       check for an empty list.  */
    if (_tx_thread_created_count == TX_EMPTY)
 8014624:	4b41      	ldr	r3, [pc, #260]	; (801472c <_tx_thread_create+0x1d8>)
 8014626:	681b      	ldr	r3, [r3, #0]
 8014628:	2b00      	cmp	r3, #0
 801462a:	d10b      	bne.n	8014644 <_tx_thread_create+0xf0>
    {

        /* The created thread list is empty.  Add thread to empty list.  */
        _tx_thread_created_ptr =                    thread_ptr;
 801462c:	4a40      	ldr	r2, [pc, #256]	; (8014730 <_tx_thread_create+0x1dc>)
 801462e:	68fb      	ldr	r3, [r7, #12]
 8014630:	6013      	str	r3, [r2, #0]
        thread_ptr -> tx_thread_created_next =      thread_ptr;
 8014632:	68fb      	ldr	r3, [r7, #12]
 8014634:	68fa      	ldr	r2, [r7, #12]
 8014636:	f8c3 2088 	str.w	r2, [r3, #136]	; 0x88
        thread_ptr -> tx_thread_created_previous =  thread_ptr;
 801463a:	68fb      	ldr	r3, [r7, #12]
 801463c:	68fa      	ldr	r2, [r7, #12]
 801463e:	f8c3 208c 	str.w	r2, [r3, #140]	; 0x8c
 8014642:	e016      	b.n	8014672 <_tx_thread_create+0x11e>
    }
    else
    {

        /* This list is not NULL, add to the end of the list.  */
        next_thread =  _tx_thread_created_ptr;
 8014644:	4b3a      	ldr	r3, [pc, #232]	; (8014730 <_tx_thread_create+0x1dc>)
 8014646:	681b      	ldr	r3, [r3, #0]
 8014648:	637b      	str	r3, [r7, #52]	; 0x34
        previous_thread =  next_thread -> tx_thread_created_previous;
 801464a:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 801464c:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
 8014650:	633b      	str	r3, [r7, #48]	; 0x30

        /* Place the new thread in the list.  */
        next_thread -> tx_thread_created_previous =  thread_ptr;
 8014652:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8014654:	68fa      	ldr	r2, [r7, #12]
 8014656:	f8c3 208c 	str.w	r2, [r3, #140]	; 0x8c
        previous_thread -> tx_thread_created_next =  thread_ptr;
 801465a:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801465c:	68fa      	ldr	r2, [r7, #12]
 801465e:	f8c3 2088 	str.w	r2, [r3, #136]	; 0x88

        /* Setup this thread's created links.  */
        thread_ptr -> tx_thread_created_previous =  previous_thread;
 8014662:	68fb      	ldr	r3, [r7, #12]
 8014664:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 8014666:	f8c3 208c 	str.w	r2, [r3, #140]	; 0x8c
        thread_ptr -> tx_thread_created_next =      next_thread;
 801466a:	68fb      	ldr	r3, [r7, #12]
 801466c:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 801466e:	f8c3 2088 	str.w	r2, [r3, #136]	; 0x88
    }
    
    /* Increment the thread created count.  */
    _tx_thread_created_count++;
 8014672:	4b2e      	ldr	r3, [pc, #184]	; (801472c <_tx_thread_create+0x1d8>)
 8014674:	681b      	ldr	r3, [r3, #0]
 8014676:	3301      	adds	r3, #1
 8014678:	4a2c      	ldr	r2, [pc, #176]	; (801472c <_tx_thread_create+0x1d8>)
 801467a:	6013      	str	r3, [r2, #0]
    TX_EL_THREAD_CREATE_INSERT

#ifndef TX_NOT_INTERRUPTABLE

    /* Temporarily disable preemption.  */
    _tx_thread_preempt_disable++;
 801467c:	4b2d      	ldr	r3, [pc, #180]	; (8014734 <_tx_thread_create+0x1e0>)
 801467e:	681b      	ldr	r3, [r3, #0]
 8014680:	3301      	adds	r3, #1
 8014682:	4a2c      	ldr	r2, [pc, #176]	; (8014734 <_tx_thread_create+0x1e0>)
 8014684:	6013      	str	r3, [r2, #0]
#endif

    /* Determine if an automatic start was requested.  If so, call the resume
       thread function and then check for a preemption condition.  */
    if (auto_start == TX_AUTO_START)
 8014686:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 8014688:	2b01      	cmp	r3, #1
 801468a:	d129      	bne.n	80146e0 <_tx_thread_create+0x18c>
    __asm__ volatile (" MRS  %0,IPSR ": "=r" (ipsr_value) );
 801468c:	f3ef 8305 	mrs	r3, IPSR
 8014690:	627b      	str	r3, [r7, #36]	; 0x24
    return(ipsr_value);
 8014692:	6a7a      	ldr	r2, [r7, #36]	; 0x24
    {

        /* Determine if the create call is being called from initialization.  */
        if (TX_THREAD_GET_SYSTEM_STATE() >= TX_INITIALIZE_IN_PROGRESS)
 8014694:	4b28      	ldr	r3, [pc, #160]	; (8014738 <_tx_thread_create+0x1e4>)
 8014696:	681b      	ldr	r3, [r3, #0]
 8014698:	4313      	orrs	r3, r2
 801469a:	f1b3 3ff0 	cmp.w	r3, #4042322160	; 0xf0f0f0f0
 801469e:	d30d      	bcc.n	80146bc <_tx_thread_create+0x168>

            /* Pickup the current thread execute pointer, which corresponds to the
               highest priority thread ready to execute.  Interrupt lockout is 
               not required, since interrupts are assumed to be disabled during 
               initialization.  */
            saved_thread_ptr =  _tx_thread_execute_ptr;
 80146a0:	4b26      	ldr	r3, [pc, #152]	; (801473c <_tx_thread_create+0x1e8>)
 80146a2:	681b      	ldr	r3, [r3, #0]
 80146a4:	647b      	str	r3, [r7, #68]	; 0x44

            /* Determine if there is thread ready for execution.  */
            if (saved_thread_ptr != TX_NULL)
 80146a6:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 80146a8:	2b00      	cmp	r3, #0
 80146aa:	d009      	beq.n	80146c0 <_tx_thread_create+0x16c>
            {
                
                /* Yes, a thread is ready for execution when initialization completes.  */

                /* Save the current preemption-threshold.  */
                saved_threshold =  saved_thread_ptr -> tx_thread_preempt_threshold;
 80146ac:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 80146ae:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 80146b0:	643b      	str	r3, [r7, #64]	; 0x40

                /* For initialization, temporarily set the preemption-threshold to the 
                   priority level to make sure the highest-priority thread runs once 
                   initialization is complete.  */
                saved_thread_ptr -> tx_thread_preempt_threshold =  saved_thread_ptr -> tx_thread_priority;
 80146b2:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 80146b4:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 80146b6:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 80146b8:	63da      	str	r2, [r3, #60]	; 0x3c
 80146ba:	e001      	b.n	80146c0 <_tx_thread_create+0x16c>
        }
        else
        {

            /* Simply set the saved thread pointer to NULL.  */
            saved_thread_ptr =  TX_NULL;
 80146bc:	2300      	movs	r3, #0
 80146be:	647b      	str	r3, [r7, #68]	; 0x44
 80146c0:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 80146c2:	623b      	str	r3, [r7, #32]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 80146c4:	6a3b      	ldr	r3, [r7, #32]
 80146c6:	f383 8810 	msr	PRIMASK, r3
}
 80146ca:	bf00      	nop

        /* Perform any additional activities for tool or user purpose.  */
        TX_THREAD_CREATE_EXTENSION(thread_ptr)

        /* Call the resume thread function to make this thread ready.  */
        _tx_thread_system_resume(thread_ptr);
 80146cc:	68f8      	ldr	r0, [r7, #12]
 80146ce:	f000 fb2b 	bl	8014d28 <_tx_thread_system_resume>
#endif
 
        /* Determine if the thread's preemption-threshold needs to be restored.  */
        if (saved_thread_ptr != TX_NULL)
 80146d2:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 80146d4:	2b00      	cmp	r3, #0
 80146d6:	d01e      	beq.n	8014716 <_tx_thread_create+0x1c2>
        {

            /* Yes, restore the previous highest-priority thread's preemption-threshold. This
               can only happen if this routine is called from initialization.  */
            saved_thread_ptr -> tx_thread_preempt_threshold =  saved_threshold;
 80146d8:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 80146da:	6c3a      	ldr	r2, [r7, #64]	; 0x40
 80146dc:	63da      	str	r2, [r3, #60]	; 0x3c
 80146de:	e01a      	b.n	8014716 <_tx_thread_create+0x1c2>
 80146e0:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 80146e2:	613b      	str	r3, [r7, #16]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 80146e4:	693b      	ldr	r3, [r7, #16]
 80146e6:	f383 8810 	msr	PRIMASK, r3
}
 80146ea:	bf00      	nop
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 80146ec:	f3ef 8310 	mrs	r3, PRIMASK
 80146f0:	61bb      	str	r3, [r7, #24]
    return(posture);
 80146f2:	69bb      	ldr	r3, [r7, #24]
    int_posture = __get_interrupt_posture();
 80146f4:	617b      	str	r3, [r7, #20]
    __asm__ volatile ("CPSID i" : : : "memory");
 80146f6:	b672      	cpsid	i
    return(int_posture);
 80146f8:	697b      	ldr	r3, [r7, #20]

        /* Perform any additional activities for tool or user purpose.  */
        TX_THREAD_CREATE_EXTENSION(thread_ptr)

        /* Disable interrupts.  */
        TX_DISABLE
 80146fa:	63bb      	str	r3, [r7, #56]	; 0x38

        /* Re-enable preemption.  */
        _tx_thread_preempt_disable--;
 80146fc:	4b0d      	ldr	r3, [pc, #52]	; (8014734 <_tx_thread_create+0x1e0>)
 80146fe:	681b      	ldr	r3, [r3, #0]
 8014700:	3b01      	subs	r3, #1
 8014702:	4a0c      	ldr	r2, [pc, #48]	; (8014734 <_tx_thread_create+0x1e0>)
 8014704:	6013      	str	r3, [r2, #0]
 8014706:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8014708:	61fb      	str	r3, [r7, #28]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 801470a:	69fb      	ldr	r3, [r7, #28]
 801470c:	f383 8810 	msr	PRIMASK, r3
}
 8014710:	bf00      	nop

        /* Restore interrupts.  */
        TX_RESTORE

        /* Check for preemption.  */
        _tx_thread_system_preempt_check();
 8014712:	f000 facf 	bl	8014cb4 <_tx_thread_system_preempt_check>
#endif
    }

    /* Always return a success.  */
    return(TX_SUCCESS);
 8014716:	2300      	movs	r3, #0
}
 8014718:	4618      	mov	r0, r3
 801471a:	3748      	adds	r7, #72	; 0x48
 801471c:	46bd      	mov	sp, r7
 801471e:	bd80      	pop	{r7, pc}
 8014720:	080154fd 	.word	0x080154fd
 8014724:	08014b1d 	.word	0x08014b1d
 8014728:	54485244 	.word	0x54485244
 801472c:	24031bd0 	.word	0x24031bd0
 8014730:	24031bcc 	.word	0x24031bcc
 8014734:	24031c5c 	.word	0x24031c5c
 8014738:	24000078 	.word	0x24000078
 801473c:	24031bc8 	.word	0x24031bc8

08014740 <_tx_thread_delete>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
UINT  _tx_thread_delete(TX_THREAD *thread_ptr)
{
 8014740:	b480      	push	{r7}
 8014742:	b08b      	sub	sp, #44	; 0x2c
 8014744:	af00      	add	r7, sp, #0
 8014746:	6078      	str	r0, [r7, #4]
TX_THREAD       *previous_thread;
UINT            status;


    /* Default status to success.  */
    status =  TX_SUCCESS;
 8014748:	2300      	movs	r3, #0
 801474a:	627b      	str	r3, [r7, #36]	; 0x24
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 801474c:	f3ef 8310 	mrs	r3, PRIMASK
 8014750:	617b      	str	r3, [r7, #20]
    return(posture);
 8014752:	697b      	ldr	r3, [r7, #20]
    int_posture = __get_interrupt_posture();
 8014754:	613b      	str	r3, [r7, #16]
    __asm__ volatile ("CPSID i" : : : "memory");
 8014756:	b672      	cpsid	i
    return(int_posture);
 8014758:	693b      	ldr	r3, [r7, #16]
    
    /* Lockout interrupts while the thread is being deleted.  */
    TX_DISABLE
 801475a:	623b      	str	r3, [r7, #32]

    /* Check for proper status of this thread to delete.  */
    if (thread_ptr -> tx_thread_state != TX_COMPLETED)
 801475c:	687b      	ldr	r3, [r7, #4]
 801475e:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8014760:	2b01      	cmp	r3, #1
 8014762:	d00b      	beq.n	801477c <_tx_thread_delete+0x3c>
    {

        /* Now check for terminated state.  */
        if (thread_ptr -> tx_thread_state != TX_TERMINATED)
 8014764:	687b      	ldr	r3, [r7, #4]
 8014766:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8014768:	2b02      	cmp	r3, #2
 801476a:	d007      	beq.n	801477c <_tx_thread_delete+0x3c>
 801476c:	6a3b      	ldr	r3, [r7, #32]
 801476e:	60fb      	str	r3, [r7, #12]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 8014770:	68fb      	ldr	r3, [r7, #12]
 8014772:	f383 8810 	msr	PRIMASK, r3
}
 8014776:	bf00      	nop

            /* Restore interrupts.  */
            TX_RESTORE

            /* Thread not completed or terminated - return an error!  */
            status =  TX_DELETE_ERROR;
 8014778:	2311      	movs	r3, #17
 801477a:	627b      	str	r3, [r7, #36]	; 0x24
        }
    }

    /* Determine if the delete operation is okay.  */
    if (status == TX_SUCCESS)
 801477c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801477e:	2b00      	cmp	r3, #0
 8014780:	d12d      	bne.n	80147de <_tx_thread_delete+0x9e>

        /* Unregister thread in the thread array structure.  */
        TX_EL_THREAD_UNREGISTER(thread_ptr)

        /* Clear the thread ID to make it invalid.  */
        thread_ptr -> tx_thread_id =  TX_CLEAR_ID;
 8014782:	687b      	ldr	r3, [r7, #4]
 8014784:	2200      	movs	r2, #0
 8014786:	601a      	str	r2, [r3, #0]

        /* Decrement the number of created threads.  */
        _tx_thread_created_count--;
 8014788:	4b18      	ldr	r3, [pc, #96]	; (80147ec <_tx_thread_delete+0xac>)
 801478a:	681b      	ldr	r3, [r3, #0]
 801478c:	3b01      	subs	r3, #1
 801478e:	4a17      	ldr	r2, [pc, #92]	; (80147ec <_tx_thread_delete+0xac>)
 8014790:	6013      	str	r3, [r2, #0]
        
        /* See if the thread is the only one on the list.  */
        if (_tx_thread_created_count == TX_EMPTY)
 8014792:	4b16      	ldr	r3, [pc, #88]	; (80147ec <_tx_thread_delete+0xac>)
 8014794:	681b      	ldr	r3, [r3, #0]
 8014796:	2b00      	cmp	r3, #0
 8014798:	d103      	bne.n	80147a2 <_tx_thread_delete+0x62>
        {

            /* Only created thread, just set the created list to NULL.  */
            _tx_thread_created_ptr =  TX_NULL;
 801479a:	4b15      	ldr	r3, [pc, #84]	; (80147f0 <_tx_thread_delete+0xb0>)
 801479c:	2200      	movs	r2, #0
 801479e:	601a      	str	r2, [r3, #0]
 80147a0:	e017      	b.n	80147d2 <_tx_thread_delete+0x92>
        }
        else
        {

            /* Otherwise, not the only created thread, link-up the neighbors.  */
            next_thread =                                thread_ptr -> tx_thread_created_next;
 80147a2:	687b      	ldr	r3, [r7, #4]
 80147a4:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
 80147a8:	61fb      	str	r3, [r7, #28]
            previous_thread =                            thread_ptr -> tx_thread_created_previous;
 80147aa:	687b      	ldr	r3, [r7, #4]
 80147ac:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
 80147b0:	61bb      	str	r3, [r7, #24]
            next_thread -> tx_thread_created_previous =  previous_thread;
 80147b2:	69fb      	ldr	r3, [r7, #28]
 80147b4:	69ba      	ldr	r2, [r7, #24]
 80147b6:	f8c3 208c 	str.w	r2, [r3, #140]	; 0x8c
            previous_thread -> tx_thread_created_next =  next_thread;
 80147ba:	69bb      	ldr	r3, [r7, #24]
 80147bc:	69fa      	ldr	r2, [r7, #28]
 80147be:	f8c3 2088 	str.w	r2, [r3, #136]	; 0x88

            /* See if we have to update the created list head pointer.  */
            if (_tx_thread_created_ptr == thread_ptr)
 80147c2:	4b0b      	ldr	r3, [pc, #44]	; (80147f0 <_tx_thread_delete+0xb0>)
 80147c4:	681b      	ldr	r3, [r3, #0]
 80147c6:	687a      	ldr	r2, [r7, #4]
 80147c8:	429a      	cmp	r2, r3
 80147ca:	d102      	bne.n	80147d2 <_tx_thread_delete+0x92>
            {
                        
                /* Yes, move the head pointer to the next link. */
                _tx_thread_created_ptr =  next_thread;
 80147cc:	4a08      	ldr	r2, [pc, #32]	; (80147f0 <_tx_thread_delete+0xb0>)
 80147ce:	69fb      	ldr	r3, [r7, #28]
 80147d0:	6013      	str	r3, [r2, #0]
 80147d2:	6a3b      	ldr	r3, [r7, #32]
 80147d4:	60bb      	str	r3, [r7, #8]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 80147d6:	68bb      	ldr	r3, [r7, #8]
 80147d8:	f383 8810 	msr	PRIMASK, r3
}
 80147dc:	bf00      	nop
        /* Restore interrupts.  */
        TX_RESTORE
    }

    /* Return completion status.  */
    return(status);
 80147de:	6a7b      	ldr	r3, [r7, #36]	; 0x24
}
 80147e0:	4618      	mov	r0, r3
 80147e2:	372c      	adds	r7, #44	; 0x2c
 80147e4:	46bd      	mov	sp, r7
 80147e6:	f85d 7b04 	ldr.w	r7, [sp], #4
 80147ea:	4770      	bx	lr
 80147ec:	24031bd0 	.word	0x24031bd0
 80147f0:	24031bcc 	.word	0x24031bcc

080147f4 <_tx_thread_identify>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
TX_THREAD  *_tx_thread_identify(VOID)
{
 80147f4:	b480      	push	{r7}
 80147f6:	b087      	sub	sp, #28
 80147f8:	af00      	add	r7, sp, #0
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 80147fa:	f3ef 8310 	mrs	r3, PRIMASK
 80147fe:	60bb      	str	r3, [r7, #8]
    return(posture);
 8014800:	68bb      	ldr	r3, [r7, #8]
    int_posture = __get_interrupt_posture();
 8014802:	607b      	str	r3, [r7, #4]
    __asm__ volatile ("CPSID i" : : : "memory");
 8014804:	b672      	cpsid	i
    return(int_posture);
 8014806:	687b      	ldr	r3, [r7, #4]

TX_INTERRUPT_SAVE_AREA

    
    /* Disable interrupts to put the timer on the created list.  */
    TX_DISABLE
 8014808:	617b      	str	r3, [r7, #20]

   /* Log this kernel call.  */
    TX_EL_THREAD_IDENTIFY_INSERT

    /* Pickup thread pointer.  */
    TX_THREAD_GET_CURRENT(thread_ptr)
 801480a:	4b08      	ldr	r3, [pc, #32]	; (801482c <_tx_thread_identify+0x38>)
 801480c:	681b      	ldr	r3, [r3, #0]
 801480e:	613b      	str	r3, [r7, #16]
 8014810:	697b      	ldr	r3, [r7, #20]
 8014812:	60fb      	str	r3, [r7, #12]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 8014814:	68fb      	ldr	r3, [r7, #12]
 8014816:	f383 8810 	msr	PRIMASK, r3
}
 801481a:	bf00      	nop

    /* Restore interrupts.  */
    TX_RESTORE

    /* Return the current thread pointer.  */
    return(thread_ptr);
 801481c:	693b      	ldr	r3, [r7, #16]
}
 801481e:	4618      	mov	r0, r3
 8014820:	371c      	adds	r7, #28
 8014822:	46bd      	mov	sp, r7
 8014824:	f85d 7b04 	ldr.w	r7, [sp], #4
 8014828:	4770      	bx	lr
 801482a:	bf00      	nop
 801482c:	24031bc4 	.word	0x24031bc4

08014830 <_tx_thread_initialize>:
/*                                            Execution Profile support,  */
/*                                            resulting in version 6.1.7  */   
/*                                                                        */
/**************************************************************************/
VOID  _tx_thread_initialize(VOID)
{
 8014830:	b580      	push	{r7, lr}
 8014832:	af00      	add	r7, sp, #0
       respectively.  */

#ifndef TX_DISABLE_REDUNDANT_CLEARING

    /* Set current thread pointer to NULL.  */
    TX_THREAD_SET_CURRENT(TX_NULL)
 8014834:	4b12      	ldr	r3, [pc, #72]	; (8014880 <_tx_thread_initialize+0x50>)
 8014836:	2200      	movs	r2, #0
 8014838:	601a      	str	r2, [r3, #0]

    /* Initialize the execute thread pointer to NULL.  */
    _tx_thread_execute_ptr =  TX_NULL;
 801483a:	4b12      	ldr	r3, [pc, #72]	; (8014884 <_tx_thread_initialize+0x54>)
 801483c:	2200      	movs	r2, #0
 801483e:	601a      	str	r2, [r3, #0]
 8014840:	4b11      	ldr	r3, [pc, #68]	; (8014888 <_tx_thread_initialize+0x58>)
 8014842:	2200      	movs	r2, #0
 8014844:	601a      	str	r2, [r3, #0]
#endif
#endif

    /* Setup the highest priority variable to the max, indicating no thread is currently
       ready.  */
    _tx_thread_highest_priority =  ((UINT) TX_MAX_PRIORITIES);
 8014846:	4b11      	ldr	r3, [pc, #68]	; (801488c <_tx_thread_initialize+0x5c>)
 8014848:	2220      	movs	r2, #32
 801484a:	601a      	str	r2, [r3, #0]


#ifndef TX_DISABLE_REDUNDANT_CLEARING

    /* Initialize the array of priority head pointers.  */
    TX_MEMSET(&_tx_thread_priority_list[0], 0, (sizeof(_tx_thread_priority_list)));
 801484c:	2280      	movs	r2, #128	; 0x80
 801484e:	2100      	movs	r1, #0
 8014850:	480f      	ldr	r0, [pc, #60]	; (8014890 <_tx_thread_initialize+0x60>)
 8014852:	f00b f813 	bl	801f87c <memset>

    /* Initialize the head pointer of the created threads list and the
       number of threads created.  */
    _tx_thread_created_ptr =        TX_NULL;
 8014856:	4b0f      	ldr	r3, [pc, #60]	; (8014894 <_tx_thread_initialize+0x64>)
 8014858:	2200      	movs	r2, #0
 801485a:	601a      	str	r2, [r3, #0]
    _tx_thread_created_count =      TX_EMPTY;
 801485c:	4b0e      	ldr	r3, [pc, #56]	; (8014898 <_tx_thread_initialize+0x68>)
 801485e:	2200      	movs	r2, #0
 8014860:	601a      	str	r2, [r3, #0]

    /* Clear the global preempt disable variable.  */
    _tx_thread_preempt_disable =    ((UINT) 0);
 8014862:	4b0e      	ldr	r3, [pc, #56]	; (801489c <_tx_thread_initialize+0x6c>)
 8014864:	2200      	movs	r2, #0
 8014866:	601a      	str	r2, [r3, #0]

    /* Initialize the thread mutex release function pointer.  */
    _tx_thread_mutex_release =      TX_NULL;
 8014868:	4b0d      	ldr	r3, [pc, #52]	; (80148a0 <_tx_thread_initialize+0x70>)
 801486a:	2200      	movs	r2, #0
 801486c:	601a      	str	r2, [r3, #0]
#endif
#ifdef TX_DISABLE_REDUNDANT_CLEARING
                            | (((ULONG) 1) << 18)
#endif
#ifdef TX_DISABLE_NOTIFY_CALLBACKS
                            | (((ULONG) 1) << 17)
 801486e:	4b0d      	ldr	r3, [pc, #52]	; (80148a4 <_tx_thread_initialize+0x74>)
 8014870:	681b      	ldr	r3, [r3, #0]
 8014872:	f043 7385 	orr.w	r3, r3, #17432576	; 0x10a0000
    _tx_build_options =  _tx_build_options 
 8014876:	4a0b      	ldr	r2, [pc, #44]	; (80148a4 <_tx_thread_initialize+0x74>)
 8014878:	6013      	str	r3, [r2, #0]
#endif
#if TX_PORT_SPECIFIC_BUILD_OPTIONS != 0
                            | TX_PORT_SPECIFIC_BUILD_OPTIONS
#endif
                            ;
}
 801487a:	bf00      	nop
 801487c:	bd80      	pop	{r7, pc}
 801487e:	bf00      	nop
 8014880:	24031bc4 	.word	0x24031bc4
 8014884:	24031bc8 	.word	0x24031bc8
 8014888:	24031bd4 	.word	0x24031bd4
 801488c:	24031bd8 	.word	0x24031bd8
 8014890:	24031bdc 	.word	0x24031bdc
 8014894:	24031bcc 	.word	0x24031bcc
 8014898:	24031bd0 	.word	0x24031bd0
 801489c:	24031c5c 	.word	0x24031c5c
 80148a0:	24031c60 	.word	0x24031c60
 80148a4:	24031c64 	.word	0x24031c64

080148a8 <_tx_thread_preemption_change>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
UINT  _tx_thread_preemption_change(TX_THREAD *thread_ptr, UINT new_threshold, UINT *old_threshold)
{
 80148a8:	b580      	push	{r7, lr}
 80148aa:	b08c      	sub	sp, #48	; 0x30
 80148ac:	af00      	add	r7, sp, #0
 80148ae:	60f8      	str	r0, [r7, #12]
 80148b0:	60b9      	str	r1, [r7, #8]
 80148b2:	607a      	str	r2, [r7, #4]
#endif
UINT        status;


    /* Default status to success.  */
    status =  TX_SUCCESS;
 80148b4:	2300      	movs	r3, #0
 80148b6:	62bb      	str	r3, [r7, #40]	; 0x28
#ifdef TX_DISABLE_PREEMPTION_THRESHOLD

    /* Only allow 0 (disable all preemption) and returning preemption-threshold to the 
       current thread priority if preemption-threshold is disabled. All other threshold
       values are converted to 0.  */
    if (thread_ptr -> tx_thread_user_priority != new_threshold)
 80148b8:	68fb      	ldr	r3, [r7, #12]
 80148ba:	f8d3 3094 	ldr.w	r3, [r3, #148]	; 0x94
 80148be:	68ba      	ldr	r2, [r7, #8]
 80148c0:	429a      	cmp	r2, r3
 80148c2:	d004      	beq.n	80148ce <_tx_thread_preemption_change+0x26>
    {
    
        /* Is the new threshold zero?  */
        if (new_threshold != ((UINT) 0))
 80148c4:	68bb      	ldr	r3, [r7, #8]
 80148c6:	2b00      	cmp	r3, #0
 80148c8:	d001      	beq.n	80148ce <_tx_thread_preemption_change+0x26>
        {
        
            /* Convert the new threshold to disable all preemption, since preemption-threshold is
               not supported.  */
            new_threshold =  ((UINT) 0);
 80148ca:	2300      	movs	r3, #0
 80148cc:	60bb      	str	r3, [r7, #8]
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 80148ce:	f3ef 8310 	mrs	r3, PRIMASK
 80148d2:	627b      	str	r3, [r7, #36]	; 0x24
    return(posture);
 80148d4:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    int_posture = __get_interrupt_posture();
 80148d6:	623b      	str	r3, [r7, #32]
    __asm__ volatile ("CPSID i" : : : "memory");
 80148d8:	b672      	cpsid	i
    return(int_posture);
 80148da:	6a3b      	ldr	r3, [r7, #32]
        }
    }
#endif

    /* Lockout interrupts while the thread is being resumed.  */
    TX_DISABLE
 80148dc:	62fb      	str	r3, [r7, #44]	; 0x2c

    /* Log this kernel call.  */
    TX_EL_THREAD_PREEMPTION_CHANGE_INSERT

    /* Determine if the new threshold is greater than the current user priority.  */
    if (new_threshold > thread_ptr -> tx_thread_user_priority)
 80148de:	68fb      	ldr	r3, [r7, #12]
 80148e0:	f8d3 3094 	ldr.w	r3, [r3, #148]	; 0x94
 80148e4:	68ba      	ldr	r2, [r7, #8]
 80148e6:	429a      	cmp	r2, r3
 80148e8:	d902      	bls.n	80148f0 <_tx_thread_preemption_change+0x48>
    {
            
        /* Return error.  */
        status =  TX_THRESH_ERROR;
 80148ea:	2318      	movs	r3, #24
 80148ec:	62bb      	str	r3, [r7, #40]	; 0x28
 80148ee:	e03e      	b.n	801496e <_tx_thread_preemption_change+0xc6>
            }
        }
#endif

        /* Return the user's preemption-threshold.   */
        *old_threshold =  thread_ptr -> tx_thread_user_preempt_threshold;
 80148f0:	68fb      	ldr	r3, [r7, #12]
 80148f2:	f8d3 2098 	ldr.w	r2, [r3, #152]	; 0x98
 80148f6:	687b      	ldr	r3, [r7, #4]
 80148f8:	601a      	str	r2, [r3, #0]

        /* Setup the new threshold.  */
        thread_ptr -> tx_thread_user_preempt_threshold =  new_threshold;
 80148fa:	68fb      	ldr	r3, [r7, #12]
 80148fc:	68ba      	ldr	r2, [r7, #8]
 80148fe:	f8c3 2098 	str.w	r2, [r3, #152]	; 0x98

        /* Determine if the new threshold represents a higher priority than the priority inheritance threshold.  */
        if (new_threshold < thread_ptr -> tx_thread_inherit_priority)
 8014902:	68fb      	ldr	r3, [r7, #12]
 8014904:	f8d3 309c 	ldr.w	r3, [r3, #156]	; 0x9c
 8014908:	68ba      	ldr	r2, [r7, #8]
 801490a:	429a      	cmp	r2, r3
 801490c:	d203      	bcs.n	8014916 <_tx_thread_preemption_change+0x6e>
        {
    
            /* Update the actual preemption-threshold with the new threshold.  */
            thread_ptr -> tx_thread_preempt_threshold =  new_threshold;
 801490e:	68fb      	ldr	r3, [r7, #12]
 8014910:	68ba      	ldr	r2, [r7, #8]
 8014912:	63da      	str	r2, [r3, #60]	; 0x3c
 8014914:	e004      	b.n	8014920 <_tx_thread_preemption_change+0x78>
        }
        else
        {
    
            /* Update the actual preemption-threshold with the priority inheritance.  */
            thread_ptr -> tx_thread_preempt_threshold =  thread_ptr -> tx_thread_inherit_priority;
 8014916:	68fb      	ldr	r3, [r7, #12]
 8014918:	f8d3 209c 	ldr.w	r2, [r3, #156]	; 0x9c
 801491c:	68fb      	ldr	r3, [r7, #12]
 801491e:	63da      	str	r2, [r3, #60]	; 0x3c
        }

        /* Is the thread priority less than the current highest priority?  If not, no preemption is required.  */
        if (_tx_thread_highest_priority < thread_ptr -> tx_thread_priority)
 8014920:	68fb      	ldr	r3, [r7, #12]
 8014922:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 8014924:	4b17      	ldr	r3, [pc, #92]	; (8014984 <_tx_thread_preemption_change+0xdc>)
 8014926:	681b      	ldr	r3, [r3, #0]
 8014928:	429a      	cmp	r2, r3
 801492a:	d920      	bls.n	801496e <_tx_thread_preemption_change+0xc6>
        {

            /* Is the new thread preemption-threshold less than the current highest priority?  If not, no preemption is required.  */
            if (_tx_thread_highest_priority < new_threshold)
 801492c:	4b15      	ldr	r3, [pc, #84]	; (8014984 <_tx_thread_preemption_change+0xdc>)
 801492e:	681b      	ldr	r3, [r3, #0]
 8014930:	68ba      	ldr	r2, [r7, #8]
 8014932:	429a      	cmp	r2, r3
 8014934:	d91b      	bls.n	801496e <_tx_thread_preemption_change+0xc6>
            {

                /* If the current execute pointer is the same at this thread, preemption needs to take place.  */
                if (_tx_thread_execute_ptr == thread_ptr)
 8014936:	4b14      	ldr	r3, [pc, #80]	; (8014988 <_tx_thread_preemption_change+0xe0>)
 8014938:	681b      	ldr	r3, [r3, #0]
 801493a:	68fa      	ldr	r2, [r7, #12]
 801493c:	429a      	cmp	r2, r3
 801493e:	d116      	bne.n	801496e <_tx_thread_preemption_change+0xc6>
                        _tx_thread_performance_execute_log[_tx_thread_performance__execute_log_index] =  _tx_thread_execute_ptr;
                    }
#endif

                    /* Setup the highest priority thread to execute.  */
                    _tx_thread_execute_ptr =  _tx_thread_priority_list[_tx_thread_highest_priority];
 8014940:	4b10      	ldr	r3, [pc, #64]	; (8014984 <_tx_thread_preemption_change+0xdc>)
 8014942:	681b      	ldr	r3, [r3, #0]
 8014944:	4a11      	ldr	r2, [pc, #68]	; (801498c <_tx_thread_preemption_change+0xe4>)
 8014946:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 801494a:	4a0f      	ldr	r2, [pc, #60]	; (8014988 <_tx_thread_preemption_change+0xe0>)
 801494c:	6013      	str	r3, [r2, #0]
 801494e:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8014950:	617b      	str	r3, [r7, #20]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 8014952:	697b      	ldr	r3, [r7, #20]
 8014954:	f383 8810 	msr	PRIMASK, r3
}
 8014958:	bf00      	nop

                    /* Restore interrupts.  */
                    TX_RESTORE

                    /* Check for preemption.  */
                    _tx_thread_system_preempt_check();
 801495a:	f000 f9ab 	bl	8014cb4 <_tx_thread_system_preempt_check>
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 801495e:	f3ef 8310 	mrs	r3, PRIMASK
 8014962:	61fb      	str	r3, [r7, #28]
    return(posture);
 8014964:	69fb      	ldr	r3, [r7, #28]
    int_posture = __get_interrupt_posture();
 8014966:	61bb      	str	r3, [r7, #24]
    __asm__ volatile ("CPSID i" : : : "memory");
 8014968:	b672      	cpsid	i
    return(int_posture);
 801496a:	69bb      	ldr	r3, [r7, #24]
                    
                    /* Disable interrupts.  */
                    TX_DISABLE
 801496c:	62fb      	str	r3, [r7, #44]	; 0x2c
 801496e:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8014970:	613b      	str	r3, [r7, #16]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 8014972:	693b      	ldr	r3, [r7, #16]
 8014974:	f383 8810 	msr	PRIMASK, r3
}
 8014978:	bf00      	nop

    /* Restore interrupts.  */
    TX_RESTORE
    
    /* Return completion status.  */
    return(status);
 801497a:	6abb      	ldr	r3, [r7, #40]	; 0x28
}
 801497c:	4618      	mov	r0, r3
 801497e:	3730      	adds	r7, #48	; 0x30
 8014980:	46bd      	mov	sp, r7
 8014982:	bd80      	pop	{r7, pc}
 8014984:	24031bd8 	.word	0x24031bd8
 8014988:	24031bc8 	.word	0x24031bc8
 801498c:	24031bdc 	.word	0x24031bdc

08014990 <_tx_thread_relinquish>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
VOID  _tx_thread_relinquish(VOID)
{
 8014990:	b480      	push	{r7}
 8014992:	b08b      	sub	sp, #44	; 0x2c
 8014994:	af00      	add	r7, sp, #0
UINT            priority;
TX_THREAD       *thread_ptr;


    /* Pickup thread pointer.  */
    TX_THREAD_GET_CURRENT(thread_ptr)
 8014996:	4b2b      	ldr	r3, [pc, #172]	; (8014a44 <_tx_thread_relinquish+0xb4>)
 8014998:	681b      	ldr	r3, [r3, #0]
 801499a:	627b      	str	r3, [r7, #36]	; 0x24
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 801499c:	f3ef 8310 	mrs	r3, PRIMASK
 80149a0:	61bb      	str	r3, [r7, #24]
    return(posture);
 80149a2:	69bb      	ldr	r3, [r7, #24]
    int_posture = __get_interrupt_posture();
 80149a4:	617b      	str	r3, [r7, #20]
    __asm__ volatile ("CPSID i" : : : "memory");
 80149a6:	b672      	cpsid	i
    return(int_posture);
 80149a8:	697b      	ldr	r3, [r7, #20]
    /* Check this thread's stack.  */
    TX_THREAD_STACK_CHECK(thread_ptr)
#endif

    /* Disable interrupts.  */
    TX_DISABLE
 80149aa:	623b      	str	r3, [r7, #32]

#ifndef TX_NO_TIMER

    /* Reset time slice for current thread.  */
    _tx_timer_time_slice =  thread_ptr -> tx_thread_new_time_slice;
 80149ac:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80149ae:	69db      	ldr	r3, [r3, #28]
 80149b0:	4a25      	ldr	r2, [pc, #148]	; (8014a48 <_tx_thread_relinquish+0xb8>)
 80149b2:	6013      	str	r3, [r2, #0]
#endif

    /* Pickup the thread's priority.  */
    priority =  thread_ptr -> tx_thread_priority;
 80149b4:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80149b6:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 80149b8:	61fb      	str	r3, [r7, #28]

    /* Determine if there is another thread at the same priority.  */
    if (thread_ptr -> tx_thread_ready_next != thread_ptr)
 80149ba:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80149bc:	6a1b      	ldr	r3, [r3, #32]
 80149be:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 80149c0:	429a      	cmp	r2, r3
 80149c2:	d009      	beq.n	80149d8 <_tx_thread_relinquish+0x48>
    {

        /* Yes, there is another thread at this priority, make it the highest at
           this priority level.  */
        _tx_thread_priority_list[priority] =  thread_ptr -> tx_thread_ready_next;
 80149c4:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80149c6:	6a1a      	ldr	r2, [r3, #32]
 80149c8:	4920      	ldr	r1, [pc, #128]	; (8014a4c <_tx_thread_relinquish+0xbc>)
 80149ca:	69fb      	ldr	r3, [r7, #28]
 80149cc:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    
        /* Mark the new thread as the one to execute.  */
        _tx_thread_execute_ptr = thread_ptr -> tx_thread_ready_next;
 80149d0:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80149d2:	6a1b      	ldr	r3, [r3, #32]
 80149d4:	4a1e      	ldr	r2, [pc, #120]	; (8014a50 <_tx_thread_relinquish+0xc0>)
 80149d6:	6013      	str	r3, [r2, #0]
    }

    /* Determine if there is a higher-priority thread ready.  */
    if (_tx_thread_highest_priority < priority)
 80149d8:	4b1e      	ldr	r3, [pc, #120]	; (8014a54 <_tx_thread_relinquish+0xc4>)
 80149da:	681b      	ldr	r3, [r3, #0]
 80149dc:	69fa      	ldr	r2, [r7, #28]
 80149de:	429a      	cmp	r2, r3
 80149e0:	d906      	bls.n	80149f0 <_tx_thread_relinquish+0x60>
    {

        /* Yes, there is a higher priority thread ready to execute.  Make
           it visible to the thread scheduler.  */
        _tx_thread_execute_ptr =  _tx_thread_priority_list[_tx_thread_highest_priority];
 80149e2:	4b1c      	ldr	r3, [pc, #112]	; (8014a54 <_tx_thread_relinquish+0xc4>)
 80149e4:	681b      	ldr	r3, [r3, #0]
 80149e6:	4a19      	ldr	r2, [pc, #100]	; (8014a4c <_tx_thread_relinquish+0xbc>)
 80149e8:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 80149ec:	4a18      	ldr	r2, [pc, #96]	; (8014a50 <_tx_thread_relinquish+0xc0>)
 80149ee:	6013      	str	r3, [r2, #0]
 80149f0:	6a3b      	ldr	r3, [r7, #32]
 80149f2:	613b      	str	r3, [r7, #16]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 80149f4:	693b      	ldr	r3, [r7, #16]
 80149f6:	f383 8810 	msr	PRIMASK, r3
}
 80149fa:	bf00      	nop

    /* Restore previous interrupt posture.  */
    TX_RESTORE

    /* Determine if this thread needs to return to the system.  */
    if (_tx_thread_execute_ptr != thread_ptr)
 80149fc:	4b14      	ldr	r3, [pc, #80]	; (8014a50 <_tx_thread_relinquish+0xc0>)
 80149fe:	681b      	ldr	r3, [r3, #0]
 8014a00:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8014a02:	429a      	cmp	r2, r3
 8014a04:	d017      	beq.n	8014a36 <_tx_thread_relinquish+0xa6>
__attribute__( ( always_inline ) ) static inline void _tx_thread_system_return_inline(void)
{
unsigned int interrupt_save;

    /* Set PendSV to invoke ThreadX scheduler.  */
    *((ULONG *) 0xE000ED04) = ((ULONG) 0x10000000);
 8014a06:	4b14      	ldr	r3, [pc, #80]	; (8014a58 <_tx_thread_relinquish+0xc8>)
 8014a08:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 8014a0c:	601a      	str	r2, [r3, #0]
    __asm__ volatile (" MRS  %0,IPSR ": "=r" (ipsr_value) );
 8014a0e:	f3ef 8305 	mrs	r3, IPSR
 8014a12:	60fb      	str	r3, [r7, #12]
    return(ipsr_value);
 8014a14:	68fb      	ldr	r3, [r7, #12]
    if (__get_ipsr_value() == 0)
 8014a16:	2b00      	cmp	r3, #0
 8014a18:	d10c      	bne.n	8014a34 <_tx_thread_relinquish+0xa4>
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 8014a1a:	f3ef 8310 	mrs	r3, PRIMASK
 8014a1e:	60bb      	str	r3, [r7, #8]
    return(posture);
 8014a20:	68bb      	ldr	r3, [r7, #8]
    {
        interrupt_save = __get_interrupt_posture();
 8014a22:	607b      	str	r3, [r7, #4]
    __asm__ volatile ("CPSIE  i": : : "memory");
 8014a24:	b662      	cpsie	i
}
 8014a26:	bf00      	nop
 8014a28:	687b      	ldr	r3, [r7, #4]
 8014a2a:	603b      	str	r3, [r7, #0]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 8014a2c:	683b      	ldr	r3, [r7, #0]
 8014a2e:	f383 8810 	msr	PRIMASK, r3
}
 8014a32:	bf00      	nop
#else
        __enable_interrupts();
#endif
        __restore_interrupt(interrupt_save);
    }
}
 8014a34:	bf00      	nop

        /* Transfer control to the system so the scheduler can execute
           the next thread.  */
        _tx_thread_system_return();
    }
}
 8014a36:	bf00      	nop
 8014a38:	372c      	adds	r7, #44	; 0x2c
 8014a3a:	46bd      	mov	sp, r7
 8014a3c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8014a40:	4770      	bx	lr
 8014a42:	bf00      	nop
 8014a44:	24031bc4 	.word	0x24031bc4
 8014a48:	240321cc 	.word	0x240321cc
 8014a4c:	24031bdc 	.word	0x24031bdc
 8014a50:	24031bc8 	.word	0x24031bc8
 8014a54:	24031bd8 	.word	0x24031bd8
 8014a58:	e000ed04 	.word	0xe000ed04

08014a5c <_tx_thread_resume>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
UINT  _tx_thread_resume(TX_THREAD *thread_ptr)
{
 8014a5c:	b580      	push	{r7, lr}
 8014a5e:	b08c      	sub	sp, #48	; 0x30
 8014a60:	af00      	add	r7, sp, #0
 8014a62:	6078      	str	r0, [r7, #4]

TX_INTERRUPT_SAVE_AREA

UINT        status;
TX_THREAD   *saved_thread_ptr;
UINT        saved_threshold =  ((UINT) 0);
 8014a64:	2300      	movs	r3, #0
 8014a66:	627b      	str	r3, [r7, #36]	; 0x24
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 8014a68:	f3ef 8310 	mrs	r3, PRIMASK
 8014a6c:	61fb      	str	r3, [r7, #28]
    return(posture);
 8014a6e:	69fb      	ldr	r3, [r7, #28]
    int_posture = __get_interrupt_posture();
 8014a70:	61bb      	str	r3, [r7, #24]
    __asm__ volatile ("CPSID i" : : : "memory");
 8014a72:	b672      	cpsid	i
    return(int_posture);
 8014a74:	69bb      	ldr	r3, [r7, #24]
    TX_THREAD_STACK_CHECK(thread_ptr)
#endif
#endif

    /* Lockout interrupts while the thread is being resumed.  */
    TX_DISABLE
 8014a76:	623b      	str	r3, [r7, #32]
    /* Log this kernel call.  */
    TX_EL_THREAD_RESUME_INSERT

    /* Determine if the thread is suspended or in the process of suspending.
       If so, call the thread resume processing.  */
    if (thread_ptr -> tx_thread_state == TX_SUSPENDED)
 8014a78:	687b      	ldr	r3, [r7, #4]
 8014a7a:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8014a7c:	2b03      	cmp	r3, #3
 8014a7e:	d12f      	bne.n	8014ae0 <_tx_thread_resume+0x84>
    __asm__ volatile (" MRS  %0,IPSR ": "=r" (ipsr_value) );
 8014a80:	f3ef 8305 	mrs	r3, IPSR
 8014a84:	617b      	str	r3, [r7, #20]
    return(ipsr_value);
 8014a86:	697a      	ldr	r2, [r7, #20]
    {

        /* Determine if the create call is being called from initialization.  */
        if (TX_THREAD_GET_SYSTEM_STATE() >= TX_INITIALIZE_IN_PROGRESS)
 8014a88:	4b21      	ldr	r3, [pc, #132]	; (8014b10 <_tx_thread_resume+0xb4>)
 8014a8a:	681b      	ldr	r3, [r3, #0]
 8014a8c:	4313      	orrs	r3, r2
 8014a8e:	f1b3 3ff0 	cmp.w	r3, #4042322160	; 0xf0f0f0f0
 8014a92:	d30d      	bcc.n	8014ab0 <_tx_thread_resume+0x54>

            /* Pickup the current thread execute pointer, which corresponds to the
               highest priority thread ready to execute.  Interrupt lockout is 
               not required, since interrupts are assumed to be disabled during 
               initialization.  */
            saved_thread_ptr =  _tx_thread_execute_ptr;
 8014a94:	4b1f      	ldr	r3, [pc, #124]	; (8014b14 <_tx_thread_resume+0xb8>)
 8014a96:	681b      	ldr	r3, [r3, #0]
 8014a98:	62bb      	str	r3, [r7, #40]	; 0x28

            /* Determine if there is thread ready for execution.  */
            if (saved_thread_ptr != TX_NULL)
 8014a9a:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8014a9c:	2b00      	cmp	r3, #0
 8014a9e:	d009      	beq.n	8014ab4 <_tx_thread_resume+0x58>
            {
                
                /* Yes, a thread is ready for execution when initialization completes.  */

                /* Save the current preemption-threshold.  */
                saved_threshold =  saved_thread_ptr -> tx_thread_preempt_threshold;
 8014aa0:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8014aa2:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 8014aa4:	627b      	str	r3, [r7, #36]	; 0x24

                /* For initialization, temporarily set the preemption-threshold to the 
                   priority level to make sure the highest-priority thread runs once 
                   initialization is complete.  */
                saved_thread_ptr -> tx_thread_preempt_threshold =  saved_thread_ptr -> tx_thread_priority;
 8014aa6:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8014aa8:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 8014aaa:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8014aac:	63da      	str	r2, [r3, #60]	; 0x3c
 8014aae:	e001      	b.n	8014ab4 <_tx_thread_resume+0x58>
        }
        else
        {

            /* Simply set the saved thread pointer to NULL.  */
            saved_thread_ptr =  TX_NULL;
 8014ab0:	2300      	movs	r3, #0
 8014ab2:	62bb      	str	r3, [r7, #40]	; 0x28
        /* Restore interrupts.  */
        TX_RESTORE
#else

        /* Temporarily disable preemption.  */
        _tx_thread_preempt_disable++;
 8014ab4:	4b18      	ldr	r3, [pc, #96]	; (8014b18 <_tx_thread_resume+0xbc>)
 8014ab6:	681b      	ldr	r3, [r3, #0]
 8014ab8:	3301      	adds	r3, #1
 8014aba:	4a17      	ldr	r2, [pc, #92]	; (8014b18 <_tx_thread_resume+0xbc>)
 8014abc:	6013      	str	r3, [r2, #0]
 8014abe:	6a3b      	ldr	r3, [r7, #32]
 8014ac0:	613b      	str	r3, [r7, #16]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 8014ac2:	693b      	ldr	r3, [r7, #16]
 8014ac4:	f383 8810 	msr	PRIMASK, r3
}
 8014ac8:	bf00      	nop

        /* Restore interrupts.  */
        TX_RESTORE

        /* Call the actual resume service to resume the thread.  */
        _tx_thread_system_resume(thread_ptr);
 8014aca:	6878      	ldr	r0, [r7, #4]
 8014acc:	f000 f92c 	bl	8014d28 <_tx_thread_system_resume>
#endif

        /* Determine if the thread's preemption-threshold needs to be restored.  */
        if (saved_thread_ptr != TX_NULL)
 8014ad0:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8014ad2:	2b00      	cmp	r3, #0
 8014ad4:	d002      	beq.n	8014adc <_tx_thread_resume+0x80>
        {

            /* Yes, restore the previous highest-priority thread's preemption-threshold. This
               can only happen if this routine is called from initialization.  */
            saved_thread_ptr -> tx_thread_preempt_threshold =  saved_threshold;
 8014ad6:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8014ad8:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8014ada:	63da      	str	r2, [r3, #60]	; 0x3c
        /* Setup successful return status.  */
        status =  TX_SUCCESS;
#else

        /* Return successful completion.  */
        return(TX_SUCCESS);
 8014adc:	2300      	movs	r3, #0
 8014ade:	e012      	b.n	8014b06 <_tx_thread_resume+0xaa>
        
        /* Setup successful return status.  */
        status =  TX_SUCCESS;
#endif
    }
    else if (thread_ptr -> tx_thread_delayed_suspend == TX_TRUE)
 8014ae0:	687b      	ldr	r3, [r7, #4]
 8014ae2:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8014ae4:	2b01      	cmp	r3, #1
 8014ae6:	d105      	bne.n	8014af4 <_tx_thread_resume+0x98>
    {

        /* Clear the delayed suspension.  */
        thread_ptr -> tx_thread_delayed_suspend =  TX_FALSE;
 8014ae8:	687b      	ldr	r3, [r7, #4]
 8014aea:	2200      	movs	r2, #0
 8014aec:	635a      	str	r2, [r3, #52]	; 0x34

        /* Setup delayed suspend lifted return status.  */
        status =  TX_SUSPEND_LIFTED;
 8014aee:	2319      	movs	r3, #25
 8014af0:	62fb      	str	r3, [r7, #44]	; 0x2c
 8014af2:	e001      	b.n	8014af8 <_tx_thread_resume+0x9c>
    }
    else
    {

        /* Setup invalid resume return status.  */
        status =  TX_RESUME_ERROR;
 8014af4:	2312      	movs	r3, #18
 8014af6:	62fb      	str	r3, [r7, #44]	; 0x2c
 8014af8:	6a3b      	ldr	r3, [r7, #32]
 8014afa:	60fb      	str	r3, [r7, #12]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 8014afc:	68fb      	ldr	r3, [r7, #12]
 8014afe:	f383 8810 	msr	PRIMASK, r3
}
 8014b02:	bf00      	nop
        }
    }
#endif

    /* Return completion status. */
    return(status);
 8014b04:	6afb      	ldr	r3, [r7, #44]	; 0x2c
}
 8014b06:	4618      	mov	r0, r3
 8014b08:	3730      	adds	r7, #48	; 0x30
 8014b0a:	46bd      	mov	sp, r7
 8014b0c:	bd80      	pop	{r7, pc}
 8014b0e:	bf00      	nop
 8014b10:	24000078 	.word	0x24000078
 8014b14:	24031bc8 	.word	0x24031bc8
 8014b18:	24031c5c 	.word	0x24031c5c

08014b1c <_tx_thread_shell_entry>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
VOID  _tx_thread_shell_entry(VOID)
{
 8014b1c:	b580      	push	{r7, lr}
 8014b1e:	b088      	sub	sp, #32
 8014b20:	af00      	add	r7, sp, #0
VOID            (*entry_exit_notify)(TX_THREAD *notify_thread_ptr, UINT type);
#endif


    /* Pickup thread pointer.  */
    TX_THREAD_GET_CURRENT(thread_ptr)
 8014b22:	4b21      	ldr	r3, [pc, #132]	; (8014ba8 <_tx_thread_shell_entry+0x8c>)
 8014b24:	681b      	ldr	r3, [r3, #0]
 8014b26:	61fb      	str	r3, [r7, #28]
        (entry_exit_notify)(thread_ptr, TX_THREAD_ENTRY);
    }
#endif

    /* Call current thread's entry function.  */
    (thread_ptr -> tx_thread_entry) (thread_ptr -> tx_thread_entry_parameter);
 8014b28:	69fb      	ldr	r3, [r7, #28]
 8014b2a:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 8014b2c:	69fa      	ldr	r2, [r7, #28]
 8014b2e:	6c92      	ldr	r2, [r2, #72]	; 0x48
 8014b30:	4610      	mov	r0, r2
 8014b32:	4798      	blx	r3

    /* Suspend thread with a "completed" state.  */

    /* Determine if the application is using mutexes.  */
    if (_tx_thread_mutex_release != TX_NULL)
 8014b34:	4b1d      	ldr	r3, [pc, #116]	; (8014bac <_tx_thread_shell_entry+0x90>)
 8014b36:	681b      	ldr	r3, [r3, #0]
 8014b38:	2b00      	cmp	r3, #0
 8014b3a:	d003      	beq.n	8014b44 <_tx_thread_shell_entry+0x28>
    {

        /* Yes, call the mutex release function via a function pointer that 
           is setup during mutex initialization.  */
        (_tx_thread_mutex_release)(thread_ptr);
 8014b3c:	4b1b      	ldr	r3, [pc, #108]	; (8014bac <_tx_thread_shell_entry+0x90>)
 8014b3e:	681b      	ldr	r3, [r3, #0]
 8014b40:	69f8      	ldr	r0, [r7, #28]
 8014b42:	4798      	blx	r3
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 8014b44:	f3ef 8310 	mrs	r3, PRIMASK
 8014b48:	607b      	str	r3, [r7, #4]
    return(posture);
 8014b4a:	687b      	ldr	r3, [r7, #4]
    int_posture = __get_interrupt_posture();
 8014b4c:	603b      	str	r3, [r7, #0]
    __asm__ volatile ("CPSID i" : : : "memory");
 8014b4e:	b672      	cpsid	i
    return(int_posture);
 8014b50:	683b      	ldr	r3, [r7, #0]
    }

    /* Lockout interrupts while the thread state is setup.  */
    TX_DISABLE
 8014b52:	61bb      	str	r3, [r7, #24]
    entry_exit_notify =  thread_ptr -> tx_thread_entry_exit_notify;
#endif

    /* Set the status to suspending, in order to indicate the suspension
       is in progress.  */
    thread_ptr -> tx_thread_state =  TX_COMPLETED;
 8014b54:	69fb      	ldr	r3, [r7, #28]
 8014b56:	2201      	movs	r2, #1
 8014b58:	631a      	str	r2, [r3, #48]	; 0x30
    /* Restore interrupts.  */
    TX_RESTORE
#else

    /* Set the suspending flag. */
    thread_ptr -> tx_thread_suspending =  TX_TRUE;
 8014b5a:	69fb      	ldr	r3, [r7, #28]
 8014b5c:	2201      	movs	r2, #1
 8014b5e:	639a      	str	r2, [r3, #56]	; 0x38

    /* Setup for no timeout period.  */
    thread_ptr -> tx_thread_timer.tx_timer_internal_remaining_ticks =  ((ULONG) 0);
 8014b60:	69fb      	ldr	r3, [r7, #28]
 8014b62:	2200      	movs	r2, #0
 8014b64:	64da      	str	r2, [r3, #76]	; 0x4c

    /* Temporarily disable preemption.  */
    _tx_thread_preempt_disable++;
 8014b66:	4b12      	ldr	r3, [pc, #72]	; (8014bb0 <_tx_thread_shell_entry+0x94>)
 8014b68:	681b      	ldr	r3, [r3, #0]
 8014b6a:	3301      	adds	r3, #1
 8014b6c:	4a10      	ldr	r2, [pc, #64]	; (8014bb0 <_tx_thread_shell_entry+0x94>)
 8014b6e:	6013      	str	r3, [r2, #0]
 8014b70:	69bb      	ldr	r3, [r7, #24]
 8014b72:	60bb      	str	r3, [r7, #8]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 8014b74:	68bb      	ldr	r3, [r7, #8]
 8014b76:	f383 8810 	msr	PRIMASK, r3
}
 8014b7a:	bf00      	nop
    __asm__ volatile (" MRS  %0,CONTROL ": "=r" (control_value) );
 8014b7c:	f3ef 8314 	mrs	r3, CONTROL
 8014b80:	60fb      	str	r3, [r7, #12]
    return(control_value);
 8014b82:	68fb      	ldr	r3, [r7, #12]

    /* Restore interrupts.  */
    TX_RESTORE

    /* Perform any additional activities for tool or user purpose.  */
    TX_THREAD_COMPLETED_EXTENSION(thread_ptr)
 8014b84:	617b      	str	r3, [r7, #20]
 8014b86:	697b      	ldr	r3, [r7, #20]
 8014b88:	f023 0304 	bic.w	r3, r3, #4
 8014b8c:	617b      	str	r3, [r7, #20]
 8014b8e:	697b      	ldr	r3, [r7, #20]
 8014b90:	613b      	str	r3, [r7, #16]
    __asm__ volatile (" MSR  CONTROL,%0": : "r" (control_value): "memory" );
 8014b92:	693b      	ldr	r3, [r7, #16]
 8014b94:	f383 8814 	msr	CONTROL, r3
}
 8014b98:	bf00      	nop
        (entry_exit_notify)(thread_ptr, TX_THREAD_EXIT);
    }
#endif

    /* Call actual thread suspension routine.  */
    _tx_thread_system_suspend(thread_ptr);
 8014b9a:	69f8      	ldr	r0, [r7, #28]
 8014b9c:	f000 f9c4 	bl	8014f28 <_tx_thread_system_suspend>
#ifdef TX_SAFETY_CRITICAL

    /* If we ever get here, raise safety critical exception.  */
    TX_SAFETY_CRITICAL_EXCEPTION(__FILE__, __LINE__, 0);
#endif
}
 8014ba0:	bf00      	nop
 8014ba2:	3720      	adds	r7, #32
 8014ba4:	46bd      	mov	sp, r7
 8014ba6:	bd80      	pop	{r7, pc}
 8014ba8:	24031bc4 	.word	0x24031bc4
 8014bac:	24031c60 	.word	0x24031c60
 8014bb0:	24031c5c 	.word	0x24031c5c

08014bb4 <_tx_thread_sleep>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
UINT  _tx_thread_sleep(ULONG timer_ticks)
{
 8014bb4:	b580      	push	{r7, lr}
 8014bb6:	b08e      	sub	sp, #56	; 0x38
 8014bb8:	af00      	add	r7, sp, #0
 8014bba:	6078      	str	r0, [r7, #4]
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 8014bbc:	f3ef 8310 	mrs	r3, PRIMASK
 8014bc0:	62bb      	str	r3, [r7, #40]	; 0x28
    return(posture);
 8014bc2:	6abb      	ldr	r3, [r7, #40]	; 0x28
    int_posture = __get_interrupt_posture();
 8014bc4:	627b      	str	r3, [r7, #36]	; 0x24
    __asm__ volatile ("CPSID i" : : : "memory");
 8014bc6:	b672      	cpsid	i
    return(int_posture);
 8014bc8:	6a7b      	ldr	r3, [r7, #36]	; 0x24
UINT            status;
TX_THREAD       *thread_ptr;


    /* Lockout interrupts while the thread is being resumed.  */
    TX_DISABLE
 8014bca:	633b      	str	r3, [r7, #48]	; 0x30

    /* Pickup thread pointer.  */
    TX_THREAD_GET_CURRENT(thread_ptr)
 8014bcc:	4b35      	ldr	r3, [pc, #212]	; (8014ca4 <_tx_thread_sleep+0xf0>)
 8014bce:	681b      	ldr	r3, [r3, #0]
 8014bd0:	62fb      	str	r3, [r7, #44]	; 0x2c

    /* Determine if this is a legal request.  */

    /* Is there a current thread?  */
    if (thread_ptr == TX_NULL)
 8014bd2:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8014bd4:	2b00      	cmp	r3, #0
 8014bd6:	d108      	bne.n	8014bea <_tx_thread_sleep+0x36>
 8014bd8:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8014bda:	623b      	str	r3, [r7, #32]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 8014bdc:	6a3b      	ldr	r3, [r7, #32]
 8014bde:	f383 8810 	msr	PRIMASK, r3
}
 8014be2:	bf00      	nop

        /* Restore interrupts.  */
        TX_RESTORE
        
        /* Illegal caller of this service.  */
        status =  TX_CALLER_ERROR;
 8014be4:	2313      	movs	r3, #19
 8014be6:	637b      	str	r3, [r7, #52]	; 0x34
 8014be8:	e056      	b.n	8014c98 <_tx_thread_sleep+0xe4>
    __asm__ volatile (" MRS  %0,IPSR ": "=r" (ipsr_value) );
 8014bea:	f3ef 8305 	mrs	r3, IPSR
 8014bee:	61fb      	str	r3, [r7, #28]
    return(ipsr_value);
 8014bf0:	69fa      	ldr	r2, [r7, #28]
    }
    
    /* Is the caller an ISR or Initialization?  */
    else if (TX_THREAD_GET_SYSTEM_STATE() != ((ULONG) 0))
 8014bf2:	4b2d      	ldr	r3, [pc, #180]	; (8014ca8 <_tx_thread_sleep+0xf4>)
 8014bf4:	681b      	ldr	r3, [r3, #0]
 8014bf6:	4313      	orrs	r3, r2
 8014bf8:	2b00      	cmp	r3, #0
 8014bfa:	d008      	beq.n	8014c0e <_tx_thread_sleep+0x5a>
 8014bfc:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8014bfe:	61bb      	str	r3, [r7, #24]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 8014c00:	69bb      	ldr	r3, [r7, #24]
 8014c02:	f383 8810 	msr	PRIMASK, r3
}
 8014c06:	bf00      	nop

        /* Restore interrupts.  */
        TX_RESTORE
        
        /* Illegal caller of this service.  */
        status =  TX_CALLER_ERROR;
 8014c08:	2313      	movs	r3, #19
 8014c0a:	637b      	str	r3, [r7, #52]	; 0x34
 8014c0c:	e044      	b.n	8014c98 <_tx_thread_sleep+0xe4>
    }

#ifndef TX_TIMER_PROCESS_IN_ISR

    /* Is the caller the system timer thread?  */
    else if (thread_ptr == &_tx_timer_thread)
 8014c0e:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8014c10:	4a26      	ldr	r2, [pc, #152]	; (8014cac <_tx_thread_sleep+0xf8>)
 8014c12:	4293      	cmp	r3, r2
 8014c14:	d108      	bne.n	8014c28 <_tx_thread_sleep+0x74>
 8014c16:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8014c18:	617b      	str	r3, [r7, #20]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 8014c1a:	697b      	ldr	r3, [r7, #20]
 8014c1c:	f383 8810 	msr	PRIMASK, r3
}
 8014c20:	bf00      	nop

        /* Restore interrupts.  */
        TX_RESTORE
        
        /* Illegal caller of this service.  */
        status =  TX_CALLER_ERROR;
 8014c22:	2313      	movs	r3, #19
 8014c24:	637b      	str	r3, [r7, #52]	; 0x34
 8014c26:	e037      	b.n	8014c98 <_tx_thread_sleep+0xe4>
    }
#endif

    /* Determine if the requested number of ticks is zero.  */
    else if (timer_ticks == ((ULONG) 0))
 8014c28:	687b      	ldr	r3, [r7, #4]
 8014c2a:	2b00      	cmp	r3, #0
 8014c2c:	d108      	bne.n	8014c40 <_tx_thread_sleep+0x8c>
 8014c2e:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8014c30:	613b      	str	r3, [r7, #16]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 8014c32:	693b      	ldr	r3, [r7, #16]
 8014c34:	f383 8810 	msr	PRIMASK, r3
}
 8014c38:	bf00      	nop

        /* Restore interrupts.  */
        TX_RESTORE
      
        /* Just return with a successful status.  */
        status =  TX_SUCCESS;
 8014c3a:	2300      	movs	r3, #0
 8014c3c:	637b      	str	r3, [r7, #52]	; 0x34
 8014c3e:	e02b      	b.n	8014c98 <_tx_thread_sleep+0xe4>
    }
    else
    {

        /* Determine if the preempt disable flag is non-zero.  */
        if (_tx_thread_preempt_disable != ((UINT) 0))
 8014c40:	4b1b      	ldr	r3, [pc, #108]	; (8014cb0 <_tx_thread_sleep+0xfc>)
 8014c42:	681b      	ldr	r3, [r3, #0]
 8014c44:	2b00      	cmp	r3, #0
 8014c46:	d008      	beq.n	8014c5a <_tx_thread_sleep+0xa6>
 8014c48:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8014c4a:	60fb      	str	r3, [r7, #12]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 8014c4c:	68fb      	ldr	r3, [r7, #12]
 8014c4e:	f383 8810 	msr	PRIMASK, r3
}
 8014c52:	bf00      	nop

            /* Restore interrupts.  */
            TX_RESTORE
        
            /* Suspension is not allowed if the preempt disable flag is non-zero at this point - return error completion.  */
            status =  TX_CALLER_ERROR;
 8014c54:	2313      	movs	r3, #19
 8014c56:	637b      	str	r3, [r7, #52]	; 0x34
 8014c58:	e01e      	b.n	8014c98 <_tx_thread_sleep+0xe4>
            TX_EL_THREAD_SLEEP_INSERT

            /* Suspend the current thread.  */

            /* Set the state to suspended.  */
            thread_ptr -> tx_thread_state =    TX_SLEEP;
 8014c5a:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8014c5c:	2204      	movs	r2, #4
 8014c5e:	631a      	str	r2, [r3, #48]	; 0x30
            /* Restore interrupts.  */
            TX_RESTORE
#else

            /* Set the suspending flag. */
            thread_ptr -> tx_thread_suspending =  TX_TRUE;
 8014c60:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8014c62:	2201      	movs	r2, #1
 8014c64:	639a      	str	r2, [r3, #56]	; 0x38

            /* Initialize the status to successful.  */
            thread_ptr -> tx_thread_suspend_status =  TX_SUCCESS;
 8014c66:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8014c68:	2200      	movs	r2, #0
 8014c6a:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84

            /* Setup the timeout period.  */
            thread_ptr -> tx_thread_timer.tx_timer_internal_remaining_ticks =  timer_ticks;
 8014c6e:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8014c70:	687a      	ldr	r2, [r7, #4]
 8014c72:	64da      	str	r2, [r3, #76]	; 0x4c

            /* Temporarily disable preemption.  */
            _tx_thread_preempt_disable++;
 8014c74:	4b0e      	ldr	r3, [pc, #56]	; (8014cb0 <_tx_thread_sleep+0xfc>)
 8014c76:	681b      	ldr	r3, [r3, #0]
 8014c78:	3301      	adds	r3, #1
 8014c7a:	4a0d      	ldr	r2, [pc, #52]	; (8014cb0 <_tx_thread_sleep+0xfc>)
 8014c7c:	6013      	str	r3, [r2, #0]
 8014c7e:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8014c80:	60bb      	str	r3, [r7, #8]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 8014c82:	68bb      	ldr	r3, [r7, #8]
 8014c84:	f383 8810 	msr	PRIMASK, r3
}
 8014c88:	bf00      	nop

            /* Restore interrupts.  */
            TX_RESTORE

            /* Call actual thread suspension routine.  */
            _tx_thread_system_suspend(thread_ptr);
 8014c8a:	6af8      	ldr	r0, [r7, #44]	; 0x2c
 8014c8c:	f000 f94c 	bl	8014f28 <_tx_thread_system_suspend>
#endif

            /* Return status to the caller.  */
            status =  thread_ptr -> tx_thread_suspend_status;
 8014c90:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8014c92:	f8d3 3084 	ldr.w	r3, [r3, #132]	; 0x84
 8014c96:	637b      	str	r3, [r7, #52]	; 0x34
        }
    }
    
    /* Return completion status.  */
    return(status);
 8014c98:	6b7b      	ldr	r3, [r7, #52]	; 0x34
}
 8014c9a:	4618      	mov	r0, r3
 8014c9c:	3738      	adds	r7, #56	; 0x38
 8014c9e:	46bd      	mov	sp, r7
 8014ca0:	bd80      	pop	{r7, pc}
 8014ca2:	bf00      	nop
 8014ca4:	24031bc4 	.word	0x24031bc4
 8014ca8:	24000078 	.word	0x24000078
 8014cac:	24031d0c 	.word	0x24031d0c
 8014cb0:	24031c5c 	.word	0x24031c5c

08014cb4 <_tx_thread_system_preempt_check>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
VOID  _tx_thread_system_preempt_check(VOID)
{
 8014cb4:	b480      	push	{r7}
 8014cb6:	b089      	sub	sp, #36	; 0x24
 8014cb8:	af00      	add	r7, sp, #0
TX_THREAD       *current_thread;
TX_THREAD       *thread_ptr;


    /* Combine the system state and preempt disable flags into one for comparison.  */
    TX_THREAD_SYSTEM_RETURN_CHECK(combined_flags)
 8014cba:	4b17      	ldr	r3, [pc, #92]	; (8014d18 <_tx_thread_system_preempt_check+0x64>)
 8014cbc:	681b      	ldr	r3, [r3, #0]
 8014cbe:	61fb      	str	r3, [r7, #28]

    /* Determine if we are in a system state (ISR or Initialization) or internal preemption is disabled.  */
    if (combined_flags == ((ULONG) 0))
 8014cc0:	69fb      	ldr	r3, [r7, #28]
 8014cc2:	2b00      	cmp	r3, #0
 8014cc4:	d121      	bne.n	8014d0a <_tx_thread_system_preempt_check+0x56>
    {
    
        /* No, at thread execution level so continue checking for preemption.  */

        /* Pickup thread pointer.  */
        TX_THREAD_GET_CURRENT(current_thread)
 8014cc6:	4b15      	ldr	r3, [pc, #84]	; (8014d1c <_tx_thread_system_preempt_check+0x68>)
 8014cc8:	681b      	ldr	r3, [r3, #0]
 8014cca:	61bb      	str	r3, [r7, #24]

        /* Pickup the next execute pointer.  */
        thread_ptr =  _tx_thread_execute_ptr;
 8014ccc:	4b14      	ldr	r3, [pc, #80]	; (8014d20 <_tx_thread_system_preempt_check+0x6c>)
 8014cce:	681b      	ldr	r3, [r3, #0]
 8014cd0:	617b      	str	r3, [r7, #20]

        /* Determine if preemption should take place.  */
        if (current_thread != thread_ptr)
 8014cd2:	69ba      	ldr	r2, [r7, #24]
 8014cd4:	697b      	ldr	r3, [r7, #20]
 8014cd6:	429a      	cmp	r2, r3
 8014cd8:	d017      	beq.n	8014d0a <_tx_thread_system_preempt_check+0x56>
    *((ULONG *) 0xE000ED04) = ((ULONG) 0x10000000);
 8014cda:	4b12      	ldr	r3, [pc, #72]	; (8014d24 <_tx_thread_system_preempt_check+0x70>)
 8014cdc:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 8014ce0:	601a      	str	r2, [r3, #0]
    __asm__ volatile (" MRS  %0,IPSR ": "=r" (ipsr_value) );
 8014ce2:	f3ef 8305 	mrs	r3, IPSR
 8014ce6:	613b      	str	r3, [r7, #16]
    return(ipsr_value);
 8014ce8:	693b      	ldr	r3, [r7, #16]
    if (__get_ipsr_value() == 0)
 8014cea:	2b00      	cmp	r3, #0
 8014cec:	d10c      	bne.n	8014d08 <_tx_thread_system_preempt_check+0x54>
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 8014cee:	f3ef 8310 	mrs	r3, PRIMASK
 8014cf2:	60fb      	str	r3, [r7, #12]
    return(posture);
 8014cf4:	68fb      	ldr	r3, [r7, #12]
        interrupt_save = __get_interrupt_posture();
 8014cf6:	60bb      	str	r3, [r7, #8]
    __asm__ volatile ("CPSIE  i": : : "memory");
 8014cf8:	b662      	cpsie	i
}
 8014cfa:	bf00      	nop
 8014cfc:	68bb      	ldr	r3, [r7, #8]
 8014cfe:	607b      	str	r3, [r7, #4]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 8014d00:	687b      	ldr	r3, [r7, #4]
 8014d02:	f383 8810 	msr	PRIMASK, r3
}
 8014d06:	bf00      	nop
}
 8014d08:	bf00      	nop

            /* Return to the system so the higher priority thread can be scheduled.  */
            _tx_thread_system_return();
        }
    }
}
 8014d0a:	bf00      	nop
 8014d0c:	3724      	adds	r7, #36	; 0x24
 8014d0e:	46bd      	mov	sp, r7
 8014d10:	f85d 7b04 	ldr.w	r7, [sp], #4
 8014d14:	4770      	bx	lr
 8014d16:	bf00      	nop
 8014d18:	24031c5c 	.word	0x24031c5c
 8014d1c:	24031bc4 	.word	0x24031bc4
 8014d20:	24031bc8 	.word	0x24031bc8
 8014d24:	e000ed04 	.word	0xe000ed04

08014d28 <_tx_thread_system_resume>:
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
VOID  _tx_thread_system_resume(TX_THREAD *thread_ptr)
#ifndef TX_NOT_INTERRUPTABLE
{
 8014d28:	b580      	push	{r7, lr}
 8014d2a:	b096      	sub	sp, #88	; 0x58
 8014d2c:	af00      	add	r7, sp, #0
 8014d2e:	6078      	str	r0, [r7, #4]
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 8014d30:	f3ef 8310 	mrs	r3, PRIMASK
 8014d34:	637b      	str	r3, [r7, #52]	; 0x34
    return(posture);
 8014d36:	6b7b      	ldr	r3, [r7, #52]	; 0x34
    int_posture = __get_interrupt_posture();
 8014d38:	633b      	str	r3, [r7, #48]	; 0x30
    __asm__ volatile ("CPSID i" : : : "memory");
 8014d3a:	b672      	cpsid	i
    return(int_posture);
 8014d3c:	6b3b      	ldr	r3, [r7, #48]	; 0x30
    /* Check this thread's stack.  */
    TX_THREAD_STACK_CHECK(thread_ptr)
#endif

    /* Lockout interrupts while the thread is being resumed.  */
    TX_DISABLE
 8014d3e:	657b      	str	r3, [r7, #84]	; 0x54

#ifndef TX_NO_TIMER

    /* Deactivate the timeout timer if necessary.  */
    if (thread_ptr -> tx_thread_timer.tx_timer_internal_list_head != TX_NULL)
 8014d40:	687b      	ldr	r3, [r7, #4]
 8014d42:	6e5b      	ldr	r3, [r3, #100]	; 0x64
 8014d44:	2b00      	cmp	r3, #0
 8014d46:	d005      	beq.n	8014d54 <_tx_thread_system_resume+0x2c>
    {

        /* Deactivate the thread's timeout timer.  */
        _tx_timer_system_deactivate(&(thread_ptr -> tx_thread_timer));
 8014d48:	687b      	ldr	r3, [r7, #4]
 8014d4a:	334c      	adds	r3, #76	; 0x4c
 8014d4c:	4618      	mov	r0, r3
 8014d4e:	f000 fde9 	bl	8015924 <_tx_timer_system_deactivate>
 8014d52:	e002      	b.n	8014d5a <_tx_thread_system_resume+0x32>
    }
    else
    {

        /* Clear the remaining time to ensure timer doesn't get activated.  */
        thread_ptr -> tx_thread_timer.tx_timer_internal_remaining_ticks =  ((ULONG) 0);
 8014d54:	687b      	ldr	r3, [r7, #4]
 8014d56:	2200      	movs	r2, #0
 8014d58:	64da      	str	r2, [r3, #76]	; 0x4c
        time_stamp =  entry_ptr -> tx_trace_buffer_entry_time_stamp;
    }
#endif

    /* Decrease the preempt disabled count.  */
    _tx_thread_preempt_disable--;
 8014d5a:	4b6c      	ldr	r3, [pc, #432]	; (8014f0c <_tx_thread_system_resume+0x1e4>)
 8014d5c:	681b      	ldr	r3, [r3, #0]
 8014d5e:	3b01      	subs	r3, #1
 8014d60:	4a6a      	ldr	r2, [pc, #424]	; (8014f0c <_tx_thread_system_resume+0x1e4>)
 8014d62:	6013      	str	r3, [r2, #0]

    /* Determine if the thread is in the process of suspending.  If so, the thread
       control block is already on the linked list so nothing needs to be done.  */
    if (thread_ptr -> tx_thread_suspending == TX_FALSE)
 8014d64:	687b      	ldr	r3, [r7, #4]
 8014d66:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 8014d68:	2b00      	cmp	r3, #0
 8014d6a:	f040 8083 	bne.w	8014e74 <_tx_thread_system_resume+0x14c>
    {

        /* Thread is not in the process of suspending. Now check to make sure the thread 
           has not already been resumed.  */
        if (thread_ptr -> tx_thread_state != TX_READY)
 8014d6e:	687b      	ldr	r3, [r7, #4]
 8014d70:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8014d72:	2b00      	cmp	r3, #0
 8014d74:	f000 8097 	beq.w	8014ea6 <_tx_thread_system_resume+0x17e>
        {

            /* No, now check to see if the delayed suspension flag is set.  */
            if (thread_ptr -> tx_thread_delayed_suspend == TX_FALSE)
 8014d78:	687b      	ldr	r3, [r7, #4]
 8014d7a:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8014d7c:	2b00      	cmp	r3, #0
 8014d7e:	d172      	bne.n	8014e66 <_tx_thread_system_resume+0x13e>
                /* Resume the thread!  */
                
                /* Make this thread ready.  */

                /* Change the state to ready.  */
                thread_ptr -> tx_thread_state =  TX_READY;
 8014d80:	687b      	ldr	r3, [r7, #4]
 8014d82:	2200      	movs	r2, #0
 8014d84:	631a      	str	r2, [r3, #48]	; 0x30

                /* Pickup priority of thread.  */
                priority =  thread_ptr -> tx_thread_priority;
 8014d86:	687b      	ldr	r3, [r7, #4]
 8014d88:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8014d8a:	653b      	str	r3, [r7, #80]	; 0x50
                thread_ptr -> tx_thread_performance_resume_count++;
#endif

                /* Determine if there are other threads at this priority that are
                   ready.  */
                head_ptr =  _tx_thread_priority_list[priority];
 8014d8c:	4a60      	ldr	r2, [pc, #384]	; (8014f10 <_tx_thread_system_resume+0x1e8>)
 8014d8e:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 8014d90:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 8014d94:	64fb      	str	r3, [r7, #76]	; 0x4c
                if (head_ptr == TX_NULL)
 8014d96:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8014d98:	2b00      	cmp	r3, #0
 8014d9a:	d154      	bne.n	8014e46 <_tx_thread_system_resume+0x11e>
                {

                    /* First thread at this priority ready.  Add to the front of the list.  */
                    _tx_thread_priority_list[priority] =       thread_ptr;
 8014d9c:	495c      	ldr	r1, [pc, #368]	; (8014f10 <_tx_thread_system_resume+0x1e8>)
 8014d9e:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 8014da0:	687a      	ldr	r2, [r7, #4]
 8014da2:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
                    thread_ptr -> tx_thread_ready_next =       thread_ptr;
 8014da6:	687b      	ldr	r3, [r7, #4]
 8014da8:	687a      	ldr	r2, [r7, #4]
 8014daa:	621a      	str	r2, [r3, #32]
                    thread_ptr -> tx_thread_ready_previous =   thread_ptr;
 8014dac:	687b      	ldr	r3, [r7, #4]
 8014dae:	687a      	ldr	r2, [r7, #4]
 8014db0:	625a      	str	r2, [r3, #36]	; 0x24
                    TX_DIV32_BIT_SET(priority, priority_bit)
                    _tx_thread_priority_map_active =  _tx_thread_priority_map_active | priority_bit;
#endif

                    /* Or in the thread's priority bit.  */
                    TX_MOD32_BIT_SET(priority, priority_bit)
 8014db2:	2201      	movs	r2, #1
 8014db4:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 8014db6:	fa02 f303 	lsl.w	r3, r2, r3
 8014dba:	647b      	str	r3, [r7, #68]	; 0x44
                    _tx_thread_priority_maps[MAP_INDEX] =  _tx_thread_priority_maps[MAP_INDEX] | priority_bit;
 8014dbc:	4b55      	ldr	r3, [pc, #340]	; (8014f14 <_tx_thread_system_resume+0x1ec>)
 8014dbe:	681a      	ldr	r2, [r3, #0]
 8014dc0:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8014dc2:	4313      	orrs	r3, r2
 8014dc4:	4a53      	ldr	r2, [pc, #332]	; (8014f14 <_tx_thread_system_resume+0x1ec>)
 8014dc6:	6013      	str	r3, [r2, #0]

                    /* Determine if this newly ready thread is the highest priority.  */
                    if (priority < _tx_thread_highest_priority)
 8014dc8:	4b53      	ldr	r3, [pc, #332]	; (8014f18 <_tx_thread_system_resume+0x1f0>)
 8014dca:	681b      	ldr	r3, [r3, #0]
 8014dcc:	6d3a      	ldr	r2, [r7, #80]	; 0x50
 8014dce:	429a      	cmp	r2, r3
 8014dd0:	d269      	bcs.n	8014ea6 <_tx_thread_system_resume+0x17e>
                    {

                        /* A new highest priority thread is present. */

                        /* Update the highest priority variable.  */
                        _tx_thread_highest_priority =  priority;
 8014dd2:	4a51      	ldr	r2, [pc, #324]	; (8014f18 <_tx_thread_system_resume+0x1f0>)
 8014dd4:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 8014dd6:	6013      	str	r3, [r2, #0]

                        /* Pickup the execute pointer. Since it is going to be referenced multiple
                           times, it is placed in a local variable.  */
                        execute_ptr =  _tx_thread_execute_ptr;
 8014dd8:	4b50      	ldr	r3, [pc, #320]	; (8014f1c <_tx_thread_system_resume+0x1f4>)
 8014dda:	681b      	ldr	r3, [r3, #0]
 8014ddc:	643b      	str	r3, [r7, #64]	; 0x40
                        
                        /* Determine if no thread is currently executing.  */
                        if (execute_ptr == TX_NULL)
 8014dde:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8014de0:	2b00      	cmp	r3, #0
 8014de2:	d103      	bne.n	8014dec <_tx_thread_system_resume+0xc4>
                        {

                            /* Simply setup the execute pointer.  */
                            _tx_thread_execute_ptr =  thread_ptr;
 8014de4:	4a4d      	ldr	r2, [pc, #308]	; (8014f1c <_tx_thread_system_resume+0x1f4>)
 8014de6:	687b      	ldr	r3, [r7, #4]
 8014de8:	6013      	str	r3, [r2, #0]
 8014dea:	e05c      	b.n	8014ea6 <_tx_thread_system_resume+0x17e>
                        {
                        
                            /* Another thread has been scheduled for execution.  */
               
                            /* Check to see if this is a higher priority thread and determine if preemption is allowed.  */
                            if (priority < execute_ptr -> tx_thread_preempt_threshold)
 8014dec:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8014dee:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 8014df0:	6d3a      	ldr	r2, [r7, #80]	; 0x50
 8014df2:	429a      	cmp	r2, r3
 8014df4:	d257      	bcs.n	8014ea6 <_tx_thread_system_resume+0x17e>
                                execute_ptr -> tx_thread_performance_last_preempting_thread =  thread_ptr;

#endif

                                /* Yes, modify the execute thread pointer.  */
                                _tx_thread_execute_ptr =  thread_ptr;
 8014df6:	4a49      	ldr	r2, [pc, #292]	; (8014f1c <_tx_thread_system_resume+0x1f4>)
 8014df8:	687b      	ldr	r3, [r7, #4]
 8014dfa:	6013      	str	r3, [r2, #0]
 8014dfc:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 8014dfe:	62fb      	str	r3, [r7, #44]	; 0x2c
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 8014e00:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8014e02:	f383 8810 	msr	PRIMASK, r3
}
 8014e06:	bf00      	nop
                                TX_THREAD_STACK_CHECK(thread_ptr)
#endif

                                /* Now determine if preemption should take place. This is only possible if the current thread pointer is
                                   not the same as the execute thread pointer AND the system state and preempt disable flags are clear.  */
                                TX_THREAD_SYSTEM_RETURN_CHECK(combined_flags)
 8014e08:	4b40      	ldr	r3, [pc, #256]	; (8014f0c <_tx_thread_system_resume+0x1e4>)
 8014e0a:	681b      	ldr	r3, [r3, #0]
 8014e0c:	63fb      	str	r3, [r7, #60]	; 0x3c
                                if (combined_flags == ((ULONG) 0))
 8014e0e:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8014e10:	2b00      	cmp	r3, #0
 8014e12:	d174      	bne.n	8014efe <_tx_thread_system_resume+0x1d6>
    *((ULONG *) 0xE000ED04) = ((ULONG) 0x10000000);
 8014e14:	4b42      	ldr	r3, [pc, #264]	; (8014f20 <_tx_thread_system_resume+0x1f8>)
 8014e16:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 8014e1a:	601a      	str	r2, [r3, #0]
    __asm__ volatile (" MRS  %0,IPSR ": "=r" (ipsr_value) );
 8014e1c:	f3ef 8305 	mrs	r3, IPSR
 8014e20:	62bb      	str	r3, [r7, #40]	; 0x28
    return(ipsr_value);
 8014e22:	6abb      	ldr	r3, [r7, #40]	; 0x28
    if (__get_ipsr_value() == 0)
 8014e24:	2b00      	cmp	r3, #0
 8014e26:	d10c      	bne.n	8014e42 <_tx_thread_system_resume+0x11a>
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 8014e28:	f3ef 8310 	mrs	r3, PRIMASK
 8014e2c:	627b      	str	r3, [r7, #36]	; 0x24
    return(posture);
 8014e2e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
        interrupt_save = __get_interrupt_posture();
 8014e30:	623b      	str	r3, [r7, #32]
    __asm__ volatile ("CPSIE  i": : : "memory");
 8014e32:	b662      	cpsie	i
}
 8014e34:	bf00      	nop
 8014e36:	6a3b      	ldr	r3, [r7, #32]
 8014e38:	61fb      	str	r3, [r7, #28]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 8014e3a:	69fb      	ldr	r3, [r7, #28]
 8014e3c:	f383 8810 	msr	PRIMASK, r3
}
 8014e40:	bf00      	nop
}
 8014e42:	bf00      	nop
                                    /* Preemption is needed - return to the system!  */
                                    _tx_thread_system_return();
                                }

                                /* Return in-line when MISRA is not enabled.  */
                                return;
 8014e44:	e05b      	b.n	8014efe <_tx_thread_system_resume+0x1d6>
                {

                    /* No, there are other threads at this priority already ready.  */

                    /* Just add this thread to the priority list.  */
                    tail_ptr =                                 head_ptr -> tx_thread_ready_previous;
 8014e46:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8014e48:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8014e4a:	64bb      	str	r3, [r7, #72]	; 0x48
                    tail_ptr -> tx_thread_ready_next =         thread_ptr;
 8014e4c:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 8014e4e:	687a      	ldr	r2, [r7, #4]
 8014e50:	621a      	str	r2, [r3, #32]
                    head_ptr -> tx_thread_ready_previous =     thread_ptr;
 8014e52:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8014e54:	687a      	ldr	r2, [r7, #4]
 8014e56:	625a      	str	r2, [r3, #36]	; 0x24
                    thread_ptr -> tx_thread_ready_previous =   tail_ptr;
 8014e58:	687b      	ldr	r3, [r7, #4]
 8014e5a:	6cba      	ldr	r2, [r7, #72]	; 0x48
 8014e5c:	625a      	str	r2, [r3, #36]	; 0x24
                    thread_ptr -> tx_thread_ready_next =       head_ptr;
 8014e5e:	687b      	ldr	r3, [r7, #4]
 8014e60:	6cfa      	ldr	r2, [r7, #76]	; 0x4c
 8014e62:	621a      	str	r2, [r3, #32]
 8014e64:	e01f      	b.n	8014ea6 <_tx_thread_system_resume+0x17e>
            /* Else, delayed suspend flag was set.  */
            else
            {

                /* Clear the delayed suspend flag and change the state.  */
                thread_ptr -> tx_thread_delayed_suspend =  TX_FALSE;
 8014e66:	687b      	ldr	r3, [r7, #4]
 8014e68:	2200      	movs	r2, #0
 8014e6a:	635a      	str	r2, [r3, #52]	; 0x34
                thread_ptr -> tx_thread_state =            TX_SUSPENDED;
 8014e6c:	687b      	ldr	r3, [r7, #4]
 8014e6e:	2203      	movs	r2, #3
 8014e70:	631a      	str	r2, [r3, #48]	; 0x30
 8014e72:	e018      	b.n	8014ea6 <_tx_thread_system_resume+0x17e>
        /* A resumption occurred in the middle of a previous thread suspension.  */
        
        /* Make sure the type of suspension under way is not a terminate or
           thread completion.  In either of these cases, do not void the 
           interrupted suspension processing.  */
        if (thread_ptr -> tx_thread_state != TX_COMPLETED)
 8014e74:	687b      	ldr	r3, [r7, #4]
 8014e76:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8014e78:	2b01      	cmp	r3, #1
 8014e7a:	d014      	beq.n	8014ea6 <_tx_thread_system_resume+0x17e>
        {
            
            /* Make sure the thread isn't terminated.  */
            if (thread_ptr -> tx_thread_state != TX_TERMINATED)
 8014e7c:	687b      	ldr	r3, [r7, #4]
 8014e7e:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8014e80:	2b02      	cmp	r3, #2
 8014e82:	d010      	beq.n	8014ea6 <_tx_thread_system_resume+0x17e>
            {

                /* No, now check to see if the delayed suspension flag is set.  */
                if (thread_ptr -> tx_thread_delayed_suspend == TX_FALSE)
 8014e84:	687b      	ldr	r3, [r7, #4]
 8014e86:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8014e88:	2b00      	cmp	r3, #0
 8014e8a:	d106      	bne.n	8014e9a <_tx_thread_system_resume+0x172>
                {

                    /* Clear the suspending flag.  */
                    thread_ptr -> tx_thread_suspending =   TX_FALSE;
 8014e8c:	687b      	ldr	r3, [r7, #4]
 8014e8e:	2200      	movs	r2, #0
 8014e90:	639a      	str	r2, [r3, #56]	; 0x38

                    /* Restore the state to ready.  */
                    thread_ptr -> tx_thread_state =        TX_READY;
 8014e92:	687b      	ldr	r3, [r7, #4]
 8014e94:	2200      	movs	r2, #0
 8014e96:	631a      	str	r2, [r3, #48]	; 0x30
 8014e98:	e005      	b.n	8014ea6 <_tx_thread_system_resume+0x17e>
                }
                else
                {
                
                    /* Clear the delayed suspend flag and change the state.  */
                    thread_ptr -> tx_thread_delayed_suspend =  TX_FALSE;
 8014e9a:	687b      	ldr	r3, [r7, #4]
 8014e9c:	2200      	movs	r2, #0
 8014e9e:	635a      	str	r2, [r3, #52]	; 0x34
                    thread_ptr -> tx_thread_state =            TX_SUSPENDED;
 8014ea0:	687b      	ldr	r3, [r7, #4]
 8014ea2:	2203      	movs	r2, #3
 8014ea4:	631a      	str	r2, [r3, #48]	; 0x30
        }
    }
#endif

    /* Pickup thread pointer.  */
    TX_THREAD_GET_CURRENT(current_thread)
 8014ea6:	4b1f      	ldr	r3, [pc, #124]	; (8014f24 <_tx_thread_system_resume+0x1fc>)
 8014ea8:	681b      	ldr	r3, [r3, #0]
 8014eaa:	63bb      	str	r3, [r7, #56]	; 0x38
 8014eac:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 8014eae:	61bb      	str	r3, [r7, #24]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 8014eb0:	69bb      	ldr	r3, [r7, #24]
 8014eb2:	f383 8810 	msr	PRIMASK, r3
}
 8014eb6:	bf00      	nop

    /* Restore interrupts.  */
    TX_RESTORE

    /* Determine if a preemption condition is present.  */
    if (current_thread != _tx_thread_execute_ptr)
 8014eb8:	4b18      	ldr	r3, [pc, #96]	; (8014f1c <_tx_thread_system_resume+0x1f4>)
 8014eba:	681b      	ldr	r3, [r3, #0]
 8014ebc:	6bba      	ldr	r2, [r7, #56]	; 0x38
 8014ebe:	429a      	cmp	r2, r3
 8014ec0:	d020      	beq.n	8014f04 <_tx_thread_system_resume+0x1dc>
        TX_THREAD_STACK_CHECK(thread_ptr)
#endif

        /* Now determine if preemption should take place. This is only possible if the current thread pointer is
           not the same as the execute thread pointer AND the system state and preempt disable flags are clear.  */
        TX_THREAD_SYSTEM_RETURN_CHECK(combined_flags)
 8014ec2:	4b12      	ldr	r3, [pc, #72]	; (8014f0c <_tx_thread_system_resume+0x1e4>)
 8014ec4:	681b      	ldr	r3, [r3, #0]
 8014ec6:	63fb      	str	r3, [r7, #60]	; 0x3c
        if (combined_flags == ((ULONG) 0))
 8014ec8:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8014eca:	2b00      	cmp	r3, #0
 8014ecc:	d11a      	bne.n	8014f04 <_tx_thread_system_resume+0x1dc>
    *((ULONG *) 0xE000ED04) = ((ULONG) 0x10000000);
 8014ece:	4b14      	ldr	r3, [pc, #80]	; (8014f20 <_tx_thread_system_resume+0x1f8>)
 8014ed0:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 8014ed4:	601a      	str	r2, [r3, #0]
    __asm__ volatile (" MRS  %0,IPSR ": "=r" (ipsr_value) );
 8014ed6:	f3ef 8305 	mrs	r3, IPSR
 8014eda:	617b      	str	r3, [r7, #20]
    return(ipsr_value);
 8014edc:	697b      	ldr	r3, [r7, #20]
    if (__get_ipsr_value() == 0)
 8014ede:	2b00      	cmp	r3, #0
 8014ee0:	d10f      	bne.n	8014f02 <_tx_thread_system_resume+0x1da>
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 8014ee2:	f3ef 8310 	mrs	r3, PRIMASK
 8014ee6:	613b      	str	r3, [r7, #16]
    return(posture);
 8014ee8:	693b      	ldr	r3, [r7, #16]
        interrupt_save = __get_interrupt_posture();
 8014eea:	60fb      	str	r3, [r7, #12]
    __asm__ volatile ("CPSIE  i": : : "memory");
 8014eec:	b662      	cpsie	i
}
 8014eee:	bf00      	nop
 8014ef0:	68fb      	ldr	r3, [r7, #12]
 8014ef2:	60bb      	str	r3, [r7, #8]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 8014ef4:	68bb      	ldr	r3, [r7, #8]
 8014ef6:	f383 8810 	msr	PRIMASK, r3
}
 8014efa:	bf00      	nop
}
 8014efc:	e001      	b.n	8014f02 <_tx_thread_system_resume+0x1da>
                                return;
 8014efe:	bf00      	nop
 8014f00:	e000      	b.n	8014f04 <_tx_thread_system_resume+0x1dc>
 8014f02:	bf00      	nop

            /* Preemption is needed - return to the system!  */
            _tx_thread_system_return();
        }
    }
}
 8014f04:	3758      	adds	r7, #88	; 0x58
 8014f06:	46bd      	mov	sp, r7
 8014f08:	bd80      	pop	{r7, pc}
 8014f0a:	bf00      	nop
 8014f0c:	24031c5c 	.word	0x24031c5c
 8014f10:	24031bdc 	.word	0x24031bdc
 8014f14:	24031bd4 	.word	0x24031bd4
 8014f18:	24031bd8 	.word	0x24031bd8
 8014f1c:	24031bc8 	.word	0x24031bc8
 8014f20:	e000ed04 	.word	0xe000ed04
 8014f24:	24031bc4 	.word	0x24031bc4

08014f28 <_tx_thread_system_suspend>:
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
VOID  _tx_thread_system_suspend(TX_THREAD *thread_ptr)
#ifndef TX_NOT_INTERRUPTABLE
{
 8014f28:	b580      	push	{r7, lr}
 8014f2a:	b09e      	sub	sp, #120	; 0x78
 8014f2c:	af00      	add	r7, sp, #0
 8014f2e:	6078      	str	r0, [r7, #4]
TX_TRACE_BUFFER_ENTRY       *entry_ptr;
ULONG                       time_stamp =  ((ULONG) 0);
#endif

    /* Pickup thread pointer.  */
    TX_THREAD_GET_CURRENT(current_thread)
 8014f30:	4b81      	ldr	r3, [pc, #516]	; (8015138 <_tx_thread_system_suspend+0x210>)
 8014f32:	681b      	ldr	r3, [r3, #0]
 8014f34:	677b      	str	r3, [r7, #116]	; 0x74
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 8014f36:	f3ef 8310 	mrs	r3, PRIMASK
 8014f3a:	64fb      	str	r3, [r7, #76]	; 0x4c
    return(posture);
 8014f3c:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
    int_posture = __get_interrupt_posture();
 8014f3e:	64bb      	str	r3, [r7, #72]	; 0x48
    __asm__ volatile ("CPSID i" : : : "memory");
 8014f40:	b672      	cpsid	i
    return(int_posture);
 8014f42:	6cbb      	ldr	r3, [r7, #72]	; 0x48
    /* Check this thread's stack.  */
    TX_THREAD_STACK_CHECK(thread_ptr)
#endif

    /* Lockout interrupts while the thread is being suspended.  */
    TX_DISABLE
 8014f44:	673b      	str	r3, [r7, #112]	; 0x70

#ifndef TX_NO_TIMER

    /* Is the current thread suspending?  */
    if (thread_ptr == current_thread)
 8014f46:	687a      	ldr	r2, [r7, #4]
 8014f48:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 8014f4a:	429a      	cmp	r2, r3
 8014f4c:	d112      	bne.n	8014f74 <_tx_thread_system_suspend+0x4c>
    {

        /* Pickup the wait option.  */
        timeout =  thread_ptr -> tx_thread_timer.tx_timer_internal_remaining_ticks;
 8014f4e:	687b      	ldr	r3, [r7, #4]
 8014f50:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 8014f52:	66fb      	str	r3, [r7, #108]	; 0x6c

        /* Determine if an activation is needed.  */
        if (timeout != TX_NO_WAIT)
 8014f54:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 8014f56:	2b00      	cmp	r3, #0
 8014f58:	d008      	beq.n	8014f6c <_tx_thread_system_suspend+0x44>
        {

            /* Make sure the suspension is not a wait-forever.  */
            if (timeout != TX_WAIT_FOREVER)
 8014f5a:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 8014f5c:	f1b3 3fff 	cmp.w	r3, #4294967295
 8014f60:	d004      	beq.n	8014f6c <_tx_thread_system_suspend+0x44>
            {
            
                /* Activate the thread timer with the timeout value setup in the caller.  */
                _tx_timer_system_activate(&(thread_ptr -> tx_thread_timer));
 8014f62:	687b      	ldr	r3, [r7, #4]
 8014f64:	334c      	adds	r3, #76	; 0x4c
 8014f66:	4618      	mov	r0, r3
 8014f68:	f000 fc7a 	bl	8015860 <_tx_timer_system_activate>
            }
        }

        /* Yes, reset time slice for current thread.  */
        _tx_timer_time_slice =  thread_ptr -> tx_thread_new_time_slice;
 8014f6c:	687b      	ldr	r3, [r7, #4]
 8014f6e:	69db      	ldr	r3, [r3, #28]
 8014f70:	4a72      	ldr	r2, [pc, #456]	; (801513c <_tx_thread_system_suspend+0x214>)
 8014f72:	6013      	str	r3, [r2, #0]
    }
#endif
    
    /* Decrease the preempt disabled count.  */
    _tx_thread_preempt_disable--;
 8014f74:	4b72      	ldr	r3, [pc, #456]	; (8015140 <_tx_thread_system_suspend+0x218>)
 8014f76:	681b      	ldr	r3, [r3, #0]
 8014f78:	3b01      	subs	r3, #1
 8014f7a:	4a71      	ldr	r2, [pc, #452]	; (8015140 <_tx_thread_system_suspend+0x218>)
 8014f7c:	6013      	str	r3, [r2, #0]
    _tx_thread_performance_suspend_count++;
#endif

    /* Check to make sure the thread suspending flag is still set.  If not, it
       has already been resumed.  */
    if (thread_ptr -> tx_thread_suspending == TX_TRUE)
 8014f7e:	687b      	ldr	r3, [r7, #4]
 8014f80:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 8014f82:	2b01      	cmp	r3, #1
 8014f84:	f040 80a6 	bne.w	80150d4 <_tx_thread_system_suspend+0x1ac>
            time_stamp =  entry_ptr -> tx_trace_buffer_entry_time_stamp;
        }
#endif

        /* Actually suspend this thread.  But first, clear the suspending flag.  */
        thread_ptr -> tx_thread_suspending =  TX_FALSE;
 8014f88:	687b      	ldr	r3, [r7, #4]
 8014f8a:	2200      	movs	r2, #0
 8014f8c:	639a      	str	r2, [r3, #56]	; 0x38

        /* Pickup priority of thread.  */
        priority =  thread_ptr -> tx_thread_priority;
 8014f8e:	687b      	ldr	r3, [r7, #4]
 8014f90:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8014f92:	66bb      	str	r3, [r7, #104]	; 0x68

        /* Pickup the next ready thread pointer.  */
        ready_next =      thread_ptr -> tx_thread_ready_next;
 8014f94:	687b      	ldr	r3, [r7, #4]
 8014f96:	6a1b      	ldr	r3, [r3, #32]
 8014f98:	667b      	str	r3, [r7, #100]	; 0x64

        /* Determine if there are other threads at this priority that are
           ready.  */
        if (ready_next != thread_ptr)
 8014f9a:	6e7a      	ldr	r2, [r7, #100]	; 0x64
 8014f9c:	687b      	ldr	r3, [r7, #4]
 8014f9e:	429a      	cmp	r2, r3
 8014fa0:	d015      	beq.n	8014fce <_tx_thread_system_suspend+0xa6>
        {

            /* Yes, there are other threads at this priority ready.  */

            /* Pickup the previous ready thread pointer.  */
            ready_previous =  thread_ptr -> tx_thread_ready_previous;
 8014fa2:	687b      	ldr	r3, [r7, #4]
 8014fa4:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8014fa6:	653b      	str	r3, [r7, #80]	; 0x50

            /* Just remove this thread from the priority list.  */
            ready_next -> tx_thread_ready_previous =    ready_previous;
 8014fa8:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 8014faa:	6d3a      	ldr	r2, [r7, #80]	; 0x50
 8014fac:	625a      	str	r2, [r3, #36]	; 0x24
            ready_previous -> tx_thread_ready_next =    ready_next;
 8014fae:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 8014fb0:	6e7a      	ldr	r2, [r7, #100]	; 0x64
 8014fb2:	621a      	str	r2, [r3, #32]

            /* Determine if this is the head of the priority list.  */
            if (_tx_thread_priority_list[priority] == thread_ptr)
 8014fb4:	4a63      	ldr	r2, [pc, #396]	; (8015144 <_tx_thread_system_suspend+0x21c>)
 8014fb6:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 8014fb8:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 8014fbc:	687a      	ldr	r2, [r7, #4]
 8014fbe:	429a      	cmp	r2, r3
 8014fc0:	d157      	bne.n	8015072 <_tx_thread_system_suspend+0x14a>
            {

                /* Update the head pointer of this priority list.  */
                _tx_thread_priority_list[priority] =  ready_next;
 8014fc2:	4960      	ldr	r1, [pc, #384]	; (8015144 <_tx_thread_system_suspend+0x21c>)
 8014fc4:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 8014fc6:	6e7a      	ldr	r2, [r7, #100]	; 0x64
 8014fc8:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
 8014fcc:	e051      	b.n	8015072 <_tx_thread_system_suspend+0x14a>
        else
        {

            /* This is the only thread at this priority ready to run.  Set the head 
               pointer to NULL.  */
            _tx_thread_priority_list[priority] =    TX_NULL;
 8014fce:	4a5d      	ldr	r2, [pc, #372]	; (8015144 <_tx_thread_system_suspend+0x21c>)
 8014fd0:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 8014fd2:	2100      	movs	r1, #0
 8014fd4:	f842 1023 	str.w	r1, [r2, r3, lsl #2]
            /* Calculate the index into the bit map array.  */
            map_index =  priority/((UINT) 32);
#endif

            /* Clear this priority bit in the ready priority bit map.  */
            TX_MOD32_BIT_SET(priority, priority_bit)
 8014fd8:	2201      	movs	r2, #1
 8014fda:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 8014fdc:	fa02 f303 	lsl.w	r3, r2, r3
 8014fe0:	663b      	str	r3, [r7, #96]	; 0x60
            _tx_thread_priority_maps[MAP_INDEX] =  _tx_thread_priority_maps[MAP_INDEX] & (~(priority_bit));
 8014fe2:	4b59      	ldr	r3, [pc, #356]	; (8015148 <_tx_thread_system_suspend+0x220>)
 8014fe4:	681a      	ldr	r2, [r3, #0]
 8014fe6:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 8014fe8:	43db      	mvns	r3, r3
 8014fea:	4013      	ands	r3, r2
 8014fec:	4a56      	ldr	r2, [pc, #344]	; (8015148 <_tx_thread_system_suspend+0x220>)
 8014fee:	6013      	str	r3, [r2, #0]
            /* Calculate the base priority as well.  */
            base_priority =  map_index * ((UINT) 32);
#else

            /* Setup the base priority to zero.  */
            base_priority =   ((UINT) 0);
 8014ff0:	2300      	movs	r3, #0
 8014ff2:	65fb      	str	r3, [r7, #92]	; 0x5c
#endif

            /* Setup working variable for the priority map.  */
            priority_map =    _tx_thread_priority_maps[MAP_INDEX];
 8014ff4:	4b54      	ldr	r3, [pc, #336]	; (8015148 <_tx_thread_system_suspend+0x220>)
 8014ff6:	681b      	ldr	r3, [r3, #0]
 8014ff8:	65bb      	str	r3, [r7, #88]	; 0x58

            /* Make a quick check for no other threads ready for execution.  */
            if (priority_map == ((ULONG) 0))
 8014ffa:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 8014ffc:	2b00      	cmp	r3, #0
 8014ffe:	d12b      	bne.n	8015058 <_tx_thread_system_suspend+0x130>
            {

                /* Nothing else is ready.  Set highest priority and execute thread
                   accordingly.  */
                _tx_thread_highest_priority =  ((UINT) TX_MAX_PRIORITIES);
 8015000:	4b52      	ldr	r3, [pc, #328]	; (801514c <_tx_thread_system_suspend+0x224>)
 8015002:	2220      	movs	r2, #32
 8015004:	601a      	str	r2, [r3, #0]
                _tx_thread_execute_ptr =       TX_NULL;
 8015006:	4b52      	ldr	r3, [pc, #328]	; (8015150 <_tx_thread_system_suspend+0x228>)
 8015008:	2200      	movs	r2, #0
 801500a:	601a      	str	r2, [r3, #0]
 801500c:	6f3b      	ldr	r3, [r7, #112]	; 0x70
 801500e:	647b      	str	r3, [r7, #68]	; 0x44
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 8015010:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8015012:	f383 8810 	msr	PRIMASK, r3
}
 8015016:	bf00      	nop
                /* Restore interrupts.  */
                TX_RESTORE

                /* Determine if preemption should take place. This is only possible if the current thread pointer is
                   not the same as the execute thread pointer AND the system state and preempt disable flags are clear.  */
                TX_THREAD_SYSTEM_RETURN_CHECK(combined_flags)
 8015018:	4b49      	ldr	r3, [pc, #292]	; (8015140 <_tx_thread_system_suspend+0x218>)
 801501a:	681b      	ldr	r3, [r3, #0]
 801501c:	657b      	str	r3, [r7, #84]	; 0x54
                if (combined_flags == ((ULONG) 0))
 801501e:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 8015020:	2b00      	cmp	r3, #0
 8015022:	f040 8081 	bne.w	8015128 <_tx_thread_system_suspend+0x200>
    *((ULONG *) 0xE000ED04) = ((ULONG) 0x10000000);
 8015026:	4b4b      	ldr	r3, [pc, #300]	; (8015154 <_tx_thread_system_suspend+0x22c>)
 8015028:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 801502c:	601a      	str	r2, [r3, #0]
    __asm__ volatile (" MRS  %0,IPSR ": "=r" (ipsr_value) );
 801502e:	f3ef 8305 	mrs	r3, IPSR
 8015032:	643b      	str	r3, [r7, #64]	; 0x40
    return(ipsr_value);
 8015034:	6c3b      	ldr	r3, [r7, #64]	; 0x40
    if (__get_ipsr_value() == 0)
 8015036:	2b00      	cmp	r3, #0
 8015038:	d10c      	bne.n	8015054 <_tx_thread_system_suspend+0x12c>
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 801503a:	f3ef 8310 	mrs	r3, PRIMASK
 801503e:	63fb      	str	r3, [r7, #60]	; 0x3c
    return(posture);
 8015040:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
        interrupt_save = __get_interrupt_posture();
 8015042:	63bb      	str	r3, [r7, #56]	; 0x38
    __asm__ volatile ("CPSIE  i": : : "memory");
 8015044:	b662      	cpsie	i
}
 8015046:	bf00      	nop
 8015048:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 801504a:	637b      	str	r3, [r7, #52]	; 0x34
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 801504c:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 801504e:	f383 8810 	msr	PRIMASK, r3
}
 8015052:	bf00      	nop
}
 8015054:	bf00      	nop
                    /* Preemption is needed - return to the system!  */
                    _tx_thread_system_return();
                }

                /* Return to caller.  */
                return;
 8015056:	e067      	b.n	8015128 <_tx_thread_system_suspend+0x200>
            {
            
                /* Other threads at different priority levels are ready to run.  */
            
                /* Calculate the lowest bit set in the priority map. */
                TX_LOWEST_SET_BIT_CALCULATE(priority_map, priority_bit)
 8015058:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 801505a:	fa93 f3a3 	rbit	r3, r3
 801505e:	65bb      	str	r3, [r7, #88]	; 0x58
 8015060:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 8015062:	fab3 f383 	clz	r3, r3
 8015066:	663b      	str	r3, [r7, #96]	; 0x60

                /* Setup the next highest priority variable.  */
                _tx_thread_highest_priority =  base_priority + ((UINT) priority_bit);
 8015068:	6dfa      	ldr	r2, [r7, #92]	; 0x5c
 801506a:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 801506c:	4413      	add	r3, r2
 801506e:	4a37      	ldr	r2, [pc, #220]	; (801514c <_tx_thread_system_suspend+0x224>)
 8015070:	6013      	str	r3, [r2, #0]
            }
        }

        /* Determine if the suspending thread is the thread designated to execute.  */
        if (thread_ptr == _tx_thread_execute_ptr)
 8015072:	4b37      	ldr	r3, [pc, #220]	; (8015150 <_tx_thread_system_suspend+0x228>)
 8015074:	681b      	ldr	r3, [r3, #0]
 8015076:	687a      	ldr	r2, [r7, #4]
 8015078:	429a      	cmp	r2, r3
 801507a:	d12b      	bne.n	80150d4 <_tx_thread_system_suspend+0x1ac>
        {

            /* Pickup the highest priority thread to execute.  */
            _tx_thread_execute_ptr =  _tx_thread_priority_list[_tx_thread_highest_priority];
 801507c:	4b33      	ldr	r3, [pc, #204]	; (801514c <_tx_thread_system_suspend+0x224>)
 801507e:	681b      	ldr	r3, [r3, #0]
 8015080:	4a30      	ldr	r2, [pc, #192]	; (8015144 <_tx_thread_system_suspend+0x21c>)
 8015082:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 8015086:	4a32      	ldr	r2, [pc, #200]	; (8015150 <_tx_thread_system_suspend+0x228>)
 8015088:	6013      	str	r3, [r2, #0]
 801508a:	6f3b      	ldr	r3, [r7, #112]	; 0x70
 801508c:	633b      	str	r3, [r7, #48]	; 0x30
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 801508e:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8015090:	f383 8810 	msr	PRIMASK, r3
}
 8015094:	bf00      	nop
            /* Restore interrupts.  */
            TX_RESTORE

            /* Determine if preemption should take place. This is only possible if the current thread pointer is
               not the same as the execute thread pointer AND the system state and preempt disable flags are clear.  */
            TX_THREAD_SYSTEM_RETURN_CHECK(combined_flags)
 8015096:	4b2a      	ldr	r3, [pc, #168]	; (8015140 <_tx_thread_system_suspend+0x218>)
 8015098:	681b      	ldr	r3, [r3, #0]
 801509a:	657b      	str	r3, [r7, #84]	; 0x54
            if (combined_flags == ((ULONG) 0))
 801509c:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 801509e:	2b00      	cmp	r3, #0
 80150a0:	d144      	bne.n	801512c <_tx_thread_system_suspend+0x204>
    *((ULONG *) 0xE000ED04) = ((ULONG) 0x10000000);
 80150a2:	4b2c      	ldr	r3, [pc, #176]	; (8015154 <_tx_thread_system_suspend+0x22c>)
 80150a4:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 80150a8:	601a      	str	r2, [r3, #0]
    __asm__ volatile (" MRS  %0,IPSR ": "=r" (ipsr_value) );
 80150aa:	f3ef 8305 	mrs	r3, IPSR
 80150ae:	62fb      	str	r3, [r7, #44]	; 0x2c
    return(ipsr_value);
 80150b0:	6afb      	ldr	r3, [r7, #44]	; 0x2c
    if (__get_ipsr_value() == 0)
 80150b2:	2b00      	cmp	r3, #0
 80150b4:	d10c      	bne.n	80150d0 <_tx_thread_system_suspend+0x1a8>
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 80150b6:	f3ef 8310 	mrs	r3, PRIMASK
 80150ba:	62bb      	str	r3, [r7, #40]	; 0x28
    return(posture);
 80150bc:	6abb      	ldr	r3, [r7, #40]	; 0x28
        interrupt_save = __get_interrupt_posture();
 80150be:	627b      	str	r3, [r7, #36]	; 0x24
    __asm__ volatile ("CPSIE  i": : : "memory");
 80150c0:	b662      	cpsie	i
}
 80150c2:	bf00      	nop
 80150c4:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80150c6:	623b      	str	r3, [r7, #32]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 80150c8:	6a3b      	ldr	r3, [r7, #32]
 80150ca:	f383 8810 	msr	PRIMASK, r3
}
 80150ce:	bf00      	nop
}
 80150d0:	bf00      	nop
                /* Preemption is needed - return to the system!  */
                _tx_thread_system_return();
            }

            /* Return to caller.  */
            return;
 80150d2:	e02b      	b.n	801512c <_tx_thread_system_suspend+0x204>
 80150d4:	6f3b      	ldr	r3, [r7, #112]	; 0x70
 80150d6:	61fb      	str	r3, [r7, #28]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 80150d8:	69fb      	ldr	r3, [r7, #28]
 80150da:	f383 8810 	msr	PRIMASK, r3
}
 80150de:	bf00      	nop

    /* Restore interrupts.  */
    TX_RESTORE

    /* Determine if a preemption condition is present.  */
    if (current_thread != _tx_thread_execute_ptr)
 80150e0:	4b1b      	ldr	r3, [pc, #108]	; (8015150 <_tx_thread_system_suspend+0x228>)
 80150e2:	681b      	ldr	r3, [r3, #0]
 80150e4:	6f7a      	ldr	r2, [r7, #116]	; 0x74
 80150e6:	429a      	cmp	r2, r3
 80150e8:	d022      	beq.n	8015130 <_tx_thread_system_suspend+0x208>
        TX_THREAD_STACK_CHECK(thread_ptr)
#endif

        /* Determine if preemption should take place. This is only possible if the current thread pointer is
           not the same as the execute thread pointer AND the system state and preempt disable flags are clear.  */
        TX_THREAD_SYSTEM_RETURN_CHECK(combined_flags)
 80150ea:	4b15      	ldr	r3, [pc, #84]	; (8015140 <_tx_thread_system_suspend+0x218>)
 80150ec:	681b      	ldr	r3, [r3, #0]
 80150ee:	657b      	str	r3, [r7, #84]	; 0x54
        if (combined_flags == ((ULONG) 0))
 80150f0:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 80150f2:	2b00      	cmp	r3, #0
 80150f4:	d11c      	bne.n	8015130 <_tx_thread_system_suspend+0x208>
    *((ULONG *) 0xE000ED04) = ((ULONG) 0x10000000);
 80150f6:	4b17      	ldr	r3, [pc, #92]	; (8015154 <_tx_thread_system_suspend+0x22c>)
 80150f8:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 80150fc:	601a      	str	r2, [r3, #0]
    __asm__ volatile (" MRS  %0,IPSR ": "=r" (ipsr_value) );
 80150fe:	f3ef 8305 	mrs	r3, IPSR
 8015102:	61bb      	str	r3, [r7, #24]
    return(ipsr_value);
 8015104:	69bb      	ldr	r3, [r7, #24]
    if (__get_ipsr_value() == 0)
 8015106:	2b00      	cmp	r3, #0
 8015108:	d10c      	bne.n	8015124 <_tx_thread_system_suspend+0x1fc>
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 801510a:	f3ef 8310 	mrs	r3, PRIMASK
 801510e:	617b      	str	r3, [r7, #20]
    return(posture);
 8015110:	697b      	ldr	r3, [r7, #20]
        interrupt_save = __get_interrupt_posture();
 8015112:	613b      	str	r3, [r7, #16]
    __asm__ volatile ("CPSIE  i": : : "memory");
 8015114:	b662      	cpsie	i
}
 8015116:	bf00      	nop
 8015118:	693b      	ldr	r3, [r7, #16]
 801511a:	60fb      	str	r3, [r7, #12]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 801511c:	68fb      	ldr	r3, [r7, #12]
 801511e:	f383 8810 	msr	PRIMASK, r3
}
 8015122:	bf00      	nop
}
 8015124:	bf00      	nop
            _tx_thread_system_return();
        }
    }

    /* Return to caller.  */
    return;
 8015126:	e003      	b.n	8015130 <_tx_thread_system_suspend+0x208>
                return;
 8015128:	bf00      	nop
 801512a:	e002      	b.n	8015132 <_tx_thread_system_suspend+0x20a>
            return;
 801512c:	bf00      	nop
 801512e:	e000      	b.n	8015132 <_tx_thread_system_suspend+0x20a>
    return;
 8015130:	bf00      	nop
}
 8015132:	3778      	adds	r7, #120	; 0x78
 8015134:	46bd      	mov	sp, r7
 8015136:	bd80      	pop	{r7, pc}
 8015138:	24031bc4 	.word	0x24031bc4
 801513c:	240321cc 	.word	0x240321cc
 8015140:	24031c5c 	.word	0x24031c5c
 8015144:	24031bdc 	.word	0x24031bdc
 8015148:	24031bd4 	.word	0x24031bd4
 801514c:	24031bd8 	.word	0x24031bd8
 8015150:	24031bc8 	.word	0x24031bc8
 8015154:	e000ed04 	.word	0xe000ed04

08015158 <_tx_thread_terminate>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
UINT  _tx_thread_terminate(TX_THREAD *thread_ptr)
{
 8015158:	b580      	push	{r7, lr}
 801515a:	b0ac      	sub	sp, #176	; 0xb0
 801515c:	af00      	add	r7, sp, #0
 801515e:	6078      	str	r0, [r7, #4]
UINT        status;
ULONG       suspension_sequence;


    /* Default to successful completion.  */
    status =  TX_SUCCESS;
 8015160:	2300      	movs	r3, #0
 8015162:	f8c7 30a8 	str.w	r3, [r7, #168]	; 0xa8
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 8015166:	f3ef 8310 	mrs	r3, PRIMASK
 801516a:	67fb      	str	r3, [r7, #124]	; 0x7c
    return(posture);
 801516c:	6ffb      	ldr	r3, [r7, #124]	; 0x7c
    int_posture = __get_interrupt_posture();
 801516e:	67bb      	str	r3, [r7, #120]	; 0x78
    __asm__ volatile ("CPSID i" : : : "memory");
 8015170:	b672      	cpsid	i
    return(int_posture);
 8015172:	6fbb      	ldr	r3, [r7, #120]	; 0x78

    /* Lockout interrupts while the thread is being terminated.  */
    TX_DISABLE
 8015174:	f8c7 30ac 	str.w	r3, [r7, #172]	; 0xac

    /* Deactivate thread timer, if active.  */
    _tx_timer_system_deactivate(&thread_ptr -> tx_thread_timer);
 8015178:	687b      	ldr	r3, [r7, #4]
 801517a:	334c      	adds	r3, #76	; 0x4c
 801517c:	4618      	mov	r0, r3
 801517e:	f000 fbd1 	bl	8015924 <_tx_timer_system_deactivate>

    /* Log this kernel call.  */
    TX_EL_THREAD_TERMINATE_INSERT

    /* Is the thread already terminated?  */
    if (thread_ptr -> tx_thread_state == TX_TERMINATED)
 8015182:	687b      	ldr	r3, [r7, #4]
 8015184:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8015186:	2b02      	cmp	r3, #2
 8015188:	d10a      	bne.n	80151a0 <_tx_thread_terminate+0x48>
 801518a:	f8d7 30ac 	ldr.w	r3, [r7, #172]	; 0xac
 801518e:	677b      	str	r3, [r7, #116]	; 0x74
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 8015190:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 8015192:	f383 8810 	msr	PRIMASK, r3
}
 8015196:	bf00      	nop

        /* Restore interrupts.  */
        TX_RESTORE

        /* Return success since thread is already terminated.  */
        status =  TX_SUCCESS;
 8015198:	2300      	movs	r3, #0
 801519a:	f8c7 30a8 	str.w	r3, [r7, #168]	; 0xa8
 801519e:	e148      	b.n	8015432 <_tx_thread_terminate+0x2da>
    }

    /* Check the specified thread's current status.  */
    else if (thread_ptr -> tx_thread_state != TX_COMPLETED)
 80151a0:	687b      	ldr	r3, [r7, #4]
 80151a2:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 80151a4:	2b01      	cmp	r3, #1
 80151a6:	f000 813d 	beq.w	8015424 <_tx_thread_terminate+0x2cc>
    {

        /* Disable preemption.  */
        _tx_thread_preempt_disable++;
 80151aa:	4ba6      	ldr	r3, [pc, #664]	; (8015444 <_tx_thread_terminate+0x2ec>)
 80151ac:	681b      	ldr	r3, [r3, #0]
 80151ae:	3301      	adds	r3, #1
 80151b0:	4aa4      	ldr	r2, [pc, #656]	; (8015444 <_tx_thread_terminate+0x2ec>)
 80151b2:	6013      	str	r3, [r2, #0]
        /* Pickup the entry/exit application callback routine.  */
        entry_exit_notify =  thread_ptr -> tx_thread_entry_exit_notify;
#endif

        /* Check to see if the thread is currently ready.  */
        if (thread_ptr -> tx_thread_state == TX_READY)
 80151b4:	687b      	ldr	r3, [r7, #4]
 80151b6:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 80151b8:	2b00      	cmp	r3, #0
 80151ba:	d17a      	bne.n	80152b2 <_tx_thread_terminate+0x15a>
        {

            /* Set the state to terminated.  */
            thread_ptr -> tx_thread_state =  TX_TERMINATED;
 80151bc:	687b      	ldr	r3, [r7, #4]
 80151be:	2202      	movs	r2, #2
 80151c0:	631a      	str	r2, [r3, #48]	; 0x30
            /* Call actual non-interruptable thread suspension routine.  */
            _tx_thread_system_ni_suspend(thread_ptr, ((ULONG) 0));
#else

            /* Set the suspending flag.  */
            thread_ptr -> tx_thread_suspending =  TX_TRUE;
 80151c2:	687b      	ldr	r3, [r7, #4]
 80151c4:	2201      	movs	r2, #1
 80151c6:	639a      	str	r2, [r3, #56]	; 0x38

            /* Setup for no timeout period.  */
            thread_ptr -> tx_thread_timer.tx_timer_internal_remaining_ticks =  ((ULONG) 0);
 80151c8:	687b      	ldr	r3, [r7, #4]
 80151ca:	2200      	movs	r2, #0
 80151cc:	64da      	str	r2, [r3, #76]	; 0x4c

            /* Disable preemption.  */
            _tx_thread_preempt_disable++;
 80151ce:	4b9d      	ldr	r3, [pc, #628]	; (8015444 <_tx_thread_terminate+0x2ec>)
 80151d0:	681b      	ldr	r3, [r3, #0]
 80151d2:	3301      	adds	r3, #1
 80151d4:	4a9b      	ldr	r2, [pc, #620]	; (8015444 <_tx_thread_terminate+0x2ec>)
 80151d6:	6013      	str	r3, [r2, #0]
 80151d8:	f8d7 30ac 	ldr.w	r3, [r7, #172]	; 0xac
 80151dc:	66fb      	str	r3, [r7, #108]	; 0x6c
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 80151de:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 80151e0:	f383 8810 	msr	PRIMASK, r3
}
 80151e4:	bf00      	nop
    __asm__ volatile (" MRS  %0,IPSR ": "=r" (ipsr_value) );
 80151e6:	f3ef 8305 	mrs	r3, IPSR
 80151ea:	673b      	str	r3, [r7, #112]	; 0x70
    return(ipsr_value);
 80151ec:	6f3a      	ldr	r2, [r7, #112]	; 0x70

            /* Restore interrupts.  */
            TX_RESTORE

            /* Perform any additional activities for tool or user purpose.  */
            TX_THREAD_TERMINATED_EXTENSION(thread_ptr)
 80151ee:	4b96      	ldr	r3, [pc, #600]	; (8015448 <_tx_thread_terminate+0x2f0>)
 80151f0:	681b      	ldr	r3, [r3, #0]
 80151f2:	4313      	orrs	r3, r2
 80151f4:	f8c7 308c 	str.w	r3, [r7, #140]	; 0x8c
 80151f8:	f8d7 308c 	ldr.w	r3, [r7, #140]	; 0x8c
 80151fc:	2b00      	cmp	r3, #0
 80151fe:	d118      	bne.n	8015232 <_tx_thread_terminate+0xda>
 8015200:	4b92      	ldr	r3, [pc, #584]	; (801544c <_tx_thread_terminate+0x2f4>)
 8015202:	681b      	ldr	r3, [r3, #0]
 8015204:	687a      	ldr	r2, [r7, #4]
 8015206:	429a      	cmp	r2, r3
 8015208:	d113      	bne.n	8015232 <_tx_thread_terminate+0xda>
    __asm__ volatile (" MRS  %0,CONTROL ": "=r" (control_value) );
 801520a:	f3ef 8314 	mrs	r3, CONTROL
 801520e:	667b      	str	r3, [r7, #100]	; 0x64
    return(control_value);
 8015210:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 8015212:	f8c7 3088 	str.w	r3, [r7, #136]	; 0x88
 8015216:	f8d7 3088 	ldr.w	r3, [r7, #136]	; 0x88
 801521a:	f023 0304 	bic.w	r3, r3, #4
 801521e:	f8c7 3088 	str.w	r3, [r7, #136]	; 0x88
 8015222:	f8d7 3088 	ldr.w	r3, [r7, #136]	; 0x88
 8015226:	66bb      	str	r3, [r7, #104]	; 0x68
    __asm__ volatile (" MSR  CONTROL,%0": : "r" (control_value): "memory" );
 8015228:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 801522a:	f383 8814 	msr	CONTROL, r3
}
 801522e:	bf00      	nop
 8015230:	e032      	b.n	8015298 <_tx_thread_terminate+0x140>
 8015232:	4b87      	ldr	r3, [pc, #540]	; (8015450 <_tx_thread_terminate+0x2f8>)
 8015234:	681b      	ldr	r3, [r3, #0]
 8015236:	f8c7 3084 	str.w	r3, [r7, #132]	; 0x84
 801523a:	f8d7 3084 	ldr.w	r3, [r7, #132]	; 0x84
 801523e:	f003 0301 	and.w	r3, r3, #1
 8015242:	f8c7 3084 	str.w	r3, [r7, #132]	; 0x84
 8015246:	f8d7 3084 	ldr.w	r3, [r7, #132]	; 0x84
 801524a:	2b01      	cmp	r3, #1
 801524c:	d124      	bne.n	8015298 <_tx_thread_terminate+0x140>
    __asm__ volatile (" MRS  %0,CONTROL ": "=r" (control_value) );
 801524e:	f3ef 8314 	mrs	r3, CONTROL
 8015252:	663b      	str	r3, [r7, #96]	; 0x60
    return(control_value);
 8015254:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 8015256:	f8c7 3080 	str.w	r3, [r7, #128]	; 0x80
 801525a:	f8d7 3080 	ldr.w	r3, [r7, #128]	; 0x80
 801525e:	f003 0304 	and.w	r3, r3, #4
 8015262:	f8c7 3080 	str.w	r3, [r7, #128]	; 0x80
 8015266:	eeb0 0a40 	vmov.f32	s0, s0
 801526a:	f8d7 3080 	ldr.w	r3, [r7, #128]	; 0x80
 801526e:	2b00      	cmp	r3, #0
 8015270:	d112      	bne.n	8015298 <_tx_thread_terminate+0x140>
    __asm__ volatile (" MRS  %0,CONTROL ": "=r" (control_value) );
 8015272:	f3ef 8314 	mrs	r3, CONTROL
 8015276:	65bb      	str	r3, [r7, #88]	; 0x58
    return(control_value);
 8015278:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 801527a:	f8c7 3080 	str.w	r3, [r7, #128]	; 0x80
 801527e:	f8d7 3080 	ldr.w	r3, [r7, #128]	; 0x80
 8015282:	f023 0304 	bic.w	r3, r3, #4
 8015286:	f8c7 3080 	str.w	r3, [r7, #128]	; 0x80
 801528a:	f8d7 3080 	ldr.w	r3, [r7, #128]	; 0x80
 801528e:	65fb      	str	r3, [r7, #92]	; 0x5c
    __asm__ volatile (" MSR  CONTROL,%0": : "r" (control_value): "memory" );
 8015290:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 8015292:	f383 8814 	msr	CONTROL, r3
}
 8015296:	bf00      	nop
                (entry_exit_notify)(thread_ptr, TX_THREAD_EXIT);
            }
#endif

            /* Call actual thread suspension routine.  */
            _tx_thread_system_suspend(thread_ptr);
 8015298:	6878      	ldr	r0, [r7, #4]
 801529a:	f7ff fe45 	bl	8014f28 <_tx_thread_system_suspend>
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 801529e:	f3ef 8310 	mrs	r3, PRIMASK
 80152a2:	657b      	str	r3, [r7, #84]	; 0x54
    return(posture);
 80152a4:	6d7b      	ldr	r3, [r7, #84]	; 0x54
    int_posture = __get_interrupt_posture();
 80152a6:	653b      	str	r3, [r7, #80]	; 0x50
    __asm__ volatile ("CPSID i" : : : "memory");
 80152a8:	b672      	cpsid	i
    return(int_posture);
 80152aa:	6d3b      	ldr	r3, [r7, #80]	; 0x50

            /* Disable interrupts.  */
            TX_DISABLE
 80152ac:	f8c7 30ac 	str.w	r3, [r7, #172]	; 0xac
 80152b0:	e094      	b.n	80153dc <_tx_thread_terminate+0x284>
        }
        else
        {

            /* Change the state to terminated.  */
            thread_ptr -> tx_thread_state =    TX_TERMINATED;
 80152b2:	687b      	ldr	r3, [r7, #4]
 80152b4:	2202      	movs	r2, #2
 80152b6:	631a      	str	r2, [r3, #48]	; 0x30
            /* Thread state change.  */
            TX_THREAD_STATE_CHANGE(thread_ptr, TX_TERMINATED)

            /* Set the suspending flag.  This prevents the thread from being 
               resumed before the cleanup routine is executed.  */
            thread_ptr -> tx_thread_suspending =  TX_TRUE;
 80152b8:	687b      	ldr	r3, [r7, #4]
 80152ba:	2201      	movs	r2, #1
 80152bc:	639a      	str	r2, [r3, #56]	; 0x38

            /* Pickup the cleanup routine address.  */
            suspend_cleanup =  thread_ptr -> tx_thread_suspend_cleanup;
 80152be:	687b      	ldr	r3, [r7, #4]
 80152c0:	6e9b      	ldr	r3, [r3, #104]	; 0x68
 80152c2:	f8c7 30a4 	str.w	r3, [r7, #164]	; 0xa4

#ifndef TX_NOT_INTERRUPTABLE

            /* Pickup the suspension sequence number that is used later to verify that the
               cleanup is still necessary.  */
            suspension_sequence =  thread_ptr -> tx_thread_suspension_sequence;
 80152c6:	687b      	ldr	r3, [r7, #4]
 80152c8:	f8d3 30ac 	ldr.w	r3, [r3, #172]	; 0xac
 80152cc:	f8c7 30a0 	str.w	r3, [r7, #160]	; 0xa0
 80152d0:	f8d7 30ac 	ldr.w	r3, [r7, #172]	; 0xac
 80152d4:	64fb      	str	r3, [r7, #76]	; 0x4c
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 80152d6:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 80152d8:	f383 8810 	msr	PRIMASK, r3
}
 80152dc:	bf00      	nop
            /* Restore interrupts.  */
            TX_RESTORE
#endif

            /* Call any cleanup routines.  */
            if (suspend_cleanup != TX_NULL)
 80152de:	f8d7 30a4 	ldr.w	r3, [r7, #164]	; 0xa4
 80152e2:	2b00      	cmp	r3, #0
 80152e4:	d005      	beq.n	80152f2 <_tx_thread_terminate+0x19a>
            {

                /* Yes, there is a function to call.  */
                (suspend_cleanup)(thread_ptr, suspension_sequence);
 80152e6:	f8d7 30a4 	ldr.w	r3, [r7, #164]	; 0xa4
 80152ea:	f8d7 10a0 	ldr.w	r1, [r7, #160]	; 0xa0
 80152ee:	6878      	ldr	r0, [r7, #4]
 80152f0:	4798      	blx	r3
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 80152f2:	f3ef 8310 	mrs	r3, PRIMASK
 80152f6:	643b      	str	r3, [r7, #64]	; 0x40
    return(posture);
 80152f8:	6c3b      	ldr	r3, [r7, #64]	; 0x40
    int_posture = __get_interrupt_posture();
 80152fa:	63fb      	str	r3, [r7, #60]	; 0x3c
    __asm__ volatile ("CPSID i" : : : "memory");
 80152fc:	b672      	cpsid	i
    return(int_posture);
 80152fe:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
            }

#ifndef TX_NOT_INTERRUPTABLE

            /* Disable interrupts.  */
            TX_DISABLE
 8015300:	f8c7 30ac 	str.w	r3, [r7, #172]	; 0xac
#endif

            /* Clear the suspending flag.  */
            thread_ptr -> tx_thread_suspending =  TX_FALSE;
 8015304:	687b      	ldr	r3, [r7, #4]
 8015306:	2200      	movs	r2, #0
 8015308:	639a      	str	r2, [r3, #56]	; 0x38
 801530a:	f8d7 30ac 	ldr.w	r3, [r7, #172]	; 0xac
 801530e:	647b      	str	r3, [r7, #68]	; 0x44
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 8015310:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8015312:	f383 8810 	msr	PRIMASK, r3
}
 8015316:	bf00      	nop
    __asm__ volatile (" MRS  %0,IPSR ": "=r" (ipsr_value) );
 8015318:	f3ef 8305 	mrs	r3, IPSR
 801531c:	64bb      	str	r3, [r7, #72]	; 0x48
    return(ipsr_value);
 801531e:	6cba      	ldr	r2, [r7, #72]	; 0x48
            /* Restore interrupts.  */
            TX_RESTORE
#endif

            /* Perform any additional activities for tool or user purpose.  */
            TX_THREAD_TERMINATED_EXTENSION(thread_ptr)
 8015320:	4b49      	ldr	r3, [pc, #292]	; (8015448 <_tx_thread_terminate+0x2f0>)
 8015322:	681b      	ldr	r3, [r3, #0]
 8015324:	4313      	orrs	r3, r2
 8015326:	f8c7 309c 	str.w	r3, [r7, #156]	; 0x9c
 801532a:	f8d7 309c 	ldr.w	r3, [r7, #156]	; 0x9c
 801532e:	2b00      	cmp	r3, #0
 8015330:	d118      	bne.n	8015364 <_tx_thread_terminate+0x20c>
 8015332:	4b46      	ldr	r3, [pc, #280]	; (801544c <_tx_thread_terminate+0x2f4>)
 8015334:	681b      	ldr	r3, [r3, #0]
 8015336:	687a      	ldr	r2, [r7, #4]
 8015338:	429a      	cmp	r2, r3
 801533a:	d113      	bne.n	8015364 <_tx_thread_terminate+0x20c>
    __asm__ volatile (" MRS  %0,CONTROL ": "=r" (control_value) );
 801533c:	f3ef 8314 	mrs	r3, CONTROL
 8015340:	637b      	str	r3, [r7, #52]	; 0x34
    return(control_value);
 8015342:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8015344:	f8c7 3098 	str.w	r3, [r7, #152]	; 0x98
 8015348:	f8d7 3098 	ldr.w	r3, [r7, #152]	; 0x98
 801534c:	f023 0304 	bic.w	r3, r3, #4
 8015350:	f8c7 3098 	str.w	r3, [r7, #152]	; 0x98
 8015354:	f8d7 3098 	ldr.w	r3, [r7, #152]	; 0x98
 8015358:	63bb      	str	r3, [r7, #56]	; 0x38
    __asm__ volatile (" MSR  CONTROL,%0": : "r" (control_value): "memory" );
 801535a:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 801535c:	f383 8814 	msr	CONTROL, r3
}
 8015360:	bf00      	nop
 8015362:	e032      	b.n	80153ca <_tx_thread_terminate+0x272>
 8015364:	4b3a      	ldr	r3, [pc, #232]	; (8015450 <_tx_thread_terminate+0x2f8>)
 8015366:	681b      	ldr	r3, [r3, #0]
 8015368:	f8c7 3094 	str.w	r3, [r7, #148]	; 0x94
 801536c:	f8d7 3094 	ldr.w	r3, [r7, #148]	; 0x94
 8015370:	f003 0301 	and.w	r3, r3, #1
 8015374:	f8c7 3094 	str.w	r3, [r7, #148]	; 0x94
 8015378:	f8d7 3094 	ldr.w	r3, [r7, #148]	; 0x94
 801537c:	2b01      	cmp	r3, #1
 801537e:	d124      	bne.n	80153ca <_tx_thread_terminate+0x272>
    __asm__ volatile (" MRS  %0,CONTROL ": "=r" (control_value) );
 8015380:	f3ef 8314 	mrs	r3, CONTROL
 8015384:	633b      	str	r3, [r7, #48]	; 0x30
    return(control_value);
 8015386:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8015388:	f8c7 3090 	str.w	r3, [r7, #144]	; 0x90
 801538c:	f8d7 3090 	ldr.w	r3, [r7, #144]	; 0x90
 8015390:	f003 0304 	and.w	r3, r3, #4
 8015394:	f8c7 3090 	str.w	r3, [r7, #144]	; 0x90
 8015398:	eeb0 0a40 	vmov.f32	s0, s0
 801539c:	f8d7 3090 	ldr.w	r3, [r7, #144]	; 0x90
 80153a0:	2b00      	cmp	r3, #0
 80153a2:	d112      	bne.n	80153ca <_tx_thread_terminate+0x272>
    __asm__ volatile (" MRS  %0,CONTROL ": "=r" (control_value) );
 80153a4:	f3ef 8314 	mrs	r3, CONTROL
 80153a8:	62bb      	str	r3, [r7, #40]	; 0x28
    return(control_value);
 80153aa:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80153ac:	f8c7 3090 	str.w	r3, [r7, #144]	; 0x90
 80153b0:	f8d7 3090 	ldr.w	r3, [r7, #144]	; 0x90
 80153b4:	f023 0304 	bic.w	r3, r3, #4
 80153b8:	f8c7 3090 	str.w	r3, [r7, #144]	; 0x90
 80153bc:	f8d7 3090 	ldr.w	r3, [r7, #144]	; 0x90
 80153c0:	62fb      	str	r3, [r7, #44]	; 0x2c
    __asm__ volatile (" MSR  CONTROL,%0": : "r" (control_value): "memory" );
 80153c2:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 80153c4:	f383 8814 	msr	CONTROL, r3
}
 80153c8:	bf00      	nop
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 80153ca:	f3ef 8310 	mrs	r3, PRIMASK
 80153ce:	627b      	str	r3, [r7, #36]	; 0x24
    return(posture);
 80153d0:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    int_posture = __get_interrupt_posture();
 80153d2:	623b      	str	r3, [r7, #32]
    __asm__ volatile ("CPSID i" : : : "memory");
 80153d4:	b672      	cpsid	i
    return(int_posture);
 80153d6:	6a3b      	ldr	r3, [r7, #32]
#endif

#ifndef TX_NOT_INTERRUPTABLE

            /* Disable interrupts.  */
            TX_DISABLE
 80153d8:	f8c7 30ac 	str.w	r3, [r7, #172]	; 0xac
 80153dc:	f8d7 30ac 	ldr.w	r3, [r7, #172]	; 0xac
 80153e0:	61fb      	str	r3, [r7, #28]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 80153e2:	69fb      	ldr	r3, [r7, #28]
 80153e4:	f383 8810 	msr	PRIMASK, r3
}
 80153e8:	bf00      	nop
        /* Restore interrupts.  */
        TX_RESTORE
#endif

        /* Determine if the application is using mutexes.  */
        if (_tx_thread_mutex_release != TX_NULL)
 80153ea:	4b1a      	ldr	r3, [pc, #104]	; (8015454 <_tx_thread_terminate+0x2fc>)
 80153ec:	681b      	ldr	r3, [r3, #0]
 80153ee:	2b00      	cmp	r3, #0
 80153f0:	d003      	beq.n	80153fa <_tx_thread_terminate+0x2a2>
        {

            /* Yes, call the mutex release function via a function pointer that 
               is setup during initialization.  */
            (_tx_thread_mutex_release)(thread_ptr);
 80153f2:	4b18      	ldr	r3, [pc, #96]	; (8015454 <_tx_thread_terminate+0x2fc>)
 80153f4:	681b      	ldr	r3, [r3, #0]
 80153f6:	6878      	ldr	r0, [r7, #4]
 80153f8:	4798      	blx	r3
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 80153fa:	f3ef 8310 	mrs	r3, PRIMASK
 80153fe:	617b      	str	r3, [r7, #20]
    return(posture);
 8015400:	697b      	ldr	r3, [r7, #20]
    int_posture = __get_interrupt_posture();
 8015402:	613b      	str	r3, [r7, #16]
    __asm__ volatile ("CPSID i" : : : "memory");
 8015404:	b672      	cpsid	i
    return(int_posture);
 8015406:	693b      	ldr	r3, [r7, #16]
        }

#ifndef TX_NOT_INTERRUPTABLE

        /* Disable interrupts.  */
        TX_DISABLE
 8015408:	f8c7 30ac 	str.w	r3, [r7, #172]	; 0xac
#endif

        /* Enable preemption.  */
        _tx_thread_preempt_disable--;
 801540c:	4b0d      	ldr	r3, [pc, #52]	; (8015444 <_tx_thread_terminate+0x2ec>)
 801540e:	681b      	ldr	r3, [r3, #0]
 8015410:	3b01      	subs	r3, #1
 8015412:	4a0c      	ldr	r2, [pc, #48]	; (8015444 <_tx_thread_terminate+0x2ec>)
 8015414:	6013      	str	r3, [r2, #0]
 8015416:	f8d7 30ac 	ldr.w	r3, [r7, #172]	; 0xac
 801541a:	61bb      	str	r3, [r7, #24]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 801541c:	69bb      	ldr	r3, [r7, #24]
 801541e:	f383 8810 	msr	PRIMASK, r3
}
 8015422:	e006      	b.n	8015432 <_tx_thread_terminate+0x2da>
 8015424:	f8d7 30ac 	ldr.w	r3, [r7, #172]	; 0xac
 8015428:	60fb      	str	r3, [r7, #12]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 801542a:	68fb      	ldr	r3, [r7, #12]
 801542c:	f383 8810 	msr	PRIMASK, r3
}
 8015430:	bf00      	nop
        /* Restore interrupts.  */
        TX_RESTORE
    }

    /* Check for preemption.  */
    _tx_thread_system_preempt_check();
 8015432:	f7ff fc3f 	bl	8014cb4 <_tx_thread_system_preempt_check>

    /* Return completion status.  */
    return(status);
 8015436:	f8d7 30a8 	ldr.w	r3, [r7, #168]	; 0xa8
}
 801543a:	4618      	mov	r0, r3
 801543c:	37b0      	adds	r7, #176	; 0xb0
 801543e:	46bd      	mov	sp, r7
 8015440:	bd80      	pop	{r7, pc}
 8015442:	bf00      	nop
 8015444:	24031c5c 	.word	0x24031c5c
 8015448:	24000078 	.word	0x24000078
 801544c:	24031bc4 	.word	0x24031bc4
 8015450:	e000ef34 	.word	0xe000ef34
 8015454:	24031c60 	.word	0x24031c60

08015458 <_tx_thread_time_slice>:
/*                                            TX_NO_TIMER is defined,     */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
VOID  _tx_thread_time_slice(VOID)
{
 8015458:	b480      	push	{r7}
 801545a:	b087      	sub	sp, #28
 801545c:	af00      	add	r7, sp, #0
ULONG           system_state;
UINT            preempt_disable;
#endif

    /* Pickup thread pointer.  */
    TX_THREAD_GET_CURRENT(thread_ptr)
 801545e:	4b21      	ldr	r3, [pc, #132]	; (80154e4 <_tx_thread_time_slice+0x8c>)
 8015460:	681b      	ldr	r3, [r3, #0]
 8015462:	617b      	str	r3, [r7, #20]
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 8015464:	f3ef 8310 	mrs	r3, PRIMASK
 8015468:	60fb      	str	r3, [r7, #12]
    return(posture);
 801546a:	68fb      	ldr	r3, [r7, #12]
    int_posture = __get_interrupt_posture();
 801546c:	60bb      	str	r3, [r7, #8]
    __asm__ volatile ("CPSID i" : : : "memory");
 801546e:	b672      	cpsid	i
    return(int_posture);
 8015470:	68bb      	ldr	r3, [r7, #8]
    /* Set the next thread pointer to NULL.  */
    next_thread_ptr =  TX_NULL;
#endif

    /* Lockout interrupts while the time-slice is evaluated.  */
    TX_DISABLE
 8015472:	613b      	str	r3, [r7, #16]

    /* Clear the expired time-slice flag.  */
    _tx_timer_expired_time_slice =  TX_FALSE;
 8015474:	4b1c      	ldr	r3, [pc, #112]	; (80154e8 <_tx_thread_time_slice+0x90>)
 8015476:	2200      	movs	r2, #0
 8015478:	601a      	str	r2, [r3, #0]

    /* Make sure the thread pointer is valid.  */
    if (thread_ptr != TX_NULL)
 801547a:	697b      	ldr	r3, [r7, #20]
 801547c:	2b00      	cmp	r3, #0
 801547e:	d024      	beq.n	80154ca <_tx_thread_time_slice+0x72>
    {

        /* Make sure the thread is still active, i.e. not suspended.  */
        if (thread_ptr -> tx_thread_state == TX_READY)
 8015480:	697b      	ldr	r3, [r7, #20]
 8015482:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8015484:	2b00      	cmp	r3, #0
 8015486:	d120      	bne.n	80154ca <_tx_thread_time_slice+0x72>
        {

            /* Setup a fresh time-slice for the thread.  */
            thread_ptr -> tx_thread_time_slice =  thread_ptr -> tx_thread_new_time_slice;
 8015488:	697b      	ldr	r3, [r7, #20]
 801548a:	69da      	ldr	r2, [r3, #28]
 801548c:	697b      	ldr	r3, [r7, #20]
 801548e:	619a      	str	r2, [r3, #24]

            /* Reset the actual time-slice variable.  */
            _tx_timer_time_slice =  thread_ptr -> tx_thread_time_slice;
 8015490:	697b      	ldr	r3, [r7, #20]
 8015492:	699b      	ldr	r3, [r3, #24]
 8015494:	4a15      	ldr	r2, [pc, #84]	; (80154ec <_tx_thread_time_slice+0x94>)
 8015496:	6013      	str	r3, [r2, #0]

            /* Determine if there is another thread at the same priority and preemption-threshold
               is not set.  Preemption-threshold overrides time-slicing.  */
            if (thread_ptr -> tx_thread_ready_next != thread_ptr)
 8015498:	697b      	ldr	r3, [r7, #20]
 801549a:	6a1b      	ldr	r3, [r3, #32]
 801549c:	697a      	ldr	r2, [r7, #20]
 801549e:	429a      	cmp	r2, r3
 80154a0:	d013      	beq.n	80154ca <_tx_thread_time_slice+0x72>
            {

                /* Check to see if preemption-threshold is not being used.  */
                if (thread_ptr -> tx_thread_priority == thread_ptr -> tx_thread_preempt_threshold)
 80154a2:	697b      	ldr	r3, [r7, #20]
 80154a4:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 80154a6:	697b      	ldr	r3, [r7, #20]
 80154a8:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 80154aa:	429a      	cmp	r2, r3
 80154ac:	d10d      	bne.n	80154ca <_tx_thread_time_slice+0x72>
                
                    /* Preemption-threshold is not being used by this thread.  */
        
                    /* There is another thread at this priority, make it the highest at
                       this priority level.  */
                    _tx_thread_priority_list[thread_ptr -> tx_thread_priority] =  thread_ptr -> tx_thread_ready_next;
 80154ae:	697b      	ldr	r3, [r7, #20]
 80154b0:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 80154b2:	697a      	ldr	r2, [r7, #20]
 80154b4:	6a12      	ldr	r2, [r2, #32]
 80154b6:	490e      	ldr	r1, [pc, #56]	; (80154f0 <_tx_thread_time_slice+0x98>)
 80154b8:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    
                    /* Designate the highest priority thread as the one to execute.  Don't use this 
                       thread's priority as an index just in case a higher priority thread is now 
                       ready!  */
                    _tx_thread_execute_ptr =  _tx_thread_priority_list[_tx_thread_highest_priority];
 80154bc:	4b0d      	ldr	r3, [pc, #52]	; (80154f4 <_tx_thread_time_slice+0x9c>)
 80154be:	681b      	ldr	r3, [r3, #0]
 80154c0:	4a0b      	ldr	r2, [pc, #44]	; (80154f0 <_tx_thread_time_slice+0x98>)
 80154c2:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 80154c6:	4a0c      	ldr	r2, [pc, #48]	; (80154f8 <_tx_thread_time_slice+0xa0>)
 80154c8:	6013      	str	r3, [r2, #0]
 80154ca:	693b      	ldr	r3, [r7, #16]
 80154cc:	607b      	str	r3, [r7, #4]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 80154ce:	687b      	ldr	r3, [r7, #4]
 80154d0:	f383 8810 	msr	PRIMASK, r3
}
 80154d4:	bf00      	nop

        /* Yes, check this thread's stack.  */
        TX_THREAD_STACK_CHECK(next_thread_ptr)
    }
#endif
}
 80154d6:	bf00      	nop
 80154d8:	371c      	adds	r7, #28
 80154da:	46bd      	mov	sp, r7
 80154dc:	f85d 7b04 	ldr.w	r7, [sp], #4
 80154e0:	4770      	bx	lr
 80154e2:	bf00      	nop
 80154e4:	24031bc4 	.word	0x24031bc4
 80154e8:	24031c6c 	.word	0x24031c6c
 80154ec:	240321cc 	.word	0x240321cc
 80154f0:	24031bdc 	.word	0x24031bdc
 80154f4:	24031bd8 	.word	0x24031bd8
 80154f8:	24031bc8 	.word	0x24031bc8

080154fc <_tx_thread_timeout>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
VOID  _tx_thread_timeout(ULONG timeout_input)
{
 80154fc:	b580      	push	{r7, lr}
 80154fe:	b08a      	sub	sp, #40	; 0x28
 8015500:	af00      	add	r7, sp, #0
 8015502:	6078      	str	r0, [r7, #4]
VOID            (*suspend_cleanup)(struct TX_THREAD_STRUCT *suspend_thread_ptr, ULONG suspension_sequence);
ULONG           suspension_sequence;


    /* Pickup the thread pointer.  */
    TX_THREAD_TIMEOUT_POINTER_SETUP(thread_ptr)
 8015504:	687b      	ldr	r3, [r7, #4]
 8015506:	627b      	str	r3, [r7, #36]	; 0x24
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 8015508:	f3ef 8310 	mrs	r3, PRIMASK
 801550c:	617b      	str	r3, [r7, #20]
    return(posture);
 801550e:	697b      	ldr	r3, [r7, #20]
    int_posture = __get_interrupt_posture();
 8015510:	613b      	str	r3, [r7, #16]
    __asm__ volatile ("CPSID i" : : : "memory");
 8015512:	b672      	cpsid	i
    return(int_posture);
 8015514:	693b      	ldr	r3, [r7, #16]

    /* Disable interrupts.  */
    TX_DISABLE
 8015516:	623b      	str	r3, [r7, #32]

    /* Determine how the thread is currently suspended.  */
    if (thread_ptr -> tx_thread_state == TX_SLEEP)
 8015518:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801551a:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 801551c:	2b04      	cmp	r3, #4
 801551e:	d10e      	bne.n	801553e <_tx_thread_timeout+0x42>
        /* Restore interrupts.  */
        TX_RESTORE
#else

        /* Increment the disable preemption flag.  */
        _tx_thread_preempt_disable++;
 8015520:	4b13      	ldr	r3, [pc, #76]	; (8015570 <_tx_thread_timeout+0x74>)
 8015522:	681b      	ldr	r3, [r3, #0]
 8015524:	3301      	adds	r3, #1
 8015526:	4a12      	ldr	r2, [pc, #72]	; (8015570 <_tx_thread_timeout+0x74>)
 8015528:	6013      	str	r3, [r2, #0]
 801552a:	6a3b      	ldr	r3, [r7, #32]
 801552c:	60fb      	str	r3, [r7, #12]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 801552e:	68fb      	ldr	r3, [r7, #12]
 8015530:	f383 8810 	msr	PRIMASK, r3
}
 8015534:	bf00      	nop

        /* Restore interrupts.  */
        TX_RESTORE

        /* Lift the suspension on the sleeping thread.  */
        _tx_thread_system_resume(thread_ptr);
 8015536:	6a78      	ldr	r0, [r7, #36]	; 0x24
 8015538:	f7ff fbf6 	bl	8014d28 <_tx_thread_system_resume>

        /* Restore interrupts.  */
        TX_RESTORE
#endif
    }
}
 801553c:	e013      	b.n	8015566 <_tx_thread_timeout+0x6a>
        suspend_cleanup =  thread_ptr -> tx_thread_suspend_cleanup;
 801553e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8015540:	6e9b      	ldr	r3, [r3, #104]	; 0x68
 8015542:	61fb      	str	r3, [r7, #28]
        suspension_sequence =  thread_ptr -> tx_thread_suspension_sequence;
 8015544:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8015546:	f8d3 30ac 	ldr.w	r3, [r3, #172]	; 0xac
 801554a:	61bb      	str	r3, [r7, #24]
 801554c:	6a3b      	ldr	r3, [r7, #32]
 801554e:	60bb      	str	r3, [r7, #8]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 8015550:	68bb      	ldr	r3, [r7, #8]
 8015552:	f383 8810 	msr	PRIMASK, r3
}
 8015556:	bf00      	nop
        if (suspend_cleanup != TX_NULL)
 8015558:	69fb      	ldr	r3, [r7, #28]
 801555a:	2b00      	cmp	r3, #0
 801555c:	d003      	beq.n	8015566 <_tx_thread_timeout+0x6a>
            (suspend_cleanup)(thread_ptr, suspension_sequence);
 801555e:	69fb      	ldr	r3, [r7, #28]
 8015560:	69b9      	ldr	r1, [r7, #24]
 8015562:	6a78      	ldr	r0, [r7, #36]	; 0x24
 8015564:	4798      	blx	r3
}
 8015566:	bf00      	nop
 8015568:	3728      	adds	r7, #40	; 0x28
 801556a:	46bd      	mov	sp, r7
 801556c:	bd80      	pop	{r7, pc}
 801556e:	bf00      	nop
 8015570:	24031c5c 	.word	0x24031c5c

08015574 <_tx_timer_activate>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
UINT  _tx_timer_activate(TX_TIMER *timer_ptr)
{
 8015574:	b580      	push	{r7, lr}
 8015576:	b088      	sub	sp, #32
 8015578:	af00      	add	r7, sp, #0
 801557a:	6078      	str	r0, [r7, #4]
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 801557c:	f3ef 8310 	mrs	r3, PRIMASK
 8015580:	617b      	str	r3, [r7, #20]
    return(posture);
 8015582:	697b      	ldr	r3, [r7, #20]
    int_posture = __get_interrupt_posture();
 8015584:	613b      	str	r3, [r7, #16]
    __asm__ volatile ("CPSID i" : : : "memory");
 8015586:	b672      	cpsid	i
    return(int_posture);
 8015588:	693b      	ldr	r3, [r7, #16]

UINT        status;


    /* Disable interrupts to put the timer on the created list.  */
    TX_DISABLE
 801558a:	61bb      	str	r3, [r7, #24]
    /* Log this kernel call.  */
    TX_EL_TIMER_ACTIVATE_INSERT
#endif

    /* Check for an already active timer.  */
    if (timer_ptr -> tx_timer_internal.tx_timer_internal_list_head != TX_NULL)
 801558c:	687b      	ldr	r3, [r7, #4]
 801558e:	6a1b      	ldr	r3, [r3, #32]
 8015590:	2b00      	cmp	r3, #0
 8015592:	d002      	beq.n	801559a <_tx_timer_activate+0x26>
    {

        /* Timer is already active, return an error.  */
        status =  TX_ACTIVATE_ERROR;
 8015594:	2317      	movs	r3, #23
 8015596:	61fb      	str	r3, [r7, #28]
 8015598:	e00d      	b.n	80155b6 <_tx_timer_activate+0x42>
    }

    /* Check for a timer with a zero expiration.  */
    else if (timer_ptr -> tx_timer_internal.tx_timer_internal_remaining_ticks == ((ULONG) 0))
 801559a:	687b      	ldr	r3, [r7, #4]
 801559c:	689b      	ldr	r3, [r3, #8]
 801559e:	2b00      	cmp	r3, #0
 80155a0:	d102      	bne.n	80155a8 <_tx_timer_activate+0x34>
    {

        /* Timer is being activated with a zero expiration.  */
        status =  TX_ACTIVATE_ERROR;
 80155a2:	2317      	movs	r3, #23
 80155a4:	61fb      	str	r3, [r7, #28]
 80155a6:	e006      	b.n	80155b6 <_tx_timer_activate+0x42>
        /* Increment the number of activations on this timer.  */
        timer_ptr -> tx_timer_performance_activate_count++;
#endif

        /* Call actual activation function.  */
        _tx_timer_system_activate(&(timer_ptr -> tx_timer_internal));
 80155a8:	687b      	ldr	r3, [r7, #4]
 80155aa:	3308      	adds	r3, #8
 80155ac:	4618      	mov	r0, r3
 80155ae:	f000 f957 	bl	8015860 <_tx_timer_system_activate>

        /* Return a successful status.  */
        status =  TX_SUCCESS;
 80155b2:	2300      	movs	r3, #0
 80155b4:	61fb      	str	r3, [r7, #28]
 80155b6:	69bb      	ldr	r3, [r7, #24]
 80155b8:	60fb      	str	r3, [r7, #12]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 80155ba:	68fb      	ldr	r3, [r7, #12]
 80155bc:	f383 8810 	msr	PRIMASK, r3
}
 80155c0:	bf00      	nop

    /* Restore interrupts.  */
    TX_RESTORE

    /* Return completion status.  */
    return(status);
 80155c2:	69fb      	ldr	r3, [r7, #28]
}
 80155c4:	4618      	mov	r0, r3
 80155c6:	3720      	adds	r7, #32
 80155c8:	46bd      	mov	sp, r7
 80155ca:	bd80      	pop	{r7, pc}

080155cc <_tx_timer_create>:
/*                                                                        */
/**************************************************************************/
UINT  _tx_timer_create(TX_TIMER *timer_ptr, CHAR *name_ptr, 
            VOID (*expiration_function)(ULONG id), ULONG expiration_input,
            ULONG initial_ticks, ULONG reschedule_ticks, UINT auto_activate)
{
 80155cc:	b580      	push	{r7, lr}
 80155ce:	b08a      	sub	sp, #40	; 0x28
 80155d0:	af00      	add	r7, sp, #0
 80155d2:	60f8      	str	r0, [r7, #12]
 80155d4:	60b9      	str	r1, [r7, #8]
 80155d6:	607a      	str	r2, [r7, #4]
 80155d8:	603b      	str	r3, [r7, #0]
TX_TIMER        *next_timer;
TX_TIMER        *previous_timer;


    /* Initialize timer control block to all zeros.  */
    TX_MEMSET(timer_ptr, 0, (sizeof(TX_TIMER)));
 80155da:	222c      	movs	r2, #44	; 0x2c
 80155dc:	2100      	movs	r1, #0
 80155de:	68f8      	ldr	r0, [r7, #12]
 80155e0:	f00a f94c 	bl	801f87c <memset>

    /* Setup the basic timer fields.  */
    timer_ptr -> tx_timer_name =                                            name_ptr;
 80155e4:	68fb      	ldr	r3, [r7, #12]
 80155e6:	68ba      	ldr	r2, [r7, #8]
 80155e8:	605a      	str	r2, [r3, #4]
    timer_ptr -> tx_timer_internal.tx_timer_internal_remaining_ticks =      initial_ticks;
 80155ea:	68fb      	ldr	r3, [r7, #12]
 80155ec:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 80155ee:	609a      	str	r2, [r3, #8]
    timer_ptr -> tx_timer_internal.tx_timer_internal_re_initialize_ticks =  reschedule_ticks;
 80155f0:	68fb      	ldr	r3, [r7, #12]
 80155f2:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 80155f4:	60da      	str	r2, [r3, #12]
    timer_ptr -> tx_timer_internal.tx_timer_internal_timeout_function =     expiration_function;
 80155f6:	68fb      	ldr	r3, [r7, #12]
 80155f8:	687a      	ldr	r2, [r7, #4]
 80155fa:	611a      	str	r2, [r3, #16]
    timer_ptr -> tx_timer_internal.tx_timer_internal_timeout_param =        expiration_input;
 80155fc:	68fb      	ldr	r3, [r7, #12]
 80155fe:	683a      	ldr	r2, [r7, #0]
 8015600:	615a      	str	r2, [r3, #20]
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 8015602:	f3ef 8310 	mrs	r3, PRIMASK
 8015606:	61bb      	str	r3, [r7, #24]
    return(posture);
 8015608:	69bb      	ldr	r3, [r7, #24]
    int_posture = __get_interrupt_posture();
 801560a:	617b      	str	r3, [r7, #20]
    __asm__ volatile ("CPSID i" : : : "memory");
 801560c:	b672      	cpsid	i
    return(int_posture);
 801560e:	697b      	ldr	r3, [r7, #20]
    
    /* Disable interrupts to put the timer on the created list.  */
    TX_DISABLE
 8015610:	627b      	str	r3, [r7, #36]	; 0x24

    /* Setup the timer ID to make it valid.  */
    timer_ptr -> tx_timer_id =  TX_TIMER_ID;
 8015612:	68fb      	ldr	r3, [r7, #12]
 8015614:	4a1c      	ldr	r2, [pc, #112]	; (8015688 <_tx_timer_create+0xbc>)
 8015616:	601a      	str	r2, [r3, #0]

    /* Place the timer on the list of created application timers.  First,
       check for an empty list.  */
    if (_tx_timer_created_count == TX_EMPTY)
 8015618:	4b1c      	ldr	r3, [pc, #112]	; (801568c <_tx_timer_create+0xc0>)
 801561a:	681b      	ldr	r3, [r3, #0]
 801561c:	2b00      	cmp	r3, #0
 801561e:	d109      	bne.n	8015634 <_tx_timer_create+0x68>
    {

        /* The created timer list is empty.  Add timer to empty list.  */
        _tx_timer_created_ptr =                   timer_ptr;
 8015620:	4a1b      	ldr	r2, [pc, #108]	; (8015690 <_tx_timer_create+0xc4>)
 8015622:	68fb      	ldr	r3, [r7, #12]
 8015624:	6013      	str	r3, [r2, #0]
        timer_ptr -> tx_timer_created_next =      timer_ptr;
 8015626:	68fb      	ldr	r3, [r7, #12]
 8015628:	68fa      	ldr	r2, [r7, #12]
 801562a:	625a      	str	r2, [r3, #36]	; 0x24
        timer_ptr -> tx_timer_created_previous =  timer_ptr;
 801562c:	68fb      	ldr	r3, [r7, #12]
 801562e:	68fa      	ldr	r2, [r7, #12]
 8015630:	629a      	str	r2, [r3, #40]	; 0x28
 8015632:	e011      	b.n	8015658 <_tx_timer_create+0x8c>
    }
    else
    {

        /* This list is not NULL, add to the end of the list.  */
        next_timer =  _tx_timer_created_ptr;
 8015634:	4b16      	ldr	r3, [pc, #88]	; (8015690 <_tx_timer_create+0xc4>)
 8015636:	681b      	ldr	r3, [r3, #0]
 8015638:	623b      	str	r3, [r7, #32]
        previous_timer =  next_timer -> tx_timer_created_previous;
 801563a:	6a3b      	ldr	r3, [r7, #32]
 801563c:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 801563e:	61fb      	str	r3, [r7, #28]

        /* Place the new timer in the list.  */
        next_timer -> tx_timer_created_previous =  timer_ptr;
 8015640:	6a3b      	ldr	r3, [r7, #32]
 8015642:	68fa      	ldr	r2, [r7, #12]
 8015644:	629a      	str	r2, [r3, #40]	; 0x28
        previous_timer -> tx_timer_created_next =    timer_ptr;
 8015646:	69fb      	ldr	r3, [r7, #28]
 8015648:	68fa      	ldr	r2, [r7, #12]
 801564a:	625a      	str	r2, [r3, #36]	; 0x24

        /* Setup this timer's created links.  */
        timer_ptr -> tx_timer_created_previous =  previous_timer;
 801564c:	68fb      	ldr	r3, [r7, #12]
 801564e:	69fa      	ldr	r2, [r7, #28]
 8015650:	629a      	str	r2, [r3, #40]	; 0x28
        timer_ptr -> tx_timer_created_next =      next_timer;
 8015652:	68fb      	ldr	r3, [r7, #12]
 8015654:	6a3a      	ldr	r2, [r7, #32]
 8015656:	625a      	str	r2, [r3, #36]	; 0x24
    }

    /* Increment the number of created timers.  */
    _tx_timer_created_count++;
 8015658:	4b0c      	ldr	r3, [pc, #48]	; (801568c <_tx_timer_create+0xc0>)
 801565a:	681b      	ldr	r3, [r3, #0]
 801565c:	3301      	adds	r3, #1
 801565e:	4a0b      	ldr	r2, [pc, #44]	; (801568c <_tx_timer_create+0xc0>)
 8015660:	6013      	str	r3, [r2, #0]

    /* Log this kernel call.  */
    TX_EL_TIMER_CREATE_INSERT

    /* Determine if this timer needs to be activated.  */
    if (auto_activate == TX_AUTO_ACTIVATE)
 8015662:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8015664:	2b01      	cmp	r3, #1
 8015666:	d104      	bne.n	8015672 <_tx_timer_create+0xa6>
        /* Increment the number of activations on this timer.  */
        timer_ptr -> tx_timer_performance_activate_count++;
#endif

        /* Call actual activation function.  */
        _tx_timer_system_activate(&(timer_ptr -> tx_timer_internal));
 8015668:	68fb      	ldr	r3, [r7, #12]
 801566a:	3308      	adds	r3, #8
 801566c:	4618      	mov	r0, r3
 801566e:	f000 f8f7 	bl	8015860 <_tx_timer_system_activate>
 8015672:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8015674:	613b      	str	r3, [r7, #16]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 8015676:	693b      	ldr	r3, [r7, #16]
 8015678:	f383 8810 	msr	PRIMASK, r3
}
 801567c:	bf00      	nop

    /* Restore interrupts.  */
    TX_RESTORE

    /* Return TX_SUCCESS.  */
    return(TX_SUCCESS);
 801567e:	2300      	movs	r3, #0
}
 8015680:	4618      	mov	r0, r3
 8015682:	3728      	adds	r7, #40	; 0x28
 8015684:	46bd      	mov	sp, r7
 8015686:	bd80      	pop	{r7, pc}
 8015688:	4154494d 	.word	0x4154494d
 801568c:	24031d04 	.word	0x24031d04
 8015690:	24031d00 	.word	0x24031d00

08015694 <_tx_timer_delete>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
UINT  _tx_timer_delete(TX_TIMER *timer_ptr)
{
 8015694:	b580      	push	{r7, lr}
 8015696:	b088      	sub	sp, #32
 8015698:	af00      	add	r7, sp, #0
 801569a:	6078      	str	r0, [r7, #4]
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 801569c:	f3ef 8310 	mrs	r3, PRIMASK
 80156a0:	613b      	str	r3, [r7, #16]
    return(posture);
 80156a2:	693b      	ldr	r3, [r7, #16]
    int_posture = __get_interrupt_posture();
 80156a4:	60fb      	str	r3, [r7, #12]
    __asm__ volatile ("CPSID i" : : : "memory");
 80156a6:	b672      	cpsid	i
    return(int_posture);
 80156a8:	68fb      	ldr	r3, [r7, #12]
TX_TIMER        *next_timer;
TX_TIMER        *previous_timer;


    /* Disable interrupts to remove the timer from the created list.  */
    TX_DISABLE
 80156aa:	61fb      	str	r3, [r7, #28]

    /* Determine if the timer needs to be deactivated.  */
    if (timer_ptr -> tx_timer_internal.tx_timer_internal_list_head != TX_NULL)
 80156ac:	687b      	ldr	r3, [r7, #4]
 80156ae:	6a1b      	ldr	r3, [r3, #32]
 80156b0:	2b00      	cmp	r3, #0
 80156b2:	d004      	beq.n	80156be <_tx_timer_delete+0x2a>
    {

        /* Yes, deactivate the timer before it is deleted.  */
        _tx_timer_system_deactivate(&(timer_ptr -> tx_timer_internal));
 80156b4:	687b      	ldr	r3, [r7, #4]
 80156b6:	3308      	adds	r3, #8
 80156b8:	4618      	mov	r0, r3
 80156ba:	f000 f933 	bl	8015924 <_tx_timer_system_deactivate>

    /* Log this kernel call.  */
    TX_EL_TIMER_DELETE_INSERT

    /* Clear the timer ID to make it invalid.  */
    timer_ptr -> tx_timer_id =  TX_CLEAR_ID;
 80156be:	687b      	ldr	r3, [r7, #4]
 80156c0:	2200      	movs	r2, #0
 80156c2:	601a      	str	r2, [r3, #0]

    /* Decrement the number of created timers.  */
    _tx_timer_created_count--;
 80156c4:	4b15      	ldr	r3, [pc, #84]	; (801571c <_tx_timer_delete+0x88>)
 80156c6:	681b      	ldr	r3, [r3, #0]
 80156c8:	3b01      	subs	r3, #1
 80156ca:	4a14      	ldr	r2, [pc, #80]	; (801571c <_tx_timer_delete+0x88>)
 80156cc:	6013      	str	r3, [r2, #0]
    
    /* See if the timer is the only one on the list.  */
    if (_tx_timer_created_count == TX_EMPTY)
 80156ce:	4b13      	ldr	r3, [pc, #76]	; (801571c <_tx_timer_delete+0x88>)
 80156d0:	681b      	ldr	r3, [r3, #0]
 80156d2:	2b00      	cmp	r3, #0
 80156d4:	d103      	bne.n	80156de <_tx_timer_delete+0x4a>
    {

        /* Only created timer, just set the created list to NULL.  */
        _tx_timer_created_ptr =  TX_NULL;
 80156d6:	4b12      	ldr	r3, [pc, #72]	; (8015720 <_tx_timer_delete+0x8c>)
 80156d8:	2200      	movs	r2, #0
 80156da:	601a      	str	r2, [r3, #0]
 80156dc:	e013      	b.n	8015706 <_tx_timer_delete+0x72>
    }
    else
    {

        /* Link-up the neighbors.  */
        next_timer =                               timer_ptr -> tx_timer_created_next;
 80156de:	687b      	ldr	r3, [r7, #4]
 80156e0:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 80156e2:	61bb      	str	r3, [r7, #24]
        previous_timer =                           timer_ptr -> tx_timer_created_previous;
 80156e4:	687b      	ldr	r3, [r7, #4]
 80156e6:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 80156e8:	617b      	str	r3, [r7, #20]
        next_timer -> tx_timer_created_previous =  previous_timer;
 80156ea:	69bb      	ldr	r3, [r7, #24]
 80156ec:	697a      	ldr	r2, [r7, #20]
 80156ee:	629a      	str	r2, [r3, #40]	; 0x28
        previous_timer -> tx_timer_created_next =  next_timer;
 80156f0:	697b      	ldr	r3, [r7, #20]
 80156f2:	69ba      	ldr	r2, [r7, #24]
 80156f4:	625a      	str	r2, [r3, #36]	; 0x24

        /* See if we have to update the created list head pointer.  */
        if (_tx_timer_created_ptr == timer_ptr)
 80156f6:	4b0a      	ldr	r3, [pc, #40]	; (8015720 <_tx_timer_delete+0x8c>)
 80156f8:	681b      	ldr	r3, [r3, #0]
 80156fa:	687a      	ldr	r2, [r7, #4]
 80156fc:	429a      	cmp	r2, r3
 80156fe:	d102      	bne.n	8015706 <_tx_timer_delete+0x72>
        {
                    
            /* Yes, move the head pointer to the next link. */
            _tx_timer_created_ptr =  next_timer;
 8015700:	4a07      	ldr	r2, [pc, #28]	; (8015720 <_tx_timer_delete+0x8c>)
 8015702:	69bb      	ldr	r3, [r7, #24]
 8015704:	6013      	str	r3, [r2, #0]
 8015706:	69fb      	ldr	r3, [r7, #28]
 8015708:	60bb      	str	r3, [r7, #8]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 801570a:	68bb      	ldr	r3, [r7, #8]
 801570c:	f383 8810 	msr	PRIMASK, r3
}
 8015710:	bf00      	nop

    /* Restore interrupts.  */
    TX_RESTORE

    /* Return TX_SUCCESS.  */
    return(TX_SUCCESS);
 8015712:	2300      	movs	r3, #0
}
 8015714:	4618      	mov	r0, r3
 8015716:	3720      	adds	r7, #32
 8015718:	46bd      	mov	sp, r7
 801571a:	bd80      	pop	{r7, pc}
 801571c:	24031d04 	.word	0x24031d04
 8015720:	24031d00 	.word	0x24031d00

08015724 <_tx_timer_expiration_process>:
/*                                            TX_NO_TIMER is defined,     */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
VOID  _tx_timer_expiration_process(VOID)
{
 8015724:	b580      	push	{r7, lr}
 8015726:	b084      	sub	sp, #16
 8015728:	af00      	add	r7, sp, #0
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 801572a:	f3ef 8310 	mrs	r3, PRIMASK
 801572e:	607b      	str	r3, [r7, #4]
    return(posture);
 8015730:	687b      	ldr	r3, [r7, #4]
    int_posture = __get_interrupt_posture();
 8015732:	603b      	str	r3, [r7, #0]
    __asm__ volatile ("CPSID i" : : : "memory");
 8015734:	b672      	cpsid	i
    return(int_posture);
 8015736:	683b      	ldr	r3, [r7, #0]

    /* Don't process in the ISR, wakeup the system timer thread to process the 
       timer expiration.  */

    /* Disable interrupts.  */
    TX_DISABLE
 8015738:	60fb      	str	r3, [r7, #12]
    /* Restore interrupts.  */
    TX_RESTORE
#else

    /* Increment the preempt disable flag.  */
    _tx_thread_preempt_disable++;
 801573a:	4b09      	ldr	r3, [pc, #36]	; (8015760 <_tx_timer_expiration_process+0x3c>)
 801573c:	681b      	ldr	r3, [r3, #0]
 801573e:	3301      	adds	r3, #1
 8015740:	4a07      	ldr	r2, [pc, #28]	; (8015760 <_tx_timer_expiration_process+0x3c>)
 8015742:	6013      	str	r3, [r2, #0]
 8015744:	68fb      	ldr	r3, [r7, #12]
 8015746:	60bb      	str	r3, [r7, #8]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 8015748:	68bb      	ldr	r3, [r7, #8]
 801574a:	f383 8810 	msr	PRIMASK, r3
}
 801574e:	bf00      	nop

    /* Restore interrupts.  */
    TX_RESTORE

    /* Call the system resume function to activate the timer thread.  */
    _tx_thread_system_resume(&_tx_timer_thread);
 8015750:	4804      	ldr	r0, [pc, #16]	; (8015764 <_tx_timer_expiration_process+0x40>)
 8015752:	f7ff fae9 	bl	8014d28 <_tx_thread_system_resume>
    }
    
    /* Restore interrupts.  */
    TX_RESTORE
#endif
}
 8015756:	bf00      	nop
 8015758:	3710      	adds	r7, #16
 801575a:	46bd      	mov	sp, r7
 801575c:	bd80      	pop	{r7, pc}
 801575e:	bf00      	nop
 8015760:	24031c5c 	.word	0x24031c5c
 8015764:	24031d0c 	.word	0x24031d0c

08015768 <_tx_timer_initialize>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
VOID  _tx_timer_initialize(VOID)
{
 8015768:	b590      	push	{r4, r7, lr}
 801576a:	b089      	sub	sp, #36	; 0x24
 801576c:	af06      	add	r7, sp, #24
#endif

#ifndef TX_DISABLE_REDUNDANT_CLEARING

    /* Initialize the system clock to 0.  */
    _tx_timer_system_clock =  ((ULONG) 0);
 801576e:	4b28      	ldr	r3, [pc, #160]	; (8015810 <_tx_timer_initialize+0xa8>)
 8015770:	2200      	movs	r2, #0
 8015772:	601a      	str	r2, [r3, #0]

    /* Initialize the time-slice value to 0 to make sure it is disabled.  */
    _tx_timer_time_slice =  ((ULONG) 0);
 8015774:	4b27      	ldr	r3, [pc, #156]	; (8015814 <_tx_timer_initialize+0xac>)
 8015776:	2200      	movs	r2, #0
 8015778:	601a      	str	r2, [r3, #0]

    /* Clear the expired flags.  */
    _tx_timer_expired_time_slice =  TX_FALSE;
 801577a:	4b27      	ldr	r3, [pc, #156]	; (8015818 <_tx_timer_initialize+0xb0>)
 801577c:	2200      	movs	r2, #0
 801577e:	601a      	str	r2, [r3, #0]
    _tx_timer_expired =             TX_FALSE;
 8015780:	4b26      	ldr	r3, [pc, #152]	; (801581c <_tx_timer_initialize+0xb4>)
 8015782:	2200      	movs	r2, #0
 8015784:	601a      	str	r2, [r3, #0]

    /* Set the currently expired timer being processed pointer to NULL.  */
    _tx_timer_expired_timer_ptr =  TX_NULL;
 8015786:	4b26      	ldr	r3, [pc, #152]	; (8015820 <_tx_timer_initialize+0xb8>)
 8015788:	2200      	movs	r2, #0
 801578a:	601a      	str	r2, [r3, #0]

    /* Initialize the thread and application timer management control structures.  */

    /* First, initialize the timer list.  */
    TX_MEMSET(&_tx_timer_list[0], 0, (sizeof(_tx_timer_list)));
 801578c:	2280      	movs	r2, #128	; 0x80
 801578e:	2100      	movs	r1, #0
 8015790:	4824      	ldr	r0, [pc, #144]	; (8015824 <_tx_timer_initialize+0xbc>)
 8015792:	f00a f873 	bl	801f87c <memset>
#endif

    /* Initialize all of the list pointers.  */
    _tx_timer_list_start =   &_tx_timer_list[0];
 8015796:	4b24      	ldr	r3, [pc, #144]	; (8015828 <_tx_timer_initialize+0xc0>)
 8015798:	4a22      	ldr	r2, [pc, #136]	; (8015824 <_tx_timer_initialize+0xbc>)
 801579a:	601a      	str	r2, [r3, #0]
    _tx_timer_current_ptr =  &_tx_timer_list[0];
 801579c:	4b23      	ldr	r3, [pc, #140]	; (801582c <_tx_timer_initialize+0xc4>)
 801579e:	4a21      	ldr	r2, [pc, #132]	; (8015824 <_tx_timer_initialize+0xbc>)
 80157a0:	601a      	str	r2, [r3, #0]

    /* Set the timer list end pointer to one past the actual timer list.  This is done
       to make the timer interrupt handling in assembly language a little easier.  */
    _tx_timer_list_end =     &_tx_timer_list[TX_TIMER_ENTRIES-((ULONG) 1)];
 80157a2:	4b23      	ldr	r3, [pc, #140]	; (8015830 <_tx_timer_initialize+0xc8>)
 80157a4:	4a23      	ldr	r2, [pc, #140]	; (8015834 <_tx_timer_initialize+0xcc>)
 80157a6:	601a      	str	r2, [r3, #0]
    _tx_timer_list_end =     TX_TIMER_POINTER_ADD(_tx_timer_list_end, ((ULONG) 1));
 80157a8:	4b21      	ldr	r3, [pc, #132]	; (8015830 <_tx_timer_initialize+0xc8>)
 80157aa:	681b      	ldr	r3, [r3, #0]
 80157ac:	3304      	adds	r3, #4
 80157ae:	4a20      	ldr	r2, [pc, #128]	; (8015830 <_tx_timer_initialize+0xc8>)
 80157b0:	6013      	str	r3, [r2, #0]

#ifndef TX_TIMER_PROCESS_IN_ISR

    /* Setup the variables associated with the system timer thread's stack and 
       priority.  */
    _tx_timer_stack_start =  (VOID *) &_tx_timer_thread_stack_area[0];
 80157b2:	4b21      	ldr	r3, [pc, #132]	; (8015838 <_tx_timer_initialize+0xd0>)
 80157b4:	4a21      	ldr	r2, [pc, #132]	; (801583c <_tx_timer_initialize+0xd4>)
 80157b6:	601a      	str	r2, [r3, #0]
    _tx_timer_stack_size =   ((ULONG) TX_TIMER_THREAD_STACK_SIZE);
 80157b8:	4b21      	ldr	r3, [pc, #132]	; (8015840 <_tx_timer_initialize+0xd8>)
 80157ba:	f44f 6280 	mov.w	r2, #1024	; 0x400
 80157be:	601a      	str	r2, [r3, #0]
    _tx_timer_priority =     ((UINT) TX_TIMER_THREAD_PRIORITY);
 80157c0:	4b20      	ldr	r3, [pc, #128]	; (8015844 <_tx_timer_initialize+0xdc>)
 80157c2:	2200      	movs	r2, #0
 80157c4:	601a      	str	r2, [r3, #0]
       low-level initialization component.  */
    do
    {
      
        /* Create the system timer thread.  */
        status =  _tx_thread_create(&_tx_timer_thread, 
 80157c6:	4b1c      	ldr	r3, [pc, #112]	; (8015838 <_tx_timer_initialize+0xd0>)
 80157c8:	681b      	ldr	r3, [r3, #0]
 80157ca:	4a1d      	ldr	r2, [pc, #116]	; (8015840 <_tx_timer_initialize+0xd8>)
 80157cc:	6812      	ldr	r2, [r2, #0]
 80157ce:	491d      	ldr	r1, [pc, #116]	; (8015844 <_tx_timer_initialize+0xdc>)
 80157d0:	6809      	ldr	r1, [r1, #0]
 80157d2:	481c      	ldr	r0, [pc, #112]	; (8015844 <_tx_timer_initialize+0xdc>)
 80157d4:	6800      	ldr	r0, [r0, #0]
 80157d6:	2400      	movs	r4, #0
 80157d8:	9405      	str	r4, [sp, #20]
 80157da:	2400      	movs	r4, #0
 80157dc:	9404      	str	r4, [sp, #16]
 80157de:	9003      	str	r0, [sp, #12]
 80157e0:	9102      	str	r1, [sp, #8]
 80157e2:	9201      	str	r2, [sp, #4]
 80157e4:	9300      	str	r3, [sp, #0]
 80157e6:	4b18      	ldr	r3, [pc, #96]	; (8015848 <_tx_timer_initialize+0xe0>)
 80157e8:	4a18      	ldr	r2, [pc, #96]	; (801584c <_tx_timer_initialize+0xe4>)
 80157ea:	4919      	ldr	r1, [pc, #100]	; (8015850 <_tx_timer_initialize+0xe8>)
 80157ec:	4819      	ldr	r0, [pc, #100]	; (8015854 <_tx_timer_initialize+0xec>)
 80157ee:	f7fe feb1 	bl	8014554 <_tx_thread_create>
 80157f2:	6078      	str	r0, [r7, #4]
#endif

        /* Define timer initialize extension.  */
        TX_TIMER_INITIALIZE_EXTENSION(status)
        
    } while (status != TX_SUCCESS);
 80157f4:	687b      	ldr	r3, [r7, #4]
 80157f6:	2b00      	cmp	r3, #0
 80157f8:	d1e5      	bne.n	80157c6 <_tx_timer_initialize+0x5e>
#endif

#ifndef TX_DISABLE_REDUNDANT_CLEARING

    /* Initialize the head pointer of the created application timer list.  */
    _tx_timer_created_ptr =  TX_NULL;
 80157fa:	4b17      	ldr	r3, [pc, #92]	; (8015858 <_tx_timer_initialize+0xf0>)
 80157fc:	2200      	movs	r2, #0
 80157fe:	601a      	str	r2, [r3, #0]

    /* Set the created count to zero.  */
    _tx_timer_created_count =  TX_EMPTY;
 8015800:	4b16      	ldr	r3, [pc, #88]	; (801585c <_tx_timer_initialize+0xf4>)
 8015802:	2200      	movs	r2, #0
 8015804:	601a      	str	r2, [r3, #0]
    _tx_timer_performance_expiration_count =         ((ULONG) 0);
    _tx_timer_performance__expiration_adjust_count =  ((ULONG) 0);
#endif
#endif
#endif
}
 8015806:	bf00      	nop
 8015808:	370c      	adds	r7, #12
 801580a:	46bd      	mov	sp, r7
 801580c:	bd90      	pop	{r4, r7, pc}
 801580e:	bf00      	nop
 8015810:	24031c68 	.word	0x24031c68
 8015814:	240321cc 	.word	0x240321cc
 8015818:	24031c6c 	.word	0x24031c6c
 801581c:	24031cfc 	.word	0x24031cfc
 8015820:	24031d08 	.word	0x24031d08
 8015824:	24031c70 	.word	0x24031c70
 8015828:	24031cf0 	.word	0x24031cf0
 801582c:	24031cf8 	.word	0x24031cf8
 8015830:	24031cf4 	.word	0x24031cf4
 8015834:	24031cec 	.word	0x24031cec
 8015838:	24031dc0 	.word	0x24031dc0
 801583c:	24031dcc 	.word	0x24031dcc
 8015840:	24031dc4 	.word	0x24031dc4
 8015844:	24031dc8 	.word	0x24031dc8
 8015848:	4154494d 	.word	0x4154494d
 801584c:	08015995 	.word	0x08015995
 8015850:	08021e6c 	.word	0x08021e6c
 8015854:	24031d0c 	.word	0x24031d0c
 8015858:	24031d00 	.word	0x24031d00
 801585c:	24031d04 	.word	0x24031d04

08015860 <_tx_timer_system_activate>:
/*                                            TX_NO_TIMER is defined,     */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
VOID  _tx_timer_system_activate(TX_TIMER_INTERNAL *timer_ptr)
{
 8015860:	b480      	push	{r7}
 8015862:	b089      	sub	sp, #36	; 0x24
 8015864:	af00      	add	r7, sp, #0
 8015866:	6078      	str	r0, [r7, #4]
ULONG                       remaining_ticks;
ULONG                       expiration_time;


    /* Pickup the remaining ticks.  */
    remaining_ticks =  timer_ptr -> tx_timer_internal_remaining_ticks;
 8015868:	687b      	ldr	r3, [r7, #4]
 801586a:	681b      	ldr	r3, [r3, #0]
 801586c:	617b      	str	r3, [r7, #20]

    /* Determine if there is a timer to activate.  */
    if (remaining_ticks != ((ULONG) 0))
 801586e:	697b      	ldr	r3, [r7, #20]
 8015870:	2b00      	cmp	r3, #0
 8015872:	d04a      	beq.n	801590a <_tx_timer_system_activate+0xaa>
    {
    
        /* Determine if the timer is set to wait forever.  */
        if (remaining_ticks != TX_WAIT_FOREVER)
 8015874:	697b      	ldr	r3, [r7, #20]
 8015876:	f1b3 3fff 	cmp.w	r3, #4294967295
 801587a:	d046      	beq.n	801590a <_tx_timer_system_activate+0xaa>
        {
    
            /* Valid timer activate request.  */

            /* Determine if the timer still needs activation.  */
            if (timer_ptr -> tx_timer_internal_list_head == TX_NULL)
 801587c:	687b      	ldr	r3, [r7, #4]
 801587e:	699b      	ldr	r3, [r3, #24]
 8015880:	2b00      	cmp	r3, #0
 8015882:	d142      	bne.n	801590a <_tx_timer_system_activate+0xaa>
            {

                /* Activate the timer.  */

                /* Calculate the amount of time remaining for the timer.  */
                if (remaining_ticks > TX_TIMER_ENTRIES)
 8015884:	697b      	ldr	r3, [r7, #20]
 8015886:	2b20      	cmp	r3, #32
 8015888:	d902      	bls.n	8015890 <_tx_timer_system_activate+0x30>
                {

                    /* Set expiration time to the maximum number of entries.  */
                    expiration_time =  TX_TIMER_ENTRIES - ((ULONG) 1);
 801588a:	231f      	movs	r3, #31
 801588c:	61bb      	str	r3, [r7, #24]
 801588e:	e002      	b.n	8015896 <_tx_timer_system_activate+0x36>
                {

                    /* Timer value fits in the timer entries.  */

                    /* Set the expiration time.  */
                    expiration_time =  (remaining_ticks - ((ULONG) 1));
 8015890:	697b      	ldr	r3, [r7, #20]
 8015892:	3b01      	subs	r3, #1
 8015894:	61bb      	str	r3, [r7, #24]

                /* At this point, we are ready to put the timer on one of
                   the timer lists.  */
    
                /* Calculate the proper place for the timer.  */
                timer_list =  TX_TIMER_POINTER_ADD(_tx_timer_current_ptr, expiration_time);
 8015896:	4b20      	ldr	r3, [pc, #128]	; (8015918 <_tx_timer_system_activate+0xb8>)
 8015898:	681a      	ldr	r2, [r3, #0]
 801589a:	69bb      	ldr	r3, [r7, #24]
 801589c:	009b      	lsls	r3, r3, #2
 801589e:	4413      	add	r3, r2
 80158a0:	61fb      	str	r3, [r7, #28]
                if (TX_TIMER_INDIRECT_TO_VOID_POINTER_CONVERT(timer_list) >= TX_TIMER_INDIRECT_TO_VOID_POINTER_CONVERT(_tx_timer_list_end))
 80158a2:	4b1e      	ldr	r3, [pc, #120]	; (801591c <_tx_timer_system_activate+0xbc>)
 80158a4:	681b      	ldr	r3, [r3, #0]
 80158a6:	69fa      	ldr	r2, [r7, #28]
 80158a8:	429a      	cmp	r2, r3
 80158aa:	d30b      	bcc.n	80158c4 <_tx_timer_system_activate+0x64>
                {

                    /* Wrap from the beginning of the list.  */
                    delta =  TX_TIMER_POINTER_DIF(timer_list, _tx_timer_list_end);
 80158ac:	4b1b      	ldr	r3, [pc, #108]	; (801591c <_tx_timer_system_activate+0xbc>)
 80158ae:	681b      	ldr	r3, [r3, #0]
 80158b0:	69fa      	ldr	r2, [r7, #28]
 80158b2:	1ad3      	subs	r3, r2, r3
 80158b4:	109b      	asrs	r3, r3, #2
 80158b6:	613b      	str	r3, [r7, #16]
                    timer_list =  TX_TIMER_POINTER_ADD(_tx_timer_list_start, delta);
 80158b8:	4b19      	ldr	r3, [pc, #100]	; (8015920 <_tx_timer_system_activate+0xc0>)
 80158ba:	681a      	ldr	r2, [r3, #0]
 80158bc:	693b      	ldr	r3, [r7, #16]
 80158be:	009b      	lsls	r3, r3, #2
 80158c0:	4413      	add	r3, r2
 80158c2:	61fb      	str	r3, [r7, #28]
                }
    
                /* Now put the timer on this list.  */
                if ((*timer_list) == TX_NULL)
 80158c4:	69fb      	ldr	r3, [r7, #28]
 80158c6:	681b      	ldr	r3, [r3, #0]
 80158c8:	2b00      	cmp	r3, #0
 80158ca:	d109      	bne.n	80158e0 <_tx_timer_system_activate+0x80>
                {
                
                    /* This list is NULL, just put the new timer on it.  */

                    /* Setup the links in this timer.  */
                    timer_ptr -> tx_timer_internal_active_next =      timer_ptr;
 80158cc:	687b      	ldr	r3, [r7, #4]
 80158ce:	687a      	ldr	r2, [r7, #4]
 80158d0:	611a      	str	r2, [r3, #16]
                    timer_ptr -> tx_timer_internal_active_previous =  timer_ptr;
 80158d2:	687b      	ldr	r3, [r7, #4]
 80158d4:	687a      	ldr	r2, [r7, #4]
 80158d6:	615a      	str	r2, [r3, #20]

                    /* Setup the list head pointer.  */
                    *timer_list =  timer_ptr;
 80158d8:	69fb      	ldr	r3, [r7, #28]
 80158da:	687a      	ldr	r2, [r7, #4]
 80158dc:	601a      	str	r2, [r3, #0]
 80158de:	e011      	b.n	8015904 <_tx_timer_system_activate+0xa4>
                }
                else
                {

                    /* This list is not NULL, add current timer to the end. */
                    next_timer =                                        *timer_list;
 80158e0:	69fb      	ldr	r3, [r7, #28]
 80158e2:	681b      	ldr	r3, [r3, #0]
 80158e4:	60fb      	str	r3, [r7, #12]
                    previous_timer =                                    next_timer -> tx_timer_internal_active_previous;
 80158e6:	68fb      	ldr	r3, [r7, #12]
 80158e8:	695b      	ldr	r3, [r3, #20]
 80158ea:	60bb      	str	r3, [r7, #8]
                    previous_timer -> tx_timer_internal_active_next =   timer_ptr;
 80158ec:	68bb      	ldr	r3, [r7, #8]
 80158ee:	687a      	ldr	r2, [r7, #4]
 80158f0:	611a      	str	r2, [r3, #16]
                    next_timer -> tx_timer_internal_active_previous =   timer_ptr;
 80158f2:	68fb      	ldr	r3, [r7, #12]
 80158f4:	687a      	ldr	r2, [r7, #4]
 80158f6:	615a      	str	r2, [r3, #20]
                    timer_ptr -> tx_timer_internal_active_next =        next_timer;
 80158f8:	687b      	ldr	r3, [r7, #4]
 80158fa:	68fa      	ldr	r2, [r7, #12]
 80158fc:	611a      	str	r2, [r3, #16]
                    timer_ptr -> tx_timer_internal_active_previous =    previous_timer;
 80158fe:	687b      	ldr	r3, [r7, #4]
 8015900:	68ba      	ldr	r2, [r7, #8]
 8015902:	615a      	str	r2, [r3, #20]
                }

                /* Setup list head pointer.  */
                timer_ptr -> tx_timer_internal_list_head =  timer_list;
 8015904:	687b      	ldr	r3, [r7, #4]
 8015906:	69fa      	ldr	r2, [r7, #28]
 8015908:	619a      	str	r2, [r3, #24]
            }
        }
    }
}
 801590a:	bf00      	nop
 801590c:	3724      	adds	r7, #36	; 0x24
 801590e:	46bd      	mov	sp, r7
 8015910:	f85d 7b04 	ldr.w	r7, [sp], #4
 8015914:	4770      	bx	lr
 8015916:	bf00      	nop
 8015918:	24031cf8 	.word	0x24031cf8
 801591c:	24031cf4 	.word	0x24031cf4
 8015920:	24031cf0 	.word	0x24031cf0

08015924 <_tx_timer_system_deactivate>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
VOID  _tx_timer_system_deactivate(TX_TIMER_INTERNAL *timer_ptr)
{
 8015924:	b480      	push	{r7}
 8015926:	b087      	sub	sp, #28
 8015928:	af00      	add	r7, sp, #0
 801592a:	6078      	str	r0, [r7, #4]
TX_TIMER_INTERNAL   *next_timer;
TX_TIMER_INTERNAL   *previous_timer;


    /* Pickup the list head pointer.  */
    list_head =  timer_ptr -> tx_timer_internal_list_head;
 801592c:	687b      	ldr	r3, [r7, #4]
 801592e:	699b      	ldr	r3, [r3, #24]
 8015930:	617b      	str	r3, [r7, #20]

    /* Determine if the timer still needs deactivation.  */
    if (list_head != TX_NULL)
 8015932:	697b      	ldr	r3, [r7, #20]
 8015934:	2b00      	cmp	r3, #0
 8015936:	d026      	beq.n	8015986 <_tx_timer_system_deactivate+0x62>
    {

        /* Deactivate the timer.  */

        /* Pickup the next active timer.  */
        next_timer =  timer_ptr -> tx_timer_internal_active_next;
 8015938:	687b      	ldr	r3, [r7, #4]
 801593a:	691b      	ldr	r3, [r3, #16]
 801593c:	613b      	str	r3, [r7, #16]

        /* See if this is the only timer in the list.  */
        if (timer_ptr == next_timer)
 801593e:	687a      	ldr	r2, [r7, #4]
 8015940:	693b      	ldr	r3, [r7, #16]
 8015942:	429a      	cmp	r2, r3
 8015944:	d108      	bne.n	8015958 <_tx_timer_system_deactivate+0x34>
        {

            /* Yes, the only timer on the list.  */

            /* Determine if the head pointer needs to be updated.  */
            if (*(list_head) == timer_ptr)
 8015946:	697b      	ldr	r3, [r7, #20]
 8015948:	681b      	ldr	r3, [r3, #0]
 801594a:	687a      	ldr	r2, [r7, #4]
 801594c:	429a      	cmp	r2, r3
 801594e:	d117      	bne.n	8015980 <_tx_timer_system_deactivate+0x5c>
            {

                /* Update the head pointer.  */
                *(list_head) =  TX_NULL;
 8015950:	697b      	ldr	r3, [r7, #20]
 8015952:	2200      	movs	r2, #0
 8015954:	601a      	str	r2, [r3, #0]
 8015956:	e013      	b.n	8015980 <_tx_timer_system_deactivate+0x5c>
        {

            /* At least one more timer is on the same expiration list.  */

            /* Update the links of the adjacent timers.  */
            previous_timer =                                   timer_ptr -> tx_timer_internal_active_previous;
 8015958:	687b      	ldr	r3, [r7, #4]
 801595a:	695b      	ldr	r3, [r3, #20]
 801595c:	60fb      	str	r3, [r7, #12]
            next_timer -> tx_timer_internal_active_previous =  previous_timer;
 801595e:	693b      	ldr	r3, [r7, #16]
 8015960:	68fa      	ldr	r2, [r7, #12]
 8015962:	615a      	str	r2, [r3, #20]
            previous_timer -> tx_timer_internal_active_next =  next_timer;
 8015964:	68fb      	ldr	r3, [r7, #12]
 8015966:	693a      	ldr	r2, [r7, #16]
 8015968:	611a      	str	r2, [r3, #16]

            /* Determine if the head pointer needs to be updated.  */
            if (*(list_head) == timer_ptr)
 801596a:	697b      	ldr	r3, [r7, #20]
 801596c:	681b      	ldr	r3, [r3, #0]
 801596e:	687a      	ldr	r2, [r7, #4]
 8015970:	429a      	cmp	r2, r3
 8015972:	d105      	bne.n	8015980 <_tx_timer_system_deactivate+0x5c>
            {

                /* Update the next timer in the list with the list head pointer.  */
                next_timer -> tx_timer_internal_list_head =  list_head;
 8015974:	693b      	ldr	r3, [r7, #16]
 8015976:	697a      	ldr	r2, [r7, #20]
 8015978:	619a      	str	r2, [r3, #24]

                /* Update the head pointer.  */
                *(list_head) =  next_timer;
 801597a:	697b      	ldr	r3, [r7, #20]
 801597c:	693a      	ldr	r2, [r7, #16]
 801597e:	601a      	str	r2, [r3, #0]
            }
        }

        /* Clear the timer's list head pointer.  */
        timer_ptr -> tx_timer_internal_list_head =  TX_NULL;
 8015980:	687b      	ldr	r3, [r7, #4]
 8015982:	2200      	movs	r2, #0
 8015984:	619a      	str	r2, [r3, #24]
    }
}
 8015986:	bf00      	nop
 8015988:	371c      	adds	r7, #28
 801598a:	46bd      	mov	sp, r7
 801598c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8015990:	4770      	bx	lr
	...

08015994 <_tx_timer_thread_entry>:
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
#ifndef TX_TIMER_PROCESS_IN_ISR
VOID  _tx_timer_thread_entry(ULONG timer_thread_input)
{
 8015994:	b580      	push	{r7, lr}
 8015996:	b098      	sub	sp, #96	; 0x60
 8015998:	af00      	add	r7, sp, #0
 801599a:	6078      	str	r0, [r7, #4]
TX_TIMER_INTERNAL           *reactivate_timer;
TX_TIMER_INTERNAL           *next_timer;
TX_TIMER_INTERNAL           *previous_timer;
TX_TIMER_INTERNAL           *current_timer;
VOID                        (*timeout_function)(ULONG id);
ULONG                       timeout_param =  ((ULONG) 0);
 801599c:	2300      	movs	r3, #0
 801599e:	657b      	str	r3, [r7, #84]	; 0x54
#endif


    /* Make sure the timer input is correct.  This also gets rid of the
       silly compiler warnings.  */
    if (timer_thread_input == TX_TIMER_ID)
 80159a0:	687b      	ldr	r3, [r7, #4]
 80159a2:	4a73      	ldr	r2, [pc, #460]	; (8015b70 <_tx_timer_thread_entry+0x1dc>)
 80159a4:	4293      	cmp	r3, r2
 80159a6:	f040 80de 	bne.w	8015b66 <_tx_timer_thread_entry+0x1d2>
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 80159aa:	f3ef 8310 	mrs	r3, PRIMASK
 80159ae:	643b      	str	r3, [r7, #64]	; 0x40
    return(posture);
 80159b0:	6c3b      	ldr	r3, [r7, #64]	; 0x40
    int_posture = __get_interrupt_posture();
 80159b2:	63fb      	str	r3, [r7, #60]	; 0x3c
    __asm__ volatile ("CPSID i" : : : "memory");
 80159b4:	b672      	cpsid	i
    return(int_posture);
 80159b6:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
        {

            /* First, move the current list pointer and clear the timer 
               expired value.  This allows the interrupt handling portion
               to continue looking for timer expirations.  */
            TX_DISABLE
 80159b8:	65fb      	str	r3, [r7, #92]	; 0x5c

            /* Save the current timer expiration list pointer.  */
            expired_timers =  *_tx_timer_current_ptr;
 80159ba:	4b6e      	ldr	r3, [pc, #440]	; (8015b74 <_tx_timer_thread_entry+0x1e0>)
 80159bc:	681b      	ldr	r3, [r3, #0]
 80159be:	681b      	ldr	r3, [r3, #0]
 80159c0:	60fb      	str	r3, [r7, #12]

            /* Modify the head pointer in the first timer in the list, if there
               is one!  */
            if (expired_timers != TX_NULL)
 80159c2:	68fb      	ldr	r3, [r7, #12]
 80159c4:	2b00      	cmp	r3, #0
 80159c6:	d003      	beq.n	80159d0 <_tx_timer_thread_entry+0x3c>
            {
        
                expired_timers -> tx_timer_internal_list_head =  &expired_timers;
 80159c8:	68fb      	ldr	r3, [r7, #12]
 80159ca:	f107 020c 	add.w	r2, r7, #12
 80159ce:	619a      	str	r2, [r3, #24]
            }

            /* Set the current list pointer to NULL.  */
            *_tx_timer_current_ptr =  TX_NULL;
 80159d0:	4b68      	ldr	r3, [pc, #416]	; (8015b74 <_tx_timer_thread_entry+0x1e0>)
 80159d2:	681b      	ldr	r3, [r3, #0]
 80159d4:	2200      	movs	r2, #0
 80159d6:	601a      	str	r2, [r3, #0]

            /* Move the current pointer up one timer entry wrap if we get to 
               the end of the list.  */
            _tx_timer_current_ptr =  TX_TIMER_POINTER_ADD(_tx_timer_current_ptr, 1);
 80159d8:	4b66      	ldr	r3, [pc, #408]	; (8015b74 <_tx_timer_thread_entry+0x1e0>)
 80159da:	681b      	ldr	r3, [r3, #0]
 80159dc:	3304      	adds	r3, #4
 80159de:	4a65      	ldr	r2, [pc, #404]	; (8015b74 <_tx_timer_thread_entry+0x1e0>)
 80159e0:	6013      	str	r3, [r2, #0]
            if (_tx_timer_current_ptr == _tx_timer_list_end)
 80159e2:	4b64      	ldr	r3, [pc, #400]	; (8015b74 <_tx_timer_thread_entry+0x1e0>)
 80159e4:	681a      	ldr	r2, [r3, #0]
 80159e6:	4b64      	ldr	r3, [pc, #400]	; (8015b78 <_tx_timer_thread_entry+0x1e4>)
 80159e8:	681b      	ldr	r3, [r3, #0]
 80159ea:	429a      	cmp	r2, r3
 80159ec:	d103      	bne.n	80159f6 <_tx_timer_thread_entry+0x62>
            {
        
                _tx_timer_current_ptr =  _tx_timer_list_start;
 80159ee:	4b63      	ldr	r3, [pc, #396]	; (8015b7c <_tx_timer_thread_entry+0x1e8>)
 80159f0:	681b      	ldr	r3, [r3, #0]
 80159f2:	4a60      	ldr	r2, [pc, #384]	; (8015b74 <_tx_timer_thread_entry+0x1e0>)
 80159f4:	6013      	str	r3, [r2, #0]
            }

            /* Clear the expired flag.  */
            _tx_timer_expired =  TX_FALSE;
 80159f6:	4b62      	ldr	r3, [pc, #392]	; (8015b80 <_tx_timer_thread_entry+0x1ec>)
 80159f8:	2200      	movs	r2, #0
 80159fa:	601a      	str	r2, [r3, #0]
 80159fc:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 80159fe:	633b      	str	r3, [r7, #48]	; 0x30
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 8015a00:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8015a02:	f383 8810 	msr	PRIMASK, r3
}
 8015a06:	bf00      	nop
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 8015a08:	f3ef 8310 	mrs	r3, PRIMASK
 8015a0c:	63bb      	str	r3, [r7, #56]	; 0x38
    return(posture);
 8015a0e:	6bbb      	ldr	r3, [r7, #56]	; 0x38
    int_posture = __get_interrupt_posture();
 8015a10:	637b      	str	r3, [r7, #52]	; 0x34
    __asm__ volatile ("CPSID i" : : : "memory");
 8015a12:	b672      	cpsid	i
    return(int_posture);
 8015a14:	6b7b      	ldr	r3, [r7, #52]	; 0x34

            /* Restore interrupts temporarily.  */
            TX_RESTORE

            /* Disable interrupts again.  */
            TX_DISABLE
 8015a16:	65fb      	str	r3, [r7, #92]	; 0x5c

            /* Next, process the expiration of the associated timers at this
               time slot.  */
            while (expired_timers != TX_NULL)
 8015a18:	e07f      	b.n	8015b1a <_tx_timer_thread_entry+0x186>
            {

                /* Something is on the list.  Remove it and process the expiration.  */
                current_timer =  expired_timers;
 8015a1a:	68fb      	ldr	r3, [r7, #12]
 8015a1c:	64fb      	str	r3, [r7, #76]	; 0x4c

                /* Pickup the next timer.  */
                next_timer =  expired_timers -> tx_timer_internal_active_next;
 8015a1e:	68fb      	ldr	r3, [r7, #12]
 8015a20:	691b      	ldr	r3, [r3, #16]
 8015a22:	64bb      	str	r3, [r7, #72]	; 0x48
            
                /* Set the reactivate_timer to NULL.  */
                reactivate_timer =  TX_NULL;
 8015a24:	2300      	movs	r3, #0
 8015a26:	60bb      	str	r3, [r7, #8]

                /* Determine if this is the only timer.  */
                if (current_timer == next_timer)
 8015a28:	6cfa      	ldr	r2, [r7, #76]	; 0x4c
 8015a2a:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 8015a2c:	429a      	cmp	r2, r3
 8015a2e:	d102      	bne.n	8015a36 <_tx_timer_thread_entry+0xa2>
                {

                    /* Yes, this is the only timer in the list.  */

                    /* Set the head pointer to NULL.  */
                    expired_timers =  TX_NULL;
 8015a30:	2300      	movs	r3, #0
 8015a32:	60fb      	str	r3, [r7, #12]
 8015a34:	e00e      	b.n	8015a54 <_tx_timer_thread_entry+0xc0>
                {

                    /* No, not the only expired timer.  */
            
                    /* Remove this timer from the expired list.  */
                    previous_timer =                                   current_timer -> tx_timer_internal_active_previous;
 8015a36:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8015a38:	695b      	ldr	r3, [r3, #20]
 8015a3a:	647b      	str	r3, [r7, #68]	; 0x44
                    next_timer -> tx_timer_internal_active_previous =  previous_timer;
 8015a3c:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 8015a3e:	6c7a      	ldr	r2, [r7, #68]	; 0x44
 8015a40:	615a      	str	r2, [r3, #20]
                    previous_timer -> tx_timer_internal_active_next =  next_timer;
 8015a42:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8015a44:	6cba      	ldr	r2, [r7, #72]	; 0x48
 8015a46:	611a      	str	r2, [r3, #16]

                    /* Modify the next timer's list head to point at the current list head.  */
                    next_timer -> tx_timer_internal_list_head =  &expired_timers;
 8015a48:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 8015a4a:	f107 020c 	add.w	r2, r7, #12
 8015a4e:	619a      	str	r2, [r3, #24]

                    /* Set the list head pointer.  */
                    expired_timers =  next_timer;
 8015a50:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 8015a52:	60fb      	str	r3, [r7, #12]

                /* In any case, the timer is now off of the expired list.  */

                /* Determine if the timer has expired or if it is just a really 
                   big timer that needs to be placed in the list again.  */
                if (current_timer -> tx_timer_internal_remaining_ticks > TX_TIMER_ENTRIES)
 8015a54:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8015a56:	681b      	ldr	r3, [r3, #0]
 8015a58:	2b20      	cmp	r3, #32
 8015a5a:	d911      	bls.n	8015a80 <_tx_timer_thread_entry+0xec>
                    }
#endif

                    /* Decrement the remaining ticks of the timer.  */
                    current_timer -> tx_timer_internal_remaining_ticks =  
                            current_timer -> tx_timer_internal_remaining_ticks - TX_TIMER_ENTRIES;
 8015a5c:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8015a5e:	681b      	ldr	r3, [r3, #0]
 8015a60:	f1a3 0220 	sub.w	r2, r3, #32
                    current_timer -> tx_timer_internal_remaining_ticks =  
 8015a64:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8015a66:	601a      	str	r2, [r3, #0]
                
                    /* Set the timeout function to NULL in order to bypass the
                       expiration.  */
                    timeout_function =  TX_NULL;
 8015a68:	2300      	movs	r3, #0
 8015a6a:	65bb      	str	r3, [r7, #88]	; 0x58

                    /* Make the timer appear that it is still active while interrupts
                       are enabled.  This will permit proper processing of a timer
                       deactivate from an ISR.  */
                    current_timer -> tx_timer_internal_list_head =    &reactivate_timer;
 8015a6c:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8015a6e:	f107 0208 	add.w	r2, r7, #8
 8015a72:	619a      	str	r2, [r3, #24]
                    current_timer -> tx_timer_internal_active_next =  current_timer;
 8015a74:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8015a76:	6cfa      	ldr	r2, [r7, #76]	; 0x4c
 8015a78:	611a      	str	r2, [r3, #16]

                    /* Setup the temporary timer list head pointer.  */
                    reactivate_timer =  current_timer;
 8015a7a:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8015a7c:	60bb      	str	r3, [r7, #8]
 8015a7e:	e01a      	b.n	8015ab6 <_tx_timer_thread_entry+0x122>
                    }
#endif
                  
                    /* Copy the calling function and ID into local variables before interrupts 
                       are re-enabled.  */
                    timeout_function =  current_timer -> tx_timer_internal_timeout_function;
 8015a80:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8015a82:	689b      	ldr	r3, [r3, #8]
 8015a84:	65bb      	str	r3, [r7, #88]	; 0x58
                    timeout_param =     current_timer -> tx_timer_internal_timeout_param;
 8015a86:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8015a88:	68db      	ldr	r3, [r3, #12]
 8015a8a:	657b      	str	r3, [r7, #84]	; 0x54

                    /* Copy the reinitialize ticks into the remaining ticks.  */
                    current_timer -> tx_timer_internal_remaining_ticks =  current_timer -> tx_timer_internal_re_initialize_ticks;
 8015a8c:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8015a8e:	685a      	ldr	r2, [r3, #4]
 8015a90:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8015a92:	601a      	str	r2, [r3, #0]

                    /* Determine if the timer should be reactivated.  */
                    if (current_timer -> tx_timer_internal_remaining_ticks != ((ULONG) 0))
 8015a94:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8015a96:	681b      	ldr	r3, [r3, #0]
 8015a98:	2b00      	cmp	r3, #0
 8015a9a:	d009      	beq.n	8015ab0 <_tx_timer_thread_entry+0x11c>

                        /* Make the timer appear that it is still active while processing
                           the expiration routine and with interrupts enabled.  This will 
                           permit proper processing of a timer deactivate from both the
                           expiration routine and an ISR.  */
                        current_timer -> tx_timer_internal_list_head =    &reactivate_timer;
 8015a9c:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8015a9e:	f107 0208 	add.w	r2, r7, #8
 8015aa2:	619a      	str	r2, [r3, #24]
                        current_timer -> tx_timer_internal_active_next =  current_timer;
 8015aa4:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8015aa6:	6cfa      	ldr	r2, [r7, #76]	; 0x4c
 8015aa8:	611a      	str	r2, [r3, #16]
                        
                        /* Setup the temporary timer list head pointer.  */
                        reactivate_timer =  current_timer;
 8015aaa:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8015aac:	60bb      	str	r3, [r7, #8]
 8015aae:	e002      	b.n	8015ab6 <_tx_timer_thread_entry+0x122>
                    else
                    {

                        /* Set the list pointer of this timer to NULL.  This is used to indicate
                           the timer is no longer active.  */
                        current_timer -> tx_timer_internal_list_head =  TX_NULL;
 8015ab0:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8015ab2:	2200      	movs	r2, #0
 8015ab4:	619a      	str	r2, [r3, #24]
                    }
                }

                /* Set pointer to indicate the expired timer that is currently being processed.  */
                _tx_timer_expired_timer_ptr =  current_timer;
 8015ab6:	4a33      	ldr	r2, [pc, #204]	; (8015b84 <_tx_timer_thread_entry+0x1f0>)
 8015ab8:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8015aba:	6013      	str	r3, [r2, #0]
 8015abc:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 8015abe:	62fb      	str	r3, [r7, #44]	; 0x2c
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 8015ac0:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8015ac2:	f383 8810 	msr	PRIMASK, r3
}
 8015ac6:	bf00      	nop

                /* Restore interrupts for timer expiration call.  */
                TX_RESTORE

                /* Call the timer-expiration function, if non-NULL.  */
                if (timeout_function != TX_NULL)
 8015ac8:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 8015aca:	2b00      	cmp	r3, #0
 8015acc:	d002      	beq.n	8015ad4 <_tx_timer_thread_entry+0x140>
                {
            
                    (timeout_function) (timeout_param);
 8015ace:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 8015ad0:	6d78      	ldr	r0, [r7, #84]	; 0x54
 8015ad2:	4798      	blx	r3
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 8015ad4:	f3ef 8310 	mrs	r3, PRIMASK
 8015ad8:	62bb      	str	r3, [r7, #40]	; 0x28
    return(posture);
 8015ada:	6abb      	ldr	r3, [r7, #40]	; 0x28
    int_posture = __get_interrupt_posture();
 8015adc:	627b      	str	r3, [r7, #36]	; 0x24
    __asm__ volatile ("CPSID i" : : : "memory");
 8015ade:	b672      	cpsid	i
    return(int_posture);
 8015ae0:	6a7b      	ldr	r3, [r7, #36]	; 0x24
                }

                /* Lockout interrupts again.  */
                TX_DISABLE
 8015ae2:	65fb      	str	r3, [r7, #92]	; 0x5c

                /* Clear expired timer pointer.  */
                _tx_timer_expired_timer_ptr =  TX_NULL;
 8015ae4:	4b27      	ldr	r3, [pc, #156]	; (8015b84 <_tx_timer_thread_entry+0x1f0>)
 8015ae6:	2200      	movs	r2, #0
 8015ae8:	601a      	str	r2, [r3, #0]

                /* Determine if the timer needs to be reactivated.  */
                if (reactivate_timer == current_timer)
 8015aea:	68bb      	ldr	r3, [r7, #8]
 8015aec:	6cfa      	ldr	r2, [r7, #76]	; 0x4c
 8015aee:	429a      	cmp	r2, r3
 8015af0:	d105      	bne.n	8015afe <_tx_timer_thread_entry+0x16a>
#else

                    /* Reactivate through the timer activate function.  */

                    /* Clear the list head for the timer activate call.  */
                    current_timer -> tx_timer_internal_list_head = TX_NULL;
 8015af2:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8015af4:	2200      	movs	r2, #0
 8015af6:	619a      	str	r2, [r3, #24]

                    /* Activate the current timer.  */
                    _tx_timer_system_activate(current_timer);
 8015af8:	6cf8      	ldr	r0, [r7, #76]	; 0x4c
 8015afa:	f7ff feb1 	bl	8015860 <_tx_timer_system_activate>
 8015afe:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 8015b00:	61bb      	str	r3, [r7, #24]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 8015b02:	69bb      	ldr	r3, [r7, #24]
 8015b04:	f383 8810 	msr	PRIMASK, r3
}
 8015b08:	bf00      	nop
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 8015b0a:	f3ef 8310 	mrs	r3, PRIMASK
 8015b0e:	623b      	str	r3, [r7, #32]
    return(posture);
 8015b10:	6a3b      	ldr	r3, [r7, #32]
    int_posture = __get_interrupt_posture();
 8015b12:	61fb      	str	r3, [r7, #28]
    __asm__ volatile ("CPSID i" : : : "memory");
 8015b14:	b672      	cpsid	i
    return(int_posture);
 8015b16:	69fb      	ldr	r3, [r7, #28]

                /* Restore interrupts.  */
                TX_RESTORE

                /* Lockout interrupts again.  */
                TX_DISABLE
 8015b18:	65fb      	str	r3, [r7, #92]	; 0x5c
            while (expired_timers != TX_NULL)
 8015b1a:	68fb      	ldr	r3, [r7, #12]
 8015b1c:	2b00      	cmp	r3, #0
 8015b1e:	f47f af7c 	bne.w	8015a1a <_tx_timer_thread_entry+0x86>

            /* Finally, suspend this thread and wait for the next expiration.  */

            /* Determine if another expiration took place while we were in this
               thread.  If so, process another expiration.  */
            if (_tx_timer_expired == TX_FALSE)
 8015b22:	4b17      	ldr	r3, [pc, #92]	; (8015b80 <_tx_timer_thread_entry+0x1ec>)
 8015b24:	681b      	ldr	r3, [r3, #0]
 8015b26:	2b00      	cmp	r3, #0
 8015b28:	d116      	bne.n	8015b58 <_tx_timer_thread_entry+0x1c4>
            {

                /* Otherwise, no timer expiration, so suspend the thread.  */

                /* Build pointer to the timer thread.  */
                thread_ptr =  &_tx_timer_thread;
 8015b2a:	4b17      	ldr	r3, [pc, #92]	; (8015b88 <_tx_timer_thread_entry+0x1f4>)
 8015b2c:	653b      	str	r3, [r7, #80]	; 0x50

                /* Set the status to suspending, in order to indicate the 
                   suspension is in progress.  */
                thread_ptr -> tx_thread_state =  TX_SUSPENDED;
 8015b2e:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 8015b30:	2203      	movs	r2, #3
 8015b32:	631a      	str	r2, [r3, #48]	; 0x30
                /* Restore interrupts.  */
                TX_RESTORE
#else

                /* Set the suspending flag. */
                thread_ptr -> tx_thread_suspending =  TX_TRUE;
 8015b34:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 8015b36:	2201      	movs	r2, #1
 8015b38:	639a      	str	r2, [r3, #56]	; 0x38

                /* Increment the preempt disable count prior to suspending.  */
                _tx_thread_preempt_disable++;
 8015b3a:	4b14      	ldr	r3, [pc, #80]	; (8015b8c <_tx_timer_thread_entry+0x1f8>)
 8015b3c:	681b      	ldr	r3, [r3, #0]
 8015b3e:	3301      	adds	r3, #1
 8015b40:	4a12      	ldr	r2, [pc, #72]	; (8015b8c <_tx_timer_thread_entry+0x1f8>)
 8015b42:	6013      	str	r3, [r2, #0]
 8015b44:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 8015b46:	617b      	str	r3, [r7, #20]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 8015b48:	697b      	ldr	r3, [r7, #20]
 8015b4a:	f383 8810 	msr	PRIMASK, r3
}
 8015b4e:	bf00      	nop

                /* Restore interrupts.  */
                TX_RESTORE

                /* Call actual thread suspension routine.  */
                _tx_thread_system_suspend(thread_ptr);
 8015b50:	6d38      	ldr	r0, [r7, #80]	; 0x50
 8015b52:	f7ff f9e9 	bl	8014f28 <_tx_thread_system_suspend>
 8015b56:	e728      	b.n	80159aa <_tx_timer_thread_entry+0x16>
 8015b58:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 8015b5a:	613b      	str	r3, [r7, #16]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 8015b5c:	693b      	ldr	r3, [r7, #16]
 8015b5e:	f383 8810 	msr	PRIMASK, r3
}
 8015b62:	bf00      	nop
            TX_DISABLE
 8015b64:	e721      	b.n	80159aa <_tx_timer_thread_entry+0x16>

    /* If we ever get here, raise safety critical exception.  */
    TX_SAFETY_CRITICAL_EXCEPTION(__FILE__, __LINE__, 0);
#endif

}
 8015b66:	bf00      	nop
 8015b68:	3760      	adds	r7, #96	; 0x60
 8015b6a:	46bd      	mov	sp, r7
 8015b6c:	bd80      	pop	{r7, pc}
 8015b6e:	bf00      	nop
 8015b70:	4154494d 	.word	0x4154494d
 8015b74:	24031cf8 	.word	0x24031cf8
 8015b78:	24031cf4 	.word	0x24031cf4
 8015b7c:	24031cf0 	.word	0x24031cf0
 8015b80:	24031cfc 	.word	0x24031cfc
 8015b84:	24031d08 	.word	0x24031d08
 8015b88:	24031d0c 	.word	0x24031d0c
 8015b8c:	24031c5c 	.word	0x24031c5c

08015b90 <_txe_byte_allocate>:
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
UINT  _txe_byte_allocate(TX_BYTE_POOL *pool_ptr, VOID **memory_ptr, 
                                    ULONG memory_size,  ULONG wait_option)
{
 8015b90:	b580      	push	{r7, lr}
 8015b92:	b08a      	sub	sp, #40	; 0x28
 8015b94:	af00      	add	r7, sp, #0
 8015b96:	60f8      	str	r0, [r7, #12]
 8015b98:	60b9      	str	r1, [r7, #8]
 8015b9a:	607a      	str	r2, [r7, #4]
 8015b9c:	603b      	str	r3, [r7, #0]
TX_THREAD       *thread_ptr;
#endif


    /* Default status to success.  */
    status =  TX_SUCCESS;
 8015b9e:	2300      	movs	r3, #0
 8015ba0:	627b      	str	r3, [r7, #36]	; 0x24

    /* Check for an invalid byte pool pointer.  */
    if (pool_ptr == TX_NULL)
 8015ba2:	68fb      	ldr	r3, [r7, #12]
 8015ba4:	2b00      	cmp	r3, #0
 8015ba6:	d102      	bne.n	8015bae <_txe_byte_allocate+0x1e>
    {
        
        /* Byte pool pointer is invalid, return appropriate error code.  */
        status =  TX_POOL_ERROR;
 8015ba8:	2302      	movs	r3, #2
 8015baa:	627b      	str	r3, [r7, #36]	; 0x24
 8015bac:	e029      	b.n	8015c02 <_txe_byte_allocate+0x72>
    }
    
    /* Now check for invalid pool ID.  */
    else if  (pool_ptr -> tx_byte_pool_id != TX_BYTE_POOL_ID)
 8015bae:	68fb      	ldr	r3, [r7, #12]
 8015bb0:	681b      	ldr	r3, [r3, #0]
 8015bb2:	4a2d      	ldr	r2, [pc, #180]	; (8015c68 <_txe_byte_allocate+0xd8>)
 8015bb4:	4293      	cmp	r3, r2
 8015bb6:	d002      	beq.n	8015bbe <_txe_byte_allocate+0x2e>
    {
        
        /* Byte pool pointer is invalid, return appropriate error code.  */
        status =  TX_POOL_ERROR;
 8015bb8:	2302      	movs	r3, #2
 8015bba:	627b      	str	r3, [r7, #36]	; 0x24
 8015bbc:	e021      	b.n	8015c02 <_txe_byte_allocate+0x72>
    }

    /* Check for an invalid destination for return pointer.  */
    else if (memory_ptr == TX_NULL)
 8015bbe:	68bb      	ldr	r3, [r7, #8]
 8015bc0:	2b00      	cmp	r3, #0
 8015bc2:	d102      	bne.n	8015bca <_txe_byte_allocate+0x3a>
    {

        /* Null destination pointer, return appropriate error.  */
        status =  TX_PTR_ERROR;
 8015bc4:	2303      	movs	r3, #3
 8015bc6:	627b      	str	r3, [r7, #36]	; 0x24
 8015bc8:	e01b      	b.n	8015c02 <_txe_byte_allocate+0x72>
    }

    /* Check for an invalid memory size.  */
    else if (memory_size == ((ULONG) 0))
 8015bca:	687b      	ldr	r3, [r7, #4]
 8015bcc:	2b00      	cmp	r3, #0
 8015bce:	d102      	bne.n	8015bd6 <_txe_byte_allocate+0x46>
    {

        /* Error in size, return appropriate error.  */
        status =  TX_SIZE_ERROR;
 8015bd0:	2305      	movs	r3, #5
 8015bd2:	627b      	str	r3, [r7, #36]	; 0x24
 8015bd4:	e015      	b.n	8015c02 <_txe_byte_allocate+0x72>
    }
    
    /* Determine if the size is greater than the pool size.  */
    else if (memory_size > pool_ptr -> tx_byte_pool_size)
 8015bd6:	68fb      	ldr	r3, [r7, #12]
 8015bd8:	69db      	ldr	r3, [r3, #28]
 8015bda:	687a      	ldr	r2, [r7, #4]
 8015bdc:	429a      	cmp	r2, r3
 8015bde:	d902      	bls.n	8015be6 <_txe_byte_allocate+0x56>
    {

        /* Error in size, return appropriate error.  */
        status =  TX_SIZE_ERROR;
 8015be0:	2305      	movs	r3, #5
 8015be2:	627b      	str	r3, [r7, #36]	; 0x24
 8015be4:	e00d      	b.n	8015c02 <_txe_byte_allocate+0x72>
    else
    {

        /* Check for a wait option error.  Only threads are allowed any form of 
           suspension.  */
        if (wait_option != TX_NO_WAIT)
 8015be6:	683b      	ldr	r3, [r7, #0]
 8015be8:	2b00      	cmp	r3, #0
 8015bea:	d00a      	beq.n	8015c02 <_txe_byte_allocate+0x72>
    __asm__ volatile (" MRS  %0,IPSR ": "=r" (ipsr_value) );
 8015bec:	f3ef 8305 	mrs	r3, IPSR
 8015bf0:	61fb      	str	r3, [r7, #28]
    return(ipsr_value);
 8015bf2:	69fa      	ldr	r2, [r7, #28]
        {

            /* Is call from ISR or Initialization?  */
            if (TX_THREAD_GET_SYSTEM_STATE() != ((ULONG) 0))
 8015bf4:	4b1d      	ldr	r3, [pc, #116]	; (8015c6c <_txe_byte_allocate+0xdc>)
 8015bf6:	681b      	ldr	r3, [r3, #0]
 8015bf8:	4313      	orrs	r3, r2
 8015bfa:	2b00      	cmp	r3, #0
 8015bfc:	d001      	beq.n	8015c02 <_txe_byte_allocate+0x72>
            {
        
                /* A non-thread is trying to suspend, return appropriate error code.  */
                status =  TX_WAIT_ERROR;
 8015bfe:	2304      	movs	r3, #4
 8015c00:	627b      	str	r3, [r7, #36]	; 0x24
        }
    }
#ifndef TX_TIMER_PROCESS_IN_ISR
    
    /* Check for timer execution.  */
    if (status == TX_SUCCESS)
 8015c02:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8015c04:	2b00      	cmp	r3, #0
 8015c06:	d108      	bne.n	8015c1a <_txe_byte_allocate+0x8a>
    {

        /* Pickup thread pointer.  */
        TX_THREAD_GET_CURRENT(thread_ptr)
 8015c08:	4b19      	ldr	r3, [pc, #100]	; (8015c70 <_txe_byte_allocate+0xe0>)
 8015c0a:	681b      	ldr	r3, [r3, #0]
 8015c0c:	623b      	str	r3, [r7, #32]

        /* Check for invalid caller of this function.  First check for a calling thread.  */
        if (thread_ptr == &_tx_timer_thread)
 8015c0e:	6a3b      	ldr	r3, [r7, #32]
 8015c10:	4a18      	ldr	r2, [pc, #96]	; (8015c74 <_txe_byte_allocate+0xe4>)
 8015c12:	4293      	cmp	r3, r2
 8015c14:	d101      	bne.n	8015c1a <_txe_byte_allocate+0x8a>
        {

            /* Invalid caller of this function, return appropriate error code.  */
            status =  TX_CALLER_ERROR;
 8015c16:	2313      	movs	r3, #19
 8015c18:	627b      	str	r3, [r7, #36]	; 0x24
        }
    }
#endif

    /* Is everything still okay?  */
    if (status == TX_SUCCESS)
 8015c1a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8015c1c:	2b00      	cmp	r3, #0
 8015c1e:	d114      	bne.n	8015c4a <_txe_byte_allocate+0xba>
    __asm__ volatile (" MRS  %0,IPSR ": "=r" (ipsr_value) );
 8015c20:	f3ef 8305 	mrs	r3, IPSR
 8015c24:	61bb      	str	r3, [r7, #24]
    return(ipsr_value);
 8015c26:	69ba      	ldr	r2, [r7, #24]
    {
    
        /* Check for interrupt call.  */
        if (TX_THREAD_GET_SYSTEM_STATE() != ((ULONG) 0))
 8015c28:	4b10      	ldr	r3, [pc, #64]	; (8015c6c <_txe_byte_allocate+0xdc>)
 8015c2a:	681b      	ldr	r3, [r3, #0]
 8015c2c:	4313      	orrs	r3, r2
 8015c2e:	2b00      	cmp	r3, #0
 8015c30:	d00b      	beq.n	8015c4a <_txe_byte_allocate+0xba>
    __asm__ volatile (" MRS  %0,IPSR ": "=r" (ipsr_value) );
 8015c32:	f3ef 8305 	mrs	r3, IPSR
 8015c36:	617b      	str	r3, [r7, #20]
    return(ipsr_value);
 8015c38:	697a      	ldr	r2, [r7, #20]
        {
    
            /* Now, make sure the call is from an interrupt and not initialization.  */
            if (TX_THREAD_GET_SYSTEM_STATE() < TX_INITIALIZE_IN_PROGRESS)
 8015c3a:	4b0c      	ldr	r3, [pc, #48]	; (8015c6c <_txe_byte_allocate+0xdc>)
 8015c3c:	681b      	ldr	r3, [r3, #0]
 8015c3e:	4313      	orrs	r3, r2
 8015c40:	f1b3 3ff0 	cmp.w	r3, #4042322160	; 0xf0f0f0f0
 8015c44:	d201      	bcs.n	8015c4a <_txe_byte_allocate+0xba>
            {
        
                /* Invalid caller of this function, return appropriate error code.  */
                status =  TX_CALLER_ERROR;
 8015c46:	2313      	movs	r3, #19
 8015c48:	627b      	str	r3, [r7, #36]	; 0x24
            }
        }
    }

    /* Determine if everything is okay.  */
    if (status == TX_SUCCESS)
 8015c4a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8015c4c:	2b00      	cmp	r3, #0
 8015c4e:	d106      	bne.n	8015c5e <_txe_byte_allocate+0xce>
    {

        /* Call actual byte memory allocate function.  */
        status =  _tx_byte_allocate(pool_ptr, memory_ptr, memory_size,  wait_option);
 8015c50:	683b      	ldr	r3, [r7, #0]
 8015c52:	687a      	ldr	r2, [r7, #4]
 8015c54:	68b9      	ldr	r1, [r7, #8]
 8015c56:	68f8      	ldr	r0, [r7, #12]
 8015c58:	f7fb fe88 	bl	801196c <_tx_byte_allocate>
 8015c5c:	6278      	str	r0, [r7, #36]	; 0x24
    }

    /* Return completion status.  */
    return(status);
 8015c5e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
}
 8015c60:	4618      	mov	r0, r3
 8015c62:	3728      	adds	r7, #40	; 0x28
 8015c64:	46bd      	mov	sp, r7
 8015c66:	bd80      	pop	{r7, pc}
 8015c68:	42595445 	.word	0x42595445
 8015c6c:	24000078 	.word	0x24000078
 8015c70:	24031bc4 	.word	0x24031bc4
 8015c74:	24031d0c 	.word	0x24031d0c

08015c78 <_txe_byte_pool_create>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
UINT  _txe_byte_pool_create(TX_BYTE_POOL *pool_ptr, CHAR *name_ptr, VOID *pool_start, ULONG pool_size, UINT pool_control_block_size)
{
 8015c78:	b580      	push	{r7, lr}
 8015c7a:	b092      	sub	sp, #72	; 0x48
 8015c7c:	af00      	add	r7, sp, #0
 8015c7e:	60f8      	str	r0, [r7, #12]
 8015c80:	60b9      	str	r1, [r7, #8]
 8015c82:	607a      	str	r2, [r7, #4]
 8015c84:	603b      	str	r3, [r7, #0]
TX_THREAD       *thread_ptr;
#endif


    /* Default status to success.  */
    status =  TX_SUCCESS;
 8015c86:	2300      	movs	r3, #0
 8015c88:	647b      	str	r3, [r7, #68]	; 0x44

    /* Check for an invalid byte pool pointer.  */
    if (pool_ptr == TX_NULL)
 8015c8a:	68fb      	ldr	r3, [r7, #12]
 8015c8c:	2b00      	cmp	r3, #0
 8015c8e:	d102      	bne.n	8015c96 <_txe_byte_pool_create+0x1e>
    {

        /* Byte pool pointer is invalid, return appropriate error code.  */
        status =  TX_POOL_ERROR;
 8015c90:	2302      	movs	r3, #2
 8015c92:	647b      	str	r3, [r7, #68]	; 0x44
 8015c94:	e075      	b.n	8015d82 <_txe_byte_pool_create+0x10a>
    }

    /* Now see if the pool control block size is valid.  */
    else if (pool_control_block_size != (sizeof(TX_BYTE_POOL)))
 8015c96:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 8015c98:	2b34      	cmp	r3, #52	; 0x34
 8015c9a:	d002      	beq.n	8015ca2 <_txe_byte_pool_create+0x2a>
    {

        /* Byte pool pointer is invalid, return appropriate error code.  */
        status =  TX_POOL_ERROR;
 8015c9c:	2302      	movs	r3, #2
 8015c9e:	647b      	str	r3, [r7, #68]	; 0x44
 8015ca0:	e06f      	b.n	8015d82 <_txe_byte_pool_create+0x10a>
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 8015ca2:	f3ef 8310 	mrs	r3, PRIMASK
 8015ca6:	62fb      	str	r3, [r7, #44]	; 0x2c
    return(posture);
 8015ca8:	6afb      	ldr	r3, [r7, #44]	; 0x2c
    int_posture = __get_interrupt_posture();
 8015caa:	62bb      	str	r3, [r7, #40]	; 0x28
    __asm__ volatile ("CPSID i" : : : "memory");
 8015cac:	b672      	cpsid	i
    return(int_posture);
 8015cae:	6abb      	ldr	r3, [r7, #40]	; 0x28
    }
    else
    {
    
        /* Disable interrupts.  */
        TX_DISABLE
 8015cb0:	63bb      	str	r3, [r7, #56]	; 0x38

        /* Increment the preempt disable flag.  */
        _tx_thread_preempt_disable++;
 8015cb2:	4b3b      	ldr	r3, [pc, #236]	; (8015da0 <_txe_byte_pool_create+0x128>)
 8015cb4:	681b      	ldr	r3, [r3, #0]
 8015cb6:	3301      	adds	r3, #1
 8015cb8:	4a39      	ldr	r2, [pc, #228]	; (8015da0 <_txe_byte_pool_create+0x128>)
 8015cba:	6013      	str	r3, [r2, #0]
 8015cbc:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8015cbe:	633b      	str	r3, [r7, #48]	; 0x30
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 8015cc0:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8015cc2:	f383 8810 	msr	PRIMASK, r3
}
 8015cc6:	bf00      	nop

        /* Restore interrupts.  */
        TX_RESTORE

        /* Next see if it is already in the created list.  */
        next_pool =   _tx_byte_pool_created_ptr;
 8015cc8:	4b36      	ldr	r3, [pc, #216]	; (8015da4 <_txe_byte_pool_create+0x12c>)
 8015cca:	681b      	ldr	r3, [r3, #0]
 8015ccc:	63fb      	str	r3, [r7, #60]	; 0x3c
        for (i = ((ULONG) 0); i < _tx_byte_pool_created_count; i++)
 8015cce:	2300      	movs	r3, #0
 8015cd0:	643b      	str	r3, [r7, #64]	; 0x40
 8015cd2:	e009      	b.n	8015ce8 <_txe_byte_pool_create+0x70>
        {

            /* Determine if this byte pool matches the pool in the list.  */
            if (pool_ptr == next_pool)
 8015cd4:	68fa      	ldr	r2, [r7, #12]
 8015cd6:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8015cd8:	429a      	cmp	r2, r3
 8015cda:	d00b      	beq.n	8015cf4 <_txe_byte_pool_create+0x7c>
            }
            else
            {

                /* Move to the next pool.  */
                next_pool =  next_pool -> tx_byte_pool_created_next;
 8015cdc:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8015cde:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8015ce0:	63fb      	str	r3, [r7, #60]	; 0x3c
        for (i = ((ULONG) 0); i < _tx_byte_pool_created_count; i++)
 8015ce2:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8015ce4:	3301      	adds	r3, #1
 8015ce6:	643b      	str	r3, [r7, #64]	; 0x40
 8015ce8:	4b2f      	ldr	r3, [pc, #188]	; (8015da8 <_txe_byte_pool_create+0x130>)
 8015cea:	681b      	ldr	r3, [r3, #0]
 8015cec:	6c3a      	ldr	r2, [r7, #64]	; 0x40
 8015cee:	429a      	cmp	r2, r3
 8015cf0:	d3f0      	bcc.n	8015cd4 <_txe_byte_pool_create+0x5c>
 8015cf2:	e000      	b.n	8015cf6 <_txe_byte_pool_create+0x7e>
                break;
 8015cf4:	bf00      	nop
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 8015cf6:	f3ef 8310 	mrs	r3, PRIMASK
 8015cfa:	623b      	str	r3, [r7, #32]
    return(posture);
 8015cfc:	6a3b      	ldr	r3, [r7, #32]
    int_posture = __get_interrupt_posture();
 8015cfe:	61fb      	str	r3, [r7, #28]
    __asm__ volatile ("CPSID i" : : : "memory");
 8015d00:	b672      	cpsid	i
    return(int_posture);
 8015d02:	69fb      	ldr	r3, [r7, #28]
            }
        }

        /* Disable interrupts.  */
        TX_DISABLE
 8015d04:	63bb      	str	r3, [r7, #56]	; 0x38

        /* Decrement the preempt disable flag.  */
        _tx_thread_preempt_disable--;
 8015d06:	4b26      	ldr	r3, [pc, #152]	; (8015da0 <_txe_byte_pool_create+0x128>)
 8015d08:	681b      	ldr	r3, [r3, #0]
 8015d0a:	3b01      	subs	r3, #1
 8015d0c:	4a24      	ldr	r2, [pc, #144]	; (8015da0 <_txe_byte_pool_create+0x128>)
 8015d0e:	6013      	str	r3, [r2, #0]
 8015d10:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8015d12:	627b      	str	r3, [r7, #36]	; 0x24
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 8015d14:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8015d16:	f383 8810 	msr	PRIMASK, r3
}
 8015d1a:	bf00      	nop
    
        /* Restore interrupts.  */
        TX_RESTORE

        /* Check for preemption.  */
        _tx_thread_system_preempt_check();
 8015d1c:	f7fe ffca 	bl	8014cb4 <_tx_thread_system_preempt_check>

        /* At this point, check to see if there is a duplicate pool.  */
        if (pool_ptr == next_pool)
 8015d20:	68fa      	ldr	r2, [r7, #12]
 8015d22:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8015d24:	429a      	cmp	r2, r3
 8015d26:	d102      	bne.n	8015d2e <_txe_byte_pool_create+0xb6>
        {

            /* Pool is already created, return appropriate error code.  */
            status =  TX_POOL_ERROR;
 8015d28:	2302      	movs	r3, #2
 8015d2a:	647b      	str	r3, [r7, #68]	; 0x44
 8015d2c:	e029      	b.n	8015d82 <_txe_byte_pool_create+0x10a>
        }

        /* Check for an invalid starting address.  */
        else if (pool_start == TX_NULL)
 8015d2e:	687b      	ldr	r3, [r7, #4]
 8015d30:	2b00      	cmp	r3, #0
 8015d32:	d102      	bne.n	8015d3a <_txe_byte_pool_create+0xc2>
        {
    
            /* Null starting address pointer, return appropriate error.  */
            status =  TX_PTR_ERROR;
 8015d34:	2303      	movs	r3, #3
 8015d36:	647b      	str	r3, [r7, #68]	; 0x44
 8015d38:	e023      	b.n	8015d82 <_txe_byte_pool_create+0x10a>
        }

        /* Check for invalid pool size.  */
        else if (pool_size < TX_BYTE_POOL_MIN)
 8015d3a:	683b      	ldr	r3, [r7, #0]
 8015d3c:	2b63      	cmp	r3, #99	; 0x63
 8015d3e:	d802      	bhi.n	8015d46 <_txe_byte_pool_create+0xce>
        {

            /* Pool not big enough, return appropriate error.  */
            status =  TX_SIZE_ERROR;
 8015d40:	2305      	movs	r3, #5
 8015d42:	647b      	str	r3, [r7, #68]	; 0x44
 8015d44:	e01d      	b.n	8015d82 <_txe_byte_pool_create+0x10a>
        {

#ifndef TX_TIMER_PROCESS_IN_ISR

            /* Pickup thread pointer.  */
            TX_THREAD_GET_CURRENT(thread_ptr)
 8015d46:	4b19      	ldr	r3, [pc, #100]	; (8015dac <_txe_byte_pool_create+0x134>)
 8015d48:	681b      	ldr	r3, [r3, #0]
 8015d4a:	637b      	str	r3, [r7, #52]	; 0x34

            /* Check for invalid caller of this function.  First check for a calling thread.  */
            if (thread_ptr == &_tx_timer_thread)
 8015d4c:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8015d4e:	4a18      	ldr	r2, [pc, #96]	; (8015db0 <_txe_byte_pool_create+0x138>)
 8015d50:	4293      	cmp	r3, r2
 8015d52:	d101      	bne.n	8015d58 <_txe_byte_pool_create+0xe0>
            {

                /* Invalid caller of this function, return appropriate error code.  */
                status =  TX_CALLER_ERROR;
 8015d54:	2313      	movs	r3, #19
 8015d56:	647b      	str	r3, [r7, #68]	; 0x44
    __asm__ volatile (" MRS  %0,IPSR ": "=r" (ipsr_value) );
 8015d58:	f3ef 8305 	mrs	r3, IPSR
 8015d5c:	61bb      	str	r3, [r7, #24]
    return(ipsr_value);
 8015d5e:	69ba      	ldr	r2, [r7, #24]
            }
#endif

            /* Check for interrupt call.  */
            if (TX_THREAD_GET_SYSTEM_STATE() != ((ULONG) 0))
 8015d60:	4b14      	ldr	r3, [pc, #80]	; (8015db4 <_txe_byte_pool_create+0x13c>)
 8015d62:	681b      	ldr	r3, [r3, #0]
 8015d64:	4313      	orrs	r3, r2
 8015d66:	2b00      	cmp	r3, #0
 8015d68:	d00b      	beq.n	8015d82 <_txe_byte_pool_create+0x10a>
    __asm__ volatile (" MRS  %0,IPSR ": "=r" (ipsr_value) );
 8015d6a:	f3ef 8305 	mrs	r3, IPSR
 8015d6e:	617b      	str	r3, [r7, #20]
    return(ipsr_value);
 8015d70:	697a      	ldr	r2, [r7, #20]
            {
    
                /* Now, make sure the call is from an interrupt and not initialization.  */
                if (TX_THREAD_GET_SYSTEM_STATE() < TX_INITIALIZE_IN_PROGRESS)
 8015d72:	4b10      	ldr	r3, [pc, #64]	; (8015db4 <_txe_byte_pool_create+0x13c>)
 8015d74:	681b      	ldr	r3, [r3, #0]
 8015d76:	4313      	orrs	r3, r2
 8015d78:	f1b3 3ff0 	cmp.w	r3, #4042322160	; 0xf0f0f0f0
 8015d7c:	d201      	bcs.n	8015d82 <_txe_byte_pool_create+0x10a>
                {
        
                    /* Invalid caller of this function, return appropriate error code.  */
                    status =  TX_CALLER_ERROR;
 8015d7e:	2313      	movs	r3, #19
 8015d80:	647b      	str	r3, [r7, #68]	; 0x44
            }
        }
    }

    /* Determine if everything is okay.  */
    if (status == TX_SUCCESS)
 8015d82:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8015d84:	2b00      	cmp	r3, #0
 8015d86:	d106      	bne.n	8015d96 <_txe_byte_pool_create+0x11e>
    {

        /* Call actual byte pool create function.  */
        status =  _tx_byte_pool_create(pool_ptr, name_ptr, pool_start, pool_size);
 8015d88:	683b      	ldr	r3, [r7, #0]
 8015d8a:	687a      	ldr	r2, [r7, #4]
 8015d8c:	68b9      	ldr	r1, [r7, #8]
 8015d8e:	68f8      	ldr	r0, [r7, #12]
 8015d90:	f7fb ff2e 	bl	8011bf0 <_tx_byte_pool_create>
 8015d94:	6478      	str	r0, [r7, #68]	; 0x44
    }

    /* Return completion status.  */
    return(status);
 8015d96:	6c7b      	ldr	r3, [r7, #68]	; 0x44
}
 8015d98:	4618      	mov	r0, r3
 8015d9a:	3748      	adds	r7, #72	; 0x48
 8015d9c:	46bd      	mov	sp, r7
 8015d9e:	bd80      	pop	{r7, pc}
 8015da0:	24031c5c 	.word	0x24031c5c
 8015da4:	24031bb4 	.word	0x24031bb4
 8015da8:	24031bb8 	.word	0x24031bb8
 8015dac:	24031bc4 	.word	0x24031bc4
 8015db0:	24031d0c 	.word	0x24031d0c
 8015db4:	24000078 	.word	0x24000078

08015db8 <_txe_byte_release>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
UINT  _txe_byte_release(VOID *memory_ptr)
{
 8015db8:	b580      	push	{r7, lr}
 8015dba:	b086      	sub	sp, #24
 8015dbc:	af00      	add	r7, sp, #0
 8015dbe:	6078      	str	r0, [r7, #4]
TX_THREAD       *thread_ptr;
#endif


    /* Default status to success.  */
    status =  TX_SUCCESS;
 8015dc0:	2300      	movs	r3, #0
 8015dc2:	617b      	str	r3, [r7, #20]

    /* First check the supplied memory pointer.  */
    if (memory_ptr == TX_NULL)
 8015dc4:	687b      	ldr	r3, [r7, #4]
 8015dc6:	2b00      	cmp	r3, #0
 8015dc8:	d102      	bne.n	8015dd0 <_txe_byte_release+0x18>
    {

        /* The byte memory pointer is invalid, return appropriate status.  */
        status =  TX_PTR_ERROR;
 8015dca:	2303      	movs	r3, #3
 8015dcc:	617b      	str	r3, [r7, #20]
 8015dce:	e01d      	b.n	8015e0c <_txe_byte_release+0x54>
    {

#ifndef TX_TIMER_PROCESS_IN_ISR

        /* Pickup thread pointer.  */
        TX_THREAD_GET_CURRENT(thread_ptr)
 8015dd0:	4b14      	ldr	r3, [pc, #80]	; (8015e24 <_txe_byte_release+0x6c>)
 8015dd2:	681b      	ldr	r3, [r3, #0]
 8015dd4:	613b      	str	r3, [r7, #16]

        /* Check for invalid caller of this function.  First check for a calling thread.  */
        if (thread_ptr == &_tx_timer_thread)
 8015dd6:	693b      	ldr	r3, [r7, #16]
 8015dd8:	4a13      	ldr	r2, [pc, #76]	; (8015e28 <_txe_byte_release+0x70>)
 8015dda:	4293      	cmp	r3, r2
 8015ddc:	d101      	bne.n	8015de2 <_txe_byte_release+0x2a>
        {

            /* Invalid caller of this function, return appropriate error code.  */
            status =  TX_CALLER_ERROR;
 8015dde:	2313      	movs	r3, #19
 8015de0:	617b      	str	r3, [r7, #20]
    __asm__ volatile (" MRS  %0,IPSR ": "=r" (ipsr_value) );
 8015de2:	f3ef 8305 	mrs	r3, IPSR
 8015de6:	60fb      	str	r3, [r7, #12]
    return(ipsr_value);
 8015de8:	68fa      	ldr	r2, [r7, #12]
        }
#endif

        /* Check for interrupt call.  */
        if (TX_THREAD_GET_SYSTEM_STATE() != ((ULONG) 0))
 8015dea:	4b10      	ldr	r3, [pc, #64]	; (8015e2c <_txe_byte_release+0x74>)
 8015dec:	681b      	ldr	r3, [r3, #0]
 8015dee:	4313      	orrs	r3, r2
 8015df0:	2b00      	cmp	r3, #0
 8015df2:	d00b      	beq.n	8015e0c <_txe_byte_release+0x54>
    __asm__ volatile (" MRS  %0,IPSR ": "=r" (ipsr_value) );
 8015df4:	f3ef 8305 	mrs	r3, IPSR
 8015df8:	60bb      	str	r3, [r7, #8]
    return(ipsr_value);
 8015dfa:	68ba      	ldr	r2, [r7, #8]
        {
    
            /* Now, make sure the call is from an interrupt and not initialization.  */
            if (TX_THREAD_GET_SYSTEM_STATE() < TX_INITIALIZE_IN_PROGRESS)
 8015dfc:	4b0b      	ldr	r3, [pc, #44]	; (8015e2c <_txe_byte_release+0x74>)
 8015dfe:	681b      	ldr	r3, [r3, #0]
 8015e00:	4313      	orrs	r3, r2
 8015e02:	f1b3 3ff0 	cmp.w	r3, #4042322160	; 0xf0f0f0f0
 8015e06:	d201      	bcs.n	8015e0c <_txe_byte_release+0x54>
            {
        
                /* Invalid caller of this function, return appropriate error code.  */
                status =  TX_CALLER_ERROR;
 8015e08:	2313      	movs	r3, #19
 8015e0a:	617b      	str	r3, [r7, #20]
            }
        }
    }

    /* Determine if everything is okay.  */
    if (status == TX_SUCCESS)
 8015e0c:	697b      	ldr	r3, [r7, #20]
 8015e0e:	2b00      	cmp	r3, #0
 8015e10:	d103      	bne.n	8015e1a <_txe_byte_release+0x62>
    {

        /* Call actual byte release function.  */
        status =  _tx_byte_release(memory_ptr);
 8015e12:	6878      	ldr	r0, [r7, #4]
 8015e14:	f7fc f890 	bl	8011f38 <_tx_byte_release>
 8015e18:	6178      	str	r0, [r7, #20]
    }

    /* Return completion status.  */
    return(status);
 8015e1a:	697b      	ldr	r3, [r7, #20]
}
 8015e1c:	4618      	mov	r0, r3
 8015e1e:	3718      	adds	r7, #24
 8015e20:	46bd      	mov	sp, r7
 8015e22:	bd80      	pop	{r7, pc}
 8015e24:	24031bc4 	.word	0x24031bc4
 8015e28:	24031d0c 	.word	0x24031d0c
 8015e2c:	24000078 	.word	0x24000078

08015e30 <_txe_event_flags_create>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
UINT  _txe_event_flags_create(TX_EVENT_FLAGS_GROUP *group_ptr, CHAR *name_ptr, UINT event_control_block_size)
{
 8015e30:	b580      	push	{r7, lr}
 8015e32:	b092      	sub	sp, #72	; 0x48
 8015e34:	af00      	add	r7, sp, #0
 8015e36:	60f8      	str	r0, [r7, #12]
 8015e38:	60b9      	str	r1, [r7, #8]
 8015e3a:	607a      	str	r2, [r7, #4]
TX_THREAD                   *thread_ptr;
#endif


    /* Default status to success.  */
    status =  TX_SUCCESS;
 8015e3c:	2300      	movs	r3, #0
 8015e3e:	647b      	str	r3, [r7, #68]	; 0x44

    /* Check for an invalid event flags group pointer.  */
    if (group_ptr == TX_NULL)
 8015e40:	68fb      	ldr	r3, [r7, #12]
 8015e42:	2b00      	cmp	r3, #0
 8015e44:	d102      	bne.n	8015e4c <_txe_event_flags_create+0x1c>
    {

        /* Event flags group pointer is invalid, return appropriate error code.  */
        status =  TX_GROUP_ERROR;
 8015e46:	2306      	movs	r3, #6
 8015e48:	647b      	str	r3, [r7, #68]	; 0x44
 8015e4a:	e069      	b.n	8015f20 <_txe_event_flags_create+0xf0>
    }

    /* Now check for proper control block size.  */
    else if (event_control_block_size != (sizeof(TX_EVENT_FLAGS_GROUP)))
 8015e4c:	687b      	ldr	r3, [r7, #4]
 8015e4e:	2b24      	cmp	r3, #36	; 0x24
 8015e50:	d002      	beq.n	8015e58 <_txe_event_flags_create+0x28>
    {

        /* Event flags group pointer is invalid, return appropriate error code.  */
        status =  TX_GROUP_ERROR;
 8015e52:	2306      	movs	r3, #6
 8015e54:	647b      	str	r3, [r7, #68]	; 0x44
 8015e56:	e063      	b.n	8015f20 <_txe_event_flags_create+0xf0>
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 8015e58:	f3ef 8310 	mrs	r3, PRIMASK
 8015e5c:	62fb      	str	r3, [r7, #44]	; 0x2c
    return(posture);
 8015e5e:	6afb      	ldr	r3, [r7, #44]	; 0x2c
    int_posture = __get_interrupt_posture();
 8015e60:	62bb      	str	r3, [r7, #40]	; 0x28
    __asm__ volatile ("CPSID i" : : : "memory");
 8015e62:	b672      	cpsid	i
    return(int_posture);
 8015e64:	6abb      	ldr	r3, [r7, #40]	; 0x28
    }
    else
    {

        /* Disable interrupts.  */
        TX_DISABLE
 8015e66:	63bb      	str	r3, [r7, #56]	; 0x38

        /* Increment the preempt disable flag.  */
        _tx_thread_preempt_disable++;
 8015e68:	4b34      	ldr	r3, [pc, #208]	; (8015f3c <_txe_event_flags_create+0x10c>)
 8015e6a:	681b      	ldr	r3, [r3, #0]
 8015e6c:	3301      	adds	r3, #1
 8015e6e:	4a33      	ldr	r2, [pc, #204]	; (8015f3c <_txe_event_flags_create+0x10c>)
 8015e70:	6013      	str	r3, [r2, #0]
 8015e72:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8015e74:	633b      	str	r3, [r7, #48]	; 0x30
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 8015e76:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8015e78:	f383 8810 	msr	PRIMASK, r3
}
 8015e7c:	bf00      	nop

        /* Restore interrupts.  */
        TX_RESTORE

        /* Next see if it is already in the created list.  */
        next_group =   _tx_event_flags_created_ptr;
 8015e7e:	4b30      	ldr	r3, [pc, #192]	; (8015f40 <_txe_event_flags_create+0x110>)
 8015e80:	681b      	ldr	r3, [r3, #0]
 8015e82:	63fb      	str	r3, [r7, #60]	; 0x3c
        for (i = ((ULONG) 0); i < _tx_event_flags_created_count; i++)
 8015e84:	2300      	movs	r3, #0
 8015e86:	643b      	str	r3, [r7, #64]	; 0x40
 8015e88:	e009      	b.n	8015e9e <_txe_event_flags_create+0x6e>
        {

            /* Determine if this group matches the event flags group in the list.  */
            if (group_ptr == next_group)
 8015e8a:	68fa      	ldr	r2, [r7, #12]
 8015e8c:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8015e8e:	429a      	cmp	r2, r3
 8015e90:	d00b      	beq.n	8015eaa <_txe_event_flags_create+0x7a>
            }
            else
            {
        
                /* Move to the next group.  */
                next_group =  next_group -> tx_event_flags_group_created_next;
 8015e92:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8015e94:	699b      	ldr	r3, [r3, #24]
 8015e96:	63fb      	str	r3, [r7, #60]	; 0x3c
        for (i = ((ULONG) 0); i < _tx_event_flags_created_count; i++)
 8015e98:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8015e9a:	3301      	adds	r3, #1
 8015e9c:	643b      	str	r3, [r7, #64]	; 0x40
 8015e9e:	4b29      	ldr	r3, [pc, #164]	; (8015f44 <_txe_event_flags_create+0x114>)
 8015ea0:	681b      	ldr	r3, [r3, #0]
 8015ea2:	6c3a      	ldr	r2, [r7, #64]	; 0x40
 8015ea4:	429a      	cmp	r2, r3
 8015ea6:	d3f0      	bcc.n	8015e8a <_txe_event_flags_create+0x5a>
 8015ea8:	e000      	b.n	8015eac <_txe_event_flags_create+0x7c>
                break;
 8015eaa:	bf00      	nop
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 8015eac:	f3ef 8310 	mrs	r3, PRIMASK
 8015eb0:	623b      	str	r3, [r7, #32]
    return(posture);
 8015eb2:	6a3b      	ldr	r3, [r7, #32]
    int_posture = __get_interrupt_posture();
 8015eb4:	61fb      	str	r3, [r7, #28]
    __asm__ volatile ("CPSID i" : : : "memory");
 8015eb6:	b672      	cpsid	i
    return(int_posture);
 8015eb8:	69fb      	ldr	r3, [r7, #28]
            }
        }

        /* Disable interrupts.  */
        TX_DISABLE
 8015eba:	63bb      	str	r3, [r7, #56]	; 0x38

        /* Decrement the preempt disable flag.  */
        _tx_thread_preempt_disable--;
 8015ebc:	4b1f      	ldr	r3, [pc, #124]	; (8015f3c <_txe_event_flags_create+0x10c>)
 8015ebe:	681b      	ldr	r3, [r3, #0]
 8015ec0:	3b01      	subs	r3, #1
 8015ec2:	4a1e      	ldr	r2, [pc, #120]	; (8015f3c <_txe_event_flags_create+0x10c>)
 8015ec4:	6013      	str	r3, [r2, #0]
 8015ec6:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8015ec8:	627b      	str	r3, [r7, #36]	; 0x24
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 8015eca:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8015ecc:	f383 8810 	msr	PRIMASK, r3
}
 8015ed0:	bf00      	nop
    
        /* Restore interrupts.  */
        TX_RESTORE

        /* Check for preemption.  */
        _tx_thread_system_preempt_check();
 8015ed2:	f7fe feef 	bl	8014cb4 <_tx_thread_system_preempt_check>

        /* At this point, check to see if there is a duplicate event flag group.  */
        if (group_ptr == next_group)
 8015ed6:	68fa      	ldr	r2, [r7, #12]
 8015ed8:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8015eda:	429a      	cmp	r2, r3
 8015edc:	d102      	bne.n	8015ee4 <_txe_event_flags_create+0xb4>
        {

            /* Group is already created, return appropriate error code.  */
            status =  TX_GROUP_ERROR;
 8015ede:	2306      	movs	r3, #6
 8015ee0:	647b      	str	r3, [r7, #68]	; 0x44
 8015ee2:	e01d      	b.n	8015f20 <_txe_event_flags_create+0xf0>
        {

#ifndef TX_TIMER_PROCESS_IN_ISR

            /* Pickup thread pointer.  */
            TX_THREAD_GET_CURRENT(thread_ptr)
 8015ee4:	4b18      	ldr	r3, [pc, #96]	; (8015f48 <_txe_event_flags_create+0x118>)
 8015ee6:	681b      	ldr	r3, [r3, #0]
 8015ee8:	637b      	str	r3, [r7, #52]	; 0x34

            /* Check for invalid caller of this function.  First check for a calling thread.  */
            if (thread_ptr == &_tx_timer_thread)
 8015eea:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8015eec:	4a17      	ldr	r2, [pc, #92]	; (8015f4c <_txe_event_flags_create+0x11c>)
 8015eee:	4293      	cmp	r3, r2
 8015ef0:	d101      	bne.n	8015ef6 <_txe_event_flags_create+0xc6>
            {

                /* Invalid caller of this function, return appropriate error code.  */
                status =  TX_CALLER_ERROR;
 8015ef2:	2313      	movs	r3, #19
 8015ef4:	647b      	str	r3, [r7, #68]	; 0x44
    __asm__ volatile (" MRS  %0,IPSR ": "=r" (ipsr_value) );
 8015ef6:	f3ef 8305 	mrs	r3, IPSR
 8015efa:	61bb      	str	r3, [r7, #24]
    return(ipsr_value);
 8015efc:	69ba      	ldr	r2, [r7, #24]
            }
#endif

            /* Check for interrupt call.  */
            if (TX_THREAD_GET_SYSTEM_STATE() != ((ULONG) 0))
 8015efe:	4b14      	ldr	r3, [pc, #80]	; (8015f50 <_txe_event_flags_create+0x120>)
 8015f00:	681b      	ldr	r3, [r3, #0]
 8015f02:	4313      	orrs	r3, r2
 8015f04:	2b00      	cmp	r3, #0
 8015f06:	d00b      	beq.n	8015f20 <_txe_event_flags_create+0xf0>
    __asm__ volatile (" MRS  %0,IPSR ": "=r" (ipsr_value) );
 8015f08:	f3ef 8305 	mrs	r3, IPSR
 8015f0c:	617b      	str	r3, [r7, #20]
    return(ipsr_value);
 8015f0e:	697a      	ldr	r2, [r7, #20]
            {
    
                /* Now, make sure the call is from an interrupt and not initialization.  */
                if (TX_THREAD_GET_SYSTEM_STATE() < TX_INITIALIZE_IN_PROGRESS)
 8015f10:	4b0f      	ldr	r3, [pc, #60]	; (8015f50 <_txe_event_flags_create+0x120>)
 8015f12:	681b      	ldr	r3, [r3, #0]
 8015f14:	4313      	orrs	r3, r2
 8015f16:	f1b3 3ff0 	cmp.w	r3, #4042322160	; 0xf0f0f0f0
 8015f1a:	d201      	bcs.n	8015f20 <_txe_event_flags_create+0xf0>
                {
        
                    /* Invalid caller of this function, return appropriate error code.  */
                    status =  TX_CALLER_ERROR;
 8015f1c:	2313      	movs	r3, #19
 8015f1e:	647b      	str	r3, [r7, #68]	; 0x44
            }
        }
    }

    /* Determine if everything is okay.  */
    if (status == TX_SUCCESS)
 8015f20:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8015f22:	2b00      	cmp	r3, #0
 8015f24:	d104      	bne.n	8015f30 <_txe_event_flags_create+0x100>
    {

        /* Call actual event flags create function.  */
        status =  _tx_event_flags_create(group_ptr, name_ptr);
 8015f26:	68b9      	ldr	r1, [r7, #8]
 8015f28:	68f8      	ldr	r0, [r7, #12]
 8015f2a:	f7fc f9af 	bl	801228c <_tx_event_flags_create>
 8015f2e:	6478      	str	r0, [r7, #68]	; 0x44
    }

    /* Return completion status.  */
    return(status);
 8015f30:	6c7b      	ldr	r3, [r7, #68]	; 0x44
}
 8015f32:	4618      	mov	r0, r3
 8015f34:	3748      	adds	r7, #72	; 0x48
 8015f36:	46bd      	mov	sp, r7
 8015f38:	bd80      	pop	{r7, pc}
 8015f3a:	bf00      	nop
 8015f3c:	24031c5c 	.word	0x24031c5c
 8015f40:	24031b9c 	.word	0x24031b9c
 8015f44:	24031ba0 	.word	0x24031ba0
 8015f48:	24031bc4 	.word	0x24031bc4
 8015f4c:	24031d0c 	.word	0x24031d0c
 8015f50:	24000078 	.word	0x24000078

08015f54 <_txe_event_flags_get>:
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
UINT  _txe_event_flags_get(TX_EVENT_FLAGS_GROUP *group_ptr, ULONG requested_flags,
                    UINT get_option, ULONG *actual_flags_ptr, ULONG wait_option)
{
 8015f54:	b580      	push	{r7, lr}
 8015f56:	b08a      	sub	sp, #40	; 0x28
 8015f58:	af02      	add	r7, sp, #8
 8015f5a:	60f8      	str	r0, [r7, #12]
 8015f5c:	60b9      	str	r1, [r7, #8]
 8015f5e:	607a      	str	r2, [r7, #4]
 8015f60:	603b      	str	r3, [r7, #0]
TX_THREAD       *current_thread;
#endif


    /* Default status to success.  */
    status =  TX_SUCCESS;
 8015f62:	2300      	movs	r3, #0
 8015f64:	61fb      	str	r3, [r7, #28]

    /* Check for an invalid event flag group pointer.  */
    if (group_ptr == TX_NULL)
 8015f66:	68fb      	ldr	r3, [r7, #12]
 8015f68:	2b00      	cmp	r3, #0
 8015f6a:	d102      	bne.n	8015f72 <_txe_event_flags_get+0x1e>
    {

        /* Event flags group pointer is invalid, return appropriate error code.  */
        status =  TX_GROUP_ERROR;
 8015f6c:	2306      	movs	r3, #6
 8015f6e:	61fb      	str	r3, [r7, #28]
 8015f70:	e025      	b.n	8015fbe <_txe_event_flags_get+0x6a>
    }
    
    /* Now check for invalid event group ID.  */
    else if (group_ptr -> tx_event_flags_group_id != TX_EVENT_FLAGS_ID)
 8015f72:	68fb      	ldr	r3, [r7, #12]
 8015f74:	681b      	ldr	r3, [r3, #0]
 8015f76:	4a1e      	ldr	r2, [pc, #120]	; (8015ff0 <_txe_event_flags_get+0x9c>)
 8015f78:	4293      	cmp	r3, r2
 8015f7a:	d002      	beq.n	8015f82 <_txe_event_flags_get+0x2e>
    {

        /* Event flags group pointer is invalid, return appropriate error code.  */
        status =  TX_GROUP_ERROR;
 8015f7c:	2306      	movs	r3, #6
 8015f7e:	61fb      	str	r3, [r7, #28]
 8015f80:	e01d      	b.n	8015fbe <_txe_event_flags_get+0x6a>
    }

    /* Check for an invalid destination for actual flags.  */
    else if (actual_flags_ptr == TX_NULL)
 8015f82:	683b      	ldr	r3, [r7, #0]
 8015f84:	2b00      	cmp	r3, #0
 8015f86:	d102      	bne.n	8015f8e <_txe_event_flags_get+0x3a>
    {

        /* Null destination pointer, return appropriate error.  */
        status =  TX_PTR_ERROR;
 8015f88:	2303      	movs	r3, #3
 8015f8a:	61fb      	str	r3, [r7, #28]
 8015f8c:	e017      	b.n	8015fbe <_txe_event_flags_get+0x6a>
    else
    {

        /* Check for a wait option error.  Only threads are allowed any form of 
           suspension.  */
        if (wait_option != TX_NO_WAIT)
 8015f8e:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8015f90:	2b00      	cmp	r3, #0
 8015f92:	d014      	beq.n	8015fbe <_txe_event_flags_get+0x6a>
    __asm__ volatile (" MRS  %0,IPSR ": "=r" (ipsr_value) );
 8015f94:	f3ef 8305 	mrs	r3, IPSR
 8015f98:	617b      	str	r3, [r7, #20]
    return(ipsr_value);
 8015f9a:	697a      	ldr	r2, [r7, #20]
        {

            /* Is the call from an ISR or Initialization?  */
            if (TX_THREAD_GET_SYSTEM_STATE() != ((ULONG) 0))
 8015f9c:	4b15      	ldr	r3, [pc, #84]	; (8015ff4 <_txe_event_flags_get+0xa0>)
 8015f9e:	681b      	ldr	r3, [r3, #0]
 8015fa0:	4313      	orrs	r3, r2
 8015fa2:	2b00      	cmp	r3, #0
 8015fa4:	d002      	beq.n	8015fac <_txe_event_flags_get+0x58>
            {

                /* A non-thread is trying to suspend, return appropriate error code.  */
                status =  TX_WAIT_ERROR;
 8015fa6:	2304      	movs	r3, #4
 8015fa8:	61fb      	str	r3, [r7, #28]
 8015faa:	e008      	b.n	8015fbe <_txe_event_flags_get+0x6a>
#ifndef TX_TIMER_PROCESS_IN_ISR
            else
            {
            
                /* Pickup thread pointer.  */
                TX_THREAD_GET_CURRENT(current_thread)
 8015fac:	4b12      	ldr	r3, [pc, #72]	; (8015ff8 <_txe_event_flags_get+0xa4>)
 8015fae:	681b      	ldr	r3, [r3, #0]
 8015fb0:	61bb      	str	r3, [r7, #24]

                /* Is the current thread the timer thread?  */
                if (current_thread == &_tx_timer_thread)
 8015fb2:	69bb      	ldr	r3, [r7, #24]
 8015fb4:	4a11      	ldr	r2, [pc, #68]	; (8015ffc <_txe_event_flags_get+0xa8>)
 8015fb6:	4293      	cmp	r3, r2
 8015fb8:	d101      	bne.n	8015fbe <_txe_event_flags_get+0x6a>
                {

                    /* A non-thread is trying to suspend, return appropriate error code.  */
                    status =  TX_WAIT_ERROR;
 8015fba:	2304      	movs	r3, #4
 8015fbc:	61fb      	str	r3, [r7, #28]
#endif
        }
    }

    /* Is everything still okay?  */
    if (status == TX_SUCCESS)
 8015fbe:	69fb      	ldr	r3, [r7, #28]
 8015fc0:	2b00      	cmp	r3, #0
 8015fc2:	d104      	bne.n	8015fce <_txe_event_flags_get+0x7a>
    {
    
        /* Check for invalid get option.  */
        if (get_option > TX_AND_CLEAR)
 8015fc4:	687b      	ldr	r3, [r7, #4]
 8015fc6:	2b03      	cmp	r3, #3
 8015fc8:	d901      	bls.n	8015fce <_txe_event_flags_get+0x7a>
        {

            /* Invalid get events option, return appropriate error.  */
            status =  TX_OPTION_ERROR;
 8015fca:	2308      	movs	r3, #8
 8015fcc:	61fb      	str	r3, [r7, #28]
        }
    }

    /* Determine if everything is okay.  */
    if (status == TX_SUCCESS)
 8015fce:	69fb      	ldr	r3, [r7, #28]
 8015fd0:	2b00      	cmp	r3, #0
 8015fd2:	d108      	bne.n	8015fe6 <_txe_event_flags_get+0x92>
    {

        /* Call actual event flags get function.  */
        status =  _tx_event_flags_get(group_ptr, requested_flags, get_option, actual_flags_ptr, wait_option);
 8015fd4:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8015fd6:	9300      	str	r3, [sp, #0]
 8015fd8:	683b      	ldr	r3, [r7, #0]
 8015fda:	687a      	ldr	r2, [r7, #4]
 8015fdc:	68b9      	ldr	r1, [r7, #8]
 8015fde:	68f8      	ldr	r0, [r7, #12]
 8015fe0:	f7fc f9a2 	bl	8012328 <_tx_event_flags_get>
 8015fe4:	61f8      	str	r0, [r7, #28]
    }

    /* Return completion status.  */
    return(status);
 8015fe6:	69fb      	ldr	r3, [r7, #28]
}
 8015fe8:	4618      	mov	r0, r3
 8015fea:	3720      	adds	r7, #32
 8015fec:	46bd      	mov	sp, r7
 8015fee:	bd80      	pop	{r7, pc}
 8015ff0:	4456444e 	.word	0x4456444e
 8015ff4:	24000078 	.word	0x24000078
 8015ff8:	24031bc4 	.word	0x24031bc4
 8015ffc:	24031d0c 	.word	0x24031d0c

08016000 <_txe_event_flags_set>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
UINT  _txe_event_flags_set(TX_EVENT_FLAGS_GROUP *group_ptr, ULONG flags_to_set, UINT set_option)
{
 8016000:	b580      	push	{r7, lr}
 8016002:	b086      	sub	sp, #24
 8016004:	af00      	add	r7, sp, #0
 8016006:	60f8      	str	r0, [r7, #12]
 8016008:	60b9      	str	r1, [r7, #8]
 801600a:	607a      	str	r2, [r7, #4]

UINT        status;


    /* Default status to success.  */
    status =  TX_SUCCESS;
 801600c:	2300      	movs	r3, #0
 801600e:	617b      	str	r3, [r7, #20]

    /* Check for an invalid event flag group pointer.  */
    if (group_ptr == TX_NULL)
 8016010:	68fb      	ldr	r3, [r7, #12]
 8016012:	2b00      	cmp	r3, #0
 8016014:	d102      	bne.n	801601c <_txe_event_flags_set+0x1c>
    {

        /* Event flags group pointer is invalid, return appropriate error code.  */
        status =  TX_GROUP_ERROR;
 8016016:	2306      	movs	r3, #6
 8016018:	617b      	str	r3, [r7, #20]
 801601a:	e00f      	b.n	801603c <_txe_event_flags_set+0x3c>
    }
    
    /* Now check for invalid event flag group ID.  */
    else if (group_ptr -> tx_event_flags_group_id != TX_EVENT_FLAGS_ID)
 801601c:	68fb      	ldr	r3, [r7, #12]
 801601e:	681b      	ldr	r3, [r3, #0]
 8016020:	4a0d      	ldr	r2, [pc, #52]	; (8016058 <_txe_event_flags_set+0x58>)
 8016022:	4293      	cmp	r3, r2
 8016024:	d002      	beq.n	801602c <_txe_event_flags_set+0x2c>
    {

        /* Event flags group pointer is invalid, return appropriate error code.  */
        status =  TX_GROUP_ERROR;
 8016026:	2306      	movs	r3, #6
 8016028:	617b      	str	r3, [r7, #20]
 801602a:	e007      	b.n	801603c <_txe_event_flags_set+0x3c>
    }
    else
    {

        /* Check for invalid set option.  */
        if (set_option != TX_AND)
 801602c:	687b      	ldr	r3, [r7, #4]
 801602e:	2b02      	cmp	r3, #2
 8016030:	d004      	beq.n	801603c <_txe_event_flags_set+0x3c>
        {

            if (set_option != TX_OR)
 8016032:	687b      	ldr	r3, [r7, #4]
 8016034:	2b00      	cmp	r3, #0
 8016036:	d001      	beq.n	801603c <_txe_event_flags_set+0x3c>
            {
        
                /* Invalid set events option, return appropriate error.  */
                status =  TX_OPTION_ERROR;
 8016038:	2308      	movs	r3, #8
 801603a:	617b      	str	r3, [r7, #20]
            }
        }
    }

    /* Determine if everything is okay.  */
    if (status == TX_SUCCESS)
 801603c:	697b      	ldr	r3, [r7, #20]
 801603e:	2b00      	cmp	r3, #0
 8016040:	d105      	bne.n	801604e <_txe_event_flags_set+0x4e>
    {

        /* Call actual event flags set function.  */
        status =  _tx_event_flags_set(group_ptr, flags_to_set, set_option);
 8016042:	687a      	ldr	r2, [r7, #4]
 8016044:	68b9      	ldr	r1, [r7, #8]
 8016046:	68f8      	ldr	r0, [r7, #12]
 8016048:	f7fc fa50 	bl	80124ec <_tx_event_flags_set>
 801604c:	6178      	str	r0, [r7, #20]
    }

    /* Return completion status.  */
    return(status);
 801604e:	697b      	ldr	r3, [r7, #20]
}
 8016050:	4618      	mov	r0, r3
 8016052:	3718      	adds	r7, #24
 8016054:	46bd      	mov	sp, r7
 8016056:	bd80      	pop	{r7, pc}
 8016058:	4456444e 	.word	0x4456444e

0801605c <_txe_mutex_create>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
UINT  _txe_mutex_create(TX_MUTEX *mutex_ptr, CHAR *name_ptr, UINT inherit, UINT mutex_control_block_size)
{
 801605c:	b580      	push	{r7, lr}
 801605e:	b092      	sub	sp, #72	; 0x48
 8016060:	af00      	add	r7, sp, #0
 8016062:	60f8      	str	r0, [r7, #12]
 8016064:	60b9      	str	r1, [r7, #8]
 8016066:	607a      	str	r2, [r7, #4]
 8016068:	603b      	str	r3, [r7, #0]
TX_THREAD       *thread_ptr;
#endif


    /* Default status to success.  */
    status =  TX_SUCCESS;
 801606a:	2300      	movs	r3, #0
 801606c:	647b      	str	r3, [r7, #68]	; 0x44

    /* Check for an invalid mutex pointer.  */
    if (mutex_ptr == TX_NULL)
 801606e:	68fb      	ldr	r3, [r7, #12]
 8016070:	2b00      	cmp	r3, #0
 8016072:	d102      	bne.n	801607a <_txe_mutex_create+0x1e>
    {

        /* Mutex pointer is invalid, return appropriate error code.  */
        status =  TX_MUTEX_ERROR;
 8016074:	231c      	movs	r3, #28
 8016076:	647b      	str	r3, [r7, #68]	; 0x44
 8016078:	e053      	b.n	8016122 <_txe_mutex_create+0xc6>
    }
    
    /* Now check to make sure the control block is the correct size.  */
    else if (mutex_control_block_size != (sizeof(TX_MUTEX)))
 801607a:	683b      	ldr	r3, [r7, #0]
 801607c:	2b34      	cmp	r3, #52	; 0x34
 801607e:	d002      	beq.n	8016086 <_txe_mutex_create+0x2a>
    {

        /* Mutex pointer is invalid, return appropriate error code.  */
        status =  TX_MUTEX_ERROR;
 8016080:	231c      	movs	r3, #28
 8016082:	647b      	str	r3, [r7, #68]	; 0x44
 8016084:	e04d      	b.n	8016122 <_txe_mutex_create+0xc6>
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 8016086:	f3ef 8310 	mrs	r3, PRIMASK
 801608a:	62fb      	str	r3, [r7, #44]	; 0x2c
    return(posture);
 801608c:	6afb      	ldr	r3, [r7, #44]	; 0x2c
    int_posture = __get_interrupt_posture();
 801608e:	62bb      	str	r3, [r7, #40]	; 0x28
    __asm__ volatile ("CPSID i" : : : "memory");
 8016090:	b672      	cpsid	i
    return(int_posture);
 8016092:	6abb      	ldr	r3, [r7, #40]	; 0x28
    }
    else
    {

        /* Disable interrupts.  */
        TX_DISABLE
 8016094:	63bb      	str	r3, [r7, #56]	; 0x38

        /* Increment the preempt disable flag.  */
        _tx_thread_preempt_disable++;
 8016096:	4b3a      	ldr	r3, [pc, #232]	; (8016180 <_txe_mutex_create+0x124>)
 8016098:	681b      	ldr	r3, [r3, #0]
 801609a:	3301      	adds	r3, #1
 801609c:	4a38      	ldr	r2, [pc, #224]	; (8016180 <_txe_mutex_create+0x124>)
 801609e:	6013      	str	r3, [r2, #0]
 80160a0:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 80160a2:	633b      	str	r3, [r7, #48]	; 0x30
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 80160a4:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 80160a6:	f383 8810 	msr	PRIMASK, r3
}
 80160aa:	bf00      	nop

        /* Restore interrupts.  */
        TX_RESTORE

        /* Next see if it is already in the created list.  */
        next_mutex =   _tx_mutex_created_ptr;
 80160ac:	4b35      	ldr	r3, [pc, #212]	; (8016184 <_txe_mutex_create+0x128>)
 80160ae:	681b      	ldr	r3, [r3, #0]
 80160b0:	63fb      	str	r3, [r7, #60]	; 0x3c
        for (i = ((ULONG) 0); i < _tx_mutex_created_count; i++)
 80160b2:	2300      	movs	r3, #0
 80160b4:	643b      	str	r3, [r7, #64]	; 0x40
 80160b6:	e009      	b.n	80160cc <_txe_mutex_create+0x70>
        {

            /* Determine if this mutex matches the mutex in the list.  */
            if (mutex_ptr == next_mutex)
 80160b8:	68fa      	ldr	r2, [r7, #12]
 80160ba:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 80160bc:	429a      	cmp	r2, r3
 80160be:	d00b      	beq.n	80160d8 <_txe_mutex_create+0x7c>
            }
            else
            {

                /* Move to the next mutex.  */
                next_mutex =  next_mutex -> tx_mutex_created_next;
 80160c0:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 80160c2:	6a1b      	ldr	r3, [r3, #32]
 80160c4:	63fb      	str	r3, [r7, #60]	; 0x3c
        for (i = ((ULONG) 0); i < _tx_mutex_created_count; i++)
 80160c6:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 80160c8:	3301      	adds	r3, #1
 80160ca:	643b      	str	r3, [r7, #64]	; 0x40
 80160cc:	4b2e      	ldr	r3, [pc, #184]	; (8016188 <_txe_mutex_create+0x12c>)
 80160ce:	681b      	ldr	r3, [r3, #0]
 80160d0:	6c3a      	ldr	r2, [r7, #64]	; 0x40
 80160d2:	429a      	cmp	r2, r3
 80160d4:	d3f0      	bcc.n	80160b8 <_txe_mutex_create+0x5c>
 80160d6:	e000      	b.n	80160da <_txe_mutex_create+0x7e>
                break;
 80160d8:	bf00      	nop
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 80160da:	f3ef 8310 	mrs	r3, PRIMASK
 80160de:	623b      	str	r3, [r7, #32]
    return(posture);
 80160e0:	6a3b      	ldr	r3, [r7, #32]
    int_posture = __get_interrupt_posture();
 80160e2:	61fb      	str	r3, [r7, #28]
    __asm__ volatile ("CPSID i" : : : "memory");
 80160e4:	b672      	cpsid	i
    return(int_posture);
 80160e6:	69fb      	ldr	r3, [r7, #28]
            }
        }

        /* Disable interrupts.  */
        TX_DISABLE
 80160e8:	63bb      	str	r3, [r7, #56]	; 0x38

        /* Decrement the preempt disable flag.  */
        _tx_thread_preempt_disable--;
 80160ea:	4b25      	ldr	r3, [pc, #148]	; (8016180 <_txe_mutex_create+0x124>)
 80160ec:	681b      	ldr	r3, [r3, #0]
 80160ee:	3b01      	subs	r3, #1
 80160f0:	4a23      	ldr	r2, [pc, #140]	; (8016180 <_txe_mutex_create+0x124>)
 80160f2:	6013      	str	r3, [r2, #0]
 80160f4:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 80160f6:	627b      	str	r3, [r7, #36]	; 0x24
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 80160f8:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80160fa:	f383 8810 	msr	PRIMASK, r3
}
 80160fe:	bf00      	nop
    
        /* Restore interrupts.  */
        TX_RESTORE

        /* Check for preemption.  */
        _tx_thread_system_preempt_check();
 8016100:	f7fe fdd8 	bl	8014cb4 <_tx_thread_system_preempt_check>

        /* At this point, check to see if there is a duplicate mutex.  */
        if (mutex_ptr == next_mutex)
 8016104:	68fa      	ldr	r2, [r7, #12]
 8016106:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8016108:	429a      	cmp	r2, r3
 801610a:	d102      	bne.n	8016112 <_txe_mutex_create+0xb6>
        {

            /* Mutex is already created, return appropriate error code.  */
            status =  TX_MUTEX_ERROR;
 801610c:	231c      	movs	r3, #28
 801610e:	647b      	str	r3, [r7, #68]	; 0x44
 8016110:	e007      	b.n	8016122 <_txe_mutex_create+0xc6>
        }
        else
        {
        
            /* Check for a valid inherit option.  */
            if (inherit != TX_INHERIT)
 8016112:	687b      	ldr	r3, [r7, #4]
 8016114:	2b01      	cmp	r3, #1
 8016116:	d004      	beq.n	8016122 <_txe_mutex_create+0xc6>
            {

                if (inherit != TX_NO_INHERIT)
 8016118:	687b      	ldr	r3, [r7, #4]
 801611a:	2b00      	cmp	r3, #0
 801611c:	d001      	beq.n	8016122 <_txe_mutex_create+0xc6>
                {
        
                    /* Inherit option is illegal.  */
                    status =  TX_INHERIT_ERROR;
 801611e:	231f      	movs	r3, #31
 8016120:	647b      	str	r3, [r7, #68]	; 0x44
            }
        }
    }

    /* Determine if everything is okay.  */
    if (status == TX_SUCCESS)
 8016122:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8016124:	2b00      	cmp	r3, #0
 8016126:	d11d      	bne.n	8016164 <_txe_mutex_create+0x108>
    {

#ifndef TX_TIMER_PROCESS_IN_ISR

        /* Pickup thread pointer.  */
        TX_THREAD_GET_CURRENT(thread_ptr)
 8016128:	4b18      	ldr	r3, [pc, #96]	; (801618c <_txe_mutex_create+0x130>)
 801612a:	681b      	ldr	r3, [r3, #0]
 801612c:	637b      	str	r3, [r7, #52]	; 0x34

        /* Check for invalid caller of this function.  First check for a calling thread.  */
        if (thread_ptr == &_tx_timer_thread)
 801612e:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8016130:	4a17      	ldr	r2, [pc, #92]	; (8016190 <_txe_mutex_create+0x134>)
 8016132:	4293      	cmp	r3, r2
 8016134:	d101      	bne.n	801613a <_txe_mutex_create+0xde>
        {

            /* Invalid caller of this function, return appropriate error code.  */
            status =  TX_CALLER_ERROR;
 8016136:	2313      	movs	r3, #19
 8016138:	647b      	str	r3, [r7, #68]	; 0x44
    __asm__ volatile (" MRS  %0,IPSR ": "=r" (ipsr_value) );
 801613a:	f3ef 8305 	mrs	r3, IPSR
 801613e:	61bb      	str	r3, [r7, #24]
    return(ipsr_value);
 8016140:	69ba      	ldr	r2, [r7, #24]
        }
#endif

        /* Check for interrupt call.  */
        if (TX_THREAD_GET_SYSTEM_STATE() != ((ULONG) 0))
 8016142:	4b14      	ldr	r3, [pc, #80]	; (8016194 <_txe_mutex_create+0x138>)
 8016144:	681b      	ldr	r3, [r3, #0]
 8016146:	4313      	orrs	r3, r2
 8016148:	2b00      	cmp	r3, #0
 801614a:	d00b      	beq.n	8016164 <_txe_mutex_create+0x108>
    __asm__ volatile (" MRS  %0,IPSR ": "=r" (ipsr_value) );
 801614c:	f3ef 8305 	mrs	r3, IPSR
 8016150:	617b      	str	r3, [r7, #20]
    return(ipsr_value);
 8016152:	697a      	ldr	r2, [r7, #20]
        {
    
            /* Now, make sure the call is from an interrupt and not initialization.  */
            if (TX_THREAD_GET_SYSTEM_STATE() < TX_INITIALIZE_IN_PROGRESS)
 8016154:	4b0f      	ldr	r3, [pc, #60]	; (8016194 <_txe_mutex_create+0x138>)
 8016156:	681b      	ldr	r3, [r3, #0]
 8016158:	4313      	orrs	r3, r2
 801615a:	f1b3 3ff0 	cmp.w	r3, #4042322160	; 0xf0f0f0f0
 801615e:	d201      	bcs.n	8016164 <_txe_mutex_create+0x108>
            {
        
                /* Invalid caller of this function, return appropriate error code.  */
                status =  TX_CALLER_ERROR;
 8016160:	2313      	movs	r3, #19
 8016162:	647b      	str	r3, [r7, #68]	; 0x44
            }
        }
    }

    /* Determine if everything is okay.  */
    if (status == TX_SUCCESS)
 8016164:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8016166:	2b00      	cmp	r3, #0
 8016168:	d105      	bne.n	8016176 <_txe_mutex_create+0x11a>
    {

        /* Call actual mutex create function.  */
        status =  _tx_mutex_create(mutex_ptr, name_ptr, inherit);
 801616a:	687a      	ldr	r2, [r7, #4]
 801616c:	68b9      	ldr	r1, [r7, #8]
 801616e:	68f8      	ldr	r0, [r7, #12]
 8016170:	f7fc fcfc 	bl	8012b6c <_tx_mutex_create>
 8016174:	6478      	str	r0, [r7, #68]	; 0x44
    }

    /* Return completion status.  */
    return(status);
 8016176:	6c7b      	ldr	r3, [r7, #68]	; 0x44
}
 8016178:	4618      	mov	r0, r3
 801617a:	3748      	adds	r7, #72	; 0x48
 801617c:	46bd      	mov	sp, r7
 801617e:	bd80      	pop	{r7, pc}
 8016180:	24031c5c 	.word	0x24031c5c
 8016184:	24031ba4 	.word	0x24031ba4
 8016188:	24031ba8 	.word	0x24031ba8
 801618c:	24031bc4 	.word	0x24031bc4
 8016190:	24031d0c 	.word	0x24031d0c
 8016194:	24000078 	.word	0x24000078

08016198 <_txe_mutex_delete>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
UINT  _txe_mutex_delete(TX_MUTEX *mutex_ptr)
{
 8016198:	b580      	push	{r7, lr}
 801619a:	b086      	sub	sp, #24
 801619c:	af00      	add	r7, sp, #0
 801619e:	6078      	str	r0, [r7, #4]


#ifndef TX_TIMER_PROCESS_IN_ISR

    /* Default status to success.  */
    status =  TX_SUCCESS;
 80161a0:	2300      	movs	r3, #0
 80161a2:	617b      	str	r3, [r7, #20]
#endif
    
    /* Check for an invalid mutex pointer.  */
    if (mutex_ptr == TX_NULL)
 80161a4:	687b      	ldr	r3, [r7, #4]
 80161a6:	2b00      	cmp	r3, #0
 80161a8:	d102      	bne.n	80161b0 <_txe_mutex_delete+0x18>
    {

        /* Mutex pointer is invalid, return appropriate error code.  */
        status =  TX_MUTEX_ERROR;
 80161aa:	231c      	movs	r3, #28
 80161ac:	617b      	str	r3, [r7, #20]
 80161ae:	e023      	b.n	80161f8 <_txe_mutex_delete+0x60>
    }
    
    /* Now check for a valid mutex ID.  */
    else if (mutex_ptr -> tx_mutex_id != TX_MUTEX_ID)
 80161b0:	687b      	ldr	r3, [r7, #4]
 80161b2:	681b      	ldr	r3, [r3, #0]
 80161b4:	4a13      	ldr	r2, [pc, #76]	; (8016204 <_txe_mutex_delete+0x6c>)
 80161b6:	4293      	cmp	r3, r2
 80161b8:	d002      	beq.n	80161c0 <_txe_mutex_delete+0x28>
    {

        /* Mutex pointer is invalid, return appropriate error code.  */
        status =  TX_MUTEX_ERROR;
 80161ba:	231c      	movs	r3, #28
 80161bc:	617b      	str	r3, [r7, #20]
 80161be:	e01b      	b.n	80161f8 <_txe_mutex_delete+0x60>
    __asm__ volatile (" MRS  %0,IPSR ": "=r" (ipsr_value) );
 80161c0:	f3ef 8305 	mrs	r3, IPSR
 80161c4:	60fb      	str	r3, [r7, #12]
    return(ipsr_value);
 80161c6:	68fa      	ldr	r2, [r7, #12]
    }

    /* Check for invalid caller of this function.  */

    /* Is the caller an ISR or Initialization?  */
    else if (TX_THREAD_GET_SYSTEM_STATE() != ((ULONG) 0))
 80161c8:	4b0f      	ldr	r3, [pc, #60]	; (8016208 <_txe_mutex_delete+0x70>)
 80161ca:	681b      	ldr	r3, [r3, #0]
 80161cc:	4313      	orrs	r3, r2
 80161ce:	2b00      	cmp	r3, #0
 80161d0:	d002      	beq.n	80161d8 <_txe_mutex_delete+0x40>
    {

        /* Invalid caller of this function, return appropriate error code.  */
        status =  TX_CALLER_ERROR;
 80161d2:	2313      	movs	r3, #19
 80161d4:	617b      	str	r3, [r7, #20]
 80161d6:	e00f      	b.n	80161f8 <_txe_mutex_delete+0x60>
    {

#ifndef TX_TIMER_PROCESS_IN_ISR

        /* Pickup thread pointer.  */
        TX_THREAD_GET_CURRENT(thread_ptr)
 80161d8:	4b0c      	ldr	r3, [pc, #48]	; (801620c <_txe_mutex_delete+0x74>)
 80161da:	681b      	ldr	r3, [r3, #0]
 80161dc:	613b      	str	r3, [r7, #16]

        /* Is the caller the system timer thread?  */
        if (thread_ptr == &_tx_timer_thread)
 80161de:	693b      	ldr	r3, [r7, #16]
 80161e0:	4a0b      	ldr	r2, [pc, #44]	; (8016210 <_txe_mutex_delete+0x78>)
 80161e2:	4293      	cmp	r3, r2
 80161e4:	d101      	bne.n	80161ea <_txe_mutex_delete+0x52>
        {

            /* Invalid caller of this function, return appropriate error code.  */
            status =  TX_CALLER_ERROR;
 80161e6:	2313      	movs	r3, #19
 80161e8:	617b      	str	r3, [r7, #20]
        }

        /* Determine if everything is okay.  */
        if (status == TX_SUCCESS)
 80161ea:	697b      	ldr	r3, [r7, #20]
 80161ec:	2b00      	cmp	r3, #0
 80161ee:	d103      	bne.n	80161f8 <_txe_mutex_delete+0x60>
        {
#endif

            /* Call actual mutex delete function.  */
            status =  _tx_mutex_delete(mutex_ptr);
 80161f0:	6878      	ldr	r0, [r7, #4]
 80161f2:	f7fc fd15 	bl	8012c20 <_tx_mutex_delete>
 80161f6:	6178      	str	r0, [r7, #20]
        }
#endif
    }

    /* Return completion status.  */
    return(status);
 80161f8:	697b      	ldr	r3, [r7, #20]
}
 80161fa:	4618      	mov	r0, r3
 80161fc:	3718      	adds	r7, #24
 80161fe:	46bd      	mov	sp, r7
 8016200:	bd80      	pop	{r7, pc}
 8016202:	bf00      	nop
 8016204:	4d555445 	.word	0x4d555445
 8016208:	24000078 	.word	0x24000078
 801620c:	24031bc4 	.word	0x24031bc4
 8016210:	24031d0c 	.word	0x24031d0c

08016214 <_txe_mutex_get>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
UINT  _txe_mutex_get(TX_MUTEX *mutex_ptr, ULONG wait_option)
{
 8016214:	b580      	push	{r7, lr}
 8016216:	b088      	sub	sp, #32
 8016218:	af00      	add	r7, sp, #0
 801621a:	6078      	str	r0, [r7, #4]
 801621c:	6039      	str	r1, [r7, #0]
TX_THREAD       *current_thread;
#endif


    /* Default status to success.  */
    status =  TX_SUCCESS;
 801621e:	2300      	movs	r3, #0
 8016220:	61fb      	str	r3, [r7, #28]

    /* Check for an invalid mutex pointer.  */
    if (mutex_ptr == TX_NULL)
 8016222:	687b      	ldr	r3, [r7, #4]
 8016224:	2b00      	cmp	r3, #0
 8016226:	d102      	bne.n	801622e <_txe_mutex_get+0x1a>
    {

        /* Mutex pointer is invalid, return appropriate error code.  */
        status =  TX_MUTEX_ERROR;
 8016228:	231c      	movs	r3, #28
 801622a:	61fb      	str	r3, [r7, #28]
 801622c:	e01f      	b.n	801626e <_txe_mutex_get+0x5a>
    }
    
    /* Now check for a valid mutex ID.  */
    else if (mutex_ptr -> tx_mutex_id != TX_MUTEX_ID)
 801622e:	687b      	ldr	r3, [r7, #4]
 8016230:	681b      	ldr	r3, [r3, #0]
 8016232:	4a21      	ldr	r2, [pc, #132]	; (80162b8 <_txe_mutex_get+0xa4>)
 8016234:	4293      	cmp	r3, r2
 8016236:	d002      	beq.n	801623e <_txe_mutex_get+0x2a>
    {

        /* Mutex pointer is invalid, return appropriate error code.  */
        status =  TX_MUTEX_ERROR;
 8016238:	231c      	movs	r3, #28
 801623a:	61fb      	str	r3, [r7, #28]
 801623c:	e017      	b.n	801626e <_txe_mutex_get+0x5a>
    else
    {

        /* Check for a wait option error.  Only threads are allowed any form of 
           suspension.  */
        if (wait_option != TX_NO_WAIT)
 801623e:	683b      	ldr	r3, [r7, #0]
 8016240:	2b00      	cmp	r3, #0
 8016242:	d014      	beq.n	801626e <_txe_mutex_get+0x5a>
    __asm__ volatile (" MRS  %0,IPSR ": "=r" (ipsr_value) );
 8016244:	f3ef 8305 	mrs	r3, IPSR
 8016248:	617b      	str	r3, [r7, #20]
    return(ipsr_value);
 801624a:	697a      	ldr	r2, [r7, #20]
        {

            /* Is the call from an ISR or Initialization?  */
            if (TX_THREAD_GET_SYSTEM_STATE() != ((ULONG) 0))
 801624c:	4b1b      	ldr	r3, [pc, #108]	; (80162bc <_txe_mutex_get+0xa8>)
 801624e:	681b      	ldr	r3, [r3, #0]
 8016250:	4313      	orrs	r3, r2
 8016252:	2b00      	cmp	r3, #0
 8016254:	d002      	beq.n	801625c <_txe_mutex_get+0x48>
            {

                /* A non-thread is trying to suspend, return appropriate error code.  */
                status =  TX_WAIT_ERROR;
 8016256:	2304      	movs	r3, #4
 8016258:	61fb      	str	r3, [r7, #28]
 801625a:	e008      	b.n	801626e <_txe_mutex_get+0x5a>
#ifndef TX_TIMER_PROCESS_IN_ISR
            else
            {

                /* Pickup thread pointer.  */
                TX_THREAD_GET_CURRENT(current_thread)
 801625c:	4b18      	ldr	r3, [pc, #96]	; (80162c0 <_txe_mutex_get+0xac>)
 801625e:	681b      	ldr	r3, [r3, #0]
 8016260:	61bb      	str	r3, [r7, #24]

                /* Is the current thread the timer thread?  */
                if (current_thread == &_tx_timer_thread)
 8016262:	69bb      	ldr	r3, [r7, #24]
 8016264:	4a17      	ldr	r2, [pc, #92]	; (80162c4 <_txe_mutex_get+0xb0>)
 8016266:	4293      	cmp	r3, r2
 8016268:	d101      	bne.n	801626e <_txe_mutex_get+0x5a>
                {

                    /* A non-thread is trying to suspend, return appropriate error code.  */
                    status =  TX_WAIT_ERROR;
 801626a:	2304      	movs	r3, #4
 801626c:	61fb      	str	r3, [r7, #28]
#endif
        }
    }

    /* Determine if everything is okay.  */
    if (status == TX_SUCCESS)
 801626e:	69fb      	ldr	r3, [r7, #28]
 8016270:	2b00      	cmp	r3, #0
 8016272:	d114      	bne.n	801629e <_txe_mutex_get+0x8a>
    __asm__ volatile (" MRS  %0,IPSR ": "=r" (ipsr_value) );
 8016274:	f3ef 8305 	mrs	r3, IPSR
 8016278:	613b      	str	r3, [r7, #16]
    return(ipsr_value);
 801627a:	693a      	ldr	r2, [r7, #16]
    {

        /* Check for interrupt call.  */
        if (TX_THREAD_GET_SYSTEM_STATE() != ((ULONG) 0))
 801627c:	4b0f      	ldr	r3, [pc, #60]	; (80162bc <_txe_mutex_get+0xa8>)
 801627e:	681b      	ldr	r3, [r3, #0]
 8016280:	4313      	orrs	r3, r2
 8016282:	2b00      	cmp	r3, #0
 8016284:	d00b      	beq.n	801629e <_txe_mutex_get+0x8a>
    __asm__ volatile (" MRS  %0,IPSR ": "=r" (ipsr_value) );
 8016286:	f3ef 8305 	mrs	r3, IPSR
 801628a:	60fb      	str	r3, [r7, #12]
    return(ipsr_value);
 801628c:	68fa      	ldr	r2, [r7, #12]
        {
    
            /* Now, make sure the call is from an interrupt and not initialization.  */
            if (TX_THREAD_GET_SYSTEM_STATE() < TX_INITIALIZE_IN_PROGRESS)
 801628e:	4b0b      	ldr	r3, [pc, #44]	; (80162bc <_txe_mutex_get+0xa8>)
 8016290:	681b      	ldr	r3, [r3, #0]
 8016292:	4313      	orrs	r3, r2
 8016294:	f1b3 3ff0 	cmp.w	r3, #4042322160	; 0xf0f0f0f0
 8016298:	d201      	bcs.n	801629e <_txe_mutex_get+0x8a>
            {
        
                /* Yes, invalid caller of this function, return appropriate error code.  */
                status =  TX_CALLER_ERROR;
 801629a:	2313      	movs	r3, #19
 801629c:	61fb      	str	r3, [r7, #28]
            }
        }
    }

    /* Determine if everything is okay.  */
    if (status == TX_SUCCESS)
 801629e:	69fb      	ldr	r3, [r7, #28]
 80162a0:	2b00      	cmp	r3, #0
 80162a2:	d104      	bne.n	80162ae <_txe_mutex_get+0x9a>
    {

        /* Call actual get mutex function.  */
        status =  _tx_mutex_get(mutex_ptr, wait_option);
 80162a4:	6839      	ldr	r1, [r7, #0]
 80162a6:	6878      	ldr	r0, [r7, #4]
 80162a8:	f7fc fd64 	bl	8012d74 <_tx_mutex_get>
 80162ac:	61f8      	str	r0, [r7, #28]
    }

    /* Return completion status.  */
    return(status);
 80162ae:	69fb      	ldr	r3, [r7, #28]
}
 80162b0:	4618      	mov	r0, r3
 80162b2:	3720      	adds	r7, #32
 80162b4:	46bd      	mov	sp, r7
 80162b6:	bd80      	pop	{r7, pc}
 80162b8:	4d555445 	.word	0x4d555445
 80162bc:	24000078 	.word	0x24000078
 80162c0:	24031bc4 	.word	0x24031bc4
 80162c4:	24031d0c 	.word	0x24031d0c

080162c8 <_txe_mutex_put>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
UINT  _txe_mutex_put(TX_MUTEX *mutex_ptr)
{
 80162c8:	b580      	push	{r7, lr}
 80162ca:	b086      	sub	sp, #24
 80162cc:	af00      	add	r7, sp, #0
 80162ce:	6078      	str	r0, [r7, #4]

UINT            status;


    /* Default status to success.  */
    status =  TX_SUCCESS;
 80162d0:	2300      	movs	r3, #0
 80162d2:	617b      	str	r3, [r7, #20]

    /* Check for an invalid mutex pointer.  */
    if (mutex_ptr == TX_NULL)
 80162d4:	687b      	ldr	r3, [r7, #4]
 80162d6:	2b00      	cmp	r3, #0
 80162d8:	d102      	bne.n	80162e0 <_txe_mutex_put+0x18>
    {

        /* Mutex pointer is invalid, return appropriate error code.  */
        status =  TX_MUTEX_ERROR;
 80162da:	231c      	movs	r3, #28
 80162dc:	617b      	str	r3, [r7, #20]
 80162de:	e01c      	b.n	801631a <_txe_mutex_put+0x52>
    }
    
    /* Now check for invalid mutex ID.  */
    else if (mutex_ptr -> tx_mutex_id != TX_MUTEX_ID)
 80162e0:	687b      	ldr	r3, [r7, #4]
 80162e2:	681b      	ldr	r3, [r3, #0]
 80162e4:	4a13      	ldr	r2, [pc, #76]	; (8016334 <_txe_mutex_put+0x6c>)
 80162e6:	4293      	cmp	r3, r2
 80162e8:	d002      	beq.n	80162f0 <_txe_mutex_put+0x28>
    {

        /* Mutex pointer is invalid, return appropriate error code.  */
        status =  TX_MUTEX_ERROR;
 80162ea:	231c      	movs	r3, #28
 80162ec:	617b      	str	r3, [r7, #20]
 80162ee:	e014      	b.n	801631a <_txe_mutex_put+0x52>
    __asm__ volatile (" MRS  %0,IPSR ": "=r" (ipsr_value) );
 80162f0:	f3ef 8305 	mrs	r3, IPSR
 80162f4:	613b      	str	r3, [r7, #16]
    return(ipsr_value);
 80162f6:	693a      	ldr	r2, [r7, #16]
    }
    else
    {

        /* Check for interrupt call.  */
        if (TX_THREAD_GET_SYSTEM_STATE() != ((ULONG) 0))
 80162f8:	4b0f      	ldr	r3, [pc, #60]	; (8016338 <_txe_mutex_put+0x70>)
 80162fa:	681b      	ldr	r3, [r3, #0]
 80162fc:	4313      	orrs	r3, r2
 80162fe:	2b00      	cmp	r3, #0
 8016300:	d00b      	beq.n	801631a <_txe_mutex_put+0x52>
    __asm__ volatile (" MRS  %0,IPSR ": "=r" (ipsr_value) );
 8016302:	f3ef 8305 	mrs	r3, IPSR
 8016306:	60fb      	str	r3, [r7, #12]
    return(ipsr_value);
 8016308:	68fa      	ldr	r2, [r7, #12]
        {
    
            /* Now, make sure the call is from an interrupt and not initialization.  */
            if (TX_THREAD_GET_SYSTEM_STATE() < TX_INITIALIZE_IN_PROGRESS)
 801630a:	4b0b      	ldr	r3, [pc, #44]	; (8016338 <_txe_mutex_put+0x70>)
 801630c:	681b      	ldr	r3, [r3, #0]
 801630e:	4313      	orrs	r3, r2
 8016310:	f1b3 3ff0 	cmp.w	r3, #4042322160	; 0xf0f0f0f0
 8016314:	d201      	bcs.n	801631a <_txe_mutex_put+0x52>
            {
        
                /* Invalid caller of this function, return appropriate error code.  */
                status =  TX_CALLER_ERROR;
 8016316:	2313      	movs	r3, #19
 8016318:	617b      	str	r3, [r7, #20]
            }
        }
    }

    /* Determine if everything is okay.  */
    if (status == TX_SUCCESS)
 801631a:	697b      	ldr	r3, [r7, #20]
 801631c:	2b00      	cmp	r3, #0
 801631e:	d103      	bne.n	8016328 <_txe_mutex_put+0x60>
    {

        /* Call actual put mutex function.  */
        status =  _tx_mutex_put(mutex_ptr);
 8016320:	6878      	ldr	r0, [r7, #4]
 8016322:	f7fc ff9f 	bl	8013264 <_tx_mutex_put>
 8016326:	6178      	str	r0, [r7, #20]
    }

    /* Return completion status.  */
    return(status);
 8016328:	697b      	ldr	r3, [r7, #20]
}
 801632a:	4618      	mov	r0, r3
 801632c:	3718      	adds	r7, #24
 801632e:	46bd      	mov	sp, r7
 8016330:	bd80      	pop	{r7, pc}
 8016332:	bf00      	nop
 8016334:	4d555445 	.word	0x4d555445
 8016338:	24000078 	.word	0x24000078

0801633c <_txe_queue_create>:
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
UINT  _txe_queue_create(TX_QUEUE *queue_ptr, CHAR *name_ptr, UINT message_size, 
                        VOID *queue_start, ULONG queue_size, UINT queue_control_block_size)
{
 801633c:	b580      	push	{r7, lr}
 801633e:	b094      	sub	sp, #80	; 0x50
 8016340:	af02      	add	r7, sp, #8
 8016342:	60f8      	str	r0, [r7, #12]
 8016344:	60b9      	str	r1, [r7, #8]
 8016346:	607a      	str	r2, [r7, #4]
 8016348:	603b      	str	r3, [r7, #0]
TX_THREAD       *thread_ptr;
#endif


    /* Default status to success.  */
    status =  TX_SUCCESS;
 801634a:	2300      	movs	r3, #0
 801634c:	647b      	str	r3, [r7, #68]	; 0x44

    /* Check for an invalid queue pointer.  */
    if (queue_ptr == TX_NULL)
 801634e:	68fb      	ldr	r3, [r7, #12]
 8016350:	2b00      	cmp	r3, #0
 8016352:	d102      	bne.n	801635a <_txe_queue_create+0x1e>
    {

        /* Queue pointer is invalid, return appropriate error code.  */
        status =  TX_QUEUE_ERROR;
 8016354:	2309      	movs	r3, #9
 8016356:	647b      	str	r3, [r7, #68]	; 0x44
 8016358:	e083      	b.n	8016462 <_txe_queue_create+0x126>
    }
    
    /* Now check for a valid control block size.  */
    else if (queue_control_block_size != (sizeof(TX_QUEUE)))
 801635a:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 801635c:	2b38      	cmp	r3, #56	; 0x38
 801635e:	d002      	beq.n	8016366 <_txe_queue_create+0x2a>
    {

        /* Queue pointer is invalid, return appropriate error code.  */
        status =  TX_QUEUE_ERROR;
 8016360:	2309      	movs	r3, #9
 8016362:	647b      	str	r3, [r7, #68]	; 0x44
 8016364:	e07d      	b.n	8016462 <_txe_queue_create+0x126>
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 8016366:	f3ef 8310 	mrs	r3, PRIMASK
 801636a:	62fb      	str	r3, [r7, #44]	; 0x2c
    return(posture);
 801636c:	6afb      	ldr	r3, [r7, #44]	; 0x2c
    int_posture = __get_interrupt_posture();
 801636e:	62bb      	str	r3, [r7, #40]	; 0x28
    __asm__ volatile ("CPSID i" : : : "memory");
 8016370:	b672      	cpsid	i
    return(int_posture);
 8016372:	6abb      	ldr	r3, [r7, #40]	; 0x28
    }
    else
    {

        /* Disable interrupts.  */
        TX_DISABLE
 8016374:	63bb      	str	r3, [r7, #56]	; 0x38

        /* Increment the preempt disable flag.  */
        _tx_thread_preempt_disable++;
 8016376:	4b43      	ldr	r3, [pc, #268]	; (8016484 <_txe_queue_create+0x148>)
 8016378:	681b      	ldr	r3, [r3, #0]
 801637a:	3301      	adds	r3, #1
 801637c:	4a41      	ldr	r2, [pc, #260]	; (8016484 <_txe_queue_create+0x148>)
 801637e:	6013      	str	r3, [r2, #0]
 8016380:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8016382:	633b      	str	r3, [r7, #48]	; 0x30
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 8016384:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8016386:	f383 8810 	msr	PRIMASK, r3
}
 801638a:	bf00      	nop

        /* Restore interrupts.  */
        TX_RESTORE

        /* Next see if it is already in the created list.  */
        next_queue =   _tx_queue_created_ptr;
 801638c:	4b3e      	ldr	r3, [pc, #248]	; (8016488 <_txe_queue_create+0x14c>)
 801638e:	681b      	ldr	r3, [r3, #0]
 8016390:	63fb      	str	r3, [r7, #60]	; 0x3c
        for (i = ((ULONG) 0); i < _tx_queue_created_count; i++)
 8016392:	2300      	movs	r3, #0
 8016394:	643b      	str	r3, [r7, #64]	; 0x40
 8016396:	e009      	b.n	80163ac <_txe_queue_create+0x70>
        {

            /* Determine if this queue matches the queue in the list.  */
            if (queue_ptr == next_queue)
 8016398:	68fa      	ldr	r2, [r7, #12]
 801639a:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 801639c:	429a      	cmp	r2, r3
 801639e:	d00b      	beq.n	80163b8 <_txe_queue_create+0x7c>
            }
            else
            {
        
                /* Move to the next queue.  */
                next_queue =  next_queue -> tx_queue_created_next;
 80163a0:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 80163a2:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 80163a4:	63fb      	str	r3, [r7, #60]	; 0x3c
        for (i = ((ULONG) 0); i < _tx_queue_created_count; i++)
 80163a6:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 80163a8:	3301      	adds	r3, #1
 80163aa:	643b      	str	r3, [r7, #64]	; 0x40
 80163ac:	4b37      	ldr	r3, [pc, #220]	; (801648c <_txe_queue_create+0x150>)
 80163ae:	681b      	ldr	r3, [r3, #0]
 80163b0:	6c3a      	ldr	r2, [r7, #64]	; 0x40
 80163b2:	429a      	cmp	r2, r3
 80163b4:	d3f0      	bcc.n	8016398 <_txe_queue_create+0x5c>
 80163b6:	e000      	b.n	80163ba <_txe_queue_create+0x7e>
                break;
 80163b8:	bf00      	nop
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 80163ba:	f3ef 8310 	mrs	r3, PRIMASK
 80163be:	623b      	str	r3, [r7, #32]
    return(posture);
 80163c0:	6a3b      	ldr	r3, [r7, #32]
    int_posture = __get_interrupt_posture();
 80163c2:	61fb      	str	r3, [r7, #28]
    __asm__ volatile ("CPSID i" : : : "memory");
 80163c4:	b672      	cpsid	i
    return(int_posture);
 80163c6:	69fb      	ldr	r3, [r7, #28]
            }
        }

        /* Disable interrupts.  */
        TX_DISABLE
 80163c8:	63bb      	str	r3, [r7, #56]	; 0x38

        /* Decrement the preempt disable flag.  */
        _tx_thread_preempt_disable--;
 80163ca:	4b2e      	ldr	r3, [pc, #184]	; (8016484 <_txe_queue_create+0x148>)
 80163cc:	681b      	ldr	r3, [r3, #0]
 80163ce:	3b01      	subs	r3, #1
 80163d0:	4a2c      	ldr	r2, [pc, #176]	; (8016484 <_txe_queue_create+0x148>)
 80163d2:	6013      	str	r3, [r2, #0]
 80163d4:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 80163d6:	627b      	str	r3, [r7, #36]	; 0x24
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 80163d8:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80163da:	f383 8810 	msr	PRIMASK, r3
}
 80163de:	bf00      	nop
    
        /* Restore interrupts.  */
        TX_RESTORE

        /* Check for preemption.  */
        _tx_thread_system_preempt_check();
 80163e0:	f7fe fc68 	bl	8014cb4 <_tx_thread_system_preempt_check>

        /* At this point, check to see if there is a duplicate queue.  */
        if (queue_ptr == next_queue)
 80163e4:	68fa      	ldr	r2, [r7, #12]
 80163e6:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 80163e8:	429a      	cmp	r2, r3
 80163ea:	d102      	bne.n	80163f2 <_txe_queue_create+0xb6>
        {

            /* Queue is already created, return appropriate error code.  */
            status =  TX_QUEUE_ERROR;
 80163ec:	2309      	movs	r3, #9
 80163ee:	647b      	str	r3, [r7, #68]	; 0x44
 80163f0:	e037      	b.n	8016462 <_txe_queue_create+0x126>
        }

        /* Check the starting address of the queue.  */
        else if (queue_start == TX_NULL)
 80163f2:	683b      	ldr	r3, [r7, #0]
 80163f4:	2b00      	cmp	r3, #0
 80163f6:	d102      	bne.n	80163fe <_txe_queue_create+0xc2>
        {

            /* Invalid starting address of queue.  */
            status =  TX_PTR_ERROR;
 80163f8:	2303      	movs	r3, #3
 80163fa:	647b      	str	r3, [r7, #68]	; 0x44
 80163fc:	e031      	b.n	8016462 <_txe_queue_create+0x126>
        }

        /* Check for an invalid message size - less than 1.  */
        else if (message_size < TX_1_ULONG)
 80163fe:	687b      	ldr	r3, [r7, #4]
 8016400:	2b00      	cmp	r3, #0
 8016402:	d102      	bne.n	801640a <_txe_queue_create+0xce>
        {

            /* Invalid message size specified.  */
            status =  TX_SIZE_ERROR;
 8016404:	2305      	movs	r3, #5
 8016406:	647b      	str	r3, [r7, #68]	; 0x44
 8016408:	e02b      	b.n	8016462 <_txe_queue_create+0x126>
        }
    
        /* Check for an invalid message size - greater than 16.  */
        else if (message_size > TX_16_ULONG)
 801640a:	687b      	ldr	r3, [r7, #4]
 801640c:	2b10      	cmp	r3, #16
 801640e:	d902      	bls.n	8016416 <_txe_queue_create+0xda>
        {

            /* Invalid message size specified.  */
            status =  TX_SIZE_ERROR;
 8016410:	2305      	movs	r3, #5
 8016412:	647b      	str	r3, [r7, #68]	; 0x44
 8016414:	e025      	b.n	8016462 <_txe_queue_create+0x126>
        }

        /* Check on the queue size.  */
        else if ((queue_size/(sizeof(ULONG))) < message_size)
 8016416:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 8016418:	089b      	lsrs	r3, r3, #2
 801641a:	687a      	ldr	r2, [r7, #4]
 801641c:	429a      	cmp	r2, r3
 801641e:	d902      	bls.n	8016426 <_txe_queue_create+0xea>
        {

            /* Invalid queue size specified.  */
            status =  TX_SIZE_ERROR;
 8016420:	2305      	movs	r3, #5
 8016422:	647b      	str	r3, [r7, #68]	; 0x44
 8016424:	e01d      	b.n	8016462 <_txe_queue_create+0x126>
        {

#ifndef TX_TIMER_PROCESS_IN_ISR

            /* Pickup thread pointer.  */
            TX_THREAD_GET_CURRENT(thread_ptr)
 8016426:	4b1a      	ldr	r3, [pc, #104]	; (8016490 <_txe_queue_create+0x154>)
 8016428:	681b      	ldr	r3, [r3, #0]
 801642a:	637b      	str	r3, [r7, #52]	; 0x34

            /* Check for invalid caller of this function.  First check for a calling thread.  */
            if (thread_ptr == &_tx_timer_thread)
 801642c:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 801642e:	4a19      	ldr	r2, [pc, #100]	; (8016494 <_txe_queue_create+0x158>)
 8016430:	4293      	cmp	r3, r2
 8016432:	d101      	bne.n	8016438 <_txe_queue_create+0xfc>
            {

                /* Invalid caller of this function, return appropriate error code.  */
                status =  TX_CALLER_ERROR;
 8016434:	2313      	movs	r3, #19
 8016436:	647b      	str	r3, [r7, #68]	; 0x44
    __asm__ volatile (" MRS  %0,IPSR ": "=r" (ipsr_value) );
 8016438:	f3ef 8305 	mrs	r3, IPSR
 801643c:	61bb      	str	r3, [r7, #24]
    return(ipsr_value);
 801643e:	69ba      	ldr	r2, [r7, #24]
            }
#endif

            /* Check for interrupt call.  */
            if (TX_THREAD_GET_SYSTEM_STATE() != ((ULONG) 0))
 8016440:	4b15      	ldr	r3, [pc, #84]	; (8016498 <_txe_queue_create+0x15c>)
 8016442:	681b      	ldr	r3, [r3, #0]
 8016444:	4313      	orrs	r3, r2
 8016446:	2b00      	cmp	r3, #0
 8016448:	d00b      	beq.n	8016462 <_txe_queue_create+0x126>
    __asm__ volatile (" MRS  %0,IPSR ": "=r" (ipsr_value) );
 801644a:	f3ef 8305 	mrs	r3, IPSR
 801644e:	617b      	str	r3, [r7, #20]
    return(ipsr_value);
 8016450:	697a      	ldr	r2, [r7, #20]
            {
    
                /* Now, make sure the call is from an interrupt and not initialization.  */
                if (TX_THREAD_GET_SYSTEM_STATE() < TX_INITIALIZE_IN_PROGRESS)
 8016452:	4b11      	ldr	r3, [pc, #68]	; (8016498 <_txe_queue_create+0x15c>)
 8016454:	681b      	ldr	r3, [r3, #0]
 8016456:	4313      	orrs	r3, r2
 8016458:	f1b3 3ff0 	cmp.w	r3, #4042322160	; 0xf0f0f0f0
 801645c:	d201      	bcs.n	8016462 <_txe_queue_create+0x126>
                {
        
                    /* Invalid caller of this function, return appropriate error code.  */
                    status =  TX_CALLER_ERROR;
 801645e:	2313      	movs	r3, #19
 8016460:	647b      	str	r3, [r7, #68]	; 0x44
            }
        }
    }

    /* Determine if everything is okay.  */
    if (status == TX_SUCCESS)
 8016462:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8016464:	2b00      	cmp	r3, #0
 8016466:	d108      	bne.n	801647a <_txe_queue_create+0x13e>
    {

        /* Call actual queue create function.  */
        status =  _tx_queue_create(queue_ptr, name_ptr, message_size, queue_start, queue_size);
 8016468:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 801646a:	9300      	str	r3, [sp, #0]
 801646c:	683b      	ldr	r3, [r7, #0]
 801646e:	687a      	ldr	r2, [r7, #4]
 8016470:	68b9      	ldr	r1, [r7, #8]
 8016472:	68f8      	ldr	r0, [r7, #12]
 8016474:	f7fd f9a0 	bl	80137b8 <_tx_queue_create>
 8016478:	6478      	str	r0, [r7, #68]	; 0x44
    }

    /* Return completion status.  */
    return(status);
 801647a:	6c7b      	ldr	r3, [r7, #68]	; 0x44
}
 801647c:	4618      	mov	r0, r3
 801647e:	3748      	adds	r7, #72	; 0x48
 8016480:	46bd      	mov	sp, r7
 8016482:	bd80      	pop	{r7, pc}
 8016484:	24031c5c 	.word	0x24031c5c
 8016488:	24031b94 	.word	0x24031b94
 801648c:	24031b98 	.word	0x24031b98
 8016490:	24031bc4 	.word	0x24031bc4
 8016494:	24031d0c 	.word	0x24031d0c
 8016498:	24000078 	.word	0x24000078

0801649c <_txe_queue_delete>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
UINT  _txe_queue_delete(TX_QUEUE *queue_ptr)
{
 801649c:	b580      	push	{r7, lr}
 801649e:	b086      	sub	sp, #24
 80164a0:	af00      	add	r7, sp, #0
 80164a2:	6078      	str	r0, [r7, #4]
TX_THREAD       *thread_ptr;
#endif


    /* Default status to success.  */
    status =  TX_SUCCESS;
 80164a4:	2300      	movs	r3, #0
 80164a6:	617b      	str	r3, [r7, #20]

    /* Check for an invalid queue pointer.  */
    if (queue_ptr == TX_NULL)
 80164a8:	687b      	ldr	r3, [r7, #4]
 80164aa:	2b00      	cmp	r3, #0
 80164ac:	d102      	bne.n	80164b4 <_txe_queue_delete+0x18>
    {

        /* Queue pointer is invalid, return appropriate error code.  */
        status =  TX_QUEUE_ERROR;
 80164ae:	2309      	movs	r3, #9
 80164b0:	617b      	str	r3, [r7, #20]
 80164b2:	e01c      	b.n	80164ee <_txe_queue_delete+0x52>
    }

    /* Now check for a valid queue ID.  */
    else if (queue_ptr -> tx_queue_id != TX_QUEUE_ID)
 80164b4:	687b      	ldr	r3, [r7, #4]
 80164b6:	681b      	ldr	r3, [r3, #0]
 80164b8:	4a13      	ldr	r2, [pc, #76]	; (8016508 <_txe_queue_delete+0x6c>)
 80164ba:	4293      	cmp	r3, r2
 80164bc:	d002      	beq.n	80164c4 <_txe_queue_delete+0x28>
    {

        /* Queue pointer is invalid, return appropriate error code.  */
        status =  TX_QUEUE_ERROR;
 80164be:	2309      	movs	r3, #9
 80164c0:	617b      	str	r3, [r7, #20]
 80164c2:	e014      	b.n	80164ee <_txe_queue_delete+0x52>
    __asm__ volatile (" MRS  %0,IPSR ": "=r" (ipsr_value) );
 80164c4:	f3ef 8305 	mrs	r3, IPSR
 80164c8:	60fb      	str	r3, [r7, #12]
    return(ipsr_value);
 80164ca:	68fa      	ldr	r2, [r7, #12]
    {
    
        /* Check for invalid caller of this function.  */

        /* Is the caller an ISR or Initialization?  */
        if (TX_THREAD_GET_SYSTEM_STATE() != ((ULONG) 0))
 80164cc:	4b0f      	ldr	r3, [pc, #60]	; (801650c <_txe_queue_delete+0x70>)
 80164ce:	681b      	ldr	r3, [r3, #0]
 80164d0:	4313      	orrs	r3, r2
 80164d2:	2b00      	cmp	r3, #0
 80164d4:	d002      	beq.n	80164dc <_txe_queue_delete+0x40>
        {

            /* Invalid caller of this function, return appropriate error code.  */
            status =  TX_CALLER_ERROR;
 80164d6:	2313      	movs	r3, #19
 80164d8:	617b      	str	r3, [r7, #20]
 80164da:	e008      	b.n	80164ee <_txe_queue_delete+0x52>
#ifndef TX_TIMER_PROCESS_IN_ISR
        else
        {
        
            /* Pickup thread pointer.  */
            TX_THREAD_GET_CURRENT(thread_ptr)
 80164dc:	4b0c      	ldr	r3, [pc, #48]	; (8016510 <_txe_queue_delete+0x74>)
 80164de:	681b      	ldr	r3, [r3, #0]
 80164e0:	613b      	str	r3, [r7, #16]

            /* Is the caller the system timer thread?  */
            if (thread_ptr == &_tx_timer_thread)
 80164e2:	693b      	ldr	r3, [r7, #16]
 80164e4:	4a0b      	ldr	r2, [pc, #44]	; (8016514 <_txe_queue_delete+0x78>)
 80164e6:	4293      	cmp	r3, r2
 80164e8:	d101      	bne.n	80164ee <_txe_queue_delete+0x52>
            {

                /* Invalid caller of this function, return appropriate error code.  */
                status =  TX_CALLER_ERROR;
 80164ea:	2313      	movs	r3, #19
 80164ec:	617b      	str	r3, [r7, #20]
        }
#endif
    }

    /* Determine if everything is okay.  */
    if (status == TX_SUCCESS)
 80164ee:	697b      	ldr	r3, [r7, #20]
 80164f0:	2b00      	cmp	r3, #0
 80164f2:	d103      	bne.n	80164fc <_txe_queue_delete+0x60>
    {

        /* Call actual queue delete function.  */
        status =  _tx_queue_delete(queue_ptr);
 80164f4:	6878      	ldr	r0, [r7, #4]
 80164f6:	f7fd f9d3 	bl	80138a0 <_tx_queue_delete>
 80164fa:	6178      	str	r0, [r7, #20]
    }

    /* Return completion status.  */
    return(status);
 80164fc:	697b      	ldr	r3, [r7, #20]
}
 80164fe:	4618      	mov	r0, r3
 8016500:	3718      	adds	r7, #24
 8016502:	46bd      	mov	sp, r7
 8016504:	bd80      	pop	{r7, pc}
 8016506:	bf00      	nop
 8016508:	51554555 	.word	0x51554555
 801650c:	24000078 	.word	0x24000078
 8016510:	24031bc4 	.word	0x24031bc4
 8016514:	24031d0c 	.word	0x24031d0c

08016518 <_txe_queue_flush>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
UINT  _txe_queue_flush(TX_QUEUE *queue_ptr)
{
 8016518:	b580      	push	{r7, lr}
 801651a:	b084      	sub	sp, #16
 801651c:	af00      	add	r7, sp, #0
 801651e:	6078      	str	r0, [r7, #4]

UINT        status;


    /* Check for an invalid queue pointer.  */
    if (queue_ptr == TX_NULL)
 8016520:	687b      	ldr	r3, [r7, #4]
 8016522:	2b00      	cmp	r3, #0
 8016524:	d102      	bne.n	801652c <_txe_queue_flush+0x14>
    {

        /* Queue pointer is invalid, return appropriate error code.  */
        status =  TX_QUEUE_ERROR;
 8016526:	2309      	movs	r3, #9
 8016528:	60fb      	str	r3, [r7, #12]
 801652a:	e00b      	b.n	8016544 <_txe_queue_flush+0x2c>
    }
    
    /* Now check for invalid queue ID.  */
    else if (queue_ptr -> tx_queue_id != TX_QUEUE_ID)
 801652c:	687b      	ldr	r3, [r7, #4]
 801652e:	681b      	ldr	r3, [r3, #0]
 8016530:	4a07      	ldr	r2, [pc, #28]	; (8016550 <_txe_queue_flush+0x38>)
 8016532:	4293      	cmp	r3, r2
 8016534:	d002      	beq.n	801653c <_txe_queue_flush+0x24>
    {

        /* Queue pointer is invalid, return appropriate error code.  */
        status =  TX_QUEUE_ERROR;
 8016536:	2309      	movs	r3, #9
 8016538:	60fb      	str	r3, [r7, #12]
 801653a:	e003      	b.n	8016544 <_txe_queue_flush+0x2c>
    }
    else
    {

        /* Call actual queue flush function.  */
        status =  _tx_queue_flush(queue_ptr);
 801653c:	6878      	ldr	r0, [r7, #4]
 801653e:	f7fd fa3f 	bl	80139c0 <_tx_queue_flush>
 8016542:	60f8      	str	r0, [r7, #12]
    }

    /* Return completion status.  */
    return(status);
 8016544:	68fb      	ldr	r3, [r7, #12]
}
 8016546:	4618      	mov	r0, r3
 8016548:	3710      	adds	r7, #16
 801654a:	46bd      	mov	sp, r7
 801654c:	bd80      	pop	{r7, pc}
 801654e:	bf00      	nop
 8016550:	51554555 	.word	0x51554555

08016554 <_txe_queue_receive>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
UINT  _txe_queue_receive(TX_QUEUE *queue_ptr, VOID *destination_ptr, ULONG wait_option)
{
 8016554:	b580      	push	{r7, lr}
 8016556:	b088      	sub	sp, #32
 8016558:	af00      	add	r7, sp, #0
 801655a:	60f8      	str	r0, [r7, #12]
 801655c:	60b9      	str	r1, [r7, #8]
 801655e:	607a      	str	r2, [r7, #4]
TX_THREAD   *current_thread;
#endif


    /* Default status to success.  */
    status =  TX_SUCCESS;
 8016560:	2300      	movs	r3, #0
 8016562:	61fb      	str	r3, [r7, #28]

    /* Check for an invalid queue pointer.  */
    if (queue_ptr == TX_NULL)
 8016564:	68fb      	ldr	r3, [r7, #12]
 8016566:	2b00      	cmp	r3, #0
 8016568:	d102      	bne.n	8016570 <_txe_queue_receive+0x1c>
    {

        /* Queue pointer is invalid, return appropriate error code.  */
        status =  TX_QUEUE_ERROR;
 801656a:	2309      	movs	r3, #9
 801656c:	61fb      	str	r3, [r7, #28]
 801656e:	e025      	b.n	80165bc <_txe_queue_receive+0x68>
    }
    
    /* Now check for invalid queue ID.  */
    else if (queue_ptr -> tx_queue_id != TX_QUEUE_ID)
 8016570:	68fb      	ldr	r3, [r7, #12]
 8016572:	681b      	ldr	r3, [r3, #0]
 8016574:	4a18      	ldr	r2, [pc, #96]	; (80165d8 <_txe_queue_receive+0x84>)
 8016576:	4293      	cmp	r3, r2
 8016578:	d002      	beq.n	8016580 <_txe_queue_receive+0x2c>
    {

        /* Queue pointer is invalid, return appropriate error code.  */
        status =  TX_QUEUE_ERROR;
 801657a:	2309      	movs	r3, #9
 801657c:	61fb      	str	r3, [r7, #28]
 801657e:	e01d      	b.n	80165bc <_txe_queue_receive+0x68>
    }

    /* Check for an invalid destination for message.  */
    else if (destination_ptr == TX_NULL)
 8016580:	68bb      	ldr	r3, [r7, #8]
 8016582:	2b00      	cmp	r3, #0
 8016584:	d102      	bne.n	801658c <_txe_queue_receive+0x38>
    {

        /* Null destination pointer, return appropriate error.  */
        status =  TX_PTR_ERROR;
 8016586:	2303      	movs	r3, #3
 8016588:	61fb      	str	r3, [r7, #28]
 801658a:	e017      	b.n	80165bc <_txe_queue_receive+0x68>
    else
    {

        /* Check for a wait option error.  Only threads are allowed any form of 
           suspension.  */
        if (wait_option != TX_NO_WAIT)
 801658c:	687b      	ldr	r3, [r7, #4]
 801658e:	2b00      	cmp	r3, #0
 8016590:	d014      	beq.n	80165bc <_txe_queue_receive+0x68>
    __asm__ volatile (" MRS  %0,IPSR ": "=r" (ipsr_value) );
 8016592:	f3ef 8305 	mrs	r3, IPSR
 8016596:	617b      	str	r3, [r7, #20]
    return(ipsr_value);
 8016598:	697a      	ldr	r2, [r7, #20]
        {

            /* Is the call from an ISR or Initialization?  */
            if (TX_THREAD_GET_SYSTEM_STATE() != ((ULONG) 0))
 801659a:	4b10      	ldr	r3, [pc, #64]	; (80165dc <_txe_queue_receive+0x88>)
 801659c:	681b      	ldr	r3, [r3, #0]
 801659e:	4313      	orrs	r3, r2
 80165a0:	2b00      	cmp	r3, #0
 80165a2:	d002      	beq.n	80165aa <_txe_queue_receive+0x56>
            {

                /* A non-thread is trying to suspend, return appropriate error code.  */
                status =  TX_WAIT_ERROR;
 80165a4:	2304      	movs	r3, #4
 80165a6:	61fb      	str	r3, [r7, #28]
 80165a8:	e008      	b.n	80165bc <_txe_queue_receive+0x68>
#ifndef TX_TIMER_PROCESS_IN_ISR
            else
            {

                /* Pickup thread pointer.  */
                TX_THREAD_GET_CURRENT(current_thread)
 80165aa:	4b0d      	ldr	r3, [pc, #52]	; (80165e0 <_txe_queue_receive+0x8c>)
 80165ac:	681b      	ldr	r3, [r3, #0]
 80165ae:	61bb      	str	r3, [r7, #24]

                /* Is the current thread the timer thread?  */
                if (current_thread == &_tx_timer_thread)
 80165b0:	69bb      	ldr	r3, [r7, #24]
 80165b2:	4a0c      	ldr	r2, [pc, #48]	; (80165e4 <_txe_queue_receive+0x90>)
 80165b4:	4293      	cmp	r3, r2
 80165b6:	d101      	bne.n	80165bc <_txe_queue_receive+0x68>
                {

                    /* A non-thread is trying to suspend, return appropriate error code.  */
                    status =  TX_WAIT_ERROR;
 80165b8:	2304      	movs	r3, #4
 80165ba:	61fb      	str	r3, [r7, #28]
#endif
        }
    }

    /* Determine if everything is okay.  */
    if (status == TX_SUCCESS)
 80165bc:	69fb      	ldr	r3, [r7, #28]
 80165be:	2b00      	cmp	r3, #0
 80165c0:	d105      	bne.n	80165ce <_txe_queue_receive+0x7a>
    {

        /* Call actual queue receive function.  */
        status =  _tx_queue_receive(queue_ptr, destination_ptr, wait_option);
 80165c2:	687a      	ldr	r2, [r7, #4]
 80165c4:	68b9      	ldr	r1, [r7, #8]
 80165c6:	68f8      	ldr	r0, [r7, #12]
 80165c8:	f7fd fa88 	bl	8013adc <_tx_queue_receive>
 80165cc:	61f8      	str	r0, [r7, #28]
    }

    /* Return completion status.  */
    return(status);
 80165ce:	69fb      	ldr	r3, [r7, #28]
}
 80165d0:	4618      	mov	r0, r3
 80165d2:	3720      	adds	r7, #32
 80165d4:	46bd      	mov	sp, r7
 80165d6:	bd80      	pop	{r7, pc}
 80165d8:	51554555 	.word	0x51554555
 80165dc:	24000078 	.word	0x24000078
 80165e0:	24031bc4 	.word	0x24031bc4
 80165e4:	24031d0c 	.word	0x24031d0c

080165e8 <_txe_queue_send>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
UINT  _txe_queue_send(TX_QUEUE *queue_ptr, VOID *source_ptr, ULONG wait_option)
{
 80165e8:	b580      	push	{r7, lr}
 80165ea:	b088      	sub	sp, #32
 80165ec:	af00      	add	r7, sp, #0
 80165ee:	60f8      	str	r0, [r7, #12]
 80165f0:	60b9      	str	r1, [r7, #8]
 80165f2:	607a      	str	r2, [r7, #4]
TX_THREAD   *current_thread;
#endif


    /* Default status to success.  */
    status =  TX_SUCCESS;
 80165f4:	2300      	movs	r3, #0
 80165f6:	61fb      	str	r3, [r7, #28]

    /* Check for an invalid queue pointer.  */
    if (queue_ptr == TX_NULL)
 80165f8:	68fb      	ldr	r3, [r7, #12]
 80165fa:	2b00      	cmp	r3, #0
 80165fc:	d102      	bne.n	8016604 <_txe_queue_send+0x1c>
    {

        /* Queue pointer is invalid, return appropriate error code.  */
        status =  TX_QUEUE_ERROR;
 80165fe:	2309      	movs	r3, #9
 8016600:	61fb      	str	r3, [r7, #28]
 8016602:	e025      	b.n	8016650 <_txe_queue_send+0x68>
    }
    
    /* Now check for invalid queue ID.  */
    else if (queue_ptr -> tx_queue_id != TX_QUEUE_ID)
 8016604:	68fb      	ldr	r3, [r7, #12]
 8016606:	681b      	ldr	r3, [r3, #0]
 8016608:	4a18      	ldr	r2, [pc, #96]	; (801666c <_txe_queue_send+0x84>)
 801660a:	4293      	cmp	r3, r2
 801660c:	d002      	beq.n	8016614 <_txe_queue_send+0x2c>
    {

        /* Queue pointer is invalid, return appropriate error code.  */
        status =  TX_QUEUE_ERROR;
 801660e:	2309      	movs	r3, #9
 8016610:	61fb      	str	r3, [r7, #28]
 8016612:	e01d      	b.n	8016650 <_txe_queue_send+0x68>
    }

    /* Check for an invalid source for message.  */
    else if (source_ptr == TX_NULL)
 8016614:	68bb      	ldr	r3, [r7, #8]
 8016616:	2b00      	cmp	r3, #0
 8016618:	d102      	bne.n	8016620 <_txe_queue_send+0x38>
    {

        /* Null source pointer, return appropriate error.  */
        status =  TX_PTR_ERROR;
 801661a:	2303      	movs	r3, #3
 801661c:	61fb      	str	r3, [r7, #28]
 801661e:	e017      	b.n	8016650 <_txe_queue_send+0x68>
    else
    {

        /* Check for a wait option error.  Only threads are allowed any form of 
           suspension.  */
        if (wait_option != TX_NO_WAIT)
 8016620:	687b      	ldr	r3, [r7, #4]
 8016622:	2b00      	cmp	r3, #0
 8016624:	d014      	beq.n	8016650 <_txe_queue_send+0x68>
    __asm__ volatile (" MRS  %0,IPSR ": "=r" (ipsr_value) );
 8016626:	f3ef 8305 	mrs	r3, IPSR
 801662a:	617b      	str	r3, [r7, #20]
    return(ipsr_value);
 801662c:	697a      	ldr	r2, [r7, #20]
        {

            /* Is the call from an ISR or Initialization?  */
            if (TX_THREAD_GET_SYSTEM_STATE() != ((ULONG) 0))
 801662e:	4b10      	ldr	r3, [pc, #64]	; (8016670 <_txe_queue_send+0x88>)
 8016630:	681b      	ldr	r3, [r3, #0]
 8016632:	4313      	orrs	r3, r2
 8016634:	2b00      	cmp	r3, #0
 8016636:	d002      	beq.n	801663e <_txe_queue_send+0x56>
            {

                /* A non-thread is trying to suspend, return appropriate error code.  */
                status =  TX_WAIT_ERROR;
 8016638:	2304      	movs	r3, #4
 801663a:	61fb      	str	r3, [r7, #28]
 801663c:	e008      	b.n	8016650 <_txe_queue_send+0x68>
#ifndef TX_TIMER_PROCESS_IN_ISR
            else
            {
    
                /* Pickup thread pointer.  */
                TX_THREAD_GET_CURRENT(current_thread)
 801663e:	4b0d      	ldr	r3, [pc, #52]	; (8016674 <_txe_queue_send+0x8c>)
 8016640:	681b      	ldr	r3, [r3, #0]
 8016642:	61bb      	str	r3, [r7, #24]

                /* Is the current thread the timer thread?  */
                if (current_thread == &_tx_timer_thread)
 8016644:	69bb      	ldr	r3, [r7, #24]
 8016646:	4a0c      	ldr	r2, [pc, #48]	; (8016678 <_txe_queue_send+0x90>)
 8016648:	4293      	cmp	r3, r2
 801664a:	d101      	bne.n	8016650 <_txe_queue_send+0x68>
                {

                    /* A non-thread is trying to suspend, return appropriate error code.  */
                    status =  TX_WAIT_ERROR;
 801664c:	2304      	movs	r3, #4
 801664e:	61fb      	str	r3, [r7, #28]
#endif
        }
    }

    /* Determine if everything is okay.  */
    if (status == TX_SUCCESS)
 8016650:	69fb      	ldr	r3, [r7, #28]
 8016652:	2b00      	cmp	r3, #0
 8016654:	d105      	bne.n	8016662 <_txe_queue_send+0x7a>
    {

        /* Call actual queue send function.  */
        status =  _tx_queue_send(queue_ptr, source_ptr, wait_option);
 8016656:	687a      	ldr	r2, [r7, #4]
 8016658:	68b9      	ldr	r1, [r7, #8]
 801665a:	68f8      	ldr	r0, [r7, #12]
 801665c:	f7fd fc06 	bl	8013e6c <_tx_queue_send>
 8016660:	61f8      	str	r0, [r7, #28]
    }

    /* Return completion status.  */
    return(status);
 8016662:	69fb      	ldr	r3, [r7, #28]
}
 8016664:	4618      	mov	r0, r3
 8016666:	3720      	adds	r7, #32
 8016668:	46bd      	mov	sp, r7
 801666a:	bd80      	pop	{r7, pc}
 801666c:	51554555 	.word	0x51554555
 8016670:	24000078 	.word	0x24000078
 8016674:	24031bc4 	.word	0x24031bc4
 8016678:	24031d0c 	.word	0x24031d0c

0801667c <_txe_semaphore_create>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
UINT  _txe_semaphore_create(TX_SEMAPHORE *semaphore_ptr, CHAR *name_ptr, ULONG initial_count, UINT semaphore_control_block_size)
{
 801667c:	b580      	push	{r7, lr}
 801667e:	b092      	sub	sp, #72	; 0x48
 8016680:	af00      	add	r7, sp, #0
 8016682:	60f8      	str	r0, [r7, #12]
 8016684:	60b9      	str	r1, [r7, #8]
 8016686:	607a      	str	r2, [r7, #4]
 8016688:	603b      	str	r3, [r7, #0]
TX_THREAD           *thread_ptr;
#endif


    /* Default status to success.  */
    status =  TX_SUCCESS;
 801668a:	2300      	movs	r3, #0
 801668c:	647b      	str	r3, [r7, #68]	; 0x44

    /* Check for an invalid semaphore pointer.  */
    if (semaphore_ptr == TX_NULL)
 801668e:	68fb      	ldr	r3, [r7, #12]
 8016690:	2b00      	cmp	r3, #0
 8016692:	d102      	bne.n	801669a <_txe_semaphore_create+0x1e>
    {

        /* Semaphore pointer is invalid, return appropriate error code.  */
        status =  TX_SEMAPHORE_ERROR;
 8016694:	230c      	movs	r3, #12
 8016696:	647b      	str	r3, [r7, #68]	; 0x44
 8016698:	e054      	b.n	8016744 <_txe_semaphore_create+0xc8>
    }

    /* Now check for a valid semaphore ID.  */
    else if (semaphore_control_block_size != (sizeof(TX_SEMAPHORE)))
 801669a:	683b      	ldr	r3, [r7, #0]
 801669c:	2b1c      	cmp	r3, #28
 801669e:	d002      	beq.n	80166a6 <_txe_semaphore_create+0x2a>
    {

        /* Semaphore pointer is invalid, return appropriate error code.  */
        status =  TX_SEMAPHORE_ERROR;
 80166a0:	230c      	movs	r3, #12
 80166a2:	647b      	str	r3, [r7, #68]	; 0x44
 80166a4:	e04e      	b.n	8016744 <_txe_semaphore_create+0xc8>
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 80166a6:	f3ef 8310 	mrs	r3, PRIMASK
 80166aa:	62fb      	str	r3, [r7, #44]	; 0x2c
    return(posture);
 80166ac:	6afb      	ldr	r3, [r7, #44]	; 0x2c
    int_posture = __get_interrupt_posture();
 80166ae:	62bb      	str	r3, [r7, #40]	; 0x28
    __asm__ volatile ("CPSID i" : : : "memory");
 80166b0:	b672      	cpsid	i
    return(int_posture);
 80166b2:	6abb      	ldr	r3, [r7, #40]	; 0x28
    }
    else
    {

        /* Disable interrupts.  */
        TX_DISABLE
 80166b4:	63bb      	str	r3, [r7, #56]	; 0x38

        /* Increment the preempt disable flag.  */
        _tx_thread_preempt_disable++;
 80166b6:	4b36      	ldr	r3, [pc, #216]	; (8016790 <_txe_semaphore_create+0x114>)
 80166b8:	681b      	ldr	r3, [r3, #0]
 80166ba:	3301      	adds	r3, #1
 80166bc:	4a34      	ldr	r2, [pc, #208]	; (8016790 <_txe_semaphore_create+0x114>)
 80166be:	6013      	str	r3, [r2, #0]
 80166c0:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 80166c2:	633b      	str	r3, [r7, #48]	; 0x30
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 80166c4:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 80166c6:	f383 8810 	msr	PRIMASK, r3
}
 80166ca:	bf00      	nop

        /* Restore interrupts.  */
        TX_RESTORE

        /* Next see if it is already in the created list.  */
        next_semaphore =  _tx_semaphore_created_ptr;
 80166cc:	4b31      	ldr	r3, [pc, #196]	; (8016794 <_txe_semaphore_create+0x118>)
 80166ce:	681b      	ldr	r3, [r3, #0]
 80166d0:	63fb      	str	r3, [r7, #60]	; 0x3c
        for (i = ((ULONG) 0); i < _tx_semaphore_created_count; i++)
 80166d2:	2300      	movs	r3, #0
 80166d4:	643b      	str	r3, [r7, #64]	; 0x40
 80166d6:	e009      	b.n	80166ec <_txe_semaphore_create+0x70>
        {

            /* Determine if this semaphore matches the current semaphore in the list.  */
            if (semaphore_ptr == next_semaphore)
 80166d8:	68fa      	ldr	r2, [r7, #12]
 80166da:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 80166dc:	429a      	cmp	r2, r3
 80166de:	d00b      	beq.n	80166f8 <_txe_semaphore_create+0x7c>
            }
            else
            {
            
                /* Move to next semaphore.  */
                next_semaphore =  next_semaphore -> tx_semaphore_created_next;
 80166e0:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 80166e2:	695b      	ldr	r3, [r3, #20]
 80166e4:	63fb      	str	r3, [r7, #60]	; 0x3c
        for (i = ((ULONG) 0); i < _tx_semaphore_created_count; i++)
 80166e6:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 80166e8:	3301      	adds	r3, #1
 80166ea:	643b      	str	r3, [r7, #64]	; 0x40
 80166ec:	4b2a      	ldr	r3, [pc, #168]	; (8016798 <_txe_semaphore_create+0x11c>)
 80166ee:	681b      	ldr	r3, [r3, #0]
 80166f0:	6c3a      	ldr	r2, [r7, #64]	; 0x40
 80166f2:	429a      	cmp	r2, r3
 80166f4:	d3f0      	bcc.n	80166d8 <_txe_semaphore_create+0x5c>
 80166f6:	e000      	b.n	80166fa <_txe_semaphore_create+0x7e>
                break;
 80166f8:	bf00      	nop
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 80166fa:	f3ef 8310 	mrs	r3, PRIMASK
 80166fe:	623b      	str	r3, [r7, #32]
    return(posture);
 8016700:	6a3b      	ldr	r3, [r7, #32]
    int_posture = __get_interrupt_posture();
 8016702:	61fb      	str	r3, [r7, #28]
    __asm__ volatile ("CPSID i" : : : "memory");
 8016704:	b672      	cpsid	i
    return(int_posture);
 8016706:	69fb      	ldr	r3, [r7, #28]
            }
        }

        /* Disable interrupts.  */
        TX_DISABLE
 8016708:	63bb      	str	r3, [r7, #56]	; 0x38

        /* Decrement the preempt disable flag.  */
        _tx_thread_preempt_disable--;
 801670a:	4b21      	ldr	r3, [pc, #132]	; (8016790 <_txe_semaphore_create+0x114>)
 801670c:	681b      	ldr	r3, [r3, #0]
 801670e:	3b01      	subs	r3, #1
 8016710:	4a1f      	ldr	r2, [pc, #124]	; (8016790 <_txe_semaphore_create+0x114>)
 8016712:	6013      	str	r3, [r2, #0]
 8016714:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8016716:	627b      	str	r3, [r7, #36]	; 0x24
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 8016718:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801671a:	f383 8810 	msr	PRIMASK, r3
}
 801671e:	bf00      	nop
    
        /* Restore interrupts.  */
        TX_RESTORE

        /* Check for preemption.  */
        _tx_thread_system_preempt_check();
 8016720:	f7fe fac8 	bl	8014cb4 <_tx_thread_system_preempt_check>

        /* At this point, check to see if there is a duplicate semaphore.  */
        if (semaphore_ptr == next_semaphore)
 8016724:	68fa      	ldr	r2, [r7, #12]
 8016726:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8016728:	429a      	cmp	r2, r3
 801672a:	d102      	bne.n	8016732 <_txe_semaphore_create+0xb6>
        {

            /* Semaphore is already created, return appropriate error code.  */
            status =  TX_SEMAPHORE_ERROR;
 801672c:	230c      	movs	r3, #12
 801672e:	647b      	str	r3, [r7, #68]	; 0x44
 8016730:	e008      	b.n	8016744 <_txe_semaphore_create+0xc8>
#ifndef TX_TIMER_PROCESS_IN_ISR
        else
        {
        
            /* Pickup thread pointer.  */
            TX_THREAD_GET_CURRENT(thread_ptr)
 8016732:	4b1a      	ldr	r3, [pc, #104]	; (801679c <_txe_semaphore_create+0x120>)
 8016734:	681b      	ldr	r3, [r3, #0]
 8016736:	637b      	str	r3, [r7, #52]	; 0x34

            /* Check for invalid caller of this function.  First check for a calling thread.  */
            if (thread_ptr == &_tx_timer_thread)
 8016738:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 801673a:	4a19      	ldr	r2, [pc, #100]	; (80167a0 <_txe_semaphore_create+0x124>)
 801673c:	4293      	cmp	r3, r2
 801673e:	d101      	bne.n	8016744 <_txe_semaphore_create+0xc8>
            {

                /* Invalid caller of this function, return appropriate error code.  */
                status =  TX_CALLER_ERROR;
 8016740:	2313      	movs	r3, #19
 8016742:	647b      	str	r3, [r7, #68]	; 0x44
        }
#endif
    }

    /* Determine if everything is okay.  */
    if (status == TX_SUCCESS)
 8016744:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8016746:	2b00      	cmp	r3, #0
 8016748:	d114      	bne.n	8016774 <_txe_semaphore_create+0xf8>
    __asm__ volatile (" MRS  %0,IPSR ": "=r" (ipsr_value) );
 801674a:	f3ef 8305 	mrs	r3, IPSR
 801674e:	61bb      	str	r3, [r7, #24]
    return(ipsr_value);
 8016750:	69ba      	ldr	r2, [r7, #24]
    {

        /* Check for interrupt call.  */
        if (TX_THREAD_GET_SYSTEM_STATE() != ((ULONG) 0))
 8016752:	4b14      	ldr	r3, [pc, #80]	; (80167a4 <_txe_semaphore_create+0x128>)
 8016754:	681b      	ldr	r3, [r3, #0]
 8016756:	4313      	orrs	r3, r2
 8016758:	2b00      	cmp	r3, #0
 801675a:	d00b      	beq.n	8016774 <_txe_semaphore_create+0xf8>
    __asm__ volatile (" MRS  %0,IPSR ": "=r" (ipsr_value) );
 801675c:	f3ef 8305 	mrs	r3, IPSR
 8016760:	617b      	str	r3, [r7, #20]
    return(ipsr_value);
 8016762:	697a      	ldr	r2, [r7, #20]
        {
    
            /* Now, make sure the call is from an interrupt and not initialization.  */
            if (TX_THREAD_GET_SYSTEM_STATE() < TX_INITIALIZE_IN_PROGRESS)
 8016764:	4b0f      	ldr	r3, [pc, #60]	; (80167a4 <_txe_semaphore_create+0x128>)
 8016766:	681b      	ldr	r3, [r3, #0]
 8016768:	4313      	orrs	r3, r2
 801676a:	f1b3 3ff0 	cmp.w	r3, #4042322160	; 0xf0f0f0f0
 801676e:	d201      	bcs.n	8016774 <_txe_semaphore_create+0xf8>
            {
        
                /* Invalid caller of this function, return appropriate error code.  */
                status =  TX_CALLER_ERROR;
 8016770:	2313      	movs	r3, #19
 8016772:	647b      	str	r3, [r7, #68]	; 0x44
            }
        }
    }

    /* Determine if everything is okay.  */
    if (status == TX_SUCCESS)
 8016774:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8016776:	2b00      	cmp	r3, #0
 8016778:	d105      	bne.n	8016786 <_txe_semaphore_create+0x10a>
    {

        /* Call actual semaphore create function.  */
        status =  _tx_semaphore_create(semaphore_ptr, name_ptr, initial_count);
 801677a:	687a      	ldr	r2, [r7, #4]
 801677c:	68b9      	ldr	r1, [r7, #8]
 801677e:	68f8      	ldr	r0, [r7, #12]
 8016780:	f7fd fd1c 	bl	80141bc <_tx_semaphore_create>
 8016784:	6478      	str	r0, [r7, #68]	; 0x44
    }

    /* Return completion status.  */
    return(status);
 8016786:	6c7b      	ldr	r3, [r7, #68]	; 0x44
}
 8016788:	4618      	mov	r0, r3
 801678a:	3748      	adds	r7, #72	; 0x48
 801678c:	46bd      	mov	sp, r7
 801678e:	bd80      	pop	{r7, pc}
 8016790:	24031c5c 	.word	0x24031c5c
 8016794:	24031b8c 	.word	0x24031b8c
 8016798:	24031b90 	.word	0x24031b90
 801679c:	24031bc4 	.word	0x24031bc4
 80167a0:	24031d0c 	.word	0x24031d0c
 80167a4:	24000078 	.word	0x24000078

080167a8 <_txe_semaphore_delete>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
UINT  _txe_semaphore_delete(TX_SEMAPHORE *semaphore_ptr)
{
 80167a8:	b580      	push	{r7, lr}
 80167aa:	b086      	sub	sp, #24
 80167ac:	af00      	add	r7, sp, #0
 80167ae:	6078      	str	r0, [r7, #4]
TX_THREAD       *thread_ptr;
#endif


    /* Default status to success.  */
    status =  TX_SUCCESS;
 80167b0:	2300      	movs	r3, #0
 80167b2:	617b      	str	r3, [r7, #20]

    /* Check for an invalid semaphore pointer.  */
    if (semaphore_ptr == TX_NULL)
 80167b4:	687b      	ldr	r3, [r7, #4]
 80167b6:	2b00      	cmp	r3, #0
 80167b8:	d102      	bne.n	80167c0 <_txe_semaphore_delete+0x18>
    {

        /* Semaphore pointer is invalid, return appropriate error code.  */
        status =  TX_SEMAPHORE_ERROR;
 80167ba:	230c      	movs	r3, #12
 80167bc:	617b      	str	r3, [r7, #20]
 80167be:	e01c      	b.n	80167fa <_txe_semaphore_delete+0x52>
    }

    /* Now check for invalid semaphore ID.  */
    else if (semaphore_ptr -> tx_semaphore_id != TX_SEMAPHORE_ID)
 80167c0:	687b      	ldr	r3, [r7, #4]
 80167c2:	681b      	ldr	r3, [r3, #0]
 80167c4:	4a13      	ldr	r2, [pc, #76]	; (8016814 <_txe_semaphore_delete+0x6c>)
 80167c6:	4293      	cmp	r3, r2
 80167c8:	d002      	beq.n	80167d0 <_txe_semaphore_delete+0x28>
    {

        /* Semaphore pointer is invalid, return appropriate error code.  */
        status =  TX_SEMAPHORE_ERROR;
 80167ca:	230c      	movs	r3, #12
 80167cc:	617b      	str	r3, [r7, #20]
 80167ce:	e014      	b.n	80167fa <_txe_semaphore_delete+0x52>
    __asm__ volatile (" MRS  %0,IPSR ": "=r" (ipsr_value) );
 80167d0:	f3ef 8305 	mrs	r3, IPSR
 80167d4:	60fb      	str	r3, [r7, #12]
    return(ipsr_value);
 80167d6:	68fa      	ldr	r2, [r7, #12]
    {

        /* Check for invalid caller of this function.  */

        /* Is the caller an ISR or Initialization?  */
        if (TX_THREAD_GET_SYSTEM_STATE() != ((ULONG) 0))
 80167d8:	4b0f      	ldr	r3, [pc, #60]	; (8016818 <_txe_semaphore_delete+0x70>)
 80167da:	681b      	ldr	r3, [r3, #0]
 80167dc:	4313      	orrs	r3, r2
 80167de:	2b00      	cmp	r3, #0
 80167e0:	d002      	beq.n	80167e8 <_txe_semaphore_delete+0x40>
        {

            /* Invalid caller of this function, return appropriate error code.  */
            status =  TX_CALLER_ERROR;
 80167e2:	2313      	movs	r3, #19
 80167e4:	617b      	str	r3, [r7, #20]
 80167e6:	e008      	b.n	80167fa <_txe_semaphore_delete+0x52>
#ifndef TX_TIMER_PROCESS_IN_ISR
        else
        {
        
            /* Pickup thread pointer.  */
            TX_THREAD_GET_CURRENT(thread_ptr)
 80167e8:	4b0c      	ldr	r3, [pc, #48]	; (801681c <_txe_semaphore_delete+0x74>)
 80167ea:	681b      	ldr	r3, [r3, #0]
 80167ec:	613b      	str	r3, [r7, #16]

            /* Is the caller the system timer thread?  */
            if (thread_ptr == &_tx_timer_thread)
 80167ee:	693b      	ldr	r3, [r7, #16]
 80167f0:	4a0b      	ldr	r2, [pc, #44]	; (8016820 <_txe_semaphore_delete+0x78>)
 80167f2:	4293      	cmp	r3, r2
 80167f4:	d101      	bne.n	80167fa <_txe_semaphore_delete+0x52>
            {

                /* Invalid caller of this function, return appropriate error code.  */
                status =  TX_CALLER_ERROR;
 80167f6:	2313      	movs	r3, #19
 80167f8:	617b      	str	r3, [r7, #20]
        }
#endif
    }

    /* Determine if everything is okay.  */
    if (status == TX_SUCCESS)
 80167fa:	697b      	ldr	r3, [r7, #20]
 80167fc:	2b00      	cmp	r3, #0
 80167fe:	d103      	bne.n	8016808 <_txe_semaphore_delete+0x60>
    {

        /* Call actual semaphore delete function.  */
        status =  _tx_semaphore_delete(semaphore_ptr);
 8016800:	6878      	ldr	r0, [r7, #4]
 8016802:	f7fd fd2d 	bl	8014260 <_tx_semaphore_delete>
 8016806:	6178      	str	r0, [r7, #20]
    }

    /* Return completion status.  */
    return(status);
 8016808:	697b      	ldr	r3, [r7, #20]
}
 801680a:	4618      	mov	r0, r3
 801680c:	3718      	adds	r7, #24
 801680e:	46bd      	mov	sp, r7
 8016810:	bd80      	pop	{r7, pc}
 8016812:	bf00      	nop
 8016814:	53454d41 	.word	0x53454d41
 8016818:	24000078 	.word	0x24000078
 801681c:	24031bc4 	.word	0x24031bc4
 8016820:	24031d0c 	.word	0x24031d0c

08016824 <_txe_semaphore_get>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
UINT  _txe_semaphore_get(TX_SEMAPHORE *semaphore_ptr, ULONG wait_option)
{
 8016824:	b580      	push	{r7, lr}
 8016826:	b086      	sub	sp, #24
 8016828:	af00      	add	r7, sp, #0
 801682a:	6078      	str	r0, [r7, #4]
 801682c:	6039      	str	r1, [r7, #0]
TX_THREAD   *current_thread;
#endif


    /* Default status to success.  */
    status =  TX_SUCCESS;
 801682e:	2300      	movs	r3, #0
 8016830:	617b      	str	r3, [r7, #20]

    /* Check for an invalid semaphore pointer.  */
    if (semaphore_ptr == TX_NULL)
 8016832:	687b      	ldr	r3, [r7, #4]
 8016834:	2b00      	cmp	r3, #0
 8016836:	d102      	bne.n	801683e <_txe_semaphore_get+0x1a>
    {

        /* Semaphore pointer is invalid, return appropriate error code.  */
        status =  TX_SEMAPHORE_ERROR;
 8016838:	230c      	movs	r3, #12
 801683a:	617b      	str	r3, [r7, #20]
 801683c:	e01f      	b.n	801687e <_txe_semaphore_get+0x5a>
    }
    
    /* Now check for invalid semaphore ID.  */
    else if (semaphore_ptr -> tx_semaphore_id != TX_SEMAPHORE_ID)
 801683e:	687b      	ldr	r3, [r7, #4]
 8016840:	681b      	ldr	r3, [r3, #0]
 8016842:	4a15      	ldr	r2, [pc, #84]	; (8016898 <_txe_semaphore_get+0x74>)
 8016844:	4293      	cmp	r3, r2
 8016846:	d002      	beq.n	801684e <_txe_semaphore_get+0x2a>
    {

        /* Semaphore pointer is invalid, return appropriate error code.  */
        status =  TX_SEMAPHORE_ERROR;
 8016848:	230c      	movs	r3, #12
 801684a:	617b      	str	r3, [r7, #20]
 801684c:	e017      	b.n	801687e <_txe_semaphore_get+0x5a>
    else
    {

        /* Check for a wait option error.  Only threads are allowed any form of 
           suspension.  */
        if (wait_option != TX_NO_WAIT)
 801684e:	683b      	ldr	r3, [r7, #0]
 8016850:	2b00      	cmp	r3, #0
 8016852:	d014      	beq.n	801687e <_txe_semaphore_get+0x5a>
    __asm__ volatile (" MRS  %0,IPSR ": "=r" (ipsr_value) );
 8016854:	f3ef 8305 	mrs	r3, IPSR
 8016858:	60fb      	str	r3, [r7, #12]
    return(ipsr_value);
 801685a:	68fa      	ldr	r2, [r7, #12]
        {

            /* Is the call from an ISR or Initialization?  */
            if (TX_THREAD_GET_SYSTEM_STATE() != ((ULONG) 0))
 801685c:	4b0f      	ldr	r3, [pc, #60]	; (801689c <_txe_semaphore_get+0x78>)
 801685e:	681b      	ldr	r3, [r3, #0]
 8016860:	4313      	orrs	r3, r2
 8016862:	2b00      	cmp	r3, #0
 8016864:	d002      	beq.n	801686c <_txe_semaphore_get+0x48>
            {

                /* A non-thread is trying to suspend, return appropriate error code.  */
                status =  TX_WAIT_ERROR;
 8016866:	2304      	movs	r3, #4
 8016868:	617b      	str	r3, [r7, #20]
 801686a:	e008      	b.n	801687e <_txe_semaphore_get+0x5a>
#ifndef TX_TIMER_PROCESS_IN_ISR
            else
            {
            
                /* Pickup thread pointer.  */
                TX_THREAD_GET_CURRENT(current_thread)
 801686c:	4b0c      	ldr	r3, [pc, #48]	; (80168a0 <_txe_semaphore_get+0x7c>)
 801686e:	681b      	ldr	r3, [r3, #0]
 8016870:	613b      	str	r3, [r7, #16]

                /* Is the current thread the timer thread?  */
                if (current_thread == &_tx_timer_thread)
 8016872:	693b      	ldr	r3, [r7, #16]
 8016874:	4a0b      	ldr	r2, [pc, #44]	; (80168a4 <_txe_semaphore_get+0x80>)
 8016876:	4293      	cmp	r3, r2
 8016878:	d101      	bne.n	801687e <_txe_semaphore_get+0x5a>
                {

                    /* A non-thread is trying to suspend, return appropriate error code.  */
                    status =  TX_WAIT_ERROR;
 801687a:	2304      	movs	r3, #4
 801687c:	617b      	str	r3, [r7, #20]
#endif
        }
    }

    /* Determine if everything is okay.  */
    if (status == TX_SUCCESS)
 801687e:	697b      	ldr	r3, [r7, #20]
 8016880:	2b00      	cmp	r3, #0
 8016882:	d104      	bne.n	801688e <_txe_semaphore_get+0x6a>
    {

        /* Call actual get semaphore function.  */
        status =  _tx_semaphore_get(semaphore_ptr, wait_option);
 8016884:	6839      	ldr	r1, [r7, #0]
 8016886:	6878      	ldr	r0, [r7, #4]
 8016888:	f7fd fd7a 	bl	8014380 <_tx_semaphore_get>
 801688c:	6178      	str	r0, [r7, #20]
    }

    /* Return completion status.  */
    return(status);
 801688e:	697b      	ldr	r3, [r7, #20]
}
 8016890:	4618      	mov	r0, r3
 8016892:	3718      	adds	r7, #24
 8016894:	46bd      	mov	sp, r7
 8016896:	bd80      	pop	{r7, pc}
 8016898:	53454d41 	.word	0x53454d41
 801689c:	24000078 	.word	0x24000078
 80168a0:	24031bc4 	.word	0x24031bc4
 80168a4:	24031d0c 	.word	0x24031d0c

080168a8 <_txe_semaphore_put>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
UINT  _txe_semaphore_put(TX_SEMAPHORE *semaphore_ptr)
{
 80168a8:	b580      	push	{r7, lr}
 80168aa:	b084      	sub	sp, #16
 80168ac:	af00      	add	r7, sp, #0
 80168ae:	6078      	str	r0, [r7, #4]

UINT        status;


    /* Check for an invalid semaphore pointer.  */
    if (semaphore_ptr == TX_NULL)
 80168b0:	687b      	ldr	r3, [r7, #4]
 80168b2:	2b00      	cmp	r3, #0
 80168b4:	d102      	bne.n	80168bc <_txe_semaphore_put+0x14>
    {

        /* Semaphore pointer is invalid, return appropriate error code.  */
        status =  TX_SEMAPHORE_ERROR;
 80168b6:	230c      	movs	r3, #12
 80168b8:	60fb      	str	r3, [r7, #12]
 80168ba:	e00b      	b.n	80168d4 <_txe_semaphore_put+0x2c>
    }
    
    /* Now check for invalid semaphore ID.  */
    else if (semaphore_ptr -> tx_semaphore_id != TX_SEMAPHORE_ID)
 80168bc:	687b      	ldr	r3, [r7, #4]
 80168be:	681b      	ldr	r3, [r3, #0]
 80168c0:	4a07      	ldr	r2, [pc, #28]	; (80168e0 <_txe_semaphore_put+0x38>)
 80168c2:	4293      	cmp	r3, r2
 80168c4:	d002      	beq.n	80168cc <_txe_semaphore_put+0x24>
    {

        /* Semaphore pointer is invalid, return appropriate error code.  */
        status =  TX_SEMAPHORE_ERROR;
 80168c6:	230c      	movs	r3, #12
 80168c8:	60fb      	str	r3, [r7, #12]
 80168ca:	e003      	b.n	80168d4 <_txe_semaphore_put+0x2c>
    }
    else
    {

        /* Call actual put semaphore function.  */
        status =  _tx_semaphore_put(semaphore_ptr);
 80168cc:	6878      	ldr	r0, [r7, #4]
 80168ce:	f7fd fde9 	bl	80144a4 <_tx_semaphore_put>
 80168d2:	60f8      	str	r0, [r7, #12]
    }

    /* Return completion status.  */
    return(status);
 80168d4:	68fb      	ldr	r3, [r7, #12]
}
 80168d6:	4618      	mov	r0, r3
 80168d8:	3710      	adds	r7, #16
 80168da:	46bd      	mov	sp, r7
 80168dc:	bd80      	pop	{r7, pc}
 80168de:	bf00      	nop
 80168e0:	53454d41 	.word	0x53454d41

080168e4 <_txe_thread_create>:
UINT    _txe_thread_create(TX_THREAD *thread_ptr, CHAR *name_ptr, 
                VOID (*entry_function)(ULONG id), ULONG entry_input,
                VOID *stack_start, ULONG stack_size, 
                UINT priority, UINT preempt_threshold,
                ULONG time_slice, UINT auto_start, UINT thread_control_block_size)
{
 80168e4:	b580      	push	{r7, lr}
 80168e6:	b09a      	sub	sp, #104	; 0x68
 80168e8:	af06      	add	r7, sp, #24
 80168ea:	60f8      	str	r0, [r7, #12]
 80168ec:	60b9      	str	r1, [r7, #8]
 80168ee:	607a      	str	r2, [r7, #4]
 80168f0:	603b      	str	r3, [r7, #0]
TX_THREAD       *current_thread;
#endif


    /* Default status to success.  */
    status =  TX_SUCCESS;
 80168f2:	2300      	movs	r3, #0
 80168f4:	64fb      	str	r3, [r7, #76]	; 0x4c

    /* Check for an invalid thread pointer.  */
    if (thread_ptr == TX_NULL)
 80168f6:	68fb      	ldr	r3, [r7, #12]
 80168f8:	2b00      	cmp	r3, #0
 80168fa:	d102      	bne.n	8016902 <_txe_thread_create+0x1e>
    {

        /* Thread pointer is invalid, return appropriate error code.  */
        status =  TX_THREAD_ERROR;
 80168fc:	230e      	movs	r3, #14
 80168fe:	64fb      	str	r3, [r7, #76]	; 0x4c
 8016900:	e0bb      	b.n	8016a7a <_txe_thread_create+0x196>
    }

    /* Now check for invalid thread control block size.  */
    else if (thread_control_block_size != (sizeof(TX_THREAD)))
 8016902:	6f3b      	ldr	r3, [r7, #112]	; 0x70
 8016904:	2bb4      	cmp	r3, #180	; 0xb4
 8016906:	d002      	beq.n	801690e <_txe_thread_create+0x2a>
    {

        /* Thread pointer is invalid, return appropriate error code.  */
        status =  TX_THREAD_ERROR;
 8016908:	230e      	movs	r3, #14
 801690a:	64fb      	str	r3, [r7, #76]	; 0x4c
 801690c:	e0b5      	b.n	8016a7a <_txe_thread_create+0x196>
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 801690e:	f3ef 8310 	mrs	r3, PRIMASK
 8016912:	62bb      	str	r3, [r7, #40]	; 0x28
    return(posture);
 8016914:	6abb      	ldr	r3, [r7, #40]	; 0x28
    int_posture = __get_interrupt_posture();
 8016916:	627b      	str	r3, [r7, #36]	; 0x24
    __asm__ volatile ("CPSID i" : : : "memory");
 8016918:	b672      	cpsid	i
    return(int_posture);
 801691a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    }
    else
    {

        /* Disable interrupts.  */
        TX_DISABLE
 801691c:	63fb      	str	r3, [r7, #60]	; 0x3c

        /* Increment the preempt disable flag.  */
        _tx_thread_preempt_disable++;
 801691e:	4b64      	ldr	r3, [pc, #400]	; (8016ab0 <_txe_thread_create+0x1cc>)
 8016920:	681b      	ldr	r3, [r3, #0]
 8016922:	3301      	adds	r3, #1
 8016924:	4a62      	ldr	r2, [pc, #392]	; (8016ab0 <_txe_thread_create+0x1cc>)
 8016926:	6013      	str	r3, [r2, #0]
 8016928:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 801692a:	62fb      	str	r3, [r7, #44]	; 0x2c
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 801692c:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 801692e:	f383 8810 	msr	PRIMASK, r3
}
 8016932:	bf00      	nop

        /* Restore interrupts.  */
        TX_RESTORE

        /* Next see if it is already in the created list.  */
        break_flag =   TX_FALSE;
 8016934:	2300      	movs	r3, #0
 8016936:	64bb      	str	r3, [r7, #72]	; 0x48
        next_thread =  _tx_thread_created_ptr;
 8016938:	4b5e      	ldr	r3, [pc, #376]	; (8016ab4 <_txe_thread_create+0x1d0>)
 801693a:	681b      	ldr	r3, [r3, #0]
 801693c:	643b      	str	r3, [r7, #64]	; 0x40
        work_ptr =     TX_VOID_TO_UCHAR_POINTER_CONVERT(stack_start);
 801693e:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 8016940:	63bb      	str	r3, [r7, #56]	; 0x38
        work_ptr =     TX_UCHAR_POINTER_ADD(work_ptr, (stack_size - ((ULONG) 1)));
 8016942:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 8016944:	3b01      	subs	r3, #1
 8016946:	6bba      	ldr	r2, [r7, #56]	; 0x38
 8016948:	4413      	add	r3, r2
 801694a:	63bb      	str	r3, [r7, #56]	; 0x38
        stack_end =    TX_UCHAR_TO_VOID_POINTER_CONVERT(work_ptr);
 801694c:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 801694e:	637b      	str	r3, [r7, #52]	; 0x34
        for (i = ((ULONG) 0); i < _tx_thread_created_count; i++)
 8016950:	2300      	movs	r3, #0
 8016952:	647b      	str	r3, [r7, #68]	; 0x44
 8016954:	e02b      	b.n	80169ae <_txe_thread_create+0xca>
        {
        
            /* Determine if this thread matches the thread in the list.  */
            if (thread_ptr == next_thread)
 8016956:	68fa      	ldr	r2, [r7, #12]
 8016958:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 801695a:	429a      	cmp	r2, r3
 801695c:	d101      	bne.n	8016962 <_txe_thread_create+0x7e>
            {
        
                /* Set the break flag.  */
                break_flag =  TX_TRUE;
 801695e:	2301      	movs	r3, #1
 8016960:	64bb      	str	r3, [r7, #72]	; 0x48
            }
            
            /* Determine if we need to break the loop.  */
            if (break_flag == TX_TRUE)
 8016962:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 8016964:	2b01      	cmp	r3, #1
 8016966:	d028      	beq.n	80169ba <_txe_thread_create+0xd6>
                /* Yes, break out of the loop.  */
                break;
            }

            /* Check the stack pointer to see if it overlaps with this thread's stack.  */
            if (stack_start >= next_thread -> tx_thread_stack_start)
 8016968:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 801696a:	68db      	ldr	r3, [r3, #12]
 801696c:	6dba      	ldr	r2, [r7, #88]	; 0x58
 801696e:	429a      	cmp	r2, r3
 8016970:	d308      	bcc.n	8016984 <_txe_thread_create+0xa0>
            {

                if (stack_start < next_thread -> tx_thread_stack_end)
 8016972:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8016974:	691b      	ldr	r3, [r3, #16]
 8016976:	6dba      	ldr	r2, [r7, #88]	; 0x58
 8016978:	429a      	cmp	r2, r3
 801697a:	d203      	bcs.n	8016984 <_txe_thread_create+0xa0>
                {
        
                    /* This stack overlaps with an existing thread, clear the stack pointer to 
                       force a stack error below.  */
                    stack_start =  TX_NULL;
 801697c:	2300      	movs	r3, #0
 801697e:	65bb      	str	r3, [r7, #88]	; 0x58
                    
                    /* Set the break flag.  */
                    break_flag =  TX_TRUE;
 8016980:	2301      	movs	r3, #1
 8016982:	64bb      	str	r3, [r7, #72]	; 0x48
                }
            }

            /* Check the end of the stack to see if it is inside this thread's stack area as well.  */
            if (stack_end >= next_thread -> tx_thread_stack_start)
 8016984:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8016986:	68db      	ldr	r3, [r3, #12]
 8016988:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 801698a:	429a      	cmp	r2, r3
 801698c:	d308      	bcc.n	80169a0 <_txe_thread_create+0xbc>
            {

                if (stack_end < next_thread -> tx_thread_stack_end)
 801698e:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8016990:	691b      	ldr	r3, [r3, #16]
 8016992:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 8016994:	429a      	cmp	r2, r3
 8016996:	d203      	bcs.n	80169a0 <_txe_thread_create+0xbc>
                {
        
                    /* This stack overlaps with an existing thread, clear the stack pointer to 
                       force a stack error below.  */
                    stack_start =  TX_NULL;
 8016998:	2300      	movs	r3, #0
 801699a:	65bb      	str	r3, [r7, #88]	; 0x58
                    
                    /* Set the break flag.  */
                    break_flag =  TX_TRUE;
 801699c:	2301      	movs	r3, #1
 801699e:	64bb      	str	r3, [r7, #72]	; 0x48
                }
            }

            /* Move to the next thread.  */
            next_thread =  next_thread -> tx_thread_created_next;
 80169a0:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 80169a2:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
 80169a6:	643b      	str	r3, [r7, #64]	; 0x40
        for (i = ((ULONG) 0); i < _tx_thread_created_count; i++)
 80169a8:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 80169aa:	3301      	adds	r3, #1
 80169ac:	647b      	str	r3, [r7, #68]	; 0x44
 80169ae:	4b42      	ldr	r3, [pc, #264]	; (8016ab8 <_txe_thread_create+0x1d4>)
 80169b0:	681b      	ldr	r3, [r3, #0]
 80169b2:	6c7a      	ldr	r2, [r7, #68]	; 0x44
 80169b4:	429a      	cmp	r2, r3
 80169b6:	d3ce      	bcc.n	8016956 <_txe_thread_create+0x72>
 80169b8:	e000      	b.n	80169bc <_txe_thread_create+0xd8>
                break;
 80169ba:	bf00      	nop
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 80169bc:	f3ef 8310 	mrs	r3, PRIMASK
 80169c0:	61fb      	str	r3, [r7, #28]
    return(posture);
 80169c2:	69fb      	ldr	r3, [r7, #28]
    int_posture = __get_interrupt_posture();
 80169c4:	61bb      	str	r3, [r7, #24]
    __asm__ volatile ("CPSID i" : : : "memory");
 80169c6:	b672      	cpsid	i
    return(int_posture);
 80169c8:	69bb      	ldr	r3, [r7, #24]
        }

        /* Disable interrupts.  */
        TX_DISABLE
 80169ca:	63fb      	str	r3, [r7, #60]	; 0x3c

        /* Decrement the preempt disable flag.  */
        _tx_thread_preempt_disable--;
 80169cc:	4b38      	ldr	r3, [pc, #224]	; (8016ab0 <_txe_thread_create+0x1cc>)
 80169ce:	681b      	ldr	r3, [r3, #0]
 80169d0:	3b01      	subs	r3, #1
 80169d2:	4a37      	ldr	r2, [pc, #220]	; (8016ab0 <_txe_thread_create+0x1cc>)
 80169d4:	6013      	str	r3, [r2, #0]
 80169d6:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 80169d8:	623b      	str	r3, [r7, #32]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 80169da:	6a3b      	ldr	r3, [r7, #32]
 80169dc:	f383 8810 	msr	PRIMASK, r3
}
 80169e0:	bf00      	nop
    
        /* Restore interrupts.  */
        TX_RESTORE

        /* Check for preemption.  */
        _tx_thread_system_preempt_check();
 80169e2:	f7fe f967 	bl	8014cb4 <_tx_thread_system_preempt_check>

        /* At this point, check to see if there is a duplicate thread.  */
        if (thread_ptr == next_thread)
 80169e6:	68fa      	ldr	r2, [r7, #12]
 80169e8:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 80169ea:	429a      	cmp	r2, r3
 80169ec:	d102      	bne.n	80169f4 <_txe_thread_create+0x110>
        {

            /* Thread is already created, return appropriate error code.  */
            status =  TX_THREAD_ERROR;
 80169ee:	230e      	movs	r3, #14
 80169f0:	64fb      	str	r3, [r7, #76]	; 0x4c
 80169f2:	e042      	b.n	8016a7a <_txe_thread_create+0x196>
        }

        /* Check for invalid starting address of stack.  */
        else if (stack_start == TX_NULL)
 80169f4:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 80169f6:	2b00      	cmp	r3, #0
 80169f8:	d102      	bne.n	8016a00 <_txe_thread_create+0x11c>
        {

            /* Invalid stack or entry point, return appropriate error code.  */
            status =  TX_PTR_ERROR;
 80169fa:	2303      	movs	r3, #3
 80169fc:	64fb      	str	r3, [r7, #76]	; 0x4c
 80169fe:	e03c      	b.n	8016a7a <_txe_thread_create+0x196>
        }

        /* Check for invalid thread entry point.  */
        else if (entry_function == TX_NULL)
 8016a00:	687b      	ldr	r3, [r7, #4]
 8016a02:	2b00      	cmp	r3, #0
 8016a04:	d102      	bne.n	8016a0c <_txe_thread_create+0x128>
        {

            /* Invalid stack or entry point, return appropriate error code.  */
            status =  TX_PTR_ERROR;
 8016a06:	2303      	movs	r3, #3
 8016a08:	64fb      	str	r3, [r7, #76]	; 0x4c
 8016a0a:	e036      	b.n	8016a7a <_txe_thread_create+0x196>
        }

        /* Check the stack size.  */
        else if (stack_size < ((ULONG) TX_MINIMUM_STACK))
 8016a0c:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 8016a0e:	2bc7      	cmp	r3, #199	; 0xc7
 8016a10:	d802      	bhi.n	8016a18 <_txe_thread_create+0x134>
        {

            /* Stack is not big enough, return appropriate error code.  */
            status =  TX_SIZE_ERROR;
 8016a12:	2305      	movs	r3, #5
 8016a14:	64fb      	str	r3, [r7, #76]	; 0x4c
 8016a16:	e030      	b.n	8016a7a <_txe_thread_create+0x196>
        }

        /* Check the priority specified.  */
        else if (priority >= ((UINT) TX_MAX_PRIORITIES))
 8016a18:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 8016a1a:	2b1f      	cmp	r3, #31
 8016a1c:	d902      	bls.n	8016a24 <_txe_thread_create+0x140>
        {

            /* Invalid priority selected, return appropriate error code.  */
            status =  TX_PRIORITY_ERROR;
 8016a1e:	230f      	movs	r3, #15
 8016a20:	64fb      	str	r3, [r7, #76]	; 0x4c
 8016a22:	e02a      	b.n	8016a7a <_txe_thread_create+0x196>
        }

        /* Check preemption threshold. */
        else if (preempt_threshold > priority)
 8016a24:	6e7a      	ldr	r2, [r7, #100]	; 0x64
 8016a26:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 8016a28:	429a      	cmp	r2, r3
 8016a2a:	d902      	bls.n	8016a32 <_txe_thread_create+0x14e>
        {

            /* Invalid preempt threshold, return appropriate error code.  */
            status =  TX_THRESH_ERROR;
 8016a2c:	2318      	movs	r3, #24
 8016a2e:	64fb      	str	r3, [r7, #76]	; 0x4c
 8016a30:	e023      	b.n	8016a7a <_txe_thread_create+0x196>
        }

        /* Check the start selection.  */
        else if (auto_start > TX_AUTO_START)
 8016a32:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 8016a34:	2b01      	cmp	r3, #1
 8016a36:	d902      	bls.n	8016a3e <_txe_thread_create+0x15a>
        {

            /* Invalid auto start selection, return appropriate error code.  */
            status =  TX_START_ERROR;
 8016a38:	2310      	movs	r3, #16
 8016a3a:	64fb      	str	r3, [r7, #76]	; 0x4c
 8016a3c:	e01d      	b.n	8016a7a <_txe_thread_create+0x196>
        {

#ifndef TX_TIMER_PROCESS_IN_ISR

            /* Pickup thread pointer.  */
            TX_THREAD_GET_CURRENT(current_thread)
 8016a3e:	4b1f      	ldr	r3, [pc, #124]	; (8016abc <_txe_thread_create+0x1d8>)
 8016a40:	681b      	ldr	r3, [r3, #0]
 8016a42:	633b      	str	r3, [r7, #48]	; 0x30

            /* Check for invalid caller of this function.  First check for a calling thread.  */
            if (current_thread == &_tx_timer_thread)
 8016a44:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8016a46:	4a1e      	ldr	r2, [pc, #120]	; (8016ac0 <_txe_thread_create+0x1dc>)
 8016a48:	4293      	cmp	r3, r2
 8016a4a:	d101      	bne.n	8016a50 <_txe_thread_create+0x16c>
            {

                /* Invalid caller of this function, return appropriate error code.  */
                status =  TX_CALLER_ERROR;
 8016a4c:	2313      	movs	r3, #19
 8016a4e:	64fb      	str	r3, [r7, #76]	; 0x4c
    __asm__ volatile (" MRS  %0,IPSR ": "=r" (ipsr_value) );
 8016a50:	f3ef 8305 	mrs	r3, IPSR
 8016a54:	617b      	str	r3, [r7, #20]
    return(ipsr_value);
 8016a56:	697a      	ldr	r2, [r7, #20]
            }
#endif

            /* Check for interrupt call.  */
            if (TX_THREAD_GET_SYSTEM_STATE() != ((ULONG) 0))
 8016a58:	4b1a      	ldr	r3, [pc, #104]	; (8016ac4 <_txe_thread_create+0x1e0>)
 8016a5a:	681b      	ldr	r3, [r3, #0]
 8016a5c:	4313      	orrs	r3, r2
 8016a5e:	2b00      	cmp	r3, #0
 8016a60:	d00b      	beq.n	8016a7a <_txe_thread_create+0x196>
    __asm__ volatile (" MRS  %0,IPSR ": "=r" (ipsr_value) );
 8016a62:	f3ef 8305 	mrs	r3, IPSR
 8016a66:	613b      	str	r3, [r7, #16]
    return(ipsr_value);
 8016a68:	693a      	ldr	r2, [r7, #16]
            {
    
                /* Now, make sure the call is from an interrupt and not initialization.  */
                if (TX_THREAD_GET_SYSTEM_STATE() < TX_INITIALIZE_IN_PROGRESS)
 8016a6a:	4b16      	ldr	r3, [pc, #88]	; (8016ac4 <_txe_thread_create+0x1e0>)
 8016a6c:	681b      	ldr	r3, [r3, #0]
 8016a6e:	4313      	orrs	r3, r2
 8016a70:	f1b3 3ff0 	cmp.w	r3, #4042322160	; 0xf0f0f0f0
 8016a74:	d201      	bcs.n	8016a7a <_txe_thread_create+0x196>
                {
            
                    /* Invalid caller of this function, return appropriate error code.  */
                    status =  TX_CALLER_ERROR;
 8016a76:	2313      	movs	r3, #19
 8016a78:	64fb      	str	r3, [r7, #76]	; 0x4c
            }
        }
    }

    /* Determine if everything is okay.  */
    if (status == TX_SUCCESS)
 8016a7a:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8016a7c:	2b00      	cmp	r3, #0
 8016a7e:	d112      	bne.n	8016aa6 <_txe_thread_create+0x1c2>
    {

        /* Call actual thread create function.  */
        status =  _tx_thread_create(thread_ptr, name_ptr, entry_function, entry_input,
 8016a80:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 8016a82:	9305      	str	r3, [sp, #20]
 8016a84:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 8016a86:	9304      	str	r3, [sp, #16]
 8016a88:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 8016a8a:	9303      	str	r3, [sp, #12]
 8016a8c:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 8016a8e:	9302      	str	r3, [sp, #8]
 8016a90:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 8016a92:	9301      	str	r3, [sp, #4]
 8016a94:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 8016a96:	9300      	str	r3, [sp, #0]
 8016a98:	683b      	ldr	r3, [r7, #0]
 8016a9a:	687a      	ldr	r2, [r7, #4]
 8016a9c:	68b9      	ldr	r1, [r7, #8]
 8016a9e:	68f8      	ldr	r0, [r7, #12]
 8016aa0:	f7fd fd58 	bl	8014554 <_tx_thread_create>
 8016aa4:	64f8      	str	r0, [r7, #76]	; 0x4c
                        stack_start, stack_size, priority, preempt_threshold,
                        time_slice, auto_start);
    }

    /* Return completion status.  */
    return(status);
 8016aa6:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
}
 8016aa8:	4618      	mov	r0, r3
 8016aaa:	3750      	adds	r7, #80	; 0x50
 8016aac:	46bd      	mov	sp, r7
 8016aae:	bd80      	pop	{r7, pc}
 8016ab0:	24031c5c 	.word	0x24031c5c
 8016ab4:	24031bcc 	.word	0x24031bcc
 8016ab8:	24031bd0 	.word	0x24031bd0
 8016abc:	24031bc4 	.word	0x24031bc4
 8016ac0:	24031d0c 	.word	0x24031d0c
 8016ac4:	24000078 	.word	0x24000078

08016ac8 <_txe_thread_delete>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
UINT  _txe_thread_delete(TX_THREAD *thread_ptr)
{
 8016ac8:	b580      	push	{r7, lr}
 8016aca:	b084      	sub	sp, #16
 8016acc:	af00      	add	r7, sp, #0
 8016ace:	6078      	str	r0, [r7, #4]
    __asm__ volatile (" MRS  %0,IPSR ": "=r" (ipsr_value) );
 8016ad0:	f3ef 8305 	mrs	r3, IPSR
 8016ad4:	60bb      	str	r3, [r7, #8]
    return(ipsr_value);
 8016ad6:	68ba      	ldr	r2, [r7, #8]

UINT        status;


    /* Check for invalid caller of this function.  */
    if (TX_THREAD_GET_SYSTEM_STATE() != ((ULONG) 0))
 8016ad8:	4b0f      	ldr	r3, [pc, #60]	; (8016b18 <_txe_thread_delete+0x50>)
 8016ada:	681b      	ldr	r3, [r3, #0]
 8016adc:	4313      	orrs	r3, r2
 8016ade:	2b00      	cmp	r3, #0
 8016ae0:	d002      	beq.n	8016ae8 <_txe_thread_delete+0x20>
    {

        /* Invalid caller of this function, return appropriate error code.  */
        status =  TX_CALLER_ERROR;
 8016ae2:	2313      	movs	r3, #19
 8016ae4:	60fb      	str	r3, [r7, #12]
 8016ae6:	e011      	b.n	8016b0c <_txe_thread_delete+0x44>
    }

    /* Check for an invalid thread pointer.  */
    else if (thread_ptr == TX_NULL)
 8016ae8:	687b      	ldr	r3, [r7, #4]
 8016aea:	2b00      	cmp	r3, #0
 8016aec:	d102      	bne.n	8016af4 <_txe_thread_delete+0x2c>
    {

        /* Thread pointer is invalid, return appropriate error code.  */
        status =  TX_THREAD_ERROR;
 8016aee:	230e      	movs	r3, #14
 8016af0:	60fb      	str	r3, [r7, #12]
 8016af2:	e00b      	b.n	8016b0c <_txe_thread_delete+0x44>
    }

    /* Now check for invalid thread ID.  */
    else if (thread_ptr -> tx_thread_id != TX_THREAD_ID)
 8016af4:	687b      	ldr	r3, [r7, #4]
 8016af6:	681b      	ldr	r3, [r3, #0]
 8016af8:	4a08      	ldr	r2, [pc, #32]	; (8016b1c <_txe_thread_delete+0x54>)
 8016afa:	4293      	cmp	r3, r2
 8016afc:	d002      	beq.n	8016b04 <_txe_thread_delete+0x3c>
    {

        /* Thread pointer is invalid, return appropriate error code.  */
        status =  TX_THREAD_ERROR;
 8016afe:	230e      	movs	r3, #14
 8016b00:	60fb      	str	r3, [r7, #12]
 8016b02:	e003      	b.n	8016b0c <_txe_thread_delete+0x44>
    }
    else
    {

        /* Call actual thread delete function.  */
        status =  _tx_thread_delete(thread_ptr);
 8016b04:	6878      	ldr	r0, [r7, #4]
 8016b06:	f7fd fe1b 	bl	8014740 <_tx_thread_delete>
 8016b0a:	60f8      	str	r0, [r7, #12]
    }

    /* Return completion status.  */
    return(status);
 8016b0c:	68fb      	ldr	r3, [r7, #12]
}
 8016b0e:	4618      	mov	r0, r3
 8016b10:	3710      	adds	r7, #16
 8016b12:	46bd      	mov	sp, r7
 8016b14:	bd80      	pop	{r7, pc}
 8016b16:	bf00      	nop
 8016b18:	24000078 	.word	0x24000078
 8016b1c:	54485244 	.word	0x54485244

08016b20 <_txe_thread_relinquish>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
VOID  _txe_thread_relinquish(VOID)
{
 8016b20:	b580      	push	{r7, lr}
 8016b22:	b082      	sub	sp, #8
 8016b24:	af00      	add	r7, sp, #0

TX_THREAD   *current_thread;


    /* Pickup thread pointer.  */
    TX_THREAD_GET_CURRENT(current_thread)
 8016b26:	4b0a      	ldr	r3, [pc, #40]	; (8016b50 <_txe_thread_relinquish+0x30>)
 8016b28:	681b      	ldr	r3, [r3, #0]
 8016b2a:	607b      	str	r3, [r7, #4]

    /* Make sure a thread is executing.  */
    if (current_thread != TX_NULL)
 8016b2c:	687b      	ldr	r3, [r7, #4]
 8016b2e:	2b00      	cmp	r3, #0
 8016b30:	d00a      	beq.n	8016b48 <_txe_thread_relinquish+0x28>
    __asm__ volatile (" MRS  %0,IPSR ": "=r" (ipsr_value) );
 8016b32:	f3ef 8305 	mrs	r3, IPSR
 8016b36:	603b      	str	r3, [r7, #0]
    return(ipsr_value);
 8016b38:	683a      	ldr	r2, [r7, #0]
    {

        /* Now make sure the call is not from an ISR or Initialization.  */
        if (TX_THREAD_GET_SYSTEM_STATE() == ((ULONG) 0))
 8016b3a:	4b06      	ldr	r3, [pc, #24]	; (8016b54 <_txe_thread_relinquish+0x34>)
 8016b3c:	681b      	ldr	r3, [r3, #0]
 8016b3e:	4313      	orrs	r3, r2
 8016b40:	2b00      	cmp	r3, #0
 8016b42:	d101      	bne.n	8016b48 <_txe_thread_relinquish+0x28>
        {
        
            /* Okay to call the real relinquish function.  */
            _tx_thread_relinquish();
 8016b44:	f7fd ff24 	bl	8014990 <_tx_thread_relinquish>
        }
    }
}
 8016b48:	bf00      	nop
 8016b4a:	3708      	adds	r7, #8
 8016b4c:	46bd      	mov	sp, r7
 8016b4e:	bd80      	pop	{r7, pc}
 8016b50:	24031bc4 	.word	0x24031bc4
 8016b54:	24000078 	.word	0x24000078

08016b58 <_txe_thread_resume>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
UINT  _txe_thread_resume(TX_THREAD *thread_ptr)
{
 8016b58:	b580      	push	{r7, lr}
 8016b5a:	b084      	sub	sp, #16
 8016b5c:	af00      	add	r7, sp, #0
 8016b5e:	6078      	str	r0, [r7, #4]

UINT    status;


    /* Check for an invalid thread pointer.  */
    if (thread_ptr == TX_NULL)
 8016b60:	687b      	ldr	r3, [r7, #4]
 8016b62:	2b00      	cmp	r3, #0
 8016b64:	d102      	bne.n	8016b6c <_txe_thread_resume+0x14>
    {

        /* Thread pointer is invalid, return appropriate error code.  */
        status =  TX_THREAD_ERROR;
 8016b66:	230e      	movs	r3, #14
 8016b68:	60fb      	str	r3, [r7, #12]
 8016b6a:	e00b      	b.n	8016b84 <_txe_thread_resume+0x2c>
    }
    
    /* Now check for invalid thread ID.  */
    else if (thread_ptr -> tx_thread_id != TX_THREAD_ID)
 8016b6c:	687b      	ldr	r3, [r7, #4]
 8016b6e:	681b      	ldr	r3, [r3, #0]
 8016b70:	4a07      	ldr	r2, [pc, #28]	; (8016b90 <_txe_thread_resume+0x38>)
 8016b72:	4293      	cmp	r3, r2
 8016b74:	d002      	beq.n	8016b7c <_txe_thread_resume+0x24>
    {

        /* Thread pointer is invalid, return appropriate error code.  */
        status =  TX_THREAD_ERROR;
 8016b76:	230e      	movs	r3, #14
 8016b78:	60fb      	str	r3, [r7, #12]
 8016b7a:	e003      	b.n	8016b84 <_txe_thread_resume+0x2c>
    }
    else
    {

        /* Call actual thread resume function.  */
        status =  _tx_thread_resume(thread_ptr);
 8016b7c:	6878      	ldr	r0, [r7, #4]
 8016b7e:	f7fd ff6d 	bl	8014a5c <_tx_thread_resume>
 8016b82:	60f8      	str	r0, [r7, #12]
    }

    /* Return completion status.  */
    return(status);
 8016b84:	68fb      	ldr	r3, [r7, #12]
}
 8016b86:	4618      	mov	r0, r3
 8016b88:	3710      	adds	r7, #16
 8016b8a:	46bd      	mov	sp, r7
 8016b8c:	bd80      	pop	{r7, pc}
 8016b8e:	bf00      	nop
 8016b90:	54485244 	.word	0x54485244

08016b94 <_txe_thread_terminate>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
UINT  _txe_thread_terminate(TX_THREAD *thread_ptr)
{
 8016b94:	b580      	push	{r7, lr}
 8016b96:	b084      	sub	sp, #16
 8016b98:	af00      	add	r7, sp, #0
 8016b9a:	6078      	str	r0, [r7, #4]

UINT        status;


    /* Check for an invalid thread pointer.  */
    if (thread_ptr == TX_NULL)
 8016b9c:	687b      	ldr	r3, [r7, #4]
 8016b9e:	2b00      	cmp	r3, #0
 8016ba0:	d102      	bne.n	8016ba8 <_txe_thread_terminate+0x14>
    {

        /* Thread pointer is invalid, return appropriate error code.  */
        status =  TX_THREAD_ERROR;
 8016ba2:	230e      	movs	r3, #14
 8016ba4:	60fb      	str	r3, [r7, #12]
 8016ba6:	e017      	b.n	8016bd8 <_txe_thread_terminate+0x44>
    }
    
    /* Now check for invalid thread ID.  */
    else if (thread_ptr -> tx_thread_id != TX_THREAD_ID)
 8016ba8:	687b      	ldr	r3, [r7, #4]
 8016baa:	681b      	ldr	r3, [r3, #0]
 8016bac:	4a0d      	ldr	r2, [pc, #52]	; (8016be4 <_txe_thread_terminate+0x50>)
 8016bae:	4293      	cmp	r3, r2
 8016bb0:	d002      	beq.n	8016bb8 <_txe_thread_terminate+0x24>
    {

        /* Thread pointer is invalid, return appropriate error code.  */
        status =  TX_THREAD_ERROR;
 8016bb2:	230e      	movs	r3, #14
 8016bb4:	60fb      	str	r3, [r7, #12]
 8016bb6:	e00f      	b.n	8016bd8 <_txe_thread_terminate+0x44>
    __asm__ volatile (" MRS  %0,IPSR ": "=r" (ipsr_value) );
 8016bb8:	f3ef 8305 	mrs	r3, IPSR
 8016bbc:	60bb      	str	r3, [r7, #8]
    return(ipsr_value);
 8016bbe:	68ba      	ldr	r2, [r7, #8]
    }

    /* Check for invalid caller of this function.  */
    else if (TX_THREAD_GET_SYSTEM_STATE() != ((ULONG) 0))
 8016bc0:	4b09      	ldr	r3, [pc, #36]	; (8016be8 <_txe_thread_terminate+0x54>)
 8016bc2:	681b      	ldr	r3, [r3, #0]
 8016bc4:	4313      	orrs	r3, r2
 8016bc6:	2b00      	cmp	r3, #0
 8016bc8:	d002      	beq.n	8016bd0 <_txe_thread_terminate+0x3c>
    {

        /* Invalid caller of this function, return appropriate error code.  */
        status =  TX_CALLER_ERROR;
 8016bca:	2313      	movs	r3, #19
 8016bcc:	60fb      	str	r3, [r7, #12]
 8016bce:	e003      	b.n	8016bd8 <_txe_thread_terminate+0x44>
    }
    else
    {

        /* Call actual thread terminate function.  */
        status =  _tx_thread_terminate(thread_ptr);
 8016bd0:	6878      	ldr	r0, [r7, #4]
 8016bd2:	f7fe fac1 	bl	8015158 <_tx_thread_terminate>
 8016bd6:	60f8      	str	r0, [r7, #12]
    }

    /* Return completion status.  */
    return(status);
 8016bd8:	68fb      	ldr	r3, [r7, #12]
}
 8016bda:	4618      	mov	r0, r3
 8016bdc:	3710      	adds	r7, #16
 8016bde:	46bd      	mov	sp, r7
 8016be0:	bd80      	pop	{r7, pc}
 8016be2:	bf00      	nop
 8016be4:	54485244 	.word	0x54485244
 8016be8:	24000078 	.word	0x24000078

08016bec <_txe_timer_activate>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
UINT  _txe_timer_activate(TX_TIMER *timer_ptr)
{
 8016bec:	b580      	push	{r7, lr}
 8016bee:	b084      	sub	sp, #16
 8016bf0:	af00      	add	r7, sp, #0
 8016bf2:	6078      	str	r0, [r7, #4]

UINT    status;


    /* Check for an invalid timer pointer.  */
    if (timer_ptr == TX_NULL)
 8016bf4:	687b      	ldr	r3, [r7, #4]
 8016bf6:	2b00      	cmp	r3, #0
 8016bf8:	d102      	bne.n	8016c00 <_txe_timer_activate+0x14>
    {
        /* Timer pointer is invalid, return appropriate error code.  */
        status =  TX_TIMER_ERROR;
 8016bfa:	2315      	movs	r3, #21
 8016bfc:	60fb      	str	r3, [r7, #12]
 8016bfe:	e00b      	b.n	8016c18 <_txe_timer_activate+0x2c>
    }
    
    /* Now check for invalid timer ID.  */
    else if (timer_ptr -> tx_timer_id != TX_TIMER_ID)
 8016c00:	687b      	ldr	r3, [r7, #4]
 8016c02:	681b      	ldr	r3, [r3, #0]
 8016c04:	4a07      	ldr	r2, [pc, #28]	; (8016c24 <_txe_timer_activate+0x38>)
 8016c06:	4293      	cmp	r3, r2
 8016c08:	d002      	beq.n	8016c10 <_txe_timer_activate+0x24>
    {
        /* Timer pointer is invalid, return appropriate error code.  */
        status =  TX_TIMER_ERROR;
 8016c0a:	2315      	movs	r3, #21
 8016c0c:	60fb      	str	r3, [r7, #12]
 8016c0e:	e003      	b.n	8016c18 <_txe_timer_activate+0x2c>
    }
    else
    {

        /* Call actual application timer activate function.  */
        status =  _tx_timer_activate(timer_ptr);
 8016c10:	6878      	ldr	r0, [r7, #4]
 8016c12:	f7fe fcaf 	bl	8015574 <_tx_timer_activate>
 8016c16:	60f8      	str	r0, [r7, #12]
    }

    /* Return completion status.  */
    return(status);
 8016c18:	68fb      	ldr	r3, [r7, #12]
}
 8016c1a:	4618      	mov	r0, r3
 8016c1c:	3710      	adds	r7, #16
 8016c1e:	46bd      	mov	sp, r7
 8016c20:	bd80      	pop	{r7, pc}
 8016c22:	bf00      	nop
 8016c24:	4154494d 	.word	0x4154494d

08016c28 <_txe_timer_create>:
/*                                                                        */
/**************************************************************************/
UINT  _txe_timer_create(TX_TIMER *timer_ptr, CHAR *name_ptr, 
            VOID (*expiration_function)(ULONG id), ULONG expiration_input,
            ULONG initial_ticks, ULONG reschedule_ticks, UINT auto_activate, UINT timer_control_block_size)
{
 8016c28:	b580      	push	{r7, lr}
 8016c2a:	b096      	sub	sp, #88	; 0x58
 8016c2c:	af04      	add	r7, sp, #16
 8016c2e:	60f8      	str	r0, [r7, #12]
 8016c30:	60b9      	str	r1, [r7, #8]
 8016c32:	607a      	str	r2, [r7, #4]
 8016c34:	603b      	str	r3, [r7, #0]
TX_THREAD       *thread_ptr;
#endif


    /* Default status to success.  */
    status =  TX_SUCCESS;
 8016c36:	2300      	movs	r3, #0
 8016c38:	647b      	str	r3, [r7, #68]	; 0x44

    /* Check for a NULL timer pointer.  */
    if (timer_ptr == TX_NULL)
 8016c3a:	68fb      	ldr	r3, [r7, #12]
 8016c3c:	2b00      	cmp	r3, #0
 8016c3e:	d102      	bne.n	8016c46 <_txe_timer_create+0x1e>
    {

        /* Timer pointer is invalid, return appropriate error code.  */
        status =  TX_TIMER_ERROR;
 8016c40:	2315      	movs	r3, #21
 8016c42:	647b      	str	r3, [r7, #68]	; 0x44
 8016c44:	e059      	b.n	8016cfa <_txe_timer_create+0xd2>
    }
    
    /* Now check for invalid control block size.  */
    else if (timer_control_block_size != (sizeof(TX_TIMER)))
 8016c46:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 8016c48:	2b2c      	cmp	r3, #44	; 0x2c
 8016c4a:	d002      	beq.n	8016c52 <_txe_timer_create+0x2a>
    {

        /* Timer pointer is invalid, return appropriate error code.  */
        status =  TX_TIMER_ERROR;
 8016c4c:	2315      	movs	r3, #21
 8016c4e:	647b      	str	r3, [r7, #68]	; 0x44
 8016c50:	e053      	b.n	8016cfa <_txe_timer_create+0xd2>
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 8016c52:	f3ef 8310 	mrs	r3, PRIMASK
 8016c56:	62fb      	str	r3, [r7, #44]	; 0x2c
    return(posture);
 8016c58:	6afb      	ldr	r3, [r7, #44]	; 0x2c
    int_posture = __get_interrupt_posture();
 8016c5a:	62bb      	str	r3, [r7, #40]	; 0x28
    __asm__ volatile ("CPSID i" : : : "memory");
 8016c5c:	b672      	cpsid	i
    return(int_posture);
 8016c5e:	6abb      	ldr	r3, [r7, #40]	; 0x28
    }
    else
    {

        /* Disable interrupts.  */
        TX_DISABLE
 8016c60:	63bb      	str	r3, [r7, #56]	; 0x38

        /* Increment the preempt disable flag.  */
        _tx_thread_preempt_disable++;
 8016c62:	4b41      	ldr	r3, [pc, #260]	; (8016d68 <_txe_timer_create+0x140>)
 8016c64:	681b      	ldr	r3, [r3, #0]
 8016c66:	3301      	adds	r3, #1
 8016c68:	4a3f      	ldr	r2, [pc, #252]	; (8016d68 <_txe_timer_create+0x140>)
 8016c6a:	6013      	str	r3, [r2, #0]
 8016c6c:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8016c6e:	633b      	str	r3, [r7, #48]	; 0x30
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 8016c70:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8016c72:	f383 8810 	msr	PRIMASK, r3
}
 8016c76:	bf00      	nop

        /* Restore interrupts.  */
        TX_RESTORE

        /* Next see if it is already in the created list.  */
        next_timer =  _tx_timer_created_ptr;
 8016c78:	4b3c      	ldr	r3, [pc, #240]	; (8016d6c <_txe_timer_create+0x144>)
 8016c7a:	681b      	ldr	r3, [r3, #0]
 8016c7c:	63fb      	str	r3, [r7, #60]	; 0x3c
        for (i = ((ULONG) 0); i < _tx_timer_created_count; i++)
 8016c7e:	2300      	movs	r3, #0
 8016c80:	643b      	str	r3, [r7, #64]	; 0x40
 8016c82:	e009      	b.n	8016c98 <_txe_timer_create+0x70>
        {

            /* Determine if this timer matches the current timer in the list.  */
            if (timer_ptr == next_timer)
 8016c84:	68fa      	ldr	r2, [r7, #12]
 8016c86:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8016c88:	429a      	cmp	r2, r3
 8016c8a:	d00b      	beq.n	8016ca4 <_txe_timer_create+0x7c>
            }
            else
            {
        
                /* Move to next timer.  */
                next_timer =  next_timer -> tx_timer_created_next;
 8016c8c:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8016c8e:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8016c90:	63fb      	str	r3, [r7, #60]	; 0x3c
        for (i = ((ULONG) 0); i < _tx_timer_created_count; i++)
 8016c92:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8016c94:	3301      	adds	r3, #1
 8016c96:	643b      	str	r3, [r7, #64]	; 0x40
 8016c98:	4b35      	ldr	r3, [pc, #212]	; (8016d70 <_txe_timer_create+0x148>)
 8016c9a:	681b      	ldr	r3, [r3, #0]
 8016c9c:	6c3a      	ldr	r2, [r7, #64]	; 0x40
 8016c9e:	429a      	cmp	r2, r3
 8016ca0:	d3f0      	bcc.n	8016c84 <_txe_timer_create+0x5c>
 8016ca2:	e000      	b.n	8016ca6 <_txe_timer_create+0x7e>
                break;
 8016ca4:	bf00      	nop
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 8016ca6:	f3ef 8310 	mrs	r3, PRIMASK
 8016caa:	623b      	str	r3, [r7, #32]
    return(posture);
 8016cac:	6a3b      	ldr	r3, [r7, #32]
    int_posture = __get_interrupt_posture();
 8016cae:	61fb      	str	r3, [r7, #28]
    __asm__ volatile ("CPSID i" : : : "memory");
 8016cb0:	b672      	cpsid	i
    return(int_posture);
 8016cb2:	69fb      	ldr	r3, [r7, #28]
            }
        }

        /* Disable interrupts.  */
        TX_DISABLE
 8016cb4:	63bb      	str	r3, [r7, #56]	; 0x38

        /* Decrement the preempt disable flag.  */
        _tx_thread_preempt_disable--;
 8016cb6:	4b2c      	ldr	r3, [pc, #176]	; (8016d68 <_txe_timer_create+0x140>)
 8016cb8:	681b      	ldr	r3, [r3, #0]
 8016cba:	3b01      	subs	r3, #1
 8016cbc:	4a2a      	ldr	r2, [pc, #168]	; (8016d68 <_txe_timer_create+0x140>)
 8016cbe:	6013      	str	r3, [r2, #0]
 8016cc0:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8016cc2:	627b      	str	r3, [r7, #36]	; 0x24
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 8016cc4:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8016cc6:	f383 8810 	msr	PRIMASK, r3
}
 8016cca:	bf00      	nop
    
        /* Restore interrupts.  */
        TX_RESTORE

        /* Check for preemption.  */
        _tx_thread_system_preempt_check();
 8016ccc:	f7fd fff2 	bl	8014cb4 <_tx_thread_system_preempt_check>

        /* At this point, check to see if there is a duplicate timer.  */
        if (timer_ptr == next_timer)
 8016cd0:	68fa      	ldr	r2, [r7, #12]
 8016cd2:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8016cd4:	429a      	cmp	r2, r3
 8016cd6:	d102      	bne.n	8016cde <_txe_timer_create+0xb6>
        {

            /* Timer is already created, return appropriate error code.  */
            status =  TX_TIMER_ERROR;
 8016cd8:	2315      	movs	r3, #21
 8016cda:	647b      	str	r3, [r7, #68]	; 0x44
 8016cdc:	e00d      	b.n	8016cfa <_txe_timer_create+0xd2>
        }

        /* Check for an illegal initial tick value.  */
        else if (initial_ticks == ((ULONG) 0))
 8016cde:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 8016ce0:	2b00      	cmp	r3, #0
 8016ce2:	d102      	bne.n	8016cea <_txe_timer_create+0xc2>
        {

            /* Invalid initial tick value, return appropriate error code.  */
            status =  TX_TICK_ERROR;
 8016ce4:	2316      	movs	r3, #22
 8016ce6:	647b      	str	r3, [r7, #68]	; 0x44
 8016ce8:	e007      	b.n	8016cfa <_txe_timer_create+0xd2>
        }
        else
        {

            /* Check for an illegal activation.  */
            if (auto_activate != TX_AUTO_ACTIVATE)
 8016cea:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 8016cec:	2b01      	cmp	r3, #1
 8016cee:	d004      	beq.n	8016cfa <_txe_timer_create+0xd2>
            {
    
                /* And activation is not the other value.  */
                if (auto_activate != TX_NO_ACTIVATE)
 8016cf0:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 8016cf2:	2b00      	cmp	r3, #0
 8016cf4:	d001      	beq.n	8016cfa <_txe_timer_create+0xd2>
                {
        
                    /* Invalid activation selected, return appropriate error code.  */
                    status =  TX_ACTIVATE_ERROR;
 8016cf6:	2317      	movs	r3, #23
 8016cf8:	647b      	str	r3, [r7, #68]	; 0x44
            }
        }
    }

    /* Determine if everything is okay.  */
    if (status == TX_SUCCESS)
 8016cfa:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8016cfc:	2b00      	cmp	r3, #0
 8016cfe:	d11d      	bne.n	8016d3c <_txe_timer_create+0x114>
    {

#ifndef TX_TIMER_PROCESS_IN_ISR

        /* Pickup thread pointer.  */
        TX_THREAD_GET_CURRENT(thread_ptr)
 8016d00:	4b1c      	ldr	r3, [pc, #112]	; (8016d74 <_txe_timer_create+0x14c>)
 8016d02:	681b      	ldr	r3, [r3, #0]
 8016d04:	637b      	str	r3, [r7, #52]	; 0x34

        /* Check for invalid caller of this function.  First check for a calling thread.  */
        if (thread_ptr == &_tx_timer_thread)
 8016d06:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8016d08:	4a1b      	ldr	r2, [pc, #108]	; (8016d78 <_txe_timer_create+0x150>)
 8016d0a:	4293      	cmp	r3, r2
 8016d0c:	d101      	bne.n	8016d12 <_txe_timer_create+0xea>
        {

            /* Invalid caller of this function, return appropriate error code.  */
            status =  TX_CALLER_ERROR;
 8016d0e:	2313      	movs	r3, #19
 8016d10:	647b      	str	r3, [r7, #68]	; 0x44
    __asm__ volatile (" MRS  %0,IPSR ": "=r" (ipsr_value) );
 8016d12:	f3ef 8305 	mrs	r3, IPSR
 8016d16:	61bb      	str	r3, [r7, #24]
    return(ipsr_value);
 8016d18:	69ba      	ldr	r2, [r7, #24]
        }
#endif

        /* Check for interrupt call.  */
        if (TX_THREAD_GET_SYSTEM_STATE() != ((ULONG) 0))
 8016d1a:	4b18      	ldr	r3, [pc, #96]	; (8016d7c <_txe_timer_create+0x154>)
 8016d1c:	681b      	ldr	r3, [r3, #0]
 8016d1e:	4313      	orrs	r3, r2
 8016d20:	2b00      	cmp	r3, #0
 8016d22:	d00b      	beq.n	8016d3c <_txe_timer_create+0x114>
    __asm__ volatile (" MRS  %0,IPSR ": "=r" (ipsr_value) );
 8016d24:	f3ef 8305 	mrs	r3, IPSR
 8016d28:	617b      	str	r3, [r7, #20]
    return(ipsr_value);
 8016d2a:	697a      	ldr	r2, [r7, #20]
        {
    
            /* Now, make sure the call is from an interrupt and not initialization.  */
            if (TX_THREAD_GET_SYSTEM_STATE() < TX_INITIALIZE_IN_PROGRESS)
 8016d2c:	4b13      	ldr	r3, [pc, #76]	; (8016d7c <_txe_timer_create+0x154>)
 8016d2e:	681b      	ldr	r3, [r3, #0]
 8016d30:	4313      	orrs	r3, r2
 8016d32:	f1b3 3ff0 	cmp.w	r3, #4042322160	; 0xf0f0f0f0
 8016d36:	d201      	bcs.n	8016d3c <_txe_timer_create+0x114>
            {
        
                /* Invalid caller of this function, return appropriate error code.  */
                status =  TX_CALLER_ERROR;
 8016d38:	2313      	movs	r3, #19
 8016d3a:	647b      	str	r3, [r7, #68]	; 0x44
        }
    }


    /* Determine if everything is okay.  */
    if (status == TX_SUCCESS)
 8016d3c:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8016d3e:	2b00      	cmp	r3, #0
 8016d40:	d10c      	bne.n	8016d5c <_txe_timer_create+0x134>
    {

        /* Call actual application timer create function.  */
        status =  _tx_timer_create(timer_ptr, name_ptr, expiration_function, expiration_input,
 8016d42:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 8016d44:	9302      	str	r3, [sp, #8]
 8016d46:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 8016d48:	9301      	str	r3, [sp, #4]
 8016d4a:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 8016d4c:	9300      	str	r3, [sp, #0]
 8016d4e:	683b      	ldr	r3, [r7, #0]
 8016d50:	687a      	ldr	r2, [r7, #4]
 8016d52:	68b9      	ldr	r1, [r7, #8]
 8016d54:	68f8      	ldr	r0, [r7, #12]
 8016d56:	f7fe fc39 	bl	80155cc <_tx_timer_create>
 8016d5a:	6478      	str	r0, [r7, #68]	; 0x44
                                                    initial_ticks, reschedule_ticks, auto_activate);
    }

    /* Return completion status.  */
    return(status);
 8016d5c:	6c7b      	ldr	r3, [r7, #68]	; 0x44
}
 8016d5e:	4618      	mov	r0, r3
 8016d60:	3748      	adds	r7, #72	; 0x48
 8016d62:	46bd      	mov	sp, r7
 8016d64:	bd80      	pop	{r7, pc}
 8016d66:	bf00      	nop
 8016d68:	24031c5c 	.word	0x24031c5c
 8016d6c:	24031d00 	.word	0x24031d00
 8016d70:	24031d04 	.word	0x24031d04
 8016d74:	24031bc4 	.word	0x24031bc4
 8016d78:	24031d0c 	.word	0x24031d0c
 8016d7c:	24000078 	.word	0x24000078

08016d80 <_txe_timer_delete>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
UINT  _txe_timer_delete(TX_TIMER *timer_ptr)
{
 8016d80:	b580      	push	{r7, lr}
 8016d82:	b086      	sub	sp, #24
 8016d84:	af00      	add	r7, sp, #0
 8016d86:	6078      	str	r0, [r7, #4]


#ifndef TX_TIMER_PROCESS_IN_ISR

    /* Default status to success.  */
    status =  TX_SUCCESS;
 8016d88:	2300      	movs	r3, #0
 8016d8a:	617b      	str	r3, [r7, #20]
#endif
    
    /* Check for an invalid timer pointer.  */
    if (timer_ptr == TX_NULL)
 8016d8c:	687b      	ldr	r3, [r7, #4]
 8016d8e:	2b00      	cmp	r3, #0
 8016d90:	d102      	bne.n	8016d98 <_txe_timer_delete+0x18>
    {
        /* Timer pointer is invalid, return appropriate error code.  */
        status =  TX_TIMER_ERROR;
 8016d92:	2315      	movs	r3, #21
 8016d94:	617b      	str	r3, [r7, #20]
 8016d96:	e023      	b.n	8016de0 <_txe_timer_delete+0x60>
    }
    
    /* Now check for invalid timer ID.  */
    else if (timer_ptr -> tx_timer_id != TX_TIMER_ID)
 8016d98:	687b      	ldr	r3, [r7, #4]
 8016d9a:	681b      	ldr	r3, [r3, #0]
 8016d9c:	4a13      	ldr	r2, [pc, #76]	; (8016dec <_txe_timer_delete+0x6c>)
 8016d9e:	4293      	cmp	r3, r2
 8016da0:	d002      	beq.n	8016da8 <_txe_timer_delete+0x28>
    {
        /* Timer pointer is invalid, return appropriate error code.  */
        status =  TX_TIMER_ERROR;
 8016da2:	2315      	movs	r3, #21
 8016da4:	617b      	str	r3, [r7, #20]
 8016da6:	e01b      	b.n	8016de0 <_txe_timer_delete+0x60>
    __asm__ volatile (" MRS  %0,IPSR ": "=r" (ipsr_value) );
 8016da8:	f3ef 8305 	mrs	r3, IPSR
 8016dac:	60fb      	str	r3, [r7, #12]
    return(ipsr_value);
 8016dae:	68fa      	ldr	r2, [r7, #12]
    }

    /* Check for invalid caller of this function.  */

    /* Is the caller an ISR or Initialization?  */
    else if (TX_THREAD_GET_SYSTEM_STATE() != ((ULONG) 0))
 8016db0:	4b0f      	ldr	r3, [pc, #60]	; (8016df0 <_txe_timer_delete+0x70>)
 8016db2:	681b      	ldr	r3, [r3, #0]
 8016db4:	4313      	orrs	r3, r2
 8016db6:	2b00      	cmp	r3, #0
 8016db8:	d002      	beq.n	8016dc0 <_txe_timer_delete+0x40>
    {

        /* Invalid caller of this function, return appropriate error code.  */
        status =  TX_CALLER_ERROR;
 8016dba:	2313      	movs	r3, #19
 8016dbc:	617b      	str	r3, [r7, #20]
 8016dbe:	e00f      	b.n	8016de0 <_txe_timer_delete+0x60>
    {

#ifndef TX_TIMER_PROCESS_IN_ISR

        /* Pickup thread pointer.  */
        TX_THREAD_GET_CURRENT(thread_ptr)
 8016dc0:	4b0c      	ldr	r3, [pc, #48]	; (8016df4 <_txe_timer_delete+0x74>)
 8016dc2:	681b      	ldr	r3, [r3, #0]
 8016dc4:	613b      	str	r3, [r7, #16]

        /* Is the caller the system timer thread?  */
        if (thread_ptr == &_tx_timer_thread)
 8016dc6:	693b      	ldr	r3, [r7, #16]
 8016dc8:	4a0b      	ldr	r2, [pc, #44]	; (8016df8 <_txe_timer_delete+0x78>)
 8016dca:	4293      	cmp	r3, r2
 8016dcc:	d101      	bne.n	8016dd2 <_txe_timer_delete+0x52>
        {
        
            /* Invalid caller of this function, return appropriate error code.  */
            status =  TX_CALLER_ERROR;
 8016dce:	2313      	movs	r3, #19
 8016dd0:	617b      	str	r3, [r7, #20]
        }

        /* Determine if everything is okay.  */
        if (status == TX_SUCCESS)
 8016dd2:	697b      	ldr	r3, [r7, #20]
 8016dd4:	2b00      	cmp	r3, #0
 8016dd6:	d103      	bne.n	8016de0 <_txe_timer_delete+0x60>
        {
#endif

            /* Call actual application timer delete function.  */
            status =  _tx_timer_delete(timer_ptr);
 8016dd8:	6878      	ldr	r0, [r7, #4]
 8016dda:	f7fe fc5b 	bl	8015694 <_tx_timer_delete>
 8016dde:	6178      	str	r0, [r7, #20]
        }
#endif
    }

    /* Return completion status.  */
    return(status);
 8016de0:	697b      	ldr	r3, [r7, #20]
}
 8016de2:	4618      	mov	r0, r3
 8016de4:	3718      	adds	r7, #24
 8016de6:	46bd      	mov	sp, r7
 8016de8:	bd80      	pop	{r7, pc}
 8016dea:	bf00      	nop
 8016dec:	4154494d 	.word	0x4154494d
 8016df0:	24000078 	.word	0x24000078
 8016df4:	24031bc4 	.word	0x24031bc4
 8016df8:	24031d0c 	.word	0x24031d0c

08016dfc <MX_NetXDuo_Init>:
  * @brief  Application NetXDuo Initialization.
  * @param memory_ptr: memory pointer
  * @retval int
  */
UINT MX_NetXDuo_Init(VOID *memory_ptr)
{
 8016dfc:	b580      	push	{r7, lr}
 8016dfe:	b08c      	sub	sp, #48	; 0x30
 8016e00:	af08      	add	r7, sp, #32
 8016e02:	6078      	str	r0, [r7, #4]
  UINT ret = NX_SUCCESS;
 8016e04:	2300      	movs	r3, #0
 8016e06:	60fb      	str	r3, [r7, #12]
  TX_BYTE_POOL *byte_pool = (TX_BYTE_POOL*)memory_ptr;
 8016e08:	687b      	ldr	r3, [r7, #4]
 8016e0a:	60bb      	str	r3, [r7, #8]
  (void)byte_pool;
  /* USER CODE END MX_NetXDuo_MEM_POOL */

  /* USER CODE BEGIN MX_NetXDuo_Init */
  /* Allocate the memory for packet_pool.  */
   if (tx_byte_allocate(byte_pool, (VOID **) &pointer,  NX_PACKET_POOL_SIZE, TX_NO_WAIT) != TX_SUCCESS)
 8016e0c:	2300      	movs	r3, #0
 8016e0e:	f643 6230 	movw	r2, #15920	; 0x3e30
 8016e12:	4961      	ldr	r1, [pc, #388]	; (8016f98 <MX_NetXDuo_Init+0x19c>)
 8016e14:	68b8      	ldr	r0, [r7, #8]
 8016e16:	f7fe febb 	bl	8015b90 <_txe_byte_allocate>
 8016e1a:	4603      	mov	r3, r0
 8016e1c:	2b00      	cmp	r3, #0
 8016e1e:	d001      	beq.n	8016e24 <MX_NetXDuo_Init+0x28>
   {
     return TX_POOL_ERROR;
 8016e20:	2302      	movs	r3, #2
 8016e22:	e0b4      	b.n	8016f8e <MX_NetXDuo_Init+0x192>
   }

   /* Create the Packet pool to be used for packet allocation */
   ret = nx_packet_pool_create(&AppPool, "Main Packet Pool", PAYLOAD_SIZE, pointer, NX_PACKET_POOL_SIZE);
 8016e24:	4b5c      	ldr	r3, [pc, #368]	; (8016f98 <MX_NetXDuo_Init+0x19c>)
 8016e26:	681b      	ldr	r3, [r3, #0]
 8016e28:	223c      	movs	r2, #60	; 0x3c
 8016e2a:	9201      	str	r2, [sp, #4]
 8016e2c:	f643 6230 	movw	r2, #15920	; 0x3e30
 8016e30:	9200      	str	r2, [sp, #0]
 8016e32:	f44f 62c0 	mov.w	r2, #1536	; 0x600
 8016e36:	4959      	ldr	r1, [pc, #356]	; (8016f9c <MX_NetXDuo_Init+0x1a0>)
 8016e38:	4859      	ldr	r0, [pc, #356]	; (8016fa0 <MX_NetXDuo_Init+0x1a4>)
 8016e3a:	f7fa fb71 	bl	8011520 <_nxe_packet_pool_create>
 8016e3e:	60f8      	str	r0, [r7, #12]

   if (ret != NX_SUCCESS)
 8016e40:	68fb      	ldr	r3, [r7, #12]
 8016e42:	2b00      	cmp	r3, #0
 8016e44:	d001      	beq.n	8016e4a <MX_NetXDuo_Init+0x4e>
   {
     return NX_NOT_ENABLED;
 8016e46:	2314      	movs	r3, #20
 8016e48:	e0a1      	b.n	8016f8e <MX_NetXDuo_Init+0x192>
   }

   /* Allocate the memory for Ip_Instance */
   if (tx_byte_allocate(byte_pool, (VOID **) &pointer,   2 * DEFAULT_MEMORY_SIZE, TX_NO_WAIT) != TX_SUCCESS)
 8016e4a:	2300      	movs	r3, #0
 8016e4c:	f44f 6200 	mov.w	r2, #2048	; 0x800
 8016e50:	4951      	ldr	r1, [pc, #324]	; (8016f98 <MX_NetXDuo_Init+0x19c>)
 8016e52:	68b8      	ldr	r0, [r7, #8]
 8016e54:	f7fe fe9c 	bl	8015b90 <_txe_byte_allocate>
 8016e58:	4603      	mov	r3, r0
 8016e5a:	2b00      	cmp	r3, #0
 8016e5c:	d001      	beq.n	8016e62 <MX_NetXDuo_Init+0x66>
   {
     return TX_POOL_ERROR;
 8016e5e:	2302      	movs	r3, #2
 8016e60:	e095      	b.n	8016f8e <MX_NetXDuo_Init+0x192>
   }

   /* Create the main NX_IP instance */
   ret = nx_ip_create(&IpInstance, SOFTAP_INTERFACE, NULL_ADDRESS, NULL_ADDRESS, &AppPool,nx_stm32_custom_driver,
 8016e62:	4b4d      	ldr	r3, [pc, #308]	; (8016f98 <MX_NetXDuo_Init+0x19c>)
 8016e64:	681b      	ldr	r3, [r3, #0]
 8016e66:	f640 02a4 	movw	r2, #2212	; 0x8a4
 8016e6a:	9205      	str	r2, [sp, #20]
 8016e6c:	220a      	movs	r2, #10
 8016e6e:	9204      	str	r2, [sp, #16]
 8016e70:	f44f 6200 	mov.w	r2, #2048	; 0x800
 8016e74:	9203      	str	r2, [sp, #12]
 8016e76:	9302      	str	r3, [sp, #8]
 8016e78:	4b4a      	ldr	r3, [pc, #296]	; (8016fa4 <MX_NetXDuo_Init+0x1a8>)
 8016e7a:	9301      	str	r3, [sp, #4]
 8016e7c:	4b48      	ldr	r3, [pc, #288]	; (8016fa0 <MX_NetXDuo_Init+0x1a4>)
 8016e7e:	9300      	str	r3, [sp, #0]
 8016e80:	2300      	movs	r3, #0
 8016e82:	2200      	movs	r2, #0
 8016e84:	4948      	ldr	r1, [pc, #288]	; (8016fa8 <MX_NetXDuo_Init+0x1ac>)
 8016e86:	4849      	ldr	r0, [pc, #292]	; (8016fac <MX_NetXDuo_Init+0x1b0>)
 8016e88:	f7fa fa38 	bl	80112fc <_nxe_ip_create>
 8016e8c:	60f8      	str	r0, [r7, #12]
                      pointer, 2 * DEFAULT_MEMORY_SIZE, DEFAULT_PRIORITY);

   if (ret != NX_SUCCESS)
 8016e8e:	68fb      	ldr	r3, [r7, #12]
 8016e90:	2b00      	cmp	r3, #0
 8016e92:	d001      	beq.n	8016e98 <MX_NetXDuo_Init+0x9c>
   {
     return NX_NOT_ENABLED;
 8016e94:	2314      	movs	r3, #20
 8016e96:	e07a      	b.n	8016f8e <MX_NetXDuo_Init+0x192>
   }

   /* Allocate the memory for ARP */
   if (tx_byte_allocate(byte_pool, (VOID **) &pointer, DEFAULT_MEMORY_SIZE, TX_NO_WAIT) != TX_SUCCESS)
 8016e98:	2300      	movs	r3, #0
 8016e9a:	f44f 6280 	mov.w	r2, #1024	; 0x400
 8016e9e:	493e      	ldr	r1, [pc, #248]	; (8016f98 <MX_NetXDuo_Init+0x19c>)
 8016ea0:	68b8      	ldr	r0, [r7, #8]
 8016ea2:	f7fe fe75 	bl	8015b90 <_txe_byte_allocate>
 8016ea6:	4603      	mov	r3, r0
 8016ea8:	2b00      	cmp	r3, #0
 8016eaa:	d001      	beq.n	8016eb0 <MX_NetXDuo_Init+0xb4>
   {
     return TX_POOL_ERROR;
 8016eac:	2302      	movs	r3, #2
 8016eae:	e06e      	b.n	8016f8e <MX_NetXDuo_Init+0x192>
   }

   /*  Enable the ARP protocol and provide the ARP cache size for the IP instance */
   ret = nx_arp_enable(&IpInstance, (VOID *)pointer, DEFAULT_MEMORY_SIZE);
 8016eb0:	4b39      	ldr	r3, [pc, #228]	; (8016f98 <MX_NetXDuo_Init+0x19c>)
 8016eb2:	681b      	ldr	r3, [r3, #0]
 8016eb4:	f44f 6280 	mov.w	r2, #1024	; 0x400
 8016eb8:	4619      	mov	r1, r3
 8016eba:	483c      	ldr	r0, [pc, #240]	; (8016fac <MX_NetXDuo_Init+0x1b0>)
 8016ebc:	f7fa f910 	bl	80110e0 <_nxe_arp_enable>
 8016ec0:	60f8      	str	r0, [r7, #12]

   if (ret != NX_SUCCESS)
 8016ec2:	68fb      	ldr	r3, [r7, #12]
 8016ec4:	2b00      	cmp	r3, #0
 8016ec6:	d001      	beq.n	8016ecc <MX_NetXDuo_Init+0xd0>
   {
     return NX_NOT_ENABLED;
 8016ec8:	2314      	movs	r3, #20
 8016eca:	e060      	b.n	8016f8e <MX_NetXDuo_Init+0x192>
   }

   /* Enable the ICMP */
    ret = nx_icmp_enable(&IpInstance);
 8016ecc:	4837      	ldr	r0, [pc, #220]	; (8016fac <MX_NetXDuo_Init+0x1b0>)
 8016ece:	f7fa f953 	bl	8011178 <_nxe_icmp_enable>
 8016ed2:	60f8      	str	r0, [r7, #12]

    if (ret != NX_SUCCESS)
 8016ed4:	68fb      	ldr	r3, [r7, #12]
 8016ed6:	2b00      	cmp	r3, #0
 8016ed8:	d001      	beq.n	8016ede <MX_NetXDuo_Init+0xe2>
    {
      return NX_NOT_ENABLED;
 8016eda:	2314      	movs	r3, #20
 8016edc:	e057      	b.n	8016f8e <MX_NetXDuo_Init+0x192>
    }

    /* Enable the UDP protocol required for  DHCP communication */
    ret = nx_udp_enable(&IpInstance);
 8016ede:	4833      	ldr	r0, [pc, #204]	; (8016fac <MX_NetXDuo_Init+0x1b0>)
 8016ee0:	f7fa fc58 	bl	8011794 <_nxe_udp_enable>
 8016ee4:	60f8      	str	r0, [r7, #12]

    if (ret != NX_SUCCESS)
 8016ee6:	68fb      	ldr	r3, [r7, #12]
 8016ee8:	2b00      	cmp	r3, #0
 8016eea:	d001      	beq.n	8016ef0 <MX_NetXDuo_Init+0xf4>
    {
      return NX_NOT_ENABLED;
 8016eec:	2314      	movs	r3, #20
 8016eee:	e04e      	b.n	8016f8e <MX_NetXDuo_Init+0x192>
    }

    /* Enable the TCP protocol */
    ret = nx_tcp_enable(&IpInstance);
 8016ef0:	482e      	ldr	r0, [pc, #184]	; (8016fac <MX_NetXDuo_Init+0x1b0>)
 8016ef2:	f7fa fc17 	bl	8011724 <_nxe_tcp_enable>
 8016ef6:	60f8      	str	r0, [r7, #12]

    if (ret != NX_SUCCESS)
 8016ef8:	68fb      	ldr	r3, [r7, #12]
 8016efa:	2b00      	cmp	r3, #0
 8016efc:	d001      	beq.n	8016f02 <MX_NetXDuo_Init+0x106>
    {
      return NX_NOT_ENABLED;
 8016efe:	2314      	movs	r3, #20
 8016f00:	e045      	b.n	8016f8e <MX_NetXDuo_Init+0x192>
    }

    /* Allocate the memory for main thread   */
    if (tx_byte_allocate(byte_pool, (VOID **) &pointer,2 *  DEFAULT_MEMORY_SIZE, TX_NO_WAIT) != TX_SUCCESS)
 8016f02:	2300      	movs	r3, #0
 8016f04:	f44f 6200 	mov.w	r2, #2048	; 0x800
 8016f08:	4923      	ldr	r1, [pc, #140]	; (8016f98 <MX_NetXDuo_Init+0x19c>)
 8016f0a:	68b8      	ldr	r0, [r7, #8]
 8016f0c:	f7fe fe40 	bl	8015b90 <_txe_byte_allocate>
 8016f10:	4603      	mov	r3, r0
 8016f12:	2b00      	cmp	r3, #0
 8016f14:	d001      	beq.n	8016f1a <MX_NetXDuo_Init+0x11e>
    {
      return TX_POOL_ERROR;
 8016f16:	2302      	movs	r3, #2
 8016f18:	e039      	b.n	8016f8e <MX_NetXDuo_Init+0x192>
    }

   /* Allocate the memory for main thread   */
    if (tx_byte_allocate(byte_pool, (VOID **) &pointer,2 *  DEFAULT_MEMORY_SIZE, TX_NO_WAIT) != TX_SUCCESS)
 8016f1a:	2300      	movs	r3, #0
 8016f1c:	f44f 6200 	mov.w	r2, #2048	; 0x800
 8016f20:	491d      	ldr	r1, [pc, #116]	; (8016f98 <MX_NetXDuo_Init+0x19c>)
 8016f22:	68b8      	ldr	r0, [r7, #8]
 8016f24:	f7fe fe34 	bl	8015b90 <_txe_byte_allocate>
 8016f28:	4603      	mov	r3, r0
 8016f2a:	2b00      	cmp	r3, #0
 8016f2c:	d001      	beq.n	8016f32 <MX_NetXDuo_Init+0x136>
    {
      return TX_POOL_ERROR;
 8016f2e:	2302      	movs	r3, #2
 8016f30:	e02d      	b.n	8016f8e <MX_NetXDuo_Init+0x192>
    }

    /* Create the main thread */
    ret = tx_thread_create(&AppMainThread, "App Main thread", App_Main_Thread_Entry, 0, pointer, 2 * DEFAULT_MEMORY_SIZE,
 8016f32:	4b19      	ldr	r3, [pc, #100]	; (8016f98 <MX_NetXDuo_Init+0x19c>)
 8016f34:	681b      	ldr	r3, [r3, #0]
 8016f36:	22b4      	movs	r2, #180	; 0xb4
 8016f38:	9206      	str	r2, [sp, #24]
 8016f3a:	2201      	movs	r2, #1
 8016f3c:	9205      	str	r2, [sp, #20]
 8016f3e:	2200      	movs	r2, #0
 8016f40:	9204      	str	r2, [sp, #16]
 8016f42:	220a      	movs	r2, #10
 8016f44:	9203      	str	r2, [sp, #12]
 8016f46:	220a      	movs	r2, #10
 8016f48:	9202      	str	r2, [sp, #8]
 8016f4a:	f44f 6200 	mov.w	r2, #2048	; 0x800
 8016f4e:	9201      	str	r2, [sp, #4]
 8016f50:	9300      	str	r3, [sp, #0]
 8016f52:	2300      	movs	r3, #0
 8016f54:	4a16      	ldr	r2, [pc, #88]	; (8016fb0 <MX_NetXDuo_Init+0x1b4>)
 8016f56:	4917      	ldr	r1, [pc, #92]	; (8016fb4 <MX_NetXDuo_Init+0x1b8>)
 8016f58:	4817      	ldr	r0, [pc, #92]	; (8016fb8 <MX_NetXDuo_Init+0x1bc>)
 8016f5a:	f7ff fcc3 	bl	80168e4 <_txe_thread_create>
 8016f5e:	60f8      	str	r0, [r7, #12]
                           DEFAULT_PRIORITY, DEFAULT_PRIORITY, TX_NO_TIME_SLICE, TX_AUTO_START);

    if (ret != TX_SUCCESS)
 8016f60:	68fb      	ldr	r3, [r7, #12]
 8016f62:	2b00      	cmp	r3, #0
 8016f64:	d001      	beq.n	8016f6a <MX_NetXDuo_Init+0x16e>
    {
      return NX_NOT_ENABLED;
 8016f66:	2314      	movs	r3, #20
 8016f68:	e011      	b.n	8016f8e <MX_NetXDuo_Init+0x192>
      return NX_NOT_ENABLED;
    }
#endif

    /* create the DHCP client */
    ret = nx_dhcp_create(&DHCPClient, &IpInstance, "DHCP Client");
 8016f6a:	4a14      	ldr	r2, [pc, #80]	; (8016fbc <MX_NetXDuo_Init+0x1c0>)
 8016f6c:	490f      	ldr	r1, [pc, #60]	; (8016fac <MX_NetXDuo_Init+0x1b0>)
 8016f6e:	4814      	ldr	r0, [pc, #80]	; (8016fc0 <MX_NetXDuo_Init+0x1c4>)
 8016f70:	f7ef fc20 	bl	80067b4 <_nxe_dhcp_create>
 8016f74:	60f8      	str	r0, [r7, #12]

    if (ret != NX_SUCCESS)
 8016f76:	68fb      	ldr	r3, [r7, #12]
 8016f78:	2b00      	cmp	r3, #0
 8016f7a:	d001      	beq.n	8016f80 <MX_NetXDuo_Init+0x184>
    {
      return NX_NOT_ENABLED;
 8016f7c:	2314      	movs	r3, #20
 8016f7e:	e006      	b.n	8016f8e <MX_NetXDuo_Init+0x192>
    }

    /* set DHCP notification callback  */

    tx_semaphore_create(&Semaphore, "App Semaphore", 0);
 8016f80:	231c      	movs	r3, #28
 8016f82:	2200      	movs	r2, #0
 8016f84:	490f      	ldr	r1, [pc, #60]	; (8016fc4 <MX_NetXDuo_Init+0x1c8>)
 8016f86:	4810      	ldr	r0, [pc, #64]	; (8016fc8 <MX_NetXDuo_Init+0x1cc>)
 8016f88:	f7ff fb78 	bl	801667c <_txe_semaphore_create>
  /* USER CODE END MX_NetXDuo_Init */

  return ret;
 8016f8c:	68fb      	ldr	r3, [r7, #12]
}
 8016f8e:	4618      	mov	r0, r3
 8016f90:	3710      	adds	r7, #16
 8016f92:	46bd      	mov	sp, r7
 8016f94:	bd80      	pop	{r7, pc}
 8016f96:	bf00      	nop
 8016f98:	24034ad4 	.word	0x24034ad4
 8016f9c:	08021e80 	.word	0x08021e80
 8016fa0:	240322a0 	.word	0x240322a0
 8016fa4:	08017069 	.word	0x08017069
 8016fa8:	08021e94 	.word	0x08021e94
 8016fac:	240322e4 	.word	0x240322e4
 8016fb0:	08016fcd 	.word	0x08016fcd
 8016fb4:	08021ea0 	.word	0x08021ea0
 8016fb8:	240321d0 	.word	0x240321d0
 8016fbc:	08021eb0 	.word	0x08021eb0
 8016fc0:	24032b88 	.word	0x24032b88
 8016fc4:	08021ebc 	.word	0x08021ebc
 8016fc8:	24032284 	.word	0x24032284

08016fcc <App_Main_Thread_Entry>:
* @brief  Main thread entry.
* @param thread_input: ULONG user argument used by the thread entry
* @retval none
*/
static VOID App_Main_Thread_Entry(ULONG thread_input)
{
 8016fcc:	b580      	push	{r7, lr}
 8016fce:	b084      	sub	sp, #16
 8016fd0:	af00      	add	r7, sp, #0
 8016fd2:	6078      	str	r0, [r7, #4]
  UINT ret;

  ret = nx_ip_address_change_notify(&IpInstance, ip_address_change_notify_callback, NULL);
 8016fd4:	2200      	movs	r2, #0
 8016fd6:	4917      	ldr	r1, [pc, #92]	; (8017034 <App_Main_Thread_Entry+0x68>)
 8016fd8:	4817      	ldr	r0, [pc, #92]	; (8017038 <App_Main_Thread_Entry+0x6c>)
 8016fda:	f7fa f90d 	bl	80111f8 <_nxe_ip_address_change_notify>
 8016fde:	60f8      	str	r0, [r7, #12]
  if (ret != NX_SUCCESS)
 8016fe0:	68fb      	ldr	r3, [r7, #12]
 8016fe2:	2b00      	cmp	r3, #0
 8016fe4:	d001      	beq.n	8016fea <App_Main_Thread_Entry+0x1e>
  {
    Error_Handler();
 8016fe6:	f7e9 ff61 	bl	8000eac <Error_Handler>
  }

  ret = nx_dhcp_start(&DHCPClient);
 8016fea:	4814      	ldr	r0, [pc, #80]	; (801703c <App_Main_Thread_Entry+0x70>)
 8016fec:	f7ef fdb4 	bl	8006b58 <_nxe_dhcp_start>
 8016ff0:	60f8      	str	r0, [r7, #12]
  if (ret != NX_SUCCESS)
 8016ff2:	68fb      	ldr	r3, [r7, #12]
 8016ff4:	2b00      	cmp	r3, #0
 8016ff6:	d001      	beq.n	8016ffc <App_Main_Thread_Entry+0x30>
  {
    Error_Handler();
 8016ff8:	f7e9 ff58 	bl	8000eac <Error_Handler>
  }

  /* wait until an IP address is ready */
  if(tx_semaphore_get(&Semaphore, TX_WAIT_FOREVER) != TX_SUCCESS)
 8016ffc:	f04f 31ff 	mov.w	r1, #4294967295
 8017000:	480f      	ldr	r0, [pc, #60]	; (8017040 <App_Main_Thread_Entry+0x74>)
 8017002:	f7ff fc0f 	bl	8016824 <_txe_semaphore_get>
 8017006:	4603      	mov	r3, r0
 8017008:	2b00      	cmp	r3, #0
 801700a:	d001      	beq.n	8017010 <App_Main_Thread_Entry+0x44>
  {
    Error_Handler();
 801700c:	f7e9 ff4e 	bl	8000eac <Error_Handler>
  }

  ret = nx_ip_address_get(&IpInstance, &IpAddress, &NetMask);
 8017010:	4a0c      	ldr	r2, [pc, #48]	; (8017044 <App_Main_Thread_Entry+0x78>)
 8017012:	490d      	ldr	r1, [pc, #52]	; (8017048 <App_Main_Thread_Entry+0x7c>)
 8017014:	4808      	ldr	r0, [pc, #32]	; (8017038 <App_Main_Thread_Entry+0x6c>)
 8017016:	f7fa f92d 	bl	8011274 <_nxe_ip_address_get>
 801701a:	60f8      	str	r0, [r7, #12]

  if (ret != TX_SUCCESS)
 801701c:	68fb      	ldr	r3, [r7, #12]
 801701e:	2b00      	cmp	r3, #0
 8017020:	d001      	beq.n	8017026 <App_Main_Thread_Entry+0x5a>
  {
    Error_Handler();
 8017022:	f7e9 ff43 	bl	8000eac <Error_Handler>
  /* the network is correctly initialized, start the TCP server thread */
#if 0
  tx_thread_resume(&AppTCPThread);
#endif
  /* this thread is not needed any more, relinquish it */
  tx_thread_relinquish();
 8017026:	f7ff fd7b 	bl	8016b20 <_txe_thread_relinquish>

  return;
 801702a:	bf00      	nop
}
 801702c:	3710      	adds	r7, #16
 801702e:	46bd      	mov	sp, r7
 8017030:	bd80      	pop	{r7, pc}
 8017032:	bf00      	nop
 8017034:	0801704d 	.word	0x0801704d
 8017038:	240322e4 	.word	0x240322e4
 801703c:	24032b88 	.word	0x24032b88
 8017040:	24032284 	.word	0x24032284
 8017044:	240322e0 	.word	0x240322e0
 8017048:	240322dc 	.word	0x240322dc

0801704c <ip_address_change_notify_callback>:
* @param ip_instance: NX_IP instance registered for this callback.
* @param ptr: VOID* user data pointer
* @retval none
*/
static VOID ip_address_change_notify_callback(NX_IP *ip_instance, VOID *ptr)
{
 801704c:	b580      	push	{r7, lr}
 801704e:	b082      	sub	sp, #8
 8017050:	af00      	add	r7, sp, #0
 8017052:	6078      	str	r0, [r7, #4]
 8017054:	6039      	str	r1, [r7, #0]
  tx_semaphore_put(&Semaphore);
 8017056:	4803      	ldr	r0, [pc, #12]	; (8017064 <ip_address_change_notify_callback+0x18>)
 8017058:	f7ff fc26 	bl	80168a8 <_txe_semaphore_put>
}
 801705c:	bf00      	nop
 801705e:	3708      	adds	r7, #8
 8017060:	46bd      	mov	sp, r7
 8017062:	bd80      	pop	{r7, pc}
 8017064:	24032284 	.word	0x24032284

08017068 <nx_stm32_custom_driver>:
/* USER CODE END PFP */



VOID  nx_stm32_custom_driver(NX_IP_DRIVER *driver_req_ptr)
{
 8017068:	b580      	push	{r7, lr}
 801706a:	b08c      	sub	sp, #48	; 0x30
 801706c:	af00      	add	r7, sp, #0
 801706e:	6078      	str	r0, [r7, #4]
	/* USER CODE BEGIN 1 */
	UINT          i = 0;
 8017070:	2300      	movs	r3, #0
 8017072:	62bb      	str	r3, [r7, #40]	; 0x28
	ULONG        *ethernet_frame_ptr;
	NX_INTERFACE *interface_ptr;
	UINT          interface_index;

	/* Setup the IP pointer from the driver request.  */
	    ip_ptr =  driver_req_ptr -> nx_ip_driver_ptr;
 8017074:	687b      	ldr	r3, [r7, #4]
 8017076:	699b      	ldr	r3, [r3, #24]
 8017078:	627b      	str	r3, [r7, #36]	; 0x24

	    /* Default to successful return.  */
	    driver_req_ptr -> nx_ip_driver_status =  NX_SUCCESS;
 801707a:	687b      	ldr	r3, [r7, #4]
 801707c:	2200      	movs	r2, #0
 801707e:	605a      	str	r2, [r3, #4]

	    /* Setup interface pointer.  */
	    interface_ptr = driver_req_ptr -> nx_ip_driver_interface;
 8017080:	687b      	ldr	r3, [r7, #4]
 8017082:	69db      	ldr	r3, [r3, #28]
 8017084:	623b      	str	r3, [r7, #32]

	    /* Obtain the index number of the network interface. */
	    interface_index = interface_ptr -> nx_interface_index;
 8017086:	6a3b      	ldr	r3, [r7, #32]
 8017088:	79db      	ldrb	r3, [r3, #7]
 801708a:	61fb      	str	r3, [r7, #28]
	/* USER CODE END 1 */
    /* Process according to the driver request type in the IP control
       block.  */
    switch (driver_req_ptr -> nx_ip_driver_command)
 801708c:	687b      	ldr	r3, [r7, #4]
 801708e:	681b      	ldr	r3, [r3, #0]
 8017090:	2b13      	cmp	r3, #19
 8017092:	f200 81b0 	bhi.w	80173f6 <nx_stm32_custom_driver+0x38e>
 8017096:	a201      	add	r2, pc, #4	; (adr r2, 801709c <nx_stm32_custom_driver+0x34>)
 8017098:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 801709c:	08017277 	.word	0x08017277
 80170a0:	0801717d 	.word	0x0801717d
 80170a4:	08017183 	.word	0x08017183
 80170a8:	0801726d 	.word	0x0801726d
 80170ac:	08017401 	.word	0x08017401
 80170b0:	08017401 	.word	0x08017401
 80170b4:	08017401 	.word	0x08017401
 80170b8:	08017401 	.word	0x08017401
 80170bc:	080173d9 	.word	0x080173d9
 80170c0:	080173e3 	.word	0x080173e3
 80170c4:	080173ed 	.word	0x080173ed
 80170c8:	080173f7 	.word	0x080173f7
 80170cc:	080173f7 	.word	0x080173f7
 80170d0:	080173f7 	.word	0x080173f7
 80170d4:	080173f7 	.word	0x080173f7
 80170d8:	080173f7 	.word	0x080173f7
 80170dc:	080173f7 	.word	0x080173f7
 80170e0:	080173f7 	.word	0x080173f7
 80170e4:	08017401 	.word	0x08017401
 80170e8:	080170ed 	.word	0x080170ed
    {

    case NX_LINK_INTERFACE_ATTACH:
    /* USER CODE BEGIN NX_LINK_INTERFACE_ATTACH */
    	reset_slave();
 80170ec:	f005 fa2c 	bl	801c548 <reset_slave>
		/* Find an available driver instance to attach the interface. */
		for (int i = 0; i < MAX_INTERFACES; i++) {
 80170f0:	2300      	movs	r3, #0
 80170f2:	62fb      	str	r3, [r7, #44]	; 0x2c
 80170f4:	e00c      	b.n	8017110 <nx_stm32_custom_driver+0xa8>
			if (nx_wifi_driver[i].nx_network_driver_in_use == 0) {
 80170f6:	498e      	ldr	r1, [pc, #568]	; (8017330 <nx_stm32_custom_driver+0x2c8>)
 80170f8:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 80170fa:	4613      	mov	r3, r2
 80170fc:	00db      	lsls	r3, r3, #3
 80170fe:	1a9b      	subs	r3, r3, r2
 8017100:	009b      	lsls	r3, r3, #2
 8017102:	440b      	add	r3, r1
 8017104:	681b      	ldr	r3, [r3, #0]
 8017106:	2b00      	cmp	r3, #0
 8017108:	d006      	beq.n	8017118 <nx_stm32_custom_driver+0xb0>
		for (int i = 0; i < MAX_INTERFACES; i++) {
 801710a:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 801710c:	3301      	adds	r3, #1
 801710e:	62fb      	str	r3, [r7, #44]	; 0x2c
 8017110:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8017112:	2b01      	cmp	r3, #1
 8017114:	ddef      	ble.n	80170f6 <nx_stm32_custom_driver+0x8e>
 8017116:	e000      	b.n	801711a <nx_stm32_custom_driver+0xb2>
				break;
 8017118:	bf00      	nop
			}

		}

		if (i >= MAX_INTERFACES) {
 801711a:	6abb      	ldr	r3, [r7, #40]	; 0x28
 801711c:	2b01      	cmp	r3, #1
 801711e:	d903      	bls.n	8017128 <nx_stm32_custom_driver+0xc0>
			driver_req_ptr->nx_ip_driver_status = NX_INVALID_INTERFACE;
 8017120:	687b      	ldr	r3, [r7, #4]
 8017122:	224c      	movs	r2, #76	; 0x4c
 8017124:	605a      	str	r2, [r3, #4]


		}

    /* USER CODE END NX_LINK_INTERFACE_ATTACH */
        break;
 8017126:	e16e      	b.n	8017406 <nx_stm32_custom_driver+0x39e>
			nx_wifi_driver[i].nx_interface_ptr = driver_req_ptr->nx_ip_driver_interface;
 8017128:	687b      	ldr	r3, [r7, #4]
 801712a:	69d9      	ldr	r1, [r3, #28]
 801712c:	4880      	ldr	r0, [pc, #512]	; (8017330 <nx_stm32_custom_driver+0x2c8>)
 801712e:	6aba      	ldr	r2, [r7, #40]	; 0x28
 8017130:	4613      	mov	r3, r2
 8017132:	00db      	lsls	r3, r3, #3
 8017134:	1a9b      	subs	r3, r3, r2
 8017136:	009b      	lsls	r3, r3, #2
 8017138:	4403      	add	r3, r0
 801713a:	3308      	adds	r3, #8
 801713c:	6019      	str	r1, [r3, #0]
			nx_wifi_driver[i].nx_driver_ip_ptr = driver_req_ptr->nx_ip_driver_ptr;
 801713e:	687b      	ldr	r3, [r7, #4]
 8017140:	6999      	ldr	r1, [r3, #24]
 8017142:	487b      	ldr	r0, [pc, #492]	; (8017330 <nx_stm32_custom_driver+0x2c8>)
 8017144:	6aba      	ldr	r2, [r7, #40]	; 0x28
 8017146:	4613      	mov	r3, r2
 8017148:	00db      	lsls	r3, r3, #3
 801714a:	1a9b      	subs	r3, r3, r2
 801714c:	009b      	lsls	r3, r3, #2
 801714e:	4403      	add	r3, r0
 8017150:	330c      	adds	r3, #12
 8017152:	6019      	str	r1, [r3, #0]
			nx_wifi_driver[i].nx_network_driver_in_use = 1;
 8017154:	4976      	ldr	r1, [pc, #472]	; (8017330 <nx_stm32_custom_driver+0x2c8>)
 8017156:	6aba      	ldr	r2, [r7, #40]	; 0x28
 8017158:	4613      	mov	r3, r2
 801715a:	00db      	lsls	r3, r3, #3
 801715c:	1a9b      	subs	r3, r3, r2
 801715e:	009b      	lsls	r3, r3, #2
 8017160:	440b      	add	r3, r1
 8017162:	2201      	movs	r2, #1
 8017164:	601a      	str	r2, [r3, #0]
			nx_wifi_driver[i].nx_driver_id = i;
 8017166:	4972      	ldr	r1, [pc, #456]	; (8017330 <nx_stm32_custom_driver+0x2c8>)
 8017168:	6aba      	ldr	r2, [r7, #40]	; 0x28
 801716a:	4613      	mov	r3, r2
 801716c:	00db      	lsls	r3, r3, #3
 801716e:	1a9b      	subs	r3, r3, r2
 8017170:	009b      	lsls	r3, r3, #2
 8017172:	440b      	add	r3, r1
 8017174:	3304      	adds	r3, #4
 8017176:	6aba      	ldr	r2, [r7, #40]	; 0x28
 8017178:	601a      	str	r2, [r3, #0]
        break;
 801717a:	e144      	b.n	8017406 <nx_stm32_custom_driver+0x39e>
		/* For this simulated RAM driver, the MAC address is constructed by
		 incrementing a base lsw value, to simulate multiple nodes on the
		 ethernet.  */
		/* TODO - Check if the below function syntax is correct */

		network_init();
 801717c:	f007 f876 	bl	801e26c <network_init>


    /* USER CODE END NX_LINK_INITIALIZE */
        break;
 8017180:	e141      	b.n	8017406 <nx_stm32_custom_driver+0x39e>

    case NX_LINK_ENABLE:
    /* USER CODE BEGIN NX_LINK_ENABLE */
    	stm_spi_init(spi_driver_event_handler);
 8017182:	486c      	ldr	r0, [pc, #432]	; (8017334 <nx_stm32_custom_driver+0x2cc>)
 8017184:	f007 fdfc 	bl	801ed80 <stm_spi_init>
		if (strncmp(driver_req_ptr->nx_ip_driver_ptr->nx_ip_name, SOFTAP_INTERFACE,
 8017188:	687b      	ldr	r3, [r7, #4]
 801718a:	699b      	ldr	r3, [r3, #24]
 801718c:	685b      	ldr	r3, [r3, #4]
 801718e:	496a      	ldr	r1, [pc, #424]	; (8017338 <nx_stm32_custom_driver+0x2d0>)
 8017190:	4618      	mov	r0, r3
 8017192:	f7e9 f9c1 	bl	8000518 <strcmp>
 8017196:	4603      	mov	r3, r0
 8017198:	2b00      	cmp	r3, #0
 801719a:	d113      	bne.n	80171c4 <nx_stm32_custom_driver+0x15c>
				sizeof(SOFTAP_INTERFACE)) == 0) {
			nx_wifi_driver[i].interface_handle = network_open(SOFTAP_INTERFACE, softap_callback);
 801719c:	4967      	ldr	r1, [pc, #412]	; (801733c <nx_stm32_custom_driver+0x2d4>)
 801719e:	4866      	ldr	r0, [pc, #408]	; (8017338 <nx_stm32_custom_driver+0x2d0>)
 80171a0:	f007 f86c 	bl	801e27c <network_open>
 80171a4:	4601      	mov	r1, r0
 80171a6:	4862      	ldr	r0, [pc, #392]	; (8017330 <nx_stm32_custom_driver+0x2c8>)
 80171a8:	6aba      	ldr	r2, [r7, #40]	; 0x28
 80171aa:	4613      	mov	r3, r2
 80171ac:	00db      	lsls	r3, r3, #3
 80171ae:	1a9b      	subs	r3, r3, r2
 80171b0:	009b      	lsls	r3, r3, #2
 80171b2:	4403      	add	r3, r0
 80171b4:	3318      	adds	r3, #24
 80171b6:	6019      	str	r1, [r3, #0]
			mac_address = get_self_mac_softap();
 80171b8:	f005 fc1c 	bl	801c9f4 <get_self_mac_softap>
 80171bc:	4603      	mov	r3, r0
 80171be:	4a60      	ldr	r2, [pc, #384]	; (8017340 <nx_stm32_custom_driver+0x2d8>)
 80171c0:	6013      	str	r3, [r2, #0]
 80171c2:	e021      	b.n	8017208 <nx_stm32_custom_driver+0x1a0>

		} else if (strncmp(driver_req_ptr->nx_ip_driver_ptr->nx_ip_name, STA_INTERFACE,
 80171c4:	687b      	ldr	r3, [r7, #4]
 80171c6:	699b      	ldr	r3, [r3, #24]
 80171c8:	685b      	ldr	r3, [r3, #4]
 80171ca:	495e      	ldr	r1, [pc, #376]	; (8017344 <nx_stm32_custom_driver+0x2dc>)
 80171cc:	4618      	mov	r0, r3
 80171ce:	f7e9 f9a3 	bl	8000518 <strcmp>
 80171d2:	4603      	mov	r3, r0
 80171d4:	2b00      	cmp	r3, #0
 80171d6:	d113      	bne.n	8017200 <nx_stm32_custom_driver+0x198>
				sizeof(STA_INTERFACE)) == 0) {
			nx_wifi_driver[i].interface_handle = network_open(STA_INTERFACE, station_callback);
 80171d8:	495b      	ldr	r1, [pc, #364]	; (8017348 <nx_stm32_custom_driver+0x2e0>)
 80171da:	485a      	ldr	r0, [pc, #360]	; (8017344 <nx_stm32_custom_driver+0x2dc>)
 80171dc:	f007 f84e 	bl	801e27c <network_open>
 80171e0:	4601      	mov	r1, r0
 80171e2:	4853      	ldr	r0, [pc, #332]	; (8017330 <nx_stm32_custom_driver+0x2c8>)
 80171e4:	6aba      	ldr	r2, [r7, #40]	; 0x28
 80171e6:	4613      	mov	r3, r2
 80171e8:	00db      	lsls	r3, r3, #3
 80171ea:	1a9b      	subs	r3, r3, r2
 80171ec:	009b      	lsls	r3, r3, #2
 80171ee:	4403      	add	r3, r0
 80171f0:	3318      	adds	r3, #24
 80171f2:	6019      	str	r1, [r3, #0]
			mac_address = get_self_mac_station();
 80171f4:	f005 fbf4 	bl	801c9e0 <get_self_mac_station>
 80171f8:	4603      	mov	r3, r0
 80171fa:	4a51      	ldr	r2, [pc, #324]	; (8017340 <nx_stm32_custom_driver+0x2d8>)
 80171fc:	6013      	str	r3, [r2, #0]
 80171fe:	e003      	b.n	8017208 <nx_stm32_custom_driver+0x1a0>

		} else {
			driver_req_ptr->nx_ip_driver_status = NX_INVALID_INTERFACE;
 8017200:	687b      	ldr	r3, [r7, #4]
 8017202:	224c      	movs	r2, #76	; 0x4c
 8017204:	605a      	str	r2, [r3, #4]
 8017206:	e0fe      	b.n	8017406 <nx_stm32_custom_driver+0x39e>
			return;
		}

		driver_req_ptr->nx_ip_driver_interface->nx_interface_physical_address_lsw =
				(ULONG) ((mac_address[0] << 8) | (mac_address[1]));
 8017208:	4b4d      	ldr	r3, [pc, #308]	; (8017340 <nx_stm32_custom_driver+0x2d8>)
 801720a:	681b      	ldr	r3, [r3, #0]
 801720c:	781b      	ldrb	r3, [r3, #0]
 801720e:	021b      	lsls	r3, r3, #8
 8017210:	4a4b      	ldr	r2, [pc, #300]	; (8017340 <nx_stm32_custom_driver+0x2d8>)
 8017212:	6812      	ldr	r2, [r2, #0]
 8017214:	3201      	adds	r2, #1
 8017216:	7812      	ldrb	r2, [r2, #0]
 8017218:	431a      	orrs	r2, r3
		driver_req_ptr->nx_ip_driver_interface->nx_interface_physical_address_lsw =
 801721a:	687b      	ldr	r3, [r7, #4]
 801721c:	69db      	ldr	r3, [r3, #28]
 801721e:	611a      	str	r2, [r3, #16]
		driver_req_ptr->nx_ip_driver_interface->nx_interface_physical_address_msw =
				(ULONG) ((mac_address[2] << 24) | (mac_address[3] << 16)
 8017220:	4b47      	ldr	r3, [pc, #284]	; (8017340 <nx_stm32_custom_driver+0x2d8>)
 8017222:	681b      	ldr	r3, [r3, #0]
 8017224:	3302      	adds	r3, #2
 8017226:	781b      	ldrb	r3, [r3, #0]
 8017228:	061a      	lsls	r2, r3, #24
 801722a:	4b45      	ldr	r3, [pc, #276]	; (8017340 <nx_stm32_custom_driver+0x2d8>)
 801722c:	681b      	ldr	r3, [r3, #0]
 801722e:	3303      	adds	r3, #3
 8017230:	781b      	ldrb	r3, [r3, #0]
 8017232:	041b      	lsls	r3, r3, #16
 8017234:	431a      	orrs	r2, r3
						| (mac_address[4] << 8) | (mac_address[5]));
 8017236:	4b42      	ldr	r3, [pc, #264]	; (8017340 <nx_stm32_custom_driver+0x2d8>)
 8017238:	681b      	ldr	r3, [r3, #0]
 801723a:	3304      	adds	r3, #4
 801723c:	781b      	ldrb	r3, [r3, #0]
 801723e:	021b      	lsls	r3, r3, #8
 8017240:	4313      	orrs	r3, r2
 8017242:	4a3f      	ldr	r2, [pc, #252]	; (8017340 <nx_stm32_custom_driver+0x2d8>)
 8017244:	6812      	ldr	r2, [r2, #0]
 8017246:	3205      	adds	r2, #5
 8017248:	7812      	ldrb	r2, [r2, #0]
 801724a:	431a      	orrs	r2, r3
		driver_req_ptr->nx_ip_driver_interface->nx_interface_physical_address_msw =
 801724c:	687b      	ldr	r3, [r7, #4]
 801724e:	69db      	ldr	r3, [r3, #28]
 8017250:	60da      	str	r2, [r3, #12]

		/* Indicate to the IP software that IP to physical mapping is required.  */
				nx_ip_interface_address_mapping_configure(driver_req_ptr->nx_ip_driver_ptr, nx_wifi_driver->nx_driver_id,
 8017252:	687b      	ldr	r3, [r7, #4]
 8017254:	699b      	ldr	r3, [r3, #24]
 8017256:	4a36      	ldr	r2, [pc, #216]	; (8017330 <nx_stm32_custom_driver+0x2c8>)
 8017258:	6851      	ldr	r1, [r2, #4]
 801725a:	2201      	movs	r2, #1
 801725c:	4618      	mov	r0, r3
 801725e:	f7fa f91d 	bl	801149c <_nxe_ip_interface_address_mapping_configure>
				NX_TRUE);
		/* In the RAM driver, just set the enabled flag.  */

		driver_req_ptr->nx_ip_driver_interface->nx_interface_link_up = NX_TRUE;
 8017262:	687b      	ldr	r3, [r7, #4]
 8017264:	69db      	ldr	r3, [r3, #28]
 8017266:	2201      	movs	r2, #1
 8017268:	719a      	strb	r2, [r3, #6]

    /* USER CODE END NX_LINK_ENABLE */
        break;
 801726a:	e0cc      	b.n	8017406 <nx_stm32_custom_driver+0x39e>

    case NX_LINK_DISABLE:
    /* USER CODE BEGIN NX_LINK_DISABLE */

		/* In the RAM driver, just clear the enabled flag.  */
		driver_req_ptr->nx_ip_driver_interface->nx_interface_link_up = NX_FALSE;
 801726c:	687b      	ldr	r3, [r7, #4]
 801726e:	69db      	ldr	r3, [r3, #28]
 8017270:	2200      	movs	r2, #0
 8017272:	719a      	strb	r2, [r3, #6]
    /* USER CODE END NX_LINK_DISABLE */
        break;
 8017274:	e0c7      	b.n	8017406 <nx_stm32_custom_driver+0x39e>

		 The following sequence illustrates this process.
		 */

		/* Place the ethernet frame at the front of the packet.  */
		packet_ptr = driver_req_ptr->nx_ip_driver_packet;
 8017276:	687b      	ldr	r3, [r7, #4]
 8017278:	691b      	ldr	r3, [r3, #16]
 801727a:	61bb      	str	r3, [r7, #24]

		/* Adjust the prepend pointer.  */
		packet_ptr->nx_packet_prepend_ptr = packet_ptr->nx_packet_prepend_ptr
 801727c:	69bb      	ldr	r3, [r7, #24]
 801727e:	689b      	ldr	r3, [r3, #8]
				- NX_ETHERNET_SIZE;
 8017280:	f1a3 020e 	sub.w	r2, r3, #14
		packet_ptr->nx_packet_prepend_ptr = packet_ptr->nx_packet_prepend_ptr
 8017284:	69bb      	ldr	r3, [r7, #24]
 8017286:	609a      	str	r2, [r3, #8]

		/* Adjust the packet length.  */
		packet_ptr->nx_packet_length = packet_ptr->nx_packet_length
 8017288:	69bb      	ldr	r3, [r7, #24]
 801728a:	6a5b      	ldr	r3, [r3, #36]	; 0x24
				+ NX_ETHERNET_SIZE;
 801728c:	f103 020e 	add.w	r2, r3, #14
		packet_ptr->nx_packet_length = packet_ptr->nx_packet_length
 8017290:	69bb      	ldr	r3, [r7, #24]
 8017292:	625a      	str	r2, [r3, #36]	; 0x24

		/* Setup the ethernet frame pointer to build the ethernet frame.  Backup another 2
		 bytes to get 32-bit word alignment.  */
		/*lint -e{927} -e{826} suppress cast of pointer to pointer, since it is necessary  */
		ethernet_frame_ptr = (ULONG*) (packet_ptr->nx_packet_prepend_ptr - 2);
 8017294:	69bb      	ldr	r3, [r7, #24]
 8017296:	689b      	ldr	r3, [r3, #8]
 8017298:	3b02      	subs	r3, #2
 801729a:	617b      	str	r3, [r7, #20]

		/* Build the ethernet frame.  */
		*ethernet_frame_ptr = driver_req_ptr->nx_ip_driver_physical_address_msw;
 801729c:	687b      	ldr	r3, [r7, #4]
 801729e:	689a      	ldr	r2, [r3, #8]
 80172a0:	697b      	ldr	r3, [r7, #20]
 80172a2:	601a      	str	r2, [r3, #0]
		*(ethernet_frame_ptr + 1) =
 80172a4:	697b      	ldr	r3, [r7, #20]
 80172a6:	3304      	adds	r3, #4
				driver_req_ptr->nx_ip_driver_physical_address_lsw;
 80172a8:	687a      	ldr	r2, [r7, #4]
 80172aa:	68d2      	ldr	r2, [r2, #12]
		*(ethernet_frame_ptr + 1) =
 80172ac:	601a      	str	r2, [r3, #0]
		*(ethernet_frame_ptr + 2) =
				(driver_req_ptr->nx_ip_driver_interface->nx_interface_physical_address_msw << 16)
 80172ae:	687b      	ldr	r3, [r7, #4]
 80172b0:	69db      	ldr	r3, [r3, #28]
 80172b2:	68db      	ldr	r3, [r3, #12]
 80172b4:	0419      	lsls	r1, r3, #16
						| (driver_req_ptr->nx_ip_driver_interface->nx_interface_physical_address_lsw
 80172b6:	687b      	ldr	r3, [r7, #4]
 80172b8:	69db      	ldr	r3, [r3, #28]
 80172ba:	691b      	ldr	r3, [r3, #16]
								>> 16);
 80172bc:	0c1a      	lsrs	r2, r3, #16
		*(ethernet_frame_ptr + 2) =
 80172be:	697b      	ldr	r3, [r7, #20]
 80172c0:	3308      	adds	r3, #8
						| (driver_req_ptr->nx_ip_driver_interface->nx_interface_physical_address_lsw
 80172c2:	430a      	orrs	r2, r1
		*(ethernet_frame_ptr + 2) =
 80172c4:	601a      	str	r2, [r3, #0]
		*(ethernet_frame_ptr + 3) =
				(driver_req_ptr->nx_ip_driver_interface->nx_interface_physical_address_lsw << 16);
 80172c6:	687b      	ldr	r3, [r7, #4]
 80172c8:	69db      	ldr	r3, [r3, #28]
 80172ca:	691a      	ldr	r2, [r3, #16]
		*(ethernet_frame_ptr + 3) =
 80172cc:	697b      	ldr	r3, [r7, #20]
 80172ce:	330c      	adds	r3, #12
				(driver_req_ptr->nx_ip_driver_interface->nx_interface_physical_address_lsw << 16);
 80172d0:	0412      	lsls	r2, r2, #16
		*(ethernet_frame_ptr + 3) =
 80172d2:	601a      	str	r2, [r3, #0]

		if (driver_req_ptr->nx_ip_driver_command == NX_LINK_ARP_SEND) {
 80172d4:	687b      	ldr	r3, [r7, #4]
 80172d6:	681b      	ldr	r3, [r3, #0]
 80172d8:	2b05      	cmp	r3, #5
 80172da:	d10a      	bne.n	80172f2 <nx_stm32_custom_driver+0x28a>
			*(ethernet_frame_ptr + 3) |= NX_ETHERNET_ARP;
 80172dc:	697b      	ldr	r3, [r7, #20]
 80172de:	330c      	adds	r3, #12
 80172e0:	6819      	ldr	r1, [r3, #0]
 80172e2:	697b      	ldr	r3, [r7, #20]
 80172e4:	f103 020c 	add.w	r2, r3, #12
 80172e8:	f640 0306 	movw	r3, #2054	; 0x806
 80172ec:	430b      	orrs	r3, r1
 80172ee:	6013      	str	r3, [r2, #0]
 80172f0:	e039      	b.n	8017366 <nx_stm32_custom_driver+0x2fe>
		} else if (driver_req_ptr->nx_ip_driver_command
 80172f2:	687b      	ldr	r3, [r7, #4]
 80172f4:	681b      	ldr	r3, [r3, #0]
 80172f6:	2b06      	cmp	r3, #6
 80172f8:	d10a      	bne.n	8017310 <nx_stm32_custom_driver+0x2a8>
				== NX_LINK_ARP_RESPONSE_SEND) {
			*(ethernet_frame_ptr + 3) |= NX_ETHERNET_ARP;
 80172fa:	697b      	ldr	r3, [r7, #20]
 80172fc:	330c      	adds	r3, #12
 80172fe:	6819      	ldr	r1, [r3, #0]
 8017300:	697b      	ldr	r3, [r7, #20]
 8017302:	f103 020c 	add.w	r2, r3, #12
 8017306:	f640 0306 	movw	r3, #2054	; 0x806
 801730a:	430b      	orrs	r3, r1
 801730c:	6013      	str	r3, [r2, #0]
 801730e:	e02a      	b.n	8017366 <nx_stm32_custom_driver+0x2fe>
		} else if (driver_req_ptr->nx_ip_driver_command == NX_LINK_RARP_SEND) {
 8017310:	687b      	ldr	r3, [r7, #4]
 8017312:	681b      	ldr	r3, [r3, #0]
 8017314:	2b07      	cmp	r3, #7
 8017316:	d119      	bne.n	801734c <nx_stm32_custom_driver+0x2e4>
			*(ethernet_frame_ptr + 3) |= NX_ETHERNET_RARP;
 8017318:	697b      	ldr	r3, [r7, #20]
 801731a:	330c      	adds	r3, #12
 801731c:	6819      	ldr	r1, [r3, #0]
 801731e:	697b      	ldr	r3, [r7, #20]
 8017320:	f103 020c 	add.w	r2, r3, #12
 8017324:	f248 0335 	movw	r3, #32821	; 0x8035
 8017328:	430b      	orrs	r3, r1
 801732a:	6013      	str	r3, [r2, #0]
 801732c:	e01b      	b.n	8017366 <nx_stm32_custom_driver+0x2fe>
 801732e:	bf00      	nop
 8017330:	24034adc 	.word	0x24034adc
 8017334:	0801c611 	.word	0x0801c611
 8017338:	08021ecc 	.word	0x08021ecc
 801733c:	080174f5 	.word	0x080174f5
 8017340:	24034ad8 	.word	0x24034ad8
 8017344:	08021ed8 	.word	0x08021ed8
 8017348:	08017411 	.word	0x08017411
		} else if (packet_ptr->nx_packet_ip_version == 4) {
 801734c:	69bb      	ldr	r3, [r7, #24]
 801734e:	f893 302c 	ldrb.w	r3, [r3, #44]	; 0x2c
 8017352:	2b04      	cmp	r3, #4
 8017354:	d107      	bne.n	8017366 <nx_stm32_custom_driver+0x2fe>
			*(ethernet_frame_ptr + 3) |= NX_ETHERNET_IP;
 8017356:	697b      	ldr	r3, [r7, #20]
 8017358:	330c      	adds	r3, #12
 801735a:	681a      	ldr	r2, [r3, #0]
 801735c:	697b      	ldr	r3, [r7, #20]
 801735e:	330c      	adds	r3, #12
 8017360:	f442 6200 	orr.w	r2, r2, #2048	; 0x800
 8017364:	601a      	str	r2, [r3, #0]
		else {
			*(ethernet_frame_ptr + 3) |= NX_ETHERNET_IPV6;
		}
		*/
		struct pbuf buffer;
		buffer.len = (packet_ptr->nx_packet_append_ptr - packet_ptr->nx_packet_prepend_ptr);
 8017366:	69bb      	ldr	r3, [r7, #24]
 8017368:	68da      	ldr	r2, [r3, #12]
 801736a:	69bb      	ldr	r3, [r7, #24]
 801736c:	689b      	ldr	r3, [r3, #8]
 801736e:	1ad3      	subs	r3, r2, r3
 8017370:	b29b      	uxth	r3, r3
 8017372:	823b      	strh	r3, [r7, #16]
		buffer.payload = (uint8_t *)ethernet_frame_ptr;
 8017374:	697b      	ldr	r3, [r7, #20]
 8017376:	60fb      	str	r3, [r7, #12]

		/* Endian swapping if NX_LITTLE_ENDIAN is defined.  */
		NX_CHANGE_ULONG_ENDIAN(*(ethernet_frame_ptr));
 8017378:	697b      	ldr	r3, [r7, #20]
 801737a:	681b      	ldr	r3, [r3, #0]
 801737c:	ba1a      	rev	r2, r3
 801737e:	697b      	ldr	r3, [r7, #20]
 8017380:	601a      	str	r2, [r3, #0]
		NX_CHANGE_ULONG_ENDIAN(*(ethernet_frame_ptr + 1));
 8017382:	697b      	ldr	r3, [r7, #20]
 8017384:	3304      	adds	r3, #4
 8017386:	681a      	ldr	r2, [r3, #0]
 8017388:	697b      	ldr	r3, [r7, #20]
 801738a:	3304      	adds	r3, #4
 801738c:	ba12      	rev	r2, r2
 801738e:	601a      	str	r2, [r3, #0]
		NX_CHANGE_ULONG_ENDIAN(*(ethernet_frame_ptr + 2));
 8017390:	697b      	ldr	r3, [r7, #20]
 8017392:	3308      	adds	r3, #8
 8017394:	681a      	ldr	r2, [r3, #0]
 8017396:	697b      	ldr	r3, [r7, #20]
 8017398:	3308      	adds	r3, #8
 801739a:	ba12      	rev	r2, r2
 801739c:	601a      	str	r2, [r3, #0]
		NX_CHANGE_ULONG_ENDIAN(*(ethernet_frame_ptr + 3));
 801739e:	697b      	ldr	r3, [r7, #20]
 80173a0:	330c      	adds	r3, #12
 80173a2:	681a      	ldr	r2, [r3, #0]
 80173a4:	697b      	ldr	r3, [r7, #20]
 80173a6:	330c      	adds	r3, #12
 80173a8:	ba12      	rev	r2, r2
 80173aa:	601a      	str	r2, [r3, #0]


		if (network_write(nx_wifi_driver[i].interface_handle, &buffer) == STM_OK) {
 80173ac:	4917      	ldr	r1, [pc, #92]	; (801740c <nx_stm32_custom_driver+0x3a4>)
 80173ae:	6aba      	ldr	r2, [r7, #40]	; 0x28
 80173b0:	4613      	mov	r3, r2
 80173b2:	00db      	lsls	r3, r3, #3
 80173b4:	1a9b      	subs	r3, r3, r2
 80173b6:	009b      	lsls	r3, r3, #2
 80173b8:	440b      	add	r3, r1
 80173ba:	3318      	adds	r3, #24
 80173bc:	681b      	ldr	r3, [r3, #0]
 80173be:	f107 020c 	add.w	r2, r7, #12
 80173c2:	4611      	mov	r1, r2
 80173c4:	4618      	mov	r0, r3
 80173c6:	f006 ffd9 	bl	801e37c <network_write>
 80173ca:	4603      	mov	r3, r0
 80173cc:	2b00      	cmp	r3, #0
 80173ce:	d119      	bne.n	8017404 <nx_stm32_custom_driver+0x39c>
			driver_req_ptr->nx_ip_driver_status = NX_SUCCESS;
 80173d0:	687b      	ldr	r3, [r7, #4]
 80173d2:	2200      	movs	r2, #0
 80173d4:	605a      	str	r2, [r3, #4]
		} else {
			/*TODO - Handle packet send fail */
		}

    /* USER CODE END NX_LINK_PACKET_SEND */
        break;
 80173d6:	e015      	b.n	8017404 <nx_stm32_custom_driver+0x39c>

    case NX_LINK_MULTICAST_JOIN:
    /* USER CODE BEGIN NX_LINK_MULTICAST_JOIN */
		/*  Unsupported feature.  */
		*(driver_req_ptr->nx_ip_driver_return_ptr) = 0;
 80173d8:	687b      	ldr	r3, [r7, #4]
 80173da:	695b      	ldr	r3, [r3, #20]
 80173dc:	2200      	movs	r2, #0
 80173de:	601a      	str	r2, [r3, #0]
    /* USER CODE END NX_LINK_MULTICAST_JOIN */
        break;
 80173e0:	e011      	b.n	8017406 <nx_stm32_custom_driver+0x39e>

    case NX_LINK_MULTICAST_LEAVE:
    /* USER CODE BEGIN NX_LINK_MULTICAST_LEAVE */
		/* Return the link's line speed in the supplied return pointer. Unsupported feature.  */
		*(driver_req_ptr->nx_ip_driver_return_ptr) = 0;
 80173e2:	687b      	ldr	r3, [r7, #4]
 80173e4:	695b      	ldr	r3, [r3, #20]
 80173e6:	2200      	movs	r2, #0
 80173e8:	601a      	str	r2, [r3, #0]
    /* USER CODE END NX_LINK_MULTICAST_LEAVE */
        break;
 80173ea:	e00c      	b.n	8017406 <nx_stm32_custom_driver+0x39e>

    case NX_LINK_GET_STATUS:
    /* USER CODE BEGIN NX_LINK_GET_STATUS */
		/* Return the link's line speed in the supplied return pointer. Unsupported feature.  */
		*(driver_req_ptr->nx_ip_driver_return_ptr) = 0;
 80173ec:	687b      	ldr	r3, [r7, #4]
 80173ee:	695b      	ldr	r3, [r3, #20]
 80173f0:	2200      	movs	r2, #0
 80173f2:	601a      	str	r2, [r3, #0]
    /* USER CODE END NX_LINK_GET_STATUS */
        break;
 80173f4:	e007      	b.n	8017406 <nx_stm32_custom_driver+0x39e>
#endif /* NX_ENABLE_INTERFACE_CAPABILITY */

    default:
    /* USER CODE BEGIN DEFAULT */
		/* Unsupported feature.  */
		*(driver_req_ptr->nx_ip_driver_return_ptr) = 0;
 80173f6:	687b      	ldr	r3, [r7, #4]
 80173f8:	695b      	ldr	r3, [r3, #20]
 80173fa:	2200      	movs	r2, #0
 80173fc:	601a      	str	r2, [r3, #0]

    /* USER CODE END DEFAULT */
        break;
 80173fe:	e002      	b.n	8017406 <nx_stm32_custom_driver+0x39e>
        break;
 8017400:	bf00      	nop
 8017402:	e000      	b.n	8017406 <nx_stm32_custom_driver+0x39e>
        break;
 8017404:	bf00      	nop
    }
}
 8017406:	3730      	adds	r7, #48	; 0x30
 8017408:	46bd      	mov	sp, r7
 801740a:	bd80      	pop	{r7, pc}
 801740c:	24034adc 	.word	0x24034adc

08017410 <station_callback>:

    /* USER CODE BEGIN 2 */
void station_callback(struct network_handle *net_handle) {
 8017410:	b580      	push	{r7, lr}
 8017412:	b094      	sub	sp, #80	; 0x50
 8017414:	af00      	add	r7, sp, #0
 8017416:	6078      	str	r0, [r7, #4]
	struct pbuf *rx_buffer = NULL;
 8017418:	2300      	movs	r3, #0
 801741a:	64bb      	str	r3, [r7, #72]	; 0x48
	NX_PACKET packet;
		NX_PACKET *packet_ptr = &packet;
 801741c:	f107 030c 	add.w	r3, r7, #12
 8017420:	647b      	str	r3, [r7, #68]	; 0x44

	//uint32_t sta_ip = 0;
	//int ret;
	int i;

	for (i = 0; i < MAX_INTERFACES; i++) {
 8017422:	2300      	movs	r3, #0
 8017424:	64fb      	str	r3, [r7, #76]	; 0x4c
 8017426:	e02f      	b.n	8017488 <station_callback+0x78>
		if (nx_wifi_driver[i].nx_network_driver_in_use == 0) {
 8017428:	4931      	ldr	r1, [pc, #196]	; (80174f0 <station_callback+0xe0>)
 801742a:	6cfa      	ldr	r2, [r7, #76]	; 0x4c
 801742c:	4613      	mov	r3, r2
 801742e:	00db      	lsls	r3, r3, #3
 8017430:	1a9b      	subs	r3, r3, r2
 8017432:	009b      	lsls	r3, r3, #2
 8017434:	440b      	add	r3, r1
 8017436:	681b      	ldr	r3, [r3, #0]
 8017438:	2b00      	cmp	r3, #0
 801743a:	d01f      	beq.n	801747c <station_callback+0x6c>
			continue;
		}

		if (nx_wifi_driver[i].interface_handle != net_handle) {
 801743c:	492c      	ldr	r1, [pc, #176]	; (80174f0 <station_callback+0xe0>)
 801743e:	6cfa      	ldr	r2, [r7, #76]	; 0x4c
 8017440:	4613      	mov	r3, r2
 8017442:	00db      	lsls	r3, r3, #3
 8017444:	1a9b      	subs	r3, r3, r2
 8017446:	009b      	lsls	r3, r3, #2
 8017448:	440b      	add	r3, r1
 801744a:	3318      	adds	r3, #24
 801744c:	681b      	ldr	r3, [r3, #0]
 801744e:	687a      	ldr	r2, [r7, #4]
 8017450:	429a      	cmp	r2, r3
 8017452:	d115      	bne.n	8017480 <station_callback+0x70>
			continue;
		}

		if (strncmp(nx_wifi_driver[i].nx_driver_ip_ptr->nx_ip_name,
 8017454:	4926      	ldr	r1, [pc, #152]	; (80174f0 <station_callback+0xe0>)
 8017456:	6cfa      	ldr	r2, [r7, #76]	; 0x4c
 8017458:	4613      	mov	r3, r2
 801745a:	00db      	lsls	r3, r3, #3
 801745c:	1a9b      	subs	r3, r3, r2
 801745e:	009b      	lsls	r3, r3, #2
 8017460:	440b      	add	r3, r1
 8017462:	330c      	adds	r3, #12
 8017464:	681b      	ldr	r3, [r3, #0]
 8017466:	6858      	ldr	r0, [r3, #4]
				net_handle->ndev->name, sizeof(SOFTAP_INTERFACE)) == 0) {
 8017468:	687b      	ldr	r3, [r7, #4]
 801746a:	681b      	ldr	r3, [r3, #0]
		if (strncmp(nx_wifi_driver[i].nx_driver_ip_ptr->nx_ip_name,
 801746c:	220b      	movs	r2, #11
 801746e:	4619      	mov	r1, r3
 8017470:	f009 fa1c 	bl	80208ac <strncmp>
 8017474:	4603      	mov	r3, r0
 8017476:	2b00      	cmp	r3, #0
 8017478:	d00a      	beq.n	8017490 <station_callback+0x80>
 801747a:	e002      	b.n	8017482 <station_callback+0x72>
			continue;
 801747c:	bf00      	nop
 801747e:	e000      	b.n	8017482 <station_callback+0x72>
			continue;
 8017480:	bf00      	nop
	for (i = 0; i < MAX_INTERFACES; i++) {
 8017482:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8017484:	3301      	adds	r3, #1
 8017486:	64fb      	str	r3, [r7, #76]	; 0x4c
 8017488:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 801748a:	2b01      	cmp	r3, #1
 801748c:	ddcc      	ble.n	8017428 <station_callback+0x18>
 801748e:	e000      	b.n	8017492 <station_callback+0x82>
			break;
 8017490:	bf00      	nop
		}
	}

	if (i == MAX_INTERFACES) {
 8017492:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8017494:	2b02      	cmp	r3, #2
 8017496:	d026      	beq.n	80174e6 <station_callback+0xd6>
		//driver_req_ptr->nx_ip_driver_status = NX_INVALID_INTERFACE;
		return;
	}

	rx_buffer = network_read(net_handle, 0);
 8017498:	2100      	movs	r1, #0
 801749a:	6878      	ldr	r0, [r7, #4]
 801749c:	f006 ff2e 	bl	801e2fc <network_read>
 80174a0:	64b8      	str	r0, [r7, #72]	; 0x48


		packet_ptr->nx_packet_prepend_ptr = rx_buffer->payload;
 80174a2:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 80174a4:	681a      	ldr	r2, [r3, #0]
 80174a6:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 80174a8:	609a      	str	r2, [r3, #8]
		packet_ptr->nx_packet_append_ptr = packet_ptr->nx_packet_prepend_ptr  + rx_buffer->len;
 80174aa:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 80174ac:	689b      	ldr	r3, [r3, #8]
 80174ae:	6cba      	ldr	r2, [r7, #72]	; 0x48
 80174b0:	8892      	ldrh	r2, [r2, #4]
 80174b2:	441a      	add	r2, r3
 80174b4:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 80174b6:	60da      	str	r2, [r3, #12]
		packet_ptr->nx_packet_length = rx_buffer->len;
 80174b8:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 80174ba:	889b      	ldrh	r3, [r3, #4]
 80174bc:	461a      	mov	r2, r3
 80174be:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 80174c0:	625a      	str	r2, [r3, #36]	; 0x24
		packet_ptr->nx_packet_next = NULL;
 80174c2:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 80174c4:	2200      	movs	r2, #0
 80174c6:	605a      	str	r2, [r3, #4]

		_nx_wifi_driver_receive(nx_wifi_driver[i].nx_driver_ip_ptr, packet_ptr, i);
 80174c8:	4909      	ldr	r1, [pc, #36]	; (80174f0 <station_callback+0xe0>)
 80174ca:	6cfa      	ldr	r2, [r7, #76]	; 0x4c
 80174cc:	4613      	mov	r3, r2
 80174ce:	00db      	lsls	r3, r3, #3
 80174d0:	1a9b      	subs	r3, r3, r2
 80174d2:	009b      	lsls	r3, r3, #2
 80174d4:	440b      	add	r3, r1
 80174d6:	330c      	adds	r3, #12
 80174d8:	681b      	ldr	r3, [r3, #0]
 80174da:	6cfa      	ldr	r2, [r7, #76]	; 0x4c
 80174dc:	6c79      	ldr	r1, [r7, #68]	; 0x44
 80174de:	4618      	mov	r0, r3
 80174e0:	f000 f880 	bl	80175e4 <_nx_wifi_driver_receive>
 80174e4:	e000      	b.n	80174e8 <station_callback+0xd8>
		return;
 80174e6:	bf00      	nop

}
 80174e8:	3750      	adds	r7, #80	; 0x50
 80174ea:	46bd      	mov	sp, r7
 80174ec:	bd80      	pop	{r7, pc}
 80174ee:	bf00      	nop
 80174f0:	24034adc 	.word	0x24034adc

080174f4 <softap_callback>:

void softap_callback(struct network_handle * net_handle) {
 80174f4:	b580      	push	{r7, lr}
 80174f6:	b094      	sub	sp, #80	; 0x50
 80174f8:	af00      	add	r7, sp, #0
 80174fa:	6078      	str	r0, [r7, #4]
	struct pbuf *rx_buffer = NULL;
 80174fc:	2300      	movs	r3, #0
 80174fe:	64bb      	str	r3, [r7, #72]	; 0x48
	int i = 0;
 8017500:	2300      	movs	r3, #0
 8017502:	64fb      	str	r3, [r7, #76]	; 0x4c
	//int ret;
	NX_PACKET packet;
	NX_PACKET *packet_ptr = &packet;
 8017504:	f107 030c 	add.w	r3, r7, #12
 8017508:	647b      	str	r3, [r7, #68]	; 0x44
	rx_buffer = network_read(net_handle, 0);
 801750a:	2100      	movs	r1, #0
 801750c:	6878      	ldr	r0, [r7, #4]
 801750e:	f006 fef5 	bl	801e2fc <network_read>
 8017512:	64b8      	str	r0, [r7, #72]	; 0x48

	for (i = 0; i < MAX_INTERFACES; i++) {
 8017514:	2300      	movs	r3, #0
 8017516:	64fb      	str	r3, [r7, #76]	; 0x4c
 8017518:	e02f      	b.n	801757a <softap_callback+0x86>
		if (nx_wifi_driver[i].nx_network_driver_in_use == 0) {
 801751a:	4931      	ldr	r1, [pc, #196]	; (80175e0 <softap_callback+0xec>)
 801751c:	6cfa      	ldr	r2, [r7, #76]	; 0x4c
 801751e:	4613      	mov	r3, r2
 8017520:	00db      	lsls	r3, r3, #3
 8017522:	1a9b      	subs	r3, r3, r2
 8017524:	009b      	lsls	r3, r3, #2
 8017526:	440b      	add	r3, r1
 8017528:	681b      	ldr	r3, [r3, #0]
 801752a:	2b00      	cmp	r3, #0
 801752c:	d01f      	beq.n	801756e <softap_callback+0x7a>
			continue;
		}

		if (nx_wifi_driver[i].interface_handle != net_handle) {
 801752e:	492c      	ldr	r1, [pc, #176]	; (80175e0 <softap_callback+0xec>)
 8017530:	6cfa      	ldr	r2, [r7, #76]	; 0x4c
 8017532:	4613      	mov	r3, r2
 8017534:	00db      	lsls	r3, r3, #3
 8017536:	1a9b      	subs	r3, r3, r2
 8017538:	009b      	lsls	r3, r3, #2
 801753a:	440b      	add	r3, r1
 801753c:	3318      	adds	r3, #24
 801753e:	681b      	ldr	r3, [r3, #0]
 8017540:	687a      	ldr	r2, [r7, #4]
 8017542:	429a      	cmp	r2, r3
 8017544:	d115      	bne.n	8017572 <softap_callback+0x7e>
			continue;
		}

		if (strncmp(nx_wifi_driver[i].nx_driver_ip_ptr->nx_ip_name,
 8017546:	4926      	ldr	r1, [pc, #152]	; (80175e0 <softap_callback+0xec>)
 8017548:	6cfa      	ldr	r2, [r7, #76]	; 0x4c
 801754a:	4613      	mov	r3, r2
 801754c:	00db      	lsls	r3, r3, #3
 801754e:	1a9b      	subs	r3, r3, r2
 8017550:	009b      	lsls	r3, r3, #2
 8017552:	440b      	add	r3, r1
 8017554:	330c      	adds	r3, #12
 8017556:	681b      	ldr	r3, [r3, #0]
 8017558:	6858      	ldr	r0, [r3, #4]
				net_handle->ndev->name, sizeof(SOFTAP_INTERFACE)) == 0) {
 801755a:	687b      	ldr	r3, [r7, #4]
 801755c:	681b      	ldr	r3, [r3, #0]
		if (strncmp(nx_wifi_driver[i].nx_driver_ip_ptr->nx_ip_name,
 801755e:	220b      	movs	r2, #11
 8017560:	4619      	mov	r1, r3
 8017562:	f009 f9a3 	bl	80208ac <strncmp>
 8017566:	4603      	mov	r3, r0
 8017568:	2b00      	cmp	r3, #0
 801756a:	d00a      	beq.n	8017582 <softap_callback+0x8e>
 801756c:	e002      	b.n	8017574 <softap_callback+0x80>
			continue;
 801756e:	bf00      	nop
 8017570:	e000      	b.n	8017574 <softap_callback+0x80>
			continue;
 8017572:	bf00      	nop
	for (i = 0; i < MAX_INTERFACES; i++) {
 8017574:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8017576:	3301      	adds	r3, #1
 8017578:	64fb      	str	r3, [r7, #76]	; 0x4c
 801757a:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 801757c:	2b01      	cmp	r3, #1
 801757e:	ddcc      	ble.n	801751a <softap_callback+0x26>
 8017580:	e000      	b.n	8017584 <softap_callback+0x90>
			break;
 8017582:	bf00      	nop
		}
	}

	if (i == MAX_INTERFACES) {
 8017584:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8017586:	2b02      	cmp	r3, #2
 8017588:	d026      	beq.n	80175d8 <softap_callback+0xe4>
		//driver_req_ptr->nx_ip_driver_status = NX_INVALID_INTERFACE;
		return;
	}

	rx_buffer = network_read(net_handle, 0);
 801758a:	2100      	movs	r1, #0
 801758c:	6878      	ldr	r0, [r7, #4]
 801758e:	f006 feb5 	bl	801e2fc <network_read>
 8017592:	64b8      	str	r0, [r7, #72]	; 0x48


	packet_ptr->nx_packet_prepend_ptr = rx_buffer->payload;
 8017594:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 8017596:	681a      	ldr	r2, [r3, #0]
 8017598:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 801759a:	609a      	str	r2, [r3, #8]
	packet_ptr->nx_packet_append_ptr = packet_ptr->nx_packet_prepend_ptr  + rx_buffer->len;
 801759c:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 801759e:	689b      	ldr	r3, [r3, #8]
 80175a0:	6cba      	ldr	r2, [r7, #72]	; 0x48
 80175a2:	8892      	ldrh	r2, [r2, #4]
 80175a4:	441a      	add	r2, r3
 80175a6:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 80175a8:	60da      	str	r2, [r3, #12]
	packet_ptr->nx_packet_length = rx_buffer->len;
 80175aa:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 80175ac:	889b      	ldrh	r3, [r3, #4]
 80175ae:	461a      	mov	r2, r3
 80175b0:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 80175b2:	625a      	str	r2, [r3, #36]	; 0x24
	packet_ptr->nx_packet_next = NULL;
 80175b4:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 80175b6:	2200      	movs	r2, #0
 80175b8:	605a      	str	r2, [r3, #4]

	_nx_wifi_driver_receive(nx_wifi_driver[i].nx_driver_ip_ptr, packet_ptr, i);
 80175ba:	4909      	ldr	r1, [pc, #36]	; (80175e0 <softap_callback+0xec>)
 80175bc:	6cfa      	ldr	r2, [r7, #76]	; 0x4c
 80175be:	4613      	mov	r3, r2
 80175c0:	00db      	lsls	r3, r3, #3
 80175c2:	1a9b      	subs	r3, r3, r2
 80175c4:	009b      	lsls	r3, r3, #2
 80175c6:	440b      	add	r3, r1
 80175c8:	330c      	adds	r3, #12
 80175ca:	681b      	ldr	r3, [r3, #0]
 80175cc:	6cfa      	ldr	r2, [r7, #76]	; 0x4c
 80175ce:	6c79      	ldr	r1, [r7, #68]	; 0x44
 80175d0:	4618      	mov	r0, r3
 80175d2:	f000 f807 	bl	80175e4 <_nx_wifi_driver_receive>
 80175d6:	e000      	b.n	80175da <softap_callback+0xe6>
		return;
 80175d8:	bf00      	nop

}
 80175da:	3750      	adds	r7, #80	; 0x50
 80175dc:	46bd      	mov	sp, r7
 80175de:	bd80      	pop	{r7, pc}
 80175e0:	24034adc 	.word	0x24034adc

080175e4 <_nx_wifi_driver_receive>:

void  _nx_wifi_driver_receive(NX_IP *ip_ptr, NX_PACKET *packet_ptr, UINT interface_instance_id)
{
 80175e4:	b580      	push	{r7, lr}
 80175e6:	b086      	sub	sp, #24
 80175e8:	af00      	add	r7, sp, #0
 80175ea:	60f8      	str	r0, [r7, #12]
 80175ec:	60b9      	str	r1, [r7, #8]
 80175ee:	607a      	str	r2, [r7, #4]

UINT packet_type;

    /* Pickup the packet header to determine where the packet needs to be
       sent.  */
    packet_type =  (((UINT)(*(packet_ptr -> nx_packet_prepend_ptr + 12))) << 8) |
 80175f0:	68bb      	ldr	r3, [r7, #8]
 80175f2:	689b      	ldr	r3, [r3, #8]
 80175f4:	330c      	adds	r3, #12
 80175f6:	781b      	ldrb	r3, [r3, #0]
 80175f8:	021b      	lsls	r3, r3, #8
        ((UINT)(*(packet_ptr -> nx_packet_prepend_ptr + 13)));
 80175fa:	68ba      	ldr	r2, [r7, #8]
 80175fc:	6892      	ldr	r2, [r2, #8]
 80175fe:	320d      	adds	r2, #13
 8017600:	7812      	ldrb	r2, [r2, #0]
    packet_type =  (((UINT)(*(packet_ptr -> nx_packet_prepend_ptr + 12))) << 8) |
 8017602:	4313      	orrs	r3, r2
 8017604:	617b      	str	r3, [r7, #20]


    /* Setup interface pointer.  */
    packet_ptr -> nx_packet_address.nx_packet_interface_ptr = nx_wifi_driver[interface_instance_id].nx_interface_ptr;
 8017606:	68b9      	ldr	r1, [r7, #8]
 8017608:	4828      	ldr	r0, [pc, #160]	; (80176ac <_nx_wifi_driver_receive+0xc8>)
 801760a:	687a      	ldr	r2, [r7, #4]
 801760c:	4613      	mov	r3, r2
 801760e:	00db      	lsls	r3, r3, #3
 8017610:	1a9b      	subs	r3, r3, r2
 8017612:	009b      	lsls	r3, r3, #2
 8017614:	4403      	add	r3, r0
 8017616:	3308      	adds	r3, #8
 8017618:	681b      	ldr	r3, [r3, #0]
 801761a:	630b      	str	r3, [r1, #48]	; 0x30


    /* Route the incoming packet according to its ethernet type.  */
    /* The RAM driver accepts both IPv4 and IPv6 frames. */
    if (packet_type == NX_ETHERNET_IP)
 801761c:	697b      	ldr	r3, [r7, #20]
 801761e:	f5b3 6f00 	cmp.w	r3, #2048	; 0x800
 8017622:	d10f      	bne.n	8017644 <_nx_wifi_driver_receive+0x60>
           as well as the Ethernet header.  In some cases, the actual packet length after the
           Ethernet header should be derived from the length in the IP header (lower 16 bits of
           the first 32-bit word).  */

        /* Clean off the Ethernet header.  */
        packet_ptr -> nx_packet_prepend_ptr =  packet_ptr -> nx_packet_prepend_ptr + NX_ETHERNET_SIZE;
 8017624:	68bb      	ldr	r3, [r7, #8]
 8017626:	689a      	ldr	r2, [r3, #8]
 8017628:	68bb      	ldr	r3, [r7, #8]
 801762a:	320e      	adds	r2, #14
 801762c:	609a      	str	r2, [r3, #8]

        /* Adjust the packet length.  */
        packet_ptr -> nx_packet_length =  packet_ptr -> nx_packet_length - NX_ETHERNET_SIZE;
 801762e:	68bb      	ldr	r3, [r7, #8]
 8017630:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 8017632:	68bb      	ldr	r3, [r7, #8]
 8017634:	3a0e      	subs	r2, #14
 8017636:	625a      	str	r2, [r3, #36]	; 0x24
#endif

#ifdef NX_DIRECT_ISR_CALL
        _nx_ip_packet_receive(ip_ptr, packet_ptr);
#else
        _nx_ip_packet_deferred_receive(ip_ptr, packet_ptr);
 8017638:	68bb      	ldr	r3, [r7, #8]
 801763a:	4619      	mov	r1, r3
 801763c:	68f8      	ldr	r0, [r7, #12]
 801763e:	f7f3 faf3 	bl	800ac28 <_nx_ip_packet_deferred_receive>
    {

        /* Invalid ethernet header... release the packet.  */
        nx_packet_release(packet_ptr);
    }
}
 8017642:	e02e      	b.n	80176a2 <_nx_wifi_driver_receive+0xbe>
    else if (packet_type == NX_ETHERNET_ARP)
 8017644:	697b      	ldr	r3, [r7, #20]
 8017646:	f640 0206 	movw	r2, #2054	; 0x806
 801764a:	4293      	cmp	r3, r2
 801764c:	d10f      	bne.n	801766e <_nx_wifi_driver_receive+0x8a>
        packet_ptr -> nx_packet_prepend_ptr =  packet_ptr -> nx_packet_prepend_ptr + NX_ETHERNET_SIZE;
 801764e:	68bb      	ldr	r3, [r7, #8]
 8017650:	689a      	ldr	r2, [r3, #8]
 8017652:	68bb      	ldr	r3, [r7, #8]
 8017654:	320e      	adds	r2, #14
 8017656:	609a      	str	r2, [r3, #8]
        packet_ptr -> nx_packet_length =  packet_ptr -> nx_packet_length - NX_ETHERNET_SIZE;
 8017658:	68bb      	ldr	r3, [r7, #8]
 801765a:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 801765c:	68bb      	ldr	r3, [r7, #8]
 801765e:	3a0e      	subs	r2, #14
 8017660:	625a      	str	r2, [r3, #36]	; 0x24
        _nx_arp_packet_deferred_receive(ip_ptr, packet_ptr);
 8017662:	68bb      	ldr	r3, [r7, #8]
 8017664:	4619      	mov	r1, r3
 8017666:	68f8      	ldr	r0, [r7, #12]
 8017668:	f7f1 fa23 	bl	8008ab2 <_nx_arp_packet_deferred_receive>
}
 801766c:	e019      	b.n	80176a2 <_nx_wifi_driver_receive+0xbe>
    else if (packet_type == NX_ETHERNET_RARP)
 801766e:	697b      	ldr	r3, [r7, #20]
 8017670:	f248 0235 	movw	r2, #32821	; 0x8035
 8017674:	4293      	cmp	r3, r2
 8017676:	d10f      	bne.n	8017698 <_nx_wifi_driver_receive+0xb4>
        packet_ptr -> nx_packet_prepend_ptr =  packet_ptr -> nx_packet_prepend_ptr + NX_ETHERNET_SIZE;
 8017678:	68bb      	ldr	r3, [r7, #8]
 801767a:	689a      	ldr	r2, [r3, #8]
 801767c:	68bb      	ldr	r3, [r7, #8]
 801767e:	320e      	adds	r2, #14
 8017680:	609a      	str	r2, [r3, #8]
        packet_ptr -> nx_packet_length =  packet_ptr -> nx_packet_length - NX_ETHERNET_SIZE;
 8017682:	68bb      	ldr	r3, [r7, #8]
 8017684:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 8017686:	68bb      	ldr	r3, [r7, #8]
 8017688:	3a0e      	subs	r2, #14
 801768a:	625a      	str	r2, [r3, #36]	; 0x24
        _nx_rarp_packet_deferred_receive(ip_ptr, packet_ptr);
 801768c:	68bb      	ldr	r3, [r7, #8]
 801768e:	4619      	mov	r1, r3
 8017690:	68f8      	ldr	r0, [r7, #12]
 8017692:	f7f4 ffb5 	bl	800c600 <_nx_rarp_packet_deferred_receive>
}
 8017696:	e004      	b.n	80176a2 <_nx_wifi_driver_receive+0xbe>
        nx_packet_release(packet_ptr);
 8017698:	f107 0308 	add.w	r3, r7, #8
 801769c:	4618      	mov	r0, r3
 801769e:	f7fa f809 	bl	80116b4 <_nxe_packet_release>
}
 80176a2:	bf00      	nop
 80176a4:	3718      	adds	r7, #24
 80176a6:	46bd      	mov	sp, r7
 80176a8:	bd80      	pop	{r7, pc}
 80176aa:	bf00      	nop
 80176ac:	24034adc 	.word	0x24034adc

080176b0 <esp_hosted_cmd_get_mac_address__init>:
#endif

#include "esp_hosted_config.pb-c.h"
void   esp_hosted_cmd_get_mac_address__init
                     (EspHostedCmdGetMacAddress         *message)
{
 80176b0:	b4b0      	push	{r4, r5, r7}
 80176b2:	b083      	sub	sp, #12
 80176b4:	af00      	add	r7, sp, #0
 80176b6:	6078      	str	r0, [r7, #4]
  static EspHostedCmdGetMacAddress init_value = ESP_HOSTED_CMD_GET_MAC_ADDRESS__INIT;
  *message = init_value;
 80176b8:	687b      	ldr	r3, [r7, #4]
 80176ba:	4a06      	ldr	r2, [pc, #24]	; (80176d4 <esp_hosted_cmd_get_mac_address__init+0x24>)
 80176bc:	461c      	mov	r4, r3
 80176be:	4615      	mov	r5, r2
 80176c0:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 80176c2:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 80176c4:	682b      	ldr	r3, [r5, #0]
 80176c6:	6023      	str	r3, [r4, #0]
}
 80176c8:	bf00      	nop
 80176ca:	370c      	adds	r7, #12
 80176cc:	46bd      	mov	sp, r7
 80176ce:	bcb0      	pop	{r4, r5, r7}
 80176d0:	4770      	bx	lr
 80176d2:	bf00      	nop
 80176d4:	2400007c 	.word	0x2400007c

080176d8 <esp_hosted_resp_get_mac_address__init>:
  assert(message->base.descriptor == &esp_hosted_cmd_get_mac_address__descriptor);
  protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);
}
void   esp_hosted_resp_get_mac_address__init
                     (EspHostedRespGetMacAddress         *message)
{
 80176d8:	b4b0      	push	{r4, r5, r7}
 80176da:	b083      	sub	sp, #12
 80176dc:	af00      	add	r7, sp, #0
 80176de:	6078      	str	r0, [r7, #4]
  static EspHostedRespGetMacAddress init_value = ESP_HOSTED_RESP_GET_MAC_ADDRESS__INIT;
  *message = init_value;
 80176e0:	687b      	ldr	r3, [r7, #4]
 80176e2:	4a07      	ldr	r2, [pc, #28]	; (8017700 <esp_hosted_resp_get_mac_address__init+0x28>)
 80176e4:	461c      	mov	r4, r3
 80176e6:	4615      	mov	r5, r2
 80176e8:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 80176ea:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 80176ec:	e895 000f 	ldmia.w	r5, {r0, r1, r2, r3}
 80176f0:	e884 000f 	stmia.w	r4, {r0, r1, r2, r3}
}
 80176f4:	bf00      	nop
 80176f6:	370c      	adds	r7, #12
 80176f8:	46bd      	mov	sp, r7
 80176fa:	bcb0      	pop	{r4, r5, r7}
 80176fc:	4770      	bx	lr
 80176fe:	bf00      	nop
 8017700:	24000090 	.word	0x24000090

08017704 <esp_hosted_cmd_get_mode__init>:
  assert(message->base.descriptor == &esp_hosted_resp_get_mac_address__descriptor);
  protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);
}
void   esp_hosted_cmd_get_mode__init
                     (EspHostedCmdGetMode         *message)
{
 8017704:	b480      	push	{r7}
 8017706:	b083      	sub	sp, #12
 8017708:	af00      	add	r7, sp, #0
 801770a:	6078      	str	r0, [r7, #4]
  static EspHostedCmdGetMode init_value = ESP_HOSTED_CMD_GET_MODE__INIT;
  *message = init_value;
 801770c:	687b      	ldr	r3, [r7, #4]
 801770e:	4a05      	ldr	r2, [pc, #20]	; (8017724 <esp_hosted_cmd_get_mode__init+0x20>)
 8017710:	ca07      	ldmia	r2, {r0, r1, r2}
 8017712:	e883 0007 	stmia.w	r3, {r0, r1, r2}
}
 8017716:	bf00      	nop
 8017718:	370c      	adds	r7, #12
 801771a:	46bd      	mov	sp, r7
 801771c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8017720:	4770      	bx	lr
 8017722:	bf00      	nop
 8017724:	240000b0 	.word	0x240000b0

08017728 <esp_hosted_resp_get_mode__init>:
  assert(message->base.descriptor == &esp_hosted_cmd_get_mode__descriptor);
  protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);
}
void   esp_hosted_resp_get_mode__init
                     (EspHostedRespGetMode         *message)
{
 8017728:	b4b0      	push	{r4, r5, r7}
 801772a:	b083      	sub	sp, #12
 801772c:	af00      	add	r7, sp, #0
 801772e:	6078      	str	r0, [r7, #4]
  static EspHostedRespGetMode init_value = ESP_HOSTED_RESP_GET_MODE__INIT;
  *message = init_value;
 8017730:	687b      	ldr	r3, [r7, #4]
 8017732:	4a07      	ldr	r2, [pc, #28]	; (8017750 <esp_hosted_resp_get_mode__init+0x28>)
 8017734:	461c      	mov	r4, r3
 8017736:	4615      	mov	r5, r2
 8017738:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 801773a:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 801773c:	e895 0007 	ldmia.w	r5, {r0, r1, r2}
 8017740:	e884 0007 	stmia.w	r4, {r0, r1, r2}
}
 8017744:	bf00      	nop
 8017746:	370c      	adds	r7, #12
 8017748:	46bd      	mov	sp, r7
 801774a:	bcb0      	pop	{r4, r5, r7}
 801774c:	4770      	bx	lr
 801774e:	bf00      	nop
 8017750:	240000bc 	.word	0x240000bc

08017754 <esp_hosted_cmd_set_mode__init>:
  assert(message->base.descriptor == &esp_hosted_resp_get_mode__descriptor);
  protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);
}
void   esp_hosted_cmd_set_mode__init
                     (EspHostedCmdSetMode         *message)
{
 8017754:	b4b0      	push	{r4, r5, r7}
 8017756:	b083      	sub	sp, #12
 8017758:	af00      	add	r7, sp, #0
 801775a:	6078      	str	r0, [r7, #4]
  static EspHostedCmdSetMode init_value = ESP_HOSTED_CMD_SET_MODE__INIT;
  *message = init_value;
 801775c:	687b      	ldr	r3, [r7, #4]
 801775e:	4a06      	ldr	r2, [pc, #24]	; (8017778 <esp_hosted_cmd_set_mode__init+0x24>)
 8017760:	461c      	mov	r4, r3
 8017762:	4615      	mov	r5, r2
 8017764:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 8017766:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 8017768:	682b      	ldr	r3, [r5, #0]
 801776a:	6023      	str	r3, [r4, #0]
}
 801776c:	bf00      	nop
 801776e:	370c      	adds	r7, #12
 8017770:	46bd      	mov	sp, r7
 8017772:	bcb0      	pop	{r4, r5, r7}
 8017774:	4770      	bx	lr
 8017776:	bf00      	nop
 8017778:	240000d8 	.word	0x240000d8

0801777c <esp_hosted_resp_set_mode__init>:
  assert(message->base.descriptor == &esp_hosted_cmd_set_mode__descriptor);
  protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);
}
void   esp_hosted_resp_set_mode__init
                     (EspHostedRespSetMode         *message)
{
 801777c:	b4b0      	push	{r4, r5, r7}
 801777e:	b083      	sub	sp, #12
 8017780:	af00      	add	r7, sp, #0
 8017782:	6078      	str	r0, [r7, #4]
  static EspHostedRespSetMode init_value = ESP_HOSTED_RESP_SET_MODE__INIT;
  *message = init_value;
 8017784:	687b      	ldr	r3, [r7, #4]
 8017786:	4a06      	ldr	r2, [pc, #24]	; (80177a0 <esp_hosted_resp_set_mode__init+0x24>)
 8017788:	461c      	mov	r4, r3
 801778a:	4615      	mov	r5, r2
 801778c:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 801778e:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 8017790:	682b      	ldr	r3, [r5, #0]
 8017792:	6023      	str	r3, [r4, #0]
}
 8017794:	bf00      	nop
 8017796:	370c      	adds	r7, #12
 8017798:	46bd      	mov	sp, r7
 801779a:	bcb0      	pop	{r4, r5, r7}
 801779c:	4770      	bx	lr
 801779e:	bf00      	nop
 80177a0:	240000ec 	.word	0x240000ec

080177a4 <esp_hosted_cmd_get_status__init>:
  assert(message->base.descriptor == &esp_hosted_resp_set_mode__descriptor);
  protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);
}
void   esp_hosted_cmd_get_status__init
                     (EspHostedCmdGetStatus         *message)
{
 80177a4:	b480      	push	{r7}
 80177a6:	b083      	sub	sp, #12
 80177a8:	af00      	add	r7, sp, #0
 80177aa:	6078      	str	r0, [r7, #4]
  static EspHostedCmdGetStatus init_value = ESP_HOSTED_CMD_GET_STATUS__INIT;
  *message = init_value;
 80177ac:	687b      	ldr	r3, [r7, #4]
 80177ae:	4a05      	ldr	r2, [pc, #20]	; (80177c4 <esp_hosted_cmd_get_status__init+0x20>)
 80177b0:	ca07      	ldmia	r2, {r0, r1, r2}
 80177b2:	e883 0007 	stmia.w	r3, {r0, r1, r2}
}
 80177b6:	bf00      	nop
 80177b8:	370c      	adds	r7, #12
 80177ba:	46bd      	mov	sp, r7
 80177bc:	f85d 7b04 	ldr.w	r7, [sp], #4
 80177c0:	4770      	bx	lr
 80177c2:	bf00      	nop
 80177c4:	24000100 	.word	0x24000100

080177c8 <esp_hosted_resp_get_status__init>:
  assert(message->base.descriptor == &esp_hosted_cmd_get_status__descriptor);
  protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);
}
void   esp_hosted_resp_get_status__init
                     (EspHostedRespGetStatus         *message)
{
 80177c8:	b4b0      	push	{r4, r5, r7}
 80177ca:	b083      	sub	sp, #12
 80177cc:	af00      	add	r7, sp, #0
 80177ce:	6078      	str	r0, [r7, #4]
  static EspHostedRespGetStatus init_value = ESP_HOSTED_RESP_GET_STATUS__INIT;
  *message = init_value;
 80177d0:	687b      	ldr	r3, [r7, #4]
 80177d2:	4a06      	ldr	r2, [pc, #24]	; (80177ec <esp_hosted_resp_get_status__init+0x24>)
 80177d4:	461c      	mov	r4, r3
 80177d6:	4615      	mov	r5, r2
 80177d8:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 80177da:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 80177dc:	682b      	ldr	r3, [r5, #0]
 80177de:	6023      	str	r3, [r4, #0]
}
 80177e0:	bf00      	nop
 80177e2:	370c      	adds	r7, #12
 80177e4:	46bd      	mov	sp, r7
 80177e6:	bcb0      	pop	{r4, r5, r7}
 80177e8:	4770      	bx	lr
 80177ea:	bf00      	nop
 80177ec:	2400010c 	.word	0x2400010c

080177f0 <esp_hosted_cmd_set_mac_address__init>:
  assert(message->base.descriptor == &esp_hosted_resp_get_status__descriptor);
  protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);
}
void   esp_hosted_cmd_set_mac_address__init
                     (EspHostedCmdSetMacAddress         *message)
{
 80177f0:	b4b0      	push	{r4, r5, r7}
 80177f2:	b083      	sub	sp, #12
 80177f4:	af00      	add	r7, sp, #0
 80177f6:	6078      	str	r0, [r7, #4]
  static EspHostedCmdSetMacAddress init_value = ESP_HOSTED_CMD_SET_MAC_ADDRESS__INIT;
  *message = init_value;
 80177f8:	687b      	ldr	r3, [r7, #4]
 80177fa:	4a07      	ldr	r2, [pc, #28]	; (8017818 <esp_hosted_cmd_set_mac_address__init+0x28>)
 80177fc:	461c      	mov	r4, r3
 80177fe:	4615      	mov	r5, r2
 8017800:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 8017802:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 8017804:	e895 000f 	ldmia.w	r5, {r0, r1, r2, r3}
 8017808:	e884 000f 	stmia.w	r4, {r0, r1, r2, r3}
}
 801780c:	bf00      	nop
 801780e:	370c      	adds	r7, #12
 8017810:	46bd      	mov	sp, r7
 8017812:	bcb0      	pop	{r4, r5, r7}
 8017814:	4770      	bx	lr
 8017816:	bf00      	nop
 8017818:	24000120 	.word	0x24000120

0801781c <esp_hosted_resp_set_mac_address__init>:
  assert(message->base.descriptor == &esp_hosted_cmd_set_mac_address__descriptor);
  protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);
}
void   esp_hosted_resp_set_mac_address__init
                     (EspHostedRespSetMacAddress         *message)
{
 801781c:	b4b0      	push	{r4, r5, r7}
 801781e:	b083      	sub	sp, #12
 8017820:	af00      	add	r7, sp, #0
 8017822:	6078      	str	r0, [r7, #4]
  static EspHostedRespSetMacAddress init_value = ESP_HOSTED_RESP_SET_MAC_ADDRESS__INIT;
  *message = init_value;
 8017824:	687b      	ldr	r3, [r7, #4]
 8017826:	4a06      	ldr	r2, [pc, #24]	; (8017840 <esp_hosted_resp_set_mac_address__init+0x24>)
 8017828:	461c      	mov	r4, r3
 801782a:	4615      	mov	r5, r2
 801782c:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 801782e:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 8017830:	682b      	ldr	r3, [r5, #0]
 8017832:	6023      	str	r3, [r4, #0]
}
 8017834:	bf00      	nop
 8017836:	370c      	adds	r7, #12
 8017838:	46bd      	mov	sp, r7
 801783a:	bcb0      	pop	{r4, r5, r7}
 801783c:	4770      	bx	lr
 801783e:	bf00      	nop
 8017840:	24000140 	.word	0x24000140

08017844 <esp_hosted_cmd_get_apconfig__init>:
  assert(message->base.descriptor == &esp_hosted_resp_set_mac_address__descriptor);
  protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);
}
void   esp_hosted_cmd_get_apconfig__init
                     (EspHostedCmdGetAPConfig         *message)
{
 8017844:	b480      	push	{r7}
 8017846:	b083      	sub	sp, #12
 8017848:	af00      	add	r7, sp, #0
 801784a:	6078      	str	r0, [r7, #4]
  static EspHostedCmdGetAPConfig init_value = ESP_HOSTED_CMD_GET_APCONFIG__INIT;
  *message = init_value;
 801784c:	687b      	ldr	r3, [r7, #4]
 801784e:	4a05      	ldr	r2, [pc, #20]	; (8017864 <esp_hosted_cmd_get_apconfig__init+0x20>)
 8017850:	ca07      	ldmia	r2, {r0, r1, r2}
 8017852:	e883 0007 	stmia.w	r3, {r0, r1, r2}
}
 8017856:	bf00      	nop
 8017858:	370c      	adds	r7, #12
 801785a:	46bd      	mov	sp, r7
 801785c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8017860:	4770      	bx	lr
 8017862:	bf00      	nop
 8017864:	24000154 	.word	0x24000154

08017868 <esp_hosted_resp_get_apconfig__init>:
  assert(message->base.descriptor == &esp_hosted_cmd_get_apconfig__descriptor);
  protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);
}
void   esp_hosted_resp_get_apconfig__init
                     (EspHostedRespGetAPConfig         *message)
{
 8017868:	b580      	push	{r7, lr}
 801786a:	b082      	sub	sp, #8
 801786c:	af00      	add	r7, sp, #0
 801786e:	6078      	str	r0, [r7, #4]
  static EspHostedRespGetAPConfig init_value = ESP_HOSTED_RESP_GET_APCONFIG__INIT;
  *message = init_value;
 8017870:	687b      	ldr	r3, [r7, #4]
 8017872:	4a05      	ldr	r2, [pc, #20]	; (8017888 <esp_hosted_resp_get_apconfig__init+0x20>)
 8017874:	4618      	mov	r0, r3
 8017876:	4611      	mov	r1, r2
 8017878:	2344      	movs	r3, #68	; 0x44
 801787a:	461a      	mov	r2, r3
 801787c:	f007 ffd6 	bl	801f82c <memcpy>
}
 8017880:	bf00      	nop
 8017882:	3708      	adds	r7, #8
 8017884:	46bd      	mov	sp, r7
 8017886:	bd80      	pop	{r7, pc}
 8017888:	24000160 	.word	0x24000160

0801788c <esp_hosted_cmd_set_apconfig__init>:
  assert(message->base.descriptor == &esp_hosted_resp_get_apconfig__descriptor);
  protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);
}
void   esp_hosted_cmd_set_apconfig__init
                     (EspHostedCmdSetAPConfig         *message)
{
 801788c:	b4b0      	push	{r4, r5, r7}
 801788e:	b083      	sub	sp, #12
 8017890:	af00      	add	r7, sp, #0
 8017892:	6078      	str	r0, [r7, #4]
  static EspHostedCmdSetAPConfig init_value = ESP_HOSTED_CMD_SET_APCONFIG__INIT;
  *message = init_value;
 8017894:	687b      	ldr	r3, [r7, #4]
 8017896:	4a08      	ldr	r2, [pc, #32]	; (80178b8 <esp_hosted_cmd_set_apconfig__init+0x2c>)
 8017898:	461c      	mov	r4, r3
 801789a:	4615      	mov	r5, r2
 801789c:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 801789e:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 80178a0:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 80178a2:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 80178a4:	e895 0003 	ldmia.w	r5, {r0, r1}
 80178a8:	e884 0003 	stmia.w	r4, {r0, r1}
}
 80178ac:	bf00      	nop
 80178ae:	370c      	adds	r7, #12
 80178b0:	46bd      	mov	sp, r7
 80178b2:	bcb0      	pop	{r4, r5, r7}
 80178b4:	4770      	bx	lr
 80178b6:	bf00      	nop
 80178b8:	240001a4 	.word	0x240001a4

080178bc <esp_hosted_resp_set_apconfig__init>:
  assert(message->base.descriptor == &esp_hosted_cmd_set_apconfig__descriptor);
  protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);
}
void   esp_hosted_resp_set_apconfig__init
                     (EspHostedRespSetAPConfig         *message)
{
 80178bc:	b4b0      	push	{r4, r5, r7}
 80178be:	b083      	sub	sp, #12
 80178c0:	af00      	add	r7, sp, #0
 80178c2:	6078      	str	r0, [r7, #4]
  static EspHostedRespSetAPConfig init_value = ESP_HOSTED_RESP_SET_APCONFIG__INIT;
  *message = init_value;
 80178c4:	687b      	ldr	r3, [r7, #4]
 80178c6:	4a06      	ldr	r2, [pc, #24]	; (80178e0 <esp_hosted_resp_set_apconfig__init+0x24>)
 80178c8:	461c      	mov	r4, r3
 80178ca:	4615      	mov	r5, r2
 80178cc:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 80178ce:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 80178d0:	682b      	ldr	r3, [r5, #0]
 80178d2:	6023      	str	r3, [r4, #0]
}
 80178d4:	bf00      	nop
 80178d6:	370c      	adds	r7, #12
 80178d8:	46bd      	mov	sp, r7
 80178da:	bcb0      	pop	{r4, r5, r7}
 80178dc:	4770      	bx	lr
 80178de:	bf00      	nop
 80178e0:	240001cc 	.word	0x240001cc

080178e4 <esp_hosted_cmd_get_soft_apconfig__init>:
  assert(message->base.descriptor == &esp_hosted_resp_set_apconfig__descriptor);
  protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);
}
void   esp_hosted_cmd_get_soft_apconfig__init
                     (EspHostedCmdGetSoftAPConfig         *message)
{
 80178e4:	b480      	push	{r7}
 80178e6:	b083      	sub	sp, #12
 80178e8:	af00      	add	r7, sp, #0
 80178ea:	6078      	str	r0, [r7, #4]
  static EspHostedCmdGetSoftAPConfig init_value = ESP_HOSTED_CMD_GET_SOFT_APCONFIG__INIT;
  *message = init_value;
 80178ec:	687b      	ldr	r3, [r7, #4]
 80178ee:	4a05      	ldr	r2, [pc, #20]	; (8017904 <esp_hosted_cmd_get_soft_apconfig__init+0x20>)
 80178f0:	ca07      	ldmia	r2, {r0, r1, r2}
 80178f2:	e883 0007 	stmia.w	r3, {r0, r1, r2}
}
 80178f6:	bf00      	nop
 80178f8:	370c      	adds	r7, #12
 80178fa:	46bd      	mov	sp, r7
 80178fc:	f85d 7b04 	ldr.w	r7, [sp], #4
 8017900:	4770      	bx	lr
 8017902:	bf00      	nop
 8017904:	240001e0 	.word	0x240001e0

08017908 <esp_hosted_resp_get_soft_apconfig__init>:
  assert(message->base.descriptor == &esp_hosted_cmd_get_soft_apconfig__descriptor);
  protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);
}
void   esp_hosted_resp_get_soft_apconfig__init
                     (EspHostedRespGetSoftAPConfig         *message)
{
 8017908:	b580      	push	{r7, lr}
 801790a:	b082      	sub	sp, #8
 801790c:	af00      	add	r7, sp, #0
 801790e:	6078      	str	r0, [r7, #4]
  static EspHostedRespGetSoftAPConfig init_value = ESP_HOSTED_RESP_GET_SOFT_APCONFIG__INIT;
  *message = init_value;
 8017910:	687b      	ldr	r3, [r7, #4]
 8017912:	4a05      	ldr	r2, [pc, #20]	; (8017928 <esp_hosted_resp_get_soft_apconfig__init+0x20>)
 8017914:	4618      	mov	r0, r3
 8017916:	4611      	mov	r1, r2
 8017918:	2354      	movs	r3, #84	; 0x54
 801791a:	461a      	mov	r2, r3
 801791c:	f007 ff86 	bl	801f82c <memcpy>
}
 8017920:	bf00      	nop
 8017922:	3708      	adds	r7, #8
 8017924:	46bd      	mov	sp, r7
 8017926:	bd80      	pop	{r7, pc}
 8017928:	240001ec 	.word	0x240001ec

0801792c <esp_hosted_cmd_set_soft_apconfig__init>:
  assert(message->base.descriptor == &esp_hosted_resp_get_soft_apconfig__descriptor);
  protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);
}
void   esp_hosted_cmd_set_soft_apconfig__init
                     (EspHostedCmdSetSoftAPConfig         *message)
{
 801792c:	b4b0      	push	{r4, r5, r7}
 801792e:	b083      	sub	sp, #12
 8017930:	af00      	add	r7, sp, #0
 8017932:	6078      	str	r0, [r7, #4]
  static EspHostedCmdSetSoftAPConfig init_value = ESP_HOSTED_CMD_SET_SOFT_APCONFIG__INIT;
  *message = init_value;
 8017934:	687b      	ldr	r3, [r7, #4]
 8017936:	4a09      	ldr	r2, [pc, #36]	; (801795c <esp_hosted_cmd_set_soft_apconfig__init+0x30>)
 8017938:	461c      	mov	r4, r3
 801793a:	4615      	mov	r5, r2
 801793c:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 801793e:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 8017940:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 8017942:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 8017944:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 8017946:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 8017948:	e895 0007 	ldmia.w	r5, {r0, r1, r2}
 801794c:	e884 0007 	stmia.w	r4, {r0, r1, r2}
}
 8017950:	bf00      	nop
 8017952:	370c      	adds	r7, #12
 8017954:	46bd      	mov	sp, r7
 8017956:	bcb0      	pop	{r4, r5, r7}
 8017958:	4770      	bx	lr
 801795a:	bf00      	nop
 801795c:	24000240 	.word	0x24000240

08017960 <esp_hosted_resp_set_soft_apconfig__init>:
  assert(message->base.descriptor == &esp_hosted_cmd_set_soft_apconfig__descriptor);
  protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);
}
void   esp_hosted_resp_set_soft_apconfig__init
                     (EspHostedRespSetSoftAPConfig         *message)
{
 8017960:	b4b0      	push	{r4, r5, r7}
 8017962:	b083      	sub	sp, #12
 8017964:	af00      	add	r7, sp, #0
 8017966:	6078      	str	r0, [r7, #4]
  static EspHostedRespSetSoftAPConfig init_value = ESP_HOSTED_RESP_SET_SOFT_APCONFIG__INIT;
  *message = init_value;
 8017968:	687b      	ldr	r3, [r7, #4]
 801796a:	4a06      	ldr	r2, [pc, #24]	; (8017984 <esp_hosted_resp_set_soft_apconfig__init+0x24>)
 801796c:	461c      	mov	r4, r3
 801796e:	4615      	mov	r5, r2
 8017970:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 8017972:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 8017974:	682b      	ldr	r3, [r5, #0]
 8017976:	6023      	str	r3, [r4, #0]
}
 8017978:	bf00      	nop
 801797a:	370c      	adds	r7, #12
 801797c:	46bd      	mov	sp, r7
 801797e:	bcb0      	pop	{r4, r5, r7}
 8017980:	4770      	bx	lr
 8017982:	bf00      	nop
 8017984:	2400027c 	.word	0x2400027c

08017988 <esp_hosted_scan_result__init>:
  assert(message->base.descriptor == &esp_hosted_resp_set_soft_apconfig__descriptor);
  protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);
}
void   esp_hosted_scan_result__init
                     (EspHostedScanResult         *message)
{
 8017988:	b4b0      	push	{r4, r5, r7}
 801798a:	b083      	sub	sp, #12
 801798c:	af00      	add	r7, sp, #0
 801798e:	6078      	str	r0, [r7, #4]
  static EspHostedScanResult init_value = ESP_HOSTED_SCAN_RESULT__INIT;
  *message = init_value;
 8017990:	687b      	ldr	r3, [r7, #4]
 8017992:	4a09      	ldr	r2, [pc, #36]	; (80179b8 <esp_hosted_scan_result__init+0x30>)
 8017994:	461c      	mov	r4, r3
 8017996:	4615      	mov	r5, r2
 8017998:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 801799a:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 801799c:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 801799e:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 80179a0:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 80179a2:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 80179a4:	e895 0007 	ldmia.w	r5, {r0, r1, r2}
 80179a8:	e884 0007 	stmia.w	r4, {r0, r1, r2}
}
 80179ac:	bf00      	nop
 80179ae:	370c      	adds	r7, #12
 80179b0:	46bd      	mov	sp, r7
 80179b2:	bcb0      	pop	{r4, r5, r7}
 80179b4:	4770      	bx	lr
 80179b6:	bf00      	nop
 80179b8:	24000290 	.word	0x24000290

080179bc <esp_hosted_cmd_scan_result__init>:
  assert(message->base.descriptor == &esp_hosted_scan_result__descriptor);
  protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);
}
void   esp_hosted_cmd_scan_result__init
                     (EspHostedCmdScanResult         *message)
{
 80179bc:	b480      	push	{r7}
 80179be:	b083      	sub	sp, #12
 80179c0:	af00      	add	r7, sp, #0
 80179c2:	6078      	str	r0, [r7, #4]
  static EspHostedCmdScanResult init_value = ESP_HOSTED_CMD_SCAN_RESULT__INIT;
  *message = init_value;
 80179c4:	687b      	ldr	r3, [r7, #4]
 80179c6:	4a05      	ldr	r2, [pc, #20]	; (80179dc <esp_hosted_cmd_scan_result__init+0x20>)
 80179c8:	ca07      	ldmia	r2, {r0, r1, r2}
 80179ca:	e883 0007 	stmia.w	r3, {r0, r1, r2}
}
 80179ce:	bf00      	nop
 80179d0:	370c      	adds	r7, #12
 80179d2:	46bd      	mov	sp, r7
 80179d4:	f85d 7b04 	ldr.w	r7, [sp], #4
 80179d8:	4770      	bx	lr
 80179da:	bf00      	nop
 80179dc:	240002cc 	.word	0x240002cc

080179e0 <esp_hosted_resp_scan_result__init>:
  assert(message->base.descriptor == &esp_hosted_cmd_scan_result__descriptor);
  protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);
}
void   esp_hosted_resp_scan_result__init
                     (EspHostedRespScanResult         *message)
{
 80179e0:	b4b0      	push	{r4, r5, r7}
 80179e2:	b083      	sub	sp, #12
 80179e4:	af00      	add	r7, sp, #0
 80179e6:	6078      	str	r0, [r7, #4]
  static EspHostedRespScanResult init_value = ESP_HOSTED_RESP_SCAN_RESULT__INIT;
  *message = init_value;
 80179e8:	687b      	ldr	r3, [r7, #4]
 80179ea:	4a07      	ldr	r2, [pc, #28]	; (8017a08 <esp_hosted_resp_scan_result__init+0x28>)
 80179ec:	461c      	mov	r4, r3
 80179ee:	4615      	mov	r5, r2
 80179f0:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 80179f2:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 80179f4:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 80179f6:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 80179f8:	682b      	ldr	r3, [r5, #0]
 80179fa:	6023      	str	r3, [r4, #0]
}
 80179fc:	bf00      	nop
 80179fe:	370c      	adds	r7, #12
 8017a00:	46bd      	mov	sp, r7
 8017a02:	bcb0      	pop	{r4, r5, r7}
 8017a04:	4770      	bx	lr
 8017a06:	bf00      	nop
 8017a08:	240002d8 	.word	0x240002d8

08017a0c <esp_hosted_connected_stalist__init>:
  assert(message->base.descriptor == &esp_hosted_resp_scan_result__descriptor);
  protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);
}
void   esp_hosted_connected_stalist__init
                     (EspHostedConnectedSTAList         *message)
{
 8017a0c:	b4b0      	push	{r4, r5, r7}
 8017a0e:	b083      	sub	sp, #12
 8017a10:	af00      	add	r7, sp, #0
 8017a12:	6078      	str	r0, [r7, #4]
  static EspHostedConnectedSTAList init_value = ESP_HOSTED_CONNECTED_STALIST__INIT;
  *message = init_value;
 8017a14:	687b      	ldr	r3, [r7, #4]
 8017a16:	4a07      	ldr	r2, [pc, #28]	; (8017a34 <esp_hosted_connected_stalist__init+0x28>)
 8017a18:	461c      	mov	r4, r3
 8017a1a:	4615      	mov	r5, r2
 8017a1c:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 8017a1e:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 8017a20:	e895 000f 	ldmia.w	r5, {r0, r1, r2, r3}
 8017a24:	e884 000f 	stmia.w	r4, {r0, r1, r2, r3}
}
 8017a28:	bf00      	nop
 8017a2a:	370c      	adds	r7, #12
 8017a2c:	46bd      	mov	sp, r7
 8017a2e:	bcb0      	pop	{r4, r5, r7}
 8017a30:	4770      	bx	lr
 8017a32:	bf00      	nop
 8017a34:	240002fc 	.word	0x240002fc

08017a38 <esp_hosted_cmd_connected_sta__init>:
  assert(message->base.descriptor == &esp_hosted_connected_stalist__descriptor);
  protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);
}
void   esp_hosted_cmd_connected_sta__init
                     (EspHostedCmdConnectedSTA         *message)
{
 8017a38:	b480      	push	{r7}
 8017a3a:	b083      	sub	sp, #12
 8017a3c:	af00      	add	r7, sp, #0
 8017a3e:	6078      	str	r0, [r7, #4]
  static EspHostedCmdConnectedSTA init_value = ESP_HOSTED_CMD_CONNECTED_STA__INIT;
  *message = init_value;
 8017a40:	687b      	ldr	r3, [r7, #4]
 8017a42:	4a05      	ldr	r2, [pc, #20]	; (8017a58 <esp_hosted_cmd_connected_sta__init+0x20>)
 8017a44:	ca07      	ldmia	r2, {r0, r1, r2}
 8017a46:	e883 0007 	stmia.w	r3, {r0, r1, r2}
}
 8017a4a:	bf00      	nop
 8017a4c:	370c      	adds	r7, #12
 8017a4e:	46bd      	mov	sp, r7
 8017a50:	f85d 7b04 	ldr.w	r7, [sp], #4
 8017a54:	4770      	bx	lr
 8017a56:	bf00      	nop
 8017a58:	2400031c 	.word	0x2400031c

08017a5c <esp_hosted_resp_connected_sta__init>:
  assert(message->base.descriptor == &esp_hosted_cmd_connected_sta__descriptor);
  protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);
}
void   esp_hosted_resp_connected_sta__init
                     (EspHostedRespConnectedSTA         *message)
{
 8017a5c:	b4b0      	push	{r4, r5, r7}
 8017a5e:	b083      	sub	sp, #12
 8017a60:	af00      	add	r7, sp, #0
 8017a62:	6078      	str	r0, [r7, #4]
  static EspHostedRespConnectedSTA init_value = ESP_HOSTED_RESP_CONNECTED_STA__INIT;
  *message = init_value;
 8017a64:	687b      	ldr	r3, [r7, #4]
 8017a66:	4a07      	ldr	r2, [pc, #28]	; (8017a84 <esp_hosted_resp_connected_sta__init+0x28>)
 8017a68:	461c      	mov	r4, r3
 8017a6a:	4615      	mov	r5, r2
 8017a6c:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 8017a6e:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 8017a70:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 8017a72:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 8017a74:	682b      	ldr	r3, [r5, #0]
 8017a76:	6023      	str	r3, [r4, #0]
}
 8017a78:	bf00      	nop
 8017a7a:	370c      	adds	r7, #12
 8017a7c:	46bd      	mov	sp, r7
 8017a7e:	bcb0      	pop	{r4, r5, r7}
 8017a80:	4770      	bx	lr
 8017a82:	bf00      	nop
 8017a84:	24000328 	.word	0x24000328

08017a88 <esp_hosted_cmd_otabegin__init>:
  assert(message->base.descriptor == &esp_hosted_resp_connected_sta__descriptor);
  protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);
}
void   esp_hosted_cmd_otabegin__init
                     (EspHostedCmdOTABegin         *message)
{
 8017a88:	b480      	push	{r7}
 8017a8a:	b083      	sub	sp, #12
 8017a8c:	af00      	add	r7, sp, #0
 8017a8e:	6078      	str	r0, [r7, #4]
  static EspHostedCmdOTABegin init_value = ESP_HOSTED_CMD_OTABEGIN__INIT;
  *message = init_value;
 8017a90:	687b      	ldr	r3, [r7, #4]
 8017a92:	4a05      	ldr	r2, [pc, #20]	; (8017aa8 <esp_hosted_cmd_otabegin__init+0x20>)
 8017a94:	ca07      	ldmia	r2, {r0, r1, r2}
 8017a96:	e883 0007 	stmia.w	r3, {r0, r1, r2}
}
 8017a9a:	bf00      	nop
 8017a9c:	370c      	adds	r7, #12
 8017a9e:	46bd      	mov	sp, r7
 8017aa0:	f85d 7b04 	ldr.w	r7, [sp], #4
 8017aa4:	4770      	bx	lr
 8017aa6:	bf00      	nop
 8017aa8:	2400034c 	.word	0x2400034c

08017aac <esp_hosted_resp_otabegin__init>:
  assert(message->base.descriptor == &esp_hosted_cmd_otabegin__descriptor);
  protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);
}
void   esp_hosted_resp_otabegin__init
                     (EspHostedRespOTABegin         *message)
{
 8017aac:	b4b0      	push	{r4, r5, r7}
 8017aae:	b083      	sub	sp, #12
 8017ab0:	af00      	add	r7, sp, #0
 8017ab2:	6078      	str	r0, [r7, #4]
  static EspHostedRespOTABegin init_value = ESP_HOSTED_RESP_OTABEGIN__INIT;
  *message = init_value;
 8017ab4:	687b      	ldr	r3, [r7, #4]
 8017ab6:	4a06      	ldr	r2, [pc, #24]	; (8017ad0 <esp_hosted_resp_otabegin__init+0x24>)
 8017ab8:	461c      	mov	r4, r3
 8017aba:	4615      	mov	r5, r2
 8017abc:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 8017abe:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 8017ac0:	682b      	ldr	r3, [r5, #0]
 8017ac2:	6023      	str	r3, [r4, #0]
}
 8017ac4:	bf00      	nop
 8017ac6:	370c      	adds	r7, #12
 8017ac8:	46bd      	mov	sp, r7
 8017aca:	bcb0      	pop	{r4, r5, r7}
 8017acc:	4770      	bx	lr
 8017ace:	bf00      	nop
 8017ad0:	24000358 	.word	0x24000358

08017ad4 <esp_hosted_cmd_otawrite__init>:
  assert(message->base.descriptor == &esp_hosted_resp_otabegin__descriptor);
  protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);
}
void   esp_hosted_cmd_otawrite__init
                     (EspHostedCmdOTAWrite         *message)
{
 8017ad4:	b4b0      	push	{r4, r5, r7}
 8017ad6:	b083      	sub	sp, #12
 8017ad8:	af00      	add	r7, sp, #0
 8017ada:	6078      	str	r0, [r7, #4]
  static EspHostedCmdOTAWrite init_value = ESP_HOSTED_CMD_OTAWRITE__INIT;
  *message = init_value;
 8017adc:	687b      	ldr	r3, [r7, #4]
 8017ade:	4a07      	ldr	r2, [pc, #28]	; (8017afc <esp_hosted_cmd_otawrite__init+0x28>)
 8017ae0:	461c      	mov	r4, r3
 8017ae2:	4615      	mov	r5, r2
 8017ae4:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 8017ae6:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 8017ae8:	e895 0003 	ldmia.w	r5, {r0, r1}
 8017aec:	e884 0003 	stmia.w	r4, {r0, r1}
}
 8017af0:	bf00      	nop
 8017af2:	370c      	adds	r7, #12
 8017af4:	46bd      	mov	sp, r7
 8017af6:	bcb0      	pop	{r4, r5, r7}
 8017af8:	4770      	bx	lr
 8017afa:	bf00      	nop
 8017afc:	2400036c 	.word	0x2400036c

08017b00 <esp_hosted_resp_otawrite__init>:
  assert(message->base.descriptor == &esp_hosted_cmd_otawrite__descriptor);
  protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);
}
void   esp_hosted_resp_otawrite__init
                     (EspHostedRespOTAWrite         *message)
{
 8017b00:	b4b0      	push	{r4, r5, r7}
 8017b02:	b083      	sub	sp, #12
 8017b04:	af00      	add	r7, sp, #0
 8017b06:	6078      	str	r0, [r7, #4]
  static EspHostedRespOTAWrite init_value = ESP_HOSTED_RESP_OTAWRITE__INIT;
  *message = init_value;
 8017b08:	687b      	ldr	r3, [r7, #4]
 8017b0a:	4a06      	ldr	r2, [pc, #24]	; (8017b24 <esp_hosted_resp_otawrite__init+0x24>)
 8017b0c:	461c      	mov	r4, r3
 8017b0e:	4615      	mov	r5, r2
 8017b10:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 8017b12:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 8017b14:	682b      	ldr	r3, [r5, #0]
 8017b16:	6023      	str	r3, [r4, #0]
}
 8017b18:	bf00      	nop
 8017b1a:	370c      	adds	r7, #12
 8017b1c:	46bd      	mov	sp, r7
 8017b1e:	bcb0      	pop	{r4, r5, r7}
 8017b20:	4770      	bx	lr
 8017b22:	bf00      	nop
 8017b24:	24000384 	.word	0x24000384

08017b28 <esp_hosted_cmd_otaend__init>:
  assert(message->base.descriptor == &esp_hosted_resp_otawrite__descriptor);
  protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);
}
void   esp_hosted_cmd_otaend__init
                     (EspHostedCmdOTAEnd         *message)
{
 8017b28:	b480      	push	{r7}
 8017b2a:	b083      	sub	sp, #12
 8017b2c:	af00      	add	r7, sp, #0
 8017b2e:	6078      	str	r0, [r7, #4]
  static EspHostedCmdOTAEnd init_value = ESP_HOSTED_CMD_OTAEND__INIT;
  *message = init_value;
 8017b30:	687b      	ldr	r3, [r7, #4]
 8017b32:	4a05      	ldr	r2, [pc, #20]	; (8017b48 <esp_hosted_cmd_otaend__init+0x20>)
 8017b34:	ca07      	ldmia	r2, {r0, r1, r2}
 8017b36:	e883 0007 	stmia.w	r3, {r0, r1, r2}
}
 8017b3a:	bf00      	nop
 8017b3c:	370c      	adds	r7, #12
 8017b3e:	46bd      	mov	sp, r7
 8017b40:	f85d 7b04 	ldr.w	r7, [sp], #4
 8017b44:	4770      	bx	lr
 8017b46:	bf00      	nop
 8017b48:	24000398 	.word	0x24000398

08017b4c <esp_hosted_resp_otaend__init>:
  assert(message->base.descriptor == &esp_hosted_cmd_otaend__descriptor);
  protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);
}
void   esp_hosted_resp_otaend__init
                     (EspHostedRespOTAEnd         *message)
{
 8017b4c:	b4b0      	push	{r4, r5, r7}
 8017b4e:	b083      	sub	sp, #12
 8017b50:	af00      	add	r7, sp, #0
 8017b52:	6078      	str	r0, [r7, #4]
  static EspHostedRespOTAEnd init_value = ESP_HOSTED_RESP_OTAEND__INIT;
  *message = init_value;
 8017b54:	687b      	ldr	r3, [r7, #4]
 8017b56:	4a06      	ldr	r2, [pc, #24]	; (8017b70 <esp_hosted_resp_otaend__init+0x24>)
 8017b58:	461c      	mov	r4, r3
 8017b5a:	4615      	mov	r5, r2
 8017b5c:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 8017b5e:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 8017b60:	682b      	ldr	r3, [r5, #0]
 8017b62:	6023      	str	r3, [r4, #0]
}
 8017b64:	bf00      	nop
 8017b66:	370c      	adds	r7, #12
 8017b68:	46bd      	mov	sp, r7
 8017b6a:	bcb0      	pop	{r4, r5, r7}
 8017b6c:	4770      	bx	lr
 8017b6e:	bf00      	nop
 8017b70:	240003a4 	.word	0x240003a4

08017b74 <esp_hosted_cmd_set_vendor_specific_ie__init>:
  assert(message->base.descriptor == &esp_hosted_resp_otaend__descriptor);
  protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);
}
void   esp_hosted_cmd_set_vendor_specific_ie__init
                     (EspHostedCmdSetVendorSpecificIE         *message)
{
 8017b74:	b4b0      	push	{r4, r5, r7}
 8017b76:	b083      	sub	sp, #12
 8017b78:	af00      	add	r7, sp, #0
 8017b7a:	6078      	str	r0, [r7, #4]
  static EspHostedCmdSetVendorSpecificIE init_value = ESP_HOSTED_CMD_SET_VENDOR_SPECIFIC_IE__INIT;
  *message = init_value;
 8017b7c:	687b      	ldr	r3, [r7, #4]
 8017b7e:	4a08      	ldr	r2, [pc, #32]	; (8017ba0 <esp_hosted_cmd_set_vendor_specific_ie__init+0x2c>)
 8017b80:	461c      	mov	r4, r3
 8017b82:	4615      	mov	r5, r2
 8017b84:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 8017b86:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 8017b88:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 8017b8a:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 8017b8c:	e895 000f 	ldmia.w	r5, {r0, r1, r2, r3}
 8017b90:	e884 000f 	stmia.w	r4, {r0, r1, r2, r3}
}
 8017b94:	bf00      	nop
 8017b96:	370c      	adds	r7, #12
 8017b98:	46bd      	mov	sp, r7
 8017b9a:	bcb0      	pop	{r4, r5, r7}
 8017b9c:	4770      	bx	lr
 8017b9e:	bf00      	nop
 8017ba0:	240003b8 	.word	0x240003b8

08017ba4 <esp_hosted_resp_set_vendor_specific_ie__init>:
  assert(message->base.descriptor == &esp_hosted_cmd_set_vendor_specific_ie__descriptor);
  protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);
}
void   esp_hosted_resp_set_vendor_specific_ie__init
                     (EspHostedRespSetVendorSpecificIE         *message)
{
 8017ba4:	b4b0      	push	{r4, r5, r7}
 8017ba6:	b083      	sub	sp, #12
 8017ba8:	af00      	add	r7, sp, #0
 8017baa:	6078      	str	r0, [r7, #4]
  static EspHostedRespSetVendorSpecificIE init_value = ESP_HOSTED_RESP_SET_VENDOR_SPECIFIC_IE__INIT;
  *message = init_value;
 8017bac:	687b      	ldr	r3, [r7, #4]
 8017bae:	4a06      	ldr	r2, [pc, #24]	; (8017bc8 <esp_hosted_resp_set_vendor_specific_ie__init+0x24>)
 8017bb0:	461c      	mov	r4, r3
 8017bb2:	4615      	mov	r5, r2
 8017bb4:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 8017bb6:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 8017bb8:	682b      	ldr	r3, [r5, #0]
 8017bba:	6023      	str	r3, [r4, #0]
}
 8017bbc:	bf00      	nop
 8017bbe:	370c      	adds	r7, #12
 8017bc0:	46bd      	mov	sp, r7
 8017bc2:	bcb0      	pop	{r4, r5, r7}
 8017bc4:	4770      	bx	lr
 8017bc6:	bf00      	nop
 8017bc8:	240003e8 	.word	0x240003e8

08017bcc <esp_hosted_cmd_set_wi_fi_maxtxpower__init>:
  assert(message->base.descriptor == &esp_hosted_resp_set_vendor_specific_ie__descriptor);
  protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);
}
void   esp_hosted_cmd_set_wi_fi_maxtxpower__init
                     (EspHostedCmdSetWiFiMAXTXPower         *message)
{
 8017bcc:	b4b0      	push	{r4, r5, r7}
 8017bce:	b083      	sub	sp, #12
 8017bd0:	af00      	add	r7, sp, #0
 8017bd2:	6078      	str	r0, [r7, #4]
  static EspHostedCmdSetWiFiMAXTXPower init_value = ESP_HOSTED_CMD_SET_WI_FI_MAXTXPOWER__INIT;
  *message = init_value;
 8017bd4:	687b      	ldr	r3, [r7, #4]
 8017bd6:	4a06      	ldr	r2, [pc, #24]	; (8017bf0 <esp_hosted_cmd_set_wi_fi_maxtxpower__init+0x24>)
 8017bd8:	461c      	mov	r4, r3
 8017bda:	4615      	mov	r5, r2
 8017bdc:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 8017bde:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 8017be0:	682b      	ldr	r3, [r5, #0]
 8017be2:	6023      	str	r3, [r4, #0]
}
 8017be4:	bf00      	nop
 8017be6:	370c      	adds	r7, #12
 8017be8:	46bd      	mov	sp, r7
 8017bea:	bcb0      	pop	{r4, r5, r7}
 8017bec:	4770      	bx	lr
 8017bee:	bf00      	nop
 8017bf0:	240003fc 	.word	0x240003fc

08017bf4 <esp_hosted_resp_set_wi_fi_maxtxpower__init>:
  assert(message->base.descriptor == &esp_hosted_cmd_set_wi_fi_maxtxpower__descriptor);
  protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);
}
void   esp_hosted_resp_set_wi_fi_maxtxpower__init
                     (EspHostedRespSetWiFiMAXTXPower         *message)
{
 8017bf4:	b4b0      	push	{r4, r5, r7}
 8017bf6:	b083      	sub	sp, #12
 8017bf8:	af00      	add	r7, sp, #0
 8017bfa:	6078      	str	r0, [r7, #4]
  static EspHostedRespSetWiFiMAXTXPower init_value = ESP_HOSTED_RESP_SET_WI_FI_MAXTXPOWER__INIT;
  *message = init_value;
 8017bfc:	687b      	ldr	r3, [r7, #4]
 8017bfe:	4a06      	ldr	r2, [pc, #24]	; (8017c18 <esp_hosted_resp_set_wi_fi_maxtxpower__init+0x24>)
 8017c00:	461c      	mov	r4, r3
 8017c02:	4615      	mov	r5, r2
 8017c04:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 8017c06:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 8017c08:	682b      	ldr	r3, [r5, #0]
 8017c0a:	6023      	str	r3, [r4, #0]
}
 8017c0c:	bf00      	nop
 8017c0e:	370c      	adds	r7, #12
 8017c10:	46bd      	mov	sp, r7
 8017c12:	bcb0      	pop	{r4, r5, r7}
 8017c14:	4770      	bx	lr
 8017c16:	bf00      	nop
 8017c18:	24000410 	.word	0x24000410

08017c1c <esp_hosted_cmd_get_wi_fi_curr_txpower__init>:
  assert(message->base.descriptor == &esp_hosted_resp_set_wi_fi_maxtxpower__descriptor);
  protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);
}
void   esp_hosted_cmd_get_wi_fi_curr_txpower__init
                     (EspHostedCmdGetWiFiCurrTXPower         *message)
{
 8017c1c:	b480      	push	{r7}
 8017c1e:	b083      	sub	sp, #12
 8017c20:	af00      	add	r7, sp, #0
 8017c22:	6078      	str	r0, [r7, #4]
  static EspHostedCmdGetWiFiCurrTXPower init_value = ESP_HOSTED_CMD_GET_WI_FI_CURR_TXPOWER__INIT;
  *message = init_value;
 8017c24:	687b      	ldr	r3, [r7, #4]
 8017c26:	4a05      	ldr	r2, [pc, #20]	; (8017c3c <esp_hosted_cmd_get_wi_fi_curr_txpower__init+0x20>)
 8017c28:	ca07      	ldmia	r2, {r0, r1, r2}
 8017c2a:	e883 0007 	stmia.w	r3, {r0, r1, r2}
}
 8017c2e:	bf00      	nop
 8017c30:	370c      	adds	r7, #12
 8017c32:	46bd      	mov	sp, r7
 8017c34:	f85d 7b04 	ldr.w	r7, [sp], #4
 8017c38:	4770      	bx	lr
 8017c3a:	bf00      	nop
 8017c3c:	24000424 	.word	0x24000424

08017c40 <esp_hosted_resp_get_wi_fi_curr_txpower__init>:
  assert(message->base.descriptor == &esp_hosted_cmd_get_wi_fi_curr_txpower__descriptor);
  protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);
}
void   esp_hosted_resp_get_wi_fi_curr_txpower__init
                     (EspHostedRespGetWiFiCurrTXPower         *message)
{
 8017c40:	b4b0      	push	{r4, r5, r7}
 8017c42:	b083      	sub	sp, #12
 8017c44:	af00      	add	r7, sp, #0
 8017c46:	6078      	str	r0, [r7, #4]
  static EspHostedRespGetWiFiCurrTXPower init_value = ESP_HOSTED_RESP_GET_WI_FI_CURR_TXPOWER__INIT;
  *message = init_value;
 8017c48:	687b      	ldr	r3, [r7, #4]
 8017c4a:	4a07      	ldr	r2, [pc, #28]	; (8017c68 <esp_hosted_resp_get_wi_fi_curr_txpower__init+0x28>)
 8017c4c:	461c      	mov	r4, r3
 8017c4e:	4615      	mov	r5, r2
 8017c50:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 8017c52:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 8017c54:	e895 0007 	ldmia.w	r5, {r0, r1, r2}
 8017c58:	e884 0007 	stmia.w	r4, {r0, r1, r2}
}
 8017c5c:	bf00      	nop
 8017c5e:	370c      	adds	r7, #12
 8017c60:	46bd      	mov	sp, r7
 8017c62:	bcb0      	pop	{r4, r5, r7}
 8017c64:	4770      	bx	lr
 8017c66:	bf00      	nop
 8017c68:	24000430 	.word	0x24000430

08017c6c <esp_hosted_config_payload__init>:
  assert(message->base.descriptor == &esp_hosted_resp_get_wi_fi_curr_txpower__descriptor);
  protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);
}
void   esp_hosted_config_payload__init
                     (EspHostedConfigPayload         *message)
{
 8017c6c:	b4b0      	push	{r4, r5, r7}
 8017c6e:	b083      	sub	sp, #12
 8017c70:	af00      	add	r7, sp, #0
 8017c72:	6078      	str	r0, [r7, #4]
  static EspHostedConfigPayload init_value = ESP_HOSTED_CONFIG_PAYLOAD__INIT;
  *message = init_value;
 8017c74:	687b      	ldr	r3, [r7, #4]
 8017c76:	4a07      	ldr	r2, [pc, #28]	; (8017c94 <esp_hosted_config_payload__init+0x28>)
 8017c78:	461c      	mov	r4, r3
 8017c7a:	4615      	mov	r5, r2
 8017c7c:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 8017c7e:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 8017c80:	e895 0007 	ldmia.w	r5, {r0, r1, r2}
 8017c84:	e884 0007 	stmia.w	r4, {r0, r1, r2}
}
 8017c88:	bf00      	nop
 8017c8a:	370c      	adds	r7, #12
 8017c8c:	46bd      	mov	sp, r7
 8017c8e:	bcb0      	pop	{r4, r5, r7}
 8017c90:	4770      	bx	lr
 8017c92:	bf00      	nop
 8017c94:	2400044c 	.word	0x2400044c

08017c98 <esp_hosted_config_payload__get_packed_size>:
size_t esp_hosted_config_payload__get_packed_size
                     (const EspHostedConfigPayload *message)
{
 8017c98:	b580      	push	{r7, lr}
 8017c9a:	b082      	sub	sp, #8
 8017c9c:	af00      	add	r7, sp, #0
 8017c9e:	6078      	str	r0, [r7, #4]
  assert(message->base.descriptor == &esp_hosted_config_payload__descriptor);
 8017ca0:	687b      	ldr	r3, [r7, #4]
 8017ca2:	681b      	ldr	r3, [r3, #0]
 8017ca4:	4a08      	ldr	r2, [pc, #32]	; (8017cc8 <esp_hosted_config_payload__get_packed_size+0x30>)
 8017ca6:	4293      	cmp	r3, r2
 8017ca8:	d006      	beq.n	8017cb8 <esp_hosted_config_payload__get_packed_size+0x20>
 8017caa:	4b08      	ldr	r3, [pc, #32]	; (8017ccc <esp_hosted_config_payload__get_packed_size+0x34>)
 8017cac:	4a08      	ldr	r2, [pc, #32]	; (8017cd0 <esp_hosted_config_payload__get_packed_size+0x38>)
 8017cae:	f240 611f 	movw	r1, #1567	; 0x61f
 8017cb2:	4808      	ldr	r0, [pc, #32]	; (8017cd4 <esp_hosted_config_payload__get_packed_size+0x3c>)
 8017cb4:	f007 fd50 	bl	801f758 <__assert_func>
  return protobuf_c_message_get_packed_size ((const ProtobufCMessage*)(message));
 8017cb8:	6878      	ldr	r0, [r7, #4]
 8017cba:	f000 fc9f 	bl	80185fc <protobuf_c_message_get_packed_size>
 8017cbe:	4603      	mov	r3, r0
}
 8017cc0:	4618      	mov	r0, r3
 8017cc2:	3708      	adds	r7, #8
 8017cc4:	46bd      	mov	sp, r7
 8017cc6:	bd80      	pop	{r7, pc}
 8017cc8:	0802806c 	.word	0x0802806c
 8017ccc:	08022954 	.word	0x08022954
 8017cd0:	08028624 	.word	0x08028624
 8017cd4:	08021f2c 	.word	0x08021f2c

08017cd8 <esp_hosted_config_payload__pack>:
size_t esp_hosted_config_payload__pack
                     (const EspHostedConfigPayload *message,
                      uint8_t       *out)
{
 8017cd8:	b580      	push	{r7, lr}
 8017cda:	b082      	sub	sp, #8
 8017cdc:	af00      	add	r7, sp, #0
 8017cde:	6078      	str	r0, [r7, #4]
 8017ce0:	6039      	str	r1, [r7, #0]
  assert(message->base.descriptor == &esp_hosted_config_payload__descriptor);
 8017ce2:	687b      	ldr	r3, [r7, #4]
 8017ce4:	681b      	ldr	r3, [r3, #0]
 8017ce6:	4a09      	ldr	r2, [pc, #36]	; (8017d0c <esp_hosted_config_payload__pack+0x34>)
 8017ce8:	4293      	cmp	r3, r2
 8017cea:	d006      	beq.n	8017cfa <esp_hosted_config_payload__pack+0x22>
 8017cec:	4b08      	ldr	r3, [pc, #32]	; (8017d10 <esp_hosted_config_payload__pack+0x38>)
 8017cee:	4a09      	ldr	r2, [pc, #36]	; (8017d14 <esp_hosted_config_payload__pack+0x3c>)
 8017cf0:	f240 6126 	movw	r1, #1574	; 0x626
 8017cf4:	4808      	ldr	r0, [pc, #32]	; (8017d18 <esp_hosted_config_payload__pack+0x40>)
 8017cf6:	f007 fd2f 	bl	801f758 <__assert_func>
  return protobuf_c_message_pack ((const ProtobufCMessage*)message, out);
 8017cfa:	6839      	ldr	r1, [r7, #0]
 8017cfc:	6878      	ldr	r0, [r7, #4]
 8017cfe:	f001 faf1 	bl	80192e4 <protobuf_c_message_pack>
 8017d02:	4603      	mov	r3, r0
}
 8017d04:	4618      	mov	r0, r3
 8017d06:	3708      	adds	r7, #8
 8017d08:	46bd      	mov	sp, r7
 8017d0a:	bd80      	pop	{r7, pc}
 8017d0c:	0802806c 	.word	0x0802806c
 8017d10:	08022954 	.word	0x08022954
 8017d14:	08028650 	.word	0x08028650
 8017d18:	08021f2c 	.word	0x08021f2c

08017d1c <esp_hosted_config_payload__unpack>:
EspHostedConfigPayload *
       esp_hosted_config_payload__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data)
{
 8017d1c:	b580      	push	{r7, lr}
 8017d1e:	b084      	sub	sp, #16
 8017d20:	af00      	add	r7, sp, #0
 8017d22:	60f8      	str	r0, [r7, #12]
 8017d24:	60b9      	str	r1, [r7, #8]
 8017d26:	607a      	str	r2, [r7, #4]
  return (EspHostedConfigPayload *)
     protobuf_c_message_unpack (&esp_hosted_config_payload__descriptor,
 8017d28:	687b      	ldr	r3, [r7, #4]
 8017d2a:	68ba      	ldr	r2, [r7, #8]
 8017d2c:	68f9      	ldr	r1, [r7, #12]
 8017d2e:	4804      	ldr	r0, [pc, #16]	; (8017d40 <esp_hosted_config_payload__unpack+0x24>)
 8017d30:	f002 fe10 	bl	801a954 <protobuf_c_message_unpack>
 8017d34:	4603      	mov	r3, r0
                                allocator, len, data);
}
 8017d36:	4618      	mov	r0, r3
 8017d38:	3710      	adds	r7, #16
 8017d3a:	46bd      	mov	sp, r7
 8017d3c:	bd80      	pop	{r7, pc}
 8017d3e:	bf00      	nop
 8017d40:	0802806c 	.word	0x0802806c

08017d44 <esp_hosted_config_payload__free_unpacked>:
void   esp_hosted_config_payload__free_unpacked
                     (EspHostedConfigPayload *message,
                      ProtobufCAllocator *allocator)
{
 8017d44:	b580      	push	{r7, lr}
 8017d46:	b082      	sub	sp, #8
 8017d48:	af00      	add	r7, sp, #0
 8017d4a:	6078      	str	r0, [r7, #4]
 8017d4c:	6039      	str	r1, [r7, #0]
  assert(message->base.descriptor == &esp_hosted_config_payload__descriptor);
 8017d4e:	687b      	ldr	r3, [r7, #4]
 8017d50:	681b      	ldr	r3, [r3, #0]
 8017d52:	4a09      	ldr	r2, [pc, #36]	; (8017d78 <esp_hosted_config_payload__free_unpacked+0x34>)
 8017d54:	4293      	cmp	r3, r2
 8017d56:	d006      	beq.n	8017d66 <esp_hosted_config_payload__free_unpacked+0x22>
 8017d58:	4b08      	ldr	r3, [pc, #32]	; (8017d7c <esp_hosted_config_payload__free_unpacked+0x38>)
 8017d5a:	4a09      	ldr	r2, [pc, #36]	; (8017d80 <esp_hosted_config_payload__free_unpacked+0x3c>)
 8017d5c:	f240 613e 	movw	r1, #1598	; 0x63e
 8017d60:	4808      	ldr	r0, [pc, #32]	; (8017d84 <esp_hosted_config_payload__free_unpacked+0x40>)
 8017d62:	f007 fcf9 	bl	801f758 <__assert_func>
  protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);
 8017d66:	6839      	ldr	r1, [r7, #0]
 8017d68:	6878      	ldr	r0, [r7, #4]
 8017d6a:	f003 fadb 	bl	801b324 <protobuf_c_message_free_unpacked>
}
 8017d6e:	bf00      	nop
 8017d70:	3708      	adds	r7, #8
 8017d72:	46bd      	mov	sp, r7
 8017d74:	bd80      	pop	{r7, pc}
 8017d76:	bf00      	nop
 8017d78:	0802806c 	.word	0x0802806c
 8017d7c:	08022954 	.word	0x08022954
 8017d80:	08028670 	.word	0x08028670
 8017d84:	08021f2c 	.word	0x08021f2c

08017d88 <system_alloc>:

/* --- allocator --- */

static void *
system_alloc(void *allocator_data, size_t size)
{
 8017d88:	b580      	push	{r7, lr}
 8017d8a:	b082      	sub	sp, #8
 8017d8c:	af00      	add	r7, sp, #0
 8017d8e:	6078      	str	r0, [r7, #4]
 8017d90:	6039      	str	r1, [r7, #0]
	return malloc(size);
 8017d92:	6838      	ldr	r0, [r7, #0]
 8017d94:	f007 fd3a 	bl	801f80c <malloc>
 8017d98:	4603      	mov	r3, r0
}
 8017d9a:	4618      	mov	r0, r3
 8017d9c:	3708      	adds	r7, #8
 8017d9e:	46bd      	mov	sp, r7
 8017da0:	bd80      	pop	{r7, pc}

08017da2 <system_free>:

static void
system_free(void *allocator_data, void *data)
{
 8017da2:	b580      	push	{r7, lr}
 8017da4:	b082      	sub	sp, #8
 8017da6:	af00      	add	r7, sp, #0
 8017da8:	6078      	str	r0, [r7, #4]
 8017daa:	6039      	str	r1, [r7, #0]
	free(data);
 8017dac:	6838      	ldr	r0, [r7, #0]
 8017dae:	f007 fd35 	bl	801f81c <free>
}
 8017db2:	bf00      	nop
 8017db4:	3708      	adds	r7, #8
 8017db6:	46bd      	mov	sp, r7
 8017db8:	bd80      	pop	{r7, pc}

08017dba <do_alloc>:

static inline void *
do_alloc(ProtobufCAllocator *allocator, size_t size)
{
 8017dba:	b580      	push	{r7, lr}
 8017dbc:	b082      	sub	sp, #8
 8017dbe:	af00      	add	r7, sp, #0
 8017dc0:	6078      	str	r0, [r7, #4]
 8017dc2:	6039      	str	r1, [r7, #0]
	return allocator->alloc(allocator->allocator_data, size);
 8017dc4:	687b      	ldr	r3, [r7, #4]
 8017dc6:	681b      	ldr	r3, [r3, #0]
 8017dc8:	687a      	ldr	r2, [r7, #4]
 8017dca:	6892      	ldr	r2, [r2, #8]
 8017dcc:	6839      	ldr	r1, [r7, #0]
 8017dce:	4610      	mov	r0, r2
 8017dd0:	4798      	blx	r3
 8017dd2:	4603      	mov	r3, r0
}
 8017dd4:	4618      	mov	r0, r3
 8017dd6:	3708      	adds	r7, #8
 8017dd8:	46bd      	mov	sp, r7
 8017dda:	bd80      	pop	{r7, pc}

08017ddc <do_free>:

static inline void
do_free(ProtobufCAllocator *allocator, void *data)
{
 8017ddc:	b580      	push	{r7, lr}
 8017dde:	b082      	sub	sp, #8
 8017de0:	af00      	add	r7, sp, #0
 8017de2:	6078      	str	r0, [r7, #4]
 8017de4:	6039      	str	r1, [r7, #0]
	if (data != NULL)
 8017de6:	683b      	ldr	r3, [r7, #0]
 8017de8:	2b00      	cmp	r3, #0
 8017dea:	d006      	beq.n	8017dfa <do_free+0x1e>
		allocator->free(allocator->allocator_data, data);
 8017dec:	687b      	ldr	r3, [r7, #4]
 8017dee:	685b      	ldr	r3, [r3, #4]
 8017df0:	687a      	ldr	r2, [r7, #4]
 8017df2:	6892      	ldr	r2, [r2, #8]
 8017df4:	6839      	ldr	r1, [r7, #0]
 8017df6:	4610      	mov	r0, r2
 8017df8:	4798      	blx	r3
}
 8017dfa:	bf00      	nop
 8017dfc:	3708      	adds	r7, #8
 8017dfe:	46bd      	mov	sp, r7
 8017e00:	bd80      	pop	{r7, pc}

08017e02 <get_tag_size>:
 * \return
 *      Number of bytes required.
 */
static inline size_t
get_tag_size(uint32_t number)
{
 8017e02:	b480      	push	{r7}
 8017e04:	b083      	sub	sp, #12
 8017e06:	af00      	add	r7, sp, #0
 8017e08:	6078      	str	r0, [r7, #4]
	if (number < (1UL << 4)) {
 8017e0a:	687b      	ldr	r3, [r7, #4]
 8017e0c:	2b0f      	cmp	r3, #15
 8017e0e:	d801      	bhi.n	8017e14 <get_tag_size+0x12>
		return 1;
 8017e10:	2301      	movs	r3, #1
 8017e12:	e012      	b.n	8017e3a <get_tag_size+0x38>
	} else if (number < (1UL << 11)) {
 8017e14:	687b      	ldr	r3, [r7, #4]
 8017e16:	f5b3 6f00 	cmp.w	r3, #2048	; 0x800
 8017e1a:	d201      	bcs.n	8017e20 <get_tag_size+0x1e>
		return 2;
 8017e1c:	2302      	movs	r3, #2
 8017e1e:	e00c      	b.n	8017e3a <get_tag_size+0x38>
	} else if (number < (1UL << 18)) {
 8017e20:	687b      	ldr	r3, [r7, #4]
 8017e22:	f5b3 2f80 	cmp.w	r3, #262144	; 0x40000
 8017e26:	d201      	bcs.n	8017e2c <get_tag_size+0x2a>
		return 3;
 8017e28:	2303      	movs	r3, #3
 8017e2a:	e006      	b.n	8017e3a <get_tag_size+0x38>
	} else if (number < (1UL << 25)) {
 8017e2c:	687b      	ldr	r3, [r7, #4]
 8017e2e:	f1b3 7f00 	cmp.w	r3, #33554432	; 0x2000000
 8017e32:	d201      	bcs.n	8017e38 <get_tag_size+0x36>
		return 4;
 8017e34:	2304      	movs	r3, #4
 8017e36:	e000      	b.n	8017e3a <get_tag_size+0x38>
	} else {
		return 5;
 8017e38:	2305      	movs	r3, #5
	}
}
 8017e3a:	4618      	mov	r0, r3
 8017e3c:	370c      	adds	r7, #12
 8017e3e:	46bd      	mov	sp, r7
 8017e40:	f85d 7b04 	ldr.w	r7, [sp], #4
 8017e44:	4770      	bx	lr

08017e46 <uint32_size>:
 * \return
 *      Number of bytes required.
 */
static inline size_t
uint32_size(uint32_t v)
{
 8017e46:	b480      	push	{r7}
 8017e48:	b083      	sub	sp, #12
 8017e4a:	af00      	add	r7, sp, #0
 8017e4c:	6078      	str	r0, [r7, #4]
	if (v < (1UL << 7)) {
 8017e4e:	687b      	ldr	r3, [r7, #4]
 8017e50:	2b7f      	cmp	r3, #127	; 0x7f
 8017e52:	d801      	bhi.n	8017e58 <uint32_size+0x12>
		return 1;
 8017e54:	2301      	movs	r3, #1
 8017e56:	e012      	b.n	8017e7e <uint32_size+0x38>
	} else if (v < (1UL << 14)) {
 8017e58:	687b      	ldr	r3, [r7, #4]
 8017e5a:	f5b3 4f80 	cmp.w	r3, #16384	; 0x4000
 8017e5e:	d201      	bcs.n	8017e64 <uint32_size+0x1e>
		return 2;
 8017e60:	2302      	movs	r3, #2
 8017e62:	e00c      	b.n	8017e7e <uint32_size+0x38>
	} else if (v < (1UL << 21)) {
 8017e64:	687b      	ldr	r3, [r7, #4]
 8017e66:	f5b3 1f00 	cmp.w	r3, #2097152	; 0x200000
 8017e6a:	d201      	bcs.n	8017e70 <uint32_size+0x2a>
		return 3;
 8017e6c:	2303      	movs	r3, #3
 8017e6e:	e006      	b.n	8017e7e <uint32_size+0x38>
	} else if (v < (1UL << 28)) {
 8017e70:	687b      	ldr	r3, [r7, #4]
 8017e72:	f1b3 5f80 	cmp.w	r3, #268435456	; 0x10000000
 8017e76:	d201      	bcs.n	8017e7c <uint32_size+0x36>
		return 4;
 8017e78:	2304      	movs	r3, #4
 8017e7a:	e000      	b.n	8017e7e <uint32_size+0x38>
	} else {
		return 5;
 8017e7c:	2305      	movs	r3, #5
	}
}
 8017e7e:	4618      	mov	r0, r3
 8017e80:	370c      	adds	r7, #12
 8017e82:	46bd      	mov	sp, r7
 8017e84:	f85d 7b04 	ldr.w	r7, [sp], #4
 8017e88:	4770      	bx	lr

08017e8a <int32_size>:
 * \return
 *      Number of bytes required.
 */
static inline size_t
int32_size(int32_t v)
{
 8017e8a:	b480      	push	{r7}
 8017e8c:	b083      	sub	sp, #12
 8017e8e:	af00      	add	r7, sp, #0
 8017e90:	6078      	str	r0, [r7, #4]
	if (v < 0) {
 8017e92:	687b      	ldr	r3, [r7, #4]
 8017e94:	2b00      	cmp	r3, #0
 8017e96:	da01      	bge.n	8017e9c <int32_size+0x12>
		return 10;
 8017e98:	230a      	movs	r3, #10
 8017e9a:	e017      	b.n	8017ecc <int32_size+0x42>
	} else if (v < (1L << 7)) {
 8017e9c:	687b      	ldr	r3, [r7, #4]
 8017e9e:	2b7f      	cmp	r3, #127	; 0x7f
 8017ea0:	dc01      	bgt.n	8017ea6 <int32_size+0x1c>
		return 1;
 8017ea2:	2301      	movs	r3, #1
 8017ea4:	e012      	b.n	8017ecc <int32_size+0x42>
	} else if (v < (1L << 14)) {
 8017ea6:	687b      	ldr	r3, [r7, #4]
 8017ea8:	f5b3 4f80 	cmp.w	r3, #16384	; 0x4000
 8017eac:	da01      	bge.n	8017eb2 <int32_size+0x28>
		return 2;
 8017eae:	2302      	movs	r3, #2
 8017eb0:	e00c      	b.n	8017ecc <int32_size+0x42>
	} else if (v < (1L << 21)) {
 8017eb2:	687b      	ldr	r3, [r7, #4]
 8017eb4:	f5b3 1f00 	cmp.w	r3, #2097152	; 0x200000
 8017eb8:	da01      	bge.n	8017ebe <int32_size+0x34>
		return 3;
 8017eba:	2303      	movs	r3, #3
 8017ebc:	e006      	b.n	8017ecc <int32_size+0x42>
	} else if (v < (1L << 28)) {
 8017ebe:	687b      	ldr	r3, [r7, #4]
 8017ec0:	f1b3 5f80 	cmp.w	r3, #268435456	; 0x10000000
 8017ec4:	da01      	bge.n	8017eca <int32_size+0x40>
		return 4;
 8017ec6:	2304      	movs	r3, #4
 8017ec8:	e000      	b.n	8017ecc <int32_size+0x42>
	} else {
		return 5;
 8017eca:	2305      	movs	r3, #5
	}
}
 8017ecc:	4618      	mov	r0, r3
 8017ece:	370c      	adds	r7, #12
 8017ed0:	46bd      	mov	sp, r7
 8017ed2:	f85d 7b04 	ldr.w	r7, [sp], #4
 8017ed6:	4770      	bx	lr

08017ed8 <zigzag32>:
 * \return
 *      ZigZag encoded integer.
 */
static inline uint32_t
zigzag32(int32_t v)
{
 8017ed8:	b480      	push	{r7}
 8017eda:	b083      	sub	sp, #12
 8017edc:	af00      	add	r7, sp, #0
 8017ede:	6078      	str	r0, [r7, #4]
	// Note:  the right-shift must be arithmetic
	// Note:  left shift must be unsigned because of overflow
	return ((uint32_t)(v) << 1) ^ (uint32_t)(v >> 31);
 8017ee0:	687b      	ldr	r3, [r7, #4]
 8017ee2:	005b      	lsls	r3, r3, #1
 8017ee4:	687a      	ldr	r2, [r7, #4]
 8017ee6:	17d2      	asrs	r2, r2, #31
 8017ee8:	4053      	eors	r3, r2
}
 8017eea:	4618      	mov	r0, r3
 8017eec:	370c      	adds	r7, #12
 8017eee:	46bd      	mov	sp, r7
 8017ef0:	f85d 7b04 	ldr.w	r7, [sp], #4
 8017ef4:	4770      	bx	lr

08017ef6 <sint32_size>:
 * \return
 *      Number of bytes required.
 */
static inline size_t
sint32_size(int32_t v)
{
 8017ef6:	b580      	push	{r7, lr}
 8017ef8:	b082      	sub	sp, #8
 8017efa:	af00      	add	r7, sp, #0
 8017efc:	6078      	str	r0, [r7, #4]
	return uint32_size(zigzag32(v));
 8017efe:	6878      	ldr	r0, [r7, #4]
 8017f00:	f7ff ffea 	bl	8017ed8 <zigzag32>
 8017f04:	4603      	mov	r3, r0
 8017f06:	4618      	mov	r0, r3
 8017f08:	f7ff ff9d 	bl	8017e46 <uint32_size>
 8017f0c:	4603      	mov	r3, r0
}
 8017f0e:	4618      	mov	r0, r3
 8017f10:	3708      	adds	r7, #8
 8017f12:	46bd      	mov	sp, r7
 8017f14:	bd80      	pop	{r7, pc}

08017f16 <uint64_size>:
 * \return
 *      Number of bytes required.
 */
static inline size_t
uint64_size(uint64_t v)
{
 8017f16:	b580      	push	{r7, lr}
 8017f18:	b084      	sub	sp, #16
 8017f1a:	af00      	add	r7, sp, #0
 8017f1c:	e9c7 0100 	strd	r0, r1, [r7]
	uint32_t upper_v = (uint32_t) (v >> 32);
 8017f20:	e9d7 0100 	ldrd	r0, r1, [r7]
 8017f24:	f04f 0200 	mov.w	r2, #0
 8017f28:	f04f 0300 	mov.w	r3, #0
 8017f2c:	000a      	movs	r2, r1
 8017f2e:	2300      	movs	r3, #0
 8017f30:	4613      	mov	r3, r2
 8017f32:	60fb      	str	r3, [r7, #12]

	if (upper_v == 0) {
 8017f34:	68fb      	ldr	r3, [r7, #12]
 8017f36:	2b00      	cmp	r3, #0
 8017f38:	d105      	bne.n	8017f46 <uint64_size+0x30>
		return uint32_size((uint32_t) v);
 8017f3a:	683b      	ldr	r3, [r7, #0]
 8017f3c:	4618      	mov	r0, r3
 8017f3e:	f7ff ff82 	bl	8017e46 <uint32_size>
 8017f42:	4603      	mov	r3, r0
 8017f44:	e01c      	b.n	8017f80 <uint64_size+0x6a>
	} else if (upper_v < (1UL << 3)) {
 8017f46:	68fb      	ldr	r3, [r7, #12]
 8017f48:	2b07      	cmp	r3, #7
 8017f4a:	d801      	bhi.n	8017f50 <uint64_size+0x3a>
		return 5;
 8017f4c:	2305      	movs	r3, #5
 8017f4e:	e017      	b.n	8017f80 <uint64_size+0x6a>
	} else if (upper_v < (1UL << 10)) {
 8017f50:	68fb      	ldr	r3, [r7, #12]
 8017f52:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
 8017f56:	d201      	bcs.n	8017f5c <uint64_size+0x46>
		return 6;
 8017f58:	2306      	movs	r3, #6
 8017f5a:	e011      	b.n	8017f80 <uint64_size+0x6a>
	} else if (upper_v < (1UL << 17)) {
 8017f5c:	68fb      	ldr	r3, [r7, #12]
 8017f5e:	f5b3 3f00 	cmp.w	r3, #131072	; 0x20000
 8017f62:	d201      	bcs.n	8017f68 <uint64_size+0x52>
		return 7;
 8017f64:	2307      	movs	r3, #7
 8017f66:	e00b      	b.n	8017f80 <uint64_size+0x6a>
	} else if (upper_v < (1UL << 24)) {
 8017f68:	68fb      	ldr	r3, [r7, #12]
 8017f6a:	f1b3 7f80 	cmp.w	r3, #16777216	; 0x1000000
 8017f6e:	d201      	bcs.n	8017f74 <uint64_size+0x5e>
		return 8;
 8017f70:	2308      	movs	r3, #8
 8017f72:	e005      	b.n	8017f80 <uint64_size+0x6a>
	} else if (upper_v < (1UL << 31)) {
 8017f74:	68fb      	ldr	r3, [r7, #12]
 8017f76:	2b00      	cmp	r3, #0
 8017f78:	db01      	blt.n	8017f7e <uint64_size+0x68>
		return 9;
 8017f7a:	2309      	movs	r3, #9
 8017f7c:	e000      	b.n	8017f80 <uint64_size+0x6a>
	} else {
		return 10;
 8017f7e:	230a      	movs	r3, #10
	}
}
 8017f80:	4618      	mov	r0, r3
 8017f82:	3710      	adds	r7, #16
 8017f84:	46bd      	mov	sp, r7
 8017f86:	bd80      	pop	{r7, pc}

08017f88 <zigzag64>:
 * \return
 *      ZigZag encoded integer.
 */
static inline uint64_t
zigzag64(int64_t v)
{
 8017f88:	e92d 03b0 	stmdb	sp!, {r4, r5, r7, r8, r9}
 8017f8c:	b083      	sub	sp, #12
 8017f8e:	af00      	add	r7, sp, #0
 8017f90:	e9c7 0100 	strd	r0, r1, [r7]
	// Note:  the right-shift must be arithmetic
	// Note:  left shift must be unsigned because of overflow
	return ((uint64_t)(v) << 1) ^ (uint64_t)(v >> 63);
 8017f94:	e9d7 2300 	ldrd	r2, r3, [r7]
 8017f98:	eb12 0802 	adds.w	r8, r2, r2
 8017f9c:	eb43 0903 	adc.w	r9, r3, r3
 8017fa0:	e9d7 0100 	ldrd	r0, r1, [r7]
 8017fa4:	f04f 0200 	mov.w	r2, #0
 8017fa8:	f04f 0300 	mov.w	r3, #0
 8017fac:	17ca      	asrs	r2, r1, #31
 8017fae:	17cb      	asrs	r3, r1, #31
 8017fb0:	ea88 0402 	eor.w	r4, r8, r2
 8017fb4:	ea89 0503 	eor.w	r5, r9, r3
 8017fb8:	4622      	mov	r2, r4
 8017fba:	462b      	mov	r3, r5
}
 8017fbc:	4610      	mov	r0, r2
 8017fbe:	4619      	mov	r1, r3
 8017fc0:	370c      	adds	r7, #12
 8017fc2:	46bd      	mov	sp, r7
 8017fc4:	e8bd 03b0 	ldmia.w	sp!, {r4, r5, r7, r8, r9}
 8017fc8:	4770      	bx	lr

08017fca <sint64_size>:
 * \return
 *      Number of bytes required.
 */
static inline size_t
sint64_size(int64_t v)
{
 8017fca:	b580      	push	{r7, lr}
 8017fcc:	b082      	sub	sp, #8
 8017fce:	af00      	add	r7, sp, #0
 8017fd0:	e9c7 0100 	strd	r0, r1, [r7]
	return uint64_size(zigzag64(v));
 8017fd4:	e9d7 0100 	ldrd	r0, r1, [r7]
 8017fd8:	f7ff ffd6 	bl	8017f88 <zigzag64>
 8017fdc:	4602      	mov	r2, r0
 8017fde:	460b      	mov	r3, r1
 8017fe0:	4610      	mov	r0, r2
 8017fe2:	4619      	mov	r1, r3
 8017fe4:	f7ff ff97 	bl	8017f16 <uint64_size>
 8017fe8:	4603      	mov	r3, r0
}
 8017fea:	4618      	mov	r0, r3
 8017fec:	3708      	adds	r7, #8
 8017fee:	46bd      	mov	sp, r7
 8017ff0:	bd80      	pop	{r7, pc}
	...

08017ff4 <required_field_get_packed_size>:
 *      Number of bytes required.
 */
static size_t
required_field_get_packed_size(const ProtobufCFieldDescriptor *field,
			       const void *member)
{
 8017ff4:	b580      	push	{r7, lr}
 8017ff6:	b088      	sub	sp, #32
 8017ff8:	af00      	add	r7, sp, #0
 8017ffa:	6078      	str	r0, [r7, #4]
 8017ffc:	6039      	str	r1, [r7, #0]
	size_t rv = get_tag_size(field->id);
 8017ffe:	687b      	ldr	r3, [r7, #4]
 8018000:	685b      	ldr	r3, [r3, #4]
 8018002:	4618      	mov	r0, r3
 8018004:	f7ff fefd 	bl	8017e02 <get_tag_size>
 8018008:	61f8      	str	r0, [r7, #28]

	switch (field->type) {
 801800a:	687b      	ldr	r3, [r7, #4]
 801800c:	7a5b      	ldrb	r3, [r3, #9]
 801800e:	2b10      	cmp	r3, #16
 8018010:	f200 809e 	bhi.w	8018150 <required_field_get_packed_size+0x15c>
 8018014:	a201      	add	r2, pc, #4	; (adr r2, 801801c <required_field_get_packed_size+0x28>)
 8018016:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 801801a:	bf00      	nop
 801801c:	08018073 	.word	0x08018073
 8018020:	08018061 	.word	0x08018061
 8018024:	080180c3 	.word	0x080180c3
 8018028:	080180ad 	.word	0x080180ad
 801802c:	08018097 	.word	0x08018097
 8018030:	080180c9 	.word	0x080180c9
 8018034:	08018085 	.word	0x08018085
 8018038:	080180c3 	.word	0x080180c3
 801803c:	080180ad 	.word	0x080180ad
 8018040:	080180c9 	.word	0x080180c9
 8018044:	080180d5 	.word	0x080180d5
 8018048:	080180db 	.word	0x080180db
 801804c:	080180cf 	.word	0x080180cf
 8018050:	08018073 	.word	0x08018073
 8018054:	080180e1 	.word	0x080180e1
 8018058:	0801810d 	.word	0x0801810d
 801805c:	08018125 	.word	0x08018125
	case PROTOBUF_C_TYPE_SINT32:
		return rv + sint32_size(*(const int32_t *) member);
 8018060:	683b      	ldr	r3, [r7, #0]
 8018062:	681b      	ldr	r3, [r3, #0]
 8018064:	4618      	mov	r0, r3
 8018066:	f7ff ff46 	bl	8017ef6 <sint32_size>
 801806a:	4602      	mov	r2, r0
 801806c:	69fb      	ldr	r3, [r7, #28]
 801806e:	4413      	add	r3, r2
 8018070:	e075      	b.n	801815e <required_field_get_packed_size+0x16a>
	case PROTOBUF_C_TYPE_ENUM:
	case PROTOBUF_C_TYPE_INT32:
		return rv + int32_size(*(const int32_t *) member);
 8018072:	683b      	ldr	r3, [r7, #0]
 8018074:	681b      	ldr	r3, [r3, #0]
 8018076:	4618      	mov	r0, r3
 8018078:	f7ff ff07 	bl	8017e8a <int32_size>
 801807c:	4602      	mov	r2, r0
 801807e:	69fb      	ldr	r3, [r7, #28]
 8018080:	4413      	add	r3, r2
 8018082:	e06c      	b.n	801815e <required_field_get_packed_size+0x16a>
	case PROTOBUF_C_TYPE_UINT32:
		return rv + uint32_size(*(const uint32_t *) member);
 8018084:	683b      	ldr	r3, [r7, #0]
 8018086:	681b      	ldr	r3, [r3, #0]
 8018088:	4618      	mov	r0, r3
 801808a:	f7ff fedc 	bl	8017e46 <uint32_size>
 801808e:	4602      	mov	r2, r0
 8018090:	69fb      	ldr	r3, [r7, #28]
 8018092:	4413      	add	r3, r2
 8018094:	e063      	b.n	801815e <required_field_get_packed_size+0x16a>
	case PROTOBUF_C_TYPE_SINT64:
		return rv + sint64_size(*(const int64_t *) member);
 8018096:	683b      	ldr	r3, [r7, #0]
 8018098:	e9d3 2300 	ldrd	r2, r3, [r3]
 801809c:	4610      	mov	r0, r2
 801809e:	4619      	mov	r1, r3
 80180a0:	f7ff ff93 	bl	8017fca <sint64_size>
 80180a4:	4602      	mov	r2, r0
 80180a6:	69fb      	ldr	r3, [r7, #28]
 80180a8:	4413      	add	r3, r2
 80180aa:	e058      	b.n	801815e <required_field_get_packed_size+0x16a>
	case PROTOBUF_C_TYPE_INT64:
	case PROTOBUF_C_TYPE_UINT64:
		return rv + uint64_size(*(const uint64_t *) member);
 80180ac:	683b      	ldr	r3, [r7, #0]
 80180ae:	e9d3 2300 	ldrd	r2, r3, [r3]
 80180b2:	4610      	mov	r0, r2
 80180b4:	4619      	mov	r1, r3
 80180b6:	f7ff ff2e 	bl	8017f16 <uint64_size>
 80180ba:	4602      	mov	r2, r0
 80180bc:	69fb      	ldr	r3, [r7, #28]
 80180be:	4413      	add	r3, r2
 80180c0:	e04d      	b.n	801815e <required_field_get_packed_size+0x16a>
	case PROTOBUF_C_TYPE_SFIXED32:
	case PROTOBUF_C_TYPE_FIXED32:
		return rv + 4;
 80180c2:	69fb      	ldr	r3, [r7, #28]
 80180c4:	3304      	adds	r3, #4
 80180c6:	e04a      	b.n	801815e <required_field_get_packed_size+0x16a>
	case PROTOBUF_C_TYPE_SFIXED64:
	case PROTOBUF_C_TYPE_FIXED64:
		return rv + 8;
 80180c8:	69fb      	ldr	r3, [r7, #28]
 80180ca:	3308      	adds	r3, #8
 80180cc:	e047      	b.n	801815e <required_field_get_packed_size+0x16a>
	case PROTOBUF_C_TYPE_BOOL:
		return rv + 1;
 80180ce:	69fb      	ldr	r3, [r7, #28]
 80180d0:	3301      	adds	r3, #1
 80180d2:	e044      	b.n	801815e <required_field_get_packed_size+0x16a>
	case PROTOBUF_C_TYPE_FLOAT:
		return rv + 4;
 80180d4:	69fb      	ldr	r3, [r7, #28]
 80180d6:	3304      	adds	r3, #4
 80180d8:	e041      	b.n	801815e <required_field_get_packed_size+0x16a>
	case PROTOBUF_C_TYPE_DOUBLE:
		return rv + 8;
 80180da:	69fb      	ldr	r3, [r7, #28]
 80180dc:	3308      	adds	r3, #8
 80180de:	e03e      	b.n	801815e <required_field_get_packed_size+0x16a>
	case PROTOBUF_C_TYPE_STRING: {
		const char *str = *(char * const *) member;
 80180e0:	683b      	ldr	r3, [r7, #0]
 80180e2:	681b      	ldr	r3, [r3, #0]
 80180e4:	60fb      	str	r3, [r7, #12]
		size_t len = str ? strlen(str) : 0;
 80180e6:	68fb      	ldr	r3, [r7, #12]
 80180e8:	2b00      	cmp	r3, #0
 80180ea:	d004      	beq.n	80180f6 <required_field_get_packed_size+0x102>
 80180ec:	68f8      	ldr	r0, [r7, #12]
 80180ee:	f7e8 fa1d 	bl	800052c <strlen>
 80180f2:	4603      	mov	r3, r0
 80180f4:	e000      	b.n	80180f8 <required_field_get_packed_size+0x104>
 80180f6:	2300      	movs	r3, #0
 80180f8:	60bb      	str	r3, [r7, #8]
		return rv + uint32_size(len) + len;
 80180fa:	68b8      	ldr	r0, [r7, #8]
 80180fc:	f7ff fea3 	bl	8017e46 <uint32_size>
 8018100:	4602      	mov	r2, r0
 8018102:	69fb      	ldr	r3, [r7, #28]
 8018104:	441a      	add	r2, r3
 8018106:	68bb      	ldr	r3, [r7, #8]
 8018108:	4413      	add	r3, r2
 801810a:	e028      	b.n	801815e <required_field_get_packed_size+0x16a>
	}
	case PROTOBUF_C_TYPE_BYTES: {
		size_t len = ((const ProtobufCBinaryData *) member)->len;
 801810c:	683b      	ldr	r3, [r7, #0]
 801810e:	681b      	ldr	r3, [r3, #0]
 8018110:	613b      	str	r3, [r7, #16]
		return rv + uint32_size(len) + len;
 8018112:	6938      	ldr	r0, [r7, #16]
 8018114:	f7ff fe97 	bl	8017e46 <uint32_size>
 8018118:	4602      	mov	r2, r0
 801811a:	69fb      	ldr	r3, [r7, #28]
 801811c:	441a      	add	r2, r3
 801811e:	693b      	ldr	r3, [r7, #16]
 8018120:	4413      	add	r3, r2
 8018122:	e01c      	b.n	801815e <required_field_get_packed_size+0x16a>
	}
	case PROTOBUF_C_TYPE_MESSAGE: {
		const ProtobufCMessage *msg = *(ProtobufCMessage * const *) member;
 8018124:	683b      	ldr	r3, [r7, #0]
 8018126:	681b      	ldr	r3, [r3, #0]
 8018128:	61bb      	str	r3, [r7, #24]
		size_t subrv = msg ? protobuf_c_message_get_packed_size(msg) : 0;
 801812a:	69bb      	ldr	r3, [r7, #24]
 801812c:	2b00      	cmp	r3, #0
 801812e:	d004      	beq.n	801813a <required_field_get_packed_size+0x146>
 8018130:	69b8      	ldr	r0, [r7, #24]
 8018132:	f000 fa63 	bl	80185fc <protobuf_c_message_get_packed_size>
 8018136:	4603      	mov	r3, r0
 8018138:	e000      	b.n	801813c <required_field_get_packed_size+0x148>
 801813a:	2300      	movs	r3, #0
 801813c:	617b      	str	r3, [r7, #20]
		return rv + uint32_size(subrv) + subrv;
 801813e:	6978      	ldr	r0, [r7, #20]
 8018140:	f7ff fe81 	bl	8017e46 <uint32_size>
 8018144:	4602      	mov	r2, r0
 8018146:	69fb      	ldr	r3, [r7, #28]
 8018148:	441a      	add	r2, r3
 801814a:	697b      	ldr	r3, [r7, #20]
 801814c:	4413      	add	r3, r2
 801814e:	e006      	b.n	801815e <required_field_get_packed_size+0x16a>
	}
	}
	PROTOBUF_C__ASSERT_NOT_REACHED();
 8018150:	4b05      	ldr	r3, [pc, #20]	; (8018168 <required_field_get_packed_size+0x174>)
 8018152:	4a06      	ldr	r2, [pc, #24]	; (801816c <required_field_get_packed_size+0x178>)
 8018154:	f240 11c9 	movw	r1, #457	; 0x1c9
 8018158:	4805      	ldr	r0, [pc, #20]	; (8018170 <required_field_get_packed_size+0x17c>)
 801815a:	f007 fafd 	bl	801f758 <__assert_func>
	return 0;
}
 801815e:	4618      	mov	r0, r3
 8018160:	3720      	adds	r7, #32
 8018162:	46bd      	mov	sp, r7
 8018164:	bd80      	pop	{r7, pc}
 8018166:	bf00      	nop
 8018168:	080242e4 	.word	0x080242e4
 801816c:	0802869c 	.word	0x0802869c
 8018170:	080242e8 	.word	0x080242e8

08018174 <oneof_field_get_packed_size>:
 */
static size_t
oneof_field_get_packed_size(const ProtobufCFieldDescriptor *field,
			    uint32_t oneof_case,
			    const void *member)
{
 8018174:	b580      	push	{r7, lr}
 8018176:	b086      	sub	sp, #24
 8018178:	af00      	add	r7, sp, #0
 801817a:	60f8      	str	r0, [r7, #12]
 801817c:	60b9      	str	r1, [r7, #8]
 801817e:	607a      	str	r2, [r7, #4]
	if (oneof_case != field->id) {
 8018180:	68fb      	ldr	r3, [r7, #12]
 8018182:	685b      	ldr	r3, [r3, #4]
 8018184:	68ba      	ldr	r2, [r7, #8]
 8018186:	429a      	cmp	r2, r3
 8018188:	d001      	beq.n	801818e <oneof_field_get_packed_size+0x1a>
		return 0;
 801818a:	2300      	movs	r3, #0
 801818c:	e019      	b.n	80181c2 <oneof_field_get_packed_size+0x4e>
	}
	if (field->type == PROTOBUF_C_TYPE_MESSAGE ||
 801818e:	68fb      	ldr	r3, [r7, #12]
 8018190:	7a5b      	ldrb	r3, [r3, #9]
 8018192:	2b10      	cmp	r3, #16
 8018194:	d003      	beq.n	801819e <oneof_field_get_packed_size+0x2a>
	    field->type == PROTOBUF_C_TYPE_STRING)
 8018196:	68fb      	ldr	r3, [r7, #12]
 8018198:	7a5b      	ldrb	r3, [r3, #9]
	if (field->type == PROTOBUF_C_TYPE_MESSAGE ||
 801819a:	2b0e      	cmp	r3, #14
 801819c:	d10c      	bne.n	80181b8 <oneof_field_get_packed_size+0x44>
	{
		const void *ptr = *(const void * const *) member;
 801819e:	687b      	ldr	r3, [r7, #4]
 80181a0:	681b      	ldr	r3, [r3, #0]
 80181a2:	617b      	str	r3, [r7, #20]
		if (ptr == NULL || ptr == field->default_value)
 80181a4:	697b      	ldr	r3, [r7, #20]
 80181a6:	2b00      	cmp	r3, #0
 80181a8:	d004      	beq.n	80181b4 <oneof_field_get_packed_size+0x40>
 80181aa:	68fb      	ldr	r3, [r7, #12]
 80181ac:	699b      	ldr	r3, [r3, #24]
 80181ae:	697a      	ldr	r2, [r7, #20]
 80181b0:	429a      	cmp	r2, r3
 80181b2:	d101      	bne.n	80181b8 <oneof_field_get_packed_size+0x44>
			return 0;
 80181b4:	2300      	movs	r3, #0
 80181b6:	e004      	b.n	80181c2 <oneof_field_get_packed_size+0x4e>
	}
	return required_field_get_packed_size(field, member);
 80181b8:	6879      	ldr	r1, [r7, #4]
 80181ba:	68f8      	ldr	r0, [r7, #12]
 80181bc:	f7ff ff1a 	bl	8017ff4 <required_field_get_packed_size>
 80181c0:	4603      	mov	r3, r0
}
 80181c2:	4618      	mov	r0, r3
 80181c4:	3718      	adds	r7, #24
 80181c6:	46bd      	mov	sp, r7
 80181c8:	bd80      	pop	{r7, pc}

080181ca <optional_field_get_packed_size>:
 */
static size_t
optional_field_get_packed_size(const ProtobufCFieldDescriptor *field,
			       const protobuf_c_boolean has,
			       const void *member)
{
 80181ca:	b580      	push	{r7, lr}
 80181cc:	b086      	sub	sp, #24
 80181ce:	af00      	add	r7, sp, #0
 80181d0:	60f8      	str	r0, [r7, #12]
 80181d2:	60b9      	str	r1, [r7, #8]
 80181d4:	607a      	str	r2, [r7, #4]
	if (field->type == PROTOBUF_C_TYPE_MESSAGE ||
 80181d6:	68fb      	ldr	r3, [r7, #12]
 80181d8:	7a5b      	ldrb	r3, [r3, #9]
 80181da:	2b10      	cmp	r3, #16
 80181dc:	d003      	beq.n	80181e6 <optional_field_get_packed_size+0x1c>
	    field->type == PROTOBUF_C_TYPE_STRING)
 80181de:	68fb      	ldr	r3, [r7, #12]
 80181e0:	7a5b      	ldrb	r3, [r3, #9]
	if (field->type == PROTOBUF_C_TYPE_MESSAGE ||
 80181e2:	2b0e      	cmp	r3, #14
 80181e4:	d10c      	bne.n	8018200 <optional_field_get_packed_size+0x36>
	{
		const void *ptr = *(const void * const *) member;
 80181e6:	687b      	ldr	r3, [r7, #4]
 80181e8:	681b      	ldr	r3, [r3, #0]
 80181ea:	617b      	str	r3, [r7, #20]
		if (ptr == NULL || ptr == field->default_value)
 80181ec:	697b      	ldr	r3, [r7, #20]
 80181ee:	2b00      	cmp	r3, #0
 80181f0:	d004      	beq.n	80181fc <optional_field_get_packed_size+0x32>
 80181f2:	68fb      	ldr	r3, [r7, #12]
 80181f4:	699b      	ldr	r3, [r3, #24]
 80181f6:	697a      	ldr	r2, [r7, #20]
 80181f8:	429a      	cmp	r2, r3
 80181fa:	d106      	bne.n	801820a <optional_field_get_packed_size+0x40>
			return 0;
 80181fc:	2300      	movs	r3, #0
 80181fe:	e00a      	b.n	8018216 <optional_field_get_packed_size+0x4c>
	} else {
		if (!has)
 8018200:	68bb      	ldr	r3, [r7, #8]
 8018202:	2b00      	cmp	r3, #0
 8018204:	d102      	bne.n	801820c <optional_field_get_packed_size+0x42>
			return 0;
 8018206:	2300      	movs	r3, #0
 8018208:	e005      	b.n	8018216 <optional_field_get_packed_size+0x4c>
	{
 801820a:	bf00      	nop
	}
	return required_field_get_packed_size(field, member);
 801820c:	6879      	ldr	r1, [r7, #4]
 801820e:	68f8      	ldr	r0, [r7, #12]
 8018210:	f7ff fef0 	bl	8017ff4 <required_field_get_packed_size>
 8018214:	4603      	mov	r3, r0
}
 8018216:	4618      	mov	r0, r3
 8018218:	3718      	adds	r7, #24
 801821a:	46bd      	mov	sp, r7
 801821c:	bd80      	pop	{r7, pc}
	...

08018220 <field_is_zeroish>:

static protobuf_c_boolean
field_is_zeroish(const ProtobufCFieldDescriptor *field,
		 const void *member)
{
 8018220:	b480      	push	{r7}
 8018222:	b085      	sub	sp, #20
 8018224:	af00      	add	r7, sp, #0
 8018226:	6078      	str	r0, [r7, #4]
 8018228:	6039      	str	r1, [r7, #0]
	protobuf_c_boolean ret = FALSE;
 801822a:	2300      	movs	r3, #0
 801822c:	60fb      	str	r3, [r7, #12]

	switch (field->type) {
 801822e:	687b      	ldr	r3, [r7, #4]
 8018230:	7a5b      	ldrb	r3, [r3, #9]
 8018232:	2b10      	cmp	r3, #16
 8018234:	d872      	bhi.n	801831c <field_is_zeroish+0xfc>
 8018236:	a201      	add	r2, pc, #4	; (adr r2, 801823c <field_is_zeroish+0x1c>)
 8018238:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 801823c:	08018293 	.word	0x08018293
 8018240:	08018293 	.word	0x08018293
 8018244:	08018293 	.word	0x08018293
 8018248:	080182a5 	.word	0x080182a5
 801824c:	080182a5 	.word	0x080182a5
 8018250:	080182a5 	.word	0x080182a5
 8018254:	08018293 	.word	0x08018293
 8018258:	08018293 	.word	0x08018293
 801825c:	080182a5 	.word	0x080182a5
 8018260:	080182a5 	.word	0x080182a5
 8018264:	080182bb 	.word	0x080182bb
 8018268:	080182d5 	.word	0x080182d5
 801826c:	08018281 	.word	0x08018281
 8018270:	08018293 	.word	0x08018293
 8018274:	080182ef 	.word	0x080182ef
 8018278:	0801830b 	.word	0x0801830b
 801827c:	0801830b 	.word	0x0801830b
	case PROTOBUF_C_TYPE_BOOL:
		ret = (0 == *(const protobuf_c_boolean *) member);
 8018280:	683b      	ldr	r3, [r7, #0]
 8018282:	681b      	ldr	r3, [r3, #0]
 8018284:	2b00      	cmp	r3, #0
 8018286:	bf0c      	ite	eq
 8018288:	2301      	moveq	r3, #1
 801828a:	2300      	movne	r3, #0
 801828c:	b2db      	uxtb	r3, r3
 801828e:	60fb      	str	r3, [r7, #12]
		break;
 8018290:	e047      	b.n	8018322 <field_is_zeroish+0x102>
	case PROTOBUF_C_TYPE_SINT32:
	case PROTOBUF_C_TYPE_INT32:
	case PROTOBUF_C_TYPE_UINT32:
	case PROTOBUF_C_TYPE_SFIXED32:
	case PROTOBUF_C_TYPE_FIXED32:
		ret = (0 == *(const uint32_t *) member);
 8018292:	683b      	ldr	r3, [r7, #0]
 8018294:	681b      	ldr	r3, [r3, #0]
 8018296:	2b00      	cmp	r3, #0
 8018298:	bf0c      	ite	eq
 801829a:	2301      	moveq	r3, #1
 801829c:	2300      	movne	r3, #0
 801829e:	b2db      	uxtb	r3, r3
 80182a0:	60fb      	str	r3, [r7, #12]
		break;
 80182a2:	e03e      	b.n	8018322 <field_is_zeroish+0x102>
	case PROTOBUF_C_TYPE_SINT64:
	case PROTOBUF_C_TYPE_INT64:
	case PROTOBUF_C_TYPE_UINT64:
	case PROTOBUF_C_TYPE_SFIXED64:
	case PROTOBUF_C_TYPE_FIXED64:
		ret = (0 == *(const uint64_t *) member);
 80182a4:	683b      	ldr	r3, [r7, #0]
 80182a6:	e9d3 2300 	ldrd	r2, r3, [r3]
 80182aa:	4313      	orrs	r3, r2
 80182ac:	2b00      	cmp	r3, #0
 80182ae:	bf0c      	ite	eq
 80182b0:	2301      	moveq	r3, #1
 80182b2:	2300      	movne	r3, #0
 80182b4:	b2db      	uxtb	r3, r3
 80182b6:	60fb      	str	r3, [r7, #12]
		break;
 80182b8:	e033      	b.n	8018322 <field_is_zeroish+0x102>
	case PROTOBUF_C_TYPE_FLOAT:
		ret = (0 == *(const float *) member);
 80182ba:	683b      	ldr	r3, [r7, #0]
 80182bc:	edd3 7a00 	vldr	s15, [r3]
 80182c0:	eef5 7a40 	vcmp.f32	s15, #0.0
 80182c4:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80182c8:	bf0c      	ite	eq
 80182ca:	2301      	moveq	r3, #1
 80182cc:	2300      	movne	r3, #0
 80182ce:	b2db      	uxtb	r3, r3
 80182d0:	60fb      	str	r3, [r7, #12]
		break;
 80182d2:	e026      	b.n	8018322 <field_is_zeroish+0x102>
	case PROTOBUF_C_TYPE_DOUBLE:
		ret = (0 == *(const double *) member);
 80182d4:	683b      	ldr	r3, [r7, #0]
 80182d6:	ed93 7b00 	vldr	d7, [r3]
 80182da:	eeb5 7b40 	vcmp.f64	d7, #0.0
 80182de:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80182e2:	bf0c      	ite	eq
 80182e4:	2301      	moveq	r3, #1
 80182e6:	2300      	movne	r3, #0
 80182e8:	b2db      	uxtb	r3, r3
 80182ea:	60fb      	str	r3, [r7, #12]
		break;
 80182ec:	e019      	b.n	8018322 <field_is_zeroish+0x102>
	case PROTOBUF_C_TYPE_STRING:
		ret = (NULL == *(const char * const *) member) ||
 80182ee:	683b      	ldr	r3, [r7, #0]
 80182f0:	681b      	ldr	r3, [r3, #0]
 80182f2:	2b00      	cmp	r3, #0
 80182f4:	d004      	beq.n	8018300 <field_is_zeroish+0xe0>
		      ('\0' == **(const char * const *) member);
 80182f6:	683b      	ldr	r3, [r7, #0]
 80182f8:	681b      	ldr	r3, [r3, #0]
 80182fa:	781b      	ldrb	r3, [r3, #0]
		ret = (NULL == *(const char * const *) member) ||
 80182fc:	2b00      	cmp	r3, #0
 80182fe:	d101      	bne.n	8018304 <field_is_zeroish+0xe4>
 8018300:	2301      	movs	r3, #1
 8018302:	e000      	b.n	8018306 <field_is_zeroish+0xe6>
 8018304:	2300      	movs	r3, #0
 8018306:	60fb      	str	r3, [r7, #12]
		break;
 8018308:	e00b      	b.n	8018322 <field_is_zeroish+0x102>
	case PROTOBUF_C_TYPE_BYTES:
	case PROTOBUF_C_TYPE_MESSAGE:
		ret = (NULL == *(const void * const *) member);
 801830a:	683b      	ldr	r3, [r7, #0]
 801830c:	681b      	ldr	r3, [r3, #0]
 801830e:	2b00      	cmp	r3, #0
 8018310:	bf0c      	ite	eq
 8018312:	2301      	moveq	r3, #1
 8018314:	2300      	movne	r3, #0
 8018316:	b2db      	uxtb	r3, r3
 8018318:	60fb      	str	r3, [r7, #12]
		break;
 801831a:	e002      	b.n	8018322 <field_is_zeroish+0x102>
	default:
		ret = TRUE;
 801831c:	2301      	movs	r3, #1
 801831e:	60fb      	str	r3, [r7, #12]
		break;
 8018320:	bf00      	nop
	}

	return ret;
 8018322:	68fb      	ldr	r3, [r7, #12]
}
 8018324:	4618      	mov	r0, r3
 8018326:	3714      	adds	r7, #20
 8018328:	46bd      	mov	sp, r7
 801832a:	f85d 7b04 	ldr.w	r7, [sp], #4
 801832e:	4770      	bx	lr

08018330 <unlabeled_field_get_packed_size>:
 *      Number of bytes required.
 */
static size_t
unlabeled_field_get_packed_size(const ProtobufCFieldDescriptor *field,
				const void *member)
{
 8018330:	b580      	push	{r7, lr}
 8018332:	b082      	sub	sp, #8
 8018334:	af00      	add	r7, sp, #0
 8018336:	6078      	str	r0, [r7, #4]
 8018338:	6039      	str	r1, [r7, #0]
	if (field_is_zeroish(field, member))
 801833a:	6839      	ldr	r1, [r7, #0]
 801833c:	6878      	ldr	r0, [r7, #4]
 801833e:	f7ff ff6f 	bl	8018220 <field_is_zeroish>
 8018342:	4603      	mov	r3, r0
 8018344:	2b00      	cmp	r3, #0
 8018346:	d001      	beq.n	801834c <unlabeled_field_get_packed_size+0x1c>
		return 0;
 8018348:	2300      	movs	r3, #0
 801834a:	e004      	b.n	8018356 <unlabeled_field_get_packed_size+0x26>
	return required_field_get_packed_size(field, member);
 801834c:	6839      	ldr	r1, [r7, #0]
 801834e:	6878      	ldr	r0, [r7, #4]
 8018350:	f7ff fe50 	bl	8017ff4 <required_field_get_packed_size>
 8018354:	4603      	mov	r3, r0
}
 8018356:	4618      	mov	r0, r3
 8018358:	3708      	adds	r7, #8
 801835a:	46bd      	mov	sp, r7
 801835c:	bd80      	pop	{r7, pc}
	...

08018360 <repeated_field_get_packed_size>:
 *      Number of bytes required.
 */
static size_t
repeated_field_get_packed_size(const ProtobufCFieldDescriptor *field,
			       size_t count, const void *member)
{
 8018360:	b580      	push	{r7, lr}
 8018362:	b08c      	sub	sp, #48	; 0x30
 8018364:	af00      	add	r7, sp, #0
 8018366:	60f8      	str	r0, [r7, #12]
 8018368:	60b9      	str	r1, [r7, #8]
 801836a:	607a      	str	r2, [r7, #4]
	size_t header_size;
	size_t rv = 0;
 801836c:	2300      	movs	r3, #0
 801836e:	62bb      	str	r3, [r7, #40]	; 0x28
	unsigned i;
	void *array = *(void * const *) member;
 8018370:	687b      	ldr	r3, [r7, #4]
 8018372:	681b      	ldr	r3, [r3, #0]
 8018374:	623b      	str	r3, [r7, #32]

	if (count == 0)
 8018376:	68bb      	ldr	r3, [r7, #8]
 8018378:	2b00      	cmp	r3, #0
 801837a:	d101      	bne.n	8018380 <repeated_field_get_packed_size+0x20>
		return 0;
 801837c:	2300      	movs	r3, #0
 801837e:	e127      	b.n	80185d0 <repeated_field_get_packed_size+0x270>
	header_size = get_tag_size(field->id);
 8018380:	68fb      	ldr	r3, [r7, #12]
 8018382:	685b      	ldr	r3, [r3, #4]
 8018384:	4618      	mov	r0, r3
 8018386:	f7ff fd3c 	bl	8017e02 <get_tag_size>
 801838a:	62f8      	str	r0, [r7, #44]	; 0x2c
	if (0 == (field->flags & PROTOBUF_C_FIELD_FLAG_PACKED))
 801838c:	68fb      	ldr	r3, [r7, #12]
 801838e:	69db      	ldr	r3, [r3, #28]
 8018390:	f003 0301 	and.w	r3, r3, #1
 8018394:	2b00      	cmp	r3, #0
 8018396:	d104      	bne.n	80183a2 <repeated_field_get_packed_size+0x42>
		header_size *= count;
 8018398:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 801839a:	68ba      	ldr	r2, [r7, #8]
 801839c:	fb02 f303 	mul.w	r3, r2, r3
 80183a0:	62fb      	str	r3, [r7, #44]	; 0x2c

	switch (field->type) {
 80183a2:	68fb      	ldr	r3, [r7, #12]
 80183a4:	7a5b      	ldrb	r3, [r3, #9]
 80183a6:	2b10      	cmp	r3, #16
 80183a8:	f200 8102 	bhi.w	80185b0 <repeated_field_get_packed_size+0x250>
 80183ac:	a201      	add	r2, pc, #4	; (adr r2, 80183b4 <repeated_field_get_packed_size+0x54>)
 80183ae:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 80183b2:	bf00      	nop
 80183b4:	08018427 	.word	0x08018427
 80183b8:	080183f9 	.word	0x080183f9
 80183bc:	080184e7 	.word	0x080184e7
 80183c0:	080184b5 	.word	0x080184b5
 80183c4:	08018483 	.word	0x08018483
 80183c8:	080184f3 	.word	0x080184f3
 80183cc:	08018455 	.word	0x08018455
 80183d0:	080184e7 	.word	0x080184e7
 80183d4:	080184b5 	.word	0x080184b5
 80183d8:	080184f3 	.word	0x080184f3
 80183dc:	080184e7 	.word	0x080184e7
 80183e0:	080184f3 	.word	0x080184f3
 80183e4:	080184ff 	.word	0x080184ff
 80183e8:	08018427 	.word	0x08018427
 80183ec:	08018509 	.word	0x08018509
 80183f0:	08018543 	.word	0x08018543
 80183f4:	08018577 	.word	0x08018577
	case PROTOBUF_C_TYPE_SINT32:
		for (i = 0; i < count; i++)
 80183f8:	2300      	movs	r3, #0
 80183fa:	627b      	str	r3, [r7, #36]	; 0x24
 80183fc:	e00e      	b.n	801841c <repeated_field_get_packed_size+0xbc>
			rv += sint32_size(((int32_t *) array)[i]);
 80183fe:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8018400:	009b      	lsls	r3, r3, #2
 8018402:	6a3a      	ldr	r2, [r7, #32]
 8018404:	4413      	add	r3, r2
 8018406:	681b      	ldr	r3, [r3, #0]
 8018408:	4618      	mov	r0, r3
 801840a:	f7ff fd74 	bl	8017ef6 <sint32_size>
 801840e:	4602      	mov	r2, r0
 8018410:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8018412:	4413      	add	r3, r2
 8018414:	62bb      	str	r3, [r7, #40]	; 0x28
		for (i = 0; i < count; i++)
 8018416:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8018418:	3301      	adds	r3, #1
 801841a:	627b      	str	r3, [r7, #36]	; 0x24
 801841c:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 801841e:	68bb      	ldr	r3, [r7, #8]
 8018420:	429a      	cmp	r2, r3
 8018422:	d3ec      	bcc.n	80183fe <repeated_field_get_packed_size+0x9e>
		break;
 8018424:	e0c4      	b.n	80185b0 <repeated_field_get_packed_size+0x250>
	case PROTOBUF_C_TYPE_ENUM:
	case PROTOBUF_C_TYPE_INT32:
		for (i = 0; i < count; i++)
 8018426:	2300      	movs	r3, #0
 8018428:	627b      	str	r3, [r7, #36]	; 0x24
 801842a:	e00e      	b.n	801844a <repeated_field_get_packed_size+0xea>
			rv += int32_size(((int32_t *) array)[i]);
 801842c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801842e:	009b      	lsls	r3, r3, #2
 8018430:	6a3a      	ldr	r2, [r7, #32]
 8018432:	4413      	add	r3, r2
 8018434:	681b      	ldr	r3, [r3, #0]
 8018436:	4618      	mov	r0, r3
 8018438:	f7ff fd27 	bl	8017e8a <int32_size>
 801843c:	4602      	mov	r2, r0
 801843e:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8018440:	4413      	add	r3, r2
 8018442:	62bb      	str	r3, [r7, #40]	; 0x28
		for (i = 0; i < count; i++)
 8018444:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8018446:	3301      	adds	r3, #1
 8018448:	627b      	str	r3, [r7, #36]	; 0x24
 801844a:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 801844c:	68bb      	ldr	r3, [r7, #8]
 801844e:	429a      	cmp	r2, r3
 8018450:	d3ec      	bcc.n	801842c <repeated_field_get_packed_size+0xcc>
		break;
 8018452:	e0ad      	b.n	80185b0 <repeated_field_get_packed_size+0x250>
	case PROTOBUF_C_TYPE_UINT32:
		for (i = 0; i < count; i++)
 8018454:	2300      	movs	r3, #0
 8018456:	627b      	str	r3, [r7, #36]	; 0x24
 8018458:	e00e      	b.n	8018478 <repeated_field_get_packed_size+0x118>
			rv += uint32_size(((uint32_t *) array)[i]);
 801845a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801845c:	009b      	lsls	r3, r3, #2
 801845e:	6a3a      	ldr	r2, [r7, #32]
 8018460:	4413      	add	r3, r2
 8018462:	681b      	ldr	r3, [r3, #0]
 8018464:	4618      	mov	r0, r3
 8018466:	f7ff fcee 	bl	8017e46 <uint32_size>
 801846a:	4602      	mov	r2, r0
 801846c:	6abb      	ldr	r3, [r7, #40]	; 0x28
 801846e:	4413      	add	r3, r2
 8018470:	62bb      	str	r3, [r7, #40]	; 0x28
		for (i = 0; i < count; i++)
 8018472:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8018474:	3301      	adds	r3, #1
 8018476:	627b      	str	r3, [r7, #36]	; 0x24
 8018478:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 801847a:	68bb      	ldr	r3, [r7, #8]
 801847c:	429a      	cmp	r2, r3
 801847e:	d3ec      	bcc.n	801845a <repeated_field_get_packed_size+0xfa>
		break;
 8018480:	e096      	b.n	80185b0 <repeated_field_get_packed_size+0x250>
	case PROTOBUF_C_TYPE_SINT64:
		for (i = 0; i < count; i++)
 8018482:	2300      	movs	r3, #0
 8018484:	627b      	str	r3, [r7, #36]	; 0x24
 8018486:	e010      	b.n	80184aa <repeated_field_get_packed_size+0x14a>
			rv += sint64_size(((int64_t *) array)[i]);
 8018488:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801848a:	00db      	lsls	r3, r3, #3
 801848c:	6a3a      	ldr	r2, [r7, #32]
 801848e:	4413      	add	r3, r2
 8018490:	e9d3 2300 	ldrd	r2, r3, [r3]
 8018494:	4610      	mov	r0, r2
 8018496:	4619      	mov	r1, r3
 8018498:	f7ff fd97 	bl	8017fca <sint64_size>
 801849c:	4602      	mov	r2, r0
 801849e:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80184a0:	4413      	add	r3, r2
 80184a2:	62bb      	str	r3, [r7, #40]	; 0x28
		for (i = 0; i < count; i++)
 80184a4:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80184a6:	3301      	adds	r3, #1
 80184a8:	627b      	str	r3, [r7, #36]	; 0x24
 80184aa:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 80184ac:	68bb      	ldr	r3, [r7, #8]
 80184ae:	429a      	cmp	r2, r3
 80184b0:	d3ea      	bcc.n	8018488 <repeated_field_get_packed_size+0x128>
		break;
 80184b2:	e07d      	b.n	80185b0 <repeated_field_get_packed_size+0x250>
	case PROTOBUF_C_TYPE_INT64:
	case PROTOBUF_C_TYPE_UINT64:
		for (i = 0; i < count; i++)
 80184b4:	2300      	movs	r3, #0
 80184b6:	627b      	str	r3, [r7, #36]	; 0x24
 80184b8:	e010      	b.n	80184dc <repeated_field_get_packed_size+0x17c>
			rv += uint64_size(((uint64_t *) array)[i]);
 80184ba:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80184bc:	00db      	lsls	r3, r3, #3
 80184be:	6a3a      	ldr	r2, [r7, #32]
 80184c0:	4413      	add	r3, r2
 80184c2:	e9d3 2300 	ldrd	r2, r3, [r3]
 80184c6:	4610      	mov	r0, r2
 80184c8:	4619      	mov	r1, r3
 80184ca:	f7ff fd24 	bl	8017f16 <uint64_size>
 80184ce:	4602      	mov	r2, r0
 80184d0:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80184d2:	4413      	add	r3, r2
 80184d4:	62bb      	str	r3, [r7, #40]	; 0x28
		for (i = 0; i < count; i++)
 80184d6:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80184d8:	3301      	adds	r3, #1
 80184da:	627b      	str	r3, [r7, #36]	; 0x24
 80184dc:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 80184de:	68bb      	ldr	r3, [r7, #8]
 80184e0:	429a      	cmp	r2, r3
 80184e2:	d3ea      	bcc.n	80184ba <repeated_field_get_packed_size+0x15a>
		break;
 80184e4:	e064      	b.n	80185b0 <repeated_field_get_packed_size+0x250>
	case PROTOBUF_C_TYPE_SFIXED32:
	case PROTOBUF_C_TYPE_FIXED32:
	case PROTOBUF_C_TYPE_FLOAT:
		rv += 4 * count;
 80184e6:	68bb      	ldr	r3, [r7, #8]
 80184e8:	009b      	lsls	r3, r3, #2
 80184ea:	6aba      	ldr	r2, [r7, #40]	; 0x28
 80184ec:	4413      	add	r3, r2
 80184ee:	62bb      	str	r3, [r7, #40]	; 0x28
		break;
 80184f0:	e05e      	b.n	80185b0 <repeated_field_get_packed_size+0x250>
	case PROTOBUF_C_TYPE_SFIXED64:
	case PROTOBUF_C_TYPE_FIXED64:
	case PROTOBUF_C_TYPE_DOUBLE:
		rv += 8 * count;
 80184f2:	68bb      	ldr	r3, [r7, #8]
 80184f4:	00db      	lsls	r3, r3, #3
 80184f6:	6aba      	ldr	r2, [r7, #40]	; 0x28
 80184f8:	4413      	add	r3, r2
 80184fa:	62bb      	str	r3, [r7, #40]	; 0x28
		break;
 80184fc:	e058      	b.n	80185b0 <repeated_field_get_packed_size+0x250>
	case PROTOBUF_C_TYPE_BOOL:
		rv += count;
 80184fe:	6aba      	ldr	r2, [r7, #40]	; 0x28
 8018500:	68bb      	ldr	r3, [r7, #8]
 8018502:	4413      	add	r3, r2
 8018504:	62bb      	str	r3, [r7, #40]	; 0x28
		break;
 8018506:	e053      	b.n	80185b0 <repeated_field_get_packed_size+0x250>
	case PROTOBUF_C_TYPE_STRING:
		for (i = 0; i < count; i++) {
 8018508:	2300      	movs	r3, #0
 801850a:	627b      	str	r3, [r7, #36]	; 0x24
 801850c:	e014      	b.n	8018538 <repeated_field_get_packed_size+0x1d8>
			size_t len = strlen(((char **) array)[i]);
 801850e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8018510:	009b      	lsls	r3, r3, #2
 8018512:	6a3a      	ldr	r2, [r7, #32]
 8018514:	4413      	add	r3, r2
 8018516:	681b      	ldr	r3, [r3, #0]
 8018518:	4618      	mov	r0, r3
 801851a:	f7e8 f807 	bl	800052c <strlen>
 801851e:	6178      	str	r0, [r7, #20]
			rv += uint32_size(len) + len;
 8018520:	6978      	ldr	r0, [r7, #20]
 8018522:	f7ff fc90 	bl	8017e46 <uint32_size>
 8018526:	4602      	mov	r2, r0
 8018528:	697b      	ldr	r3, [r7, #20]
 801852a:	4413      	add	r3, r2
 801852c:	6aba      	ldr	r2, [r7, #40]	; 0x28
 801852e:	4413      	add	r3, r2
 8018530:	62bb      	str	r3, [r7, #40]	; 0x28
		for (i = 0; i < count; i++) {
 8018532:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8018534:	3301      	adds	r3, #1
 8018536:	627b      	str	r3, [r7, #36]	; 0x24
 8018538:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 801853a:	68bb      	ldr	r3, [r7, #8]
 801853c:	429a      	cmp	r2, r3
 801853e:	d3e6      	bcc.n	801850e <repeated_field_get_packed_size+0x1ae>
		}
		break;
 8018540:	e036      	b.n	80185b0 <repeated_field_get_packed_size+0x250>
	case PROTOBUF_C_TYPE_BYTES:
		for (i = 0; i < count; i++) {
 8018542:	2300      	movs	r3, #0
 8018544:	627b      	str	r3, [r7, #36]	; 0x24
 8018546:	e011      	b.n	801856c <repeated_field_get_packed_size+0x20c>
			size_t len = ((ProtobufCBinaryData *) array)[i].len;
 8018548:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801854a:	00db      	lsls	r3, r3, #3
 801854c:	6a3a      	ldr	r2, [r7, #32]
 801854e:	4413      	add	r3, r2
 8018550:	681b      	ldr	r3, [r3, #0]
 8018552:	61bb      	str	r3, [r7, #24]
			rv += uint32_size(len) + len;
 8018554:	69b8      	ldr	r0, [r7, #24]
 8018556:	f7ff fc76 	bl	8017e46 <uint32_size>
 801855a:	4602      	mov	r2, r0
 801855c:	69bb      	ldr	r3, [r7, #24]
 801855e:	4413      	add	r3, r2
 8018560:	6aba      	ldr	r2, [r7, #40]	; 0x28
 8018562:	4413      	add	r3, r2
 8018564:	62bb      	str	r3, [r7, #40]	; 0x28
		for (i = 0; i < count; i++) {
 8018566:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8018568:	3301      	adds	r3, #1
 801856a:	627b      	str	r3, [r7, #36]	; 0x24
 801856c:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 801856e:	68bb      	ldr	r3, [r7, #8]
 8018570:	429a      	cmp	r2, r3
 8018572:	d3e9      	bcc.n	8018548 <repeated_field_get_packed_size+0x1e8>
		}
		break;
 8018574:	e01c      	b.n	80185b0 <repeated_field_get_packed_size+0x250>
	case PROTOBUF_C_TYPE_MESSAGE:
		for (i = 0; i < count; i++) {
 8018576:	2300      	movs	r3, #0
 8018578:	627b      	str	r3, [r7, #36]	; 0x24
 801857a:	e014      	b.n	80185a6 <repeated_field_get_packed_size+0x246>
			size_t len = protobuf_c_message_get_packed_size(
				((ProtobufCMessage **) array)[i]);
 801857c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801857e:	009b      	lsls	r3, r3, #2
 8018580:	6a3a      	ldr	r2, [r7, #32]
 8018582:	4413      	add	r3, r2
			size_t len = protobuf_c_message_get_packed_size(
 8018584:	681b      	ldr	r3, [r3, #0]
 8018586:	4618      	mov	r0, r3
 8018588:	f000 f838 	bl	80185fc <protobuf_c_message_get_packed_size>
 801858c:	61f8      	str	r0, [r7, #28]
			rv += uint32_size(len) + len;
 801858e:	69f8      	ldr	r0, [r7, #28]
 8018590:	f7ff fc59 	bl	8017e46 <uint32_size>
 8018594:	4602      	mov	r2, r0
 8018596:	69fb      	ldr	r3, [r7, #28]
 8018598:	4413      	add	r3, r2
 801859a:	6aba      	ldr	r2, [r7, #40]	; 0x28
 801859c:	4413      	add	r3, r2
 801859e:	62bb      	str	r3, [r7, #40]	; 0x28
		for (i = 0; i < count; i++) {
 80185a0:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80185a2:	3301      	adds	r3, #1
 80185a4:	627b      	str	r3, [r7, #36]	; 0x24
 80185a6:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 80185a8:	68bb      	ldr	r3, [r7, #8]
 80185aa:	429a      	cmp	r2, r3
 80185ac:	d3e6      	bcc.n	801857c <repeated_field_get_packed_size+0x21c>
		}
		break;
 80185ae:	bf00      	nop
	}

	if (0 != (field->flags & PROTOBUF_C_FIELD_FLAG_PACKED))
 80185b0:	68fb      	ldr	r3, [r7, #12]
 80185b2:	69db      	ldr	r3, [r3, #28]
 80185b4:	f003 0301 	and.w	r3, r3, #1
 80185b8:	2b00      	cmp	r3, #0
 80185ba:	d006      	beq.n	80185ca <repeated_field_get_packed_size+0x26a>
		header_size += uint32_size(rv);
 80185bc:	6ab8      	ldr	r0, [r7, #40]	; 0x28
 80185be:	f7ff fc42 	bl	8017e46 <uint32_size>
 80185c2:	4602      	mov	r2, r0
 80185c4:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 80185c6:	4413      	add	r3, r2
 80185c8:	62fb      	str	r3, [r7, #44]	; 0x2c
	return header_size + rv;
 80185ca:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 80185cc:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80185ce:	4413      	add	r3, r2
}
 80185d0:	4618      	mov	r0, r3
 80185d2:	3730      	adds	r7, #48	; 0x30
 80185d4:	46bd      	mov	sp, r7
 80185d6:	bd80      	pop	{r7, pc}

080185d8 <unknown_field_get_packed_size>:
 * \return
 *      Number of bytes required.
 */
static inline size_t
unknown_field_get_packed_size(const ProtobufCMessageUnknownField *field)
{
 80185d8:	b580      	push	{r7, lr}
 80185da:	b082      	sub	sp, #8
 80185dc:	af00      	add	r7, sp, #0
 80185de:	6078      	str	r0, [r7, #4]
	return get_tag_size(field->tag) + field->len;
 80185e0:	687b      	ldr	r3, [r7, #4]
 80185e2:	681b      	ldr	r3, [r3, #0]
 80185e4:	4618      	mov	r0, r3
 80185e6:	f7ff fc0c 	bl	8017e02 <get_tag_size>
 80185ea:	4602      	mov	r2, r0
 80185ec:	687b      	ldr	r3, [r7, #4]
 80185ee:	689b      	ldr	r3, [r3, #8]
 80185f0:	4413      	add	r3, r2
}
 80185f2:	4618      	mov	r0, r3
 80185f4:	3708      	adds	r7, #8
 80185f6:	46bd      	mov	sp, r7
 80185f8:	bd80      	pop	{r7, pc}
	...

080185fc <protobuf_c_message_get_packed_size>:

/*
 * Calculate the serialized size of the message.
 */
size_t protobuf_c_message_get_packed_size(const ProtobufCMessage *message)
{
 80185fc:	b580      	push	{r7, lr}
 80185fe:	b088      	sub	sp, #32
 8018600:	af00      	add	r7, sp, #0
 8018602:	6078      	str	r0, [r7, #4]
	unsigned i;
	size_t rv = 0;
 8018604:	2300      	movs	r3, #0
 8018606:	61bb      	str	r3, [r7, #24]

	ASSERT_IS_MESSAGE(message);
 8018608:	687b      	ldr	r3, [r7, #4]
 801860a:	681b      	ldr	r3, [r3, #0]
 801860c:	681b      	ldr	r3, [r3, #0]
 801860e:	4a4a      	ldr	r2, [pc, #296]	; (8018738 <protobuf_c_message_get_packed_size+0x13c>)
 8018610:	4293      	cmp	r3, r2
 8018612:	d006      	beq.n	8018622 <protobuf_c_message_get_packed_size+0x26>
 8018614:	4b49      	ldr	r3, [pc, #292]	; (801873c <protobuf_c_message_get_packed_size+0x140>)
 8018616:	4a4a      	ldr	r2, [pc, #296]	; (8018740 <protobuf_c_message_get_packed_size+0x144>)
 8018618:	f240 21c7 	movw	r1, #711	; 0x2c7
 801861c:	4849      	ldr	r0, [pc, #292]	; (8018744 <protobuf_c_message_get_packed_size+0x148>)
 801861e:	f007 f89b 	bl	801f758 <__assert_func>
	for (i = 0; i < message->descriptor->n_fields; i++) {
 8018622:	2300      	movs	r3, #0
 8018624:	61fb      	str	r3, [r7, #28]
 8018626:	e064      	b.n	80186f2 <protobuf_c_message_get_packed_size+0xf6>
		const ProtobufCFieldDescriptor *field =
			message->descriptor->fields + i;
 8018628:	687b      	ldr	r3, [r7, #4]
 801862a:	681b      	ldr	r3, [r3, #0]
 801862c:	69da      	ldr	r2, [r3, #28]
 801862e:	69fb      	ldr	r3, [r7, #28]
 8018630:	212c      	movs	r1, #44	; 0x2c
 8018632:	fb01 f303 	mul.w	r3, r1, r3
		const ProtobufCFieldDescriptor *field =
 8018636:	4413      	add	r3, r2
 8018638:	617b      	str	r3, [r7, #20]
		const void *member =
			((const char *) message) + field->offset;
 801863a:	697b      	ldr	r3, [r7, #20]
 801863c:	691b      	ldr	r3, [r3, #16]
		const void *member =
 801863e:	687a      	ldr	r2, [r7, #4]
 8018640:	4413      	add	r3, r2
 8018642:	613b      	str	r3, [r7, #16]
		const void *qmember =
			((const char *) message) + field->quantifier_offset;
 8018644:	697b      	ldr	r3, [r7, #20]
 8018646:	68db      	ldr	r3, [r3, #12]
		const void *qmember =
 8018648:	687a      	ldr	r2, [r7, #4]
 801864a:	4413      	add	r3, r2
 801864c:	60fb      	str	r3, [r7, #12]

		if (field->label == PROTOBUF_C_LABEL_REQUIRED) {
 801864e:	697b      	ldr	r3, [r7, #20]
 8018650:	7a1b      	ldrb	r3, [r3, #8]
 8018652:	2b00      	cmp	r3, #0
 8018654:	d108      	bne.n	8018668 <protobuf_c_message_get_packed_size+0x6c>
			rv += required_field_get_packed_size(field, member);
 8018656:	6939      	ldr	r1, [r7, #16]
 8018658:	6978      	ldr	r0, [r7, #20]
 801865a:	f7ff fccb 	bl	8017ff4 <required_field_get_packed_size>
 801865e:	4602      	mov	r2, r0
 8018660:	69bb      	ldr	r3, [r7, #24]
 8018662:	4413      	add	r3, r2
 8018664:	61bb      	str	r3, [r7, #24]
 8018666:	e041      	b.n	80186ec <protobuf_c_message_get_packed_size+0xf0>
		} else if ((field->label == PROTOBUF_C_LABEL_OPTIONAL ||
 8018668:	697b      	ldr	r3, [r7, #20]
 801866a:	7a1b      	ldrb	r3, [r3, #8]
 801866c:	2b01      	cmp	r3, #1
 801866e:	d003      	beq.n	8018678 <protobuf_c_message_get_packed_size+0x7c>
			    field->label == PROTOBUF_C_LABEL_NONE) &&
 8018670:	697b      	ldr	r3, [r7, #20]
 8018672:	7a1b      	ldrb	r3, [r3, #8]
		} else if ((field->label == PROTOBUF_C_LABEL_OPTIONAL ||
 8018674:	2b03      	cmp	r3, #3
 8018676:	d111      	bne.n	801869c <protobuf_c_message_get_packed_size+0xa0>
			   (0 != (field->flags & PROTOBUF_C_FIELD_FLAG_ONEOF))) {
 8018678:	697b      	ldr	r3, [r7, #20]
 801867a:	69db      	ldr	r3, [r3, #28]
 801867c:	f003 0304 	and.w	r3, r3, #4
			    field->label == PROTOBUF_C_LABEL_NONE) &&
 8018680:	2b00      	cmp	r3, #0
 8018682:	d00b      	beq.n	801869c <protobuf_c_message_get_packed_size+0xa0>
			rv += oneof_field_get_packed_size(
 8018684:	68fb      	ldr	r3, [r7, #12]
 8018686:	681b      	ldr	r3, [r3, #0]
 8018688:	693a      	ldr	r2, [r7, #16]
 801868a:	4619      	mov	r1, r3
 801868c:	6978      	ldr	r0, [r7, #20]
 801868e:	f7ff fd71 	bl	8018174 <oneof_field_get_packed_size>
 8018692:	4602      	mov	r2, r0
 8018694:	69bb      	ldr	r3, [r7, #24]
 8018696:	4413      	add	r3, r2
 8018698:	61bb      	str	r3, [r7, #24]
				field,
				*(const uint32_t *) qmember,
				member
			);
 801869a:	e027      	b.n	80186ec <protobuf_c_message_get_packed_size+0xf0>
		} else if (field->label == PROTOBUF_C_LABEL_OPTIONAL) {
 801869c:	697b      	ldr	r3, [r7, #20]
 801869e:	7a1b      	ldrb	r3, [r3, #8]
 80186a0:	2b01      	cmp	r3, #1
 80186a2:	d10b      	bne.n	80186bc <protobuf_c_message_get_packed_size+0xc0>
			rv += optional_field_get_packed_size(
 80186a4:	68fb      	ldr	r3, [r7, #12]
 80186a6:	681b      	ldr	r3, [r3, #0]
 80186a8:	693a      	ldr	r2, [r7, #16]
 80186aa:	4619      	mov	r1, r3
 80186ac:	6978      	ldr	r0, [r7, #20]
 80186ae:	f7ff fd8c 	bl	80181ca <optional_field_get_packed_size>
 80186b2:	4602      	mov	r2, r0
 80186b4:	69bb      	ldr	r3, [r7, #24]
 80186b6:	4413      	add	r3, r2
 80186b8:	61bb      	str	r3, [r7, #24]
 80186ba:	e017      	b.n	80186ec <protobuf_c_message_get_packed_size+0xf0>
				field,
				*(protobuf_c_boolean *) qmember,
				member
			);
		} else if (field->label == PROTOBUF_C_LABEL_NONE) {
 80186bc:	697b      	ldr	r3, [r7, #20]
 80186be:	7a1b      	ldrb	r3, [r3, #8]
 80186c0:	2b03      	cmp	r3, #3
 80186c2:	d108      	bne.n	80186d6 <protobuf_c_message_get_packed_size+0xda>
			rv += unlabeled_field_get_packed_size(
 80186c4:	6939      	ldr	r1, [r7, #16]
 80186c6:	6978      	ldr	r0, [r7, #20]
 80186c8:	f7ff fe32 	bl	8018330 <unlabeled_field_get_packed_size>
 80186cc:	4602      	mov	r2, r0
 80186ce:	69bb      	ldr	r3, [r7, #24]
 80186d0:	4413      	add	r3, r2
 80186d2:	61bb      	str	r3, [r7, #24]
 80186d4:	e00a      	b.n	80186ec <protobuf_c_message_get_packed_size+0xf0>
				field,
				member
			);
		} else {
			rv += repeated_field_get_packed_size(
 80186d6:	68fb      	ldr	r3, [r7, #12]
 80186d8:	681b      	ldr	r3, [r3, #0]
 80186da:	693a      	ldr	r2, [r7, #16]
 80186dc:	4619      	mov	r1, r3
 80186de:	6978      	ldr	r0, [r7, #20]
 80186e0:	f7ff fe3e 	bl	8018360 <repeated_field_get_packed_size>
 80186e4:	4602      	mov	r2, r0
 80186e6:	69bb      	ldr	r3, [r7, #24]
 80186e8:	4413      	add	r3, r2
 80186ea:	61bb      	str	r3, [r7, #24]
	for (i = 0; i < message->descriptor->n_fields; i++) {
 80186ec:	69fb      	ldr	r3, [r7, #28]
 80186ee:	3301      	adds	r3, #1
 80186f0:	61fb      	str	r3, [r7, #28]
 80186f2:	687b      	ldr	r3, [r7, #4]
 80186f4:	681b      	ldr	r3, [r3, #0]
 80186f6:	699b      	ldr	r3, [r3, #24]
 80186f8:	69fa      	ldr	r2, [r7, #28]
 80186fa:	429a      	cmp	r2, r3
 80186fc:	d394      	bcc.n	8018628 <protobuf_c_message_get_packed_size+0x2c>
				*(const size_t *) qmember,
				member
			);
		}
	}
	for (i = 0; i < message->n_unknown_fields; i++)
 80186fe:	2300      	movs	r3, #0
 8018700:	61fb      	str	r3, [r7, #28]
 8018702:	e00e      	b.n	8018722 <protobuf_c_message_get_packed_size+0x126>
		rv += unknown_field_get_packed_size(&message->unknown_fields[i]);
 8018704:	687b      	ldr	r3, [r7, #4]
 8018706:	689a      	ldr	r2, [r3, #8]
 8018708:	69fb      	ldr	r3, [r7, #28]
 801870a:	011b      	lsls	r3, r3, #4
 801870c:	4413      	add	r3, r2
 801870e:	4618      	mov	r0, r3
 8018710:	f7ff ff62 	bl	80185d8 <unknown_field_get_packed_size>
 8018714:	4602      	mov	r2, r0
 8018716:	69bb      	ldr	r3, [r7, #24]
 8018718:	4413      	add	r3, r2
 801871a:	61bb      	str	r3, [r7, #24]
	for (i = 0; i < message->n_unknown_fields; i++)
 801871c:	69fb      	ldr	r3, [r7, #28]
 801871e:	3301      	adds	r3, #1
 8018720:	61fb      	str	r3, [r7, #28]
 8018722:	687b      	ldr	r3, [r7, #4]
 8018724:	685b      	ldr	r3, [r3, #4]
 8018726:	69fa      	ldr	r2, [r7, #28]
 8018728:	429a      	cmp	r2, r3
 801872a:	d3eb      	bcc.n	8018704 <protobuf_c_message_get_packed_size+0x108>
	return rv;
 801872c:	69bb      	ldr	r3, [r7, #24]
}
 801872e:	4618      	mov	r0, r3
 8018730:	3720      	adds	r7, #32
 8018732:	46bd      	mov	sp, r7
 8018734:	bd80      	pop	{r7, pc}
 8018736:	bf00      	nop
 8018738:	28aaeef9 	.word	0x28aaeef9
 801873c:	08024340 	.word	0x08024340
 8018740:	080286bc 	.word	0x080286bc
 8018744:	080242e8 	.word	0x080242e8

08018748 <uint32_pack>:
 * \return
 *      Number of bytes written to `out`.
 */
static inline size_t
uint32_pack(uint32_t value, uint8_t *out)
{
 8018748:	b480      	push	{r7}
 801874a:	b085      	sub	sp, #20
 801874c:	af00      	add	r7, sp, #0
 801874e:	6078      	str	r0, [r7, #4]
 8018750:	6039      	str	r1, [r7, #0]
	unsigned rv = 0;
 8018752:	2300      	movs	r3, #0
 8018754:	60fb      	str	r3, [r7, #12]

	if (value >= 0x80) {
 8018756:	687b      	ldr	r3, [r7, #4]
 8018758:	2b7f      	cmp	r3, #127	; 0x7f
 801875a:	d940      	bls.n	80187de <uint32_pack+0x96>
		out[rv++] = value | 0x80;
 801875c:	687b      	ldr	r3, [r7, #4]
 801875e:	b2da      	uxtb	r2, r3
 8018760:	68fb      	ldr	r3, [r7, #12]
 8018762:	1c59      	adds	r1, r3, #1
 8018764:	60f9      	str	r1, [r7, #12]
 8018766:	6839      	ldr	r1, [r7, #0]
 8018768:	440b      	add	r3, r1
 801876a:	f062 027f 	orn	r2, r2, #127	; 0x7f
 801876e:	b2d2      	uxtb	r2, r2
 8018770:	701a      	strb	r2, [r3, #0]
		value >>= 7;
 8018772:	687b      	ldr	r3, [r7, #4]
 8018774:	09db      	lsrs	r3, r3, #7
 8018776:	607b      	str	r3, [r7, #4]
		if (value >= 0x80) {
 8018778:	687b      	ldr	r3, [r7, #4]
 801877a:	2b7f      	cmp	r3, #127	; 0x7f
 801877c:	d92f      	bls.n	80187de <uint32_pack+0x96>
			out[rv++] = value | 0x80;
 801877e:	687b      	ldr	r3, [r7, #4]
 8018780:	b2da      	uxtb	r2, r3
 8018782:	68fb      	ldr	r3, [r7, #12]
 8018784:	1c59      	adds	r1, r3, #1
 8018786:	60f9      	str	r1, [r7, #12]
 8018788:	6839      	ldr	r1, [r7, #0]
 801878a:	440b      	add	r3, r1
 801878c:	f062 027f 	orn	r2, r2, #127	; 0x7f
 8018790:	b2d2      	uxtb	r2, r2
 8018792:	701a      	strb	r2, [r3, #0]
			value >>= 7;
 8018794:	687b      	ldr	r3, [r7, #4]
 8018796:	09db      	lsrs	r3, r3, #7
 8018798:	607b      	str	r3, [r7, #4]
			if (value >= 0x80) {
 801879a:	687b      	ldr	r3, [r7, #4]
 801879c:	2b7f      	cmp	r3, #127	; 0x7f
 801879e:	d91e      	bls.n	80187de <uint32_pack+0x96>
				out[rv++] = value | 0x80;
 80187a0:	687b      	ldr	r3, [r7, #4]
 80187a2:	b2da      	uxtb	r2, r3
 80187a4:	68fb      	ldr	r3, [r7, #12]
 80187a6:	1c59      	adds	r1, r3, #1
 80187a8:	60f9      	str	r1, [r7, #12]
 80187aa:	6839      	ldr	r1, [r7, #0]
 80187ac:	440b      	add	r3, r1
 80187ae:	f062 027f 	orn	r2, r2, #127	; 0x7f
 80187b2:	b2d2      	uxtb	r2, r2
 80187b4:	701a      	strb	r2, [r3, #0]
				value >>= 7;
 80187b6:	687b      	ldr	r3, [r7, #4]
 80187b8:	09db      	lsrs	r3, r3, #7
 80187ba:	607b      	str	r3, [r7, #4]
				if (value >= 0x80) {
 80187bc:	687b      	ldr	r3, [r7, #4]
 80187be:	2b7f      	cmp	r3, #127	; 0x7f
 80187c0:	d90d      	bls.n	80187de <uint32_pack+0x96>
					out[rv++] = value | 0x80;
 80187c2:	687b      	ldr	r3, [r7, #4]
 80187c4:	b2da      	uxtb	r2, r3
 80187c6:	68fb      	ldr	r3, [r7, #12]
 80187c8:	1c59      	adds	r1, r3, #1
 80187ca:	60f9      	str	r1, [r7, #12]
 80187cc:	6839      	ldr	r1, [r7, #0]
 80187ce:	440b      	add	r3, r1
 80187d0:	f062 027f 	orn	r2, r2, #127	; 0x7f
 80187d4:	b2d2      	uxtb	r2, r2
 80187d6:	701a      	strb	r2, [r3, #0]
					value >>= 7;
 80187d8:	687b      	ldr	r3, [r7, #4]
 80187da:	09db      	lsrs	r3, r3, #7
 80187dc:	607b      	str	r3, [r7, #4]
				}
			}
		}
	}
	/* assert: value<128 */
	out[rv++] = value;
 80187de:	68fb      	ldr	r3, [r7, #12]
 80187e0:	1c5a      	adds	r2, r3, #1
 80187e2:	60fa      	str	r2, [r7, #12]
 80187e4:	683a      	ldr	r2, [r7, #0]
 80187e6:	4413      	add	r3, r2
 80187e8:	687a      	ldr	r2, [r7, #4]
 80187ea:	b2d2      	uxtb	r2, r2
 80187ec:	701a      	strb	r2, [r3, #0]
	return rv;
 80187ee:	68fb      	ldr	r3, [r7, #12]
}
 80187f0:	4618      	mov	r0, r3
 80187f2:	3714      	adds	r7, #20
 80187f4:	46bd      	mov	sp, r7
 80187f6:	f85d 7b04 	ldr.w	r7, [sp], #4
 80187fa:	4770      	bx	lr

080187fc <int32_pack>:
 * \return
 *      Number of bytes written to `out`.
 */
static inline size_t
int32_pack(int32_t value, uint8_t *out)
{
 80187fc:	b580      	push	{r7, lr}
 80187fe:	b082      	sub	sp, #8
 8018800:	af00      	add	r7, sp, #0
 8018802:	6078      	str	r0, [r7, #4]
 8018804:	6039      	str	r1, [r7, #0]
	if (value < 0) {
 8018806:	687b      	ldr	r3, [r7, #4]
 8018808:	2b00      	cmp	r3, #0
 801880a:	da45      	bge.n	8018898 <int32_pack+0x9c>
		out[0] = value | 0x80;
 801880c:	687b      	ldr	r3, [r7, #4]
 801880e:	b25b      	sxtb	r3, r3
 8018810:	f063 037f 	orn	r3, r3, #127	; 0x7f
 8018814:	b25b      	sxtb	r3, r3
 8018816:	b2da      	uxtb	r2, r3
 8018818:	683b      	ldr	r3, [r7, #0]
 801881a:	701a      	strb	r2, [r3, #0]
		out[1] = (value >> 7) | 0x80;
 801881c:	687b      	ldr	r3, [r7, #4]
 801881e:	11db      	asrs	r3, r3, #7
 8018820:	b25b      	sxtb	r3, r3
 8018822:	f063 037f 	orn	r3, r3, #127	; 0x7f
 8018826:	b25a      	sxtb	r2, r3
 8018828:	683b      	ldr	r3, [r7, #0]
 801882a:	3301      	adds	r3, #1
 801882c:	b2d2      	uxtb	r2, r2
 801882e:	701a      	strb	r2, [r3, #0]
		out[2] = (value >> 14) | 0x80;
 8018830:	687b      	ldr	r3, [r7, #4]
 8018832:	139b      	asrs	r3, r3, #14
 8018834:	b25b      	sxtb	r3, r3
 8018836:	f063 037f 	orn	r3, r3, #127	; 0x7f
 801883a:	b25a      	sxtb	r2, r3
 801883c:	683b      	ldr	r3, [r7, #0]
 801883e:	3302      	adds	r3, #2
 8018840:	b2d2      	uxtb	r2, r2
 8018842:	701a      	strb	r2, [r3, #0]
		out[3] = (value >> 21) | 0x80;
 8018844:	687b      	ldr	r3, [r7, #4]
 8018846:	155b      	asrs	r3, r3, #21
 8018848:	b25b      	sxtb	r3, r3
 801884a:	f063 037f 	orn	r3, r3, #127	; 0x7f
 801884e:	b25a      	sxtb	r2, r3
 8018850:	683b      	ldr	r3, [r7, #0]
 8018852:	3303      	adds	r3, #3
 8018854:	b2d2      	uxtb	r2, r2
 8018856:	701a      	strb	r2, [r3, #0]
		out[4] = (value >> 28) | 0x80;
 8018858:	687b      	ldr	r3, [r7, #4]
 801885a:	171b      	asrs	r3, r3, #28
 801885c:	b25b      	sxtb	r3, r3
 801885e:	f063 037f 	orn	r3, r3, #127	; 0x7f
 8018862:	b25a      	sxtb	r2, r3
 8018864:	683b      	ldr	r3, [r7, #0]
 8018866:	3304      	adds	r3, #4
 8018868:	b2d2      	uxtb	r2, r2
 801886a:	701a      	strb	r2, [r3, #0]
		out[5] = out[6] = out[7] = out[8] = 0xff;
 801886c:	683b      	ldr	r3, [r7, #0]
 801886e:	3308      	adds	r3, #8
 8018870:	22ff      	movs	r2, #255	; 0xff
 8018872:	701a      	strb	r2, [r3, #0]
 8018874:	683a      	ldr	r2, [r7, #0]
 8018876:	3207      	adds	r2, #7
 8018878:	781b      	ldrb	r3, [r3, #0]
 801887a:	7013      	strb	r3, [r2, #0]
 801887c:	683b      	ldr	r3, [r7, #0]
 801887e:	3306      	adds	r3, #6
 8018880:	7812      	ldrb	r2, [r2, #0]
 8018882:	701a      	strb	r2, [r3, #0]
 8018884:	683a      	ldr	r2, [r7, #0]
 8018886:	3205      	adds	r2, #5
 8018888:	781b      	ldrb	r3, [r3, #0]
 801888a:	7013      	strb	r3, [r2, #0]
		out[9] = 0x01;
 801888c:	683b      	ldr	r3, [r7, #0]
 801888e:	3309      	adds	r3, #9
 8018890:	2201      	movs	r2, #1
 8018892:	701a      	strb	r2, [r3, #0]
		return 10;
 8018894:	230a      	movs	r3, #10
 8018896:	e005      	b.n	80188a4 <int32_pack+0xa8>
	} else {
		return uint32_pack(value, out);
 8018898:	687b      	ldr	r3, [r7, #4]
 801889a:	6839      	ldr	r1, [r7, #0]
 801889c:	4618      	mov	r0, r3
 801889e:	f7ff ff53 	bl	8018748 <uint32_pack>
 80188a2:	4603      	mov	r3, r0
	}
}
 80188a4:	4618      	mov	r0, r3
 80188a6:	3708      	adds	r7, #8
 80188a8:	46bd      	mov	sp, r7
 80188aa:	bd80      	pop	{r7, pc}

080188ac <sint32_pack>:
 * \return
 *      Number of bytes written to `out`.
 */
static inline size_t
sint32_pack(int32_t value, uint8_t *out)
{
 80188ac:	b580      	push	{r7, lr}
 80188ae:	b082      	sub	sp, #8
 80188b0:	af00      	add	r7, sp, #0
 80188b2:	6078      	str	r0, [r7, #4]
 80188b4:	6039      	str	r1, [r7, #0]
	return uint32_pack(zigzag32(value), out);
 80188b6:	6878      	ldr	r0, [r7, #4]
 80188b8:	f7ff fb0e 	bl	8017ed8 <zigzag32>
 80188bc:	4603      	mov	r3, r0
 80188be:	6839      	ldr	r1, [r7, #0]
 80188c0:	4618      	mov	r0, r3
 80188c2:	f7ff ff41 	bl	8018748 <uint32_pack>
 80188c6:	4603      	mov	r3, r0
}
 80188c8:	4618      	mov	r0, r3
 80188ca:	3708      	adds	r7, #8
 80188cc:	46bd      	mov	sp, r7
 80188ce:	bd80      	pop	{r7, pc}

080188d0 <uint64_pack>:
 * \return
 *      Number of bytes written to `out`.
 */
static size_t
uint64_pack(uint64_t value, uint8_t *out)
{
 80188d0:	b580      	push	{r7, lr}
 80188d2:	b088      	sub	sp, #32
 80188d4:	af00      	add	r7, sp, #0
 80188d6:	e9c7 0102 	strd	r0, r1, [r7, #8]
 80188da:	607a      	str	r2, [r7, #4]
	uint32_t hi = (uint32_t) (value >> 32);
 80188dc:	e9d7 0102 	ldrd	r0, r1, [r7, #8]
 80188e0:	f04f 0200 	mov.w	r2, #0
 80188e4:	f04f 0300 	mov.w	r3, #0
 80188e8:	000a      	movs	r2, r1
 80188ea:	2300      	movs	r3, #0
 80188ec:	4613      	mov	r3, r2
 80188ee:	61fb      	str	r3, [r7, #28]
	uint32_t lo = (uint32_t) value;
 80188f0:	68bb      	ldr	r3, [r7, #8]
 80188f2:	617b      	str	r3, [r7, #20]
	unsigned rv;

	if (hi == 0)
 80188f4:	69fb      	ldr	r3, [r7, #28]
 80188f6:	2b00      	cmp	r3, #0
 80188f8:	d105      	bne.n	8018906 <uint64_pack+0x36>
		return uint32_pack((uint32_t) lo, out);
 80188fa:	6879      	ldr	r1, [r7, #4]
 80188fc:	6978      	ldr	r0, [r7, #20]
 80188fe:	f7ff ff23 	bl	8018748 <uint32_pack>
 8018902:	4603      	mov	r3, r0
 8018904:	e064      	b.n	80189d0 <uint64_pack+0x100>
	out[0] = (lo) | 0x80;
 8018906:	697b      	ldr	r3, [r7, #20]
 8018908:	b2db      	uxtb	r3, r3
 801890a:	f063 037f 	orn	r3, r3, #127	; 0x7f
 801890e:	b2da      	uxtb	r2, r3
 8018910:	687b      	ldr	r3, [r7, #4]
 8018912:	701a      	strb	r2, [r3, #0]
	out[1] = (lo >> 7) | 0x80;
 8018914:	697b      	ldr	r3, [r7, #20]
 8018916:	09db      	lsrs	r3, r3, #7
 8018918:	b2da      	uxtb	r2, r3
 801891a:	687b      	ldr	r3, [r7, #4]
 801891c:	3301      	adds	r3, #1
 801891e:	f062 027f 	orn	r2, r2, #127	; 0x7f
 8018922:	b2d2      	uxtb	r2, r2
 8018924:	701a      	strb	r2, [r3, #0]
	out[2] = (lo >> 14) | 0x80;
 8018926:	697b      	ldr	r3, [r7, #20]
 8018928:	0b9b      	lsrs	r3, r3, #14
 801892a:	b2da      	uxtb	r2, r3
 801892c:	687b      	ldr	r3, [r7, #4]
 801892e:	3302      	adds	r3, #2
 8018930:	f062 027f 	orn	r2, r2, #127	; 0x7f
 8018934:	b2d2      	uxtb	r2, r2
 8018936:	701a      	strb	r2, [r3, #0]
	out[3] = (lo >> 21) | 0x80;
 8018938:	697b      	ldr	r3, [r7, #20]
 801893a:	0d5b      	lsrs	r3, r3, #21
 801893c:	b2da      	uxtb	r2, r3
 801893e:	687b      	ldr	r3, [r7, #4]
 8018940:	3303      	adds	r3, #3
 8018942:	f062 027f 	orn	r2, r2, #127	; 0x7f
 8018946:	b2d2      	uxtb	r2, r2
 8018948:	701a      	strb	r2, [r3, #0]
	if (hi < 8) {
 801894a:	69fb      	ldr	r3, [r7, #28]
 801894c:	2b07      	cmp	r3, #7
 801894e:	d80d      	bhi.n	801896c <uint64_pack+0x9c>
		out[4] = (hi << 4) | (lo >> 28);
 8018950:	69fb      	ldr	r3, [r7, #28]
 8018952:	b2db      	uxtb	r3, r3
 8018954:	011b      	lsls	r3, r3, #4
 8018956:	b2d9      	uxtb	r1, r3
 8018958:	697b      	ldr	r3, [r7, #20]
 801895a:	0f1b      	lsrs	r3, r3, #28
 801895c:	b2da      	uxtb	r2, r3
 801895e:	687b      	ldr	r3, [r7, #4]
 8018960:	3304      	adds	r3, #4
 8018962:	430a      	orrs	r2, r1
 8018964:	b2d2      	uxtb	r2, r2
 8018966:	701a      	strb	r2, [r3, #0]
		return 5;
 8018968:	2305      	movs	r3, #5
 801896a:	e031      	b.n	80189d0 <uint64_pack+0x100>
	} else {
		out[4] = ((hi & 7) << 4) | (lo >> 28) | 0x80;
 801896c:	69fb      	ldr	r3, [r7, #28]
 801896e:	b2db      	uxtb	r3, r3
 8018970:	011b      	lsls	r3, r3, #4
 8018972:	b2db      	uxtb	r3, r3
 8018974:	f003 0370 	and.w	r3, r3, #112	; 0x70
 8018978:	b2da      	uxtb	r2, r3
 801897a:	697b      	ldr	r3, [r7, #20]
 801897c:	0f1b      	lsrs	r3, r3, #28
 801897e:	b2db      	uxtb	r3, r3
 8018980:	4313      	orrs	r3, r2
 8018982:	b2da      	uxtb	r2, r3
 8018984:	687b      	ldr	r3, [r7, #4]
 8018986:	3304      	adds	r3, #4
 8018988:	f062 027f 	orn	r2, r2, #127	; 0x7f
 801898c:	b2d2      	uxtb	r2, r2
 801898e:	701a      	strb	r2, [r3, #0]
		hi >>= 3;
 8018990:	69fb      	ldr	r3, [r7, #28]
 8018992:	08db      	lsrs	r3, r3, #3
 8018994:	61fb      	str	r3, [r7, #28]
	}
	rv = 5;
 8018996:	2305      	movs	r3, #5
 8018998:	61bb      	str	r3, [r7, #24]
	while (hi >= 128) {
 801899a:	e00d      	b.n	80189b8 <uint64_pack+0xe8>
		out[rv++] = hi | 0x80;
 801899c:	69fb      	ldr	r3, [r7, #28]
 801899e:	b2da      	uxtb	r2, r3
 80189a0:	69bb      	ldr	r3, [r7, #24]
 80189a2:	1c59      	adds	r1, r3, #1
 80189a4:	61b9      	str	r1, [r7, #24]
 80189a6:	6879      	ldr	r1, [r7, #4]
 80189a8:	440b      	add	r3, r1
 80189aa:	f062 027f 	orn	r2, r2, #127	; 0x7f
 80189ae:	b2d2      	uxtb	r2, r2
 80189b0:	701a      	strb	r2, [r3, #0]
		hi >>= 7;
 80189b2:	69fb      	ldr	r3, [r7, #28]
 80189b4:	09db      	lsrs	r3, r3, #7
 80189b6:	61fb      	str	r3, [r7, #28]
	while (hi >= 128) {
 80189b8:	69fb      	ldr	r3, [r7, #28]
 80189ba:	2b7f      	cmp	r3, #127	; 0x7f
 80189bc:	d8ee      	bhi.n	801899c <uint64_pack+0xcc>
	}
	out[rv++] = hi;
 80189be:	69bb      	ldr	r3, [r7, #24]
 80189c0:	1c5a      	adds	r2, r3, #1
 80189c2:	61ba      	str	r2, [r7, #24]
 80189c4:	687a      	ldr	r2, [r7, #4]
 80189c6:	4413      	add	r3, r2
 80189c8:	69fa      	ldr	r2, [r7, #28]
 80189ca:	b2d2      	uxtb	r2, r2
 80189cc:	701a      	strb	r2, [r3, #0]
	return rv;
 80189ce:	69bb      	ldr	r3, [r7, #24]
}
 80189d0:	4618      	mov	r0, r3
 80189d2:	3720      	adds	r7, #32
 80189d4:	46bd      	mov	sp, r7
 80189d6:	bd80      	pop	{r7, pc}

080189d8 <sint64_pack>:
 * \return
 *      Number of bytes written to `out`.
 */
static inline size_t
sint64_pack(int64_t value, uint8_t *out)
{
 80189d8:	b580      	push	{r7, lr}
 80189da:	b084      	sub	sp, #16
 80189dc:	af00      	add	r7, sp, #0
 80189de:	e9c7 0102 	strd	r0, r1, [r7, #8]
 80189e2:	607a      	str	r2, [r7, #4]
	return uint64_pack(zigzag64(value), out);
 80189e4:	e9d7 0102 	ldrd	r0, r1, [r7, #8]
 80189e8:	f7ff face 	bl	8017f88 <zigzag64>
 80189ec:	687a      	ldr	r2, [r7, #4]
 80189ee:	f7ff ff6f 	bl	80188d0 <uint64_pack>
 80189f2:	4603      	mov	r3, r0
}
 80189f4:	4618      	mov	r0, r3
 80189f6:	3710      	adds	r7, #16
 80189f8:	46bd      	mov	sp, r7
 80189fa:	bd80      	pop	{r7, pc}

080189fc <fixed32_pack>:
 * \return
 *      Number of bytes written to `out`.
 */
static inline size_t
fixed32_pack(uint32_t value, void *out)
{
 80189fc:	b480      	push	{r7}
 80189fe:	b083      	sub	sp, #12
 8018a00:	af00      	add	r7, sp, #0
 8018a02:	6078      	str	r0, [r7, #4]
 8018a04:	6039      	str	r1, [r7, #0]
 8018a06:	687a      	ldr	r2, [r7, #4]
#if !defined(WORDS_BIGENDIAN)
	memcpy(out, &value, 4);
 8018a08:	683b      	ldr	r3, [r7, #0]
 8018a0a:	601a      	str	r2, [r3, #0]
	buf[0] = value;
	buf[1] = value >> 8;
	buf[2] = value >> 16;
	buf[3] = value >> 24;
#endif
	return 4;
 8018a0c:	2304      	movs	r3, #4
}
 8018a0e:	4618      	mov	r0, r3
 8018a10:	370c      	adds	r7, #12
 8018a12:	46bd      	mov	sp, r7
 8018a14:	f85d 7b04 	ldr.w	r7, [sp], #4
 8018a18:	4770      	bx	lr

08018a1a <fixed64_pack>:
 * \return
 *      Number of bytes written to `out`.
 */
static inline size_t
fixed64_pack(uint64_t value, void *out)
{
 8018a1a:	b580      	push	{r7, lr}
 8018a1c:	b084      	sub	sp, #16
 8018a1e:	af00      	add	r7, sp, #0
 8018a20:	e9c7 0102 	strd	r0, r1, [r7, #8]
 8018a24:	607a      	str	r2, [r7, #4]
#if !defined(WORDS_BIGENDIAN)
	memcpy(out, &value, 8);
 8018a26:	f107 0308 	add.w	r3, r7, #8
 8018a2a:	2208      	movs	r2, #8
 8018a2c:	4619      	mov	r1, r3
 8018a2e:	6878      	ldr	r0, [r7, #4]
 8018a30:	f006 fefc 	bl	801f82c <memcpy>
#else
	fixed32_pack(value, out);
	fixed32_pack(value >> 32, ((char *) out) + 4);
#endif
	return 8;
 8018a34:	2308      	movs	r3, #8
}
 8018a36:	4618      	mov	r0, r3
 8018a38:	3710      	adds	r7, #16
 8018a3a:	46bd      	mov	sp, r7
 8018a3c:	bd80      	pop	{r7, pc}

08018a3e <boolean_pack>:
 * \return
 *      Number of bytes written to `out`.
 */
static inline size_t
boolean_pack(protobuf_c_boolean value, uint8_t *out)
{
 8018a3e:	b480      	push	{r7}
 8018a40:	b083      	sub	sp, #12
 8018a42:	af00      	add	r7, sp, #0
 8018a44:	6078      	str	r0, [r7, #4]
 8018a46:	6039      	str	r1, [r7, #0]
	*out = value ? TRUE : FALSE;
 8018a48:	687b      	ldr	r3, [r7, #4]
 8018a4a:	2b00      	cmp	r3, #0
 8018a4c:	bf14      	ite	ne
 8018a4e:	2301      	movne	r3, #1
 8018a50:	2300      	moveq	r3, #0
 8018a52:	b2db      	uxtb	r3, r3
 8018a54:	461a      	mov	r2, r3
 8018a56:	683b      	ldr	r3, [r7, #0]
 8018a58:	701a      	strb	r2, [r3, #0]
	return 1;
 8018a5a:	2301      	movs	r3, #1
}
 8018a5c:	4618      	mov	r0, r3
 8018a5e:	370c      	adds	r7, #12
 8018a60:	46bd      	mov	sp, r7
 8018a62:	f85d 7b04 	ldr.w	r7, [sp], #4
 8018a66:	4770      	bx	lr

08018a68 <string_pack>:
 * \return
 *      Number of bytes written to `out`.
 */
static inline size_t
string_pack(const char *str, uint8_t *out)
{
 8018a68:	b580      	push	{r7, lr}
 8018a6a:	b084      	sub	sp, #16
 8018a6c:	af00      	add	r7, sp, #0
 8018a6e:	6078      	str	r0, [r7, #4]
 8018a70:	6039      	str	r1, [r7, #0]
	if (str == NULL) {
 8018a72:	687b      	ldr	r3, [r7, #4]
 8018a74:	2b00      	cmp	r3, #0
 8018a76:	d104      	bne.n	8018a82 <string_pack+0x1a>
		out[0] = 0;
 8018a78:	683b      	ldr	r3, [r7, #0]
 8018a7a:	2200      	movs	r2, #0
 8018a7c:	701a      	strb	r2, [r3, #0]
		return 1;
 8018a7e:	2301      	movs	r3, #1
 8018a80:	e013      	b.n	8018aaa <string_pack+0x42>
	} else {
		size_t len = strlen(str);
 8018a82:	6878      	ldr	r0, [r7, #4]
 8018a84:	f7e7 fd52 	bl	800052c <strlen>
 8018a88:	60f8      	str	r0, [r7, #12]
		size_t rv = uint32_pack(len, out);
 8018a8a:	6839      	ldr	r1, [r7, #0]
 8018a8c:	68f8      	ldr	r0, [r7, #12]
 8018a8e:	f7ff fe5b 	bl	8018748 <uint32_pack>
 8018a92:	60b8      	str	r0, [r7, #8]
		memcpy(out + rv, str, len);
 8018a94:	683a      	ldr	r2, [r7, #0]
 8018a96:	68bb      	ldr	r3, [r7, #8]
 8018a98:	4413      	add	r3, r2
 8018a9a:	68fa      	ldr	r2, [r7, #12]
 8018a9c:	6879      	ldr	r1, [r7, #4]
 8018a9e:	4618      	mov	r0, r3
 8018aa0:	f006 fec4 	bl	801f82c <memcpy>
		return rv + len;
 8018aa4:	68ba      	ldr	r2, [r7, #8]
 8018aa6:	68fb      	ldr	r3, [r7, #12]
 8018aa8:	4413      	add	r3, r2
	}
}
 8018aaa:	4618      	mov	r0, r3
 8018aac:	3710      	adds	r7, #16
 8018aae:	46bd      	mov	sp, r7
 8018ab0:	bd80      	pop	{r7, pc}

08018ab2 <binary_data_pack>:
 * \return
 *      Number of bytes written to `out`.
 */
static inline size_t
binary_data_pack(const ProtobufCBinaryData *bd, uint8_t *out)
{
 8018ab2:	b580      	push	{r7, lr}
 8018ab4:	b084      	sub	sp, #16
 8018ab6:	af00      	add	r7, sp, #0
 8018ab8:	6078      	str	r0, [r7, #4]
 8018aba:	6039      	str	r1, [r7, #0]
	size_t len = bd->len;
 8018abc:	687b      	ldr	r3, [r7, #4]
 8018abe:	681b      	ldr	r3, [r3, #0]
 8018ac0:	60fb      	str	r3, [r7, #12]
	size_t rv = uint32_pack(len, out);
 8018ac2:	6839      	ldr	r1, [r7, #0]
 8018ac4:	68f8      	ldr	r0, [r7, #12]
 8018ac6:	f7ff fe3f 	bl	8018748 <uint32_pack>
 8018aca:	60b8      	str	r0, [r7, #8]
	memcpy(out + rv, bd->data, len);
 8018acc:	683a      	ldr	r2, [r7, #0]
 8018ace:	68bb      	ldr	r3, [r7, #8]
 8018ad0:	18d0      	adds	r0, r2, r3
 8018ad2:	687b      	ldr	r3, [r7, #4]
 8018ad4:	685b      	ldr	r3, [r3, #4]
 8018ad6:	68fa      	ldr	r2, [r7, #12]
 8018ad8:	4619      	mov	r1, r3
 8018ada:	f006 fea7 	bl	801f82c <memcpy>
	return rv + len;
 8018ade:	68ba      	ldr	r2, [r7, #8]
 8018ae0:	68fb      	ldr	r3, [r7, #12]
 8018ae2:	4413      	add	r3, r2
}
 8018ae4:	4618      	mov	r0, r3
 8018ae6:	3710      	adds	r7, #16
 8018ae8:	46bd      	mov	sp, r7
 8018aea:	bd80      	pop	{r7, pc}

08018aec <prefixed_message_pack>:
 * \return
 *      Number of bytes written to `out`.
 */
static inline size_t
prefixed_message_pack(const ProtobufCMessage *message, uint8_t *out)
{
 8018aec:	b580      	push	{r7, lr}
 8018aee:	b084      	sub	sp, #16
 8018af0:	af00      	add	r7, sp, #0
 8018af2:	6078      	str	r0, [r7, #4]
 8018af4:	6039      	str	r1, [r7, #0]
	if (message == NULL) {
 8018af6:	687b      	ldr	r3, [r7, #4]
 8018af8:	2b00      	cmp	r3, #0
 8018afa:	d104      	bne.n	8018b06 <prefixed_message_pack+0x1a>
		out[0] = 0;
 8018afc:	683b      	ldr	r3, [r7, #0]
 8018afe:	2200      	movs	r2, #0
 8018b00:	701a      	strb	r2, [r3, #0]
		return 1;
 8018b02:	2301      	movs	r3, #1
 8018b04:	e01d      	b.n	8018b42 <prefixed_message_pack+0x56>
	} else {
		size_t rv = protobuf_c_message_pack(message, out + 1);
 8018b06:	683b      	ldr	r3, [r7, #0]
 8018b08:	3301      	adds	r3, #1
 8018b0a:	4619      	mov	r1, r3
 8018b0c:	6878      	ldr	r0, [r7, #4]
 8018b0e:	f000 fbe9 	bl	80192e4 <protobuf_c_message_pack>
 8018b12:	60f8      	str	r0, [r7, #12]
		uint32_t rv_packed_size = uint32_size(rv);
 8018b14:	68f8      	ldr	r0, [r7, #12]
 8018b16:	f7ff f996 	bl	8017e46 <uint32_size>
 8018b1a:	60b8      	str	r0, [r7, #8]
		if (rv_packed_size != 1)
 8018b1c:	68bb      	ldr	r3, [r7, #8]
 8018b1e:	2b01      	cmp	r3, #1
 8018b20:	d008      	beq.n	8018b34 <prefixed_message_pack+0x48>
			memmove(out + rv_packed_size, out + 1, rv);
 8018b22:	683a      	ldr	r2, [r7, #0]
 8018b24:	68bb      	ldr	r3, [r7, #8]
 8018b26:	18d0      	adds	r0, r2, r3
 8018b28:	683b      	ldr	r3, [r7, #0]
 8018b2a:	3301      	adds	r3, #1
 8018b2c:	68fa      	ldr	r2, [r7, #12]
 8018b2e:	4619      	mov	r1, r3
 8018b30:	f006 fe8a 	bl	801f848 <memmove>
		return uint32_pack(rv, out) + rv;
 8018b34:	6839      	ldr	r1, [r7, #0]
 8018b36:	68f8      	ldr	r0, [r7, #12]
 8018b38:	f7ff fe06 	bl	8018748 <uint32_pack>
 8018b3c:	4602      	mov	r2, r0
 8018b3e:	68fb      	ldr	r3, [r7, #12]
 8018b40:	4413      	add	r3, r2
	}
}
 8018b42:	4618      	mov	r0, r3
 8018b44:	3710      	adds	r7, #16
 8018b46:	46bd      	mov	sp, r7
 8018b48:	bd80      	pop	{r7, pc}

08018b4a <tag_pack>:
 * \return
 *      Number of bytes written to `out`.
 */
static size_t
tag_pack(uint32_t id, uint8_t *out)
{
 8018b4a:	b5b0      	push	{r4, r5, r7, lr}
 8018b4c:	b082      	sub	sp, #8
 8018b4e:	af00      	add	r7, sp, #0
 8018b50:	6078      	str	r0, [r7, #4]
 8018b52:	6039      	str	r1, [r7, #0]
	if (id < (1UL << (32 - 3)))
 8018b54:	6879      	ldr	r1, [r7, #4]
 8018b56:	f1b1 5f00 	cmp.w	r1, #536870912	; 0x20000000
 8018b5a:	d207      	bcs.n	8018b6c <tag_pack+0x22>
		return uint32_pack(id << 3, out);
 8018b5c:	687b      	ldr	r3, [r7, #4]
 8018b5e:	00db      	lsls	r3, r3, #3
 8018b60:	6839      	ldr	r1, [r7, #0]
 8018b62:	4618      	mov	r0, r3
 8018b64:	f7ff fdf0 	bl	8018748 <uint32_pack>
 8018b68:	4603      	mov	r3, r0
 8018b6a:	e00b      	b.n	8018b84 <tag_pack+0x3a>
	else
		return uint64_pack(((uint64_t) id) << 3, out);
 8018b6c:	6879      	ldr	r1, [r7, #4]
 8018b6e:	2000      	movs	r0, #0
 8018b70:	460a      	mov	r2, r1
 8018b72:	4603      	mov	r3, r0
 8018b74:	0f55      	lsrs	r5, r2, #29
 8018b76:	00d4      	lsls	r4, r2, #3
 8018b78:	683a      	ldr	r2, [r7, #0]
 8018b7a:	4620      	mov	r0, r4
 8018b7c:	4629      	mov	r1, r5
 8018b7e:	f7ff fea7 	bl	80188d0 <uint64_pack>
 8018b82:	4603      	mov	r3, r0
}
 8018b84:	4618      	mov	r0, r3
 8018b86:	3708      	adds	r7, #8
 8018b88:	46bd      	mov	sp, r7
 8018b8a:	bdb0      	pop	{r4, r5, r7, pc}

08018b8c <required_field_pack>:
 *      Number of bytes written to `out`.
 */
static size_t
required_field_pack(const ProtobufCFieldDescriptor *field,
		    const void *member, uint8_t *out)
{
 8018b8c:	b580      	push	{r7, lr}
 8018b8e:	b086      	sub	sp, #24
 8018b90:	af00      	add	r7, sp, #0
 8018b92:	60f8      	str	r0, [r7, #12]
 8018b94:	60b9      	str	r1, [r7, #8]
 8018b96:	607a      	str	r2, [r7, #4]
	size_t rv = tag_pack(field->id, out);
 8018b98:	68fb      	ldr	r3, [r7, #12]
 8018b9a:	685b      	ldr	r3, [r3, #4]
 8018b9c:	6879      	ldr	r1, [r7, #4]
 8018b9e:	4618      	mov	r0, r3
 8018ba0:	f7ff ffd3 	bl	8018b4a <tag_pack>
 8018ba4:	6178      	str	r0, [r7, #20]

	switch (field->type) {
 8018ba6:	68fb      	ldr	r3, [r7, #12]
 8018ba8:	7a5b      	ldrb	r3, [r3, #9]
 8018baa:	2b10      	cmp	r3, #16
 8018bac:	f200 80e7 	bhi.w	8018d7e <required_field_pack+0x1f2>
 8018bb0:	a201      	add	r2, pc, #4	; (adr r2, 8018bb8 <required_field_pack+0x2c>)
 8018bb2:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8018bb6:	bf00      	nop
 8018bb8:	08018c1d 	.word	0x08018c1d
 8018bbc:	08018bfd 	.word	0x08018bfd
 8018bc0:	08018ca1 	.word	0x08018ca1
 8018bc4:	08018c7f 	.word	0x08018c7f
 8018bc8:	08018c5d 	.word	0x08018c5d
 8018bcc:	08018cc7 	.word	0x08018cc7
 8018bd0:	08018c3d 	.word	0x08018c3d
 8018bd4:	08018ca1 	.word	0x08018ca1
 8018bd8:	08018c7f 	.word	0x08018c7f
 8018bdc:	08018cc7 	.word	0x08018cc7
 8018be0:	08018ca1 	.word	0x08018ca1
 8018be4:	08018cc7 	.word	0x08018cc7
 8018be8:	08018cef 	.word	0x08018cef
 8018bec:	08018c1d 	.word	0x08018c1d
 8018bf0:	08018d0f 	.word	0x08018d0f
 8018bf4:	08018d35 	.word	0x08018d35
 8018bf8:	08018d59 	.word	0x08018d59
	case PROTOBUF_C_TYPE_SINT32:
		out[0] |= PROTOBUF_C_WIRE_TYPE_VARINT;
 8018bfc:	687b      	ldr	r3, [r7, #4]
 8018bfe:	781a      	ldrb	r2, [r3, #0]
 8018c00:	687b      	ldr	r3, [r7, #4]
 8018c02:	701a      	strb	r2, [r3, #0]
		return rv + sint32_pack(*(const int32_t *) member, out + rv);
 8018c04:	68bb      	ldr	r3, [r7, #8]
 8018c06:	6818      	ldr	r0, [r3, #0]
 8018c08:	687a      	ldr	r2, [r7, #4]
 8018c0a:	697b      	ldr	r3, [r7, #20]
 8018c0c:	4413      	add	r3, r2
 8018c0e:	4619      	mov	r1, r3
 8018c10:	f7ff fe4c 	bl	80188ac <sint32_pack>
 8018c14:	4602      	mov	r2, r0
 8018c16:	697b      	ldr	r3, [r7, #20]
 8018c18:	4413      	add	r3, r2
 8018c1a:	e0b7      	b.n	8018d8c <required_field_pack+0x200>
	case PROTOBUF_C_TYPE_ENUM:
	case PROTOBUF_C_TYPE_INT32:
		out[0] |= PROTOBUF_C_WIRE_TYPE_VARINT;
 8018c1c:	687b      	ldr	r3, [r7, #4]
 8018c1e:	781a      	ldrb	r2, [r3, #0]
 8018c20:	687b      	ldr	r3, [r7, #4]
 8018c22:	701a      	strb	r2, [r3, #0]
		return rv + int32_pack(*(const int32_t *) member, out + rv);
 8018c24:	68bb      	ldr	r3, [r7, #8]
 8018c26:	6818      	ldr	r0, [r3, #0]
 8018c28:	687a      	ldr	r2, [r7, #4]
 8018c2a:	697b      	ldr	r3, [r7, #20]
 8018c2c:	4413      	add	r3, r2
 8018c2e:	4619      	mov	r1, r3
 8018c30:	f7ff fde4 	bl	80187fc <int32_pack>
 8018c34:	4602      	mov	r2, r0
 8018c36:	697b      	ldr	r3, [r7, #20]
 8018c38:	4413      	add	r3, r2
 8018c3a:	e0a7      	b.n	8018d8c <required_field_pack+0x200>
	case PROTOBUF_C_TYPE_UINT32:
		out[0] |= PROTOBUF_C_WIRE_TYPE_VARINT;
 8018c3c:	687b      	ldr	r3, [r7, #4]
 8018c3e:	781a      	ldrb	r2, [r3, #0]
 8018c40:	687b      	ldr	r3, [r7, #4]
 8018c42:	701a      	strb	r2, [r3, #0]
		return rv + uint32_pack(*(const uint32_t *) member, out + rv);
 8018c44:	68bb      	ldr	r3, [r7, #8]
 8018c46:	6818      	ldr	r0, [r3, #0]
 8018c48:	687a      	ldr	r2, [r7, #4]
 8018c4a:	697b      	ldr	r3, [r7, #20]
 8018c4c:	4413      	add	r3, r2
 8018c4e:	4619      	mov	r1, r3
 8018c50:	f7ff fd7a 	bl	8018748 <uint32_pack>
 8018c54:	4602      	mov	r2, r0
 8018c56:	697b      	ldr	r3, [r7, #20]
 8018c58:	4413      	add	r3, r2
 8018c5a:	e097      	b.n	8018d8c <required_field_pack+0x200>
	case PROTOBUF_C_TYPE_SINT64:
		out[0] |= PROTOBUF_C_WIRE_TYPE_VARINT;
 8018c5c:	687b      	ldr	r3, [r7, #4]
 8018c5e:	781a      	ldrb	r2, [r3, #0]
 8018c60:	687b      	ldr	r3, [r7, #4]
 8018c62:	701a      	strb	r2, [r3, #0]
		return rv + sint64_pack(*(const int64_t *) member, out + rv);
 8018c64:	68bb      	ldr	r3, [r7, #8]
 8018c66:	e9d3 0100 	ldrd	r0, r1, [r3]
 8018c6a:	687a      	ldr	r2, [r7, #4]
 8018c6c:	697b      	ldr	r3, [r7, #20]
 8018c6e:	4413      	add	r3, r2
 8018c70:	461a      	mov	r2, r3
 8018c72:	f7ff feb1 	bl	80189d8 <sint64_pack>
 8018c76:	4602      	mov	r2, r0
 8018c78:	697b      	ldr	r3, [r7, #20]
 8018c7a:	4413      	add	r3, r2
 8018c7c:	e086      	b.n	8018d8c <required_field_pack+0x200>
	case PROTOBUF_C_TYPE_INT64:
	case PROTOBUF_C_TYPE_UINT64:
		out[0] |= PROTOBUF_C_WIRE_TYPE_VARINT;
 8018c7e:	687b      	ldr	r3, [r7, #4]
 8018c80:	781a      	ldrb	r2, [r3, #0]
 8018c82:	687b      	ldr	r3, [r7, #4]
 8018c84:	701a      	strb	r2, [r3, #0]
		return rv + uint64_pack(*(const uint64_t *) member, out + rv);
 8018c86:	68bb      	ldr	r3, [r7, #8]
 8018c88:	e9d3 0100 	ldrd	r0, r1, [r3]
 8018c8c:	687a      	ldr	r2, [r7, #4]
 8018c8e:	697b      	ldr	r3, [r7, #20]
 8018c90:	4413      	add	r3, r2
 8018c92:	461a      	mov	r2, r3
 8018c94:	f7ff fe1c 	bl	80188d0 <uint64_pack>
 8018c98:	4602      	mov	r2, r0
 8018c9a:	697b      	ldr	r3, [r7, #20]
 8018c9c:	4413      	add	r3, r2
 8018c9e:	e075      	b.n	8018d8c <required_field_pack+0x200>
	case PROTOBUF_C_TYPE_SFIXED32:
	case PROTOBUF_C_TYPE_FIXED32:
	case PROTOBUF_C_TYPE_FLOAT:
		out[0] |= PROTOBUF_C_WIRE_TYPE_32BIT;
 8018ca0:	687b      	ldr	r3, [r7, #4]
 8018ca2:	781b      	ldrb	r3, [r3, #0]
 8018ca4:	f043 0305 	orr.w	r3, r3, #5
 8018ca8:	b2da      	uxtb	r2, r3
 8018caa:	687b      	ldr	r3, [r7, #4]
 8018cac:	701a      	strb	r2, [r3, #0]
		return rv + fixed32_pack(*(const uint32_t *) member, out + rv);
 8018cae:	68bb      	ldr	r3, [r7, #8]
 8018cb0:	6818      	ldr	r0, [r3, #0]
 8018cb2:	687a      	ldr	r2, [r7, #4]
 8018cb4:	697b      	ldr	r3, [r7, #20]
 8018cb6:	4413      	add	r3, r2
 8018cb8:	4619      	mov	r1, r3
 8018cba:	f7ff fe9f 	bl	80189fc <fixed32_pack>
 8018cbe:	4602      	mov	r2, r0
 8018cc0:	697b      	ldr	r3, [r7, #20]
 8018cc2:	4413      	add	r3, r2
 8018cc4:	e062      	b.n	8018d8c <required_field_pack+0x200>
	case PROTOBUF_C_TYPE_SFIXED64:
	case PROTOBUF_C_TYPE_FIXED64:
	case PROTOBUF_C_TYPE_DOUBLE:
		out[0] |= PROTOBUF_C_WIRE_TYPE_64BIT;
 8018cc6:	687b      	ldr	r3, [r7, #4]
 8018cc8:	781b      	ldrb	r3, [r3, #0]
 8018cca:	f043 0301 	orr.w	r3, r3, #1
 8018cce:	b2da      	uxtb	r2, r3
 8018cd0:	687b      	ldr	r3, [r7, #4]
 8018cd2:	701a      	strb	r2, [r3, #0]
		return rv + fixed64_pack(*(const uint64_t *) member, out + rv);
 8018cd4:	68bb      	ldr	r3, [r7, #8]
 8018cd6:	e9d3 0100 	ldrd	r0, r1, [r3]
 8018cda:	687a      	ldr	r2, [r7, #4]
 8018cdc:	697b      	ldr	r3, [r7, #20]
 8018cde:	4413      	add	r3, r2
 8018ce0:	461a      	mov	r2, r3
 8018ce2:	f7ff fe9a 	bl	8018a1a <fixed64_pack>
 8018ce6:	4602      	mov	r2, r0
 8018ce8:	697b      	ldr	r3, [r7, #20]
 8018cea:	4413      	add	r3, r2
 8018cec:	e04e      	b.n	8018d8c <required_field_pack+0x200>
	case PROTOBUF_C_TYPE_BOOL:
		out[0] |= PROTOBUF_C_WIRE_TYPE_VARINT;
 8018cee:	687b      	ldr	r3, [r7, #4]
 8018cf0:	781a      	ldrb	r2, [r3, #0]
 8018cf2:	687b      	ldr	r3, [r7, #4]
 8018cf4:	701a      	strb	r2, [r3, #0]
		return rv + boolean_pack(*(const protobuf_c_boolean *) member, out + rv);
 8018cf6:	68bb      	ldr	r3, [r7, #8]
 8018cf8:	6818      	ldr	r0, [r3, #0]
 8018cfa:	687a      	ldr	r2, [r7, #4]
 8018cfc:	697b      	ldr	r3, [r7, #20]
 8018cfe:	4413      	add	r3, r2
 8018d00:	4619      	mov	r1, r3
 8018d02:	f7ff fe9c 	bl	8018a3e <boolean_pack>
 8018d06:	4602      	mov	r2, r0
 8018d08:	697b      	ldr	r3, [r7, #20]
 8018d0a:	4413      	add	r3, r2
 8018d0c:	e03e      	b.n	8018d8c <required_field_pack+0x200>
	case PROTOBUF_C_TYPE_STRING:
		out[0] |= PROTOBUF_C_WIRE_TYPE_LENGTH_PREFIXED;
 8018d0e:	687b      	ldr	r3, [r7, #4]
 8018d10:	781b      	ldrb	r3, [r3, #0]
 8018d12:	f043 0302 	orr.w	r3, r3, #2
 8018d16:	b2da      	uxtb	r2, r3
 8018d18:	687b      	ldr	r3, [r7, #4]
 8018d1a:	701a      	strb	r2, [r3, #0]
		return rv + string_pack(*(char *const *) member, out + rv);
 8018d1c:	68bb      	ldr	r3, [r7, #8]
 8018d1e:	6818      	ldr	r0, [r3, #0]
 8018d20:	687a      	ldr	r2, [r7, #4]
 8018d22:	697b      	ldr	r3, [r7, #20]
 8018d24:	4413      	add	r3, r2
 8018d26:	4619      	mov	r1, r3
 8018d28:	f7ff fe9e 	bl	8018a68 <string_pack>
 8018d2c:	4602      	mov	r2, r0
 8018d2e:	697b      	ldr	r3, [r7, #20]
 8018d30:	4413      	add	r3, r2
 8018d32:	e02b      	b.n	8018d8c <required_field_pack+0x200>
	case PROTOBUF_C_TYPE_BYTES:
		out[0] |= PROTOBUF_C_WIRE_TYPE_LENGTH_PREFIXED;
 8018d34:	687b      	ldr	r3, [r7, #4]
 8018d36:	781b      	ldrb	r3, [r3, #0]
 8018d38:	f043 0302 	orr.w	r3, r3, #2
 8018d3c:	b2da      	uxtb	r2, r3
 8018d3e:	687b      	ldr	r3, [r7, #4]
 8018d40:	701a      	strb	r2, [r3, #0]
		return rv + binary_data_pack((const ProtobufCBinaryData *) member, out + rv);
 8018d42:	687a      	ldr	r2, [r7, #4]
 8018d44:	697b      	ldr	r3, [r7, #20]
 8018d46:	4413      	add	r3, r2
 8018d48:	4619      	mov	r1, r3
 8018d4a:	68b8      	ldr	r0, [r7, #8]
 8018d4c:	f7ff feb1 	bl	8018ab2 <binary_data_pack>
 8018d50:	4602      	mov	r2, r0
 8018d52:	697b      	ldr	r3, [r7, #20]
 8018d54:	4413      	add	r3, r2
 8018d56:	e019      	b.n	8018d8c <required_field_pack+0x200>
	case PROTOBUF_C_TYPE_MESSAGE:
		out[0] |= PROTOBUF_C_WIRE_TYPE_LENGTH_PREFIXED;
 8018d58:	687b      	ldr	r3, [r7, #4]
 8018d5a:	781b      	ldrb	r3, [r3, #0]
 8018d5c:	f043 0302 	orr.w	r3, r3, #2
 8018d60:	b2da      	uxtb	r2, r3
 8018d62:	687b      	ldr	r3, [r7, #4]
 8018d64:	701a      	strb	r2, [r3, #0]
		return rv + prefixed_message_pack(*(ProtobufCMessage * const *) member, out + rv);
 8018d66:	68bb      	ldr	r3, [r7, #8]
 8018d68:	6818      	ldr	r0, [r3, #0]
 8018d6a:	687a      	ldr	r2, [r7, #4]
 8018d6c:	697b      	ldr	r3, [r7, #20]
 8018d6e:	4413      	add	r3, r2
 8018d70:	4619      	mov	r1, r3
 8018d72:	f7ff febb 	bl	8018aec <prefixed_message_pack>
 8018d76:	4602      	mov	r2, r0
 8018d78:	697b      	ldr	r3, [r7, #20]
 8018d7a:	4413      	add	r3, r2
 8018d7c:	e006      	b.n	8018d8c <required_field_pack+0x200>
	}
	PROTOBUF_C__ASSERT_NOT_REACHED();
 8018d7e:	4b05      	ldr	r3, [pc, #20]	; (8018d94 <required_field_pack+0x208>)
 8018d80:	4a05      	ldr	r2, [pc, #20]	; (8018d98 <required_field_pack+0x20c>)
 8018d82:	f240 416d 	movw	r1, #1133	; 0x46d
 8018d86:	4805      	ldr	r0, [pc, #20]	; (8018d9c <required_field_pack+0x210>)
 8018d88:	f006 fce6 	bl	801f758 <__assert_func>
	return 0;
}
 8018d8c:	4618      	mov	r0, r3
 8018d8e:	3718      	adds	r7, #24
 8018d90:	46bd      	mov	sp, r7
 8018d92:	bd80      	pop	{r7, pc}
 8018d94:	080242e4 	.word	0x080242e4
 8018d98:	080286e0 	.word	0x080286e0
 8018d9c:	080242e8 	.word	0x080242e8

08018da0 <oneof_field_pack>:
 */
static size_t
oneof_field_pack(const ProtobufCFieldDescriptor *field,
		 uint32_t oneof_case,
		 const void *member, uint8_t *out)
{
 8018da0:	b580      	push	{r7, lr}
 8018da2:	b086      	sub	sp, #24
 8018da4:	af00      	add	r7, sp, #0
 8018da6:	60f8      	str	r0, [r7, #12]
 8018da8:	60b9      	str	r1, [r7, #8]
 8018daa:	607a      	str	r2, [r7, #4]
 8018dac:	603b      	str	r3, [r7, #0]
	if (oneof_case != field->id) {
 8018dae:	68fb      	ldr	r3, [r7, #12]
 8018db0:	685b      	ldr	r3, [r3, #4]
 8018db2:	68ba      	ldr	r2, [r7, #8]
 8018db4:	429a      	cmp	r2, r3
 8018db6:	d001      	beq.n	8018dbc <oneof_field_pack+0x1c>
		return 0;
 8018db8:	2300      	movs	r3, #0
 8018dba:	e01a      	b.n	8018df2 <oneof_field_pack+0x52>
	}
	if (field->type == PROTOBUF_C_TYPE_MESSAGE ||
 8018dbc:	68fb      	ldr	r3, [r7, #12]
 8018dbe:	7a5b      	ldrb	r3, [r3, #9]
 8018dc0:	2b10      	cmp	r3, #16
 8018dc2:	d003      	beq.n	8018dcc <oneof_field_pack+0x2c>
	    field->type == PROTOBUF_C_TYPE_STRING)
 8018dc4:	68fb      	ldr	r3, [r7, #12]
 8018dc6:	7a5b      	ldrb	r3, [r3, #9]
	if (field->type == PROTOBUF_C_TYPE_MESSAGE ||
 8018dc8:	2b0e      	cmp	r3, #14
 8018dca:	d10c      	bne.n	8018de6 <oneof_field_pack+0x46>
	{
		const void *ptr = *(const void * const *) member;
 8018dcc:	687b      	ldr	r3, [r7, #4]
 8018dce:	681b      	ldr	r3, [r3, #0]
 8018dd0:	617b      	str	r3, [r7, #20]
		if (ptr == NULL || ptr == field->default_value)
 8018dd2:	697b      	ldr	r3, [r7, #20]
 8018dd4:	2b00      	cmp	r3, #0
 8018dd6:	d004      	beq.n	8018de2 <oneof_field_pack+0x42>
 8018dd8:	68fb      	ldr	r3, [r7, #12]
 8018dda:	699b      	ldr	r3, [r3, #24]
 8018ddc:	697a      	ldr	r2, [r7, #20]
 8018dde:	429a      	cmp	r2, r3
 8018de0:	d101      	bne.n	8018de6 <oneof_field_pack+0x46>
			return 0;
 8018de2:	2300      	movs	r3, #0
 8018de4:	e005      	b.n	8018df2 <oneof_field_pack+0x52>
	}
	return required_field_pack(field, member, out);
 8018de6:	683a      	ldr	r2, [r7, #0]
 8018de8:	6879      	ldr	r1, [r7, #4]
 8018dea:	68f8      	ldr	r0, [r7, #12]
 8018dec:	f7ff fece 	bl	8018b8c <required_field_pack>
 8018df0:	4603      	mov	r3, r0
}
 8018df2:	4618      	mov	r0, r3
 8018df4:	3718      	adds	r7, #24
 8018df6:	46bd      	mov	sp, r7
 8018df8:	bd80      	pop	{r7, pc}

08018dfa <optional_field_pack>:
 */
static size_t
optional_field_pack(const ProtobufCFieldDescriptor *field,
		    const protobuf_c_boolean has,
		    const void *member, uint8_t *out)
{
 8018dfa:	b580      	push	{r7, lr}
 8018dfc:	b086      	sub	sp, #24
 8018dfe:	af00      	add	r7, sp, #0
 8018e00:	60f8      	str	r0, [r7, #12]
 8018e02:	60b9      	str	r1, [r7, #8]
 8018e04:	607a      	str	r2, [r7, #4]
 8018e06:	603b      	str	r3, [r7, #0]
	if (field->type == PROTOBUF_C_TYPE_MESSAGE ||
 8018e08:	68fb      	ldr	r3, [r7, #12]
 8018e0a:	7a5b      	ldrb	r3, [r3, #9]
 8018e0c:	2b10      	cmp	r3, #16
 8018e0e:	d003      	beq.n	8018e18 <optional_field_pack+0x1e>
	    field->type == PROTOBUF_C_TYPE_STRING)
 8018e10:	68fb      	ldr	r3, [r7, #12]
 8018e12:	7a5b      	ldrb	r3, [r3, #9]
	if (field->type == PROTOBUF_C_TYPE_MESSAGE ||
 8018e14:	2b0e      	cmp	r3, #14
 8018e16:	d10c      	bne.n	8018e32 <optional_field_pack+0x38>
	{
		const void *ptr = *(const void * const *) member;
 8018e18:	687b      	ldr	r3, [r7, #4]
 8018e1a:	681b      	ldr	r3, [r3, #0]
 8018e1c:	617b      	str	r3, [r7, #20]
		if (ptr == NULL || ptr == field->default_value)
 8018e1e:	697b      	ldr	r3, [r7, #20]
 8018e20:	2b00      	cmp	r3, #0
 8018e22:	d004      	beq.n	8018e2e <optional_field_pack+0x34>
 8018e24:	68fb      	ldr	r3, [r7, #12]
 8018e26:	699b      	ldr	r3, [r3, #24]
 8018e28:	697a      	ldr	r2, [r7, #20]
 8018e2a:	429a      	cmp	r2, r3
 8018e2c:	d106      	bne.n	8018e3c <optional_field_pack+0x42>
			return 0;
 8018e2e:	2300      	movs	r3, #0
 8018e30:	e00b      	b.n	8018e4a <optional_field_pack+0x50>
	} else {
		if (!has)
 8018e32:	68bb      	ldr	r3, [r7, #8]
 8018e34:	2b00      	cmp	r3, #0
 8018e36:	d102      	bne.n	8018e3e <optional_field_pack+0x44>
			return 0;
 8018e38:	2300      	movs	r3, #0
 8018e3a:	e006      	b.n	8018e4a <optional_field_pack+0x50>
	{
 8018e3c:	bf00      	nop
	}
	return required_field_pack(field, member, out);
 8018e3e:	683a      	ldr	r2, [r7, #0]
 8018e40:	6879      	ldr	r1, [r7, #4]
 8018e42:	68f8      	ldr	r0, [r7, #12]
 8018e44:	f7ff fea2 	bl	8018b8c <required_field_pack>
 8018e48:	4603      	mov	r3, r0
}
 8018e4a:	4618      	mov	r0, r3
 8018e4c:	3718      	adds	r7, #24
 8018e4e:	46bd      	mov	sp, r7
 8018e50:	bd80      	pop	{r7, pc}

08018e52 <unlabeled_field_pack>:
 *      Number of bytes written to `out`.
 */
static size_t
unlabeled_field_pack(const ProtobufCFieldDescriptor *field,
		     const void *member, uint8_t *out)
{
 8018e52:	b580      	push	{r7, lr}
 8018e54:	b084      	sub	sp, #16
 8018e56:	af00      	add	r7, sp, #0
 8018e58:	60f8      	str	r0, [r7, #12]
 8018e5a:	60b9      	str	r1, [r7, #8]
 8018e5c:	607a      	str	r2, [r7, #4]
	if (field_is_zeroish(field, member))
 8018e5e:	68b9      	ldr	r1, [r7, #8]
 8018e60:	68f8      	ldr	r0, [r7, #12]
 8018e62:	f7ff f9dd 	bl	8018220 <field_is_zeroish>
 8018e66:	4603      	mov	r3, r0
 8018e68:	2b00      	cmp	r3, #0
 8018e6a:	d001      	beq.n	8018e70 <unlabeled_field_pack+0x1e>
		return 0;
 8018e6c:	2300      	movs	r3, #0
 8018e6e:	e005      	b.n	8018e7c <unlabeled_field_pack+0x2a>
	return required_field_pack(field, member, out);
 8018e70:	687a      	ldr	r2, [r7, #4]
 8018e72:	68b9      	ldr	r1, [r7, #8]
 8018e74:	68f8      	ldr	r0, [r7, #12]
 8018e76:	f7ff fe89 	bl	8018b8c <required_field_pack>
 8018e7a:	4603      	mov	r3, r0
}
 8018e7c:	4618      	mov	r0, r3
 8018e7e:	3710      	adds	r7, #16
 8018e80:	46bd      	mov	sp, r7
 8018e82:	bd80      	pop	{r7, pc}

08018e84 <sizeof_elt_in_repeated_array>:
 * \return
 *      Size of the field.
 */
static inline size_t
sizeof_elt_in_repeated_array(ProtobufCType type)
{
 8018e84:	b580      	push	{r7, lr}
 8018e86:	b082      	sub	sp, #8
 8018e88:	af00      	add	r7, sp, #0
 8018e8a:	4603      	mov	r3, r0
 8018e8c:	71fb      	strb	r3, [r7, #7]
	switch (type) {
 8018e8e:	79fb      	ldrb	r3, [r7, #7]
 8018e90:	2b10      	cmp	r3, #16
 8018e92:	d82f      	bhi.n	8018ef4 <sizeof_elt_in_repeated_array+0x70>
 8018e94:	a201      	add	r2, pc, #4	; (adr r2, 8018e9c <sizeof_elt_in_repeated_array+0x18>)
 8018e96:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8018e9a:	bf00      	nop
 8018e9c:	08018ee1 	.word	0x08018ee1
 8018ea0:	08018ee1 	.word	0x08018ee1
 8018ea4:	08018ee1 	.word	0x08018ee1
 8018ea8:	08018ee5 	.word	0x08018ee5
 8018eac:	08018ee5 	.word	0x08018ee5
 8018eb0:	08018ee5 	.word	0x08018ee5
 8018eb4:	08018ee1 	.word	0x08018ee1
 8018eb8:	08018ee1 	.word	0x08018ee1
 8018ebc:	08018ee5 	.word	0x08018ee5
 8018ec0:	08018ee5 	.word	0x08018ee5
 8018ec4:	08018ee1 	.word	0x08018ee1
 8018ec8:	08018ee5 	.word	0x08018ee5
 8018ecc:	08018ee9 	.word	0x08018ee9
 8018ed0:	08018ee1 	.word	0x08018ee1
 8018ed4:	08018eed 	.word	0x08018eed
 8018ed8:	08018ef1 	.word	0x08018ef1
 8018edc:	08018eed 	.word	0x08018eed
	case PROTOBUF_C_TYPE_UINT32:
	case PROTOBUF_C_TYPE_SFIXED32:
	case PROTOBUF_C_TYPE_FIXED32:
	case PROTOBUF_C_TYPE_FLOAT:
	case PROTOBUF_C_TYPE_ENUM:
		return 4;
 8018ee0:	2304      	movs	r3, #4
 8018ee2:	e00e      	b.n	8018f02 <sizeof_elt_in_repeated_array+0x7e>
	case PROTOBUF_C_TYPE_INT64:
	case PROTOBUF_C_TYPE_UINT64:
	case PROTOBUF_C_TYPE_SFIXED64:
	case PROTOBUF_C_TYPE_FIXED64:
	case PROTOBUF_C_TYPE_DOUBLE:
		return 8;
 8018ee4:	2308      	movs	r3, #8
 8018ee6:	e00c      	b.n	8018f02 <sizeof_elt_in_repeated_array+0x7e>
	case PROTOBUF_C_TYPE_BOOL:
		return sizeof(protobuf_c_boolean);
 8018ee8:	2304      	movs	r3, #4
 8018eea:	e00a      	b.n	8018f02 <sizeof_elt_in_repeated_array+0x7e>
	case PROTOBUF_C_TYPE_STRING:
	case PROTOBUF_C_TYPE_MESSAGE:
		return sizeof(void *);
 8018eec:	2304      	movs	r3, #4
 8018eee:	e008      	b.n	8018f02 <sizeof_elt_in_repeated_array+0x7e>
	case PROTOBUF_C_TYPE_BYTES:
		return sizeof(ProtobufCBinaryData);
 8018ef0:	2308      	movs	r3, #8
 8018ef2:	e006      	b.n	8018f02 <sizeof_elt_in_repeated_array+0x7e>
	}
	PROTOBUF_C__ASSERT_NOT_REACHED();
 8018ef4:	4b05      	ldr	r3, [pc, #20]	; (8018f0c <sizeof_elt_in_repeated_array+0x88>)
 8018ef6:	4a06      	ldr	r2, [pc, #24]	; (8018f10 <sizeof_elt_in_repeated_array+0x8c>)
 8018ef8:	f240 41ec 	movw	r1, #1260	; 0x4ec
 8018efc:	4805      	ldr	r0, [pc, #20]	; (8018f14 <sizeof_elt_in_repeated_array+0x90>)
 8018efe:	f006 fc2b 	bl	801f758 <__assert_func>
	return 0;
}
 8018f02:	4618      	mov	r0, r3
 8018f04:	3708      	adds	r7, #8
 8018f06:	46bd      	mov	sp, r7
 8018f08:	bd80      	pop	{r7, pc}
 8018f0a:	bf00      	nop
 8018f0c:	080242e4 	.word	0x080242e4
 8018f10:	08028708 	.word	0x08028708
 8018f14:	080242e8 	.word	0x080242e8

08018f18 <copy_to_little_endian_32>:
 * \param[in] n
 *      Number of elements in the source array.
 */
static void
copy_to_little_endian_32(void *out, const void *in, const unsigned n)
{
 8018f18:	b580      	push	{r7, lr}
 8018f1a:	b084      	sub	sp, #16
 8018f1c:	af00      	add	r7, sp, #0
 8018f1e:	60f8      	str	r0, [r7, #12]
 8018f20:	60b9      	str	r1, [r7, #8]
 8018f22:	607a      	str	r2, [r7, #4]
#if !defined(WORDS_BIGENDIAN)
	memcpy(out, in, n * 4);
 8018f24:	687b      	ldr	r3, [r7, #4]
 8018f26:	009b      	lsls	r3, r3, #2
 8018f28:	461a      	mov	r2, r3
 8018f2a:	68b9      	ldr	r1, [r7, #8]
 8018f2c:	68f8      	ldr	r0, [r7, #12]
 8018f2e:	f006 fc7d 	bl	801f82c <memcpy>
	unsigned i;
	const uint32_t *ini = in;
	for (i = 0; i < n; i++)
		fixed32_pack(ini[i], (uint32_t *) out + i);
#endif
}
 8018f32:	bf00      	nop
 8018f34:	3710      	adds	r7, #16
 8018f36:	46bd      	mov	sp, r7
 8018f38:	bd80      	pop	{r7, pc}

08018f3a <copy_to_little_endian_64>:
 * \param[in] n
 *      Number of elements in the source array.
 */
static void
copy_to_little_endian_64(void *out, const void *in, const unsigned n)
{
 8018f3a:	b580      	push	{r7, lr}
 8018f3c:	b084      	sub	sp, #16
 8018f3e:	af00      	add	r7, sp, #0
 8018f40:	60f8      	str	r0, [r7, #12]
 8018f42:	60b9      	str	r1, [r7, #8]
 8018f44:	607a      	str	r2, [r7, #4]
#if !defined(WORDS_BIGENDIAN)
	memcpy(out, in, n * 8);
 8018f46:	687b      	ldr	r3, [r7, #4]
 8018f48:	00db      	lsls	r3, r3, #3
 8018f4a:	461a      	mov	r2, r3
 8018f4c:	68b9      	ldr	r1, [r7, #8]
 8018f4e:	68f8      	ldr	r0, [r7, #12]
 8018f50:	f006 fc6c 	bl	801f82c <memcpy>
	unsigned i;
	const uint64_t *ini = in;
	for (i = 0; i < n; i++)
		fixed64_pack(ini[i], (uint64_t *) out + i);
#endif
}
 8018f54:	bf00      	nop
 8018f56:	3710      	adds	r7, #16
 8018f58:	46bd      	mov	sp, r7
 8018f5a:	bd80      	pop	{r7, pc}

08018f5c <get_type_min_size>:
 * \return
 *      Number of bytes.
 */
static unsigned
get_type_min_size(ProtobufCType type)
{
 8018f5c:	b480      	push	{r7}
 8018f5e:	b083      	sub	sp, #12
 8018f60:	af00      	add	r7, sp, #0
 8018f62:	4603      	mov	r3, r0
 8018f64:	71fb      	strb	r3, [r7, #7]
	if (type == PROTOBUF_C_TYPE_SFIXED32 ||
 8018f66:	79fb      	ldrb	r3, [r7, #7]
 8018f68:	2b02      	cmp	r3, #2
 8018f6a:	d005      	beq.n	8018f78 <get_type_min_size+0x1c>
 8018f6c:	79fb      	ldrb	r3, [r7, #7]
 8018f6e:	2b07      	cmp	r3, #7
 8018f70:	d002      	beq.n	8018f78 <get_type_min_size+0x1c>
	    type == PROTOBUF_C_TYPE_FIXED32 ||
 8018f72:	79fb      	ldrb	r3, [r7, #7]
 8018f74:	2b0a      	cmp	r3, #10
 8018f76:	d101      	bne.n	8018f7c <get_type_min_size+0x20>
	    type == PROTOBUF_C_TYPE_FLOAT)
	{
		return 4;
 8018f78:	2304      	movs	r3, #4
 8018f7a:	e00b      	b.n	8018f94 <get_type_min_size+0x38>
	}
	if (type == PROTOBUF_C_TYPE_SFIXED64 ||
 8018f7c:	79fb      	ldrb	r3, [r7, #7]
 8018f7e:	2b05      	cmp	r3, #5
 8018f80:	d005      	beq.n	8018f8e <get_type_min_size+0x32>
 8018f82:	79fb      	ldrb	r3, [r7, #7]
 8018f84:	2b09      	cmp	r3, #9
 8018f86:	d002      	beq.n	8018f8e <get_type_min_size+0x32>
	    type == PROTOBUF_C_TYPE_FIXED64 ||
 8018f88:	79fb      	ldrb	r3, [r7, #7]
 8018f8a:	2b0b      	cmp	r3, #11
 8018f8c:	d101      	bne.n	8018f92 <get_type_min_size+0x36>
	    type == PROTOBUF_C_TYPE_DOUBLE)
	{
		return 8;
 8018f8e:	2308      	movs	r3, #8
 8018f90:	e000      	b.n	8018f94 <get_type_min_size+0x38>
	}
	return 1;
 8018f92:	2301      	movs	r3, #1
}
 8018f94:	4618      	mov	r0, r3
 8018f96:	370c      	adds	r7, #12
 8018f98:	46bd      	mov	sp, r7
 8018f9a:	f85d 7b04 	ldr.w	r7, [sp], #4
 8018f9e:	4770      	bx	lr

08018fa0 <repeated_field_pack>:
 *      Number of bytes serialised to `out`.
 */
static size_t
repeated_field_pack(const ProtobufCFieldDescriptor *field,
		    size_t count, const void *member, uint8_t *out)
{
 8018fa0:	b580      	push	{r7, lr}
 8018fa2:	b096      	sub	sp, #88	; 0x58
 8018fa4:	af00      	add	r7, sp, #0
 8018fa6:	60f8      	str	r0, [r7, #12]
 8018fa8:	60b9      	str	r1, [r7, #8]
 8018faa:	607a      	str	r2, [r7, #4]
 8018fac:	603b      	str	r3, [r7, #0]
	void *array = *(void * const *) member;
 8018fae:	687b      	ldr	r3, [r7, #4]
 8018fb0:	681b      	ldr	r3, [r3, #0]
 8018fb2:	657b      	str	r3, [r7, #84]	; 0x54
	unsigned i;

	if (0 != (field->flags & PROTOBUF_C_FIELD_FLAG_PACKED)) {
 8018fb4:	68fb      	ldr	r3, [r7, #12]
 8018fb6:	69db      	ldr	r3, [r3, #28]
 8018fb8:	f003 0301 	and.w	r3, r3, #1
 8018fbc:	2b00      	cmp	r3, #0
 8018fbe:	f000 813b 	beq.w	8019238 <repeated_field_pack+0x298>
		unsigned payload_len;
		unsigned length_size_min;
		unsigned actual_length_size;
		uint8_t *payload_at;

		if (count == 0)
 8018fc2:	68bb      	ldr	r3, [r7, #8]
 8018fc4:	2b00      	cmp	r3, #0
 8018fc6:	d101      	bne.n	8018fcc <repeated_field_pack+0x2c>
			return 0;
 8018fc8:	2300      	movs	r3, #0
 8018fca:	e158      	b.n	801927e <repeated_field_pack+0x2de>
		header_len = tag_pack(field->id, out);
 8018fcc:	68fb      	ldr	r3, [r7, #12]
 8018fce:	685b      	ldr	r3, [r3, #4]
 8018fd0:	6839      	ldr	r1, [r7, #0]
 8018fd2:	4618      	mov	r0, r3
 8018fd4:	f7ff fdb9 	bl	8018b4a <tag_pack>
 8018fd8:	64f8      	str	r0, [r7, #76]	; 0x4c
		out[0] |= PROTOBUF_C_WIRE_TYPE_LENGTH_PREFIXED;
 8018fda:	683b      	ldr	r3, [r7, #0]
 8018fdc:	781b      	ldrb	r3, [r3, #0]
 8018fde:	f043 0302 	orr.w	r3, r3, #2
 8018fe2:	b2da      	uxtb	r2, r3
 8018fe4:	683b      	ldr	r3, [r7, #0]
 8018fe6:	701a      	strb	r2, [r3, #0]
		len_start = header_len;
 8018fe8:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8018fea:	63fb      	str	r3, [r7, #60]	; 0x3c
		min_length = get_type_min_size(field->type) * count;
 8018fec:	68fb      	ldr	r3, [r7, #12]
 8018fee:	7a5b      	ldrb	r3, [r3, #9]
 8018ff0:	4618      	mov	r0, r3
 8018ff2:	f7ff ffb3 	bl	8018f5c <get_type_min_size>
 8018ff6:	4602      	mov	r2, r0
 8018ff8:	68bb      	ldr	r3, [r7, #8]
 8018ffa:	fb02 f303 	mul.w	r3, r2, r3
 8018ffe:	63bb      	str	r3, [r7, #56]	; 0x38
		length_size_min = uint32_size(min_length);
 8019000:	6bb8      	ldr	r0, [r7, #56]	; 0x38
 8019002:	f7fe ff20 	bl	8017e46 <uint32_size>
 8019006:	6378      	str	r0, [r7, #52]	; 0x34
		header_len += length_size_min;
 8019008:	6cfa      	ldr	r2, [r7, #76]	; 0x4c
 801900a:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 801900c:	4413      	add	r3, r2
 801900e:	64fb      	str	r3, [r7, #76]	; 0x4c
		payload_at = out + header_len;
 8019010:	683a      	ldr	r2, [r7, #0]
 8019012:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8019014:	4413      	add	r3, r2
 8019016:	64bb      	str	r3, [r7, #72]	; 0x48

		switch (field->type) {
 8019018:	68fb      	ldr	r3, [r7, #12]
 801901a:	7a5b      	ldrb	r3, [r3, #9]
 801901c:	2b0d      	cmp	r3, #13
 801901e:	f200 80d1 	bhi.w	80191c4 <repeated_field_pack+0x224>
 8019022:	a201      	add	r2, pc, #4	; (adr r2, 8019028 <repeated_field_pack+0x88>)
 8019024:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8019028:	0801908d 	.word	0x0801908d
 801902c:	080190c1 	.word	0x080190c1
 8019030:	08019061 	.word	0x08019061
 8019034:	0801915d 	.word	0x0801915d
 8019038:	080190f5 	.word	0x080190f5
 801903c:	08019077 	.word	0x08019077
 8019040:	08019129 	.word	0x08019129
 8019044:	08019061 	.word	0x08019061
 8019048:	0801915d 	.word	0x0801915d
 801904c:	08019077 	.word	0x08019077
 8019050:	08019061 	.word	0x08019061
 8019054:	08019077 	.word	0x08019077
 8019058:	08019191 	.word	0x08019191
 801905c:	0801908d 	.word	0x0801908d
		case PROTOBUF_C_TYPE_SFIXED32:
		case PROTOBUF_C_TYPE_FIXED32:
		case PROTOBUF_C_TYPE_FLOAT:
			copy_to_little_endian_32(payload_at, array, count);
 8019060:	68ba      	ldr	r2, [r7, #8]
 8019062:	6d79      	ldr	r1, [r7, #84]	; 0x54
 8019064:	6cb8      	ldr	r0, [r7, #72]	; 0x48
 8019066:	f7ff ff57 	bl	8018f18 <copy_to_little_endian_32>
			payload_at += count * 4;
 801906a:	68bb      	ldr	r3, [r7, #8]
 801906c:	009b      	lsls	r3, r3, #2
 801906e:	6cba      	ldr	r2, [r7, #72]	; 0x48
 8019070:	4413      	add	r3, r2
 8019072:	64bb      	str	r3, [r7, #72]	; 0x48
			break;
 8019074:	e0ad      	b.n	80191d2 <repeated_field_pack+0x232>
		case PROTOBUF_C_TYPE_SFIXED64:
		case PROTOBUF_C_TYPE_FIXED64:
		case PROTOBUF_C_TYPE_DOUBLE:
			copy_to_little_endian_64(payload_at, array, count);
 8019076:	68ba      	ldr	r2, [r7, #8]
 8019078:	6d79      	ldr	r1, [r7, #84]	; 0x54
 801907a:	6cb8      	ldr	r0, [r7, #72]	; 0x48
 801907c:	f7ff ff5d 	bl	8018f3a <copy_to_little_endian_64>
			payload_at += count * 8;
 8019080:	68bb      	ldr	r3, [r7, #8]
 8019082:	00db      	lsls	r3, r3, #3
 8019084:	6cba      	ldr	r2, [r7, #72]	; 0x48
 8019086:	4413      	add	r3, r2
 8019088:	64bb      	str	r3, [r7, #72]	; 0x48
			break;
 801908a:	e0a2      	b.n	80191d2 <repeated_field_pack+0x232>
		case PROTOBUF_C_TYPE_ENUM:
		case PROTOBUF_C_TYPE_INT32: {
			const int32_t *arr = (const int32_t *) array;
 801908c:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 801908e:	61fb      	str	r3, [r7, #28]
			for (i = 0; i < count; i++)
 8019090:	2300      	movs	r3, #0
 8019092:	653b      	str	r3, [r7, #80]	; 0x50
 8019094:	e00f      	b.n	80190b6 <repeated_field_pack+0x116>
				payload_at += int32_pack(arr[i], payload_at);
 8019096:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 8019098:	009b      	lsls	r3, r3, #2
 801909a:	69fa      	ldr	r2, [r7, #28]
 801909c:	4413      	add	r3, r2
 801909e:	681b      	ldr	r3, [r3, #0]
 80190a0:	6cb9      	ldr	r1, [r7, #72]	; 0x48
 80190a2:	4618      	mov	r0, r3
 80190a4:	f7ff fbaa 	bl	80187fc <int32_pack>
 80190a8:	4602      	mov	r2, r0
 80190aa:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 80190ac:	4413      	add	r3, r2
 80190ae:	64bb      	str	r3, [r7, #72]	; 0x48
			for (i = 0; i < count; i++)
 80190b0:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 80190b2:	3301      	adds	r3, #1
 80190b4:	653b      	str	r3, [r7, #80]	; 0x50
 80190b6:	6d3a      	ldr	r2, [r7, #80]	; 0x50
 80190b8:	68bb      	ldr	r3, [r7, #8]
 80190ba:	429a      	cmp	r2, r3
 80190bc:	d3eb      	bcc.n	8019096 <repeated_field_pack+0xf6>
			break;
 80190be:	e088      	b.n	80191d2 <repeated_field_pack+0x232>
		}
		case PROTOBUF_C_TYPE_SINT32: {
			const int32_t *arr = (const int32_t *) array;
 80190c0:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 80190c2:	623b      	str	r3, [r7, #32]
			for (i = 0; i < count; i++)
 80190c4:	2300      	movs	r3, #0
 80190c6:	653b      	str	r3, [r7, #80]	; 0x50
 80190c8:	e00f      	b.n	80190ea <repeated_field_pack+0x14a>
				payload_at += sint32_pack(arr[i], payload_at);
 80190ca:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 80190cc:	009b      	lsls	r3, r3, #2
 80190ce:	6a3a      	ldr	r2, [r7, #32]
 80190d0:	4413      	add	r3, r2
 80190d2:	681b      	ldr	r3, [r3, #0]
 80190d4:	6cb9      	ldr	r1, [r7, #72]	; 0x48
 80190d6:	4618      	mov	r0, r3
 80190d8:	f7ff fbe8 	bl	80188ac <sint32_pack>
 80190dc:	4602      	mov	r2, r0
 80190de:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 80190e0:	4413      	add	r3, r2
 80190e2:	64bb      	str	r3, [r7, #72]	; 0x48
			for (i = 0; i < count; i++)
 80190e4:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 80190e6:	3301      	adds	r3, #1
 80190e8:	653b      	str	r3, [r7, #80]	; 0x50
 80190ea:	6d3a      	ldr	r2, [r7, #80]	; 0x50
 80190ec:	68bb      	ldr	r3, [r7, #8]
 80190ee:	429a      	cmp	r2, r3
 80190f0:	d3eb      	bcc.n	80190ca <repeated_field_pack+0x12a>
			break;
 80190f2:	e06e      	b.n	80191d2 <repeated_field_pack+0x232>
		}
		case PROTOBUF_C_TYPE_SINT64: {
			const int64_t *arr = (const int64_t *) array;
 80190f4:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 80190f6:	62bb      	str	r3, [r7, #40]	; 0x28
			for (i = 0; i < count; i++)
 80190f8:	2300      	movs	r3, #0
 80190fa:	653b      	str	r3, [r7, #80]	; 0x50
 80190fc:	e00f      	b.n	801911e <repeated_field_pack+0x17e>
				payload_at += sint64_pack(arr[i], payload_at);
 80190fe:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 8019100:	00db      	lsls	r3, r3, #3
 8019102:	6aba      	ldr	r2, [r7, #40]	; 0x28
 8019104:	4413      	add	r3, r2
 8019106:	e9d3 0100 	ldrd	r0, r1, [r3]
 801910a:	6cba      	ldr	r2, [r7, #72]	; 0x48
 801910c:	f7ff fc64 	bl	80189d8 <sint64_pack>
 8019110:	4602      	mov	r2, r0
 8019112:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 8019114:	4413      	add	r3, r2
 8019116:	64bb      	str	r3, [r7, #72]	; 0x48
			for (i = 0; i < count; i++)
 8019118:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 801911a:	3301      	adds	r3, #1
 801911c:	653b      	str	r3, [r7, #80]	; 0x50
 801911e:	6d3a      	ldr	r2, [r7, #80]	; 0x50
 8019120:	68bb      	ldr	r3, [r7, #8]
 8019122:	429a      	cmp	r2, r3
 8019124:	d3eb      	bcc.n	80190fe <repeated_field_pack+0x15e>
			break;
 8019126:	e054      	b.n	80191d2 <repeated_field_pack+0x232>
		}
		case PROTOBUF_C_TYPE_UINT32: {
			const uint32_t *arr = (const uint32_t *) array;
 8019128:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 801912a:	62fb      	str	r3, [r7, #44]	; 0x2c
			for (i = 0; i < count; i++)
 801912c:	2300      	movs	r3, #0
 801912e:	653b      	str	r3, [r7, #80]	; 0x50
 8019130:	e00f      	b.n	8019152 <repeated_field_pack+0x1b2>
				payload_at += uint32_pack(arr[i], payload_at);
 8019132:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 8019134:	009b      	lsls	r3, r3, #2
 8019136:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 8019138:	4413      	add	r3, r2
 801913a:	681b      	ldr	r3, [r3, #0]
 801913c:	6cb9      	ldr	r1, [r7, #72]	; 0x48
 801913e:	4618      	mov	r0, r3
 8019140:	f7ff fb02 	bl	8018748 <uint32_pack>
 8019144:	4602      	mov	r2, r0
 8019146:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 8019148:	4413      	add	r3, r2
 801914a:	64bb      	str	r3, [r7, #72]	; 0x48
			for (i = 0; i < count; i++)
 801914c:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 801914e:	3301      	adds	r3, #1
 8019150:	653b      	str	r3, [r7, #80]	; 0x50
 8019152:	6d3a      	ldr	r2, [r7, #80]	; 0x50
 8019154:	68bb      	ldr	r3, [r7, #8]
 8019156:	429a      	cmp	r2, r3
 8019158:	d3eb      	bcc.n	8019132 <repeated_field_pack+0x192>
			break;
 801915a:	e03a      	b.n	80191d2 <repeated_field_pack+0x232>
		}
		case PROTOBUF_C_TYPE_INT64:
		case PROTOBUF_C_TYPE_UINT64: {
			const uint64_t *arr = (const uint64_t *) array;
 801915c:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 801915e:	627b      	str	r3, [r7, #36]	; 0x24
			for (i = 0; i < count; i++)
 8019160:	2300      	movs	r3, #0
 8019162:	653b      	str	r3, [r7, #80]	; 0x50
 8019164:	e00f      	b.n	8019186 <repeated_field_pack+0x1e6>
				payload_at += uint64_pack(arr[i], payload_at);
 8019166:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 8019168:	00db      	lsls	r3, r3, #3
 801916a:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 801916c:	4413      	add	r3, r2
 801916e:	e9d3 0100 	ldrd	r0, r1, [r3]
 8019172:	6cba      	ldr	r2, [r7, #72]	; 0x48
 8019174:	f7ff fbac 	bl	80188d0 <uint64_pack>
 8019178:	4602      	mov	r2, r0
 801917a:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 801917c:	4413      	add	r3, r2
 801917e:	64bb      	str	r3, [r7, #72]	; 0x48
			for (i = 0; i < count; i++)
 8019180:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 8019182:	3301      	adds	r3, #1
 8019184:	653b      	str	r3, [r7, #80]	; 0x50
 8019186:	6d3a      	ldr	r2, [r7, #80]	; 0x50
 8019188:	68bb      	ldr	r3, [r7, #8]
 801918a:	429a      	cmp	r2, r3
 801918c:	d3eb      	bcc.n	8019166 <repeated_field_pack+0x1c6>
			break;
 801918e:	e020      	b.n	80191d2 <repeated_field_pack+0x232>
		}
		case PROTOBUF_C_TYPE_BOOL: {
			const protobuf_c_boolean *arr = (const protobuf_c_boolean *) array;
 8019190:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 8019192:	633b      	str	r3, [r7, #48]	; 0x30
			for (i = 0; i < count; i++)
 8019194:	2300      	movs	r3, #0
 8019196:	653b      	str	r3, [r7, #80]	; 0x50
 8019198:	e00f      	b.n	80191ba <repeated_field_pack+0x21a>
				payload_at += boolean_pack(arr[i], payload_at);
 801919a:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 801919c:	009b      	lsls	r3, r3, #2
 801919e:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 80191a0:	4413      	add	r3, r2
 80191a2:	681b      	ldr	r3, [r3, #0]
 80191a4:	6cb9      	ldr	r1, [r7, #72]	; 0x48
 80191a6:	4618      	mov	r0, r3
 80191a8:	f7ff fc49 	bl	8018a3e <boolean_pack>
 80191ac:	4602      	mov	r2, r0
 80191ae:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 80191b0:	4413      	add	r3, r2
 80191b2:	64bb      	str	r3, [r7, #72]	; 0x48
			for (i = 0; i < count; i++)
 80191b4:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 80191b6:	3301      	adds	r3, #1
 80191b8:	653b      	str	r3, [r7, #80]	; 0x50
 80191ba:	6d3a      	ldr	r2, [r7, #80]	; 0x50
 80191bc:	68bb      	ldr	r3, [r7, #8]
 80191be:	429a      	cmp	r2, r3
 80191c0:	d3eb      	bcc.n	801919a <repeated_field_pack+0x1fa>
			break;
 80191c2:	e006      	b.n	80191d2 <repeated_field_pack+0x232>
		}
		default:
			PROTOBUF_C__ASSERT_NOT_REACHED();
 80191c4:	4b30      	ldr	r3, [pc, #192]	; (8019288 <repeated_field_pack+0x2e8>)
 80191c6:	4a31      	ldr	r2, [pc, #196]	; (801928c <repeated_field_pack+0x2ec>)
 80191c8:	f240 5196 	movw	r1, #1430	; 0x596
 80191cc:	4830      	ldr	r0, [pc, #192]	; (8019290 <repeated_field_pack+0x2f0>)
 80191ce:	f006 fac3 	bl	801f758 <__assert_func>
		}

		payload_len = payload_at - (out + header_len);
 80191d2:	683a      	ldr	r2, [r7, #0]
 80191d4:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 80191d6:	4413      	add	r3, r2
 80191d8:	6cba      	ldr	r2, [r7, #72]	; 0x48
 80191da:	1ad3      	subs	r3, r2, r3
 80191dc:	61bb      	str	r3, [r7, #24]
		actual_length_size = uint32_size(payload_len);
 80191de:	69b8      	ldr	r0, [r7, #24]
 80191e0:	f7fe fe31 	bl	8017e46 <uint32_size>
 80191e4:	6178      	str	r0, [r7, #20]
		if (length_size_min != actual_length_size) {
 80191e6:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 80191e8:	697b      	ldr	r3, [r7, #20]
 80191ea:	429a      	cmp	r2, r3
 80191ec:	d019      	beq.n	8019222 <repeated_field_pack+0x282>
			assert(actual_length_size == length_size_min + 1);
 80191ee:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 80191f0:	3301      	adds	r3, #1
 80191f2:	697a      	ldr	r2, [r7, #20]
 80191f4:	429a      	cmp	r2, r3
 80191f6:	d006      	beq.n	8019206 <repeated_field_pack+0x266>
 80191f8:	4b26      	ldr	r3, [pc, #152]	; (8019294 <repeated_field_pack+0x2f4>)
 80191fa:	4a24      	ldr	r2, [pc, #144]	; (801928c <repeated_field_pack+0x2ec>)
 80191fc:	f240 519c 	movw	r1, #1436	; 0x59c
 8019200:	4823      	ldr	r0, [pc, #140]	; (8019290 <repeated_field_pack+0x2f0>)
 8019202:	f006 faa9 	bl	801f758 <__assert_func>
			memmove(out + header_len + 1, out + header_len,
 8019206:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8019208:	3301      	adds	r3, #1
 801920a:	683a      	ldr	r2, [r7, #0]
 801920c:	18d0      	adds	r0, r2, r3
 801920e:	683a      	ldr	r2, [r7, #0]
 8019210:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8019212:	4413      	add	r3, r2
 8019214:	69ba      	ldr	r2, [r7, #24]
 8019216:	4619      	mov	r1, r3
 8019218:	f006 fb16 	bl	801f848 <memmove>
				payload_len);
			header_len++;
 801921c:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 801921e:	3301      	adds	r3, #1
 8019220:	64fb      	str	r3, [r7, #76]	; 0x4c
		}
		uint32_pack(payload_len, out + len_start);
 8019222:	683a      	ldr	r2, [r7, #0]
 8019224:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8019226:	4413      	add	r3, r2
 8019228:	4619      	mov	r1, r3
 801922a:	69b8      	ldr	r0, [r7, #24]
 801922c:	f7ff fa8c 	bl	8018748 <uint32_pack>
		return header_len + payload_len;
 8019230:	6cfa      	ldr	r2, [r7, #76]	; 0x4c
 8019232:	69bb      	ldr	r3, [r7, #24]
 8019234:	4413      	add	r3, r2
 8019236:	e022      	b.n	801927e <repeated_field_pack+0x2de>
	} else {
		/* not "packed" cased */
		/* CONSIDER: optimize this case a bit (by putting the loop inside the switch) */
		size_t rv = 0;
 8019238:	2300      	movs	r3, #0
 801923a:	647b      	str	r3, [r7, #68]	; 0x44
		unsigned siz = sizeof_elt_in_repeated_array(field->type);
 801923c:	68fb      	ldr	r3, [r7, #12]
 801923e:	7a5b      	ldrb	r3, [r3, #9]
 8019240:	4618      	mov	r0, r3
 8019242:	f7ff fe1f 	bl	8018e84 <sizeof_elt_in_repeated_array>
 8019246:	6438      	str	r0, [r7, #64]	; 0x40

		for (i = 0; i < count; i++) {
 8019248:	2300      	movs	r3, #0
 801924a:	653b      	str	r3, [r7, #80]	; 0x50
 801924c:	e012      	b.n	8019274 <repeated_field_pack+0x2d4>
			rv += required_field_pack(field, array, out + rv);
 801924e:	683a      	ldr	r2, [r7, #0]
 8019250:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8019252:	4413      	add	r3, r2
 8019254:	461a      	mov	r2, r3
 8019256:	6d79      	ldr	r1, [r7, #84]	; 0x54
 8019258:	68f8      	ldr	r0, [r7, #12]
 801925a:	f7ff fc97 	bl	8018b8c <required_field_pack>
 801925e:	4602      	mov	r2, r0
 8019260:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8019262:	4413      	add	r3, r2
 8019264:	647b      	str	r3, [r7, #68]	; 0x44
			array = (char *)array + siz;
 8019266:	6d7a      	ldr	r2, [r7, #84]	; 0x54
 8019268:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 801926a:	4413      	add	r3, r2
 801926c:	657b      	str	r3, [r7, #84]	; 0x54
		for (i = 0; i < count; i++) {
 801926e:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 8019270:	3301      	adds	r3, #1
 8019272:	653b      	str	r3, [r7, #80]	; 0x50
 8019274:	6d3a      	ldr	r2, [r7, #80]	; 0x50
 8019276:	68bb      	ldr	r3, [r7, #8]
 8019278:	429a      	cmp	r2, r3
 801927a:	d3e8      	bcc.n	801924e <repeated_field_pack+0x2ae>
		}
		return rv;
 801927c:	6c7b      	ldr	r3, [r7, #68]	; 0x44
	}
}
 801927e:	4618      	mov	r0, r3
 8019280:	3758      	adds	r7, #88	; 0x58
 8019282:	46bd      	mov	sp, r7
 8019284:	bd80      	pop	{r7, pc}
 8019286:	bf00      	nop
 8019288:	080242e4 	.word	0x080242e4
 801928c:	080286f4 	.word	0x080286f4
 8019290:	080242e8 	.word	0x080242e8
 8019294:	08024388 	.word	0x08024388

08019298 <unknown_field_pack>:

static size_t
unknown_field_pack(const ProtobufCMessageUnknownField *field, uint8_t *out)
{
 8019298:	b580      	push	{r7, lr}
 801929a:	b084      	sub	sp, #16
 801929c:	af00      	add	r7, sp, #0
 801929e:	6078      	str	r0, [r7, #4]
 80192a0:	6039      	str	r1, [r7, #0]
	size_t rv = tag_pack(field->tag, out);
 80192a2:	687b      	ldr	r3, [r7, #4]
 80192a4:	681b      	ldr	r3, [r3, #0]
 80192a6:	6839      	ldr	r1, [r7, #0]
 80192a8:	4618      	mov	r0, r3
 80192aa:	f7ff fc4e 	bl	8018b4a <tag_pack>
 80192ae:	60f8      	str	r0, [r7, #12]
	out[0] |= field->wire_type;
 80192b0:	683b      	ldr	r3, [r7, #0]
 80192b2:	781a      	ldrb	r2, [r3, #0]
 80192b4:	687b      	ldr	r3, [r7, #4]
 80192b6:	791b      	ldrb	r3, [r3, #4]
 80192b8:	4313      	orrs	r3, r2
 80192ba:	b2da      	uxtb	r2, r3
 80192bc:	683b      	ldr	r3, [r7, #0]
 80192be:	701a      	strb	r2, [r3, #0]
	memcpy(out + rv, field->data, field->len);
 80192c0:	683a      	ldr	r2, [r7, #0]
 80192c2:	68fb      	ldr	r3, [r7, #12]
 80192c4:	18d0      	adds	r0, r2, r3
 80192c6:	687b      	ldr	r3, [r7, #4]
 80192c8:	68d9      	ldr	r1, [r3, #12]
 80192ca:	687b      	ldr	r3, [r7, #4]
 80192cc:	689b      	ldr	r3, [r3, #8]
 80192ce:	461a      	mov	r2, r3
 80192d0:	f006 faac 	bl	801f82c <memcpy>
	return rv + field->len;
 80192d4:	687b      	ldr	r3, [r7, #4]
 80192d6:	689a      	ldr	r2, [r3, #8]
 80192d8:	68fb      	ldr	r3, [r7, #12]
 80192da:	4413      	add	r3, r2
}
 80192dc:	4618      	mov	r0, r3
 80192de:	3710      	adds	r7, #16
 80192e0:	46bd      	mov	sp, r7
 80192e2:	bd80      	pop	{r7, pc}

080192e4 <protobuf_c_message_pack>:

/**@}*/

size_t
protobuf_c_message_pack(const ProtobufCMessage *message, uint8_t *out)
{
 80192e4:	b580      	push	{r7, lr}
 80192e6:	b088      	sub	sp, #32
 80192e8:	af00      	add	r7, sp, #0
 80192ea:	6078      	str	r0, [r7, #4]
 80192ec:	6039      	str	r1, [r7, #0]
	unsigned i;
	size_t rv = 0;
 80192ee:	2300      	movs	r3, #0
 80192f0:	61bb      	str	r3, [r7, #24]

	ASSERT_IS_MESSAGE(message);
 80192f2:	687b      	ldr	r3, [r7, #4]
 80192f4:	681b      	ldr	r3, [r3, #0]
 80192f6:	681b      	ldr	r3, [r3, #0]
 80192f8:	4a52      	ldr	r2, [pc, #328]	; (8019444 <protobuf_c_message_pack+0x160>)
 80192fa:	4293      	cmp	r3, r2
 80192fc:	d006      	beq.n	801930c <protobuf_c_message_pack+0x28>
 80192fe:	4b52      	ldr	r3, [pc, #328]	; (8019448 <protobuf_c_message_pack+0x164>)
 8019300:	4a52      	ldr	r2, [pc, #328]	; (801944c <protobuf_c_message_pack+0x168>)
 8019302:	f240 51c2 	movw	r1, #1474	; 0x5c2
 8019306:	4852      	ldr	r0, [pc, #328]	; (8019450 <protobuf_c_message_pack+0x16c>)
 8019308:	f006 fa26 	bl	801f758 <__assert_func>
	for (i = 0; i < message->descriptor->n_fields; i++) {
 801930c:	2300      	movs	r3, #0
 801930e:	61fb      	str	r3, [r7, #28]
 8019310:	e072      	b.n	80193f8 <protobuf_c_message_pack+0x114>
		const ProtobufCFieldDescriptor *field =
			message->descriptor->fields + i;
 8019312:	687b      	ldr	r3, [r7, #4]
 8019314:	681b      	ldr	r3, [r3, #0]
 8019316:	69da      	ldr	r2, [r3, #28]
 8019318:	69fb      	ldr	r3, [r7, #28]
 801931a:	212c      	movs	r1, #44	; 0x2c
 801931c:	fb01 f303 	mul.w	r3, r1, r3
		const ProtobufCFieldDescriptor *field =
 8019320:	4413      	add	r3, r2
 8019322:	617b      	str	r3, [r7, #20]
		const void *member = ((const char *) message) + field->offset;
 8019324:	697b      	ldr	r3, [r7, #20]
 8019326:	691b      	ldr	r3, [r3, #16]
 8019328:	687a      	ldr	r2, [r7, #4]
 801932a:	4413      	add	r3, r2
 801932c:	613b      	str	r3, [r7, #16]
		 *  - a field that is part of a oneof
		 *  - an optional field that isn't a pointer type
		 * (Meaning: not a message or a string).
		 */
		const void *qmember =
			((const char *) message) + field->quantifier_offset;
 801932e:	697b      	ldr	r3, [r7, #20]
 8019330:	68db      	ldr	r3, [r3, #12]
		const void *qmember =
 8019332:	687a      	ldr	r2, [r7, #4]
 8019334:	4413      	add	r3, r2
 8019336:	60fb      	str	r3, [r7, #12]

		if (field->label == PROTOBUF_C_LABEL_REQUIRED) {
 8019338:	697b      	ldr	r3, [r7, #20]
 801933a:	7a1b      	ldrb	r3, [r3, #8]
 801933c:	2b00      	cmp	r3, #0
 801933e:	d10c      	bne.n	801935a <protobuf_c_message_pack+0x76>
			rv += required_field_pack(field, member, out + rv);
 8019340:	683a      	ldr	r2, [r7, #0]
 8019342:	69bb      	ldr	r3, [r7, #24]
 8019344:	4413      	add	r3, r2
 8019346:	461a      	mov	r2, r3
 8019348:	6939      	ldr	r1, [r7, #16]
 801934a:	6978      	ldr	r0, [r7, #20]
 801934c:	f7ff fc1e 	bl	8018b8c <required_field_pack>
 8019350:	4602      	mov	r2, r0
 8019352:	69bb      	ldr	r3, [r7, #24]
 8019354:	4413      	add	r3, r2
 8019356:	61bb      	str	r3, [r7, #24]
 8019358:	e04b      	b.n	80193f2 <protobuf_c_message_pack+0x10e>
		} else if ((field->label == PROTOBUF_C_LABEL_OPTIONAL ||
 801935a:	697b      	ldr	r3, [r7, #20]
 801935c:	7a1b      	ldrb	r3, [r3, #8]
 801935e:	2b01      	cmp	r3, #1
 8019360:	d003      	beq.n	801936a <protobuf_c_message_pack+0x86>
			    field->label == PROTOBUF_C_LABEL_NONE) &&
 8019362:	697b      	ldr	r3, [r7, #20]
 8019364:	7a1b      	ldrb	r3, [r3, #8]
		} else if ((field->label == PROTOBUF_C_LABEL_OPTIONAL ||
 8019366:	2b03      	cmp	r3, #3
 8019368:	d113      	bne.n	8019392 <protobuf_c_message_pack+0xae>
			   (0 != (field->flags & PROTOBUF_C_FIELD_FLAG_ONEOF))) {
 801936a:	697b      	ldr	r3, [r7, #20]
 801936c:	69db      	ldr	r3, [r3, #28]
 801936e:	f003 0304 	and.w	r3, r3, #4
			    field->label == PROTOBUF_C_LABEL_NONE) &&
 8019372:	2b00      	cmp	r3, #0
 8019374:	d00d      	beq.n	8019392 <protobuf_c_message_pack+0xae>
			rv += oneof_field_pack(
 8019376:	68fb      	ldr	r3, [r7, #12]
 8019378:	6819      	ldr	r1, [r3, #0]
 801937a:	683a      	ldr	r2, [r7, #0]
 801937c:	69bb      	ldr	r3, [r7, #24]
 801937e:	4413      	add	r3, r2
 8019380:	693a      	ldr	r2, [r7, #16]
 8019382:	6978      	ldr	r0, [r7, #20]
 8019384:	f7ff fd0c 	bl	8018da0 <oneof_field_pack>
 8019388:	4602      	mov	r2, r0
 801938a:	69bb      	ldr	r3, [r7, #24]
 801938c:	4413      	add	r3, r2
 801938e:	61bb      	str	r3, [r7, #24]
				field,
				*(const uint32_t *) qmember,
				member,
				out + rv
			);
 8019390:	e02f      	b.n	80193f2 <protobuf_c_message_pack+0x10e>
		} else if (field->label == PROTOBUF_C_LABEL_OPTIONAL) {
 8019392:	697b      	ldr	r3, [r7, #20]
 8019394:	7a1b      	ldrb	r3, [r3, #8]
 8019396:	2b01      	cmp	r3, #1
 8019398:	d10d      	bne.n	80193b6 <protobuf_c_message_pack+0xd2>
			rv += optional_field_pack(
 801939a:	68fb      	ldr	r3, [r7, #12]
 801939c:	6819      	ldr	r1, [r3, #0]
 801939e:	683a      	ldr	r2, [r7, #0]
 80193a0:	69bb      	ldr	r3, [r7, #24]
 80193a2:	4413      	add	r3, r2
 80193a4:	693a      	ldr	r2, [r7, #16]
 80193a6:	6978      	ldr	r0, [r7, #20]
 80193a8:	f7ff fd27 	bl	8018dfa <optional_field_pack>
 80193ac:	4602      	mov	r2, r0
 80193ae:	69bb      	ldr	r3, [r7, #24]
 80193b0:	4413      	add	r3, r2
 80193b2:	61bb      	str	r3, [r7, #24]
 80193b4:	e01d      	b.n	80193f2 <protobuf_c_message_pack+0x10e>
				field,
				*(const protobuf_c_boolean *) qmember,
				member,
				out + rv
			);
		} else if (field->label == PROTOBUF_C_LABEL_NONE) {
 80193b6:	697b      	ldr	r3, [r7, #20]
 80193b8:	7a1b      	ldrb	r3, [r3, #8]
 80193ba:	2b03      	cmp	r3, #3
 80193bc:	d10c      	bne.n	80193d8 <protobuf_c_message_pack+0xf4>
			rv += unlabeled_field_pack(field, member, out + rv);
 80193be:	683a      	ldr	r2, [r7, #0]
 80193c0:	69bb      	ldr	r3, [r7, #24]
 80193c2:	4413      	add	r3, r2
 80193c4:	461a      	mov	r2, r3
 80193c6:	6939      	ldr	r1, [r7, #16]
 80193c8:	6978      	ldr	r0, [r7, #20]
 80193ca:	f7ff fd42 	bl	8018e52 <unlabeled_field_pack>
 80193ce:	4602      	mov	r2, r0
 80193d0:	69bb      	ldr	r3, [r7, #24]
 80193d2:	4413      	add	r3, r2
 80193d4:	61bb      	str	r3, [r7, #24]
 80193d6:	e00c      	b.n	80193f2 <protobuf_c_message_pack+0x10e>
		} else {
			rv += repeated_field_pack(field, *(const size_t *) qmember,
 80193d8:	68fb      	ldr	r3, [r7, #12]
 80193da:	6819      	ldr	r1, [r3, #0]
 80193dc:	683a      	ldr	r2, [r7, #0]
 80193de:	69bb      	ldr	r3, [r7, #24]
 80193e0:	4413      	add	r3, r2
 80193e2:	693a      	ldr	r2, [r7, #16]
 80193e4:	6978      	ldr	r0, [r7, #20]
 80193e6:	f7ff fddb 	bl	8018fa0 <repeated_field_pack>
 80193ea:	4602      	mov	r2, r0
 80193ec:	69bb      	ldr	r3, [r7, #24]
 80193ee:	4413      	add	r3, r2
 80193f0:	61bb      	str	r3, [r7, #24]
	for (i = 0; i < message->descriptor->n_fields; i++) {
 80193f2:	69fb      	ldr	r3, [r7, #28]
 80193f4:	3301      	adds	r3, #1
 80193f6:	61fb      	str	r3, [r7, #28]
 80193f8:	687b      	ldr	r3, [r7, #4]
 80193fa:	681b      	ldr	r3, [r3, #0]
 80193fc:	699b      	ldr	r3, [r3, #24]
 80193fe:	69fa      	ldr	r2, [r7, #28]
 8019400:	429a      	cmp	r2, r3
 8019402:	d386      	bcc.n	8019312 <protobuf_c_message_pack+0x2e>
				member, out + rv);
		}
	}
	for (i = 0; i < message->n_unknown_fields; i++)
 8019404:	2300      	movs	r3, #0
 8019406:	61fb      	str	r3, [r7, #28]
 8019408:	e011      	b.n	801942e <protobuf_c_message_pack+0x14a>
		rv += unknown_field_pack(&message->unknown_fields[i], out + rv);
 801940a:	687b      	ldr	r3, [r7, #4]
 801940c:	689a      	ldr	r2, [r3, #8]
 801940e:	69fb      	ldr	r3, [r7, #28]
 8019410:	011b      	lsls	r3, r3, #4
 8019412:	18d0      	adds	r0, r2, r3
 8019414:	683a      	ldr	r2, [r7, #0]
 8019416:	69bb      	ldr	r3, [r7, #24]
 8019418:	4413      	add	r3, r2
 801941a:	4619      	mov	r1, r3
 801941c:	f7ff ff3c 	bl	8019298 <unknown_field_pack>
 8019420:	4602      	mov	r2, r0
 8019422:	69bb      	ldr	r3, [r7, #24]
 8019424:	4413      	add	r3, r2
 8019426:	61bb      	str	r3, [r7, #24]
	for (i = 0; i < message->n_unknown_fields; i++)
 8019428:	69fb      	ldr	r3, [r7, #28]
 801942a:	3301      	adds	r3, #1
 801942c:	61fb      	str	r3, [r7, #28]
 801942e:	687b      	ldr	r3, [r7, #4]
 8019430:	685b      	ldr	r3, [r3, #4]
 8019432:	69fa      	ldr	r2, [r7, #28]
 8019434:	429a      	cmp	r2, r3
 8019436:	d3e8      	bcc.n	801940a <protobuf_c_message_pack+0x126>
	return rv;
 8019438:	69bb      	ldr	r3, [r7, #24]
}
 801943a:	4618      	mov	r0, r3
 801943c:	3720      	adds	r7, #32
 801943e:	46bd      	mov	sp, r7
 8019440:	bd80      	pop	{r7, pc}
 8019442:	bf00      	nop
 8019444:	28aaeef9 	.word	0x28aaeef9
 8019448:	08024340 	.word	0x08024340
 801944c:	08028728 	.word	0x08028728
 8019450:	080242e8 	.word	0x080242e8

08019454 <int_range_lookup>:
 * @{
 */

static inline int
int_range_lookup(unsigned n_ranges, const ProtobufCIntRange *ranges, int value)
{
 8019454:	b480      	push	{r7}
 8019456:	b08b      	sub	sp, #44	; 0x2c
 8019458:	af00      	add	r7, sp, #0
 801945a:	60f8      	str	r0, [r7, #12]
 801945c:	60b9      	str	r1, [r7, #8]
 801945e:	607a      	str	r2, [r7, #4]
	unsigned n;
	unsigned start;

	if (n_ranges == 0)
 8019460:	68fb      	ldr	r3, [r7, #12]
 8019462:	2b00      	cmp	r3, #0
 8019464:	d102      	bne.n	801946c <int_range_lookup+0x18>
		return -1;
 8019466:	f04f 33ff 	mov.w	r3, #4294967295
 801946a:	e07c      	b.n	8019566 <int_range_lookup+0x112>
	start = 0;
 801946c:	2300      	movs	r3, #0
 801946e:	623b      	str	r3, [r7, #32]
	n = n_ranges;
 8019470:	68fb      	ldr	r3, [r7, #12]
 8019472:	627b      	str	r3, [r7, #36]	; 0x24
	while (n > 1) {
 8019474:	e041      	b.n	80194fa <int_range_lookup+0xa6>
		unsigned mid = start + n / 2;
 8019476:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8019478:	085b      	lsrs	r3, r3, #1
 801947a:	6a3a      	ldr	r2, [r7, #32]
 801947c:	4413      	add	r3, r2
 801947e:	617b      	str	r3, [r7, #20]

		if (value < ranges[mid].start_value) {
 8019480:	697b      	ldr	r3, [r7, #20]
 8019482:	00db      	lsls	r3, r3, #3
 8019484:	68ba      	ldr	r2, [r7, #8]
 8019486:	4413      	add	r3, r2
 8019488:	681b      	ldr	r3, [r3, #0]
 801948a:	687a      	ldr	r2, [r7, #4]
 801948c:	429a      	cmp	r2, r3
 801948e:	da04      	bge.n	801949a <int_range_lookup+0x46>
			n = mid - start;
 8019490:	697a      	ldr	r2, [r7, #20]
 8019492:	6a3b      	ldr	r3, [r7, #32]
 8019494:	1ad3      	subs	r3, r2, r3
 8019496:	627b      	str	r3, [r7, #36]	; 0x24
 8019498:	e02f      	b.n	80194fa <int_range_lookup+0xa6>
		} else if (value >= ranges[mid].start_value +
 801949a:	697b      	ldr	r3, [r7, #20]
 801949c:	00db      	lsls	r3, r3, #3
 801949e:	68ba      	ldr	r2, [r7, #8]
 80194a0:	4413      	add	r3, r2
 80194a2:	681b      	ldr	r3, [r3, #0]
			   (int) (ranges[mid + 1].orig_index -
 80194a4:	697a      	ldr	r2, [r7, #20]
 80194a6:	3201      	adds	r2, #1
 80194a8:	00d2      	lsls	r2, r2, #3
 80194aa:	68b9      	ldr	r1, [r7, #8]
 80194ac:	440a      	add	r2, r1
 80194ae:	6851      	ldr	r1, [r2, #4]
				  ranges[mid].orig_index))
 80194b0:	697a      	ldr	r2, [r7, #20]
 80194b2:	00d2      	lsls	r2, r2, #3
 80194b4:	68b8      	ldr	r0, [r7, #8]
 80194b6:	4402      	add	r2, r0
 80194b8:	6852      	ldr	r2, [r2, #4]
			   (int) (ranges[mid + 1].orig_index -
 80194ba:	1a8a      	subs	r2, r1, r2
		} else if (value >= ranges[mid].start_value +
 80194bc:	4413      	add	r3, r2
 80194be:	687a      	ldr	r2, [r7, #4]
 80194c0:	429a      	cmp	r2, r3
 80194c2:	db0b      	blt.n	80194dc <int_range_lookup+0x88>
		{
			unsigned new_start = mid + 1;
 80194c4:	697b      	ldr	r3, [r7, #20]
 80194c6:	3301      	adds	r3, #1
 80194c8:	613b      	str	r3, [r7, #16]
			n = start + n - new_start;
 80194ca:	6a3a      	ldr	r2, [r7, #32]
 80194cc:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80194ce:	441a      	add	r2, r3
 80194d0:	693b      	ldr	r3, [r7, #16]
 80194d2:	1ad3      	subs	r3, r2, r3
 80194d4:	627b      	str	r3, [r7, #36]	; 0x24
			start = new_start;
 80194d6:	693b      	ldr	r3, [r7, #16]
 80194d8:	623b      	str	r3, [r7, #32]
 80194da:	e00e      	b.n	80194fa <int_range_lookup+0xa6>
		} else
			return (value - ranges[mid].start_value) +
 80194dc:	697b      	ldr	r3, [r7, #20]
 80194de:	00db      	lsls	r3, r3, #3
 80194e0:	68ba      	ldr	r2, [r7, #8]
 80194e2:	4413      	add	r3, r2
 80194e4:	681b      	ldr	r3, [r3, #0]
 80194e6:	687a      	ldr	r2, [r7, #4]
 80194e8:	1ad3      	subs	r3, r2, r3
 80194ea:	4619      	mov	r1, r3
			    ranges[mid].orig_index;
 80194ec:	697b      	ldr	r3, [r7, #20]
 80194ee:	00db      	lsls	r3, r3, #3
 80194f0:	68ba      	ldr	r2, [r7, #8]
 80194f2:	4413      	add	r3, r2
 80194f4:	685b      	ldr	r3, [r3, #4]
			return (value - ranges[mid].start_value) +
 80194f6:	440b      	add	r3, r1
 80194f8:	e035      	b.n	8019566 <int_range_lookup+0x112>
	while (n > 1) {
 80194fa:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80194fc:	2b01      	cmp	r3, #1
 80194fe:	d8ba      	bhi.n	8019476 <int_range_lookup+0x22>
	}
	if (n > 0) {
 8019500:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8019502:	2b00      	cmp	r3, #0
 8019504:	d02d      	beq.n	8019562 <int_range_lookup+0x10e>
		unsigned start_orig_index = ranges[start].orig_index;
 8019506:	6a3b      	ldr	r3, [r7, #32]
 8019508:	00db      	lsls	r3, r3, #3
 801950a:	68ba      	ldr	r2, [r7, #8]
 801950c:	4413      	add	r3, r2
 801950e:	685b      	ldr	r3, [r3, #4]
 8019510:	61fb      	str	r3, [r7, #28]
		unsigned range_size =
			ranges[start + 1].orig_index - start_orig_index;
 8019512:	6a3b      	ldr	r3, [r7, #32]
 8019514:	3301      	adds	r3, #1
 8019516:	00db      	lsls	r3, r3, #3
 8019518:	68ba      	ldr	r2, [r7, #8]
 801951a:	4413      	add	r3, r2
 801951c:	685a      	ldr	r2, [r3, #4]
		unsigned range_size =
 801951e:	69fb      	ldr	r3, [r7, #28]
 8019520:	1ad3      	subs	r3, r2, r3
 8019522:	61bb      	str	r3, [r7, #24]

		if (ranges[start].start_value <= value &&
 8019524:	6a3b      	ldr	r3, [r7, #32]
 8019526:	00db      	lsls	r3, r3, #3
 8019528:	68ba      	ldr	r2, [r7, #8]
 801952a:	4413      	add	r3, r2
 801952c:	681b      	ldr	r3, [r3, #0]
 801952e:	687a      	ldr	r2, [r7, #4]
 8019530:	429a      	cmp	r2, r3
 8019532:	db16      	blt.n	8019562 <int_range_lookup+0x10e>
		    value < (int) (ranges[start].start_value + range_size))
 8019534:	6a3b      	ldr	r3, [r7, #32]
 8019536:	00db      	lsls	r3, r3, #3
 8019538:	68ba      	ldr	r2, [r7, #8]
 801953a:	4413      	add	r3, r2
 801953c:	681b      	ldr	r3, [r3, #0]
 801953e:	461a      	mov	r2, r3
 8019540:	69bb      	ldr	r3, [r7, #24]
 8019542:	4413      	add	r3, r2
 8019544:	461a      	mov	r2, r3
		if (ranges[start].start_value <= value &&
 8019546:	687b      	ldr	r3, [r7, #4]
 8019548:	4293      	cmp	r3, r2
 801954a:	da0a      	bge.n	8019562 <int_range_lookup+0x10e>
		{
			return (value - ranges[start].start_value) +
 801954c:	6a3b      	ldr	r3, [r7, #32]
 801954e:	00db      	lsls	r3, r3, #3
 8019550:	68ba      	ldr	r2, [r7, #8]
 8019552:	4413      	add	r3, r2
 8019554:	681b      	ldr	r3, [r3, #0]
 8019556:	687a      	ldr	r2, [r7, #4]
 8019558:	1ad3      	subs	r3, r2, r3
 801955a:	461a      	mov	r2, r3
 801955c:	69fb      	ldr	r3, [r7, #28]
 801955e:	4413      	add	r3, r2
 8019560:	e001      	b.n	8019566 <int_range_lookup+0x112>
			    start_orig_index;
		}
	}
	return -1;
 8019562:	f04f 33ff 	mov.w	r3, #4294967295
}
 8019566:	4618      	mov	r0, r3
 8019568:	372c      	adds	r7, #44	; 0x2c
 801956a:	46bd      	mov	sp, r7
 801956c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8019570:	4770      	bx	lr

08019572 <parse_tag_and_wiretype>:
static size_t
parse_tag_and_wiretype(size_t len,
		       const uint8_t *data,
		       uint32_t *tag_out,
		       ProtobufCWireType *wiretype_out)
{
 8019572:	b480      	push	{r7}
 8019574:	b089      	sub	sp, #36	; 0x24
 8019576:	af00      	add	r7, sp, #0
 8019578:	60f8      	str	r0, [r7, #12]
 801957a:	60b9      	str	r1, [r7, #8]
 801957c:	607a      	str	r2, [r7, #4]
 801957e:	603b      	str	r3, [r7, #0]
	unsigned max_rv = len > 5 ? 5 : len;
 8019580:	68fb      	ldr	r3, [r7, #12]
 8019582:	2b05      	cmp	r3, #5
 8019584:	bf28      	it	cs
 8019586:	2305      	movcs	r3, #5
 8019588:	613b      	str	r3, [r7, #16]
	uint32_t tag = (data[0] & 0x7f) >> 3;
 801958a:	68bb      	ldr	r3, [r7, #8]
 801958c:	781b      	ldrb	r3, [r3, #0]
 801958e:	10db      	asrs	r3, r3, #3
 8019590:	f003 030f 	and.w	r3, r3, #15
 8019594:	61fb      	str	r3, [r7, #28]
	unsigned shift = 4;
 8019596:	2304      	movs	r3, #4
 8019598:	61bb      	str	r3, [r7, #24]
	unsigned rv;

	/* 0 is not a valid tag value */
	if ((data[0] & 0xf8) == 0) {
 801959a:	68bb      	ldr	r3, [r7, #8]
 801959c:	781b      	ldrb	r3, [r3, #0]
 801959e:	f003 03f8 	and.w	r3, r3, #248	; 0xf8
 80195a2:	2b00      	cmp	r3, #0
 80195a4:	d101      	bne.n	80195aa <parse_tag_and_wiretype+0x38>
		return 0;
 80195a6:	2300      	movs	r3, #0
 80195a8:	e045      	b.n	8019636 <parse_tag_and_wiretype+0xc4>
	}

	*wiretype_out = data[0] & 7;
 80195aa:	68bb      	ldr	r3, [r7, #8]
 80195ac:	781b      	ldrb	r3, [r3, #0]
 80195ae:	f003 0307 	and.w	r3, r3, #7
 80195b2:	b2da      	uxtb	r2, r3
 80195b4:	683b      	ldr	r3, [r7, #0]
 80195b6:	701a      	strb	r2, [r3, #0]
	if ((data[0] & 0x80) == 0) {
 80195b8:	68bb      	ldr	r3, [r7, #8]
 80195ba:	781b      	ldrb	r3, [r3, #0]
 80195bc:	b25b      	sxtb	r3, r3
 80195be:	2b00      	cmp	r3, #0
 80195c0:	db04      	blt.n	80195cc <parse_tag_and_wiretype+0x5a>
		*tag_out = tag;
 80195c2:	687b      	ldr	r3, [r7, #4]
 80195c4:	69fa      	ldr	r2, [r7, #28]
 80195c6:	601a      	str	r2, [r3, #0]
		return 1;
 80195c8:	2301      	movs	r3, #1
 80195ca:	e034      	b.n	8019636 <parse_tag_and_wiretype+0xc4>
	}
	for (rv = 1; rv < max_rv; rv++) {
 80195cc:	2301      	movs	r3, #1
 80195ce:	617b      	str	r3, [r7, #20]
 80195d0:	e02c      	b.n	801962c <parse_tag_and_wiretype+0xba>
		if (data[rv] & 0x80) {
 80195d2:	68ba      	ldr	r2, [r7, #8]
 80195d4:	697b      	ldr	r3, [r7, #20]
 80195d6:	4413      	add	r3, r2
 80195d8:	781b      	ldrb	r3, [r3, #0]
 80195da:	b25b      	sxtb	r3, r3
 80195dc:	2b00      	cmp	r3, #0
 80195de:	da10      	bge.n	8019602 <parse_tag_and_wiretype+0x90>
			tag |= (data[rv] & 0x7f) << shift;
 80195e0:	68ba      	ldr	r2, [r7, #8]
 80195e2:	697b      	ldr	r3, [r7, #20]
 80195e4:	4413      	add	r3, r2
 80195e6:	781b      	ldrb	r3, [r3, #0]
 80195e8:	f003 027f 	and.w	r2, r3, #127	; 0x7f
 80195ec:	69bb      	ldr	r3, [r7, #24]
 80195ee:	fa02 f303 	lsl.w	r3, r2, r3
 80195f2:	461a      	mov	r2, r3
 80195f4:	69fb      	ldr	r3, [r7, #28]
 80195f6:	4313      	orrs	r3, r2
 80195f8:	61fb      	str	r3, [r7, #28]
			shift += 7;
 80195fa:	69bb      	ldr	r3, [r7, #24]
 80195fc:	3307      	adds	r3, #7
 80195fe:	61bb      	str	r3, [r7, #24]
 8019600:	e011      	b.n	8019626 <parse_tag_and_wiretype+0xb4>
		} else {
			tag |= data[rv] << shift;
 8019602:	68ba      	ldr	r2, [r7, #8]
 8019604:	697b      	ldr	r3, [r7, #20]
 8019606:	4413      	add	r3, r2
 8019608:	781b      	ldrb	r3, [r3, #0]
 801960a:	461a      	mov	r2, r3
 801960c:	69bb      	ldr	r3, [r7, #24]
 801960e:	fa02 f303 	lsl.w	r3, r2, r3
 8019612:	461a      	mov	r2, r3
 8019614:	69fb      	ldr	r3, [r7, #28]
 8019616:	4313      	orrs	r3, r2
 8019618:	61fb      	str	r3, [r7, #28]
			*tag_out = tag;
 801961a:	687b      	ldr	r3, [r7, #4]
 801961c:	69fa      	ldr	r2, [r7, #28]
 801961e:	601a      	str	r2, [r3, #0]
			return rv + 1;
 8019620:	697b      	ldr	r3, [r7, #20]
 8019622:	3301      	adds	r3, #1
 8019624:	e007      	b.n	8019636 <parse_tag_and_wiretype+0xc4>
	for (rv = 1; rv < max_rv; rv++) {
 8019626:	697b      	ldr	r3, [r7, #20]
 8019628:	3301      	adds	r3, #1
 801962a:	617b      	str	r3, [r7, #20]
 801962c:	697a      	ldr	r2, [r7, #20]
 801962e:	693b      	ldr	r3, [r7, #16]
 8019630:	429a      	cmp	r2, r3
 8019632:	d3ce      	bcc.n	80195d2 <parse_tag_and_wiretype+0x60>
		}
	}
	return 0; /* error: bad header */
 8019634:	2300      	movs	r3, #0
}
 8019636:	4618      	mov	r0, r3
 8019638:	3724      	adds	r7, #36	; 0x24
 801963a:	46bd      	mov	sp, r7
 801963c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8019640:	4770      	bx	lr

08019642 <scan_length_prefixed_data>:
};

static inline size_t
scan_length_prefixed_data(size_t len, const uint8_t *data,
			  size_t *prefix_len_out)
{
 8019642:	b480      	push	{r7}
 8019644:	b08b      	sub	sp, #44	; 0x2c
 8019646:	af00      	add	r7, sp, #0
 8019648:	60f8      	str	r0, [r7, #12]
 801964a:	60b9      	str	r1, [r7, #8]
 801964c:	607a      	str	r2, [r7, #4]
	unsigned hdr_max = len < 5 ? len : 5;
 801964e:	68fb      	ldr	r3, [r7, #12]
 8019650:	2b05      	cmp	r3, #5
 8019652:	bf28      	it	cs
 8019654:	2305      	movcs	r3, #5
 8019656:	61bb      	str	r3, [r7, #24]
	unsigned hdr_len;
	size_t val = 0;
 8019658:	2300      	movs	r3, #0
 801965a:	627b      	str	r3, [r7, #36]	; 0x24
	unsigned i;
	unsigned shift = 0;
 801965c:	2300      	movs	r3, #0
 801965e:	61fb      	str	r3, [r7, #28]

	for (i = 0; i < hdr_max; i++) {
 8019660:	2300      	movs	r3, #0
 8019662:	623b      	str	r3, [r7, #32]
 8019664:	e018      	b.n	8019698 <scan_length_prefixed_data+0x56>
		val |= ((size_t)data[i] & 0x7f) << shift;
 8019666:	68ba      	ldr	r2, [r7, #8]
 8019668:	6a3b      	ldr	r3, [r7, #32]
 801966a:	4413      	add	r3, r2
 801966c:	781b      	ldrb	r3, [r3, #0]
 801966e:	f003 027f 	and.w	r2, r3, #127	; 0x7f
 8019672:	69fb      	ldr	r3, [r7, #28]
 8019674:	fa02 f303 	lsl.w	r3, r2, r3
 8019678:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 801967a:	4313      	orrs	r3, r2
 801967c:	627b      	str	r3, [r7, #36]	; 0x24
		shift += 7;
 801967e:	69fb      	ldr	r3, [r7, #28]
 8019680:	3307      	adds	r3, #7
 8019682:	61fb      	str	r3, [r7, #28]
		if ((data[i] & 0x80) == 0)
 8019684:	68ba      	ldr	r2, [r7, #8]
 8019686:	6a3b      	ldr	r3, [r7, #32]
 8019688:	4413      	add	r3, r2
 801968a:	781b      	ldrb	r3, [r3, #0]
 801968c:	b25b      	sxtb	r3, r3
 801968e:	2b00      	cmp	r3, #0
 8019690:	da07      	bge.n	80196a2 <scan_length_prefixed_data+0x60>
	for (i = 0; i < hdr_max; i++) {
 8019692:	6a3b      	ldr	r3, [r7, #32]
 8019694:	3301      	adds	r3, #1
 8019696:	623b      	str	r3, [r7, #32]
 8019698:	6a3a      	ldr	r2, [r7, #32]
 801969a:	69bb      	ldr	r3, [r7, #24]
 801969c:	429a      	cmp	r2, r3
 801969e:	d3e2      	bcc.n	8019666 <scan_length_prefixed_data+0x24>
 80196a0:	e000      	b.n	80196a4 <scan_length_prefixed_data+0x62>
			break;
 80196a2:	bf00      	nop
	}
	if (i == hdr_max) {
 80196a4:	6a3a      	ldr	r2, [r7, #32]
 80196a6:	69bb      	ldr	r3, [r7, #24]
 80196a8:	429a      	cmp	r2, r3
 80196aa:	d101      	bne.n	80196b0 <scan_length_prefixed_data+0x6e>
		PROTOBUF_C_UNPACK_ERROR("error parsing length for length-prefixed data");
		return 0;
 80196ac:	2300      	movs	r3, #0
 80196ae:	e015      	b.n	80196dc <scan_length_prefixed_data+0x9a>
	}
	hdr_len = i + 1;
 80196b0:	6a3b      	ldr	r3, [r7, #32]
 80196b2:	3301      	adds	r3, #1
 80196b4:	617b      	str	r3, [r7, #20]
	*prefix_len_out = hdr_len;
 80196b6:	687b      	ldr	r3, [r7, #4]
 80196b8:	697a      	ldr	r2, [r7, #20]
 80196ba:	601a      	str	r2, [r3, #0]
	if (val > INT_MAX) {
 80196bc:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80196be:	2b00      	cmp	r3, #0
 80196c0:	da01      	bge.n	80196c6 <scan_length_prefixed_data+0x84>
		// Protobuf messages should always be less than 2 GiB in size.
		// We also want to return early here so that hdr_len + val does
		// not overflow on 32-bit systems.
		PROTOBUF_C_UNPACK_ERROR("length prefix of %lu is too large", val);
		return 0;
 80196c2:	2300      	movs	r3, #0
 80196c4:	e00a      	b.n	80196dc <scan_length_prefixed_data+0x9a>
	}
	if (hdr_len + val > len) {
 80196c6:	697a      	ldr	r2, [r7, #20]
 80196c8:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80196ca:	4413      	add	r3, r2
 80196cc:	68fa      	ldr	r2, [r7, #12]
 80196ce:	429a      	cmp	r2, r3
 80196d0:	d201      	bcs.n	80196d6 <scan_length_prefixed_data+0x94>
		PROTOBUF_C_UNPACK_ERROR("data too short after length-prefix of %lu", val);
		return 0;
 80196d2:	2300      	movs	r3, #0
 80196d4:	e002      	b.n	80196dc <scan_length_prefixed_data+0x9a>
	}
	return hdr_len + val;
 80196d6:	697a      	ldr	r2, [r7, #20]
 80196d8:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80196da:	4413      	add	r3, r2
}
 80196dc:	4618      	mov	r0, r3
 80196de:	372c      	adds	r7, #44	; 0x2c
 80196e0:	46bd      	mov	sp, r7
 80196e2:	f85d 7b04 	ldr.w	r7, [sp], #4
 80196e6:	4770      	bx	lr

080196e8 <max_b128_numbers>:

static size_t
max_b128_numbers(size_t len, const uint8_t *data)
{
 80196e8:	b480      	push	{r7}
 80196ea:	b085      	sub	sp, #20
 80196ec:	af00      	add	r7, sp, #0
 80196ee:	6078      	str	r0, [r7, #4]
 80196f0:	6039      	str	r1, [r7, #0]
	size_t rv = 0;
 80196f2:	2300      	movs	r3, #0
 80196f4:	60fb      	str	r3, [r7, #12]
	while (len--)
 80196f6:	e009      	b.n	801970c <max_b128_numbers+0x24>
		if ((*data++ & 0x80) == 0)
 80196f8:	683b      	ldr	r3, [r7, #0]
 80196fa:	1c5a      	adds	r2, r3, #1
 80196fc:	603a      	str	r2, [r7, #0]
 80196fe:	781b      	ldrb	r3, [r3, #0]
 8019700:	b25b      	sxtb	r3, r3
 8019702:	2b00      	cmp	r3, #0
 8019704:	db02      	blt.n	801970c <max_b128_numbers+0x24>
			++rv;
 8019706:	68fb      	ldr	r3, [r7, #12]
 8019708:	3301      	adds	r3, #1
 801970a:	60fb      	str	r3, [r7, #12]
	while (len--)
 801970c:	687b      	ldr	r3, [r7, #4]
 801970e:	1e5a      	subs	r2, r3, #1
 8019710:	607a      	str	r2, [r7, #4]
 8019712:	2b00      	cmp	r3, #0
 8019714:	d1f0      	bne.n	80196f8 <max_b128_numbers+0x10>
	return rv;
 8019716:	68fb      	ldr	r3, [r7, #12]
}
 8019718:	4618      	mov	r0, r3
 801971a:	3714      	adds	r7, #20
 801971c:	46bd      	mov	sp, r7
 801971e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8019722:	4770      	bx	lr

08019724 <merge_messages>:
 */
static protobuf_c_boolean
merge_messages(ProtobufCMessage *earlier_msg,
	       ProtobufCMessage *latter_msg,
	       ProtobufCAllocator *allocator)
{
 8019724:	b580      	push	{r7, lr}
 8019726:	b09e      	sub	sp, #120	; 0x78
 8019728:	af00      	add	r7, sp, #0
 801972a:	60f8      	str	r0, [r7, #12]
 801972c:	60b9      	str	r1, [r7, #8]
 801972e:	607a      	str	r2, [r7, #4]
	unsigned i;
	const ProtobufCFieldDescriptor *fields =
		latter_msg->descriptor->fields;
 8019730:	68bb      	ldr	r3, [r7, #8]
 8019732:	681b      	ldr	r3, [r3, #0]
	const ProtobufCFieldDescriptor *fields =
 8019734:	69db      	ldr	r3, [r3, #28]
 8019736:	66bb      	str	r3, [r7, #104]	; 0x68
	for (i = 0; i < latter_msg->descriptor->n_fields; i++) {
 8019738:	2300      	movs	r3, #0
 801973a:	677b      	str	r3, [r7, #116]	; 0x74
 801973c:	e191      	b.n	8019a62 <merge_messages+0x33e>
		if (fields[i].label == PROTOBUF_C_LABEL_REPEATED) {
 801973e:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 8019740:	222c      	movs	r2, #44	; 0x2c
 8019742:	fb02 f303 	mul.w	r3, r2, r3
 8019746:	6eba      	ldr	r2, [r7, #104]	; 0x68
 8019748:	4413      	add	r3, r2
 801974a:	7a1b      	ldrb	r3, [r3, #8]
 801974c:	2b02      	cmp	r3, #2
 801974e:	f040 8090 	bne.w	8019872 <merge_messages+0x14e>
			size_t *n_earlier =
				STRUCT_MEMBER_PTR(size_t, earlier_msg,
 8019752:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 8019754:	222c      	movs	r2, #44	; 0x2c
 8019756:	fb02 f303 	mul.w	r3, r2, r3
 801975a:	6eba      	ldr	r2, [r7, #104]	; 0x68
 801975c:	4413      	add	r3, r2
 801975e:	68db      	ldr	r3, [r3, #12]
			size_t *n_earlier =
 8019760:	68fa      	ldr	r2, [r7, #12]
 8019762:	4413      	add	r3, r2
 8019764:	62bb      	str	r3, [r7, #40]	; 0x28
						  fields[i].quantifier_offset);
			uint8_t **p_earlier =
				STRUCT_MEMBER_PTR(uint8_t *, earlier_msg,
 8019766:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 8019768:	222c      	movs	r2, #44	; 0x2c
 801976a:	fb02 f303 	mul.w	r3, r2, r3
 801976e:	6eba      	ldr	r2, [r7, #104]	; 0x68
 8019770:	4413      	add	r3, r2
 8019772:	691b      	ldr	r3, [r3, #16]
			uint8_t **p_earlier =
 8019774:	68fa      	ldr	r2, [r7, #12]
 8019776:	4413      	add	r3, r2
 8019778:	627b      	str	r3, [r7, #36]	; 0x24
						  fields[i].offset);
			size_t *n_latter =
				STRUCT_MEMBER_PTR(size_t, latter_msg,
 801977a:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 801977c:	222c      	movs	r2, #44	; 0x2c
 801977e:	fb02 f303 	mul.w	r3, r2, r3
 8019782:	6eba      	ldr	r2, [r7, #104]	; 0x68
 8019784:	4413      	add	r3, r2
 8019786:	68db      	ldr	r3, [r3, #12]
			size_t *n_latter =
 8019788:	68ba      	ldr	r2, [r7, #8]
 801978a:	4413      	add	r3, r2
 801978c:	623b      	str	r3, [r7, #32]
						  fields[i].quantifier_offset);
			uint8_t **p_latter =
				STRUCT_MEMBER_PTR(uint8_t *, latter_msg,
 801978e:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 8019790:	222c      	movs	r2, #44	; 0x2c
 8019792:	fb02 f303 	mul.w	r3, r2, r3
 8019796:	6eba      	ldr	r2, [r7, #104]	; 0x68
 8019798:	4413      	add	r3, r2
 801979a:	691b      	ldr	r3, [r3, #16]
			uint8_t **p_latter =
 801979c:	68ba      	ldr	r2, [r7, #8]
 801979e:	4413      	add	r3, r2
 80197a0:	61fb      	str	r3, [r7, #28]
						  fields[i].offset);

			if (*n_earlier > 0) {
 80197a2:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80197a4:	681b      	ldr	r3, [r3, #0]
 80197a6:	2b00      	cmp	r3, #0
 80197a8:	f000 8158 	beq.w	8019a5c <merge_messages+0x338>
				if (*n_latter > 0) {
 80197ac:	6a3b      	ldr	r3, [r7, #32]
 80197ae:	681b      	ldr	r3, [r3, #0]
 80197b0:	2b00      	cmp	r3, #0
 80197b2:	d04f      	beq.n	8019854 <merge_messages+0x130>
					/* Concatenate the repeated field */
					size_t el_size =
						sizeof_elt_in_repeated_array(fields[i].type);
 80197b4:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 80197b6:	222c      	movs	r2, #44	; 0x2c
 80197b8:	fb02 f303 	mul.w	r3, r2, r3
 80197bc:	6eba      	ldr	r2, [r7, #104]	; 0x68
 80197be:	4413      	add	r3, r2
 80197c0:	7a5b      	ldrb	r3, [r3, #9]
 80197c2:	4618      	mov	r0, r3
 80197c4:	f7ff fb5e 	bl	8018e84 <sizeof_elt_in_repeated_array>
 80197c8:	61b8      	str	r0, [r7, #24]
					uint8_t *new_field;

					new_field = do_alloc(allocator,
						(*n_earlier + *n_latter) * el_size);
 80197ca:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80197cc:	681a      	ldr	r2, [r3, #0]
 80197ce:	6a3b      	ldr	r3, [r7, #32]
 80197d0:	681b      	ldr	r3, [r3, #0]
 80197d2:	4413      	add	r3, r2
					new_field = do_alloc(allocator,
 80197d4:	69ba      	ldr	r2, [r7, #24]
 80197d6:	fb02 f303 	mul.w	r3, r2, r3
 80197da:	4619      	mov	r1, r3
 80197dc:	6878      	ldr	r0, [r7, #4]
 80197de:	f7fe faec 	bl	8017dba <do_alloc>
 80197e2:	6178      	str	r0, [r7, #20]
					if (!new_field)
 80197e4:	697b      	ldr	r3, [r7, #20]
 80197e6:	2b00      	cmp	r3, #0
 80197e8:	d101      	bne.n	80197ee <merge_messages+0xca>
						return FALSE;
 80197ea:	2300      	movs	r3, #0
 80197ec:	e141      	b.n	8019a72 <merge_messages+0x34e>

					memcpy(new_field, *p_earlier,
 80197ee:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80197f0:	6819      	ldr	r1, [r3, #0]
					       *n_earlier * el_size);
 80197f2:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80197f4:	681b      	ldr	r3, [r3, #0]
					memcpy(new_field, *p_earlier,
 80197f6:	69ba      	ldr	r2, [r7, #24]
 80197f8:	fb02 f303 	mul.w	r3, r2, r3
 80197fc:	461a      	mov	r2, r3
 80197fe:	6978      	ldr	r0, [r7, #20]
 8019800:	f006 f814 	bl	801f82c <memcpy>
					memcpy(new_field +
					       *n_earlier * el_size,
 8019804:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8019806:	681b      	ldr	r3, [r3, #0]
 8019808:	69ba      	ldr	r2, [r7, #24]
 801980a:	fb02 f303 	mul.w	r3, r2, r3
					memcpy(new_field +
 801980e:	697a      	ldr	r2, [r7, #20]
 8019810:	18d0      	adds	r0, r2, r3
 8019812:	69fb      	ldr	r3, [r7, #28]
 8019814:	6819      	ldr	r1, [r3, #0]
					       *p_latter,
					       *n_latter * el_size);
 8019816:	6a3b      	ldr	r3, [r7, #32]
 8019818:	681b      	ldr	r3, [r3, #0]
					memcpy(new_field +
 801981a:	69ba      	ldr	r2, [r7, #24]
 801981c:	fb02 f303 	mul.w	r3, r2, r3
 8019820:	461a      	mov	r2, r3
 8019822:	f006 f803 	bl	801f82c <memcpy>

					do_free(allocator, *p_latter);
 8019826:	69fb      	ldr	r3, [r7, #28]
 8019828:	681b      	ldr	r3, [r3, #0]
 801982a:	4619      	mov	r1, r3
 801982c:	6878      	ldr	r0, [r7, #4]
 801982e:	f7fe fad5 	bl	8017ddc <do_free>
					do_free(allocator, *p_earlier);
 8019832:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8019834:	681b      	ldr	r3, [r3, #0]
 8019836:	4619      	mov	r1, r3
 8019838:	6878      	ldr	r0, [r7, #4]
 801983a:	f7fe facf 	bl	8017ddc <do_free>
					*p_latter = new_field;
 801983e:	69fb      	ldr	r3, [r7, #28]
 8019840:	697a      	ldr	r2, [r7, #20]
 8019842:	601a      	str	r2, [r3, #0]
					*n_latter = *n_earlier + *n_latter;
 8019844:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8019846:	681a      	ldr	r2, [r3, #0]
 8019848:	6a3b      	ldr	r3, [r7, #32]
 801984a:	681b      	ldr	r3, [r3, #0]
 801984c:	441a      	add	r2, r3
 801984e:	6a3b      	ldr	r3, [r7, #32]
 8019850:	601a      	str	r2, [r3, #0]
 8019852:	e007      	b.n	8019864 <merge_messages+0x140>
				} else {
					/* Zero copy the repeated field from the earlier message */
					*n_latter = *n_earlier;
 8019854:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8019856:	681a      	ldr	r2, [r3, #0]
 8019858:	6a3b      	ldr	r3, [r7, #32]
 801985a:	601a      	str	r2, [r3, #0]
					*p_latter = *p_earlier;
 801985c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801985e:	681a      	ldr	r2, [r3, #0]
 8019860:	69fb      	ldr	r3, [r7, #28]
 8019862:	601a      	str	r2, [r3, #0]
				}
				/* Make sure the field does not get double freed */
				*n_earlier = 0;
 8019864:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8019866:	2200      	movs	r2, #0
 8019868:	601a      	str	r2, [r3, #0]
				*p_earlier = 0;
 801986a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801986c:	2200      	movs	r2, #0
 801986e:	601a      	str	r2, [r3, #0]
 8019870:	e0f4      	b.n	8019a5c <merge_messages+0x338>
			}
		} else if (fields[i].label == PROTOBUF_C_LABEL_OPTIONAL ||
 8019872:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 8019874:	222c      	movs	r2, #44	; 0x2c
 8019876:	fb02 f303 	mul.w	r3, r2, r3
 801987a:	6eba      	ldr	r2, [r7, #104]	; 0x68
 801987c:	4413      	add	r3, r2
 801987e:	7a1b      	ldrb	r3, [r3, #8]
 8019880:	2b01      	cmp	r3, #1
 8019882:	d009      	beq.n	8019898 <merge_messages+0x174>
			   fields[i].label == PROTOBUF_C_LABEL_NONE) {
 8019884:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 8019886:	222c      	movs	r2, #44	; 0x2c
 8019888:	fb02 f303 	mul.w	r3, r2, r3
 801988c:	6eba      	ldr	r2, [r7, #104]	; 0x68
 801988e:	4413      	add	r3, r2
 8019890:	7a1b      	ldrb	r3, [r3, #8]
		} else if (fields[i].label == PROTOBUF_C_LABEL_OPTIONAL ||
 8019892:	2b03      	cmp	r3, #3
 8019894:	f040 80e2 	bne.w	8019a5c <merge_messages+0x338>
			const ProtobufCFieldDescriptor *field;
			uint32_t *earlier_case_p = STRUCT_MEMBER_PTR(uint32_t,
 8019898:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 801989a:	222c      	movs	r2, #44	; 0x2c
 801989c:	fb02 f303 	mul.w	r3, r2, r3
 80198a0:	6eba      	ldr	r2, [r7, #104]	; 0x68
 80198a2:	4413      	add	r3, r2
 80198a4:	68db      	ldr	r3, [r3, #12]
 80198a6:	68fa      	ldr	r2, [r7, #12]
 80198a8:	4413      	add	r3, r2
 80198aa:	667b      	str	r3, [r7, #100]	; 0x64
								     earlier_msg,
								     fields[i].
								     quantifier_offset);
			uint32_t *latter_case_p = STRUCT_MEMBER_PTR(uint32_t,
 80198ac:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 80198ae:	222c      	movs	r2, #44	; 0x2c
 80198b0:	fb02 f303 	mul.w	r3, r2, r3
 80198b4:	6eba      	ldr	r2, [r7, #104]	; 0x68
 80198b6:	4413      	add	r3, r2
 80198b8:	68db      	ldr	r3, [r3, #12]
 80198ba:	68ba      	ldr	r2, [r7, #8]
 80198bc:	4413      	add	r3, r2
 80198be:	663b      	str	r3, [r7, #96]	; 0x60
								    latter_msg,
								    fields[i].
								    quantifier_offset);
			protobuf_c_boolean need_to_merge = FALSE;
 80198c0:	2300      	movs	r3, #0
 80198c2:	66fb      	str	r3, [r7, #108]	; 0x6c
			void *earlier_elem;
			void *latter_elem;
			const void *def_val;

			if (fields[i].flags & PROTOBUF_C_FIELD_FLAG_ONEOF) {
 80198c4:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 80198c6:	222c      	movs	r2, #44	; 0x2c
 80198c8:	fb02 f303 	mul.w	r3, r2, r3
 80198cc:	6eba      	ldr	r2, [r7, #104]	; 0x68
 80198ce:	4413      	add	r3, r2
 80198d0:	69db      	ldr	r3, [r3, #28]
 80198d2:	f003 0304 	and.w	r3, r3, #4
 80198d6:	2b00      	cmp	r3, #0
 80198d8:	d01f      	beq.n	801991a <merge_messages+0x1f6>
				if (*latter_case_p == 0) {
 80198da:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 80198dc:	681b      	ldr	r3, [r3, #0]
 80198de:	2b00      	cmp	r3, #0
 80198e0:	f040 80bb 	bne.w	8019a5a <merge_messages+0x336>
					/* lookup correct oneof field */
					int field_index =
						int_range_lookup(
							latter_msg->descriptor
 80198e4:	68bb      	ldr	r3, [r7, #8]
 80198e6:	681b      	ldr	r3, [r3, #0]
						int_range_lookup(
 80198e8:	6a58      	ldr	r0, [r3, #36]	; 0x24
							->n_field_ranges,
							latter_msg->descriptor
 80198ea:	68bb      	ldr	r3, [r7, #8]
 80198ec:	681b      	ldr	r3, [r3, #0]
						int_range_lookup(
 80198ee:	6a99      	ldr	r1, [r3, #40]	; 0x28
							->field_ranges,
							*earlier_case_p);
 80198f0:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 80198f2:	681b      	ldr	r3, [r3, #0]
						int_range_lookup(
 80198f4:	461a      	mov	r2, r3
 80198f6:	f7ff fdad 	bl	8019454 <int_range_lookup>
 80198fa:	65f8      	str	r0, [r7, #92]	; 0x5c
					if (field_index < 0)
 80198fc:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 80198fe:	2b00      	cmp	r3, #0
 8019900:	da01      	bge.n	8019906 <merge_messages+0x1e2>
						return FALSE;
 8019902:	2300      	movs	r3, #0
 8019904:	e0b5      	b.n	8019a72 <merge_messages+0x34e>
					field = latter_msg->descriptor->fields +
 8019906:	68bb      	ldr	r3, [r7, #8]
 8019908:	681b      	ldr	r3, [r3, #0]
 801990a:	69da      	ldr	r2, [r3, #28]
 801990c:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 801990e:	212c      	movs	r1, #44	; 0x2c
 8019910:	fb01 f303 	mul.w	r3, r1, r3
 8019914:	4413      	add	r3, r2
 8019916:	673b      	str	r3, [r7, #112]	; 0x70
 8019918:	e006      	b.n	8019928 <merge_messages+0x204>
				} else {
					/* Oneof is present in the latter message, move on */
					continue;
				}
			} else {
				field = &fields[i];
 801991a:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 801991c:	222c      	movs	r2, #44	; 0x2c
 801991e:	fb02 f303 	mul.w	r3, r2, r3
 8019922:	6eba      	ldr	r2, [r7, #104]	; 0x68
 8019924:	4413      	add	r3, r2
 8019926:	673b      	str	r3, [r7, #112]	; 0x70
			}

			earlier_elem = STRUCT_MEMBER_P(earlier_msg, field->offset);
 8019928:	6f3b      	ldr	r3, [r7, #112]	; 0x70
 801992a:	691b      	ldr	r3, [r3, #16]
 801992c:	68fa      	ldr	r2, [r7, #12]
 801992e:	4413      	add	r3, r2
 8019930:	65bb      	str	r3, [r7, #88]	; 0x58
			latter_elem = STRUCT_MEMBER_P(latter_msg, field->offset);
 8019932:	6f3b      	ldr	r3, [r7, #112]	; 0x70
 8019934:	691b      	ldr	r3, [r3, #16]
 8019936:	68ba      	ldr	r2, [r7, #8]
 8019938:	4413      	add	r3, r2
 801993a:	657b      	str	r3, [r7, #84]	; 0x54
			def_val = field->default_value;
 801993c:	6f3b      	ldr	r3, [r7, #112]	; 0x70
 801993e:	699b      	ldr	r3, [r3, #24]
 8019940:	653b      	str	r3, [r7, #80]	; 0x50

			switch (field->type) {
 8019942:	6f3b      	ldr	r3, [r7, #112]	; 0x70
 8019944:	7a5b      	ldrb	r3, [r3, #9]
 8019946:	2b10      	cmp	r3, #16
 8019948:	d006      	beq.n	8019958 <merge_messages+0x234>
 801994a:	2b10      	cmp	r3, #16
 801994c:	dc58      	bgt.n	8019a00 <merge_messages+0x2dc>
 801994e:	2b0e      	cmp	r3, #14
 8019950:	d041      	beq.n	80199d6 <merge_messages+0x2b2>
 8019952:	2b0f      	cmp	r3, #15
 8019954:	d01c      	beq.n	8019990 <merge_messages+0x26c>
 8019956:	e053      	b.n	8019a00 <merge_messages+0x2dc>
			case PROTOBUF_C_TYPE_MESSAGE: {
				ProtobufCMessage *em = *(ProtobufCMessage **) earlier_elem;
 8019958:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 801995a:	681b      	ldr	r3, [r3, #0]
 801995c:	64fb      	str	r3, [r7, #76]	; 0x4c
				ProtobufCMessage *lm = *(ProtobufCMessage **) latter_elem;
 801995e:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 8019960:	681b      	ldr	r3, [r3, #0]
 8019962:	64bb      	str	r3, [r7, #72]	; 0x48
				if (em != NULL) {
 8019964:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8019966:	2b00      	cmp	r3, #0
 8019968:	d057      	beq.n	8019a1a <merge_messages+0x2f6>
					if (lm != NULL) {
 801996a:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 801996c:	2b00      	cmp	r3, #0
 801996e:	d00c      	beq.n	801998a <merge_messages+0x266>
						if (!merge_messages(em, lm, allocator))
 8019970:	687a      	ldr	r2, [r7, #4]
 8019972:	6cb9      	ldr	r1, [r7, #72]	; 0x48
 8019974:	6cf8      	ldr	r0, [r7, #76]	; 0x4c
 8019976:	f7ff fed5 	bl	8019724 <merge_messages>
 801997a:	4603      	mov	r3, r0
 801997c:	2b00      	cmp	r3, #0
 801997e:	d101      	bne.n	8019984 <merge_messages+0x260>
							return FALSE;
 8019980:	2300      	movs	r3, #0
 8019982:	e076      	b.n	8019a72 <merge_messages+0x34e>
						/* Already merged */
						need_to_merge = FALSE;
 8019984:	2300      	movs	r3, #0
 8019986:	66fb      	str	r3, [r7, #108]	; 0x6c
					} else {
						/* Zero copy the message */
						need_to_merge = TRUE;
					}
				}
				break;
 8019988:	e047      	b.n	8019a1a <merge_messages+0x2f6>
						need_to_merge = TRUE;
 801998a:	2301      	movs	r3, #1
 801998c:	66fb      	str	r3, [r7, #108]	; 0x6c
				break;
 801998e:	e044      	b.n	8019a1a <merge_messages+0x2f6>
			}
			case PROTOBUF_C_TYPE_BYTES: {
				uint8_t *e_data =
 8019990:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 8019992:	685b      	ldr	r3, [r3, #4]
 8019994:	647b      	str	r3, [r7, #68]	; 0x44
					((ProtobufCBinaryData *) earlier_elem)->data;
				uint8_t *l_data =
 8019996:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 8019998:	685b      	ldr	r3, [r3, #4]
 801999a:	643b      	str	r3, [r7, #64]	; 0x40
					((ProtobufCBinaryData *) latter_elem)->data;
				const ProtobufCBinaryData *d_bd =
 801999c:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 801999e:	63fb      	str	r3, [r7, #60]	; 0x3c
					(ProtobufCBinaryData *) def_val;

				need_to_merge =
					(e_data != NULL &&
					 (d_bd == NULL ||
					  e_data != d_bd->data)) &&
 80199a0:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 80199a2:	2b00      	cmp	r3, #0
 80199a4:	d014      	beq.n	80199d0 <merge_messages+0x2ac>
					(e_data != NULL &&
 80199a6:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 80199a8:	2b00      	cmp	r3, #0
 80199aa:	d004      	beq.n	80199b6 <merge_messages+0x292>
					  e_data != d_bd->data)) &&
 80199ac:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 80199ae:	685b      	ldr	r3, [r3, #4]
					 (d_bd == NULL ||
 80199b0:	6c7a      	ldr	r2, [r7, #68]	; 0x44
 80199b2:	429a      	cmp	r2, r3
 80199b4:	d00c      	beq.n	80199d0 <merge_messages+0x2ac>
					  e_data != d_bd->data)) &&
 80199b6:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 80199b8:	2b00      	cmp	r3, #0
 80199ba:	d007      	beq.n	80199cc <merge_messages+0x2a8>
					(l_data == NULL ||
 80199bc:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 80199be:	2b00      	cmp	r3, #0
 80199c0:	d006      	beq.n	80199d0 <merge_messages+0x2ac>
					 (d_bd != NULL &&
					  l_data == d_bd->data));
 80199c2:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 80199c4:	685b      	ldr	r3, [r3, #4]
					 (d_bd != NULL &&
 80199c6:	6c3a      	ldr	r2, [r7, #64]	; 0x40
 80199c8:	429a      	cmp	r2, r3
 80199ca:	d101      	bne.n	80199d0 <merge_messages+0x2ac>
					  e_data != d_bd->data)) &&
 80199cc:	2301      	movs	r3, #1
 80199ce:	e000      	b.n	80199d2 <merge_messages+0x2ae>
 80199d0:	2300      	movs	r3, #0
				need_to_merge =
 80199d2:	66fb      	str	r3, [r7, #108]	; 0x6c
				break;
 80199d4:	e022      	b.n	8019a1c <merge_messages+0x2f8>
			}
			case PROTOBUF_C_TYPE_STRING: {
				char *e_str = *(char **) earlier_elem;
 80199d6:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 80199d8:	681b      	ldr	r3, [r3, #0]
 80199da:	63bb      	str	r3, [r7, #56]	; 0x38
				char *l_str = *(char **) latter_elem;
 80199dc:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 80199de:	681b      	ldr	r3, [r3, #0]
 80199e0:	637b      	str	r3, [r7, #52]	; 0x34
				const char *d_str = def_val;
 80199e2:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 80199e4:	633b      	str	r3, [r7, #48]	; 0x30

				need_to_merge = e_str != d_str && l_str == d_str;
 80199e6:	6bba      	ldr	r2, [r7, #56]	; 0x38
 80199e8:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 80199ea:	429a      	cmp	r2, r3
 80199ec:	d005      	beq.n	80199fa <merge_messages+0x2d6>
 80199ee:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 80199f0:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 80199f2:	429a      	cmp	r2, r3
 80199f4:	d101      	bne.n	80199fa <merge_messages+0x2d6>
 80199f6:	2301      	movs	r3, #1
 80199f8:	e000      	b.n	80199fc <merge_messages+0x2d8>
 80199fa:	2300      	movs	r3, #0
 80199fc:	66fb      	str	r3, [r7, #108]	; 0x6c
				break;
 80199fe:	e00d      	b.n	8019a1c <merge_messages+0x2f8>
			}
			default: {
				/* Could be has field or case enum, the logic is
				 * equivalent, since 0 (FALSE) means not set for
				 * oneof */
				need_to_merge = (*earlier_case_p != 0) &&
 8019a00:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 8019a02:	681b      	ldr	r3, [r3, #0]
 8019a04:	2b00      	cmp	r3, #0
 8019a06:	d005      	beq.n	8019a14 <merge_messages+0x2f0>
						(*latter_case_p == 0);
 8019a08:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 8019a0a:	681b      	ldr	r3, [r3, #0]
				need_to_merge = (*earlier_case_p != 0) &&
 8019a0c:	2b00      	cmp	r3, #0
 8019a0e:	d101      	bne.n	8019a14 <merge_messages+0x2f0>
 8019a10:	2301      	movs	r3, #1
 8019a12:	e000      	b.n	8019a16 <merge_messages+0x2f2>
 8019a14:	2300      	movs	r3, #0
 8019a16:	66fb      	str	r3, [r7, #108]	; 0x6c
				break;
 8019a18:	e000      	b.n	8019a1c <merge_messages+0x2f8>
				break;
 8019a1a:	bf00      	nop
			}
			}

			if (need_to_merge) {
 8019a1c:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 8019a1e:	2b00      	cmp	r3, #0
 8019a20:	d01c      	beq.n	8019a5c <merge_messages+0x338>
				size_t el_size =
					sizeof_elt_in_repeated_array(field->type);
 8019a22:	6f3b      	ldr	r3, [r7, #112]	; 0x70
 8019a24:	7a5b      	ldrb	r3, [r3, #9]
 8019a26:	4618      	mov	r0, r3
 8019a28:	f7ff fa2c 	bl	8018e84 <sizeof_elt_in_repeated_array>
 8019a2c:	62f8      	str	r0, [r7, #44]	; 0x2c
				memcpy(latter_elem, earlier_elem, el_size);
 8019a2e:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 8019a30:	6db9      	ldr	r1, [r7, #88]	; 0x58
 8019a32:	6d78      	ldr	r0, [r7, #84]	; 0x54
 8019a34:	f005 fefa 	bl	801f82c <memcpy>
				 * to make sure earlier message deallocation
				 * doesn't corrupt zero-copied data in the new
				 * message, earlier message will be freed after
				 * this function is called anyway
				 */
				memset(earlier_elem, 0, el_size);
 8019a38:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 8019a3a:	2100      	movs	r1, #0
 8019a3c:	6db8      	ldr	r0, [r7, #88]	; 0x58
 8019a3e:	f005 ff1d 	bl	801f87c <memset>

				if (field->quantifier_offset != 0) {
 8019a42:	6f3b      	ldr	r3, [r7, #112]	; 0x70
 8019a44:	68db      	ldr	r3, [r3, #12]
 8019a46:	2b00      	cmp	r3, #0
 8019a48:	d008      	beq.n	8019a5c <merge_messages+0x338>
					/* Set the has field or the case enum,
					 * if applicable */
					*latter_case_p = *earlier_case_p;
 8019a4a:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 8019a4c:	681a      	ldr	r2, [r3, #0]
 8019a4e:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 8019a50:	601a      	str	r2, [r3, #0]
					*earlier_case_p = 0;
 8019a52:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 8019a54:	2200      	movs	r2, #0
 8019a56:	601a      	str	r2, [r3, #0]
 8019a58:	e000      	b.n	8019a5c <merge_messages+0x338>
					continue;
 8019a5a:	bf00      	nop
	for (i = 0; i < latter_msg->descriptor->n_fields; i++) {
 8019a5c:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 8019a5e:	3301      	adds	r3, #1
 8019a60:	677b      	str	r3, [r7, #116]	; 0x74
 8019a62:	68bb      	ldr	r3, [r7, #8]
 8019a64:	681b      	ldr	r3, [r3, #0]
 8019a66:	699b      	ldr	r3, [r3, #24]
 8019a68:	6f7a      	ldr	r2, [r7, #116]	; 0x74
 8019a6a:	429a      	cmp	r2, r3
 8019a6c:	f4ff ae67 	bcc.w	801973e <merge_messages+0x1a>
				}
			}
		}
	}
	return TRUE;
 8019a70:	2301      	movs	r3, #1
}
 8019a72:	4618      	mov	r0, r3
 8019a74:	3778      	adds	r7, #120	; 0x78
 8019a76:	46bd      	mov	sp, r7
 8019a78:	bd80      	pop	{r7, pc}
	...

08019a7c <count_packed_elements>:
 * parse_packed_repeated_member().
 */
static protobuf_c_boolean
count_packed_elements(ProtobufCType type,
		      size_t len, const uint8_t *data, size_t *count_out)
{
 8019a7c:	b580      	push	{r7, lr}
 8019a7e:	b084      	sub	sp, #16
 8019a80:	af00      	add	r7, sp, #0
 8019a82:	60b9      	str	r1, [r7, #8]
 8019a84:	607a      	str	r2, [r7, #4]
 8019a86:	603b      	str	r3, [r7, #0]
 8019a88:	4603      	mov	r3, r0
 8019a8a:	73fb      	strb	r3, [r7, #15]
	switch (type) {
 8019a8c:	7bfb      	ldrb	r3, [r7, #15]
 8019a8e:	2b0d      	cmp	r3, #13
 8019a90:	d846      	bhi.n	8019b20 <count_packed_elements+0xa4>
 8019a92:	a201      	add	r2, pc, #4	; (adr r2, 8019a98 <count_packed_elements+0x1c>)
 8019a94:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8019a98:	08019b05 	.word	0x08019b05
 8019a9c:	08019b05 	.word	0x08019b05
 8019aa0:	08019ad1 	.word	0x08019ad1
 8019aa4:	08019b05 	.word	0x08019b05
 8019aa8:	08019b05 	.word	0x08019b05
 8019aac:	08019aeb 	.word	0x08019aeb
 8019ab0:	08019b05 	.word	0x08019b05
 8019ab4:	08019ad1 	.word	0x08019ad1
 8019ab8:	08019b05 	.word	0x08019b05
 8019abc:	08019aeb 	.word	0x08019aeb
 8019ac0:	08019ad1 	.word	0x08019ad1
 8019ac4:	08019aeb 	.word	0x08019aeb
 8019ac8:	08019b17 	.word	0x08019b17
 8019acc:	08019b05 	.word	0x08019b05
	case PROTOBUF_C_TYPE_SFIXED32:
	case PROTOBUF_C_TYPE_FIXED32:
	case PROTOBUF_C_TYPE_FLOAT:
		if (len % 4 != 0) {
 8019ad0:	68bb      	ldr	r3, [r7, #8]
 8019ad2:	f003 0303 	and.w	r3, r3, #3
 8019ad6:	2b00      	cmp	r3, #0
 8019ad8:	d001      	beq.n	8019ade <count_packed_elements+0x62>
			PROTOBUF_C_UNPACK_ERROR("length must be a multiple of 4 for fixed-length 32-bit types");
			return FALSE;
 8019ada:	2300      	movs	r3, #0
 8019adc:	e021      	b.n	8019b22 <count_packed_elements+0xa6>
		}
		*count_out = len / 4;
 8019ade:	68bb      	ldr	r3, [r7, #8]
 8019ae0:	089a      	lsrs	r2, r3, #2
 8019ae2:	683b      	ldr	r3, [r7, #0]
 8019ae4:	601a      	str	r2, [r3, #0]
		return TRUE;
 8019ae6:	2301      	movs	r3, #1
 8019ae8:	e01b      	b.n	8019b22 <count_packed_elements+0xa6>
	case PROTOBUF_C_TYPE_SFIXED64:
	case PROTOBUF_C_TYPE_FIXED64:
	case PROTOBUF_C_TYPE_DOUBLE:
		if (len % 8 != 0) {
 8019aea:	68bb      	ldr	r3, [r7, #8]
 8019aec:	f003 0307 	and.w	r3, r3, #7
 8019af0:	2b00      	cmp	r3, #0
 8019af2:	d001      	beq.n	8019af8 <count_packed_elements+0x7c>
			PROTOBUF_C_UNPACK_ERROR("length must be a multiple of 8 for fixed-length 64-bit types");
			return FALSE;
 8019af4:	2300      	movs	r3, #0
 8019af6:	e014      	b.n	8019b22 <count_packed_elements+0xa6>
		}
		*count_out = len / 8;
 8019af8:	68bb      	ldr	r3, [r7, #8]
 8019afa:	08da      	lsrs	r2, r3, #3
 8019afc:	683b      	ldr	r3, [r7, #0]
 8019afe:	601a      	str	r2, [r3, #0]
		return TRUE;
 8019b00:	2301      	movs	r3, #1
 8019b02:	e00e      	b.n	8019b22 <count_packed_elements+0xa6>
	case PROTOBUF_C_TYPE_SINT32:
	case PROTOBUF_C_TYPE_UINT32:
	case PROTOBUF_C_TYPE_INT64:
	case PROTOBUF_C_TYPE_SINT64:
	case PROTOBUF_C_TYPE_UINT64:
		*count_out = max_b128_numbers(len, data);
 8019b04:	6879      	ldr	r1, [r7, #4]
 8019b06:	68b8      	ldr	r0, [r7, #8]
 8019b08:	f7ff fdee 	bl	80196e8 <max_b128_numbers>
 8019b0c:	4602      	mov	r2, r0
 8019b0e:	683b      	ldr	r3, [r7, #0]
 8019b10:	601a      	str	r2, [r3, #0]
		return TRUE;
 8019b12:	2301      	movs	r3, #1
 8019b14:	e005      	b.n	8019b22 <count_packed_elements+0xa6>
	case PROTOBUF_C_TYPE_BOOL:
		*count_out = len;
 8019b16:	683b      	ldr	r3, [r7, #0]
 8019b18:	68ba      	ldr	r2, [r7, #8]
 8019b1a:	601a      	str	r2, [r3, #0]
		return TRUE;
 8019b1c:	2301      	movs	r3, #1
 8019b1e:	e000      	b.n	8019b22 <count_packed_elements+0xa6>
	case PROTOBUF_C_TYPE_STRING:
	case PROTOBUF_C_TYPE_BYTES:
	case PROTOBUF_C_TYPE_MESSAGE:
	default:
		PROTOBUF_C_UNPACK_ERROR("bad protobuf-c type %u for packed-repeated", type);
		return FALSE;
 8019b20:	2300      	movs	r3, #0
	}
}
 8019b22:	4618      	mov	r0, r3
 8019b24:	3710      	adds	r7, #16
 8019b26:	46bd      	mov	sp, r7
 8019b28:	bd80      	pop	{r7, pc}
 8019b2a:	bf00      	nop

08019b2c <parse_uint32>:

static inline uint32_t
parse_uint32(unsigned len, const uint8_t *data)
{
 8019b2c:	b480      	push	{r7}
 8019b2e:	b085      	sub	sp, #20
 8019b30:	af00      	add	r7, sp, #0
 8019b32:	6078      	str	r0, [r7, #4]
 8019b34:	6039      	str	r1, [r7, #0]
	uint32_t rv = data[0] & 0x7f;
 8019b36:	683b      	ldr	r3, [r7, #0]
 8019b38:	781b      	ldrb	r3, [r3, #0]
 8019b3a:	f003 037f 	and.w	r3, r3, #127	; 0x7f
 8019b3e:	60fb      	str	r3, [r7, #12]
	if (len > 1) {
 8019b40:	687b      	ldr	r3, [r7, #4]
 8019b42:	2b01      	cmp	r3, #1
 8019b44:	d92a      	bls.n	8019b9c <parse_uint32+0x70>
		rv |= ((uint32_t) (data[1] & 0x7f) << 7);
 8019b46:	683b      	ldr	r3, [r7, #0]
 8019b48:	3301      	adds	r3, #1
 8019b4a:	781b      	ldrb	r3, [r3, #0]
 8019b4c:	01db      	lsls	r3, r3, #7
 8019b4e:	f403 537e 	and.w	r3, r3, #16256	; 0x3f80
 8019b52:	68fa      	ldr	r2, [r7, #12]
 8019b54:	4313      	orrs	r3, r2
 8019b56:	60fb      	str	r3, [r7, #12]
		if (len > 2) {
 8019b58:	687b      	ldr	r3, [r7, #4]
 8019b5a:	2b02      	cmp	r3, #2
 8019b5c:	d91e      	bls.n	8019b9c <parse_uint32+0x70>
			rv |= ((uint32_t) (data[2] & 0x7f) << 14);
 8019b5e:	683b      	ldr	r3, [r7, #0]
 8019b60:	3302      	adds	r3, #2
 8019b62:	781b      	ldrb	r3, [r3, #0]
 8019b64:	039b      	lsls	r3, r3, #14
 8019b66:	f403 13fe 	and.w	r3, r3, #2080768	; 0x1fc000
 8019b6a:	68fa      	ldr	r2, [r7, #12]
 8019b6c:	4313      	orrs	r3, r2
 8019b6e:	60fb      	str	r3, [r7, #12]
			if (len > 3) {
 8019b70:	687b      	ldr	r3, [r7, #4]
 8019b72:	2b03      	cmp	r3, #3
 8019b74:	d912      	bls.n	8019b9c <parse_uint32+0x70>
				rv |= ((uint32_t) (data[3] & 0x7f) << 21);
 8019b76:	683b      	ldr	r3, [r7, #0]
 8019b78:	3303      	adds	r3, #3
 8019b7a:	781b      	ldrb	r3, [r3, #0]
 8019b7c:	055b      	lsls	r3, r3, #21
 8019b7e:	f003 637e 	and.w	r3, r3, #266338304	; 0xfe00000
 8019b82:	68fa      	ldr	r2, [r7, #12]
 8019b84:	4313      	orrs	r3, r2
 8019b86:	60fb      	str	r3, [r7, #12]
				if (len > 4)
 8019b88:	687b      	ldr	r3, [r7, #4]
 8019b8a:	2b04      	cmp	r3, #4
 8019b8c:	d906      	bls.n	8019b9c <parse_uint32+0x70>
					rv |= ((uint32_t) (data[4]) << 28);
 8019b8e:	683b      	ldr	r3, [r7, #0]
 8019b90:	3304      	adds	r3, #4
 8019b92:	781b      	ldrb	r3, [r3, #0]
 8019b94:	071b      	lsls	r3, r3, #28
 8019b96:	68fa      	ldr	r2, [r7, #12]
 8019b98:	4313      	orrs	r3, r2
 8019b9a:	60fb      	str	r3, [r7, #12]
			}
		}
	}
	return rv;
 8019b9c:	68fb      	ldr	r3, [r7, #12]
}
 8019b9e:	4618      	mov	r0, r3
 8019ba0:	3714      	adds	r7, #20
 8019ba2:	46bd      	mov	sp, r7
 8019ba4:	f85d 7b04 	ldr.w	r7, [sp], #4
 8019ba8:	4770      	bx	lr

08019baa <parse_int32>:

static inline uint32_t
parse_int32(unsigned len, const uint8_t *data)
{
 8019baa:	b580      	push	{r7, lr}
 8019bac:	b082      	sub	sp, #8
 8019bae:	af00      	add	r7, sp, #0
 8019bb0:	6078      	str	r0, [r7, #4]
 8019bb2:	6039      	str	r1, [r7, #0]
	return parse_uint32(len, data);
 8019bb4:	6839      	ldr	r1, [r7, #0]
 8019bb6:	6878      	ldr	r0, [r7, #4]
 8019bb8:	f7ff ffb8 	bl	8019b2c <parse_uint32>
 8019bbc:	4603      	mov	r3, r0
}
 8019bbe:	4618      	mov	r0, r3
 8019bc0:	3708      	adds	r7, #8
 8019bc2:	46bd      	mov	sp, r7
 8019bc4:	bd80      	pop	{r7, pc}

08019bc6 <unzigzag32>:

static inline int32_t
unzigzag32(uint32_t v)
{
 8019bc6:	b480      	push	{r7}
 8019bc8:	b083      	sub	sp, #12
 8019bca:	af00      	add	r7, sp, #0
 8019bcc:	6078      	str	r0, [r7, #4]
	// Note:  Using unsigned types prevents undefined behavior
	return (int32_t)((v >> 1) ^ (~(v & 1) + 1));
 8019bce:	687b      	ldr	r3, [r7, #4]
 8019bd0:	085a      	lsrs	r2, r3, #1
 8019bd2:	687b      	ldr	r3, [r7, #4]
 8019bd4:	f003 0301 	and.w	r3, r3, #1
 8019bd8:	425b      	negs	r3, r3
 8019bda:	4053      	eors	r3, r2
}
 8019bdc:	4618      	mov	r0, r3
 8019bde:	370c      	adds	r7, #12
 8019be0:	46bd      	mov	sp, r7
 8019be2:	f85d 7b04 	ldr.w	r7, [sp], #4
 8019be6:	4770      	bx	lr

08019be8 <parse_fixed_uint32>:

static inline uint32_t
parse_fixed_uint32(const uint8_t *data)
{
 8019be8:	b480      	push	{r7}
 8019bea:	b085      	sub	sp, #20
 8019bec:	af00      	add	r7, sp, #0
 8019bee:	6078      	str	r0, [r7, #4]
 8019bf0:	687b      	ldr	r3, [r7, #4]
 8019bf2:	681b      	ldr	r3, [r3, #0]
#if !defined(WORDS_BIGENDIAN)
	uint32_t t;
	memcpy(&t, data, 4);
 8019bf4:	60fb      	str	r3, [r7, #12]
	return t;
 8019bf6:	68fb      	ldr	r3, [r7, #12]
	return data[0] |
		((uint32_t) (data[1]) << 8) |
		((uint32_t) (data[2]) << 16) |
		((uint32_t) (data[3]) << 24);
#endif
}
 8019bf8:	4618      	mov	r0, r3
 8019bfa:	3714      	adds	r7, #20
 8019bfc:	46bd      	mov	sp, r7
 8019bfe:	f85d 7b04 	ldr.w	r7, [sp], #4
 8019c02:	4770      	bx	lr

08019c04 <parse_uint64>:

static uint64_t
parse_uint64(unsigned len, const uint8_t *data)
{
 8019c04:	e92d 4fb0 	stmdb	sp!, {r4, r5, r7, r8, r9, sl, fp, lr}
 8019c08:	b0a0      	sub	sp, #128	; 0x80
 8019c0a:	af00      	add	r7, sp, #0
 8019c0c:	66f8      	str	r0, [r7, #108]	; 0x6c
 8019c0e:	66b9      	str	r1, [r7, #104]	; 0x68
	unsigned shift, i;
	uint64_t rv;

	if (len < 5)
 8019c10:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 8019c12:	2b04      	cmp	r3, #4
 8019c14:	d808      	bhi.n	8019c28 <parse_uint64+0x24>
		return parse_uint32(len, data);
 8019c16:	6eb9      	ldr	r1, [r7, #104]	; 0x68
 8019c18:	6ef8      	ldr	r0, [r7, #108]	; 0x6c
 8019c1a:	f7ff ff87 	bl	8019b2c <parse_uint32>
 8019c1e:	4603      	mov	r3, r0
 8019c20:	2200      	movs	r2, #0
 8019c22:	461c      	mov	r4, r3
 8019c24:	4615      	mov	r5, r2
 8019c26:	e0bd      	b.n	8019da4 <parse_uint64+0x1a0>
	rv = ((uint64_t) (data[0] & 0x7f)) |
 8019c28:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 8019c2a:	781b      	ldrb	r3, [r3, #0]
 8019c2c:	b2db      	uxtb	r3, r3
 8019c2e:	2200      	movs	r2, #0
 8019c30:	663b      	str	r3, [r7, #96]	; 0x60
 8019c32:	667a      	str	r2, [r7, #100]	; 0x64
 8019c34:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 8019c36:	f003 037f 	and.w	r3, r3, #127	; 0x7f
 8019c3a:	65bb      	str	r3, [r7, #88]	; 0x58
 8019c3c:	2300      	movs	r3, #0
 8019c3e:	65fb      	str	r3, [r7, #92]	; 0x5c
		((uint64_t) (data[1] & 0x7f) << 7) |
 8019c40:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 8019c42:	3301      	adds	r3, #1
 8019c44:	781b      	ldrb	r3, [r3, #0]
 8019c46:	b2db      	uxtb	r3, r3
 8019c48:	2200      	movs	r2, #0
 8019c4a:	469a      	mov	sl, r3
 8019c4c:	4693      	mov	fp, r2
 8019c4e:	f04f 0200 	mov.w	r2, #0
 8019c52:	f04f 0300 	mov.w	r3, #0
 8019c56:	ea4f 13cb 	mov.w	r3, fp, lsl #7
 8019c5a:	ea43 635a 	orr.w	r3, r3, sl, lsr #25
 8019c5e:	ea4f 12ca 	mov.w	r2, sl, lsl #7
 8019c62:	f402 537e 	and.w	r3, r2, #16256	; 0x3f80
 8019c66:	653b      	str	r3, [r7, #80]	; 0x50
 8019c68:	2300      	movs	r3, #0
 8019c6a:	657b      	str	r3, [r7, #84]	; 0x54
	rv = ((uint64_t) (data[0] & 0x7f)) |
 8019c6c:	e9d7 4516 	ldrd	r4, r5, [r7, #88]	; 0x58
 8019c70:	4623      	mov	r3, r4
 8019c72:	e9d7 0114 	ldrd	r0, r1, [r7, #80]	; 0x50
 8019c76:	4602      	mov	r2, r0
 8019c78:	4313      	orrs	r3, r2
 8019c7a:	64bb      	str	r3, [r7, #72]	; 0x48
 8019c7c:	462b      	mov	r3, r5
 8019c7e:	460a      	mov	r2, r1
 8019c80:	4313      	orrs	r3, r2
 8019c82:	64fb      	str	r3, [r7, #76]	; 0x4c
		((uint64_t) (data[2] & 0x7f) << 14) |
 8019c84:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 8019c86:	3302      	adds	r3, #2
 8019c88:	781b      	ldrb	r3, [r3, #0]
 8019c8a:	b2db      	uxtb	r3, r3
 8019c8c:	2200      	movs	r2, #0
 8019c8e:	643b      	str	r3, [r7, #64]	; 0x40
 8019c90:	647a      	str	r2, [r7, #68]	; 0x44
 8019c92:	f04f 0200 	mov.w	r2, #0
 8019c96:	f04f 0300 	mov.w	r3, #0
 8019c9a:	e9d7 4510 	ldrd	r4, r5, [r7, #64]	; 0x40
 8019c9e:	4629      	mov	r1, r5
 8019ca0:	038b      	lsls	r3, r1, #14
 8019ca2:	4621      	mov	r1, r4
 8019ca4:	ea43 4391 	orr.w	r3, r3, r1, lsr #18
 8019ca8:	4621      	mov	r1, r4
 8019caa:	038a      	lsls	r2, r1, #14
 8019cac:	f402 13fe 	and.w	r3, r2, #2080768	; 0x1fc000
 8019cb0:	63bb      	str	r3, [r7, #56]	; 0x38
 8019cb2:	2300      	movs	r3, #0
 8019cb4:	63fb      	str	r3, [r7, #60]	; 0x3c
		((uint64_t) (data[1] & 0x7f) << 7) |
 8019cb6:	e9d7 4512 	ldrd	r4, r5, [r7, #72]	; 0x48
 8019cba:	4623      	mov	r3, r4
 8019cbc:	e9d7 010e 	ldrd	r0, r1, [r7, #56]	; 0x38
 8019cc0:	4602      	mov	r2, r0
 8019cc2:	4313      	orrs	r3, r2
 8019cc4:	633b      	str	r3, [r7, #48]	; 0x30
 8019cc6:	462b      	mov	r3, r5
 8019cc8:	460a      	mov	r2, r1
 8019cca:	4313      	orrs	r3, r2
 8019ccc:	637b      	str	r3, [r7, #52]	; 0x34
		((uint64_t) (data[3] & 0x7f) << 21);
 8019cce:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 8019cd0:	3303      	adds	r3, #3
 8019cd2:	781b      	ldrb	r3, [r3, #0]
 8019cd4:	b2db      	uxtb	r3, r3
 8019cd6:	2200      	movs	r2, #0
 8019cd8:	62bb      	str	r3, [r7, #40]	; 0x28
 8019cda:	62fa      	str	r2, [r7, #44]	; 0x2c
 8019cdc:	f04f 0200 	mov.w	r2, #0
 8019ce0:	f04f 0300 	mov.w	r3, #0
 8019ce4:	e9d7 450a 	ldrd	r4, r5, [r7, #40]	; 0x28
 8019ce8:	4629      	mov	r1, r5
 8019cea:	054b      	lsls	r3, r1, #21
 8019cec:	4621      	mov	r1, r4
 8019cee:	ea43 23d1 	orr.w	r3, r3, r1, lsr #11
 8019cf2:	4621      	mov	r1, r4
 8019cf4:	054a      	lsls	r2, r1, #21
 8019cf6:	f002 637e 	and.w	r3, r2, #266338304	; 0xfe00000
 8019cfa:	623b      	str	r3, [r7, #32]
 8019cfc:	2300      	movs	r3, #0
 8019cfe:	627b      	str	r3, [r7, #36]	; 0x24
	rv = ((uint64_t) (data[0] & 0x7f)) |
 8019d00:	e9d7 450c 	ldrd	r4, r5, [r7, #48]	; 0x30
 8019d04:	4623      	mov	r3, r4
 8019d06:	e9d7 0108 	ldrd	r0, r1, [r7, #32]
 8019d0a:	4602      	mov	r2, r0
 8019d0c:	4313      	orrs	r3, r2
 8019d0e:	60bb      	str	r3, [r7, #8]
 8019d10:	462b      	mov	r3, r5
 8019d12:	460a      	mov	r2, r1
 8019d14:	4313      	orrs	r3, r2
 8019d16:	60fb      	str	r3, [r7, #12]
 8019d18:	e9d7 3402 	ldrd	r3, r4, [r7, #8]
 8019d1c:	e9c7 341c 	strd	r3, r4, [r7, #112]	; 0x70
	shift = 28;
 8019d20:	231c      	movs	r3, #28
 8019d22:	67fb      	str	r3, [r7, #124]	; 0x7c
	for (i = 4; i < len; i++) {
 8019d24:	2304      	movs	r3, #4
 8019d26:	67bb      	str	r3, [r7, #120]	; 0x78
 8019d28:	e036      	b.n	8019d98 <parse_uint64+0x194>
		rv |= (((uint64_t) (data[i] & 0x7f)) << shift);
 8019d2a:	6eba      	ldr	r2, [r7, #104]	; 0x68
 8019d2c:	6fbb      	ldr	r3, [r7, #120]	; 0x78
 8019d2e:	4413      	add	r3, r2
 8019d30:	781b      	ldrb	r3, [r3, #0]
 8019d32:	b2db      	uxtb	r3, r3
 8019d34:	2200      	movs	r2, #0
 8019d36:	61bb      	str	r3, [r7, #24]
 8019d38:	61fa      	str	r2, [r7, #28]
 8019d3a:	69bb      	ldr	r3, [r7, #24]
 8019d3c:	f003 037f 	and.w	r3, r3, #127	; 0x7f
 8019d40:	613b      	str	r3, [r7, #16]
 8019d42:	2300      	movs	r3, #0
 8019d44:	617b      	str	r3, [r7, #20]
 8019d46:	6ffb      	ldr	r3, [r7, #124]	; 0x7c
 8019d48:	f1a3 0120 	sub.w	r1, r3, #32
 8019d4c:	f1c3 0220 	rsb	r2, r3, #32
 8019d50:	e9d7 4504 	ldrd	r4, r5, [r7, #16]
 8019d54:	4628      	mov	r0, r5
 8019d56:	fa00 f903 	lsl.w	r9, r0, r3
 8019d5a:	4620      	mov	r0, r4
 8019d5c:	fa00 f101 	lsl.w	r1, r0, r1
 8019d60:	ea49 0901 	orr.w	r9, r9, r1
 8019d64:	4621      	mov	r1, r4
 8019d66:	fa21 f202 	lsr.w	r2, r1, r2
 8019d6a:	ea49 0902 	orr.w	r9, r9, r2
 8019d6e:	4622      	mov	r2, r4
 8019d70:	fa02 f803 	lsl.w	r8, r2, r3
 8019d74:	e9d7 231c 	ldrd	r2, r3, [r7, #112]	; 0x70
 8019d78:	ea42 0108 	orr.w	r1, r2, r8
 8019d7c:	6039      	str	r1, [r7, #0]
 8019d7e:	ea43 0309 	orr.w	r3, r3, r9
 8019d82:	607b      	str	r3, [r7, #4]
 8019d84:	e9d7 3400 	ldrd	r3, r4, [r7]
 8019d88:	e9c7 341c 	strd	r3, r4, [r7, #112]	; 0x70
		shift += 7;
 8019d8c:	6ffb      	ldr	r3, [r7, #124]	; 0x7c
 8019d8e:	3307      	adds	r3, #7
 8019d90:	67fb      	str	r3, [r7, #124]	; 0x7c
	for (i = 4; i < len; i++) {
 8019d92:	6fbb      	ldr	r3, [r7, #120]	; 0x78
 8019d94:	3301      	adds	r3, #1
 8019d96:	67bb      	str	r3, [r7, #120]	; 0x78
 8019d98:	6fba      	ldr	r2, [r7, #120]	; 0x78
 8019d9a:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 8019d9c:	429a      	cmp	r2, r3
 8019d9e:	d3c4      	bcc.n	8019d2a <parse_uint64+0x126>
	}
	return rv;
 8019da0:	e9d7 451c 	ldrd	r4, r5, [r7, #112]	; 0x70
}
 8019da4:	4622      	mov	r2, r4
 8019da6:	462b      	mov	r3, r5
 8019da8:	4610      	mov	r0, r2
 8019daa:	4619      	mov	r1, r3
 8019dac:	3780      	adds	r7, #128	; 0x80
 8019dae:	46bd      	mov	sp, r7
 8019db0:	e8bd 8fb0 	ldmia.w	sp!, {r4, r5, r7, r8, r9, sl, fp, pc}

08019db4 <unzigzag64>:

static inline int64_t
unzigzag64(uint64_t v)
{
 8019db4:	e92d 0fb0 	stmdb	sp!, {r4, r5, r7, r8, r9, sl, fp}
 8019db8:	b083      	sub	sp, #12
 8019dba:	af00      	add	r7, sp, #0
 8019dbc:	e9c7 0100 	strd	r0, r1, [r7]
	// Note:  Using unsigned types prevents undefined behavior
	return (int64_t)((v >> 1) ^ (~(v & 1) + 1));
 8019dc0:	e9d7 0100 	ldrd	r0, r1, [r7]
 8019dc4:	f04f 0200 	mov.w	r2, #0
 8019dc8:	f04f 0300 	mov.w	r3, #0
 8019dcc:	0842      	lsrs	r2, r0, #1
 8019dce:	ea42 72c1 	orr.w	r2, r2, r1, lsl #31
 8019dd2:	084b      	lsrs	r3, r1, #1
 8019dd4:	e9d7 0100 	ldrd	r0, r1, [r7]
 8019dd8:	f000 0801 	and.w	r8, r0, #1
 8019ddc:	f04f 0900 	mov.w	r9, #0
 8019de0:	2100      	movs	r1, #0
 8019de2:	f1d8 0400 	rsbs	r4, r8, #0
 8019de6:	eb61 0509 	sbc.w	r5, r1, r9
 8019dea:	ea82 0a04 	eor.w	sl, r2, r4
 8019dee:	ea83 0b05 	eor.w	fp, r3, r5
 8019df2:	4652      	mov	r2, sl
 8019df4:	465b      	mov	r3, fp
}
 8019df6:	4610      	mov	r0, r2
 8019df8:	4619      	mov	r1, r3
 8019dfa:	370c      	adds	r7, #12
 8019dfc:	46bd      	mov	sp, r7
 8019dfe:	e8bd 0fb0 	ldmia.w	sp!, {r4, r5, r7, r8, r9, sl, fp}
 8019e02:	4770      	bx	lr

08019e04 <parse_fixed_uint64>:

static inline uint64_t
parse_fixed_uint64(const uint8_t *data)
{
 8019e04:	b580      	push	{r7, lr}
 8019e06:	b084      	sub	sp, #16
 8019e08:	af00      	add	r7, sp, #0
 8019e0a:	6078      	str	r0, [r7, #4]
#if !defined(WORDS_BIGENDIAN)
	uint64_t t;
	memcpy(&t, data, 8);
 8019e0c:	f107 0308 	add.w	r3, r7, #8
 8019e10:	2208      	movs	r2, #8
 8019e12:	6879      	ldr	r1, [r7, #4]
 8019e14:	4618      	mov	r0, r3
 8019e16:	f005 fd09 	bl	801f82c <memcpy>
	return t;
 8019e1a:	e9d7 2302 	ldrd	r2, r3, [r7, #8]
#else
	return (uint64_t) parse_fixed_uint32(data) |
		(((uint64_t) parse_fixed_uint32(data + 4)) << 32);
#endif
}
 8019e1e:	4610      	mov	r0, r2
 8019e20:	4619      	mov	r1, r3
 8019e22:	3710      	adds	r7, #16
 8019e24:	46bd      	mov	sp, r7
 8019e26:	bd80      	pop	{r7, pc}

08019e28 <parse_boolean>:

static protobuf_c_boolean
parse_boolean(unsigned len, const uint8_t *data)
{
 8019e28:	b480      	push	{r7}
 8019e2a:	b085      	sub	sp, #20
 8019e2c:	af00      	add	r7, sp, #0
 8019e2e:	6078      	str	r0, [r7, #4]
 8019e30:	6039      	str	r1, [r7, #0]
	unsigned i;
	for (i = 0; i < len; i++)
 8019e32:	2300      	movs	r3, #0
 8019e34:	60fb      	str	r3, [r7, #12]
 8019e36:	e00c      	b.n	8019e52 <parse_boolean+0x2a>
		if (data[i] & 0x7f)
 8019e38:	683a      	ldr	r2, [r7, #0]
 8019e3a:	68fb      	ldr	r3, [r7, #12]
 8019e3c:	4413      	add	r3, r2
 8019e3e:	781b      	ldrb	r3, [r3, #0]
 8019e40:	f003 037f 	and.w	r3, r3, #127	; 0x7f
 8019e44:	2b00      	cmp	r3, #0
 8019e46:	d001      	beq.n	8019e4c <parse_boolean+0x24>
			return TRUE;
 8019e48:	2301      	movs	r3, #1
 8019e4a:	e007      	b.n	8019e5c <parse_boolean+0x34>
	for (i = 0; i < len; i++)
 8019e4c:	68fb      	ldr	r3, [r7, #12]
 8019e4e:	3301      	adds	r3, #1
 8019e50:	60fb      	str	r3, [r7, #12]
 8019e52:	68fa      	ldr	r2, [r7, #12]
 8019e54:	687b      	ldr	r3, [r7, #4]
 8019e56:	429a      	cmp	r2, r3
 8019e58:	d3ee      	bcc.n	8019e38 <parse_boolean+0x10>
	return FALSE;
 8019e5a:	2300      	movs	r3, #0
}
 8019e5c:	4618      	mov	r0, r3
 8019e5e:	3714      	adds	r7, #20
 8019e60:	46bd      	mov	sp, r7
 8019e62:	f85d 7b04 	ldr.w	r7, [sp], #4
 8019e66:	4770      	bx	lr

08019e68 <parse_required_member>:
static protobuf_c_boolean
parse_required_member(ScannedMember *scanned_member,
		      void *member,
		      ProtobufCAllocator *allocator,
		      protobuf_c_boolean maybe_clear)
{
 8019e68:	b580      	push	{r7, lr}
 8019e6a:	b092      	sub	sp, #72	; 0x48
 8019e6c:	af00      	add	r7, sp, #0
 8019e6e:	60f8      	str	r0, [r7, #12]
 8019e70:	60b9      	str	r1, [r7, #8]
 8019e72:	607a      	str	r2, [r7, #4]
 8019e74:	603b      	str	r3, [r7, #0]
	unsigned len = scanned_member->len;
 8019e76:	68fb      	ldr	r3, [r7, #12]
 8019e78:	68db      	ldr	r3, [r3, #12]
 8019e7a:	643b      	str	r3, [r7, #64]	; 0x40
	const uint8_t *data = scanned_member->data;
 8019e7c:	68fb      	ldr	r3, [r7, #12]
 8019e7e:	691b      	ldr	r3, [r3, #16]
 8019e80:	63fb      	str	r3, [r7, #60]	; 0x3c
	ProtobufCWireType wire_type = scanned_member->wire_type;
 8019e82:	68fb      	ldr	r3, [r7, #12]
 8019e84:	791b      	ldrb	r3, [r3, #4]
 8019e86:	f887 303b 	strb.w	r3, [r7, #59]	; 0x3b

	switch (scanned_member->field->type) {
 8019e8a:	68fb      	ldr	r3, [r7, #12]
 8019e8c:	689b      	ldr	r3, [r3, #8]
 8019e8e:	7a5b      	ldrb	r3, [r3, #9]
 8019e90:	2b10      	cmp	r3, #16
 8019e92:	f200 8189 	bhi.w	801a1a8 <parse_required_member+0x340>
 8019e96:	a201      	add	r2, pc, #4	; (adr r2, 8019e9c <parse_required_member+0x34>)
 8019e98:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8019e9c:	08019ee1 	.word	0x08019ee1
 8019ea0:	08019f1f 	.word	0x08019f1f
 8019ea4:	08019f45 	.word	0x08019f45
 8019ea8:	08019f61 	.word	0x08019f61
 8019eac:	08019f83 	.word	0x08019f83
 8019eb0:	08019fb1 	.word	0x08019fb1
 8019eb4:	08019f01 	.word	0x08019f01
 8019eb8:	08019f45 	.word	0x08019f45
 8019ebc:	08019f61 	.word	0x08019f61
 8019ec0:	08019fb1 	.word	0x08019fb1
 8019ec4:	08019f45 	.word	0x08019f45
 8019ec8:	08019fb1 	.word	0x08019fb1
 8019ecc:	08019fd1 	.word	0x08019fd1
 8019ed0:	08019ee1 	.word	0x08019ee1
 8019ed4:	08019fe3 	.word	0x08019fe3
 8019ed8:	0801a079 	.word	0x0801a079
 8019edc:	0801a117 	.word	0x0801a117
	case PROTOBUF_C_TYPE_ENUM:
	case PROTOBUF_C_TYPE_INT32:
		if (wire_type != PROTOBUF_C_WIRE_TYPE_VARINT)
 8019ee0:	f897 303b 	ldrb.w	r3, [r7, #59]	; 0x3b
 8019ee4:	2b00      	cmp	r3, #0
 8019ee6:	d001      	beq.n	8019eec <parse_required_member+0x84>
			return FALSE;
 8019ee8:	2300      	movs	r3, #0
 8019eea:	e15e      	b.n	801a1aa <parse_required_member+0x342>
		*(int32_t *) member = parse_int32(len, data);
 8019eec:	6bf9      	ldr	r1, [r7, #60]	; 0x3c
 8019eee:	6c38      	ldr	r0, [r7, #64]	; 0x40
 8019ef0:	f7ff fe5b 	bl	8019baa <parse_int32>
 8019ef4:	4603      	mov	r3, r0
 8019ef6:	461a      	mov	r2, r3
 8019ef8:	68bb      	ldr	r3, [r7, #8]
 8019efa:	601a      	str	r2, [r3, #0]
		return TRUE;
 8019efc:	2301      	movs	r3, #1
 8019efe:	e154      	b.n	801a1aa <parse_required_member+0x342>
	case PROTOBUF_C_TYPE_UINT32:
		if (wire_type != PROTOBUF_C_WIRE_TYPE_VARINT)
 8019f00:	f897 303b 	ldrb.w	r3, [r7, #59]	; 0x3b
 8019f04:	2b00      	cmp	r3, #0
 8019f06:	d001      	beq.n	8019f0c <parse_required_member+0xa4>
			return FALSE;
 8019f08:	2300      	movs	r3, #0
 8019f0a:	e14e      	b.n	801a1aa <parse_required_member+0x342>
		*(uint32_t *) member = parse_uint32(len, data);
 8019f0c:	6bf9      	ldr	r1, [r7, #60]	; 0x3c
 8019f0e:	6c38      	ldr	r0, [r7, #64]	; 0x40
 8019f10:	f7ff fe0c 	bl	8019b2c <parse_uint32>
 8019f14:	4602      	mov	r2, r0
 8019f16:	68bb      	ldr	r3, [r7, #8]
 8019f18:	601a      	str	r2, [r3, #0]
		return TRUE;
 8019f1a:	2301      	movs	r3, #1
 8019f1c:	e145      	b.n	801a1aa <parse_required_member+0x342>
	case PROTOBUF_C_TYPE_SINT32:
		if (wire_type != PROTOBUF_C_WIRE_TYPE_VARINT)
 8019f1e:	f897 303b 	ldrb.w	r3, [r7, #59]	; 0x3b
 8019f22:	2b00      	cmp	r3, #0
 8019f24:	d001      	beq.n	8019f2a <parse_required_member+0xc2>
			return FALSE;
 8019f26:	2300      	movs	r3, #0
 8019f28:	e13f      	b.n	801a1aa <parse_required_member+0x342>
		*(int32_t *) member = unzigzag32(parse_uint32(len, data));
 8019f2a:	6bf9      	ldr	r1, [r7, #60]	; 0x3c
 8019f2c:	6c38      	ldr	r0, [r7, #64]	; 0x40
 8019f2e:	f7ff fdfd 	bl	8019b2c <parse_uint32>
 8019f32:	4603      	mov	r3, r0
 8019f34:	4618      	mov	r0, r3
 8019f36:	f7ff fe46 	bl	8019bc6 <unzigzag32>
 8019f3a:	4602      	mov	r2, r0
 8019f3c:	68bb      	ldr	r3, [r7, #8]
 8019f3e:	601a      	str	r2, [r3, #0]
		return TRUE;
 8019f40:	2301      	movs	r3, #1
 8019f42:	e132      	b.n	801a1aa <parse_required_member+0x342>
	case PROTOBUF_C_TYPE_SFIXED32:
	case PROTOBUF_C_TYPE_FIXED32:
	case PROTOBUF_C_TYPE_FLOAT:
		if (wire_type != PROTOBUF_C_WIRE_TYPE_32BIT)
 8019f44:	f897 303b 	ldrb.w	r3, [r7, #59]	; 0x3b
 8019f48:	2b05      	cmp	r3, #5
 8019f4a:	d001      	beq.n	8019f50 <parse_required_member+0xe8>
			return FALSE;
 8019f4c:	2300      	movs	r3, #0
 8019f4e:	e12c      	b.n	801a1aa <parse_required_member+0x342>
		*(uint32_t *) member = parse_fixed_uint32(data);
 8019f50:	6bf8      	ldr	r0, [r7, #60]	; 0x3c
 8019f52:	f7ff fe49 	bl	8019be8 <parse_fixed_uint32>
 8019f56:	4602      	mov	r2, r0
 8019f58:	68bb      	ldr	r3, [r7, #8]
 8019f5a:	601a      	str	r2, [r3, #0]
		return TRUE;
 8019f5c:	2301      	movs	r3, #1
 8019f5e:	e124      	b.n	801a1aa <parse_required_member+0x342>
	case PROTOBUF_C_TYPE_INT64:
	case PROTOBUF_C_TYPE_UINT64:
		if (wire_type != PROTOBUF_C_WIRE_TYPE_VARINT)
 8019f60:	f897 303b 	ldrb.w	r3, [r7, #59]	; 0x3b
 8019f64:	2b00      	cmp	r3, #0
 8019f66:	d001      	beq.n	8019f6c <parse_required_member+0x104>
			return FALSE;
 8019f68:	2300      	movs	r3, #0
 8019f6a:	e11e      	b.n	801a1aa <parse_required_member+0x342>
		*(uint64_t *) member = parse_uint64(len, data);
 8019f6c:	6bf9      	ldr	r1, [r7, #60]	; 0x3c
 8019f6e:	6c38      	ldr	r0, [r7, #64]	; 0x40
 8019f70:	f7ff fe48 	bl	8019c04 <parse_uint64>
 8019f74:	4602      	mov	r2, r0
 8019f76:	460b      	mov	r3, r1
 8019f78:	68b9      	ldr	r1, [r7, #8]
 8019f7a:	e9c1 2300 	strd	r2, r3, [r1]
		return TRUE;
 8019f7e:	2301      	movs	r3, #1
 8019f80:	e113      	b.n	801a1aa <parse_required_member+0x342>
	case PROTOBUF_C_TYPE_SINT64:
		if (wire_type != PROTOBUF_C_WIRE_TYPE_VARINT)
 8019f82:	f897 303b 	ldrb.w	r3, [r7, #59]	; 0x3b
 8019f86:	2b00      	cmp	r3, #0
 8019f88:	d001      	beq.n	8019f8e <parse_required_member+0x126>
			return FALSE;
 8019f8a:	2300      	movs	r3, #0
 8019f8c:	e10d      	b.n	801a1aa <parse_required_member+0x342>
		*(int64_t *) member = unzigzag64(parse_uint64(len, data));
 8019f8e:	6bf9      	ldr	r1, [r7, #60]	; 0x3c
 8019f90:	6c38      	ldr	r0, [r7, #64]	; 0x40
 8019f92:	f7ff fe37 	bl	8019c04 <parse_uint64>
 8019f96:	4602      	mov	r2, r0
 8019f98:	460b      	mov	r3, r1
 8019f9a:	4610      	mov	r0, r2
 8019f9c:	4619      	mov	r1, r3
 8019f9e:	f7ff ff09 	bl	8019db4 <unzigzag64>
 8019fa2:	4602      	mov	r2, r0
 8019fa4:	460b      	mov	r3, r1
 8019fa6:	68b9      	ldr	r1, [r7, #8]
 8019fa8:	e9c1 2300 	strd	r2, r3, [r1]
		return TRUE;
 8019fac:	2301      	movs	r3, #1
 8019fae:	e0fc      	b.n	801a1aa <parse_required_member+0x342>
	case PROTOBUF_C_TYPE_SFIXED64:
	case PROTOBUF_C_TYPE_FIXED64:
	case PROTOBUF_C_TYPE_DOUBLE:
		if (wire_type != PROTOBUF_C_WIRE_TYPE_64BIT)
 8019fb0:	f897 303b 	ldrb.w	r3, [r7, #59]	; 0x3b
 8019fb4:	2b01      	cmp	r3, #1
 8019fb6:	d001      	beq.n	8019fbc <parse_required_member+0x154>
			return FALSE;
 8019fb8:	2300      	movs	r3, #0
 8019fba:	e0f6      	b.n	801a1aa <parse_required_member+0x342>
		*(uint64_t *) member = parse_fixed_uint64(data);
 8019fbc:	6bf8      	ldr	r0, [r7, #60]	; 0x3c
 8019fbe:	f7ff ff21 	bl	8019e04 <parse_fixed_uint64>
 8019fc2:	4602      	mov	r2, r0
 8019fc4:	460b      	mov	r3, r1
 8019fc6:	68b9      	ldr	r1, [r7, #8]
 8019fc8:	e9c1 2300 	strd	r2, r3, [r1]
		return TRUE;
 8019fcc:	2301      	movs	r3, #1
 8019fce:	e0ec      	b.n	801a1aa <parse_required_member+0x342>
	case PROTOBUF_C_TYPE_BOOL:
		*(protobuf_c_boolean *) member = parse_boolean(len, data);
 8019fd0:	6bf9      	ldr	r1, [r7, #60]	; 0x3c
 8019fd2:	6c38      	ldr	r0, [r7, #64]	; 0x40
 8019fd4:	f7ff ff28 	bl	8019e28 <parse_boolean>
 8019fd8:	4602      	mov	r2, r0
 8019fda:	68bb      	ldr	r3, [r7, #8]
 8019fdc:	601a      	str	r2, [r3, #0]
		return TRUE;
 8019fde:	2301      	movs	r3, #1
 8019fe0:	e0e3      	b.n	801a1aa <parse_required_member+0x342>
	case PROTOBUF_C_TYPE_STRING: {
		char **pstr = member;
 8019fe2:	68bb      	ldr	r3, [r7, #8]
 8019fe4:	61bb      	str	r3, [r7, #24]
		unsigned pref_len = scanned_member->length_prefix_len;
 8019fe6:	68fb      	ldr	r3, [r7, #12]
 8019fe8:	795b      	ldrb	r3, [r3, #5]
 8019fea:	617b      	str	r3, [r7, #20]

		if (wire_type != PROTOBUF_C_WIRE_TYPE_LENGTH_PREFIXED)
 8019fec:	f897 303b 	ldrb.w	r3, [r7, #59]	; 0x3b
 8019ff0:	2b02      	cmp	r3, #2
 8019ff2:	d001      	beq.n	8019ff8 <parse_required_member+0x190>
			return FALSE;
 8019ff4:	2300      	movs	r3, #0
 8019ff6:	e0d8      	b.n	801a1aa <parse_required_member+0x342>

		if (maybe_clear && *pstr != NULL) {
 8019ff8:	683b      	ldr	r3, [r7, #0]
 8019ffa:	2b00      	cmp	r3, #0
 8019ffc:	d016      	beq.n	801a02c <parse_required_member+0x1c4>
 8019ffe:	69bb      	ldr	r3, [r7, #24]
 801a000:	681b      	ldr	r3, [r3, #0]
 801a002:	2b00      	cmp	r3, #0
 801a004:	d012      	beq.n	801a02c <parse_required_member+0x1c4>
			const char *def = scanned_member->field->default_value;
 801a006:	68fb      	ldr	r3, [r7, #12]
 801a008:	689b      	ldr	r3, [r3, #8]
 801a00a:	699b      	ldr	r3, [r3, #24]
 801a00c:	613b      	str	r3, [r7, #16]
			if (*pstr != NULL && *pstr != def)
 801a00e:	69bb      	ldr	r3, [r7, #24]
 801a010:	681b      	ldr	r3, [r3, #0]
 801a012:	2b00      	cmp	r3, #0
 801a014:	d00a      	beq.n	801a02c <parse_required_member+0x1c4>
 801a016:	69bb      	ldr	r3, [r7, #24]
 801a018:	681b      	ldr	r3, [r3, #0]
 801a01a:	693a      	ldr	r2, [r7, #16]
 801a01c:	429a      	cmp	r2, r3
 801a01e:	d005      	beq.n	801a02c <parse_required_member+0x1c4>
				do_free(allocator, *pstr);
 801a020:	69bb      	ldr	r3, [r7, #24]
 801a022:	681b      	ldr	r3, [r3, #0]
 801a024:	4619      	mov	r1, r3
 801a026:	6878      	ldr	r0, [r7, #4]
 801a028:	f7fd fed8 	bl	8017ddc <do_free>
		}
		*pstr = do_alloc(allocator, len - pref_len + 1);
 801a02c:	6c3a      	ldr	r2, [r7, #64]	; 0x40
 801a02e:	697b      	ldr	r3, [r7, #20]
 801a030:	1ad3      	subs	r3, r2, r3
 801a032:	3301      	adds	r3, #1
 801a034:	4619      	mov	r1, r3
 801a036:	6878      	ldr	r0, [r7, #4]
 801a038:	f7fd febf 	bl	8017dba <do_alloc>
 801a03c:	4602      	mov	r2, r0
 801a03e:	69bb      	ldr	r3, [r7, #24]
 801a040:	601a      	str	r2, [r3, #0]
		if (*pstr == NULL)
 801a042:	69bb      	ldr	r3, [r7, #24]
 801a044:	681b      	ldr	r3, [r3, #0]
 801a046:	2b00      	cmp	r3, #0
 801a048:	d101      	bne.n	801a04e <parse_required_member+0x1e6>
			return FALSE;
 801a04a:	2300      	movs	r3, #0
 801a04c:	e0ad      	b.n	801a1aa <parse_required_member+0x342>
		memcpy(*pstr, data + pref_len, len - pref_len);
 801a04e:	69bb      	ldr	r3, [r7, #24]
 801a050:	6818      	ldr	r0, [r3, #0]
 801a052:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 801a054:	697b      	ldr	r3, [r7, #20]
 801a056:	18d1      	adds	r1, r2, r3
 801a058:	6c3a      	ldr	r2, [r7, #64]	; 0x40
 801a05a:	697b      	ldr	r3, [r7, #20]
 801a05c:	1ad3      	subs	r3, r2, r3
 801a05e:	461a      	mov	r2, r3
 801a060:	f005 fbe4 	bl	801f82c <memcpy>
		(*pstr)[len - pref_len] = 0;
 801a064:	69bb      	ldr	r3, [r7, #24]
 801a066:	681a      	ldr	r2, [r3, #0]
 801a068:	6c39      	ldr	r1, [r7, #64]	; 0x40
 801a06a:	697b      	ldr	r3, [r7, #20]
 801a06c:	1acb      	subs	r3, r1, r3
 801a06e:	4413      	add	r3, r2
 801a070:	2200      	movs	r2, #0
 801a072:	701a      	strb	r2, [r3, #0]
		return TRUE;
 801a074:	2301      	movs	r3, #1
 801a076:	e098      	b.n	801a1aa <parse_required_member+0x342>
	}
	case PROTOBUF_C_TYPE_BYTES: {
		ProtobufCBinaryData *bd = member;
 801a078:	68bb      	ldr	r3, [r7, #8]
 801a07a:	627b      	str	r3, [r7, #36]	; 0x24
		const ProtobufCBinaryData *def_bd;
		unsigned pref_len = scanned_member->length_prefix_len;
 801a07c:	68fb      	ldr	r3, [r7, #12]
 801a07e:	795b      	ldrb	r3, [r3, #5]
 801a080:	623b      	str	r3, [r7, #32]

		if (wire_type != PROTOBUF_C_WIRE_TYPE_LENGTH_PREFIXED)
 801a082:	f897 303b 	ldrb.w	r3, [r7, #59]	; 0x3b
 801a086:	2b02      	cmp	r3, #2
 801a088:	d001      	beq.n	801a08e <parse_required_member+0x226>
			return FALSE;
 801a08a:	2300      	movs	r3, #0
 801a08c:	e08d      	b.n	801a1aa <parse_required_member+0x342>

		def_bd = scanned_member->field->default_value;
 801a08e:	68fb      	ldr	r3, [r7, #12]
 801a090:	689b      	ldr	r3, [r3, #8]
 801a092:	699b      	ldr	r3, [r3, #24]
 801a094:	61fb      	str	r3, [r7, #28]
		if (maybe_clear &&
 801a096:	683b      	ldr	r3, [r7, #0]
 801a098:	2b00      	cmp	r3, #0
 801a09a:	d012      	beq.n	801a0c2 <parse_required_member+0x25a>
		    bd->data != NULL &&
 801a09c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801a09e:	685b      	ldr	r3, [r3, #4]
		if (maybe_clear &&
 801a0a0:	2b00      	cmp	r3, #0
 801a0a2:	d00e      	beq.n	801a0c2 <parse_required_member+0x25a>
		    bd->data != NULL &&
 801a0a4:	69fb      	ldr	r3, [r7, #28]
 801a0a6:	2b00      	cmp	r3, #0
 801a0a8:	d005      	beq.n	801a0b6 <parse_required_member+0x24e>
		    (def_bd == NULL || bd->data != def_bd->data))
 801a0aa:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801a0ac:	685a      	ldr	r2, [r3, #4]
 801a0ae:	69fb      	ldr	r3, [r7, #28]
 801a0b0:	685b      	ldr	r3, [r3, #4]
 801a0b2:	429a      	cmp	r2, r3
 801a0b4:	d005      	beq.n	801a0c2 <parse_required_member+0x25a>
		{
			do_free(allocator, bd->data);
 801a0b6:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801a0b8:	685b      	ldr	r3, [r3, #4]
 801a0ba:	4619      	mov	r1, r3
 801a0bc:	6878      	ldr	r0, [r7, #4]
 801a0be:	f7fd fe8d 	bl	8017ddc <do_free>
		}
		if (len - pref_len > 0) {
 801a0c2:	6c3a      	ldr	r2, [r7, #64]	; 0x40
 801a0c4:	6a3b      	ldr	r3, [r7, #32]
 801a0c6:	429a      	cmp	r2, r3
 801a0c8:	d01b      	beq.n	801a102 <parse_required_member+0x29a>
			bd->data = do_alloc(allocator, len - pref_len);
 801a0ca:	6c3a      	ldr	r2, [r7, #64]	; 0x40
 801a0cc:	6a3b      	ldr	r3, [r7, #32]
 801a0ce:	1ad3      	subs	r3, r2, r3
 801a0d0:	4619      	mov	r1, r3
 801a0d2:	6878      	ldr	r0, [r7, #4]
 801a0d4:	f7fd fe71 	bl	8017dba <do_alloc>
 801a0d8:	4602      	mov	r2, r0
 801a0da:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801a0dc:	605a      	str	r2, [r3, #4]
			if (bd->data == NULL)
 801a0de:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801a0e0:	685b      	ldr	r3, [r3, #4]
 801a0e2:	2b00      	cmp	r3, #0
 801a0e4:	d101      	bne.n	801a0ea <parse_required_member+0x282>
				return FALSE;
 801a0e6:	2300      	movs	r3, #0
 801a0e8:	e05f      	b.n	801a1aa <parse_required_member+0x342>
			memcpy(bd->data, data + pref_len, len - pref_len);
 801a0ea:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801a0ec:	6858      	ldr	r0, [r3, #4]
 801a0ee:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 801a0f0:	6a3b      	ldr	r3, [r7, #32]
 801a0f2:	18d1      	adds	r1, r2, r3
 801a0f4:	6c3a      	ldr	r2, [r7, #64]	; 0x40
 801a0f6:	6a3b      	ldr	r3, [r7, #32]
 801a0f8:	1ad3      	subs	r3, r2, r3
 801a0fa:	461a      	mov	r2, r3
 801a0fc:	f005 fb96 	bl	801f82c <memcpy>
 801a100:	e002      	b.n	801a108 <parse_required_member+0x2a0>
		} else {
			bd->data = NULL;
 801a102:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801a104:	2200      	movs	r2, #0
 801a106:	605a      	str	r2, [r3, #4]
		}
		bd->len = len - pref_len;
 801a108:	6c3a      	ldr	r2, [r7, #64]	; 0x40
 801a10a:	6a3b      	ldr	r3, [r7, #32]
 801a10c:	1ad2      	subs	r2, r2, r3
 801a10e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801a110:	601a      	str	r2, [r3, #0]
		return TRUE;
 801a112:	2301      	movs	r3, #1
 801a114:	e049      	b.n	801a1aa <parse_required_member+0x342>
	}
	case PROTOBUF_C_TYPE_MESSAGE: {
		ProtobufCMessage **pmessage = member;
 801a116:	68bb      	ldr	r3, [r7, #8]
 801a118:	637b      	str	r3, [r7, #52]	; 0x34
		ProtobufCMessage *subm;
		const ProtobufCMessage *def_mess;
		protobuf_c_boolean merge_successful = TRUE;
 801a11a:	2301      	movs	r3, #1
 801a11c:	647b      	str	r3, [r7, #68]	; 0x44
		unsigned pref_len = scanned_member->length_prefix_len;
 801a11e:	68fb      	ldr	r3, [r7, #12]
 801a120:	795b      	ldrb	r3, [r3, #5]
 801a122:	633b      	str	r3, [r7, #48]	; 0x30

		if (wire_type != PROTOBUF_C_WIRE_TYPE_LENGTH_PREFIXED)
 801a124:	f897 303b 	ldrb.w	r3, [r7, #59]	; 0x3b
 801a128:	2b02      	cmp	r3, #2
 801a12a:	d001      	beq.n	801a130 <parse_required_member+0x2c8>
			return FALSE;
 801a12c:	2300      	movs	r3, #0
 801a12e:	e03c      	b.n	801a1aa <parse_required_member+0x342>

		def_mess = scanned_member->field->default_value;
 801a130:	68fb      	ldr	r3, [r7, #12]
 801a132:	689b      	ldr	r3, [r3, #8]
 801a134:	699b      	ldr	r3, [r3, #24]
 801a136:	62fb      	str	r3, [r7, #44]	; 0x2c
		subm = protobuf_c_message_unpack(scanned_member->field->descriptor,
 801a138:	68fb      	ldr	r3, [r7, #12]
 801a13a:	689b      	ldr	r3, [r3, #8]
 801a13c:	6958      	ldr	r0, [r3, #20]
 801a13e:	6c3a      	ldr	r2, [r7, #64]	; 0x40
 801a140:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801a142:	1ad1      	subs	r1, r2, r3
 801a144:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 801a146:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801a148:	4413      	add	r3, r2
 801a14a:	460a      	mov	r2, r1
 801a14c:	6879      	ldr	r1, [r7, #4]
 801a14e:	f000 fc01 	bl	801a954 <protobuf_c_message_unpack>
 801a152:	62b8      	str	r0, [r7, #40]	; 0x28
						 allocator,
						 len - pref_len,
						 data + pref_len);

		if (maybe_clear &&
 801a154:	683b      	ldr	r3, [r7, #0]
 801a156:	2b00      	cmp	r3, #0
 801a158:	d019      	beq.n	801a18e <parse_required_member+0x326>
		    *pmessage != NULL &&
 801a15a:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 801a15c:	681b      	ldr	r3, [r3, #0]
		if (maybe_clear &&
 801a15e:	2b00      	cmp	r3, #0
 801a160:	d015      	beq.n	801a18e <parse_required_member+0x326>
		    *pmessage != def_mess)
 801a162:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 801a164:	681b      	ldr	r3, [r3, #0]
		    *pmessage != NULL &&
 801a166:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 801a168:	429a      	cmp	r2, r3
 801a16a:	d010      	beq.n	801a18e <parse_required_member+0x326>
		{
			if (subm != NULL)
 801a16c:	6abb      	ldr	r3, [r7, #40]	; 0x28
 801a16e:	2b00      	cmp	r3, #0
 801a170:	d007      	beq.n	801a182 <parse_required_member+0x31a>
				merge_successful = merge_messages(*pmessage, subm, allocator);
 801a172:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 801a174:	681b      	ldr	r3, [r3, #0]
 801a176:	687a      	ldr	r2, [r7, #4]
 801a178:	6ab9      	ldr	r1, [r7, #40]	; 0x28
 801a17a:	4618      	mov	r0, r3
 801a17c:	f7ff fad2 	bl	8019724 <merge_messages>
 801a180:	6478      	str	r0, [r7, #68]	; 0x44
			/* Delete the previous message */
			protobuf_c_message_free_unpacked(*pmessage, allocator);
 801a182:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 801a184:	681b      	ldr	r3, [r3, #0]
 801a186:	6879      	ldr	r1, [r7, #4]
 801a188:	4618      	mov	r0, r3
 801a18a:	f001 f8cb 	bl	801b324 <protobuf_c_message_free_unpacked>
		}
		*pmessage = subm;
 801a18e:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 801a190:	6aba      	ldr	r2, [r7, #40]	; 0x28
 801a192:	601a      	str	r2, [r3, #0]
		if (subm == NULL || !merge_successful)
 801a194:	6abb      	ldr	r3, [r7, #40]	; 0x28
 801a196:	2b00      	cmp	r3, #0
 801a198:	d002      	beq.n	801a1a0 <parse_required_member+0x338>
 801a19a:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 801a19c:	2b00      	cmp	r3, #0
 801a19e:	d101      	bne.n	801a1a4 <parse_required_member+0x33c>
			return FALSE;
 801a1a0:	2300      	movs	r3, #0
 801a1a2:	e002      	b.n	801a1aa <parse_required_member+0x342>
		return TRUE;
 801a1a4:	2301      	movs	r3, #1
 801a1a6:	e000      	b.n	801a1aa <parse_required_member+0x342>
	}
	}
	return FALSE;
 801a1a8:	2300      	movs	r3, #0
}
 801a1aa:	4618      	mov	r0, r3
 801a1ac:	3748      	adds	r7, #72	; 0x48
 801a1ae:	46bd      	mov	sp, r7
 801a1b0:	bd80      	pop	{r7, pc}
 801a1b2:	bf00      	nop

0801a1b4 <parse_oneof_member>:
static protobuf_c_boolean
parse_oneof_member (ScannedMember *scanned_member,
		    void *member,
		    ProtobufCMessage *message,
		    ProtobufCAllocator *allocator)
{
 801a1b4:	b580      	push	{r7, lr}
 801a1b6:	b08e      	sub	sp, #56	; 0x38
 801a1b8:	af00      	add	r7, sp, #0
 801a1ba:	60f8      	str	r0, [r7, #12]
 801a1bc:	60b9      	str	r1, [r7, #8]
 801a1be:	607a      	str	r2, [r7, #4]
 801a1c0:	603b      	str	r3, [r7, #0]
	uint32_t *oneof_case = STRUCT_MEMBER_PTR(uint32_t, message,
 801a1c2:	68fb      	ldr	r3, [r7, #12]
 801a1c4:	689b      	ldr	r3, [r3, #8]
 801a1c6:	68db      	ldr	r3, [r3, #12]
 801a1c8:	687a      	ldr	r2, [r7, #4]
 801a1ca:	4413      	add	r3, r2
 801a1cc:	637b      	str	r3, [r7, #52]	; 0x34
					       scanned_member->field->quantifier_offset);

	/* If we have already parsed a member of this oneof, free it. */
	if (*oneof_case != 0) {
 801a1ce:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 801a1d0:	681b      	ldr	r3, [r3, #0]
 801a1d2:	2b00      	cmp	r3, #0
 801a1d4:	d079      	beq.n	801a2ca <parse_oneof_member+0x116>
		const ProtobufCFieldDescriptor *old_field;
		size_t el_size;
		/* lookup field */
		int field_index =
			int_range_lookup(message->descriptor->n_field_ranges,
 801a1d6:	687b      	ldr	r3, [r7, #4]
 801a1d8:	681b      	ldr	r3, [r3, #0]
 801a1da:	6a58      	ldr	r0, [r3, #36]	; 0x24
					 message->descriptor->field_ranges,
 801a1dc:	687b      	ldr	r3, [r7, #4]
 801a1de:	681b      	ldr	r3, [r3, #0]
			int_range_lookup(message->descriptor->n_field_ranges,
 801a1e0:	6a99      	ldr	r1, [r3, #40]	; 0x28
					 *oneof_case);
 801a1e2:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 801a1e4:	681b      	ldr	r3, [r3, #0]
			int_range_lookup(message->descriptor->n_field_ranges,
 801a1e6:	461a      	mov	r2, r3
 801a1e8:	f7ff f934 	bl	8019454 <int_range_lookup>
 801a1ec:	6338      	str	r0, [r7, #48]	; 0x30
		if (field_index < 0)
 801a1ee:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801a1f0:	2b00      	cmp	r3, #0
 801a1f2:	da01      	bge.n	801a1f8 <parse_oneof_member+0x44>
			return FALSE;
 801a1f4:	2300      	movs	r3, #0
 801a1f6:	e078      	b.n	801a2ea <parse_oneof_member+0x136>
		old_field = message->descriptor->fields + field_index;
 801a1f8:	687b      	ldr	r3, [r7, #4]
 801a1fa:	681b      	ldr	r3, [r3, #0]
 801a1fc:	69da      	ldr	r2, [r3, #28]
 801a1fe:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801a200:	212c      	movs	r1, #44	; 0x2c
 801a202:	fb01 f303 	mul.w	r3, r1, r3
 801a206:	4413      	add	r3, r2
 801a208:	62fb      	str	r3, [r7, #44]	; 0x2c
		el_size = sizeof_elt_in_repeated_array(old_field->type);
 801a20a:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 801a20c:	7a5b      	ldrb	r3, [r3, #9]
 801a20e:	4618      	mov	r0, r3
 801a210:	f7fe fe38 	bl	8018e84 <sizeof_elt_in_repeated_array>
 801a214:	62b8      	str	r0, [r7, #40]	; 0x28

		switch (old_field->type) {
 801a216:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 801a218:	7a5b      	ldrb	r3, [r3, #9]
 801a21a:	2b10      	cmp	r3, #16
 801a21c:	d034      	beq.n	801a288 <parse_oneof_member+0xd4>
 801a21e:	2b10      	cmp	r3, #16
 801a220:	dc47      	bgt.n	801a2b2 <parse_oneof_member+0xfe>
 801a222:	2b0e      	cmp	r3, #14
 801a224:	d002      	beq.n	801a22c <parse_oneof_member+0x78>
 801a226:	2b0f      	cmp	r3, #15
 801a228:	d015      	beq.n	801a256 <parse_oneof_member+0xa2>
			if (*pmessage != NULL && *pmessage != def_mess)
				protobuf_c_message_free_unpacked(*pmessage, allocator);
			break;
	        }
		default:
			break;
 801a22a:	e042      	b.n	801a2b2 <parse_oneof_member+0xfe>
			char **pstr = member;
 801a22c:	68bb      	ldr	r3, [r7, #8]
 801a22e:	617b      	str	r3, [r7, #20]
			const char *def = old_field->default_value;
 801a230:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 801a232:	699b      	ldr	r3, [r3, #24]
 801a234:	613b      	str	r3, [r7, #16]
			if (*pstr != NULL && *pstr != def)
 801a236:	697b      	ldr	r3, [r7, #20]
 801a238:	681b      	ldr	r3, [r3, #0]
 801a23a:	2b00      	cmp	r3, #0
 801a23c:	d03b      	beq.n	801a2b6 <parse_oneof_member+0x102>
 801a23e:	697b      	ldr	r3, [r7, #20]
 801a240:	681b      	ldr	r3, [r3, #0]
 801a242:	693a      	ldr	r2, [r7, #16]
 801a244:	429a      	cmp	r2, r3
 801a246:	d036      	beq.n	801a2b6 <parse_oneof_member+0x102>
				do_free(allocator, *pstr);
 801a248:	697b      	ldr	r3, [r7, #20]
 801a24a:	681b      	ldr	r3, [r3, #0]
 801a24c:	4619      	mov	r1, r3
 801a24e:	6838      	ldr	r0, [r7, #0]
 801a250:	f7fd fdc4 	bl	8017ddc <do_free>
			break;
 801a254:	e02f      	b.n	801a2b6 <parse_oneof_member+0x102>
			ProtobufCBinaryData *bd = member;
 801a256:	68bb      	ldr	r3, [r7, #8]
 801a258:	61fb      	str	r3, [r7, #28]
			const ProtobufCBinaryData *def_bd = old_field->default_value;
 801a25a:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 801a25c:	699b      	ldr	r3, [r3, #24]
 801a25e:	61bb      	str	r3, [r7, #24]
			if (bd->data != NULL &&
 801a260:	69fb      	ldr	r3, [r7, #28]
 801a262:	685b      	ldr	r3, [r3, #4]
 801a264:	2b00      	cmp	r3, #0
 801a266:	d028      	beq.n	801a2ba <parse_oneof_member+0x106>
 801a268:	69bb      	ldr	r3, [r7, #24]
 801a26a:	2b00      	cmp	r3, #0
 801a26c:	d005      	beq.n	801a27a <parse_oneof_member+0xc6>
			   (def_bd == NULL || bd->data != def_bd->data))
 801a26e:	69fb      	ldr	r3, [r7, #28]
 801a270:	685a      	ldr	r2, [r3, #4]
 801a272:	69bb      	ldr	r3, [r7, #24]
 801a274:	685b      	ldr	r3, [r3, #4]
 801a276:	429a      	cmp	r2, r3
 801a278:	d01f      	beq.n	801a2ba <parse_oneof_member+0x106>
				do_free(allocator, bd->data);
 801a27a:	69fb      	ldr	r3, [r7, #28]
 801a27c:	685b      	ldr	r3, [r3, #4]
 801a27e:	4619      	mov	r1, r3
 801a280:	6838      	ldr	r0, [r7, #0]
 801a282:	f7fd fdab 	bl	8017ddc <do_free>
			break;
 801a286:	e018      	b.n	801a2ba <parse_oneof_member+0x106>
			ProtobufCMessage **pmessage = member;
 801a288:	68bb      	ldr	r3, [r7, #8]
 801a28a:	627b      	str	r3, [r7, #36]	; 0x24
			const ProtobufCMessage *def_mess = old_field->default_value;
 801a28c:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 801a28e:	699b      	ldr	r3, [r3, #24]
 801a290:	623b      	str	r3, [r7, #32]
			if (*pmessage != NULL && *pmessage != def_mess)
 801a292:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801a294:	681b      	ldr	r3, [r3, #0]
 801a296:	2b00      	cmp	r3, #0
 801a298:	d011      	beq.n	801a2be <parse_oneof_member+0x10a>
 801a29a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801a29c:	681b      	ldr	r3, [r3, #0]
 801a29e:	6a3a      	ldr	r2, [r7, #32]
 801a2a0:	429a      	cmp	r2, r3
 801a2a2:	d00c      	beq.n	801a2be <parse_oneof_member+0x10a>
				protobuf_c_message_free_unpacked(*pmessage, allocator);
 801a2a4:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801a2a6:	681b      	ldr	r3, [r3, #0]
 801a2a8:	6839      	ldr	r1, [r7, #0]
 801a2aa:	4618      	mov	r0, r3
 801a2ac:	f001 f83a 	bl	801b324 <protobuf_c_message_free_unpacked>
			break;
 801a2b0:	e005      	b.n	801a2be <parse_oneof_member+0x10a>
			break;
 801a2b2:	bf00      	nop
 801a2b4:	e004      	b.n	801a2c0 <parse_oneof_member+0x10c>
			break;
 801a2b6:	bf00      	nop
 801a2b8:	e002      	b.n	801a2c0 <parse_oneof_member+0x10c>
			break;
 801a2ba:	bf00      	nop
 801a2bc:	e000      	b.n	801a2c0 <parse_oneof_member+0x10c>
			break;
 801a2be:	bf00      	nop
		}

		memset (member, 0, el_size);
 801a2c0:	6aba      	ldr	r2, [r7, #40]	; 0x28
 801a2c2:	2100      	movs	r1, #0
 801a2c4:	68b8      	ldr	r0, [r7, #8]
 801a2c6:	f005 fad9 	bl	801f87c <memset>
	}
	if (!parse_required_member (scanned_member, member, allocator, TRUE))
 801a2ca:	2301      	movs	r3, #1
 801a2cc:	683a      	ldr	r2, [r7, #0]
 801a2ce:	68b9      	ldr	r1, [r7, #8]
 801a2d0:	68f8      	ldr	r0, [r7, #12]
 801a2d2:	f7ff fdc9 	bl	8019e68 <parse_required_member>
 801a2d6:	4603      	mov	r3, r0
 801a2d8:	2b00      	cmp	r3, #0
 801a2da:	d101      	bne.n	801a2e0 <parse_oneof_member+0x12c>
		return FALSE;
 801a2dc:	2300      	movs	r3, #0
 801a2de:	e004      	b.n	801a2ea <parse_oneof_member+0x136>

	*oneof_case = scanned_member->tag;
 801a2e0:	68fb      	ldr	r3, [r7, #12]
 801a2e2:	681a      	ldr	r2, [r3, #0]
 801a2e4:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 801a2e6:	601a      	str	r2, [r3, #0]
	return TRUE;
 801a2e8:	2301      	movs	r3, #1
}
 801a2ea:	4618      	mov	r0, r3
 801a2ec:	3738      	adds	r7, #56	; 0x38
 801a2ee:	46bd      	mov	sp, r7
 801a2f0:	bd80      	pop	{r7, pc}

0801a2f2 <parse_optional_member>:
static protobuf_c_boolean
parse_optional_member(ScannedMember *scanned_member,
		      void *member,
		      ProtobufCMessage *message,
		      ProtobufCAllocator *allocator)
{
 801a2f2:	b580      	push	{r7, lr}
 801a2f4:	b084      	sub	sp, #16
 801a2f6:	af00      	add	r7, sp, #0
 801a2f8:	60f8      	str	r0, [r7, #12]
 801a2fa:	60b9      	str	r1, [r7, #8]
 801a2fc:	607a      	str	r2, [r7, #4]
 801a2fe:	603b      	str	r3, [r7, #0]
	if (!parse_required_member(scanned_member, member, allocator, TRUE))
 801a300:	2301      	movs	r3, #1
 801a302:	683a      	ldr	r2, [r7, #0]
 801a304:	68b9      	ldr	r1, [r7, #8]
 801a306:	68f8      	ldr	r0, [r7, #12]
 801a308:	f7ff fdae 	bl	8019e68 <parse_required_member>
 801a30c:	4603      	mov	r3, r0
 801a30e:	2b00      	cmp	r3, #0
 801a310:	d101      	bne.n	801a316 <parse_optional_member+0x24>
		return FALSE;
 801a312:	2300      	movs	r3, #0
 801a314:	e00c      	b.n	801a330 <parse_optional_member+0x3e>
	if (scanned_member->field->quantifier_offset != 0)
 801a316:	68fb      	ldr	r3, [r7, #12]
 801a318:	689b      	ldr	r3, [r3, #8]
 801a31a:	68db      	ldr	r3, [r3, #12]
 801a31c:	2b00      	cmp	r3, #0
 801a31e:	d006      	beq.n	801a32e <parse_optional_member+0x3c>
		STRUCT_MEMBER(protobuf_c_boolean,
 801a320:	68fb      	ldr	r3, [r7, #12]
 801a322:	689b      	ldr	r3, [r3, #8]
 801a324:	68db      	ldr	r3, [r3, #12]
 801a326:	687a      	ldr	r2, [r7, #4]
 801a328:	4413      	add	r3, r2
			      message,
			      scanned_member->field->quantifier_offset) = TRUE;
 801a32a:	2201      	movs	r2, #1
 801a32c:	601a      	str	r2, [r3, #0]
	return TRUE;
 801a32e:	2301      	movs	r3, #1
}
 801a330:	4618      	mov	r0, r3
 801a332:	3710      	adds	r7, #16
 801a334:	46bd      	mov	sp, r7
 801a336:	bd80      	pop	{r7, pc}

0801a338 <parse_repeated_member>:
static protobuf_c_boolean
parse_repeated_member(ScannedMember *scanned_member,
		      void *member,
		      ProtobufCMessage *message,
		      ProtobufCAllocator *allocator)
{
 801a338:	b580      	push	{r7, lr}
 801a33a:	b088      	sub	sp, #32
 801a33c:	af00      	add	r7, sp, #0
 801a33e:	60f8      	str	r0, [r7, #12]
 801a340:	60b9      	str	r1, [r7, #8]
 801a342:	607a      	str	r2, [r7, #4]
 801a344:	603b      	str	r3, [r7, #0]
	const ProtobufCFieldDescriptor *field = scanned_member->field;
 801a346:	68fb      	ldr	r3, [r7, #12]
 801a348:	689b      	ldr	r3, [r3, #8]
 801a34a:	61fb      	str	r3, [r7, #28]
	size_t *p_n = STRUCT_MEMBER_PTR(size_t, message, field->quantifier_offset);
 801a34c:	69fb      	ldr	r3, [r7, #28]
 801a34e:	68db      	ldr	r3, [r3, #12]
 801a350:	687a      	ldr	r2, [r7, #4]
 801a352:	4413      	add	r3, r2
 801a354:	61bb      	str	r3, [r7, #24]
	size_t siz = sizeof_elt_in_repeated_array(field->type);
 801a356:	69fb      	ldr	r3, [r7, #28]
 801a358:	7a5b      	ldrb	r3, [r3, #9]
 801a35a:	4618      	mov	r0, r3
 801a35c:	f7fe fd92 	bl	8018e84 <sizeof_elt_in_repeated_array>
 801a360:	6178      	str	r0, [r7, #20]
	char *array = *(char **) member;
 801a362:	68bb      	ldr	r3, [r7, #8]
 801a364:	681b      	ldr	r3, [r3, #0]
 801a366:	613b      	str	r3, [r7, #16]

	if (!parse_required_member(scanned_member, array + siz * (*p_n),
 801a368:	69bb      	ldr	r3, [r7, #24]
 801a36a:	681b      	ldr	r3, [r3, #0]
 801a36c:	697a      	ldr	r2, [r7, #20]
 801a36e:	fb02 f303 	mul.w	r3, r2, r3
 801a372:	693a      	ldr	r2, [r7, #16]
 801a374:	18d1      	adds	r1, r2, r3
 801a376:	2300      	movs	r3, #0
 801a378:	683a      	ldr	r2, [r7, #0]
 801a37a:	68f8      	ldr	r0, [r7, #12]
 801a37c:	f7ff fd74 	bl	8019e68 <parse_required_member>
 801a380:	4603      	mov	r3, r0
 801a382:	2b00      	cmp	r3, #0
 801a384:	d101      	bne.n	801a38a <parse_repeated_member+0x52>
				   allocator, FALSE))
	{
		return FALSE;
 801a386:	2300      	movs	r3, #0
 801a388:	e005      	b.n	801a396 <parse_repeated_member+0x5e>
	}
	*p_n += 1;
 801a38a:	69bb      	ldr	r3, [r7, #24]
 801a38c:	681b      	ldr	r3, [r3, #0]
 801a38e:	1c5a      	adds	r2, r3, #1
 801a390:	69bb      	ldr	r3, [r7, #24]
 801a392:	601a      	str	r2, [r3, #0]
	return TRUE;
 801a394:	2301      	movs	r3, #1
}
 801a396:	4618      	mov	r0, r3
 801a398:	3720      	adds	r7, #32
 801a39a:	46bd      	mov	sp, r7
 801a39c:	bd80      	pop	{r7, pc}

0801a39e <scan_varint>:

static unsigned
scan_varint(unsigned len, const uint8_t *data)
{
 801a39e:	b480      	push	{r7}
 801a3a0:	b085      	sub	sp, #20
 801a3a2:	af00      	add	r7, sp, #0
 801a3a4:	6078      	str	r0, [r7, #4]
 801a3a6:	6039      	str	r1, [r7, #0]
	unsigned i;
	if (len > 10)
 801a3a8:	687b      	ldr	r3, [r7, #4]
 801a3aa:	2b0a      	cmp	r3, #10
 801a3ac:	d901      	bls.n	801a3b2 <scan_varint+0x14>
		len = 10;
 801a3ae:	230a      	movs	r3, #10
 801a3b0:	607b      	str	r3, [r7, #4]
	for (i = 0; i < len; i++)
 801a3b2:	2300      	movs	r3, #0
 801a3b4:	60fb      	str	r3, [r7, #12]
 801a3b6:	e009      	b.n	801a3cc <scan_varint+0x2e>
		if ((data[i] & 0x80) == 0)
 801a3b8:	683a      	ldr	r2, [r7, #0]
 801a3ba:	68fb      	ldr	r3, [r7, #12]
 801a3bc:	4413      	add	r3, r2
 801a3be:	781b      	ldrb	r3, [r3, #0]
 801a3c0:	b25b      	sxtb	r3, r3
 801a3c2:	2b00      	cmp	r3, #0
 801a3c4:	da07      	bge.n	801a3d6 <scan_varint+0x38>
	for (i = 0; i < len; i++)
 801a3c6:	68fb      	ldr	r3, [r7, #12]
 801a3c8:	3301      	adds	r3, #1
 801a3ca:	60fb      	str	r3, [r7, #12]
 801a3cc:	68fa      	ldr	r2, [r7, #12]
 801a3ce:	687b      	ldr	r3, [r7, #4]
 801a3d0:	429a      	cmp	r2, r3
 801a3d2:	d3f1      	bcc.n	801a3b8 <scan_varint+0x1a>
 801a3d4:	e000      	b.n	801a3d8 <scan_varint+0x3a>
			break;
 801a3d6:	bf00      	nop
	if (i == len)
 801a3d8:	68fa      	ldr	r2, [r7, #12]
 801a3da:	687b      	ldr	r3, [r7, #4]
 801a3dc:	429a      	cmp	r2, r3
 801a3de:	d101      	bne.n	801a3e4 <scan_varint+0x46>
		return 0;
 801a3e0:	2300      	movs	r3, #0
 801a3e2:	e001      	b.n	801a3e8 <scan_varint+0x4a>
	return i + 1;
 801a3e4:	68fb      	ldr	r3, [r7, #12]
 801a3e6:	3301      	adds	r3, #1
}
 801a3e8:	4618      	mov	r0, r3
 801a3ea:	3714      	adds	r7, #20
 801a3ec:	46bd      	mov	sp, r7
 801a3ee:	f85d 7b04 	ldr.w	r7, [sp], #4
 801a3f2:	4770      	bx	lr

0801a3f4 <parse_packed_repeated_member>:

static protobuf_c_boolean
parse_packed_repeated_member(ScannedMember *scanned_member,
			     void *member,
			     ProtobufCMessage *message)
{
 801a3f4:	b5b0      	push	{r4, r5, r7, lr}
 801a3f6:	b092      	sub	sp, #72	; 0x48
 801a3f8:	af00      	add	r7, sp, #0
 801a3fa:	60f8      	str	r0, [r7, #12]
 801a3fc:	60b9      	str	r1, [r7, #8]
 801a3fe:	607a      	str	r2, [r7, #4]
	const ProtobufCFieldDescriptor *field = scanned_member->field;
 801a400:	68fb      	ldr	r3, [r7, #12]
 801a402:	689b      	ldr	r3, [r3, #8]
 801a404:	637b      	str	r3, [r7, #52]	; 0x34
	size_t *p_n = STRUCT_MEMBER_PTR(size_t, message, field->quantifier_offset);
 801a406:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 801a408:	68db      	ldr	r3, [r3, #12]
 801a40a:	687a      	ldr	r2, [r7, #4]
 801a40c:	4413      	add	r3, r2
 801a40e:	633b      	str	r3, [r7, #48]	; 0x30
	size_t siz = sizeof_elt_in_repeated_array(field->type);
 801a410:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 801a412:	7a5b      	ldrb	r3, [r3, #9]
 801a414:	4618      	mov	r0, r3
 801a416:	f7fe fd35 	bl	8018e84 <sizeof_elt_in_repeated_array>
 801a41a:	62f8      	str	r0, [r7, #44]	; 0x2c
	void *array = *(char **) member + siz * (*p_n);
 801a41c:	68bb      	ldr	r3, [r7, #8]
 801a41e:	681a      	ldr	r2, [r3, #0]
 801a420:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801a422:	681b      	ldr	r3, [r3, #0]
 801a424:	6af9      	ldr	r1, [r7, #44]	; 0x2c
 801a426:	fb01 f303 	mul.w	r3, r1, r3
 801a42a:	4413      	add	r3, r2
 801a42c:	62bb      	str	r3, [r7, #40]	; 0x28
	const uint8_t *at = scanned_member->data + scanned_member->length_prefix_len;
 801a42e:	68fb      	ldr	r3, [r7, #12]
 801a430:	691b      	ldr	r3, [r3, #16]
 801a432:	68fa      	ldr	r2, [r7, #12]
 801a434:	7952      	ldrb	r2, [r2, #5]
 801a436:	4413      	add	r3, r2
 801a438:	647b      	str	r3, [r7, #68]	; 0x44
	size_t rem = scanned_member->len - scanned_member->length_prefix_len;
 801a43a:	68fb      	ldr	r3, [r7, #12]
 801a43c:	68db      	ldr	r3, [r3, #12]
 801a43e:	68fa      	ldr	r2, [r7, #12]
 801a440:	7952      	ldrb	r2, [r2, #5]
 801a442:	1a9b      	subs	r3, r3, r2
 801a444:	643b      	str	r3, [r7, #64]	; 0x40
	size_t count = 0;
 801a446:	2300      	movs	r3, #0
 801a448:	63fb      	str	r3, [r7, #60]	; 0x3c
	unsigned i;

	switch (field->type) {
 801a44a:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 801a44c:	7a5b      	ldrb	r3, [r3, #9]
 801a44e:	2b0d      	cmp	r3, #13
 801a450:	f200 810a 	bhi.w	801a668 <parse_packed_repeated_member+0x274>
 801a454:	a201      	add	r2, pc, #4	; (adr r2, 801a45c <parse_packed_repeated_member+0x68>)
 801a456:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 801a45a:	bf00      	nop
 801a45c:	0801a4f3 	.word	0x0801a4f3
 801a460:	0801a53f 	.word	0x0801a53f
 801a464:	0801a495 	.word	0x0801a495
 801a468:	0801a623 	.word	0x0801a623
 801a46c:	0801a5d7 	.word	0x0801a5d7
 801a470:	0801a4a5 	.word	0x0801a4a5
 801a474:	0801a583 	.word	0x0801a583
 801a478:	0801a495 	.word	0x0801a495
 801a47c:	0801a623 	.word	0x0801a623
 801a480:	0801a4a5 	.word	0x0801a4a5
 801a484:	0801a495 	.word	0x0801a495
 801a488:	0801a4a5 	.word	0x0801a4a5
 801a48c:	0801a62b 	.word	0x0801a62b
 801a490:	0801a4f3 	.word	0x0801a4f3
	case PROTOBUF_C_TYPE_SFIXED32:
	case PROTOBUF_C_TYPE_FIXED32:
	case PROTOBUF_C_TYPE_FLOAT:
		count = (scanned_member->len - scanned_member->length_prefix_len) / 4;
 801a494:	68fb      	ldr	r3, [r7, #12]
 801a496:	68db      	ldr	r3, [r3, #12]
 801a498:	68fa      	ldr	r2, [r7, #12]
 801a49a:	7952      	ldrb	r2, [r2, #5]
 801a49c:	1a9b      	subs	r3, r3, r2
 801a49e:	089b      	lsrs	r3, r3, #2
 801a4a0:	63fb      	str	r3, [r7, #60]	; 0x3c
#if !defined(WORDS_BIGENDIAN)
		goto no_unpacking_needed;
 801a4a2:	e0f0      	b.n	801a686 <parse_packed_repeated_member+0x292>
		break;
#endif
	case PROTOBUF_C_TYPE_SFIXED64:
	case PROTOBUF_C_TYPE_FIXED64:
	case PROTOBUF_C_TYPE_DOUBLE:
		count = (scanned_member->len - scanned_member->length_prefix_len) / 8;
 801a4a4:	68fb      	ldr	r3, [r7, #12]
 801a4a6:	68db      	ldr	r3, [r3, #12]
 801a4a8:	68fa      	ldr	r2, [r7, #12]
 801a4aa:	7952      	ldrb	r2, [r2, #5]
 801a4ac:	1a9b      	subs	r3, r3, r2
 801a4ae:	08db      	lsrs	r3, r3, #3
 801a4b0:	63fb      	str	r3, [r7, #60]	; 0x3c
#if !defined(WORDS_BIGENDIAN)
		goto no_unpacking_needed;
 801a4b2:	e0e8      	b.n	801a686 <parse_packed_repeated_member+0x292>
		break;
#endif
	case PROTOBUF_C_TYPE_ENUM:
	case PROTOBUF_C_TYPE_INT32:
		while (rem > 0) {
			unsigned s = scan_varint(rem, at);
 801a4b4:	6c79      	ldr	r1, [r7, #68]	; 0x44
 801a4b6:	6c38      	ldr	r0, [r7, #64]	; 0x40
 801a4b8:	f7ff ff71 	bl	801a39e <scan_varint>
 801a4bc:	6178      	str	r0, [r7, #20]
			if (s == 0) {
 801a4be:	697b      	ldr	r3, [r7, #20]
 801a4c0:	2b00      	cmp	r3, #0
 801a4c2:	d101      	bne.n	801a4c8 <parse_packed_repeated_member+0xd4>
				PROTOBUF_C_UNPACK_ERROR("bad packed-repeated int32 value");
				return FALSE;
 801a4c4:	2300      	movs	r3, #0
 801a4c6:	e0ee      	b.n	801a6a6 <parse_packed_repeated_member+0x2b2>
			}
			((int32_t *) array)[count++] = parse_int32(s, at);
 801a4c8:	6c79      	ldr	r1, [r7, #68]	; 0x44
 801a4ca:	6978      	ldr	r0, [r7, #20]
 801a4cc:	f7ff fb6d 	bl	8019baa <parse_int32>
 801a4d0:	4601      	mov	r1, r0
 801a4d2:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 801a4d4:	1c5a      	adds	r2, r3, #1
 801a4d6:	63fa      	str	r2, [r7, #60]	; 0x3c
 801a4d8:	009b      	lsls	r3, r3, #2
 801a4da:	6aba      	ldr	r2, [r7, #40]	; 0x28
 801a4dc:	4413      	add	r3, r2
 801a4de:	460a      	mov	r2, r1
 801a4e0:	601a      	str	r2, [r3, #0]
			at += s;
 801a4e2:	6c7a      	ldr	r2, [r7, #68]	; 0x44
 801a4e4:	697b      	ldr	r3, [r7, #20]
 801a4e6:	4413      	add	r3, r2
 801a4e8:	647b      	str	r3, [r7, #68]	; 0x44
			rem -= s;
 801a4ea:	6c3a      	ldr	r2, [r7, #64]	; 0x40
 801a4ec:	697b      	ldr	r3, [r7, #20]
 801a4ee:	1ad3      	subs	r3, r2, r3
 801a4f0:	643b      	str	r3, [r7, #64]	; 0x40
		while (rem > 0) {
 801a4f2:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 801a4f4:	2b00      	cmp	r3, #0
 801a4f6:	d1dd      	bne.n	801a4b4 <parse_packed_repeated_member+0xc0>
		}
		break;
 801a4f8:	e0bd      	b.n	801a676 <parse_packed_repeated_member+0x282>
	case PROTOBUF_C_TYPE_SINT32:
		while (rem > 0) {
			unsigned s = scan_varint(rem, at);
 801a4fa:	6c79      	ldr	r1, [r7, #68]	; 0x44
 801a4fc:	6c38      	ldr	r0, [r7, #64]	; 0x40
 801a4fe:	f7ff ff4e 	bl	801a39e <scan_varint>
 801a502:	61b8      	str	r0, [r7, #24]
			if (s == 0) {
 801a504:	69bb      	ldr	r3, [r7, #24]
 801a506:	2b00      	cmp	r3, #0
 801a508:	d101      	bne.n	801a50e <parse_packed_repeated_member+0x11a>
				PROTOBUF_C_UNPACK_ERROR("bad packed-repeated sint32 value");
				return FALSE;
 801a50a:	2300      	movs	r3, #0
 801a50c:	e0cb      	b.n	801a6a6 <parse_packed_repeated_member+0x2b2>
			}
			((int32_t *) array)[count++] = unzigzag32(parse_uint32(s, at));
 801a50e:	6c79      	ldr	r1, [r7, #68]	; 0x44
 801a510:	69b8      	ldr	r0, [r7, #24]
 801a512:	f7ff fb0b 	bl	8019b2c <parse_uint32>
 801a516:	4601      	mov	r1, r0
 801a518:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 801a51a:	1c5a      	adds	r2, r3, #1
 801a51c:	63fa      	str	r2, [r7, #60]	; 0x3c
 801a51e:	009b      	lsls	r3, r3, #2
 801a520:	6aba      	ldr	r2, [r7, #40]	; 0x28
 801a522:	18d4      	adds	r4, r2, r3
 801a524:	4608      	mov	r0, r1
 801a526:	f7ff fb4e 	bl	8019bc6 <unzigzag32>
 801a52a:	4603      	mov	r3, r0
 801a52c:	6023      	str	r3, [r4, #0]
			at += s;
 801a52e:	6c7a      	ldr	r2, [r7, #68]	; 0x44
 801a530:	69bb      	ldr	r3, [r7, #24]
 801a532:	4413      	add	r3, r2
 801a534:	647b      	str	r3, [r7, #68]	; 0x44
			rem -= s;
 801a536:	6c3a      	ldr	r2, [r7, #64]	; 0x40
 801a538:	69bb      	ldr	r3, [r7, #24]
 801a53a:	1ad3      	subs	r3, r2, r3
 801a53c:	643b      	str	r3, [r7, #64]	; 0x40
		while (rem > 0) {
 801a53e:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 801a540:	2b00      	cmp	r3, #0
 801a542:	d1da      	bne.n	801a4fa <parse_packed_repeated_member+0x106>
		}
		break;
 801a544:	e097      	b.n	801a676 <parse_packed_repeated_member+0x282>
	case PROTOBUF_C_TYPE_UINT32:
		while (rem > 0) {
			unsigned s = scan_varint(rem, at);
 801a546:	6c79      	ldr	r1, [r7, #68]	; 0x44
 801a548:	6c38      	ldr	r0, [r7, #64]	; 0x40
 801a54a:	f7ff ff28 	bl	801a39e <scan_varint>
 801a54e:	6278      	str	r0, [r7, #36]	; 0x24
			if (s == 0) {
 801a550:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801a552:	2b00      	cmp	r3, #0
 801a554:	d101      	bne.n	801a55a <parse_packed_repeated_member+0x166>
				PROTOBUF_C_UNPACK_ERROR("bad packed-repeated enum or uint32 value");
				return FALSE;
 801a556:	2300      	movs	r3, #0
 801a558:	e0a5      	b.n	801a6a6 <parse_packed_repeated_member+0x2b2>
			}
			((uint32_t *) array)[count++] = parse_uint32(s, at);
 801a55a:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 801a55c:	1c5a      	adds	r2, r3, #1
 801a55e:	63fa      	str	r2, [r7, #60]	; 0x3c
 801a560:	009b      	lsls	r3, r3, #2
 801a562:	6aba      	ldr	r2, [r7, #40]	; 0x28
 801a564:	18d4      	adds	r4, r2, r3
 801a566:	6c79      	ldr	r1, [r7, #68]	; 0x44
 801a568:	6a78      	ldr	r0, [r7, #36]	; 0x24
 801a56a:	f7ff fadf 	bl	8019b2c <parse_uint32>
 801a56e:	4603      	mov	r3, r0
 801a570:	6023      	str	r3, [r4, #0]
			at += s;
 801a572:	6c7a      	ldr	r2, [r7, #68]	; 0x44
 801a574:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801a576:	4413      	add	r3, r2
 801a578:	647b      	str	r3, [r7, #68]	; 0x44
			rem -= s;
 801a57a:	6c3a      	ldr	r2, [r7, #64]	; 0x40
 801a57c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801a57e:	1ad3      	subs	r3, r2, r3
 801a580:	643b      	str	r3, [r7, #64]	; 0x40
		while (rem > 0) {
 801a582:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 801a584:	2b00      	cmp	r3, #0
 801a586:	d1de      	bne.n	801a546 <parse_packed_repeated_member+0x152>
		}
		break;
 801a588:	e075      	b.n	801a676 <parse_packed_repeated_member+0x282>

	case PROTOBUF_C_TYPE_SINT64:
		while (rem > 0) {
			unsigned s = scan_varint(rem, at);
 801a58a:	6c79      	ldr	r1, [r7, #68]	; 0x44
 801a58c:	6c38      	ldr	r0, [r7, #64]	; 0x40
 801a58e:	f7ff ff06 	bl	801a39e <scan_varint>
 801a592:	6238      	str	r0, [r7, #32]
			if (s == 0) {
 801a594:	6a3b      	ldr	r3, [r7, #32]
 801a596:	2b00      	cmp	r3, #0
 801a598:	d101      	bne.n	801a59e <parse_packed_repeated_member+0x1aa>
				PROTOBUF_C_UNPACK_ERROR("bad packed-repeated sint64 value");
				return FALSE;
 801a59a:	2300      	movs	r3, #0
 801a59c:	e083      	b.n	801a6a6 <parse_packed_repeated_member+0x2b2>
			}
			((int64_t *) array)[count++] = unzigzag64(parse_uint64(s, at));
 801a59e:	6c79      	ldr	r1, [r7, #68]	; 0x44
 801a5a0:	6a38      	ldr	r0, [r7, #32]
 801a5a2:	f7ff fb2f 	bl	8019c04 <parse_uint64>
 801a5a6:	4602      	mov	r2, r0
 801a5a8:	460b      	mov	r3, r1
 801a5aa:	6bf9      	ldr	r1, [r7, #60]	; 0x3c
 801a5ac:	1c48      	adds	r0, r1, #1
 801a5ae:	63f8      	str	r0, [r7, #60]	; 0x3c
 801a5b0:	00c9      	lsls	r1, r1, #3
 801a5b2:	6ab8      	ldr	r0, [r7, #40]	; 0x28
 801a5b4:	1844      	adds	r4, r0, r1
 801a5b6:	4610      	mov	r0, r2
 801a5b8:	4619      	mov	r1, r3
 801a5ba:	f7ff fbfb 	bl	8019db4 <unzigzag64>
 801a5be:	4602      	mov	r2, r0
 801a5c0:	460b      	mov	r3, r1
 801a5c2:	e9c4 2300 	strd	r2, r3, [r4]
			at += s;
 801a5c6:	6c7a      	ldr	r2, [r7, #68]	; 0x44
 801a5c8:	6a3b      	ldr	r3, [r7, #32]
 801a5ca:	4413      	add	r3, r2
 801a5cc:	647b      	str	r3, [r7, #68]	; 0x44
			rem -= s;
 801a5ce:	6c3a      	ldr	r2, [r7, #64]	; 0x40
 801a5d0:	6a3b      	ldr	r3, [r7, #32]
 801a5d2:	1ad3      	subs	r3, r2, r3
 801a5d4:	643b      	str	r3, [r7, #64]	; 0x40
		while (rem > 0) {
 801a5d6:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 801a5d8:	2b00      	cmp	r3, #0
 801a5da:	d1d6      	bne.n	801a58a <parse_packed_repeated_member+0x196>
		}
		break;
 801a5dc:	e04b      	b.n	801a676 <parse_packed_repeated_member+0x282>
	case PROTOBUF_C_TYPE_INT64:
	case PROTOBUF_C_TYPE_UINT64:
		while (rem > 0) {
			unsigned s = scan_varint(rem, at);
 801a5de:	6c79      	ldr	r1, [r7, #68]	; 0x44
 801a5e0:	6c38      	ldr	r0, [r7, #64]	; 0x40
 801a5e2:	f7ff fedc 	bl	801a39e <scan_varint>
 801a5e6:	61f8      	str	r0, [r7, #28]
			if (s == 0) {
 801a5e8:	69fb      	ldr	r3, [r7, #28]
 801a5ea:	2b00      	cmp	r3, #0
 801a5ec:	d101      	bne.n	801a5f2 <parse_packed_repeated_member+0x1fe>
				PROTOBUF_C_UNPACK_ERROR("bad packed-repeated int64/uint64 value");
				return FALSE;
 801a5ee:	2300      	movs	r3, #0
 801a5f0:	e059      	b.n	801a6a6 <parse_packed_repeated_member+0x2b2>
			}
			((int64_t *) array)[count++] = parse_uint64(s, at);
 801a5f2:	6c79      	ldr	r1, [r7, #68]	; 0x44
 801a5f4:	69f8      	ldr	r0, [r7, #28]
 801a5f6:	f7ff fb05 	bl	8019c04 <parse_uint64>
 801a5fa:	4604      	mov	r4, r0
 801a5fc:	460d      	mov	r5, r1
 801a5fe:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 801a600:	1c5a      	adds	r2, r3, #1
 801a602:	63fa      	str	r2, [r7, #60]	; 0x3c
 801a604:	00db      	lsls	r3, r3, #3
 801a606:	6aba      	ldr	r2, [r7, #40]	; 0x28
 801a608:	18d1      	adds	r1, r2, r3
 801a60a:	4622      	mov	r2, r4
 801a60c:	462b      	mov	r3, r5
 801a60e:	e9c1 2300 	strd	r2, r3, [r1]
			at += s;
 801a612:	6c7a      	ldr	r2, [r7, #68]	; 0x44
 801a614:	69fb      	ldr	r3, [r7, #28]
 801a616:	4413      	add	r3, r2
 801a618:	647b      	str	r3, [r7, #68]	; 0x44
			rem -= s;
 801a61a:	6c3a      	ldr	r2, [r7, #64]	; 0x40
 801a61c:	69fb      	ldr	r3, [r7, #28]
 801a61e:	1ad3      	subs	r3, r2, r3
 801a620:	643b      	str	r3, [r7, #64]	; 0x40
		while (rem > 0) {
 801a622:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 801a624:	2b00      	cmp	r3, #0
 801a626:	d1da      	bne.n	801a5de <parse_packed_repeated_member+0x1ea>
		}
		break;
 801a628:	e025      	b.n	801a676 <parse_packed_repeated_member+0x282>
	case PROTOBUF_C_TYPE_BOOL:
		count = rem;
 801a62a:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 801a62c:	63fb      	str	r3, [r7, #60]	; 0x3c
		for (i = 0; i < count; i++) {
 801a62e:	2300      	movs	r3, #0
 801a630:	63bb      	str	r3, [r7, #56]	; 0x38
 801a632:	e014      	b.n	801a65e <parse_packed_repeated_member+0x26a>
			if (at[i] > 1) {
 801a634:	6c7a      	ldr	r2, [r7, #68]	; 0x44
 801a636:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 801a638:	4413      	add	r3, r2
 801a63a:	781b      	ldrb	r3, [r3, #0]
 801a63c:	2b01      	cmp	r3, #1
 801a63e:	d901      	bls.n	801a644 <parse_packed_repeated_member+0x250>
				PROTOBUF_C_UNPACK_ERROR("bad packed-repeated boolean value");
				return FALSE;
 801a640:	2300      	movs	r3, #0
 801a642:	e030      	b.n	801a6a6 <parse_packed_repeated_member+0x2b2>
			}
			((protobuf_c_boolean *) array)[i] = at[i];
 801a644:	6c7a      	ldr	r2, [r7, #68]	; 0x44
 801a646:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 801a648:	4413      	add	r3, r2
 801a64a:	7819      	ldrb	r1, [r3, #0]
 801a64c:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 801a64e:	009b      	lsls	r3, r3, #2
 801a650:	6aba      	ldr	r2, [r7, #40]	; 0x28
 801a652:	4413      	add	r3, r2
 801a654:	460a      	mov	r2, r1
 801a656:	601a      	str	r2, [r3, #0]
		for (i = 0; i < count; i++) {
 801a658:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 801a65a:	3301      	adds	r3, #1
 801a65c:	63bb      	str	r3, [r7, #56]	; 0x38
 801a65e:	6bba      	ldr	r2, [r7, #56]	; 0x38
 801a660:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 801a662:	429a      	cmp	r2, r3
 801a664:	d3e6      	bcc.n	801a634 <parse_packed_repeated_member+0x240>
		}
		break;
 801a666:	e006      	b.n	801a676 <parse_packed_repeated_member+0x282>
	default:
		PROTOBUF_C__ASSERT_NOT_REACHED();
 801a668:	4b11      	ldr	r3, [pc, #68]	; (801a6b0 <parse_packed_repeated_member+0x2bc>)
 801a66a:	4a12      	ldr	r2, [pc, #72]	; (801a6b4 <parse_packed_repeated_member+0x2c0>)
 801a66c:	f640 3125 	movw	r1, #2853	; 0xb25
 801a670:	4811      	ldr	r0, [pc, #68]	; (801a6b8 <parse_packed_repeated_member+0x2c4>)
 801a672:	f005 f871 	bl	801f758 <__assert_func>
	}
	*p_n += count;
 801a676:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801a678:	681a      	ldr	r2, [r3, #0]
 801a67a:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 801a67c:	441a      	add	r2, r3
 801a67e:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801a680:	601a      	str	r2, [r3, #0]
	return TRUE;
 801a682:	2301      	movs	r3, #1
 801a684:	e00f      	b.n	801a6a6 <parse_packed_repeated_member+0x2b2>

#if !defined(WORDS_BIGENDIAN)
no_unpacking_needed:
	memcpy(array, at, count * siz);
 801a686:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 801a688:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 801a68a:	fb02 f303 	mul.w	r3, r2, r3
 801a68e:	461a      	mov	r2, r3
 801a690:	6c79      	ldr	r1, [r7, #68]	; 0x44
 801a692:	6ab8      	ldr	r0, [r7, #40]	; 0x28
 801a694:	f005 f8ca 	bl	801f82c <memcpy>
	*p_n += count;
 801a698:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801a69a:	681a      	ldr	r2, [r3, #0]
 801a69c:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 801a69e:	441a      	add	r2, r3
 801a6a0:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801a6a2:	601a      	str	r2, [r3, #0]
	return TRUE;
 801a6a4:	2301      	movs	r3, #1
#endif
}
 801a6a6:	4618      	mov	r0, r3
 801a6a8:	3748      	adds	r7, #72	; 0x48
 801a6aa:	46bd      	mov	sp, r7
 801a6ac:	bdb0      	pop	{r4, r5, r7, pc}
 801a6ae:	bf00      	nop
 801a6b0:	080242e4 	.word	0x080242e4
 801a6b4:	08028740 	.word	0x08028740
 801a6b8:	080242e8 	.word	0x080242e8

0801a6bc <is_packable_type>:

static protobuf_c_boolean
is_packable_type(ProtobufCType type)
{
 801a6bc:	b480      	push	{r7}
 801a6be:	b083      	sub	sp, #12
 801a6c0:	af00      	add	r7, sp, #0
 801a6c2:	4603      	mov	r3, r0
 801a6c4:	71fb      	strb	r3, [r7, #7]
	return
		type != PROTOBUF_C_TYPE_STRING &&
		type != PROTOBUF_C_TYPE_BYTES &&
 801a6c6:	79fb      	ldrb	r3, [r7, #7]
 801a6c8:	2b0e      	cmp	r3, #14
 801a6ca:	d007      	beq.n	801a6dc <is_packable_type+0x20>
		type != PROTOBUF_C_TYPE_STRING &&
 801a6cc:	79fb      	ldrb	r3, [r7, #7]
 801a6ce:	2b0f      	cmp	r3, #15
 801a6d0:	d004      	beq.n	801a6dc <is_packable_type+0x20>
		type != PROTOBUF_C_TYPE_BYTES &&
 801a6d2:	79fb      	ldrb	r3, [r7, #7]
 801a6d4:	2b10      	cmp	r3, #16
 801a6d6:	d001      	beq.n	801a6dc <is_packable_type+0x20>
 801a6d8:	2301      	movs	r3, #1
 801a6da:	e000      	b.n	801a6de <is_packable_type+0x22>
 801a6dc:	2300      	movs	r3, #0
		type != PROTOBUF_C_TYPE_MESSAGE;
}
 801a6de:	4618      	mov	r0, r3
 801a6e0:	370c      	adds	r7, #12
 801a6e2:	46bd      	mov	sp, r7
 801a6e4:	f85d 7b04 	ldr.w	r7, [sp], #4
 801a6e8:	4770      	bx	lr
	...

0801a6ec <parse_member>:

static protobuf_c_boolean
parse_member(ScannedMember *scanned_member,
	     ProtobufCMessage *message,
	     ProtobufCAllocator *allocator)
{
 801a6ec:	b580      	push	{r7, lr}
 801a6ee:	b088      	sub	sp, #32
 801a6f0:	af00      	add	r7, sp, #0
 801a6f2:	60f8      	str	r0, [r7, #12]
 801a6f4:	60b9      	str	r1, [r7, #8]
 801a6f6:	607a      	str	r2, [r7, #4]
	const ProtobufCFieldDescriptor *field = scanned_member->field;
 801a6f8:	68fb      	ldr	r3, [r7, #12]
 801a6fa:	689b      	ldr	r3, [r3, #8]
 801a6fc:	61fb      	str	r3, [r7, #28]
	void *member;

	if (field == NULL) {
 801a6fe:	69fb      	ldr	r3, [r7, #28]
 801a700:	2b00      	cmp	r3, #0
 801a702:	d12f      	bne.n	801a764 <parse_member+0x78>
		ProtobufCMessageUnknownField *ufield =
			message->unknown_fields +
 801a704:	68bb      	ldr	r3, [r7, #8]
 801a706:	689a      	ldr	r2, [r3, #8]
			(message->n_unknown_fields++);
 801a708:	68bb      	ldr	r3, [r7, #8]
 801a70a:	685b      	ldr	r3, [r3, #4]
 801a70c:	1c58      	adds	r0, r3, #1
 801a70e:	68b9      	ldr	r1, [r7, #8]
 801a710:	6048      	str	r0, [r1, #4]
			message->unknown_fields +
 801a712:	011b      	lsls	r3, r3, #4
		ProtobufCMessageUnknownField *ufield =
 801a714:	4413      	add	r3, r2
 801a716:	617b      	str	r3, [r7, #20]
		ufield->tag = scanned_member->tag;
 801a718:	68fb      	ldr	r3, [r7, #12]
 801a71a:	681a      	ldr	r2, [r3, #0]
 801a71c:	697b      	ldr	r3, [r7, #20]
 801a71e:	601a      	str	r2, [r3, #0]
		ufield->wire_type = scanned_member->wire_type;
 801a720:	68fb      	ldr	r3, [r7, #12]
 801a722:	791a      	ldrb	r2, [r3, #4]
 801a724:	697b      	ldr	r3, [r7, #20]
 801a726:	711a      	strb	r2, [r3, #4]
		ufield->len = scanned_member->len;
 801a728:	68fb      	ldr	r3, [r7, #12]
 801a72a:	68da      	ldr	r2, [r3, #12]
 801a72c:	697b      	ldr	r3, [r7, #20]
 801a72e:	609a      	str	r2, [r3, #8]
		ufield->data = do_alloc(allocator, scanned_member->len);
 801a730:	68fb      	ldr	r3, [r7, #12]
 801a732:	68db      	ldr	r3, [r3, #12]
 801a734:	4619      	mov	r1, r3
 801a736:	6878      	ldr	r0, [r7, #4]
 801a738:	f7fd fb3f 	bl	8017dba <do_alloc>
 801a73c:	4602      	mov	r2, r0
 801a73e:	697b      	ldr	r3, [r7, #20]
 801a740:	60da      	str	r2, [r3, #12]
		if (ufield->data == NULL)
 801a742:	697b      	ldr	r3, [r7, #20]
 801a744:	68db      	ldr	r3, [r3, #12]
 801a746:	2b00      	cmp	r3, #0
 801a748:	d101      	bne.n	801a74e <parse_member+0x62>
			return FALSE;
 801a74a:	2300      	movs	r3, #0
 801a74c:	e064      	b.n	801a818 <parse_member+0x12c>
		memcpy(ufield->data, scanned_member->data, ufield->len);
 801a74e:	697b      	ldr	r3, [r7, #20]
 801a750:	68d8      	ldr	r0, [r3, #12]
 801a752:	68fb      	ldr	r3, [r7, #12]
 801a754:	6919      	ldr	r1, [r3, #16]
 801a756:	697b      	ldr	r3, [r7, #20]
 801a758:	689b      	ldr	r3, [r3, #8]
 801a75a:	461a      	mov	r2, r3
 801a75c:	f005 f866 	bl	801f82c <memcpy>
		return TRUE;
 801a760:	2301      	movs	r3, #1
 801a762:	e059      	b.n	801a818 <parse_member+0x12c>
	}
	member = (char *) message + field->offset;
 801a764:	69fb      	ldr	r3, [r7, #28]
 801a766:	691b      	ldr	r3, [r3, #16]
 801a768:	68ba      	ldr	r2, [r7, #8]
 801a76a:	4413      	add	r3, r2
 801a76c:	61bb      	str	r3, [r7, #24]
	switch (field->label) {
 801a76e:	69fb      	ldr	r3, [r7, #28]
 801a770:	7a1b      	ldrb	r3, [r3, #8]
 801a772:	2b03      	cmp	r3, #3
 801a774:	d849      	bhi.n	801a80a <parse_member+0x11e>
 801a776:	a201      	add	r2, pc, #4	; (adr r2, 801a77c <parse_member+0x90>)
 801a778:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 801a77c:	0801a78d 	.word	0x0801a78d
 801a780:	0801a79d 	.word	0x0801a79d
 801a784:	0801a7c9 	.word	0x0801a7c9
 801a788:	0801a79d 	.word	0x0801a79d
	case PROTOBUF_C_LABEL_REQUIRED:
		return parse_required_member(scanned_member, member,
 801a78c:	2301      	movs	r3, #1
 801a78e:	687a      	ldr	r2, [r7, #4]
 801a790:	69b9      	ldr	r1, [r7, #24]
 801a792:	68f8      	ldr	r0, [r7, #12]
 801a794:	f7ff fb68 	bl	8019e68 <parse_required_member>
 801a798:	4603      	mov	r3, r0
 801a79a:	e03d      	b.n	801a818 <parse_member+0x12c>
					     allocator, TRUE);
	case PROTOBUF_C_LABEL_OPTIONAL:
	case PROTOBUF_C_LABEL_NONE:
		if (0 != (field->flags & PROTOBUF_C_FIELD_FLAG_ONEOF)) {
 801a79c:	69fb      	ldr	r3, [r7, #28]
 801a79e:	69db      	ldr	r3, [r3, #28]
 801a7a0:	f003 0304 	and.w	r3, r3, #4
 801a7a4:	2b00      	cmp	r3, #0
 801a7a6:	d007      	beq.n	801a7b8 <parse_member+0xcc>
			return parse_oneof_member(scanned_member, member,
 801a7a8:	687b      	ldr	r3, [r7, #4]
 801a7aa:	68ba      	ldr	r2, [r7, #8]
 801a7ac:	69b9      	ldr	r1, [r7, #24]
 801a7ae:	68f8      	ldr	r0, [r7, #12]
 801a7b0:	f7ff fd00 	bl	801a1b4 <parse_oneof_member>
 801a7b4:	4603      	mov	r3, r0
 801a7b6:	e02f      	b.n	801a818 <parse_member+0x12c>
						  message, allocator);
		} else {
			return parse_optional_member(scanned_member, member,
 801a7b8:	687b      	ldr	r3, [r7, #4]
 801a7ba:	68ba      	ldr	r2, [r7, #8]
 801a7bc:	69b9      	ldr	r1, [r7, #24]
 801a7be:	68f8      	ldr	r0, [r7, #12]
 801a7c0:	f7ff fd97 	bl	801a2f2 <parse_optional_member>
 801a7c4:	4603      	mov	r3, r0
 801a7c6:	e027      	b.n	801a818 <parse_member+0x12c>
						     message, allocator);
		}
	case PROTOBUF_C_LABEL_REPEATED:
		if (scanned_member->wire_type ==
 801a7c8:	68fb      	ldr	r3, [r7, #12]
 801a7ca:	791b      	ldrb	r3, [r3, #4]
 801a7cc:	2b02      	cmp	r3, #2
 801a7ce:	d114      	bne.n	801a7fa <parse_member+0x10e>
		    PROTOBUF_C_WIRE_TYPE_LENGTH_PREFIXED &&
		    (0 != (field->flags & PROTOBUF_C_FIELD_FLAG_PACKED) ||
 801a7d0:	69fb      	ldr	r3, [r7, #28]
 801a7d2:	69db      	ldr	r3, [r3, #28]
 801a7d4:	f003 0301 	and.w	r3, r3, #1
		    PROTOBUF_C_WIRE_TYPE_LENGTH_PREFIXED &&
 801a7d8:	2b00      	cmp	r3, #0
 801a7da:	d107      	bne.n	801a7ec <parse_member+0x100>
		     is_packable_type(field->type)))
 801a7dc:	69fb      	ldr	r3, [r7, #28]
 801a7de:	7a5b      	ldrb	r3, [r3, #9]
 801a7e0:	4618      	mov	r0, r3
 801a7e2:	f7ff ff6b 	bl	801a6bc <is_packable_type>
 801a7e6:	4603      	mov	r3, r0
		    (0 != (field->flags & PROTOBUF_C_FIELD_FLAG_PACKED) ||
 801a7e8:	2b00      	cmp	r3, #0
 801a7ea:	d006      	beq.n	801a7fa <parse_member+0x10e>
		{
			return parse_packed_repeated_member(scanned_member,
 801a7ec:	68ba      	ldr	r2, [r7, #8]
 801a7ee:	69b9      	ldr	r1, [r7, #24]
 801a7f0:	68f8      	ldr	r0, [r7, #12]
 801a7f2:	f7ff fdff 	bl	801a3f4 <parse_packed_repeated_member>
 801a7f6:	4603      	mov	r3, r0
 801a7f8:	e00e      	b.n	801a818 <parse_member+0x12c>
							    member, message);
		} else {
			return parse_repeated_member(scanned_member,
 801a7fa:	687b      	ldr	r3, [r7, #4]
 801a7fc:	68ba      	ldr	r2, [r7, #8]
 801a7fe:	69b9      	ldr	r1, [r7, #24]
 801a800:	68f8      	ldr	r0, [r7, #12]
 801a802:	f7ff fd99 	bl	801a338 <parse_repeated_member>
 801a806:	4603      	mov	r3, r0
 801a808:	e006      	b.n	801a818 <parse_member+0x12c>
						     member, message,
						     allocator);
		}
	}
	PROTOBUF_C__ASSERT_NOT_REACHED();
 801a80a:	4b05      	ldr	r3, [pc, #20]	; (801a820 <parse_member+0x134>)
 801a80c:	4a05      	ldr	r2, [pc, #20]	; (801a824 <parse_member+0x138>)
 801a80e:	f640 316c 	movw	r1, #2924	; 0xb6c
 801a812:	4805      	ldr	r0, [pc, #20]	; (801a828 <parse_member+0x13c>)
 801a814:	f004 ffa0 	bl	801f758 <__assert_func>
	return 0;
}
 801a818:	4618      	mov	r0, r3
 801a81a:	3720      	adds	r7, #32
 801a81c:	46bd      	mov	sp, r7
 801a81e:	bd80      	pop	{r7, pc}
 801a820:	080242e4 	.word	0x080242e4
 801a824:	08028760 	.word	0x08028760
 801a828:	080242e8 	.word	0x080242e8

0801a82c <message_init_generic>:
 * descriptors dynamically).
 */
static void
message_init_generic(const ProtobufCMessageDescriptor *desc,
		     ProtobufCMessage *message)
{
 801a82c:	b580      	push	{r7, lr}
 801a82e:	b086      	sub	sp, #24
 801a830:	af00      	add	r7, sp, #0
 801a832:	6078      	str	r0, [r7, #4]
 801a834:	6039      	str	r1, [r7, #0]
	unsigned i;

	memset(message, 0, desc->sizeof_message);
 801a836:	687b      	ldr	r3, [r7, #4]
 801a838:	695b      	ldr	r3, [r3, #20]
 801a83a:	461a      	mov	r2, r3
 801a83c:	2100      	movs	r1, #0
 801a83e:	6838      	ldr	r0, [r7, #0]
 801a840:	f005 f81c 	bl	801f87c <memset>
	message->descriptor = desc;
 801a844:	683b      	ldr	r3, [r7, #0]
 801a846:	687a      	ldr	r2, [r7, #4]
 801a848:	601a      	str	r2, [r3, #0]
	for (i = 0; i < desc->n_fields; i++) {
 801a84a:	2300      	movs	r3, #0
 801a84c:	617b      	str	r3, [r7, #20]
 801a84e:	e077      	b.n	801a940 <message_init_generic+0x114>
		if (desc->fields[i].default_value != NULL &&
 801a850:	687b      	ldr	r3, [r7, #4]
 801a852:	69da      	ldr	r2, [r3, #28]
 801a854:	697b      	ldr	r3, [r7, #20]
 801a856:	212c      	movs	r1, #44	; 0x2c
 801a858:	fb01 f303 	mul.w	r3, r1, r3
 801a85c:	4413      	add	r3, r2
 801a85e:	699b      	ldr	r3, [r3, #24]
 801a860:	2b00      	cmp	r3, #0
 801a862:	d069      	beq.n	801a938 <message_init_generic+0x10c>
		    desc->fields[i].label != PROTOBUF_C_LABEL_REPEATED)
 801a864:	687b      	ldr	r3, [r7, #4]
 801a866:	69da      	ldr	r2, [r3, #28]
 801a868:	697b      	ldr	r3, [r7, #20]
 801a86a:	212c      	movs	r1, #44	; 0x2c
 801a86c:	fb01 f303 	mul.w	r3, r1, r3
 801a870:	4413      	add	r3, r2
 801a872:	7a1b      	ldrb	r3, [r3, #8]
		if (desc->fields[i].default_value != NULL &&
 801a874:	2b02      	cmp	r3, #2
 801a876:	d05f      	beq.n	801a938 <message_init_generic+0x10c>
		{
			void *field =
				STRUCT_MEMBER_P(message, desc->fields[i].offset);
 801a878:	687b      	ldr	r3, [r7, #4]
 801a87a:	69da      	ldr	r2, [r3, #28]
 801a87c:	697b      	ldr	r3, [r7, #20]
 801a87e:	212c      	movs	r1, #44	; 0x2c
 801a880:	fb01 f303 	mul.w	r3, r1, r3
 801a884:	4413      	add	r3, r2
 801a886:	691b      	ldr	r3, [r3, #16]
			void *field =
 801a888:	683a      	ldr	r2, [r7, #0]
 801a88a:	4413      	add	r3, r2
 801a88c:	613b      	str	r3, [r7, #16]
			const void *dv = desc->fields[i].default_value;
 801a88e:	687b      	ldr	r3, [r7, #4]
 801a890:	69da      	ldr	r2, [r3, #28]
 801a892:	697b      	ldr	r3, [r7, #20]
 801a894:	212c      	movs	r1, #44	; 0x2c
 801a896:	fb01 f303 	mul.w	r3, r1, r3
 801a89a:	4413      	add	r3, r2
 801a89c:	699b      	ldr	r3, [r3, #24]
 801a89e:	60fb      	str	r3, [r7, #12]

			switch (desc->fields[i].type) {
 801a8a0:	687b      	ldr	r3, [r7, #4]
 801a8a2:	69da      	ldr	r2, [r3, #28]
 801a8a4:	697b      	ldr	r3, [r7, #20]
 801a8a6:	212c      	movs	r1, #44	; 0x2c
 801a8a8:	fb01 f303 	mul.w	r3, r1, r3
 801a8ac:	4413      	add	r3, r2
 801a8ae:	7a5b      	ldrb	r3, [r3, #9]
 801a8b0:	2b10      	cmp	r3, #16
 801a8b2:	d842      	bhi.n	801a93a <message_init_generic+0x10e>
 801a8b4:	a201      	add	r2, pc, #4	; (adr r2, 801a8bc <message_init_generic+0x90>)
 801a8b6:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 801a8ba:	bf00      	nop
 801a8bc:	0801a901 	.word	0x0801a901
 801a8c0:	0801a901 	.word	0x0801a901
 801a8c4:	0801a901 	.word	0x0801a901
 801a8c8:	0801a90d 	.word	0x0801a90d
 801a8cc:	0801a90d 	.word	0x0801a90d
 801a8d0:	0801a90d 	.word	0x0801a90d
 801a8d4:	0801a901 	.word	0x0801a901
 801a8d8:	0801a901 	.word	0x0801a901
 801a8dc:	0801a90d 	.word	0x0801a90d
 801a8e0:	0801a90d 	.word	0x0801a90d
 801a8e4:	0801a901 	.word	0x0801a901
 801a8e8:	0801a90d 	.word	0x0801a90d
 801a8ec:	0801a919 	.word	0x0801a919
 801a8f0:	0801a901 	.word	0x0801a901
 801a8f4:	0801a931 	.word	0x0801a931
 801a8f8:	0801a925 	.word	0x0801a925
 801a8fc:	0801a931 	.word	0x0801a931
 801a900:	68fb      	ldr	r3, [r7, #12]
 801a902:	681b      	ldr	r3, [r3, #0]
 801a904:	461a      	mov	r2, r3
			case PROTOBUF_C_TYPE_SFIXED32:
			case PROTOBUF_C_TYPE_UINT32:
			case PROTOBUF_C_TYPE_FIXED32:
			case PROTOBUF_C_TYPE_FLOAT:
			case PROTOBUF_C_TYPE_ENUM:
				memcpy(field, dv, 4);
 801a906:	693b      	ldr	r3, [r7, #16]
 801a908:	601a      	str	r2, [r3, #0]
				break;
 801a90a:	e016      	b.n	801a93a <message_init_generic+0x10e>
			case PROTOBUF_C_TYPE_SINT64:
			case PROTOBUF_C_TYPE_SFIXED64:
			case PROTOBUF_C_TYPE_UINT64:
			case PROTOBUF_C_TYPE_FIXED64:
			case PROTOBUF_C_TYPE_DOUBLE:
				memcpy(field, dv, 8);
 801a90c:	2208      	movs	r2, #8
 801a90e:	68f9      	ldr	r1, [r7, #12]
 801a910:	6938      	ldr	r0, [r7, #16]
 801a912:	f004 ff8b 	bl	801f82c <memcpy>
				break;
 801a916:	e010      	b.n	801a93a <message_init_generic+0x10e>
 801a918:	68fb      	ldr	r3, [r7, #12]
 801a91a:	681b      	ldr	r3, [r3, #0]
 801a91c:	461a      	mov	r2, r3
			case PROTOBUF_C_TYPE_BOOL:
				memcpy(field, dv, sizeof(protobuf_c_boolean));
 801a91e:	693b      	ldr	r3, [r7, #16]
 801a920:	601a      	str	r2, [r3, #0]
				break;
 801a922:	e00a      	b.n	801a93a <message_init_generic+0x10e>
			case PROTOBUF_C_TYPE_BYTES:
				memcpy(field, dv, sizeof(ProtobufCBinaryData));
 801a924:	2208      	movs	r2, #8
 801a926:	68f9      	ldr	r1, [r7, #12]
 801a928:	6938      	ldr	r0, [r7, #16]
 801a92a:	f004 ff7f 	bl	801f82c <memcpy>
				break;
 801a92e:	e004      	b.n	801a93a <message_init_generic+0x10e>
			case PROTOBUF_C_TYPE_MESSAGE:
				/*
				 * The next line essentially implements a cast
				 * from const, which is totally unavoidable.
				 */
				*(const void **) field = dv;
 801a930:	693b      	ldr	r3, [r7, #16]
 801a932:	68fa      	ldr	r2, [r7, #12]
 801a934:	601a      	str	r2, [r3, #0]
				break;
 801a936:	e000      	b.n	801a93a <message_init_generic+0x10e>
			}
		}
 801a938:	bf00      	nop
	for (i = 0; i < desc->n_fields; i++) {
 801a93a:	697b      	ldr	r3, [r7, #20]
 801a93c:	3301      	adds	r3, #1
 801a93e:	617b      	str	r3, [r7, #20]
 801a940:	687b      	ldr	r3, [r7, #4]
 801a942:	699b      	ldr	r3, [r3, #24]
 801a944:	697a      	ldr	r2, [r7, #20]
 801a946:	429a      	cmp	r2, r3
 801a948:	d382      	bcc.n	801a850 <message_init_generic+0x24>
	}
}
 801a94a:	bf00      	nop
 801a94c:	bf00      	nop
 801a94e:	3718      	adds	r7, #24
 801a950:	46bd      	mov	sp, r7
 801a952:	bd80      	pop	{r7, pc}

0801a954 <protobuf_c_message_unpack>:

ProtobufCMessage *
protobuf_c_message_unpack(const ProtobufCMessageDescriptor *desc,
			  ProtobufCAllocator *allocator,
			  size_t len, const uint8_t *data)
{
 801a954:	b5b0      	push	{r4, r5, r7, lr}
 801a956:	f5ad 7d14 	sub.w	sp, sp, #592	; 0x250
 801a95a:	af00      	add	r7, sp, #0
 801a95c:	f507 7414 	add.w	r4, r7, #592	; 0x250
 801a960:	f5a4 7411 	sub.w	r4, r4, #580	; 0x244
 801a964:	6020      	str	r0, [r4, #0]
 801a966:	f507 7014 	add.w	r0, r7, #592	; 0x250
 801a96a:	f5a0 7012 	sub.w	r0, r0, #584	; 0x248
 801a96e:	6001      	str	r1, [r0, #0]
 801a970:	f507 7114 	add.w	r1, r7, #592	; 0x250
 801a974:	f5a1 7113 	sub.w	r1, r1, #588	; 0x24c
 801a978:	600a      	str	r2, [r1, #0]
 801a97a:	f507 7214 	add.w	r2, r7, #592	; 0x250
 801a97e:	f5a2 7214 	sub.w	r2, r2, #592	; 0x250
 801a982:	6013      	str	r3, [r2, #0]
	ProtobufCMessage *rv;
	size_t rem = len;
 801a984:	f507 7314 	add.w	r3, r7, #592	; 0x250
 801a988:	f5a3 7313 	sub.w	r3, r3, #588	; 0x24c
 801a98c:	681b      	ldr	r3, [r3, #0]
 801a98e:	f8c7 324c 	str.w	r3, [r7, #588]	; 0x24c
	const uint8_t *at = data;
 801a992:	f507 7314 	add.w	r3, r7, #592	; 0x250
 801a996:	f5a3 7314 	sub.w	r3, r3, #592	; 0x250
 801a99a:	681b      	ldr	r3, [r3, #0]
 801a99c:	f8c7 3248 	str.w	r3, [r7, #584]	; 0x248
	const ProtobufCFieldDescriptor *last_field = desc->fields + 0;
 801a9a0:	f507 7314 	add.w	r3, r7, #592	; 0x250
 801a9a4:	f5a3 7311 	sub.w	r3, r3, #580	; 0x244
 801a9a8:	681b      	ldr	r3, [r3, #0]
 801a9aa:	69db      	ldr	r3, [r3, #28]
 801a9ac:	f8c7 3244 	str.w	r3, [r7, #580]	; 0x244
	 * The first slab (scanned_member_slabs[0] is just a pointer to
	 * first_member_slab), above. All subsequent slabs will be allocated
	 * using the allocator.
	 */
	ScannedMember *scanned_member_slabs[MAX_SCANNED_MEMBER_SLAB + 1];
	unsigned which_slab = 0; /* the slab we are currently populating */
 801a9b0:	2300      	movs	r3, #0
 801a9b2:	f8c7 3240 	str.w	r3, [r7, #576]	; 0x240
	unsigned in_slab_index = 0; /* number of members in the slab */
 801a9b6:	2300      	movs	r3, #0
 801a9b8:	f8c7 323c 	str.w	r3, [r7, #572]	; 0x23c
	size_t n_unknown = 0;
 801a9bc:	2300      	movs	r3, #0
 801a9be:	f8c7 3238 	str.w	r3, [r7, #568]	; 0x238
	unsigned f;
	unsigned j;
	unsigned i_slab;
	unsigned last_field_index = 0;
 801a9c2:	2300      	movs	r3, #0
 801a9c4:	f8c7 3228 	str.w	r3, [r7, #552]	; 0x228
	unsigned required_fields_bitmap_len;
	unsigned char required_fields_bitmap_stack[16];
	unsigned char *required_fields_bitmap = required_fields_bitmap_stack;
 801a9c8:	f107 0334 	add.w	r3, r7, #52	; 0x34
 801a9cc:	f8c7 3224 	str.w	r3, [r7, #548]	; 0x224
	protobuf_c_boolean required_fields_bitmap_alloced = FALSE;
 801a9d0:	2300      	movs	r3, #0
 801a9d2:	f8c7 3220 	str.w	r3, [r7, #544]	; 0x220

	ASSERT_IS_MESSAGE_DESCRIPTOR(desc);
 801a9d6:	f507 7314 	add.w	r3, r7, #592	; 0x250
 801a9da:	f5a3 7311 	sub.w	r3, r3, #580	; 0x244
 801a9de:	681b      	ldr	r3, [r3, #0]
 801a9e0:	681b      	ldr	r3, [r3, #0]
 801a9e2:	4ad1      	ldr	r2, [pc, #836]	; (801ad28 <protobuf_c_message_unpack+0x3d4>)
 801a9e4:	4293      	cmp	r3, r2
 801a9e6:	d006      	beq.n	801a9f6 <protobuf_c_message_unpack+0xa2>
 801a9e8:	4bd0      	ldr	r3, [pc, #832]	; (801ad2c <protobuf_c_message_unpack+0x3d8>)
 801a9ea:	4ad1      	ldr	r2, [pc, #836]	; (801ad30 <protobuf_c_message_unpack+0x3dc>)
 801a9ec:	f640 31e9 	movw	r1, #3049	; 0xbe9
 801a9f0:	48d0      	ldr	r0, [pc, #832]	; (801ad34 <protobuf_c_message_unpack+0x3e0>)
 801a9f2:	f004 feb1 	bl	801f758 <__assert_func>

	if (allocator == NULL)
 801a9f6:	f507 7314 	add.w	r3, r7, #592	; 0x250
 801a9fa:	f5a3 7312 	sub.w	r3, r3, #584	; 0x248
 801a9fe:	681b      	ldr	r3, [r3, #0]
 801aa00:	2b00      	cmp	r3, #0
 801aa02:	d105      	bne.n	801aa10 <protobuf_c_message_unpack+0xbc>
		allocator = &protobuf_c__allocator;
 801aa04:	f507 7314 	add.w	r3, r7, #592	; 0x250
 801aa08:	f5a3 7312 	sub.w	r3, r3, #584	; 0x248
 801aa0c:	4aca      	ldr	r2, [pc, #808]	; (801ad38 <protobuf_c_message_unpack+0x3e4>)
 801aa0e:	601a      	str	r2, [r3, #0]

	rv = do_alloc(allocator, desc->sizeof_message);
 801aa10:	f507 7314 	add.w	r3, r7, #592	; 0x250
 801aa14:	f5a3 7311 	sub.w	r3, r3, #580	; 0x244
 801aa18:	681b      	ldr	r3, [r3, #0]
 801aa1a:	695a      	ldr	r2, [r3, #20]
 801aa1c:	f507 7314 	add.w	r3, r7, #592	; 0x250
 801aa20:	f5a3 7312 	sub.w	r3, r3, #584	; 0x248
 801aa24:	4611      	mov	r1, r2
 801aa26:	6818      	ldr	r0, [r3, #0]
 801aa28:	f7fd f9c7 	bl	8017dba <do_alloc>
 801aa2c:	f8c7 0214 	str.w	r0, [r7, #532]	; 0x214
	if (!rv)
 801aa30:	f8d7 3214 	ldr.w	r3, [r7, #532]	; 0x214
 801aa34:	2b00      	cmp	r3, #0
 801aa36:	d102      	bne.n	801aa3e <protobuf_c_message_unpack+0xea>
		return (NULL);
 801aa38:	2300      	movs	r3, #0
 801aa3a:	f000 bc6e 	b.w	801b31a <protobuf_c_message_unpack+0x9c6>
	scanned_member_slabs[0] = first_member_slab;
 801aa3e:	f507 7314 	add.w	r3, r7, #592	; 0x250
 801aa42:	f5a3 7303 	sub.w	r3, r3, #524	; 0x20c
 801aa46:	f107 02a0 	add.w	r2, r7, #160	; 0xa0
 801aa4a:	601a      	str	r2, [r3, #0]

	required_fields_bitmap_len = (desc->n_fields + 7) / 8;
 801aa4c:	f507 7314 	add.w	r3, r7, #592	; 0x250
 801aa50:	f5a3 7311 	sub.w	r3, r3, #580	; 0x244
 801aa54:	681b      	ldr	r3, [r3, #0]
 801aa56:	699b      	ldr	r3, [r3, #24]
 801aa58:	3307      	adds	r3, #7
 801aa5a:	08db      	lsrs	r3, r3, #3
 801aa5c:	f8c7 3210 	str.w	r3, [r7, #528]	; 0x210
	if (required_fields_bitmap_len > sizeof(required_fields_bitmap_stack)) {
 801aa60:	f8d7 3210 	ldr.w	r3, [r7, #528]	; 0x210
 801aa64:	2b10      	cmp	r3, #16
 801aa66:	d91d      	bls.n	801aaa4 <protobuf_c_message_unpack+0x150>
		required_fields_bitmap = do_alloc(allocator, required_fields_bitmap_len);
 801aa68:	f507 7314 	add.w	r3, r7, #592	; 0x250
 801aa6c:	f5a3 7312 	sub.w	r3, r3, #584	; 0x248
 801aa70:	f8d7 1210 	ldr.w	r1, [r7, #528]	; 0x210
 801aa74:	6818      	ldr	r0, [r3, #0]
 801aa76:	f7fd f9a0 	bl	8017dba <do_alloc>
 801aa7a:	f8c7 0224 	str.w	r0, [r7, #548]	; 0x224
		if (!required_fields_bitmap) {
 801aa7e:	f8d7 3224 	ldr.w	r3, [r7, #548]	; 0x224
 801aa82:	2b00      	cmp	r3, #0
 801aa84:	d10b      	bne.n	801aa9e <protobuf_c_message_unpack+0x14a>
			do_free(allocator, rv);
 801aa86:	f507 7314 	add.w	r3, r7, #592	; 0x250
 801aa8a:	f5a3 7312 	sub.w	r3, r3, #584	; 0x248
 801aa8e:	f8d7 1214 	ldr.w	r1, [r7, #532]	; 0x214
 801aa92:	6818      	ldr	r0, [r3, #0]
 801aa94:	f7fd f9a2 	bl	8017ddc <do_free>
			return (NULL);
 801aa98:	2300      	movs	r3, #0
 801aa9a:	f000 bc3e 	b.w	801b31a <protobuf_c_message_unpack+0x9c6>
		}
		required_fields_bitmap_alloced = TRUE;
 801aa9e:	2301      	movs	r3, #1
 801aaa0:	f8c7 3220 	str.w	r3, [r7, #544]	; 0x220
	}
	memset(required_fields_bitmap, 0, required_fields_bitmap_len);
 801aaa4:	f8d7 2210 	ldr.w	r2, [r7, #528]	; 0x210
 801aaa8:	2100      	movs	r1, #0
 801aaaa:	f8d7 0224 	ldr.w	r0, [r7, #548]	; 0x224
 801aaae:	f004 fee5 	bl	801f87c <memset>
	 * Generated code always defines "message_init". However, we provide a
	 * fallback for (1) users of old protobuf-c generated-code that do not
	 * provide the function, and (2) descriptors constructed from some other
	 * source (most likely, direct construction from the .proto file).
	 */
	if (desc->message_init != NULL)
 801aab2:	f507 7314 	add.w	r3, r7, #592	; 0x250
 801aab6:	f5a3 7311 	sub.w	r3, r3, #580	; 0x244
 801aaba:	681b      	ldr	r3, [r3, #0]
 801aabc:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 801aabe:	2b00      	cmp	r3, #0
 801aac0:	d009      	beq.n	801aad6 <protobuf_c_message_unpack+0x182>
		protobuf_c_message_init(desc, rv);
 801aac2:	f507 7314 	add.w	r3, r7, #592	; 0x250
 801aac6:	f5a3 7311 	sub.w	r3, r3, #580	; 0x244
 801aaca:	f8d7 1214 	ldr.w	r1, [r7, #532]	; 0x214
 801aace:	6818      	ldr	r0, [r3, #0]
 801aad0:	f000 fdb0 	bl	801b634 <protobuf_c_message_init>
 801aad4:	e214      	b.n	801af00 <protobuf_c_message_unpack+0x5ac>
	else
		message_init_generic(desc, rv);
 801aad6:	f507 7314 	add.w	r3, r7, #592	; 0x250
 801aada:	f5a3 7311 	sub.w	r3, r3, #580	; 0x244
 801aade:	f8d7 1214 	ldr.w	r1, [r7, #532]	; 0x214
 801aae2:	6818      	ldr	r0, [r3, #0]
 801aae4:	f7ff fea2 	bl	801a82c <message_init_generic>

	while (rem > 0) {
 801aae8:	e20a      	b.n	801af00 <protobuf_c_message_unpack+0x5ac>
		uint32_t tag;
		ProtobufCWireType wire_type;
		size_t used = parse_tag_and_wiretype(rem, at, &tag, &wire_type);
 801aaea:	f107 032f 	add.w	r3, r7, #47	; 0x2f
 801aaee:	f107 0230 	add.w	r2, r7, #48	; 0x30
 801aaf2:	f8d7 1248 	ldr.w	r1, [r7, #584]	; 0x248
 801aaf6:	f8d7 024c 	ldr.w	r0, [r7, #588]	; 0x24c
 801aafa:	f7fe fd3a 	bl	8019572 <parse_tag_and_wiretype>
 801aafe:	f8c7 01f0 	str.w	r0, [r7, #496]	; 0x1f0
		const ProtobufCFieldDescriptor *field;
		ScannedMember tmp;

		if (used == 0) {
 801ab02:	f8d7 31f0 	ldr.w	r3, [r7, #496]	; 0x1f0
 801ab06:	2b00      	cmp	r3, #0
 801ab08:	f000 83bd 	beq.w	801b286 <protobuf_c_message_unpack+0x932>
		}
		/*
		 * \todo Consider optimizing for field[1].id == tag, if field[1]
		 * exists!
		 */
		if (last_field == NULL || last_field->id != tag) {
 801ab0c:	f8d7 3244 	ldr.w	r3, [r7, #580]	; 0x244
 801ab10:	2b00      	cmp	r3, #0
 801ab12:	d009      	beq.n	801ab28 <protobuf_c_message_unpack+0x1d4>
 801ab14:	f8d7 3244 	ldr.w	r3, [r7, #580]	; 0x244
 801ab18:	685a      	ldr	r2, [r3, #4]
 801ab1a:	f507 7314 	add.w	r3, r7, #592	; 0x250
 801ab1e:	f5a3 7308 	sub.w	r3, r3, #544	; 0x220
 801ab22:	681b      	ldr	r3, [r3, #0]
 801ab24:	429a      	cmp	r2, r3
 801ab26:	d039      	beq.n	801ab9c <protobuf_c_message_unpack+0x248>
			/* lookup field */
			int field_index =
			    int_range_lookup(desc->n_field_ranges,
 801ab28:	f507 7314 	add.w	r3, r7, #592	; 0x250
 801ab2c:	f5a3 7311 	sub.w	r3, r3, #580	; 0x244
 801ab30:	681b      	ldr	r3, [r3, #0]
 801ab32:	6a58      	ldr	r0, [r3, #36]	; 0x24
 801ab34:	f507 7314 	add.w	r3, r7, #592	; 0x250
 801ab38:	f5a3 7311 	sub.w	r3, r3, #580	; 0x244
 801ab3c:	681b      	ldr	r3, [r3, #0]
 801ab3e:	6a99      	ldr	r1, [r3, #40]	; 0x28
 801ab40:	f507 7314 	add.w	r3, r7, #592	; 0x250
 801ab44:	f5a3 7308 	sub.w	r3, r3, #544	; 0x220
 801ab48:	681b      	ldr	r3, [r3, #0]
 801ab4a:	461a      	mov	r2, r3
 801ab4c:	f7fe fc82 	bl	8019454 <int_range_lookup>
 801ab50:	f8c7 01ec 	str.w	r0, [r7, #492]	; 0x1ec
					     desc->field_ranges,
					     tag);
			if (field_index < 0) {
 801ab54:	f8d7 31ec 	ldr.w	r3, [r7, #492]	; 0x1ec
 801ab58:	2b00      	cmp	r3, #0
 801ab5a:	da08      	bge.n	801ab6e <protobuf_c_message_unpack+0x21a>
				field = NULL;
 801ab5c:	2300      	movs	r3, #0
 801ab5e:	f8c7 321c 	str.w	r3, [r7, #540]	; 0x21c
				n_unknown++;
 801ab62:	f8d7 3238 	ldr.w	r3, [r7, #568]	; 0x238
 801ab66:	3301      	adds	r3, #1
 801ab68:	f8c7 3238 	str.w	r3, [r7, #568]	; 0x238
		if (last_field == NULL || last_field->id != tag) {
 801ab6c:	e01a      	b.n	801aba4 <protobuf_c_message_unpack+0x250>
			} else {
				field = desc->fields + field_index;
 801ab6e:	f507 7314 	add.w	r3, r7, #592	; 0x250
 801ab72:	f5a3 7311 	sub.w	r3, r3, #580	; 0x244
 801ab76:	681b      	ldr	r3, [r3, #0]
 801ab78:	69da      	ldr	r2, [r3, #28]
 801ab7a:	f8d7 31ec 	ldr.w	r3, [r7, #492]	; 0x1ec
 801ab7e:	212c      	movs	r1, #44	; 0x2c
 801ab80:	fb01 f303 	mul.w	r3, r1, r3
 801ab84:	4413      	add	r3, r2
 801ab86:	f8c7 321c 	str.w	r3, [r7, #540]	; 0x21c
				last_field = field;
 801ab8a:	f8d7 321c 	ldr.w	r3, [r7, #540]	; 0x21c
 801ab8e:	f8c7 3244 	str.w	r3, [r7, #580]	; 0x244
				last_field_index = field_index;
 801ab92:	f8d7 31ec 	ldr.w	r3, [r7, #492]	; 0x1ec
 801ab96:	f8c7 3228 	str.w	r3, [r7, #552]	; 0x228
		if (last_field == NULL || last_field->id != tag) {
 801ab9a:	e003      	b.n	801aba4 <protobuf_c_message_unpack+0x250>
			}
		} else {
			field = last_field;
 801ab9c:	f8d7 3244 	ldr.w	r3, [r7, #580]	; 0x244
 801aba0:	f8c7 321c 	str.w	r3, [r7, #540]	; 0x21c
		}

		if (field != NULL && field->label == PROTOBUF_C_LABEL_REQUIRED)
 801aba4:	f8d7 321c 	ldr.w	r3, [r7, #540]	; 0x21c
 801aba8:	2b00      	cmp	r3, #0
 801abaa:	d019      	beq.n	801abe0 <protobuf_c_message_unpack+0x28c>
 801abac:	f8d7 321c 	ldr.w	r3, [r7, #540]	; 0x21c
 801abb0:	7a1b      	ldrb	r3, [r3, #8]
 801abb2:	2b00      	cmp	r3, #0
 801abb4:	d114      	bne.n	801abe0 <protobuf_c_message_unpack+0x28c>
			REQUIRED_FIELD_BITMAP_SET(last_field_index);
 801abb6:	f8d7 3228 	ldr.w	r3, [r7, #552]	; 0x228
 801abba:	08db      	lsrs	r3, r3, #3
 801abbc:	f8d7 2224 	ldr.w	r2, [r7, #548]	; 0x224
 801abc0:	441a      	add	r2, r3
 801abc2:	7811      	ldrb	r1, [r2, #0]
 801abc4:	f8d7 2228 	ldr.w	r2, [r7, #552]	; 0x228
 801abc8:	f002 0207 	and.w	r2, r2, #7
 801abcc:	2001      	movs	r0, #1
 801abce:	fa00 f202 	lsl.w	r2, r0, r2
 801abd2:	b2d2      	uxtb	r2, r2
 801abd4:	f8d7 0224 	ldr.w	r0, [r7, #548]	; 0x224
 801abd8:	4403      	add	r3, r0
 801abda:	430a      	orrs	r2, r1
 801abdc:	b2d2      	uxtb	r2, r2
 801abde:	701a      	strb	r2, [r3, #0]

		at += used;
 801abe0:	f8d7 2248 	ldr.w	r2, [r7, #584]	; 0x248
 801abe4:	f8d7 31f0 	ldr.w	r3, [r7, #496]	; 0x1f0
 801abe8:	4413      	add	r3, r2
 801abea:	f8c7 3248 	str.w	r3, [r7, #584]	; 0x248
		rem -= used;
 801abee:	f8d7 224c 	ldr.w	r2, [r7, #588]	; 0x24c
 801abf2:	f8d7 31f0 	ldr.w	r3, [r7, #496]	; 0x1f0
 801abf6:	1ad3      	subs	r3, r2, r3
 801abf8:	f8c7 324c 	str.w	r3, [r7, #588]	; 0x24c
		tmp.tag = tag;
 801abfc:	f507 7314 	add.w	r3, r7, #592	; 0x250
 801ac00:	f5a3 7308 	sub.w	r3, r3, #544	; 0x220
 801ac04:	681a      	ldr	r2, [r3, #0]
 801ac06:	f507 7314 	add.w	r3, r7, #592	; 0x250
 801ac0a:	f5a3 730e 	sub.w	r3, r3, #568	; 0x238
 801ac0e:	601a      	str	r2, [r3, #0]
		tmp.wire_type = wire_type;
 801ac10:	f507 7314 	add.w	r3, r7, #592	; 0x250
 801ac14:	f2a3 2321 	subw	r3, r3, #545	; 0x221
 801ac18:	781a      	ldrb	r2, [r3, #0]
 801ac1a:	f507 7314 	add.w	r3, r7, #592	; 0x250
 801ac1e:	f5a3 730e 	sub.w	r3, r3, #568	; 0x238
 801ac22:	711a      	strb	r2, [r3, #4]
		tmp.field = field;
 801ac24:	f507 7314 	add.w	r3, r7, #592	; 0x250
 801ac28:	f5a3 730e 	sub.w	r3, r3, #568	; 0x238
 801ac2c:	f8d7 221c 	ldr.w	r2, [r7, #540]	; 0x21c
 801ac30:	609a      	str	r2, [r3, #8]
		tmp.data = at;
 801ac32:	f507 7314 	add.w	r3, r7, #592	; 0x250
 801ac36:	f5a3 730e 	sub.w	r3, r3, #568	; 0x238
 801ac3a:	f8d7 2248 	ldr.w	r2, [r7, #584]	; 0x248
 801ac3e:	611a      	str	r2, [r3, #16]
		tmp.length_prefix_len = 0;
 801ac40:	f507 7314 	add.w	r3, r7, #592	; 0x250
 801ac44:	f5a3 730e 	sub.w	r3, r3, #568	; 0x238
 801ac48:	2200      	movs	r2, #0
 801ac4a:	715a      	strb	r2, [r3, #5]

		switch (wire_type) {
 801ac4c:	f507 7314 	add.w	r3, r7, #592	; 0x250
 801ac50:	f2a3 2321 	subw	r3, r3, #545	; 0x221
 801ac54:	781b      	ldrb	r3, [r3, #0]
 801ac56:	2b05      	cmp	r3, #5
 801ac58:	f200 8317 	bhi.w	801b28a <protobuf_c_message_unpack+0x936>
 801ac5c:	a201      	add	r2, pc, #4	; (adr r2, 801ac64 <protobuf_c_message_unpack+0x310>)
 801ac5e:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 801ac62:	bf00      	nop
 801ac64:	0801ac7d 	.word	0x0801ac7d
 801ac68:	0801acdf 	.word	0x0801acdf
 801ac6c:	0801acf7 	.word	0x0801acf7
 801ac70:	0801b28b 	.word	0x0801b28b
 801ac74:	0801b28b 	.word	0x0801b28b
 801ac78:	0801ad55 	.word	0x0801ad55
		case PROTOBUF_C_WIRE_TYPE_VARINT: {
			unsigned max_len = rem < 10 ? rem : 10;
 801ac7c:	f8d7 324c 	ldr.w	r3, [r7, #588]	; 0x24c
 801ac80:	2b0a      	cmp	r3, #10
 801ac82:	bf28      	it	cs
 801ac84:	230a      	movcs	r3, #10
 801ac86:	f8c7 31e8 	str.w	r3, [r7, #488]	; 0x1e8
			unsigned i;

			for (i = 0; i < max_len; i++)
 801ac8a:	2300      	movs	r3, #0
 801ac8c:	f8c7 3218 	str.w	r3, [r7, #536]	; 0x218
 801ac90:	e00d      	b.n	801acae <protobuf_c_message_unpack+0x35a>
				if ((at[i] & 0x80) == 0)
 801ac92:	f8d7 2248 	ldr.w	r2, [r7, #584]	; 0x248
 801ac96:	f8d7 3218 	ldr.w	r3, [r7, #536]	; 0x218
 801ac9a:	4413      	add	r3, r2
 801ac9c:	781b      	ldrb	r3, [r3, #0]
 801ac9e:	b25b      	sxtb	r3, r3
 801aca0:	2b00      	cmp	r3, #0
 801aca2:	da0b      	bge.n	801acbc <protobuf_c_message_unpack+0x368>
			for (i = 0; i < max_len; i++)
 801aca4:	f8d7 3218 	ldr.w	r3, [r7, #536]	; 0x218
 801aca8:	3301      	adds	r3, #1
 801acaa:	f8c7 3218 	str.w	r3, [r7, #536]	; 0x218
 801acae:	f8d7 2218 	ldr.w	r2, [r7, #536]	; 0x218
 801acb2:	f8d7 31e8 	ldr.w	r3, [r7, #488]	; 0x1e8
 801acb6:	429a      	cmp	r2, r3
 801acb8:	d3eb      	bcc.n	801ac92 <protobuf_c_message_unpack+0x33e>
 801acba:	e000      	b.n	801acbe <protobuf_c_message_unpack+0x36a>
					break;
 801acbc:	bf00      	nop
			if (i == max_len) {
 801acbe:	f8d7 2218 	ldr.w	r2, [r7, #536]	; 0x218
 801acc2:	f8d7 31e8 	ldr.w	r3, [r7, #488]	; 0x1e8
 801acc6:	429a      	cmp	r2, r3
 801acc8:	f000 82e1 	beq.w	801b28e <protobuf_c_message_unpack+0x93a>
				PROTOBUF_C_UNPACK_ERROR("unterminated varint at offset %u",
							(unsigned) (at - data));
				goto error_cleanup_during_scan;
			}
			tmp.len = i + 1;
 801accc:	f8d7 3218 	ldr.w	r3, [r7, #536]	; 0x218
 801acd0:	1c5a      	adds	r2, r3, #1
 801acd2:	f507 7314 	add.w	r3, r7, #592	; 0x250
 801acd6:	f5a3 730e 	sub.w	r3, r3, #568	; 0x238
 801acda:	60da      	str	r2, [r3, #12]
			break;
 801acdc:	e046      	b.n	801ad6c <protobuf_c_message_unpack+0x418>
		}
		case PROTOBUF_C_WIRE_TYPE_64BIT:
			if (rem < 8) {
 801acde:	f8d7 324c 	ldr.w	r3, [r7, #588]	; 0x24c
 801ace2:	2b07      	cmp	r3, #7
 801ace4:	f240 82d5 	bls.w	801b292 <protobuf_c_message_unpack+0x93e>
				PROTOBUF_C_UNPACK_ERROR("too short after 64bit wiretype at offset %u",
							(unsigned) (at - data));
				goto error_cleanup_during_scan;
			}
			tmp.len = 8;
 801ace8:	f507 7314 	add.w	r3, r7, #592	; 0x250
 801acec:	f5a3 730e 	sub.w	r3, r3, #568	; 0x238
 801acf0:	2208      	movs	r2, #8
 801acf2:	60da      	str	r2, [r3, #12]
			break;
 801acf4:	e03a      	b.n	801ad6c <protobuf_c_message_unpack+0x418>
		case PROTOBUF_C_WIRE_TYPE_LENGTH_PREFIXED: {
			size_t pref_len;

			tmp.len = scan_length_prefixed_data(rem, at, &pref_len);
 801acf6:	f107 0314 	add.w	r3, r7, #20
 801acfa:	461a      	mov	r2, r3
 801acfc:	f8d7 1248 	ldr.w	r1, [r7, #584]	; 0x248
 801ad00:	f8d7 024c 	ldr.w	r0, [r7, #588]	; 0x24c
 801ad04:	f7fe fc9d 	bl	8019642 <scan_length_prefixed_data>
 801ad08:	4602      	mov	r2, r0
 801ad0a:	f507 7314 	add.w	r3, r7, #592	; 0x250
 801ad0e:	f5a3 730e 	sub.w	r3, r3, #568	; 0x238
 801ad12:	60da      	str	r2, [r3, #12]
			if (tmp.len == 0) {
 801ad14:	f507 7314 	add.w	r3, r7, #592	; 0x250
 801ad18:	f5a3 730e 	sub.w	r3, r3, #568	; 0x238
 801ad1c:	68db      	ldr	r3, [r3, #12]
 801ad1e:	2b00      	cmp	r3, #0
 801ad20:	d10c      	bne.n	801ad3c <protobuf_c_message_unpack+0x3e8>
				/* NOTE: scan_length_prefixed_data calls UNPACK_ERROR */
				goto error_cleanup_during_scan;
 801ad22:	bf00      	nop
			goto error_cleanup_during_scan;
 801ad24:	e2af      	b.n	801b286 <protobuf_c_message_unpack+0x932>
 801ad26:	bf00      	nop
 801ad28:	28aaeef9 	.word	0x28aaeef9
 801ad2c:	080243c8 	.word	0x080243c8
 801ad30:	08028770 	.word	0x08028770
 801ad34:	080242e8 	.word	0x080242e8
 801ad38:	24000468 	.word	0x24000468
			}
			tmp.length_prefix_len = pref_len;
 801ad3c:	f507 7314 	add.w	r3, r7, #592	; 0x250
 801ad40:	f5a3 730f 	sub.w	r3, r3, #572	; 0x23c
 801ad44:	681b      	ldr	r3, [r3, #0]
 801ad46:	b2da      	uxtb	r2, r3
 801ad48:	f507 7314 	add.w	r3, r7, #592	; 0x250
 801ad4c:	f5a3 730e 	sub.w	r3, r3, #568	; 0x238
 801ad50:	715a      	strb	r2, [r3, #5]
 801ad52:	e00b      	b.n	801ad6c <protobuf_c_message_unpack+0x418>
			break;
		}
		case PROTOBUF_C_WIRE_TYPE_32BIT:
			if (rem < 4) {
 801ad54:	f8d7 324c 	ldr.w	r3, [r7, #588]	; 0x24c
 801ad58:	2b03      	cmp	r3, #3
 801ad5a:	f240 829c 	bls.w	801b296 <protobuf_c_message_unpack+0x942>
				PROTOBUF_C_UNPACK_ERROR("too short after 32bit wiretype at offset %u",
					      (unsigned) (at - data));
				goto error_cleanup_during_scan;
			}
			tmp.len = 4;
 801ad5e:	f507 7314 	add.w	r3, r7, #592	; 0x250
 801ad62:	f5a3 730e 	sub.w	r3, r3, #568	; 0x238
 801ad66:	2204      	movs	r2, #4
 801ad68:	60da      	str	r2, [r3, #12]
			break;
 801ad6a:	bf00      	nop
						wire_type, (unsigned) (at - data));
			goto error_cleanup_during_scan;
		}

		if (in_slab_index == (1UL <<
			(which_slab + FIRST_SCANNED_MEMBER_SLAB_SIZE_LOG2)))
 801ad6c:	f8d7 3240 	ldr.w	r3, [r7, #576]	; 0x240
 801ad70:	3304      	adds	r3, #4
		if (in_slab_index == (1UL <<
 801ad72:	2201      	movs	r2, #1
 801ad74:	fa02 f303 	lsl.w	r3, r2, r3
 801ad78:	f8d7 223c 	ldr.w	r2, [r7, #572]	; 0x23c
 801ad7c:	429a      	cmp	r2, r3
 801ad7e:	d131      	bne.n	801ade4 <protobuf_c_message_unpack+0x490>
		{
			size_t size;

			in_slab_index = 0;
 801ad80:	2300      	movs	r3, #0
 801ad82:	f8c7 323c 	str.w	r3, [r7, #572]	; 0x23c
			if (which_slab == MAX_SCANNED_MEMBER_SLAB) {
 801ad86:	f8d7 3240 	ldr.w	r3, [r7, #576]	; 0x240
 801ad8a:	2b16      	cmp	r3, #22
 801ad8c:	f000 8285 	beq.w	801b29a <protobuf_c_message_unpack+0x946>
				PROTOBUF_C_UNPACK_ERROR("too many fields");
				goto error_cleanup_during_scan;
			}
			which_slab++;
 801ad90:	f8d7 3240 	ldr.w	r3, [r7, #576]	; 0x240
 801ad94:	3301      	adds	r3, #1
 801ad96:	f8c7 3240 	str.w	r3, [r7, #576]	; 0x240
			size = sizeof(ScannedMember)
				<< (which_slab + FIRST_SCANNED_MEMBER_SLAB_SIZE_LOG2);
 801ad9a:	f8d7 3240 	ldr.w	r3, [r7, #576]	; 0x240
 801ad9e:	3304      	adds	r3, #4
			size = sizeof(ScannedMember)
 801ada0:	2214      	movs	r2, #20
 801ada2:	fa02 f303 	lsl.w	r3, r2, r3
 801ada6:	f8c7 31e4 	str.w	r3, [r7, #484]	; 0x1e4
			scanned_member_slabs[which_slab] = do_alloc(allocator, size);
 801adaa:	f507 7314 	add.w	r3, r7, #592	; 0x250
 801adae:	f5a3 7312 	sub.w	r3, r3, #584	; 0x248
 801adb2:	f8d7 11e4 	ldr.w	r1, [r7, #484]	; 0x1e4
 801adb6:	6818      	ldr	r0, [r3, #0]
 801adb8:	f7fc ffff 	bl	8017dba <do_alloc>
 801adbc:	4601      	mov	r1, r0
 801adbe:	f507 7314 	add.w	r3, r7, #592	; 0x250
 801adc2:	f5a3 7303 	sub.w	r3, r3, #524	; 0x20c
 801adc6:	f8d7 2240 	ldr.w	r2, [r7, #576]	; 0x240
 801adca:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
			if (scanned_member_slabs[which_slab] == NULL)
 801adce:	f507 7314 	add.w	r3, r7, #592	; 0x250
 801add2:	f5a3 7303 	sub.w	r3, r3, #524	; 0x20c
 801add6:	f8d7 2240 	ldr.w	r2, [r7, #576]	; 0x240
 801adda:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 801adde:	2b00      	cmp	r3, #0
 801ade0:	f000 825d 	beq.w	801b29e <protobuf_c_message_unpack+0x94a>
				goto error_cleanup_during_scan;
		}
		scanned_member_slabs[which_slab][in_slab_index++] = tmp;
 801ade4:	f507 7314 	add.w	r3, r7, #592	; 0x250
 801ade8:	f5a3 7303 	sub.w	r3, r3, #524	; 0x20c
 801adec:	f8d7 2240 	ldr.w	r2, [r7, #576]	; 0x240
 801adf0:	f853 1022 	ldr.w	r1, [r3, r2, lsl #2]
 801adf4:	f8d7 223c 	ldr.w	r2, [r7, #572]	; 0x23c
 801adf8:	1c53      	adds	r3, r2, #1
 801adfa:	f8c7 323c 	str.w	r3, [r7, #572]	; 0x23c
 801adfe:	4613      	mov	r3, r2
 801ae00:	009b      	lsls	r3, r3, #2
 801ae02:	4413      	add	r3, r2
 801ae04:	009b      	lsls	r3, r3, #2
 801ae06:	18ca      	adds	r2, r1, r3
 801ae08:	f507 7314 	add.w	r3, r7, #592	; 0x250
 801ae0c:	f5a3 730e 	sub.w	r3, r3, #568	; 0x238
 801ae10:	4614      	mov	r4, r2
 801ae12:	461d      	mov	r5, r3
 801ae14:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 801ae16:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 801ae18:	682b      	ldr	r3, [r5, #0]
 801ae1a:	6023      	str	r3, [r4, #0]

		if (field != NULL && field->label == PROTOBUF_C_LABEL_REPEATED) {
 801ae1c:	f8d7 321c 	ldr.w	r3, [r7, #540]	; 0x21c
 801ae20:	2b00      	cmp	r3, #0
 801ae22:	d059      	beq.n	801aed8 <protobuf_c_message_unpack+0x584>
 801ae24:	f8d7 321c 	ldr.w	r3, [r7, #540]	; 0x21c
 801ae28:	7a1b      	ldrb	r3, [r3, #8]
 801ae2a:	2b02      	cmp	r3, #2
 801ae2c:	d154      	bne.n	801aed8 <protobuf_c_message_unpack+0x584>
			size_t *n = STRUCT_MEMBER_PTR(size_t, rv,
 801ae2e:	f8d7 321c 	ldr.w	r3, [r7, #540]	; 0x21c
 801ae32:	68db      	ldr	r3, [r3, #12]
 801ae34:	f8d7 2214 	ldr.w	r2, [r7, #532]	; 0x214
 801ae38:	4413      	add	r3, r2
 801ae3a:	f8c7 31e0 	str.w	r3, [r7, #480]	; 0x1e0
						      field->quantifier_offset);
			if (wire_type == PROTOBUF_C_WIRE_TYPE_LENGTH_PREFIXED &&
 801ae3e:	f507 7314 	add.w	r3, r7, #592	; 0x250
 801ae42:	f2a3 2321 	subw	r3, r3, #545	; 0x221
 801ae46:	781b      	ldrb	r3, [r3, #0]
 801ae48:	2b02      	cmp	r3, #2
 801ae4a:	d13e      	bne.n	801aeca <protobuf_c_message_unpack+0x576>
			    (0 != (field->flags & PROTOBUF_C_FIELD_FLAG_PACKED) ||
 801ae4c:	f8d7 321c 	ldr.w	r3, [r7, #540]	; 0x21c
 801ae50:	69db      	ldr	r3, [r3, #28]
 801ae52:	f003 0301 	and.w	r3, r3, #1
			if (wire_type == PROTOBUF_C_WIRE_TYPE_LENGTH_PREFIXED &&
 801ae56:	2b00      	cmp	r3, #0
 801ae58:	d108      	bne.n	801ae6c <protobuf_c_message_unpack+0x518>
			     is_packable_type(field->type)))
 801ae5a:	f8d7 321c 	ldr.w	r3, [r7, #540]	; 0x21c
 801ae5e:	7a5b      	ldrb	r3, [r3, #9]
 801ae60:	4618      	mov	r0, r3
 801ae62:	f7ff fc2b 	bl	801a6bc <is_packable_type>
 801ae66:	4603      	mov	r3, r0
			    (0 != (field->flags & PROTOBUF_C_FIELD_FLAG_PACKED) ||
 801ae68:	2b00      	cmp	r3, #0
 801ae6a:	d02e      	beq.n	801aeca <protobuf_c_message_unpack+0x576>
			{
				size_t count;
				if (!count_packed_elements(field->type,
 801ae6c:	f8d7 321c 	ldr.w	r3, [r7, #540]	; 0x21c
 801ae70:	7a58      	ldrb	r0, [r3, #9]
							   tmp.len -
 801ae72:	f507 7314 	add.w	r3, r7, #592	; 0x250
 801ae76:	f5a3 730e 	sub.w	r3, r3, #568	; 0x238
 801ae7a:	68db      	ldr	r3, [r3, #12]
							   tmp.length_prefix_len,
 801ae7c:	f507 7214 	add.w	r2, r7, #592	; 0x250
 801ae80:	f5a2 720e 	sub.w	r2, r2, #568	; 0x238
 801ae84:	7952      	ldrb	r2, [r2, #5]
				if (!count_packed_elements(field->type,
 801ae86:	1a99      	subs	r1, r3, r2
							   tmp.data +
 801ae88:	f507 7314 	add.w	r3, r7, #592	; 0x250
 801ae8c:	f5a3 730e 	sub.w	r3, r3, #568	; 0x238
 801ae90:	691b      	ldr	r3, [r3, #16]
							   tmp.length_prefix_len,
 801ae92:	f507 7214 	add.w	r2, r7, #592	; 0x250
 801ae96:	f5a2 720e 	sub.w	r2, r2, #568	; 0x238
 801ae9a:	7952      	ldrb	r2, [r2, #5]
				if (!count_packed_elements(field->type,
 801ae9c:	441a      	add	r2, r3
 801ae9e:	f107 0310 	add.w	r3, r7, #16
 801aea2:	f7fe fdeb 	bl	8019a7c <count_packed_elements>
 801aea6:	4603      	mov	r3, r0
 801aea8:	2b00      	cmp	r3, #0
 801aeaa:	d101      	bne.n	801aeb0 <protobuf_c_message_unpack+0x55c>
							   &count))
				{
					PROTOBUF_C_UNPACK_ERROR("counting packed elements");
					goto error_cleanup_during_scan;
 801aeac:	bf00      	nop
			goto error_cleanup_during_scan;
 801aeae:	e1ea      	b.n	801b286 <protobuf_c_message_unpack+0x932>
				}
				*n += count;
 801aeb0:	f8d7 31e0 	ldr.w	r3, [r7, #480]	; 0x1e0
 801aeb4:	681a      	ldr	r2, [r3, #0]
 801aeb6:	f507 7314 	add.w	r3, r7, #592	; 0x250
 801aeba:	f5a3 7310 	sub.w	r3, r3, #576	; 0x240
 801aebe:	681b      	ldr	r3, [r3, #0]
 801aec0:	441a      	add	r2, r3
 801aec2:	f8d7 31e0 	ldr.w	r3, [r7, #480]	; 0x1e0
 801aec6:	601a      	str	r2, [r3, #0]
			{
 801aec8:	e006      	b.n	801aed8 <protobuf_c_message_unpack+0x584>
			} else {
				*n += 1;
 801aeca:	f8d7 31e0 	ldr.w	r3, [r7, #480]	; 0x1e0
 801aece:	681b      	ldr	r3, [r3, #0]
 801aed0:	1c5a      	adds	r2, r3, #1
 801aed2:	f8d7 31e0 	ldr.w	r3, [r7, #480]	; 0x1e0
 801aed6:	601a      	str	r2, [r3, #0]
			}
		}

		at += tmp.len;
 801aed8:	f507 7314 	add.w	r3, r7, #592	; 0x250
 801aedc:	f5a3 730e 	sub.w	r3, r3, #568	; 0x238
 801aee0:	68db      	ldr	r3, [r3, #12]
 801aee2:	f8d7 2248 	ldr.w	r2, [r7, #584]	; 0x248
 801aee6:	4413      	add	r3, r2
 801aee8:	f8c7 3248 	str.w	r3, [r7, #584]	; 0x248
		rem -= tmp.len;
 801aeec:	f507 7314 	add.w	r3, r7, #592	; 0x250
 801aef0:	f5a3 730e 	sub.w	r3, r3, #568	; 0x238
 801aef4:	68db      	ldr	r3, [r3, #12]
 801aef6:	f8d7 224c 	ldr.w	r2, [r7, #588]	; 0x24c
 801aefa:	1ad3      	subs	r3, r2, r3
 801aefc:	f8c7 324c 	str.w	r3, [r7, #588]	; 0x24c
	while (rem > 0) {
 801af00:	f8d7 324c 	ldr.w	r3, [r7, #588]	; 0x24c
 801af04:	2b00      	cmp	r3, #0
 801af06:	f47f adf0 	bne.w	801aaea <protobuf_c_message_unpack+0x196>
	}

	/* allocate space for repeated fields, also check that all required fields have been set */
	for (f = 0; f < desc->n_fields; f++) {
 801af0a:	2300      	movs	r3, #0
 801af0c:	f8c7 3234 	str.w	r3, [r7, #564]	; 0x234
 801af10:	e0de      	b.n	801b0d0 <protobuf_c_message_unpack+0x77c>
		const ProtobufCFieldDescriptor *field = desc->fields + f;
 801af12:	f507 7314 	add.w	r3, r7, #592	; 0x250
 801af16:	f5a3 7311 	sub.w	r3, r3, #580	; 0x244
 801af1a:	681b      	ldr	r3, [r3, #0]
 801af1c:	69da      	ldr	r2, [r3, #28]
 801af1e:	f8d7 3234 	ldr.w	r3, [r7, #564]	; 0x234
 801af22:	212c      	movs	r1, #44	; 0x2c
 801af24:	fb01 f303 	mul.w	r3, r1, r3
 801af28:	4413      	add	r3, r2
 801af2a:	f8c7 3204 	str.w	r3, [r7, #516]	; 0x204
		if (field->label == PROTOBUF_C_LABEL_REPEATED) {
 801af2e:	f8d7 3204 	ldr.w	r3, [r7, #516]	; 0x204
 801af32:	7a1b      	ldrb	r3, [r3, #8]
 801af34:	2b02      	cmp	r3, #2
 801af36:	d179      	bne.n	801b02c <protobuf_c_message_unpack+0x6d8>
			size_t siz =
			    sizeof_elt_in_repeated_array(field->type);
 801af38:	f8d7 3204 	ldr.w	r3, [r7, #516]	; 0x204
 801af3c:	7a5b      	ldrb	r3, [r3, #9]
 801af3e:	4618      	mov	r0, r3
 801af40:	f7fd ffa0 	bl	8018e84 <sizeof_elt_in_repeated_array>
 801af44:	f8c7 0200 	str.w	r0, [r7, #512]	; 0x200
			size_t *n_ptr =
			    STRUCT_MEMBER_PTR(size_t, rv,
 801af48:	f8d7 3204 	ldr.w	r3, [r7, #516]	; 0x204
 801af4c:	68db      	ldr	r3, [r3, #12]
			size_t *n_ptr =
 801af4e:	f8d7 2214 	ldr.w	r2, [r7, #532]	; 0x214
 801af52:	4413      	add	r3, r2
 801af54:	f8c7 31fc 	str.w	r3, [r7, #508]	; 0x1fc
					      field->quantifier_offset);
			if (*n_ptr != 0) {
 801af58:	f8d7 31fc 	ldr.w	r3, [r7, #508]	; 0x1fc
 801af5c:	681b      	ldr	r3, [r3, #0]
 801af5e:	2b00      	cmp	r3, #0
 801af60:	f000 80b1 	beq.w	801b0c6 <protobuf_c_message_unpack+0x772>
				unsigned n = *n_ptr;
 801af64:	f8d7 31fc 	ldr.w	r3, [r7, #508]	; 0x1fc
 801af68:	681b      	ldr	r3, [r3, #0]
 801af6a:	f8c7 31f8 	str.w	r3, [r7, #504]	; 0x1f8
				void *a;
				*n_ptr = 0;
 801af6e:	f8d7 31fc 	ldr.w	r3, [r7, #508]	; 0x1fc
 801af72:	2200      	movs	r2, #0
 801af74:	601a      	str	r2, [r3, #0]
				assert(rv->descriptor != NULL);
 801af76:	f8d7 3214 	ldr.w	r3, [r7, #532]	; 0x214
 801af7a:	681b      	ldr	r3, [r3, #0]
 801af7c:	2b00      	cmp	r3, #0
 801af7e:	d106      	bne.n	801af8e <protobuf_c_message_unpack+0x63a>
 801af80:	4bce      	ldr	r3, [pc, #824]	; (801b2bc <protobuf_c_message_unpack+0x968>)
 801af82:	4acf      	ldr	r2, [pc, #828]	; (801b2c0 <protobuf_c_message_unpack+0x96c>)
 801af84:	f640 41a3 	movw	r1, #3235	; 0xca3
 801af88:	48ce      	ldr	r0, [pc, #824]	; (801b2c4 <protobuf_c_message_unpack+0x970>)
 801af8a:	f004 fbe5 	bl	801f758 <__assert_func>
                {                                                             \
                  field = desc->fields + f;                                   \
                  if (field->label == PROTOBUF_C_LABEL_REPEATED)              \
                    STRUCT_MEMBER (size_t, rv, field->quantifier_offset) = 0; \
                }
				a = do_alloc(allocator, siz * n);
 801af8e:	f8d7 3200 	ldr.w	r3, [r7, #512]	; 0x200
 801af92:	f8d7 21f8 	ldr.w	r2, [r7, #504]	; 0x1f8
 801af96:	fb03 f202 	mul.w	r2, r3, r2
 801af9a:	f507 7314 	add.w	r3, r7, #592	; 0x250
 801af9e:	f5a3 7312 	sub.w	r3, r3, #584	; 0x248
 801afa2:	4611      	mov	r1, r2
 801afa4:	6818      	ldr	r0, [r3, #0]
 801afa6:	f7fc ff08 	bl	8017dba <do_alloc>
 801afaa:	f8c7 01f4 	str.w	r0, [r7, #500]	; 0x1f4
				if (!a) {
 801afae:	f8d7 31f4 	ldr.w	r3, [r7, #500]	; 0x1f4
 801afb2:	2b00      	cmp	r3, #0
 801afb4:	d130      	bne.n	801b018 <protobuf_c_message_unpack+0x6c4>
					CLEAR_REMAINING_N_PTRS();
 801afb6:	f8d7 3234 	ldr.w	r3, [r7, #564]	; 0x234
 801afba:	3301      	adds	r3, #1
 801afbc:	f8c7 3234 	str.w	r3, [r7, #564]	; 0x234
 801afc0:	e01f      	b.n	801b002 <protobuf_c_message_unpack+0x6ae>
 801afc2:	f507 7314 	add.w	r3, r7, #592	; 0x250
 801afc6:	f5a3 7311 	sub.w	r3, r3, #580	; 0x244
 801afca:	681b      	ldr	r3, [r3, #0]
 801afcc:	69da      	ldr	r2, [r3, #28]
 801afce:	f8d7 3234 	ldr.w	r3, [r7, #564]	; 0x234
 801afd2:	212c      	movs	r1, #44	; 0x2c
 801afd4:	fb01 f303 	mul.w	r3, r1, r3
 801afd8:	4413      	add	r3, r2
 801afda:	f8c7 3204 	str.w	r3, [r7, #516]	; 0x204
 801afde:	f8d7 3204 	ldr.w	r3, [r7, #516]	; 0x204
 801afe2:	7a1b      	ldrb	r3, [r3, #8]
 801afe4:	2b02      	cmp	r3, #2
 801afe6:	d107      	bne.n	801aff8 <protobuf_c_message_unpack+0x6a4>
 801afe8:	f8d7 3204 	ldr.w	r3, [r7, #516]	; 0x204
 801afec:	68db      	ldr	r3, [r3, #12]
 801afee:	f8d7 2214 	ldr.w	r2, [r7, #532]	; 0x214
 801aff2:	4413      	add	r3, r2
 801aff4:	2200      	movs	r2, #0
 801aff6:	601a      	str	r2, [r3, #0]
 801aff8:	f8d7 3234 	ldr.w	r3, [r7, #564]	; 0x234
 801affc:	3301      	adds	r3, #1
 801affe:	f8c7 3234 	str.w	r3, [r7, #564]	; 0x234
 801b002:	f507 7314 	add.w	r3, r7, #592	; 0x250
 801b006:	f5a3 7311 	sub.w	r3, r3, #580	; 0x244
 801b00a:	681b      	ldr	r3, [r3, #0]
 801b00c:	699b      	ldr	r3, [r3, #24]
 801b00e:	f8d7 2234 	ldr.w	r2, [r7, #564]	; 0x234
 801b012:	429a      	cmp	r2, r3
 801b014:	d3d5      	bcc.n	801afc2 <protobuf_c_message_unpack+0x66e>
					goto error_cleanup;
 801b016:	e0ff      	b.n	801b218 <protobuf_c_message_unpack+0x8c4>
				}
				STRUCT_MEMBER(void *, rv, field->offset) = a;
 801b018:	f8d7 3204 	ldr.w	r3, [r7, #516]	; 0x204
 801b01c:	691b      	ldr	r3, [r3, #16]
 801b01e:	f8d7 2214 	ldr.w	r2, [r7, #532]	; 0x214
 801b022:	4413      	add	r3, r2
 801b024:	f8d7 21f4 	ldr.w	r2, [r7, #500]	; 0x1f4
 801b028:	601a      	str	r2, [r3, #0]
 801b02a:	e04c      	b.n	801b0c6 <protobuf_c_message_unpack+0x772>
			}
		} else if (field->label == PROTOBUF_C_LABEL_REQUIRED) {
 801b02c:	f8d7 3204 	ldr.w	r3, [r7, #516]	; 0x204
 801b030:	7a1b      	ldrb	r3, [r3, #8]
 801b032:	2b00      	cmp	r3, #0
 801b034:	d147      	bne.n	801b0c6 <protobuf_c_message_unpack+0x772>
			if (field->default_value == NULL &&
 801b036:	f8d7 3204 	ldr.w	r3, [r7, #516]	; 0x204
 801b03a:	699b      	ldr	r3, [r3, #24]
 801b03c:	2b00      	cmp	r3, #0
 801b03e:	d142      	bne.n	801b0c6 <protobuf_c_message_unpack+0x772>
			    !REQUIRED_FIELD_BITMAP_IS_SET(f))
 801b040:	f8d7 3234 	ldr.w	r3, [r7, #564]	; 0x234
 801b044:	08db      	lsrs	r3, r3, #3
 801b046:	f8d7 2224 	ldr.w	r2, [r7, #548]	; 0x224
 801b04a:	4413      	add	r3, r2
 801b04c:	781b      	ldrb	r3, [r3, #0]
 801b04e:	461a      	mov	r2, r3
 801b050:	f8d7 3234 	ldr.w	r3, [r7, #564]	; 0x234
 801b054:	f003 0307 	and.w	r3, r3, #7
 801b058:	fa22 f303 	lsr.w	r3, r2, r3
 801b05c:	f003 0301 	and.w	r3, r3, #1
			if (field->default_value == NULL &&
 801b060:	2b00      	cmp	r3, #0
 801b062:	d130      	bne.n	801b0c6 <protobuf_c_message_unpack+0x772>
			{
				CLEAR_REMAINING_N_PTRS();
 801b064:	f8d7 3234 	ldr.w	r3, [r7, #564]	; 0x234
 801b068:	3301      	adds	r3, #1
 801b06a:	f8c7 3234 	str.w	r3, [r7, #564]	; 0x234
 801b06e:	e01f      	b.n	801b0b0 <protobuf_c_message_unpack+0x75c>
 801b070:	f507 7314 	add.w	r3, r7, #592	; 0x250
 801b074:	f5a3 7311 	sub.w	r3, r3, #580	; 0x244
 801b078:	681b      	ldr	r3, [r3, #0]
 801b07a:	69da      	ldr	r2, [r3, #28]
 801b07c:	f8d7 3234 	ldr.w	r3, [r7, #564]	; 0x234
 801b080:	212c      	movs	r1, #44	; 0x2c
 801b082:	fb01 f303 	mul.w	r3, r1, r3
 801b086:	4413      	add	r3, r2
 801b088:	f8c7 3204 	str.w	r3, [r7, #516]	; 0x204
 801b08c:	f8d7 3204 	ldr.w	r3, [r7, #516]	; 0x204
 801b090:	7a1b      	ldrb	r3, [r3, #8]
 801b092:	2b02      	cmp	r3, #2
 801b094:	d107      	bne.n	801b0a6 <protobuf_c_message_unpack+0x752>
 801b096:	f8d7 3204 	ldr.w	r3, [r7, #516]	; 0x204
 801b09a:	68db      	ldr	r3, [r3, #12]
 801b09c:	f8d7 2214 	ldr.w	r2, [r7, #532]	; 0x214
 801b0a0:	4413      	add	r3, r2
 801b0a2:	2200      	movs	r2, #0
 801b0a4:	601a      	str	r2, [r3, #0]
 801b0a6:	f8d7 3234 	ldr.w	r3, [r7, #564]	; 0x234
 801b0aa:	3301      	adds	r3, #1
 801b0ac:	f8c7 3234 	str.w	r3, [r7, #564]	; 0x234
 801b0b0:	f507 7314 	add.w	r3, r7, #592	; 0x250
 801b0b4:	f5a3 7311 	sub.w	r3, r3, #580	; 0x244
 801b0b8:	681b      	ldr	r3, [r3, #0]
 801b0ba:	699b      	ldr	r3, [r3, #24]
 801b0bc:	f8d7 2234 	ldr.w	r2, [r7, #564]	; 0x234
 801b0c0:	429a      	cmp	r2, r3
 801b0c2:	d3d5      	bcc.n	801b070 <protobuf_c_message_unpack+0x71c>
				PROTOBUF_C_UNPACK_ERROR("message '%s': missing required field '%s'",
							desc->name, field->name);
				goto error_cleanup;
 801b0c4:	e0a8      	b.n	801b218 <protobuf_c_message_unpack+0x8c4>
	for (f = 0; f < desc->n_fields; f++) {
 801b0c6:	f8d7 3234 	ldr.w	r3, [r7, #564]	; 0x234
 801b0ca:	3301      	adds	r3, #1
 801b0cc:	f8c7 3234 	str.w	r3, [r7, #564]	; 0x234
 801b0d0:	f507 7314 	add.w	r3, r7, #592	; 0x250
 801b0d4:	f5a3 7311 	sub.w	r3, r3, #580	; 0x244
 801b0d8:	681b      	ldr	r3, [r3, #0]
 801b0da:	699b      	ldr	r3, [r3, #24]
 801b0dc:	f8d7 2234 	ldr.w	r2, [r7, #564]	; 0x234
 801b0e0:	429a      	cmp	r2, r3
 801b0e2:	f4ff af16 	bcc.w	801af12 <protobuf_c_message_unpack+0x5be>
		}
	}
#undef CLEAR_REMAINING_N_PTRS

	/* allocate space for unknown fields */
	if (n_unknown) {
 801b0e6:	f8d7 3238 	ldr.w	r3, [r7, #568]	; 0x238
 801b0ea:	2b00      	cmp	r3, #0
 801b0ec:	d013      	beq.n	801b116 <protobuf_c_message_unpack+0x7c2>
		rv->unknown_fields = do_alloc(allocator,
 801b0ee:	f8d7 3238 	ldr.w	r3, [r7, #568]	; 0x238
 801b0f2:	011a      	lsls	r2, r3, #4
 801b0f4:	f507 7314 	add.w	r3, r7, #592	; 0x250
 801b0f8:	f5a3 7312 	sub.w	r3, r3, #584	; 0x248
 801b0fc:	4611      	mov	r1, r2
 801b0fe:	6818      	ldr	r0, [r3, #0]
 801b100:	f7fc fe5b 	bl	8017dba <do_alloc>
 801b104:	4602      	mov	r2, r0
 801b106:	f8d7 3214 	ldr.w	r3, [r7, #532]	; 0x214
 801b10a:	609a      	str	r2, [r3, #8]
					      n_unknown * sizeof(ProtobufCMessageUnknownField));
		if (rv->unknown_fields == NULL)
 801b10c:	f8d7 3214 	ldr.w	r3, [r7, #532]	; 0x214
 801b110:	689b      	ldr	r3, [r3, #8]
 801b112:	2b00      	cmp	r3, #0
 801b114:	d07d      	beq.n	801b212 <protobuf_c_message_unpack+0x8be>
			goto error_cleanup;
	}

	/* do real parsing */
	for (i_slab = 0; i_slab <= which_slab; i_slab++) {
 801b116:	2300      	movs	r3, #0
 801b118:	f8c7 322c 	str.w	r3, [r7, #556]	; 0x22c
 801b11c:	e044      	b.n	801b1a8 <protobuf_c_message_unpack+0x854>
		unsigned max = (i_slab == which_slab) ?
			in_slab_index : (1UL << (i_slab + 4));
 801b11e:	f8d7 222c 	ldr.w	r2, [r7, #556]	; 0x22c
 801b122:	f8d7 3240 	ldr.w	r3, [r7, #576]	; 0x240
 801b126:	429a      	cmp	r2, r3
 801b128:	d006      	beq.n	801b138 <protobuf_c_message_unpack+0x7e4>
 801b12a:	f8d7 322c 	ldr.w	r3, [r7, #556]	; 0x22c
 801b12e:	3304      	adds	r3, #4
 801b130:	2201      	movs	r2, #1
 801b132:	fa02 f303 	lsl.w	r3, r2, r3
 801b136:	e001      	b.n	801b13c <protobuf_c_message_unpack+0x7e8>
 801b138:	f8d7 323c 	ldr.w	r3, [r7, #572]	; 0x23c
		unsigned max = (i_slab == which_slab) ?
 801b13c:	f8c7 320c 	str.w	r3, [r7, #524]	; 0x20c
		ScannedMember *slab = scanned_member_slabs[i_slab];
 801b140:	f507 7314 	add.w	r3, r7, #592	; 0x250
 801b144:	f5a3 7303 	sub.w	r3, r3, #524	; 0x20c
 801b148:	f8d7 222c 	ldr.w	r2, [r7, #556]	; 0x22c
 801b14c:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 801b150:	f8c7 3208 	str.w	r3, [r7, #520]	; 0x208

		for (j = 0; j < max; j++) {
 801b154:	2300      	movs	r3, #0
 801b156:	f8c7 3230 	str.w	r3, [r7, #560]	; 0x230
 801b15a:	e01a      	b.n	801b192 <protobuf_c_message_unpack+0x83e>
			if (!parse_member(slab + j, rv, allocator)) {
 801b15c:	f8d7 2230 	ldr.w	r2, [r7, #560]	; 0x230
 801b160:	4613      	mov	r3, r2
 801b162:	009b      	lsls	r3, r3, #2
 801b164:	4413      	add	r3, r2
 801b166:	009b      	lsls	r3, r3, #2
 801b168:	461a      	mov	r2, r3
 801b16a:	f8d7 3208 	ldr.w	r3, [r7, #520]	; 0x208
 801b16e:	1898      	adds	r0, r3, r2
 801b170:	f507 7314 	add.w	r3, r7, #592	; 0x250
 801b174:	f5a3 7312 	sub.w	r3, r3, #584	; 0x248
 801b178:	681a      	ldr	r2, [r3, #0]
 801b17a:	f8d7 1214 	ldr.w	r1, [r7, #532]	; 0x214
 801b17e:	f7ff fab5 	bl	801a6ec <parse_member>
 801b182:	4603      	mov	r3, r0
 801b184:	2b00      	cmp	r3, #0
 801b186:	d046      	beq.n	801b216 <protobuf_c_message_unpack+0x8c2>
		for (j = 0; j < max; j++) {
 801b188:	f8d7 3230 	ldr.w	r3, [r7, #560]	; 0x230
 801b18c:	3301      	adds	r3, #1
 801b18e:	f8c7 3230 	str.w	r3, [r7, #560]	; 0x230
 801b192:	f8d7 2230 	ldr.w	r2, [r7, #560]	; 0x230
 801b196:	f8d7 320c 	ldr.w	r3, [r7, #524]	; 0x20c
 801b19a:	429a      	cmp	r2, r3
 801b19c:	d3de      	bcc.n	801b15c <protobuf_c_message_unpack+0x808>
	for (i_slab = 0; i_slab <= which_slab; i_slab++) {
 801b19e:	f8d7 322c 	ldr.w	r3, [r7, #556]	; 0x22c
 801b1a2:	3301      	adds	r3, #1
 801b1a4:	f8c7 322c 	str.w	r3, [r7, #556]	; 0x22c
 801b1a8:	f8d7 222c 	ldr.w	r2, [r7, #556]	; 0x22c
 801b1ac:	f8d7 3240 	ldr.w	r3, [r7, #576]	; 0x240
 801b1b0:	429a      	cmp	r2, r3
 801b1b2:	d9b4      	bls.n	801b11e <protobuf_c_message_unpack+0x7ca>
			}
		}
	}

	/* cleanup */
	for (j = 1; j <= which_slab; j++)
 801b1b4:	2301      	movs	r3, #1
 801b1b6:	f8c7 3230 	str.w	r3, [r7, #560]	; 0x230
 801b1ba:	e014      	b.n	801b1e6 <protobuf_c_message_unpack+0x892>
		do_free(allocator, scanned_member_slabs[j]);
 801b1bc:	f507 7314 	add.w	r3, r7, #592	; 0x250
 801b1c0:	f5a3 7303 	sub.w	r3, r3, #524	; 0x20c
 801b1c4:	f8d7 2230 	ldr.w	r2, [r7, #560]	; 0x230
 801b1c8:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 801b1cc:	f507 7314 	add.w	r3, r7, #592	; 0x250
 801b1d0:	f5a3 7312 	sub.w	r3, r3, #584	; 0x248
 801b1d4:	4611      	mov	r1, r2
 801b1d6:	6818      	ldr	r0, [r3, #0]
 801b1d8:	f7fc fe00 	bl	8017ddc <do_free>
	for (j = 1; j <= which_slab; j++)
 801b1dc:	f8d7 3230 	ldr.w	r3, [r7, #560]	; 0x230
 801b1e0:	3301      	adds	r3, #1
 801b1e2:	f8c7 3230 	str.w	r3, [r7, #560]	; 0x230
 801b1e6:	f8d7 2230 	ldr.w	r2, [r7, #560]	; 0x230
 801b1ea:	f8d7 3240 	ldr.w	r3, [r7, #576]	; 0x240
 801b1ee:	429a      	cmp	r2, r3
 801b1f0:	d9e4      	bls.n	801b1bc <protobuf_c_message_unpack+0x868>
	if (required_fields_bitmap_alloced)
 801b1f2:	f8d7 3220 	ldr.w	r3, [r7, #544]	; 0x220
 801b1f6:	2b00      	cmp	r3, #0
 801b1f8:	d008      	beq.n	801b20c <protobuf_c_message_unpack+0x8b8>
		do_free(allocator, required_fields_bitmap);
 801b1fa:	f507 7314 	add.w	r3, r7, #592	; 0x250
 801b1fe:	f5a3 7312 	sub.w	r3, r3, #584	; 0x248
 801b202:	f8d7 1224 	ldr.w	r1, [r7, #548]	; 0x224
 801b206:	6818      	ldr	r0, [r3, #0]
 801b208:	f7fc fde8 	bl	8017ddc <do_free>
	return rv;
 801b20c:	f8d7 3214 	ldr.w	r3, [r7, #532]	; 0x214
 801b210:	e083      	b.n	801b31a <protobuf_c_message_unpack+0x9c6>
			goto error_cleanup;
 801b212:	bf00      	nop
 801b214:	e000      	b.n	801b218 <protobuf_c_message_unpack+0x8c4>
				goto error_cleanup;
 801b216:	bf00      	nop

error_cleanup:
	protobuf_c_message_free_unpacked(rv, allocator);
 801b218:	f507 7314 	add.w	r3, r7, #592	; 0x250
 801b21c:	f5a3 7312 	sub.w	r3, r3, #584	; 0x248
 801b220:	6819      	ldr	r1, [r3, #0]
 801b222:	f8d7 0214 	ldr.w	r0, [r7, #532]	; 0x214
 801b226:	f000 f87d 	bl	801b324 <protobuf_c_message_free_unpacked>
	for (j = 1; j <= which_slab; j++)
 801b22a:	2301      	movs	r3, #1
 801b22c:	f8c7 3230 	str.w	r3, [r7, #560]	; 0x230
 801b230:	e014      	b.n	801b25c <protobuf_c_message_unpack+0x908>
		do_free(allocator, scanned_member_slabs[j]);
 801b232:	f507 7314 	add.w	r3, r7, #592	; 0x250
 801b236:	f5a3 7303 	sub.w	r3, r3, #524	; 0x20c
 801b23a:	f8d7 2230 	ldr.w	r2, [r7, #560]	; 0x230
 801b23e:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 801b242:	f507 7314 	add.w	r3, r7, #592	; 0x250
 801b246:	f5a3 7312 	sub.w	r3, r3, #584	; 0x248
 801b24a:	4611      	mov	r1, r2
 801b24c:	6818      	ldr	r0, [r3, #0]
 801b24e:	f7fc fdc5 	bl	8017ddc <do_free>
	for (j = 1; j <= which_slab; j++)
 801b252:	f8d7 3230 	ldr.w	r3, [r7, #560]	; 0x230
 801b256:	3301      	adds	r3, #1
 801b258:	f8c7 3230 	str.w	r3, [r7, #560]	; 0x230
 801b25c:	f8d7 2230 	ldr.w	r2, [r7, #560]	; 0x230
 801b260:	f8d7 3240 	ldr.w	r3, [r7, #576]	; 0x240
 801b264:	429a      	cmp	r2, r3
 801b266:	d9e4      	bls.n	801b232 <protobuf_c_message_unpack+0x8de>
	if (required_fields_bitmap_alloced)
 801b268:	f8d7 3220 	ldr.w	r3, [r7, #544]	; 0x220
 801b26c:	2b00      	cmp	r3, #0
 801b26e:	d008      	beq.n	801b282 <protobuf_c_message_unpack+0x92e>
		do_free(allocator, required_fields_bitmap);
 801b270:	f507 7314 	add.w	r3, r7, #592	; 0x250
 801b274:	f5a3 7312 	sub.w	r3, r3, #584	; 0x248
 801b278:	f8d7 1224 	ldr.w	r1, [r7, #548]	; 0x224
 801b27c:	6818      	ldr	r0, [r3, #0]
 801b27e:	f7fc fdad 	bl	8017ddc <do_free>
	return NULL;
 801b282:	2300      	movs	r3, #0
 801b284:	e049      	b.n	801b31a <protobuf_c_message_unpack+0x9c6>
			goto error_cleanup_during_scan;
 801b286:	bf00      	nop
 801b288:	e00a      	b.n	801b2a0 <protobuf_c_message_unpack+0x94c>
			goto error_cleanup_during_scan;
 801b28a:	bf00      	nop
 801b28c:	e008      	b.n	801b2a0 <protobuf_c_message_unpack+0x94c>
				goto error_cleanup_during_scan;
 801b28e:	bf00      	nop
 801b290:	e006      	b.n	801b2a0 <protobuf_c_message_unpack+0x94c>
				goto error_cleanup_during_scan;
 801b292:	bf00      	nop
 801b294:	e004      	b.n	801b2a0 <protobuf_c_message_unpack+0x94c>
				goto error_cleanup_during_scan;
 801b296:	bf00      	nop
 801b298:	e002      	b.n	801b2a0 <protobuf_c_message_unpack+0x94c>
				goto error_cleanup_during_scan;
 801b29a:	bf00      	nop
 801b29c:	e000      	b.n	801b2a0 <protobuf_c_message_unpack+0x94c>
				goto error_cleanup_during_scan;
 801b29e:	bf00      	nop

error_cleanup_during_scan:
	do_free(allocator, rv);
 801b2a0:	f507 7314 	add.w	r3, r7, #592	; 0x250
 801b2a4:	f5a3 7312 	sub.w	r3, r3, #584	; 0x248
 801b2a8:	f8d7 1214 	ldr.w	r1, [r7, #532]	; 0x214
 801b2ac:	6818      	ldr	r0, [r3, #0]
 801b2ae:	f7fc fd95 	bl	8017ddc <do_free>
	for (j = 1; j <= which_slab; j++)
 801b2b2:	2301      	movs	r3, #1
 801b2b4:	f8c7 3230 	str.w	r3, [r7, #560]	; 0x230
 801b2b8:	e01b      	b.n	801b2f2 <protobuf_c_message_unpack+0x99e>
 801b2ba:	bf00      	nop
 801b2bc:	08024400 	.word	0x08024400
 801b2c0:	08028770 	.word	0x08028770
 801b2c4:	080242e8 	.word	0x080242e8
		do_free(allocator, scanned_member_slabs[j]);
 801b2c8:	f507 7314 	add.w	r3, r7, #592	; 0x250
 801b2cc:	f5a3 7303 	sub.w	r3, r3, #524	; 0x20c
 801b2d0:	f8d7 2230 	ldr.w	r2, [r7, #560]	; 0x230
 801b2d4:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 801b2d8:	f507 7314 	add.w	r3, r7, #592	; 0x250
 801b2dc:	f5a3 7312 	sub.w	r3, r3, #584	; 0x248
 801b2e0:	4611      	mov	r1, r2
 801b2e2:	6818      	ldr	r0, [r3, #0]
 801b2e4:	f7fc fd7a 	bl	8017ddc <do_free>
	for (j = 1; j <= which_slab; j++)
 801b2e8:	f8d7 3230 	ldr.w	r3, [r7, #560]	; 0x230
 801b2ec:	3301      	adds	r3, #1
 801b2ee:	f8c7 3230 	str.w	r3, [r7, #560]	; 0x230
 801b2f2:	f8d7 2230 	ldr.w	r2, [r7, #560]	; 0x230
 801b2f6:	f8d7 3240 	ldr.w	r3, [r7, #576]	; 0x240
 801b2fa:	429a      	cmp	r2, r3
 801b2fc:	d9e4      	bls.n	801b2c8 <protobuf_c_message_unpack+0x974>
	if (required_fields_bitmap_alloced)
 801b2fe:	f8d7 3220 	ldr.w	r3, [r7, #544]	; 0x220
 801b302:	2b00      	cmp	r3, #0
 801b304:	d008      	beq.n	801b318 <protobuf_c_message_unpack+0x9c4>
		do_free(allocator, required_fields_bitmap);
 801b306:	f507 7314 	add.w	r3, r7, #592	; 0x250
 801b30a:	f5a3 7312 	sub.w	r3, r3, #584	; 0x248
 801b30e:	f8d7 1224 	ldr.w	r1, [r7, #548]	; 0x224
 801b312:	6818      	ldr	r0, [r3, #0]
 801b314:	f7fc fd62 	bl	8017ddc <do_free>
	return NULL;
 801b318:	2300      	movs	r3, #0
}
 801b31a:	4618      	mov	r0, r3
 801b31c:	f507 7714 	add.w	r7, r7, #592	; 0x250
 801b320:	46bd      	mov	sp, r7
 801b322:	bdb0      	pop	{r4, r5, r7, pc}

0801b324 <protobuf_c_message_free_unpacked>:

void
protobuf_c_message_free_unpacked(ProtobufCMessage *message,
				 ProtobufCAllocator *allocator)
{
 801b324:	b580      	push	{r7, lr}
 801b326:	b08e      	sub	sp, #56	; 0x38
 801b328:	af00      	add	r7, sp, #0
 801b32a:	6078      	str	r0, [r7, #4]
 801b32c:	6039      	str	r1, [r7, #0]
	const ProtobufCMessageDescriptor *desc;
	unsigned f;

	if (message == NULL)
 801b32e:	687b      	ldr	r3, [r7, #4]
 801b330:	2b00      	cmp	r3, #0
 801b332:	f000 817a 	beq.w	801b62a <protobuf_c_message_free_unpacked+0x306>
		return;

	desc = message->descriptor;
 801b336:	687b      	ldr	r3, [r7, #4]
 801b338:	681b      	ldr	r3, [r3, #0]
 801b33a:	627b      	str	r3, [r7, #36]	; 0x24

	ASSERT_IS_MESSAGE(message);
 801b33c:	687b      	ldr	r3, [r7, #4]
 801b33e:	681b      	ldr	r3, [r3, #0]
 801b340:	681b      	ldr	r3, [r3, #0]
 801b342:	4a89      	ldr	r2, [pc, #548]	; (801b568 <protobuf_c_message_free_unpacked+0x244>)
 801b344:	4293      	cmp	r3, r2
 801b346:	d006      	beq.n	801b356 <protobuf_c_message_free_unpacked+0x32>
 801b348:	4b88      	ldr	r3, [pc, #544]	; (801b56c <protobuf_c_message_free_unpacked+0x248>)
 801b34a:	4a89      	ldr	r2, [pc, #548]	; (801b570 <protobuf_c_message_free_unpacked+0x24c>)
 801b34c:	f640 41fb 	movw	r1, #3323	; 0xcfb
 801b350:	4888      	ldr	r0, [pc, #544]	; (801b574 <protobuf_c_message_free_unpacked+0x250>)
 801b352:	f004 fa01 	bl	801f758 <__assert_func>

	if (allocator == NULL)
 801b356:	683b      	ldr	r3, [r7, #0]
 801b358:	2b00      	cmp	r3, #0
 801b35a:	d101      	bne.n	801b360 <protobuf_c_message_free_unpacked+0x3c>
		allocator = &protobuf_c__allocator;
 801b35c:	4b86      	ldr	r3, [pc, #536]	; (801b578 <protobuf_c_message_free_unpacked+0x254>)
 801b35e:	603b      	str	r3, [r7, #0]
	message->descriptor = NULL;
 801b360:	687b      	ldr	r3, [r7, #4]
 801b362:	2200      	movs	r2, #0
 801b364:	601a      	str	r2, [r3, #0]
	for (f = 0; f < desc->n_fields; f++) {
 801b366:	2300      	movs	r3, #0
 801b368:	637b      	str	r3, [r7, #52]	; 0x34
 801b36a:	e134      	b.n	801b5d6 <protobuf_c_message_free_unpacked+0x2b2>
		if (0 != (desc->fields[f].flags & PROTOBUF_C_FIELD_FLAG_ONEOF) &&
 801b36c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801b36e:	69da      	ldr	r2, [r3, #28]
 801b370:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 801b372:	212c      	movs	r1, #44	; 0x2c
 801b374:	fb01 f303 	mul.w	r3, r1, r3
 801b378:	4413      	add	r3, r2
 801b37a:	69db      	ldr	r3, [r3, #28]
 801b37c:	f003 0304 	and.w	r3, r3, #4
 801b380:	2b00      	cmp	r3, #0
 801b382:	d015      	beq.n	801b3b0 <protobuf_c_message_free_unpacked+0x8c>
		    desc->fields[f].id !=
 801b384:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801b386:	69da      	ldr	r2, [r3, #28]
 801b388:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 801b38a:	212c      	movs	r1, #44	; 0x2c
 801b38c:	fb01 f303 	mul.w	r3, r1, r3
 801b390:	4413      	add	r3, r2
 801b392:	685a      	ldr	r2, [r3, #4]
		    STRUCT_MEMBER(uint32_t, message, desc->fields[f].quantifier_offset))
 801b394:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801b396:	69d9      	ldr	r1, [r3, #28]
 801b398:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 801b39a:	202c      	movs	r0, #44	; 0x2c
 801b39c:	fb00 f303 	mul.w	r3, r0, r3
 801b3a0:	440b      	add	r3, r1
 801b3a2:	68db      	ldr	r3, [r3, #12]
 801b3a4:	6879      	ldr	r1, [r7, #4]
 801b3a6:	440b      	add	r3, r1
		    desc->fields[f].id !=
 801b3a8:	681b      	ldr	r3, [r3, #0]
		if (0 != (desc->fields[f].flags & PROTOBUF_C_FIELD_FLAG_ONEOF) &&
 801b3aa:	429a      	cmp	r2, r3
 801b3ac:	f040 810f 	bne.w	801b5ce <protobuf_c_message_free_unpacked+0x2aa>
		{
			/* This is not the selected oneof, skip it */
			continue;
		}

		if (desc->fields[f].label == PROTOBUF_C_LABEL_REPEATED) {
 801b3b0:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801b3b2:	69da      	ldr	r2, [r3, #28]
 801b3b4:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 801b3b6:	212c      	movs	r1, #44	; 0x2c
 801b3b8:	fb01 f303 	mul.w	r3, r1, r3
 801b3bc:	4413      	add	r3, r2
 801b3be:	7a1b      	ldrb	r3, [r3, #8]
 801b3c0:	2b02      	cmp	r3, #2
 801b3c2:	d179      	bne.n	801b4b8 <protobuf_c_message_free_unpacked+0x194>
			size_t n = STRUCT_MEMBER(size_t,
 801b3c4:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801b3c6:	69da      	ldr	r2, [r3, #28]
 801b3c8:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 801b3ca:	212c      	movs	r1, #44	; 0x2c
 801b3cc:	fb01 f303 	mul.w	r3, r1, r3
 801b3d0:	4413      	add	r3, r2
 801b3d2:	68db      	ldr	r3, [r3, #12]
 801b3d4:	687a      	ldr	r2, [r7, #4]
 801b3d6:	4413      	add	r3, r2
 801b3d8:	681b      	ldr	r3, [r3, #0]
 801b3da:	613b      	str	r3, [r7, #16]
						 message,
						 desc->fields[f].quantifier_offset);
			void *arr = STRUCT_MEMBER(void *,
 801b3dc:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801b3de:	69da      	ldr	r2, [r3, #28]
 801b3e0:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 801b3e2:	212c      	movs	r1, #44	; 0x2c
 801b3e4:	fb01 f303 	mul.w	r3, r1, r3
 801b3e8:	4413      	add	r3, r2
 801b3ea:	691b      	ldr	r3, [r3, #16]
 801b3ec:	687a      	ldr	r2, [r7, #4]
 801b3ee:	4413      	add	r3, r2
 801b3f0:	681b      	ldr	r3, [r3, #0]
 801b3f2:	60fb      	str	r3, [r7, #12]
						  message,
						  desc->fields[f].offset);

			if (arr != NULL) {
 801b3f4:	68fb      	ldr	r3, [r7, #12]
 801b3f6:	2b00      	cmp	r3, #0
 801b3f8:	f000 80ea 	beq.w	801b5d0 <protobuf_c_message_free_unpacked+0x2ac>
				if (desc->fields[f].type == PROTOBUF_C_TYPE_STRING) {
 801b3fc:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801b3fe:	69da      	ldr	r2, [r3, #28]
 801b400:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 801b402:	212c      	movs	r1, #44	; 0x2c
 801b404:	fb01 f303 	mul.w	r3, r1, r3
 801b408:	4413      	add	r3, r2
 801b40a:	7a5b      	ldrb	r3, [r3, #9]
 801b40c:	2b0e      	cmp	r3, #14
 801b40e:	d113      	bne.n	801b438 <protobuf_c_message_free_unpacked+0x114>
					unsigned i;
					for (i = 0; i < n; i++)
 801b410:	2300      	movs	r3, #0
 801b412:	633b      	str	r3, [r7, #48]	; 0x30
 801b414:	e00b      	b.n	801b42e <protobuf_c_message_free_unpacked+0x10a>
						do_free(allocator, ((char **) arr)[i]);
 801b416:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801b418:	009b      	lsls	r3, r3, #2
 801b41a:	68fa      	ldr	r2, [r7, #12]
 801b41c:	4413      	add	r3, r2
 801b41e:	681b      	ldr	r3, [r3, #0]
 801b420:	4619      	mov	r1, r3
 801b422:	6838      	ldr	r0, [r7, #0]
 801b424:	f7fc fcda 	bl	8017ddc <do_free>
					for (i = 0; i < n; i++)
 801b428:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801b42a:	3301      	adds	r3, #1
 801b42c:	633b      	str	r3, [r7, #48]	; 0x30
 801b42e:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 801b430:	693b      	ldr	r3, [r7, #16]
 801b432:	429a      	cmp	r2, r3
 801b434:	d3ef      	bcc.n	801b416 <protobuf_c_message_free_unpacked+0xf2>
 801b436:	e03a      	b.n	801b4ae <protobuf_c_message_free_unpacked+0x18a>
				} else if (desc->fields[f].type == PROTOBUF_C_TYPE_BYTES) {
 801b438:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801b43a:	69da      	ldr	r2, [r3, #28]
 801b43c:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 801b43e:	212c      	movs	r1, #44	; 0x2c
 801b440:	fb01 f303 	mul.w	r3, r1, r3
 801b444:	4413      	add	r3, r2
 801b446:	7a5b      	ldrb	r3, [r3, #9]
 801b448:	2b0f      	cmp	r3, #15
 801b44a:	d113      	bne.n	801b474 <protobuf_c_message_free_unpacked+0x150>
					unsigned i;
					for (i = 0; i < n; i++)
 801b44c:	2300      	movs	r3, #0
 801b44e:	62fb      	str	r3, [r7, #44]	; 0x2c
 801b450:	e00b      	b.n	801b46a <protobuf_c_message_free_unpacked+0x146>
						do_free(allocator, ((ProtobufCBinaryData *) arr)[i].data);
 801b452:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 801b454:	00db      	lsls	r3, r3, #3
 801b456:	68fa      	ldr	r2, [r7, #12]
 801b458:	4413      	add	r3, r2
 801b45a:	685b      	ldr	r3, [r3, #4]
 801b45c:	4619      	mov	r1, r3
 801b45e:	6838      	ldr	r0, [r7, #0]
 801b460:	f7fc fcbc 	bl	8017ddc <do_free>
					for (i = 0; i < n; i++)
 801b464:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 801b466:	3301      	adds	r3, #1
 801b468:	62fb      	str	r3, [r7, #44]	; 0x2c
 801b46a:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 801b46c:	693b      	ldr	r3, [r7, #16]
 801b46e:	429a      	cmp	r2, r3
 801b470:	d3ef      	bcc.n	801b452 <protobuf_c_message_free_unpacked+0x12e>
 801b472:	e01c      	b.n	801b4ae <protobuf_c_message_free_unpacked+0x18a>
				} else if (desc->fields[f].type == PROTOBUF_C_TYPE_MESSAGE) {
 801b474:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801b476:	69da      	ldr	r2, [r3, #28]
 801b478:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 801b47a:	212c      	movs	r1, #44	; 0x2c
 801b47c:	fb01 f303 	mul.w	r3, r1, r3
 801b480:	4413      	add	r3, r2
 801b482:	7a5b      	ldrb	r3, [r3, #9]
 801b484:	2b10      	cmp	r3, #16
 801b486:	d112      	bne.n	801b4ae <protobuf_c_message_free_unpacked+0x18a>
					unsigned i;
					for (i = 0; i < n; i++)
 801b488:	2300      	movs	r3, #0
 801b48a:	62bb      	str	r3, [r7, #40]	; 0x28
 801b48c:	e00b      	b.n	801b4a6 <protobuf_c_message_free_unpacked+0x182>
						protobuf_c_message_free_unpacked(
							((ProtobufCMessage **) arr)[i],
 801b48e:	6abb      	ldr	r3, [r7, #40]	; 0x28
 801b490:	009b      	lsls	r3, r3, #2
 801b492:	68fa      	ldr	r2, [r7, #12]
 801b494:	4413      	add	r3, r2
						protobuf_c_message_free_unpacked(
 801b496:	681b      	ldr	r3, [r3, #0]
 801b498:	6839      	ldr	r1, [r7, #0]
 801b49a:	4618      	mov	r0, r3
 801b49c:	f7ff ff42 	bl	801b324 <protobuf_c_message_free_unpacked>
					for (i = 0; i < n; i++)
 801b4a0:	6abb      	ldr	r3, [r7, #40]	; 0x28
 801b4a2:	3301      	adds	r3, #1
 801b4a4:	62bb      	str	r3, [r7, #40]	; 0x28
 801b4a6:	6aba      	ldr	r2, [r7, #40]	; 0x28
 801b4a8:	693b      	ldr	r3, [r7, #16]
 801b4aa:	429a      	cmp	r2, r3
 801b4ac:	d3ef      	bcc.n	801b48e <protobuf_c_message_free_unpacked+0x16a>
							allocator
						);
				}
				do_free(allocator, arr);
 801b4ae:	68f9      	ldr	r1, [r7, #12]
 801b4b0:	6838      	ldr	r0, [r7, #0]
 801b4b2:	f7fc fc93 	bl	8017ddc <do_free>
 801b4b6:	e08b      	b.n	801b5d0 <protobuf_c_message_free_unpacked+0x2ac>
			}
		} else if (desc->fields[f].type == PROTOBUF_C_TYPE_STRING) {
 801b4b8:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801b4ba:	69da      	ldr	r2, [r3, #28]
 801b4bc:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 801b4be:	212c      	movs	r1, #44	; 0x2c
 801b4c0:	fb01 f303 	mul.w	r3, r1, r3
 801b4c4:	4413      	add	r3, r2
 801b4c6:	7a5b      	ldrb	r3, [r3, #9]
 801b4c8:	2b0e      	cmp	r3, #14
 801b4ca:	d11e      	bne.n	801b50a <protobuf_c_message_free_unpacked+0x1e6>
			char *str = STRUCT_MEMBER(char *, message,
 801b4cc:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801b4ce:	69da      	ldr	r2, [r3, #28]
 801b4d0:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 801b4d2:	212c      	movs	r1, #44	; 0x2c
 801b4d4:	fb01 f303 	mul.w	r3, r1, r3
 801b4d8:	4413      	add	r3, r2
 801b4da:	691b      	ldr	r3, [r3, #16]
 801b4dc:	687a      	ldr	r2, [r7, #4]
 801b4de:	4413      	add	r3, r2
 801b4e0:	681b      	ldr	r3, [r3, #0]
 801b4e2:	617b      	str	r3, [r7, #20]
						  desc->fields[f].offset);

			if (str && str != desc->fields[f].default_value)
 801b4e4:	697b      	ldr	r3, [r7, #20]
 801b4e6:	2b00      	cmp	r3, #0
 801b4e8:	d072      	beq.n	801b5d0 <protobuf_c_message_free_unpacked+0x2ac>
 801b4ea:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801b4ec:	69da      	ldr	r2, [r3, #28]
 801b4ee:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 801b4f0:	212c      	movs	r1, #44	; 0x2c
 801b4f2:	fb01 f303 	mul.w	r3, r1, r3
 801b4f6:	4413      	add	r3, r2
 801b4f8:	699b      	ldr	r3, [r3, #24]
 801b4fa:	697a      	ldr	r2, [r7, #20]
 801b4fc:	429a      	cmp	r2, r3
 801b4fe:	d067      	beq.n	801b5d0 <protobuf_c_message_free_unpacked+0x2ac>
				do_free(allocator, str);
 801b500:	6979      	ldr	r1, [r7, #20]
 801b502:	6838      	ldr	r0, [r7, #0]
 801b504:	f7fc fc6a 	bl	8017ddc <do_free>
 801b508:	e062      	b.n	801b5d0 <protobuf_c_message_free_unpacked+0x2ac>
		} else if (desc->fields[f].type == PROTOBUF_C_TYPE_BYTES) {
 801b50a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801b50c:	69da      	ldr	r2, [r3, #28]
 801b50e:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 801b510:	212c      	movs	r1, #44	; 0x2c
 801b512:	fb01 f303 	mul.w	r3, r1, r3
 801b516:	4413      	add	r3, r2
 801b518:	7a5b      	ldrb	r3, [r3, #9]
 801b51a:	2b0f      	cmp	r3, #15
 801b51c:	d12e      	bne.n	801b57c <protobuf_c_message_free_unpacked+0x258>
			void *data = STRUCT_MEMBER(ProtobufCBinaryData, message,
 801b51e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801b520:	69da      	ldr	r2, [r3, #28]
 801b522:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 801b524:	212c      	movs	r1, #44	; 0x2c
 801b526:	fb01 f303 	mul.w	r3, r1, r3
 801b52a:	4413      	add	r3, r2
 801b52c:	691b      	ldr	r3, [r3, #16]
 801b52e:	687a      	ldr	r2, [r7, #4]
 801b530:	4413      	add	r3, r2
 801b532:	685b      	ldr	r3, [r3, #4]
 801b534:	61fb      	str	r3, [r7, #28]
						   desc->fields[f].offset).data;
			const ProtobufCBinaryData *default_bd;

			default_bd = desc->fields[f].default_value;
 801b536:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801b538:	69da      	ldr	r2, [r3, #28]
 801b53a:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 801b53c:	212c      	movs	r1, #44	; 0x2c
 801b53e:	fb01 f303 	mul.w	r3, r1, r3
 801b542:	4413      	add	r3, r2
 801b544:	699b      	ldr	r3, [r3, #24]
 801b546:	61bb      	str	r3, [r7, #24]
			if (data != NULL &&
 801b548:	69fb      	ldr	r3, [r7, #28]
 801b54a:	2b00      	cmp	r3, #0
 801b54c:	d040      	beq.n	801b5d0 <protobuf_c_message_free_unpacked+0x2ac>
 801b54e:	69bb      	ldr	r3, [r7, #24]
 801b550:	2b00      	cmp	r3, #0
 801b552:	d004      	beq.n	801b55e <protobuf_c_message_free_unpacked+0x23a>
			    (default_bd == NULL ||
			     default_bd->data != data))
 801b554:	69bb      	ldr	r3, [r7, #24]
 801b556:	685b      	ldr	r3, [r3, #4]
			    (default_bd == NULL ||
 801b558:	69fa      	ldr	r2, [r7, #28]
 801b55a:	429a      	cmp	r2, r3
 801b55c:	d038      	beq.n	801b5d0 <protobuf_c_message_free_unpacked+0x2ac>
			{
				do_free(allocator, data);
 801b55e:	69f9      	ldr	r1, [r7, #28]
 801b560:	6838      	ldr	r0, [r7, #0]
 801b562:	f7fc fc3b 	bl	8017ddc <do_free>
 801b566:	e033      	b.n	801b5d0 <protobuf_c_message_free_unpacked+0x2ac>
 801b568:	28aaeef9 	.word	0x28aaeef9
 801b56c:	08024340 	.word	0x08024340
 801b570:	0802878c 	.word	0x0802878c
 801b574:	080242e8 	.word	0x080242e8
 801b578:	24000468 	.word	0x24000468
			}
		} else if (desc->fields[f].type == PROTOBUF_C_TYPE_MESSAGE) {
 801b57c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801b57e:	69da      	ldr	r2, [r3, #28]
 801b580:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 801b582:	212c      	movs	r1, #44	; 0x2c
 801b584:	fb01 f303 	mul.w	r3, r1, r3
 801b588:	4413      	add	r3, r2
 801b58a:	7a5b      	ldrb	r3, [r3, #9]
 801b58c:	2b10      	cmp	r3, #16
 801b58e:	d11f      	bne.n	801b5d0 <protobuf_c_message_free_unpacked+0x2ac>
			ProtobufCMessage *sm;

			sm = STRUCT_MEMBER(ProtobufCMessage *, message,
 801b590:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801b592:	69da      	ldr	r2, [r3, #28]
 801b594:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 801b596:	212c      	movs	r1, #44	; 0x2c
 801b598:	fb01 f303 	mul.w	r3, r1, r3
 801b59c:	4413      	add	r3, r2
 801b59e:	691b      	ldr	r3, [r3, #16]
 801b5a0:	687a      	ldr	r2, [r7, #4]
 801b5a2:	4413      	add	r3, r2
 801b5a4:	681b      	ldr	r3, [r3, #0]
 801b5a6:	623b      	str	r3, [r7, #32]
					   desc->fields[f].offset);
			if (sm && sm != desc->fields[f].default_value)
 801b5a8:	6a3b      	ldr	r3, [r7, #32]
 801b5aa:	2b00      	cmp	r3, #0
 801b5ac:	d010      	beq.n	801b5d0 <protobuf_c_message_free_unpacked+0x2ac>
 801b5ae:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801b5b0:	69da      	ldr	r2, [r3, #28]
 801b5b2:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 801b5b4:	212c      	movs	r1, #44	; 0x2c
 801b5b6:	fb01 f303 	mul.w	r3, r1, r3
 801b5ba:	4413      	add	r3, r2
 801b5bc:	699b      	ldr	r3, [r3, #24]
 801b5be:	6a3a      	ldr	r2, [r7, #32]
 801b5c0:	429a      	cmp	r2, r3
 801b5c2:	d005      	beq.n	801b5d0 <protobuf_c_message_free_unpacked+0x2ac>
				protobuf_c_message_free_unpacked(sm, allocator);
 801b5c4:	6839      	ldr	r1, [r7, #0]
 801b5c6:	6a38      	ldr	r0, [r7, #32]
 801b5c8:	f7ff feac 	bl	801b324 <protobuf_c_message_free_unpacked>
 801b5cc:	e000      	b.n	801b5d0 <protobuf_c_message_free_unpacked+0x2ac>
			continue;
 801b5ce:	bf00      	nop
	for (f = 0; f < desc->n_fields; f++) {
 801b5d0:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 801b5d2:	3301      	adds	r3, #1
 801b5d4:	637b      	str	r3, [r7, #52]	; 0x34
 801b5d6:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801b5d8:	699b      	ldr	r3, [r3, #24]
 801b5da:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 801b5dc:	429a      	cmp	r2, r3
 801b5de:	f4ff aec5 	bcc.w	801b36c <protobuf_c_message_free_unpacked+0x48>
		}
	}

	for (f = 0; f < message->n_unknown_fields; f++)
 801b5e2:	2300      	movs	r3, #0
 801b5e4:	637b      	str	r3, [r7, #52]	; 0x34
 801b5e6:	e00c      	b.n	801b602 <protobuf_c_message_free_unpacked+0x2de>
		do_free(allocator, message->unknown_fields[f].data);
 801b5e8:	687b      	ldr	r3, [r7, #4]
 801b5ea:	689a      	ldr	r2, [r3, #8]
 801b5ec:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 801b5ee:	011b      	lsls	r3, r3, #4
 801b5f0:	4413      	add	r3, r2
 801b5f2:	68db      	ldr	r3, [r3, #12]
 801b5f4:	4619      	mov	r1, r3
 801b5f6:	6838      	ldr	r0, [r7, #0]
 801b5f8:	f7fc fbf0 	bl	8017ddc <do_free>
	for (f = 0; f < message->n_unknown_fields; f++)
 801b5fc:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 801b5fe:	3301      	adds	r3, #1
 801b600:	637b      	str	r3, [r7, #52]	; 0x34
 801b602:	687b      	ldr	r3, [r7, #4]
 801b604:	685b      	ldr	r3, [r3, #4]
 801b606:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 801b608:	429a      	cmp	r2, r3
 801b60a:	d3ed      	bcc.n	801b5e8 <protobuf_c_message_free_unpacked+0x2c4>
	if (message->unknown_fields != NULL)
 801b60c:	687b      	ldr	r3, [r7, #4]
 801b60e:	689b      	ldr	r3, [r3, #8]
 801b610:	2b00      	cmp	r3, #0
 801b612:	d005      	beq.n	801b620 <protobuf_c_message_free_unpacked+0x2fc>
		do_free(allocator, message->unknown_fields);
 801b614:	687b      	ldr	r3, [r7, #4]
 801b616:	689b      	ldr	r3, [r3, #8]
 801b618:	4619      	mov	r1, r3
 801b61a:	6838      	ldr	r0, [r7, #0]
 801b61c:	f7fc fbde 	bl	8017ddc <do_free>

	do_free(allocator, message);
 801b620:	6879      	ldr	r1, [r7, #4]
 801b622:	6838      	ldr	r0, [r7, #0]
 801b624:	f7fc fbda 	bl	8017ddc <do_free>
 801b628:	e000      	b.n	801b62c <protobuf_c_message_free_unpacked+0x308>
		return;
 801b62a:	bf00      	nop
}
 801b62c:	3738      	adds	r7, #56	; 0x38
 801b62e:	46bd      	mov	sp, r7
 801b630:	bd80      	pop	{r7, pc}
 801b632:	bf00      	nop

0801b634 <protobuf_c_message_init>:

void
protobuf_c_message_init(const ProtobufCMessageDescriptor * descriptor,
			void *message)
{
 801b634:	b580      	push	{r7, lr}
 801b636:	b082      	sub	sp, #8
 801b638:	af00      	add	r7, sp, #0
 801b63a:	6078      	str	r0, [r7, #4]
 801b63c:	6039      	str	r1, [r7, #0]
	descriptor->message_init((ProtobufCMessage *) (message));
 801b63e:	687b      	ldr	r3, [r7, #4]
 801b640:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 801b642:	6838      	ldr	r0, [r7, #0]
 801b644:	4798      	blx	r3
}
 801b646:	bf00      	nop
 801b648:	3708      	adds	r7, #8
 801b64a:	46bd      	mov	sp, r7
 801b64c:	bd80      	pop	{r7, pc}
	...

0801b650 <wifi_get_mac>:
#endif


// Function returns MAC address of ESP32 station/softap
int wifi_get_mac (int mode, char *mac)
{
 801b650:	b580      	push	{r7, lr}
 801b652:	b090      	sub	sp, #64	; 0x40
 801b654:	af00      	add	r7, sp, #0
 801b656:	6078      	str	r0, [r7, #4]
 801b658:	6039      	str	r1, [r7, #0]
    EspHostedConfigPayload req, *resp = NULL;
 801b65a:	2300      	movs	r3, #0
 801b65c:	63fb      	str	r3, [r7, #60]	; 0x3c
    uint32_t tx_len = 0, rx_len = 0;
 801b65e:	2300      	movs	r3, #0
 801b660:	63bb      	str	r3, [r7, #56]	; 0x38
 801b662:	2300      	movs	r3, #0
 801b664:	60fb      	str	r3, [r7, #12]
    uint8_t *tx_data = NULL, *rx_data = NULL;
 801b666:	2300      	movs	r3, #0
 801b668:	637b      	str	r3, [r7, #52]	; 0x34
 801b66a:	2300      	movs	r3, #0
 801b66c:	633b      	str	r3, [r7, #48]	; 0x30

    if (!mac || (mode <= WIFI_MODE_NONE) || (mode >= WIFI_MODE_APSTA)) {
 801b66e:	683b      	ldr	r3, [r7, #0]
 801b670:	2b00      	cmp	r3, #0
 801b672:	d005      	beq.n	801b680 <wifi_get_mac+0x30>
 801b674:	687b      	ldr	r3, [r7, #4]
 801b676:	2b00      	cmp	r3, #0
 801b678:	dd02      	ble.n	801b680 <wifi_get_mac+0x30>
 801b67a:	687b      	ldr	r3, [r7, #4]
 801b67c:	2b02      	cmp	r3, #2
 801b67e:	dd08      	ble.n	801b692 <wifi_get_mac+0x42>
        command_log("Invalid parameter\n");
 801b680:	486f      	ldr	r0, [pc, #444]	; (801b840 <wifi_get_mac+0x1f0>)
 801b682:	f004 fe0f 	bl	80202a4 <puts>
 801b686:	200d      	movs	r0, #13
 801b688:	f004 fd88 	bl	802019c <putchar>
        return FAILURE;
 801b68c:	f04f 33ff 	mov.w	r3, #4294967295
 801b690:	e0d2      	b.n	801b838 <wifi_get_mac+0x1e8>
    }

    esp_hosted_config_payload__init (&req);
 801b692:	f107 0310 	add.w	r3, r7, #16
 801b696:	4618      	mov	r0, r3
 801b698:	f7fc fae8 	bl	8017c6c <esp_hosted_config_payload__init>
    req.has_msg = true;
 801b69c:	2301      	movs	r3, #1
 801b69e:	61fb      	str	r3, [r7, #28]
    req.msg = ESP_HOSTED_CONFIG_MSG_TYPE__TypeCmdGetMACAddress;
 801b6a0:	2300      	movs	r3, #0
 801b6a2:	623b      	str	r3, [r7, #32]
    req.payload_case = ESP_HOSTED_CONFIG_PAYLOAD__PAYLOAD_CMD_GET_MAC_ADDRESS ;
 801b6a4:	230a      	movs	r3, #10
 801b6a6:	f887 3024 	strb.w	r3, [r7, #36]	; 0x24

    EspHostedCmdGetMacAddress *req_payload = (EspHostedCmdGetMacAddress *)
        esp_hosted_calloc(1, sizeof(EspHostedCmdGetMacAddress));
 801b6aa:	2114      	movs	r1, #20
 801b6ac:	2001      	movs	r0, #1
 801b6ae:	f001 fed3 	bl	801d458 <esp_hosted_calloc>
 801b6b2:	62f8      	str	r0, [r7, #44]	; 0x2c
    if (!req_payload) {
 801b6b4:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 801b6b6:	2b00      	cmp	r3, #0
 801b6b8:	d108      	bne.n	801b6cc <wifi_get_mac+0x7c>
        command_log("Failed to allocate memory for req_payload\n");
 801b6ba:	4862      	ldr	r0, [pc, #392]	; (801b844 <wifi_get_mac+0x1f4>)
 801b6bc:	f004 fdf2 	bl	80202a4 <puts>
 801b6c0:	200d      	movs	r0, #13
 801b6c2:	f004 fd6b 	bl	802019c <putchar>
        return FAILURE;
 801b6c6:	f04f 33ff 	mov.w	r3, #4294967295
 801b6ca:	e0b5      	b.n	801b838 <wifi_get_mac+0x1e8>
    }

    esp_hosted_cmd_get_mac_address__init(req_payload);
 801b6cc:	6af8      	ldr	r0, [r7, #44]	; 0x2c
 801b6ce:	f7fb ffef 	bl	80176b0 <esp_hosted_cmd_get_mac_address__init>
    req_payload->has_mode = true;
 801b6d2:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 801b6d4:	2201      	movs	r2, #1
 801b6d6:	60da      	str	r2, [r3, #12]
    req_payload->mode = mode;
 801b6d8:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 801b6da:	687a      	ldr	r2, [r7, #4]
 801b6dc:	611a      	str	r2, [r3, #16]
    req.cmd_get_mac_address = req_payload;
 801b6de:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 801b6e0:	62bb      	str	r3, [r7, #40]	; 0x28
    tx_len = esp_hosted_config_payload__get_packed_size(&req);
 801b6e2:	f107 0310 	add.w	r3, r7, #16
 801b6e6:	4618      	mov	r0, r3
 801b6e8:	f7fc fad6 	bl	8017c98 <esp_hosted_config_payload__get_packed_size>
 801b6ec:	63b8      	str	r0, [r7, #56]	; 0x38
    if (!tx_len) {
 801b6ee:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 801b6f0:	2b00      	cmp	r3, #0
 801b6f2:	d106      	bne.n	801b702 <wifi_get_mac+0xb2>
        command_log("Invalid tx length\n");
 801b6f4:	4854      	ldr	r0, [pc, #336]	; (801b848 <wifi_get_mac+0x1f8>)
 801b6f6:	f004 fdd5 	bl	80202a4 <puts>
 801b6fa:	200d      	movs	r0, #13
 801b6fc:	f004 fd4e 	bl	802019c <putchar>
        goto err3;
 801b700:	e090      	b.n	801b824 <wifi_get_mac+0x1d4>
    }

    tx_data = (uint8_t *)esp_hosted_calloc(1, tx_len);
 801b702:	6bb9      	ldr	r1, [r7, #56]	; 0x38
 801b704:	2001      	movs	r0, #1
 801b706:	f001 fea7 	bl	801d458 <esp_hosted_calloc>
 801b70a:	6378      	str	r0, [r7, #52]	; 0x34
    if (!tx_data) {
 801b70c:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 801b70e:	2b00      	cmp	r3, #0
 801b710:	d106      	bne.n	801b720 <wifi_get_mac+0xd0>
        command_log("Failed to allocate memory for tx_data\n");
 801b712:	484e      	ldr	r0, [pc, #312]	; (801b84c <wifi_get_mac+0x1fc>)
 801b714:	f004 fdc6 	bl	80202a4 <puts>
 801b718:	200d      	movs	r0, #13
 801b71a:	f004 fd3f 	bl	802019c <putchar>
        goto err3;
 801b71e:	e081      	b.n	801b824 <wifi_get_mac+0x1d4>
    }

    esp_hosted_config_payload__pack(&req, tx_data);
 801b720:	f107 0310 	add.w	r3, r7, #16
 801b724:	6b79      	ldr	r1, [r7, #52]	; 0x34
 801b726:	4618      	mov	r0, r3
 801b728:	f7fc fad6 	bl	8017cd8 <esp_hosted_config_payload__pack>

    rx_data = transport_pserial_data_handler(tx_data, tx_len,
 801b72c:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 801b72e:	b299      	uxth	r1, r3
 801b730:	f107 030c 	add.w	r3, r7, #12
 801b734:	221e      	movs	r2, #30
 801b736:	6b78      	ldr	r0, [r7, #52]	; 0x34
 801b738:	f000 fe56 	bl	801c3e8 <transport_pserial_data_handler>
 801b73c:	6338      	str	r0, [r7, #48]	; 0x30
            TIMEOUT_PSERIAL_RESP, &rx_len);
    if (!rx_data || !rx_len) {
 801b73e:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801b740:	2b00      	cmp	r3, #0
 801b742:	d002      	beq.n	801b74a <wifi_get_mac+0xfa>
 801b744:	68fb      	ldr	r3, [r7, #12]
 801b746:	2b00      	cmp	r3, #0
 801b748:	d106      	bne.n	801b758 <wifi_get_mac+0x108>
        command_log("Failed to process rx data\n");
 801b74a:	4841      	ldr	r0, [pc, #260]	; (801b850 <wifi_get_mac+0x200>)
 801b74c:	f004 fdaa 	bl	80202a4 <puts>
 801b750:	200d      	movs	r0, #13
 801b752:	f004 fd23 	bl	802019c <putchar>
        goto err2;
 801b756:	e05b      	b.n	801b810 <wifi_get_mac+0x1c0>
    }

    resp = esp_hosted_config_payload__unpack(NULL, rx_len, rx_data);
 801b758:	68fb      	ldr	r3, [r7, #12]
 801b75a:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 801b75c:	4619      	mov	r1, r3
 801b75e:	2000      	movs	r0, #0
 801b760:	f7fc fadc 	bl	8017d1c <esp_hosted_config_payload__unpack>
 801b764:	63f8      	str	r0, [r7, #60]	; 0x3c
    if ((!resp) || (!resp->resp_get_mac_address) ||
 801b766:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 801b768:	2b00      	cmp	r3, #0
 801b76a:	d008      	beq.n	801b77e <wifi_get_mac+0x12e>
 801b76c:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 801b76e:	699b      	ldr	r3, [r3, #24]
 801b770:	2b00      	cmp	r3, #0
 801b772:	d004      	beq.n	801b77e <wifi_get_mac+0x12e>
            (!resp->resp_get_mac_address->mac.data)) {
 801b774:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 801b776:	699b      	ldr	r3, [r3, #24]
 801b778:	695b      	ldr	r3, [r3, #20]
    if ((!resp) || (!resp->resp_get_mac_address) ||
 801b77a:	2b00      	cmp	r3, #0
 801b77c:	d106      	bne.n	801b78c <wifi_get_mac+0x13c>
        command_log("Failed to unpack rx_data\n");
 801b77e:	4835      	ldr	r0, [pc, #212]	; (801b854 <wifi_get_mac+0x204>)
 801b780:	f004 fd90 	bl	80202a4 <puts>
 801b784:	200d      	movs	r0, #13
 801b786:	f004 fd09 	bl	802019c <putchar>
        goto err1;
 801b78a:	e035      	b.n	801b7f8 <wifi_get_mac+0x1a8>
    }

    if (resp->resp_get_mac_address->resp) {
 801b78c:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 801b78e:	699b      	ldr	r3, [r3, #24]
 801b790:	69db      	ldr	r3, [r3, #28]
 801b792:	2b00      	cmp	r3, #0
 801b794:	d006      	beq.n	801b7a4 <wifi_get_mac+0x154>
        command_log("Failed to get MAC address\n");
 801b796:	4830      	ldr	r0, [pc, #192]	; (801b858 <wifi_get_mac+0x208>)
 801b798:	f004 fd84 	bl	80202a4 <puts>
 801b79c:	200d      	movs	r0, #13
 801b79e:	f004 fcfd 	bl	802019c <putchar>
        goto err1;
 801b7a2:	e029      	b.n	801b7f8 <wifi_get_mac+0x1a8>
    }
    strncpy(mac, (char *)resp->resp_get_mac_address->mac.data, MAC_LENGTH);
 801b7a4:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 801b7a6:	699b      	ldr	r3, [r3, #24]
 801b7a8:	695b      	ldr	r3, [r3, #20]
 801b7aa:	2213      	movs	r2, #19
 801b7ac:	4619      	mov	r1, r3
 801b7ae:	6838      	ldr	r0, [r7, #0]
 801b7b0:	f005 f890 	bl	80208d4 <strncpy>
    mac[MAC_LENGTH-1] = '\0';
 801b7b4:	683b      	ldr	r3, [r7, #0]
 801b7b6:	3312      	adds	r3, #18
 801b7b8:	2200      	movs	r2, #0
 801b7ba:	701a      	strb	r2, [r3, #0]

    mem_free(tx_data);
 801b7bc:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 801b7be:	2b00      	cmp	r3, #0
 801b7c0:	d004      	beq.n	801b7cc <wifi_get_mac+0x17c>
 801b7c2:	6b78      	ldr	r0, [r7, #52]	; 0x34
 801b7c4:	f001 fe60 	bl	801d488 <esp_hosted_free>
 801b7c8:	2300      	movs	r3, #0
 801b7ca:	637b      	str	r3, [r7, #52]	; 0x34
    mem_free(rx_data);
 801b7cc:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801b7ce:	2b00      	cmp	r3, #0
 801b7d0:	d004      	beq.n	801b7dc <wifi_get_mac+0x18c>
 801b7d2:	6b38      	ldr	r0, [r7, #48]	; 0x30
 801b7d4:	f001 fe58 	bl	801d488 <esp_hosted_free>
 801b7d8:	2300      	movs	r3, #0
 801b7da:	633b      	str	r3, [r7, #48]	; 0x30
    mem_free(req_payload);
 801b7dc:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 801b7de:	2b00      	cmp	r3, #0
 801b7e0:	d004      	beq.n	801b7ec <wifi_get_mac+0x19c>
 801b7e2:	6af8      	ldr	r0, [r7, #44]	; 0x2c
 801b7e4:	f001 fe50 	bl	801d488 <esp_hosted_free>
 801b7e8:	2300      	movs	r3, #0
 801b7ea:	62fb      	str	r3, [r7, #44]	; 0x2c
    esp_hosted_config_payload__free_unpacked(resp, NULL);
 801b7ec:	2100      	movs	r1, #0
 801b7ee:	6bf8      	ldr	r0, [r7, #60]	; 0x3c
 801b7f0:	f7fc faa8 	bl	8017d44 <esp_hosted_config_payload__free_unpacked>
    return SUCCESS;
 801b7f4:	2300      	movs	r3, #0
 801b7f6:	e01f      	b.n	801b838 <wifi_get_mac+0x1e8>

err1:
    mem_free(rx_data);
 801b7f8:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801b7fa:	2b00      	cmp	r3, #0
 801b7fc:	d004      	beq.n	801b808 <wifi_get_mac+0x1b8>
 801b7fe:	6b38      	ldr	r0, [r7, #48]	; 0x30
 801b800:	f001 fe42 	bl	801d488 <esp_hosted_free>
 801b804:	2300      	movs	r3, #0
 801b806:	633b      	str	r3, [r7, #48]	; 0x30
    esp_hosted_config_payload__free_unpacked(resp, NULL);
 801b808:	2100      	movs	r1, #0
 801b80a:	6bf8      	ldr	r0, [r7, #60]	; 0x3c
 801b80c:	f7fc fa9a 	bl	8017d44 <esp_hosted_config_payload__free_unpacked>
err2:
    mem_free(tx_data);
 801b810:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 801b812:	2b00      	cmp	r3, #0
 801b814:	d005      	beq.n	801b822 <wifi_get_mac+0x1d2>
 801b816:	6b78      	ldr	r0, [r7, #52]	; 0x34
 801b818:	f001 fe36 	bl	801d488 <esp_hosted_free>
 801b81c:	2300      	movs	r3, #0
 801b81e:	637b      	str	r3, [r7, #52]	; 0x34
 801b820:	e000      	b.n	801b824 <wifi_get_mac+0x1d4>
err3:
 801b822:	bf00      	nop
    mem_free(req_payload);
 801b824:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 801b826:	2b00      	cmp	r3, #0
 801b828:	d004      	beq.n	801b834 <wifi_get_mac+0x1e4>
 801b82a:	6af8      	ldr	r0, [r7, #44]	; 0x2c
 801b82c:	f001 fe2c 	bl	801d488 <esp_hosted_free>
 801b830:	2300      	movs	r3, #0
 801b832:	62fb      	str	r3, [r7, #44]	; 0x2c
    return FAILURE;
 801b834:	f04f 33ff 	mov.w	r3, #4294967295
}
 801b838:	4618      	mov	r0, r3
 801b83a:	3740      	adds	r7, #64	; 0x40
 801b83c:	46bd      	mov	sp, r7
 801b83e:	bd80      	pop	{r7, pc}
 801b840:	08024484 	.word	0x08024484
 801b844:	08024498 	.word	0x08024498
 801b848:	080244c4 	.word	0x080244c4
 801b84c:	080244d8 	.word	0x080244d8
 801b850:	08024500 	.word	0x08024500
 801b854:	0802451c 	.word	0x0802451c
 801b858:	08024538 	.word	0x08024538

0801b85c <wifi_set_ap_config>:
    return FAILURE;
}

// Function connects ESP32 station to given AP configuration.
int wifi_set_ap_config (esp_hosted_control_config_t ap_config)
{
 801b85c:	b084      	sub	sp, #16
 801b85e:	b580      	push	{r7, lr}
 801b860:	b08e      	sub	sp, #56	; 0x38
 801b862:	af00      	add	r7, sp, #0
 801b864:	f107 0c40 	add.w	ip, r7, #64	; 0x40
 801b868:	e88c 000f 	stmia.w	ip, {r0, r1, r2, r3}
    EspHostedConfigPayload req, *resp = NULL;
 801b86c:	2300      	movs	r3, #0
 801b86e:	637b      	str	r3, [r7, #52]	; 0x34
    uint32_t tx_len = 0, rx_len = 0;
 801b870:	2300      	movs	r3, #0
 801b872:	633b      	str	r3, [r7, #48]	; 0x30
 801b874:	2300      	movs	r3, #0
 801b876:	607b      	str	r3, [r7, #4]
    uint8_t *tx_data = NULL, *rx_data = NULL;
 801b878:	2300      	movs	r3, #0
 801b87a:	62fb      	str	r3, [r7, #44]	; 0x2c
 801b87c:	2300      	movs	r3, #0
 801b87e:	62bb      	str	r3, [r7, #40]	; 0x28


    if ((strlen((char *)&ap_config.station.ssid) > MAX_SSID_LENGTH) ||
 801b880:	f107 0040 	add.w	r0, r7, #64	; 0x40
 801b884:	f7e4 fe52 	bl	800052c <strlen>
 801b888:	4603      	mov	r3, r0
 801b88a:	2b20      	cmp	r3, #32
 801b88c:	d804      	bhi.n	801b898 <wifi_set_ap_config+0x3c>
        (!strlen((char *)&ap_config.station.ssid))) {
 801b88e:	f107 0340 	add.w	r3, r7, #64	; 0x40
 801b892:	781b      	ldrb	r3, [r3, #0]
    if ((strlen((char *)&ap_config.station.ssid) > MAX_SSID_LENGTH) ||
 801b894:	2b00      	cmp	r3, #0
 801b896:	d108      	bne.n	801b8aa <wifi_set_ap_config+0x4e>
        command_log("Invalid SSID length\n");
 801b898:	48a7      	ldr	r0, [pc, #668]	; (801bb38 <wifi_set_ap_config+0x2dc>)
 801b89a:	f004 fd03 	bl	80202a4 <puts>
 801b89e:	200d      	movs	r0, #13
 801b8a0:	f004 fc7c 	bl	802019c <putchar>
        return FAILURE;
 801b8a4:	f04f 33ff 	mov.w	r3, #4294967295
 801b8a8:	e167      	b.n	801bb7a <wifi_set_ap_config+0x31e>
    }

    if (strlen((char *)&ap_config.station.pwd) > MAX_PWD_LENGTH) {
 801b8aa:	f107 0360 	add.w	r3, r7, #96	; 0x60
 801b8ae:	4618      	mov	r0, r3
 801b8b0:	f7e4 fe3c 	bl	800052c <strlen>
 801b8b4:	4603      	mov	r3, r0
 801b8b6:	2b40      	cmp	r3, #64	; 0x40
 801b8b8:	d908      	bls.n	801b8cc <wifi_set_ap_config+0x70>
        command_log("Invalid password length\n");
 801b8ba:	48a0      	ldr	r0, [pc, #640]	; (801bb3c <wifi_set_ap_config+0x2e0>)
 801b8bc:	f004 fcf2 	bl	80202a4 <puts>
 801b8c0:	200d      	movs	r0, #13
 801b8c2:	f004 fc6b 	bl	802019c <putchar>
        return FAILURE;
 801b8c6:	f04f 33ff 	mov.w	r3, #4294967295
 801b8ca:	e156      	b.n	801bb7a <wifi_set_ap_config+0x31e>
    }

    if (strlen((char *)&ap_config.station.bssid) > MAX_BSSID_LENGTH) {
 801b8cc:	f107 03a0 	add.w	r3, r7, #160	; 0xa0
 801b8d0:	4618      	mov	r0, r3
 801b8d2:	f7e4 fe2b 	bl	800052c <strlen>
 801b8d6:	4603      	mov	r3, r0
 801b8d8:	2b11      	cmp	r3, #17
 801b8da:	d908      	bls.n	801b8ee <wifi_set_ap_config+0x92>
        command_log("Invalid BSSID length\n");
 801b8dc:	4898      	ldr	r0, [pc, #608]	; (801bb40 <wifi_set_ap_config+0x2e4>)
 801b8de:	f004 fce1 	bl	80202a4 <puts>
 801b8e2:	200d      	movs	r0, #13
 801b8e4:	f004 fc5a 	bl	802019c <putchar>
        return FAILURE;
 801b8e8:	f04f 33ff 	mov.w	r3, #4294967295
 801b8ec:	e145      	b.n	801bb7a <wifi_set_ap_config+0x31e>
    }

    esp_hosted_config_payload__init (&req);
 801b8ee:	f107 0308 	add.w	r3, r7, #8
 801b8f2:	4618      	mov	r0, r3
 801b8f4:	f7fc f9ba 	bl	8017c6c <esp_hosted_config_payload__init>
    req.has_msg = true;
 801b8f8:	2301      	movs	r3, #1
 801b8fa:	617b      	str	r3, [r7, #20]
    req.msg = ESP_HOSTED_CONFIG_MSG_TYPE__TypeCmdSetAPConfig ;
 801b8fc:	2308      	movs	r3, #8
 801b8fe:	61bb      	str	r3, [r7, #24]
    req.payload_case = ESP_HOSTED_CONFIG_PAYLOAD__PAYLOAD_CMD_SET_AP_CONFIG;
 801b900:	2312      	movs	r3, #18
 801b902:	773b      	strb	r3, [r7, #28]

    EspHostedCmdSetAPConfig *req_payload = (EspHostedCmdSetAPConfig *)
        esp_hosted_calloc(1, sizeof(EspHostedCmdSetAPConfig));
 801b904:	2128      	movs	r1, #40	; 0x28
 801b906:	2001      	movs	r0, #1
 801b908:	f001 fda6 	bl	801d458 <esp_hosted_calloc>
 801b90c:	6278      	str	r0, [r7, #36]	; 0x24
    if (!req_payload) {
 801b90e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801b910:	2b00      	cmp	r3, #0
 801b912:	d108      	bne.n	801b926 <wifi_set_ap_config+0xca>
        command_log("Failed to allocate memory for req_payload\n");
 801b914:	488b      	ldr	r0, [pc, #556]	; (801bb44 <wifi_set_ap_config+0x2e8>)
 801b916:	f004 fcc5 	bl	80202a4 <puts>
 801b91a:	200d      	movs	r0, #13
 801b91c:	f004 fc3e 	bl	802019c <putchar>
        return FAILURE;
 801b920:	f04f 33ff 	mov.w	r3, #4294967295
 801b924:	e129      	b.n	801bb7a <wifi_set_ap_config+0x31e>
    }

    esp_hosted_cmd_set_apconfig__init(req_payload);
 801b926:	6a78      	ldr	r0, [r7, #36]	; 0x24
 801b928:	f7fb ffb0 	bl	801788c <esp_hosted_cmd_set_apconfig__init>
    req_payload->ssid  = (char *)&ap_config.station.ssid;
 801b92c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801b92e:	f107 0240 	add.w	r2, r7, #64	; 0x40
 801b932:	60da      	str	r2, [r3, #12]
    req_payload->pwd   = (char *)&ap_config.station.pwd;
 801b934:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801b936:	f107 0260 	add.w	r2, r7, #96	; 0x60
 801b93a:	611a      	str	r2, [r3, #16]
    req_payload->bssid = (char *)&ap_config.station.bssid;
 801b93c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801b93e:	f107 02a0 	add.w	r2, r7, #160	; 0xa0
 801b942:	615a      	str	r2, [r3, #20]
    req_payload->has_is_wpa3_supported = true;
 801b944:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801b946:	2201      	movs	r2, #1
 801b948:	619a      	str	r2, [r3, #24]
    req_payload->is_wpa3_supported = ap_config.station.is_wpa3_supported;
 801b94a:	f897 30b1 	ldrb.w	r3, [r7, #177]	; 0xb1
 801b94e:	461a      	mov	r2, r3
 801b950:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801b952:	61da      	str	r2, [r3, #28]
    req_payload->has_listen_interval = true;
 801b954:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801b956:	2201      	movs	r2, #1
 801b958:	621a      	str	r2, [r3, #32]
    req_payload->listen_interval = ap_config.station.listen_interval;
 801b95a:	f8b7 30c0 	ldrh.w	r3, [r7, #192]	; 0xc0
 801b95e:	461a      	mov	r2, r3
 801b960:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801b962:	625a      	str	r2, [r3, #36]	; 0x24
    req.cmd_set_ap_config = req_payload;
 801b964:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801b966:	623b      	str	r3, [r7, #32]

    tx_len = esp_hosted_config_payload__get_packed_size(&req);
 801b968:	f107 0308 	add.w	r3, r7, #8
 801b96c:	4618      	mov	r0, r3
 801b96e:	f7fc f993 	bl	8017c98 <esp_hosted_config_payload__get_packed_size>
 801b972:	6338      	str	r0, [r7, #48]	; 0x30
    if (!tx_len) {
 801b974:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801b976:	2b00      	cmp	r3, #0
 801b978:	d106      	bne.n	801b988 <wifi_set_ap_config+0x12c>
        command_log("Invalid tx length\n");
 801b97a:	4873      	ldr	r0, [pc, #460]	; (801bb48 <wifi_set_ap_config+0x2ec>)
 801b97c:	f004 fc92 	bl	80202a4 <puts>
 801b980:	200d      	movs	r0, #13
 801b982:	f004 fc0b 	bl	802019c <putchar>
        goto err3;
 801b986:	e0ee      	b.n	801bb66 <wifi_set_ap_config+0x30a>
    }

    tx_data = (uint8_t *)esp_hosted_calloc(1, tx_len);
 801b988:	6b39      	ldr	r1, [r7, #48]	; 0x30
 801b98a:	2001      	movs	r0, #1
 801b98c:	f001 fd64 	bl	801d458 <esp_hosted_calloc>
 801b990:	62f8      	str	r0, [r7, #44]	; 0x2c
    if (!tx_data) {
 801b992:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 801b994:	2b00      	cmp	r3, #0
 801b996:	d106      	bne.n	801b9a6 <wifi_set_ap_config+0x14a>
        command_log("Failed to allocate memory for tx_data\n");
 801b998:	486c      	ldr	r0, [pc, #432]	; (801bb4c <wifi_set_ap_config+0x2f0>)
 801b99a:	f004 fc83 	bl	80202a4 <puts>
 801b99e:	200d      	movs	r0, #13
 801b9a0:	f004 fbfc 	bl	802019c <putchar>
        goto err3;
 801b9a4:	e0df      	b.n	801bb66 <wifi_set_ap_config+0x30a>
    }

    esp_hosted_config_payload__pack(&req, tx_data);
 801b9a6:	f107 0308 	add.w	r3, r7, #8
 801b9aa:	6af9      	ldr	r1, [r7, #44]	; 0x2c
 801b9ac:	4618      	mov	r0, r3
 801b9ae:	f7fc f993 	bl	8017cd8 <esp_hosted_config_payload__pack>

    rx_data = transport_pserial_data_handler(tx_data, tx_len,
 801b9b2:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801b9b4:	b299      	uxth	r1, r3
 801b9b6:	1d3b      	adds	r3, r7, #4
 801b9b8:	221e      	movs	r2, #30
 801b9ba:	6af8      	ldr	r0, [r7, #44]	; 0x2c
 801b9bc:	f000 fd14 	bl	801c3e8 <transport_pserial_data_handler>
 801b9c0:	62b8      	str	r0, [r7, #40]	; 0x28
            TIMEOUT_PSERIAL_RESP, &rx_len);
    if (!rx_data || !rx_len) {
 801b9c2:	6abb      	ldr	r3, [r7, #40]	; 0x28
 801b9c4:	2b00      	cmp	r3, #0
 801b9c6:	d002      	beq.n	801b9ce <wifi_set_ap_config+0x172>
 801b9c8:	687b      	ldr	r3, [r7, #4]
 801b9ca:	2b00      	cmp	r3, #0
 801b9cc:	d106      	bne.n	801b9dc <wifi_set_ap_config+0x180>
        command_log("Failed to process rx data\n");
 801b9ce:	4860      	ldr	r0, [pc, #384]	; (801bb50 <wifi_set_ap_config+0x2f4>)
 801b9d0:	f004 fc68 	bl	80202a4 <puts>
 801b9d4:	200d      	movs	r0, #13
 801b9d6:	f004 fbe1 	bl	802019c <putchar>
        goto err2;
 801b9da:	e0a3      	b.n	801bb24 <wifi_set_ap_config+0x2c8>
    }

    resp = esp_hosted_config_payload__unpack(NULL, rx_len, rx_data);
 801b9dc:	687b      	ldr	r3, [r7, #4]
 801b9de:	6aba      	ldr	r2, [r7, #40]	; 0x28
 801b9e0:	4619      	mov	r1, r3
 801b9e2:	2000      	movs	r0, #0
 801b9e4:	f7fc f99a 	bl	8017d1c <esp_hosted_config_payload__unpack>
 801b9e8:	6378      	str	r0, [r7, #52]	; 0x34
    if ((!resp) || (!resp->resp_set_ap_config)) {
 801b9ea:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 801b9ec:	2b00      	cmp	r3, #0
 801b9ee:	d003      	beq.n	801b9f8 <wifi_set_ap_config+0x19c>
 801b9f0:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 801b9f2:	699b      	ldr	r3, [r3, #24]
 801b9f4:	2b00      	cmp	r3, #0
 801b9f6:	d106      	bne.n	801ba06 <wifi_set_ap_config+0x1aa>
        command_log("Failed to unpack rx_data\n");
 801b9f8:	4856      	ldr	r0, [pc, #344]	; (801bb54 <wifi_set_ap_config+0x2f8>)
 801b9fa:	f004 fc53 	bl	80202a4 <puts>
 801b9fe:	200d      	movs	r0, #13
 801ba00:	f004 fbcc 	bl	802019c <putchar>
        goto err1;
 801ba04:	e082      	b.n	801bb0c <wifi_set_ap_config+0x2b0>
    }

    if (resp->resp_set_ap_config->resp == INVALID_PASSWORD) {
 801ba06:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 801ba08:	699b      	ldr	r3, [r3, #24]
 801ba0a:	691b      	ldr	r3, [r3, #16]
 801ba0c:	2b03      	cmp	r3, #3
 801ba0e:	d128      	bne.n	801ba62 <wifi_set_ap_config+0x206>
        command_log("Invalid password %s for SSID %s\n",
 801ba10:	f107 0360 	add.w	r3, r7, #96	; 0x60
 801ba14:	f107 0240 	add.w	r2, r7, #64	; 0x40
 801ba18:	4619      	mov	r1, r3
 801ba1a:	484f      	ldr	r0, [pc, #316]	; (801bb58 <wifi_set_ap_config+0x2fc>)
 801ba1c:	f004 fba6 	bl	802016c <iprintf>
 801ba20:	200d      	movs	r0, #13
 801ba22:	f004 fbbb 	bl	802019c <putchar>
                (char *)&ap_config.station.pwd, (char *)&ap_config.station.ssid);
        mem_free(tx_data);
 801ba26:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 801ba28:	2b00      	cmp	r3, #0
 801ba2a:	d004      	beq.n	801ba36 <wifi_set_ap_config+0x1da>
 801ba2c:	6af8      	ldr	r0, [r7, #44]	; 0x2c
 801ba2e:	f001 fd2b 	bl	801d488 <esp_hosted_free>
 801ba32:	2300      	movs	r3, #0
 801ba34:	62fb      	str	r3, [r7, #44]	; 0x2c
        mem_free(rx_data);
 801ba36:	6abb      	ldr	r3, [r7, #40]	; 0x28
 801ba38:	2b00      	cmp	r3, #0
 801ba3a:	d004      	beq.n	801ba46 <wifi_set_ap_config+0x1ea>
 801ba3c:	6ab8      	ldr	r0, [r7, #40]	; 0x28
 801ba3e:	f001 fd23 	bl	801d488 <esp_hosted_free>
 801ba42:	2300      	movs	r3, #0
 801ba44:	62bb      	str	r3, [r7, #40]	; 0x28
        mem_free(req_payload);
 801ba46:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801ba48:	2b00      	cmp	r3, #0
 801ba4a:	d004      	beq.n	801ba56 <wifi_set_ap_config+0x1fa>
 801ba4c:	6a78      	ldr	r0, [r7, #36]	; 0x24
 801ba4e:	f001 fd1b 	bl	801d488 <esp_hosted_free>
 801ba52:	2300      	movs	r3, #0
 801ba54:	627b      	str	r3, [r7, #36]	; 0x24
        esp_hosted_config_payload__free_unpacked(resp, NULL);
 801ba56:	2100      	movs	r1, #0
 801ba58:	6b78      	ldr	r0, [r7, #52]	; 0x34
 801ba5a:	f7fc f973 	bl	8017d44 <esp_hosted_config_payload__free_unpacked>
        return INVALID_PASSWORD;
 801ba5e:	2303      	movs	r3, #3
 801ba60:	e08b      	b.n	801bb7a <wifi_set_ap_config+0x31e>
    } else if (resp->resp_set_ap_config->resp == NO_AP_FOUND) {
 801ba62:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 801ba64:	699b      	ldr	r3, [r3, #24]
 801ba66:	691b      	ldr	r3, [r3, #16]
 801ba68:	2b02      	cmp	r3, #2
 801ba6a:	d125      	bne.n	801bab8 <wifi_set_ap_config+0x25c>
        command_log("SSID: %s not found\n", (char *)&ap_config.station.ssid);
 801ba6c:	f107 0140 	add.w	r1, r7, #64	; 0x40
 801ba70:	483a      	ldr	r0, [pc, #232]	; (801bb5c <wifi_set_ap_config+0x300>)
 801ba72:	f004 fb7b 	bl	802016c <iprintf>
 801ba76:	200d      	movs	r0, #13
 801ba78:	f004 fb90 	bl	802019c <putchar>
        mem_free(tx_data);
 801ba7c:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 801ba7e:	2b00      	cmp	r3, #0
 801ba80:	d004      	beq.n	801ba8c <wifi_set_ap_config+0x230>
 801ba82:	6af8      	ldr	r0, [r7, #44]	; 0x2c
 801ba84:	f001 fd00 	bl	801d488 <esp_hosted_free>
 801ba88:	2300      	movs	r3, #0
 801ba8a:	62fb      	str	r3, [r7, #44]	; 0x2c
        mem_free(rx_data);
 801ba8c:	6abb      	ldr	r3, [r7, #40]	; 0x28
 801ba8e:	2b00      	cmp	r3, #0
 801ba90:	d004      	beq.n	801ba9c <wifi_set_ap_config+0x240>
 801ba92:	6ab8      	ldr	r0, [r7, #40]	; 0x28
 801ba94:	f001 fcf8 	bl	801d488 <esp_hosted_free>
 801ba98:	2300      	movs	r3, #0
 801ba9a:	62bb      	str	r3, [r7, #40]	; 0x28
        mem_free(req_payload);
 801ba9c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801ba9e:	2b00      	cmp	r3, #0
 801baa0:	d004      	beq.n	801baac <wifi_set_ap_config+0x250>
 801baa2:	6a78      	ldr	r0, [r7, #36]	; 0x24
 801baa4:	f001 fcf0 	bl	801d488 <esp_hosted_free>
 801baa8:	2300      	movs	r3, #0
 801baaa:	627b      	str	r3, [r7, #36]	; 0x24
        esp_hosted_config_payload__free_unpacked(resp, NULL);
 801baac:	2100      	movs	r1, #0
 801baae:	6b78      	ldr	r0, [r7, #52]	; 0x34
 801bab0:	f7fc f948 	bl	8017d44 <esp_hosted_config_payload__free_unpacked>
        return NO_AP_FOUND;
 801bab4:	2302      	movs	r3, #2
 801bab6:	e060      	b.n	801bb7a <wifi_set_ap_config+0x31e>
    } else if (resp->resp_set_ap_config->resp) {
 801bab8:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 801baba:	699b      	ldr	r3, [r3, #24]
 801babc:	691b      	ldr	r3, [r3, #16]
 801babe:	2b00      	cmp	r3, #0
 801bac0:	d006      	beq.n	801bad0 <wifi_set_ap_config+0x274>
        command_log("Failed to connect with AP\n");
 801bac2:	4827      	ldr	r0, [pc, #156]	; (801bb60 <wifi_set_ap_config+0x304>)
 801bac4:	f004 fbee 	bl	80202a4 <puts>
 801bac8:	200d      	movs	r0, #13
 801baca:	f004 fb67 	bl	802019c <putchar>
        goto err1;
 801bace:	e01d      	b.n	801bb0c <wifi_set_ap_config+0x2b0>
    }

    mem_free(tx_data);
 801bad0:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 801bad2:	2b00      	cmp	r3, #0
 801bad4:	d004      	beq.n	801bae0 <wifi_set_ap_config+0x284>
 801bad6:	6af8      	ldr	r0, [r7, #44]	; 0x2c
 801bad8:	f001 fcd6 	bl	801d488 <esp_hosted_free>
 801badc:	2300      	movs	r3, #0
 801bade:	62fb      	str	r3, [r7, #44]	; 0x2c
    mem_free(rx_data);
 801bae0:	6abb      	ldr	r3, [r7, #40]	; 0x28
 801bae2:	2b00      	cmp	r3, #0
 801bae4:	d004      	beq.n	801baf0 <wifi_set_ap_config+0x294>
 801bae6:	6ab8      	ldr	r0, [r7, #40]	; 0x28
 801bae8:	f001 fcce 	bl	801d488 <esp_hosted_free>
 801baec:	2300      	movs	r3, #0
 801baee:	62bb      	str	r3, [r7, #40]	; 0x28
    mem_free(req_payload);
 801baf0:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801baf2:	2b00      	cmp	r3, #0
 801baf4:	d004      	beq.n	801bb00 <wifi_set_ap_config+0x2a4>
 801baf6:	6a78      	ldr	r0, [r7, #36]	; 0x24
 801baf8:	f001 fcc6 	bl	801d488 <esp_hosted_free>
 801bafc:	2300      	movs	r3, #0
 801bafe:	627b      	str	r3, [r7, #36]	; 0x24
    esp_hosted_config_payload__free_unpacked(resp, NULL);
 801bb00:	2100      	movs	r1, #0
 801bb02:	6b78      	ldr	r0, [r7, #52]	; 0x34
 801bb04:	f7fc f91e 	bl	8017d44 <esp_hosted_config_payload__free_unpacked>
    return SUCCESS;
 801bb08:	2300      	movs	r3, #0
 801bb0a:	e036      	b.n	801bb7a <wifi_set_ap_config+0x31e>

err1:
    mem_free(rx_data);
 801bb0c:	6abb      	ldr	r3, [r7, #40]	; 0x28
 801bb0e:	2b00      	cmp	r3, #0
 801bb10:	d004      	beq.n	801bb1c <wifi_set_ap_config+0x2c0>
 801bb12:	6ab8      	ldr	r0, [r7, #40]	; 0x28
 801bb14:	f001 fcb8 	bl	801d488 <esp_hosted_free>
 801bb18:	2300      	movs	r3, #0
 801bb1a:	62bb      	str	r3, [r7, #40]	; 0x28
    esp_hosted_config_payload__free_unpacked(resp, NULL);
 801bb1c:	2100      	movs	r1, #0
 801bb1e:	6b78      	ldr	r0, [r7, #52]	; 0x34
 801bb20:	f7fc f910 	bl	8017d44 <esp_hosted_config_payload__free_unpacked>
err2:
    mem_free(tx_data);
 801bb24:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 801bb26:	2b00      	cmp	r3, #0
 801bb28:	d01c      	beq.n	801bb64 <wifi_set_ap_config+0x308>
 801bb2a:	6af8      	ldr	r0, [r7, #44]	; 0x2c
 801bb2c:	f001 fcac 	bl	801d488 <esp_hosted_free>
 801bb30:	2300      	movs	r3, #0
 801bb32:	62fb      	str	r3, [r7, #44]	; 0x2c
 801bb34:	e017      	b.n	801bb66 <wifi_set_ap_config+0x30a>
 801bb36:	bf00      	nop
 801bb38:	080245e4 	.word	0x080245e4
 801bb3c:	080245f8 	.word	0x080245f8
 801bb40:	08024610 	.word	0x08024610
 801bb44:	08024498 	.word	0x08024498
 801bb48:	080244c4 	.word	0x080244c4
 801bb4c:	080244d8 	.word	0x080244d8
 801bb50:	08024500 	.word	0x08024500
 801bb54:	0802451c 	.word	0x0802451c
 801bb58:	08024628 	.word	0x08024628
 801bb5c:	0802464c 	.word	0x0802464c
 801bb60:	08024660 	.word	0x08024660
err3:
 801bb64:	bf00      	nop
    mem_free(req_payload);
 801bb66:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801bb68:	2b00      	cmp	r3, #0
 801bb6a:	d004      	beq.n	801bb76 <wifi_set_ap_config+0x31a>
 801bb6c:	6a78      	ldr	r0, [r7, #36]	; 0x24
 801bb6e:	f001 fc8b 	bl	801d488 <esp_hosted_free>
 801bb72:	2300      	movs	r3, #0
 801bb74:	627b      	str	r3, [r7, #36]	; 0x24
    return FAILURE;
 801bb76:	f04f 33ff 	mov.w	r3, #4294967295
}
 801bb7a:	4618      	mov	r0, r3
 801bb7c:	3738      	adds	r7, #56	; 0x38
 801bb7e:	46bd      	mov	sp, r7
 801bb80:	e8bd 4080 	ldmia.w	sp!, {r7, lr}
 801bb84:	b004      	add	sp, #16
 801bb86:	4770      	bx	lr

0801bb88 <wifi_set_softap_config>:
    return FAILURE;
}

// Function sets ESP32 softap configuration
int wifi_set_softap_config (esp_hosted_control_config_t softap_config)
{
 801bb88:	b084      	sub	sp, #16
 801bb8a:	b580      	push	{r7, lr}
 801bb8c:	b08e      	sub	sp, #56	; 0x38
 801bb8e:	af00      	add	r7, sp, #0
 801bb90:	f107 0c40 	add.w	ip, r7, #64	; 0x40
 801bb94:	e88c 000f 	stmia.w	ip, {r0, r1, r2, r3}
    EspHostedConfigPayload req, *resp = NULL;
 801bb98:	2300      	movs	r3, #0
 801bb9a:	637b      	str	r3, [r7, #52]	; 0x34
    uint32_t tx_len = 0, rx_len = 0;
 801bb9c:	2300      	movs	r3, #0
 801bb9e:	633b      	str	r3, [r7, #48]	; 0x30
 801bba0:	2300      	movs	r3, #0
 801bba2:	603b      	str	r3, [r7, #0]
    uint8_t *tx_data = NULL, *rx_data = NULL;
 801bba4:	2300      	movs	r3, #0
 801bba6:	62fb      	str	r3, [r7, #44]	; 0x2c
 801bba8:	2300      	movs	r3, #0
 801bbaa:	62bb      	str	r3, [r7, #40]	; 0x28
    int ret = 0;
 801bbac:	2300      	movs	r3, #0
 801bbae:	627b      	str	r3, [r7, #36]	; 0x24

    if ((strlen((char *)&softap_config.softap.ssid) > MAX_SSID_LENGTH) ||
 801bbb0:	f107 0040 	add.w	r0, r7, #64	; 0x40
 801bbb4:	f7e4 fcba 	bl	800052c <strlen>
 801bbb8:	4603      	mov	r3, r0
 801bbba:	2b20      	cmp	r3, #32
 801bbbc:	d804      	bhi.n	801bbc8 <wifi_set_softap_config+0x40>
        (!strlen((char *)&softap_config.softap.ssid))) {
 801bbbe:	f107 0340 	add.w	r3, r7, #64	; 0x40
 801bbc2:	781b      	ldrb	r3, [r3, #0]
    if ((strlen((char *)&softap_config.softap.ssid) > MAX_SSID_LENGTH) ||
 801bbc4:	2b00      	cmp	r3, #0
 801bbc6:	d108      	bne.n	801bbda <wifi_set_softap_config+0x52>
        command_log("Invalid SSID length\n");
 801bbc8:	48ac      	ldr	r0, [pc, #688]	; (801be7c <wifi_set_softap_config+0x2f4>)
 801bbca:	f004 fb6b 	bl	80202a4 <puts>
 801bbce:	200d      	movs	r0, #13
 801bbd0:	f004 fae4 	bl	802019c <putchar>
        return FAILURE;
 801bbd4:	f04f 33ff 	mov.w	r3, #4294967295
 801bbd8:	e149      	b.n	801be6e <wifi_set_softap_config+0x2e6>
    }

    if ((strlen((char *)&softap_config.softap.pwd) > MAX_PWD_LENGTH) ||
 801bbda:	f107 0360 	add.w	r3, r7, #96	; 0x60
 801bbde:	4618      	mov	r0, r3
 801bbe0:	f7e4 fca4 	bl	800052c <strlen>
 801bbe4:	4603      	mov	r3, r0
 801bbe6:	2b40      	cmp	r3, #64	; 0x40
 801bbe8:	d80b      	bhi.n	801bc02 <wifi_set_softap_config+0x7a>
        ((softap_config.softap.encryption_mode != ESP_HOSTED_ENCRYPTION_MODE__Type_Open)
 801bbea:	f8d7 30a4 	ldr.w	r3, [r7, #164]	; 0xa4
    if ((strlen((char *)&softap_config.softap.pwd) > MAX_PWD_LENGTH) ||
 801bbee:	2b00      	cmp	r3, #0
 801bbf0:	d010      	beq.n	801bc14 <wifi_set_softap_config+0x8c>
            && (strlen((char *)&softap_config.softap.pwd) < MIN_PWD_LENGTH))) {
 801bbf2:	f107 0360 	add.w	r3, r7, #96	; 0x60
 801bbf6:	4618      	mov	r0, r3
 801bbf8:	f7e4 fc98 	bl	800052c <strlen>
 801bbfc:	4603      	mov	r3, r0
 801bbfe:	2b07      	cmp	r3, #7
 801bc00:	d808      	bhi.n	801bc14 <wifi_set_softap_config+0x8c>
        command_log("Invalid password length\n");
 801bc02:	489f      	ldr	r0, [pc, #636]	; (801be80 <wifi_set_softap_config+0x2f8>)
 801bc04:	f004 fb4e 	bl	80202a4 <puts>
 801bc08:	200d      	movs	r0, #13
 801bc0a:	f004 fac7 	bl	802019c <putchar>
        return FAILURE;
 801bc0e:	f04f 33ff 	mov.w	r3, #4294967295
 801bc12:	e12c      	b.n	801be6e <wifi_set_softap_config+0x2e6>
    }

    if ((softap_config.softap.channel < MIN_CHNL_NO) ||
 801bc14:	f8d7 30a0 	ldr.w	r3, [r7, #160]	; 0xa0
 801bc18:	2b00      	cmp	r3, #0
 801bc1a:	dd03      	ble.n	801bc24 <wifi_set_softap_config+0x9c>
            (softap_config.softap.channel > MAX_CHNL_NO)) {
 801bc1c:	f8d7 30a0 	ldr.w	r3, [r7, #160]	; 0xa0
    if ((softap_config.softap.channel < MIN_CHNL_NO) ||
 801bc20:	2b0b      	cmp	r3, #11
 801bc22:	dd08      	ble.n	801bc36 <wifi_set_softap_config+0xae>
        command_log("Invalid softap channel\n");
 801bc24:	4897      	ldr	r0, [pc, #604]	; (801be84 <wifi_set_softap_config+0x2fc>)
 801bc26:	f004 fb3d 	bl	80202a4 <puts>
 801bc2a:	200d      	movs	r0, #13
 801bc2c:	f004 fab6 	bl	802019c <putchar>
        return FAILURE;
 801bc30:	f04f 33ff 	mov.w	r3, #4294967295
 801bc34:	e11b      	b.n	801be6e <wifi_set_softap_config+0x2e6>
    }

    if ((softap_config.softap.encryption_mode < ESP_HOSTED_ENCRYPTION_MODE__Type_Open) ||
 801bc36:	f8d7 30a4 	ldr.w	r3, [r7, #164]	; 0xa4
 801bc3a:	2b00      	cmp	r3, #0
 801bc3c:	db07      	blt.n	801bc4e <wifi_set_softap_config+0xc6>
        (softap_config.softap.encryption_mode == ESP_HOSTED_ENCRYPTION_MODE__Type_WEP) ||
 801bc3e:	f8d7 30a4 	ldr.w	r3, [r7, #164]	; 0xa4
    if ((softap_config.softap.encryption_mode < ESP_HOSTED_ENCRYPTION_MODE__Type_Open) ||
 801bc42:	2b01      	cmp	r3, #1
 801bc44:	d003      	beq.n	801bc4e <wifi_set_softap_config+0xc6>
        (softap_config.softap.encryption_mode > ESP_HOSTED_ENCRYPTION_MODE__Type_WPA_WPA2_PSK)) {
 801bc46:	f8d7 30a4 	ldr.w	r3, [r7, #164]	; 0xa4
        (softap_config.softap.encryption_mode == ESP_HOSTED_ENCRYPTION_MODE__Type_WEP) ||
 801bc4a:	2b04      	cmp	r3, #4
 801bc4c:	dd08      	ble.n	801bc60 <wifi_set_softap_config+0xd8>

        command_log("Asked Encryption mode not supported\n");
 801bc4e:	488e      	ldr	r0, [pc, #568]	; (801be88 <wifi_set_softap_config+0x300>)
 801bc50:	f004 fb28 	bl	80202a4 <puts>
 801bc54:	200d      	movs	r0, #13
 801bc56:	f004 faa1 	bl	802019c <putchar>
        return FAILURE;
 801bc5a:	f04f 33ff 	mov.w	r3, #4294967295
 801bc5e:	e106      	b.n	801be6e <wifi_set_softap_config+0x2e6>
    }

    if ((softap_config.softap.max_connections < MIN_CONN_NO) ||
 801bc60:	f8d7 30a8 	ldr.w	r3, [r7, #168]	; 0xa8
 801bc64:	2b00      	cmp	r3, #0
 801bc66:	dd03      	ble.n	801bc70 <wifi_set_softap_config+0xe8>
            (softap_config.softap.max_connections > MAX_CONN_NO)) {
 801bc68:	f8d7 30a8 	ldr.w	r3, [r7, #168]	; 0xa8
    if ((softap_config.softap.max_connections < MIN_CONN_NO) ||
 801bc6c:	2b0a      	cmp	r3, #10
 801bc6e:	dd08      	ble.n	801bc82 <wifi_set_softap_config+0xfa>
        command_log("Invalid maximum connection number\n");
 801bc70:	4886      	ldr	r0, [pc, #536]	; (801be8c <wifi_set_softap_config+0x304>)
 801bc72:	f004 fb17 	bl	80202a4 <puts>
 801bc76:	200d      	movs	r0, #13
 801bc78:	f004 fa90 	bl	802019c <putchar>
        return FAILURE;
 801bc7c:	f04f 33ff 	mov.w	r3, #4294967295
 801bc80:	e0f5      	b.n	801be6e <wifi_set_softap_config+0x2e6>
    }

    if ((softap_config.softap.bandwidth < WIFI_BW_HT20) ||
 801bc82:	f897 30ad 	ldrb.w	r3, [r7, #173]	; 0xad
 801bc86:	2b00      	cmp	r3, #0
 801bc88:	d003      	beq.n	801bc92 <wifi_set_softap_config+0x10a>
            (softap_config.softap.bandwidth > WIFI_BW_HT40)) {
 801bc8a:	f897 30ad 	ldrb.w	r3, [r7, #173]	; 0xad
    if ((softap_config.softap.bandwidth < WIFI_BW_HT20) ||
 801bc8e:	2b02      	cmp	r3, #2
 801bc90:	d908      	bls.n	801bca4 <wifi_set_softap_config+0x11c>
        command_log("Invalid bandwidth\n");
 801bc92:	487f      	ldr	r0, [pc, #508]	; (801be90 <wifi_set_softap_config+0x308>)
 801bc94:	f004 fb06 	bl	80202a4 <puts>
 801bc98:	200d      	movs	r0, #13
 801bc9a:	f004 fa7f 	bl	802019c <putchar>
        return FAILURE;
 801bc9e:	f04f 33ff 	mov.w	r3, #4294967295
 801bca2:	e0e4      	b.n	801be6e <wifi_set_softap_config+0x2e6>
    }

    esp_hosted_config_payload__init (&req);
 801bca4:	1d3b      	adds	r3, r7, #4
 801bca6:	4618      	mov	r0, r3
 801bca8:	f7fb ffe0 	bl	8017c6c <esp_hosted_config_payload__init>
    req.has_msg = true;
 801bcac:	2301      	movs	r3, #1
 801bcae:	613b      	str	r3, [r7, #16]
    req.msg = ESP_HOSTED_CONFIG_MSG_TYPE__TypeCmdSetSoftAPConfig;
 801bcb0:	230c      	movs	r3, #12
 801bcb2:	617b      	str	r3, [r7, #20]
    req.payload_case = ESP_HOSTED_CONFIG_PAYLOAD__PAYLOAD_CMD_SET_SOFTAP_CONFIG;
 801bcb4:	2316      	movs	r3, #22
 801bcb6:	763b      	strb	r3, [r7, #24]

    EspHostedCmdSetSoftAPConfig *req_payload = (EspHostedCmdSetSoftAPConfig *)
        esp_hosted_calloc(1, sizeof(EspHostedCmdSetSoftAPConfig));
 801bcb8:	213c      	movs	r1, #60	; 0x3c
 801bcba:	2001      	movs	r0, #1
 801bcbc:	f001 fbcc 	bl	801d458 <esp_hosted_calloc>
 801bcc0:	6238      	str	r0, [r7, #32]
    if (!req_payload) {
 801bcc2:	6a3b      	ldr	r3, [r7, #32]
 801bcc4:	2b00      	cmp	r3, #0
 801bcc6:	d108      	bne.n	801bcda <wifi_set_softap_config+0x152>
        command_log("Failed to allocate memory for req_payload\n");
 801bcc8:	4872      	ldr	r0, [pc, #456]	; (801be94 <wifi_set_softap_config+0x30c>)
 801bcca:	f004 faeb 	bl	80202a4 <puts>
 801bcce:	200d      	movs	r0, #13
 801bcd0:	f004 fa64 	bl	802019c <putchar>
        return FAILURE;
 801bcd4:	f04f 33ff 	mov.w	r3, #4294967295
 801bcd8:	e0c9      	b.n	801be6e <wifi_set_softap_config+0x2e6>
    }

    esp_hosted_cmd_set_soft_apconfig__init(req_payload);
 801bcda:	6a38      	ldr	r0, [r7, #32]
 801bcdc:	f7fb fe26 	bl	801792c <esp_hosted_cmd_set_soft_apconfig__init>
    req_payload->ssid = (char *)&softap_config.softap.ssid;
 801bce0:	6a3b      	ldr	r3, [r7, #32]
 801bce2:	f107 0240 	add.w	r2, r7, #64	; 0x40
 801bce6:	60da      	str	r2, [r3, #12]
    req_payload->pwd = (char *)&softap_config.softap.pwd;
 801bce8:	6a3b      	ldr	r3, [r7, #32]
 801bcea:	f107 0260 	add.w	r2, r7, #96	; 0x60
 801bcee:	611a      	str	r2, [r3, #16]
    req_payload->has_chnl = true;
 801bcf0:	6a3b      	ldr	r3, [r7, #32]
 801bcf2:	2201      	movs	r2, #1
 801bcf4:	615a      	str	r2, [r3, #20]
    req_payload->chnl = softap_config.softap.channel;
 801bcf6:	f8d7 20a0 	ldr.w	r2, [r7, #160]	; 0xa0
 801bcfa:	6a3b      	ldr	r3, [r7, #32]
 801bcfc:	619a      	str	r2, [r3, #24]
    req_payload->has_ecn = true;
 801bcfe:	6a3b      	ldr	r3, [r7, #32]
 801bd00:	2201      	movs	r2, #1
 801bd02:	61da      	str	r2, [r3, #28]
    req_payload->ecn = softap_config.softap.encryption_mode;
 801bd04:	f8d7 30a4 	ldr.w	r3, [r7, #164]	; 0xa4
 801bd08:	461a      	mov	r2, r3
 801bd0a:	6a3b      	ldr	r3, [r7, #32]
 801bd0c:	621a      	str	r2, [r3, #32]
    req_payload->has_max_conn = true;
 801bd0e:	6a3b      	ldr	r3, [r7, #32]
 801bd10:	2201      	movs	r2, #1
 801bd12:	625a      	str	r2, [r3, #36]	; 0x24
    req_payload->max_conn = softap_config.softap.max_connections;
 801bd14:	f8d7 20a8 	ldr.w	r2, [r7, #168]	; 0xa8
 801bd18:	6a3b      	ldr	r3, [r7, #32]
 801bd1a:	629a      	str	r2, [r3, #40]	; 0x28
    req_payload->has_ssid_hidden = true;
 801bd1c:	6a3b      	ldr	r3, [r7, #32]
 801bd1e:	2201      	movs	r2, #1
 801bd20:	62da      	str	r2, [r3, #44]	; 0x2c
    req_payload->ssid_hidden = softap_config.softap.ssid_hidden;
 801bd22:	f897 30ac 	ldrb.w	r3, [r7, #172]	; 0xac
 801bd26:	461a      	mov	r2, r3
 801bd28:	6a3b      	ldr	r3, [r7, #32]
 801bd2a:	631a      	str	r2, [r3, #48]	; 0x30
    req_payload->has_bw = true;
 801bd2c:	6a3b      	ldr	r3, [r7, #32]
 801bd2e:	2201      	movs	r2, #1
 801bd30:	635a      	str	r2, [r3, #52]	; 0x34
    req_payload->bw = softap_config.softap.bandwidth;
 801bd32:	f897 30ad 	ldrb.w	r3, [r7, #173]	; 0xad
 801bd36:	461a      	mov	r2, r3
 801bd38:	6a3b      	ldr	r3, [r7, #32]
 801bd3a:	639a      	str	r2, [r3, #56]	; 0x38
    req.cmd_set_softap_config = req_payload;
 801bd3c:	6a3b      	ldr	r3, [r7, #32]
 801bd3e:	61fb      	str	r3, [r7, #28]

    tx_len = esp_hosted_config_payload__get_packed_size(&req);
 801bd40:	1d3b      	adds	r3, r7, #4
 801bd42:	4618      	mov	r0, r3
 801bd44:	f7fb ffa8 	bl	8017c98 <esp_hosted_config_payload__get_packed_size>
 801bd48:	6338      	str	r0, [r7, #48]	; 0x30
    if (!tx_len) {
 801bd4a:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801bd4c:	2b00      	cmp	r3, #0
 801bd4e:	d106      	bne.n	801bd5e <wifi_set_softap_config+0x1d6>
        command_log("Invalid tx length\n");
 801bd50:	4851      	ldr	r0, [pc, #324]	; (801be98 <wifi_set_softap_config+0x310>)
 801bd52:	f004 faa7 	bl	80202a4 <puts>
 801bd56:	200d      	movs	r0, #13
 801bd58:	f004 fa20 	bl	802019c <putchar>
        goto err3;
 801bd5c:	e07d      	b.n	801be5a <wifi_set_softap_config+0x2d2>
    }

    tx_data = (uint8_t *)esp_hosted_calloc(1, tx_len);
 801bd5e:	6b39      	ldr	r1, [r7, #48]	; 0x30
 801bd60:	2001      	movs	r0, #1
 801bd62:	f001 fb79 	bl	801d458 <esp_hosted_calloc>
 801bd66:	62f8      	str	r0, [r7, #44]	; 0x2c
    if (ret != SUCCESS) {
 801bd68:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801bd6a:	2b00      	cmp	r3, #0
 801bd6c:	d006      	beq.n	801bd7c <wifi_set_softap_config+0x1f4>
        command_log("Failed to allocate memory for tx_data\n");
 801bd6e:	484b      	ldr	r0, [pc, #300]	; (801be9c <wifi_set_softap_config+0x314>)
 801bd70:	f004 fa98 	bl	80202a4 <puts>
 801bd74:	200d      	movs	r0, #13
 801bd76:	f004 fa11 	bl	802019c <putchar>
        goto err3;
 801bd7a:	e06e      	b.n	801be5a <wifi_set_softap_config+0x2d2>
    }

    esp_hosted_config_payload__pack(&req, tx_data);
 801bd7c:	1d3b      	adds	r3, r7, #4
 801bd7e:	6af9      	ldr	r1, [r7, #44]	; 0x2c
 801bd80:	4618      	mov	r0, r3
 801bd82:	f7fb ffa9 	bl	8017cd8 <esp_hosted_config_payload__pack>

    rx_data = transport_pserial_data_handler(tx_data, tx_len,
 801bd86:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801bd88:	b299      	uxth	r1, r3
 801bd8a:	463b      	mov	r3, r7
 801bd8c:	221e      	movs	r2, #30
 801bd8e:	6af8      	ldr	r0, [r7, #44]	; 0x2c
 801bd90:	f000 fb2a 	bl	801c3e8 <transport_pserial_data_handler>
 801bd94:	62b8      	str	r0, [r7, #40]	; 0x28
            TIMEOUT_PSERIAL_RESP, &rx_len);
    if (!rx_data || !rx_len) {
 801bd96:	6abb      	ldr	r3, [r7, #40]	; 0x28
 801bd98:	2b00      	cmp	r3, #0
 801bd9a:	d002      	beq.n	801bda2 <wifi_set_softap_config+0x21a>
 801bd9c:	683b      	ldr	r3, [r7, #0]
 801bd9e:	2b00      	cmp	r3, #0
 801bda0:	d106      	bne.n	801bdb0 <wifi_set_softap_config+0x228>
        command_log("Failed to process rx data\n");
 801bda2:	483f      	ldr	r0, [pc, #252]	; (801bea0 <wifi_set_softap_config+0x318>)
 801bda4:	f004 fa7e 	bl	80202a4 <puts>
 801bda8:	200d      	movs	r0, #13
 801bdaa:	f004 f9f7 	bl	802019c <putchar>
        goto err2;
 801bdae:	e04a      	b.n	801be46 <wifi_set_softap_config+0x2be>
    }

    resp = esp_hosted_config_payload__unpack(NULL, rx_len, rx_data);
 801bdb0:	683b      	ldr	r3, [r7, #0]
 801bdb2:	6aba      	ldr	r2, [r7, #40]	; 0x28
 801bdb4:	4619      	mov	r1, r3
 801bdb6:	2000      	movs	r0, #0
 801bdb8:	f7fb ffb0 	bl	8017d1c <esp_hosted_config_payload__unpack>
 801bdbc:	6378      	str	r0, [r7, #52]	; 0x34
    if ((!resp) || (!resp->resp_set_softap_config)) {
 801bdbe:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 801bdc0:	2b00      	cmp	r3, #0
 801bdc2:	d003      	beq.n	801bdcc <wifi_set_softap_config+0x244>
 801bdc4:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 801bdc6:	699b      	ldr	r3, [r3, #24]
 801bdc8:	2b00      	cmp	r3, #0
 801bdca:	d106      	bne.n	801bdda <wifi_set_softap_config+0x252>
        command_log("Failed to unpack rx_data\n");
 801bdcc:	4835      	ldr	r0, [pc, #212]	; (801bea4 <wifi_set_softap_config+0x31c>)
 801bdce:	f004 fa69 	bl	80202a4 <puts>
 801bdd2:	200d      	movs	r0, #13
 801bdd4:	f004 f9e2 	bl	802019c <putchar>
        goto err1;
 801bdd8:	e029      	b.n	801be2e <wifi_set_softap_config+0x2a6>
    }

    if (resp->resp_set_softap_config->resp) {
 801bdda:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 801bddc:	699b      	ldr	r3, [r3, #24]
 801bdde:	691b      	ldr	r3, [r3, #16]
 801bde0:	2b00      	cmp	r3, #0
 801bde2:	d006      	beq.n	801bdf2 <wifi_set_softap_config+0x26a>
        command_log("Failed to set softap configuration\n");
 801bde4:	4830      	ldr	r0, [pc, #192]	; (801bea8 <wifi_set_softap_config+0x320>)
 801bde6:	f004 fa5d 	bl	80202a4 <puts>
 801bdea:	200d      	movs	r0, #13
 801bdec:	f004 f9d6 	bl	802019c <putchar>
        goto err1;
 801bdf0:	e01d      	b.n	801be2e <wifi_set_softap_config+0x2a6>
    }

    mem_free(tx_data);
 801bdf2:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 801bdf4:	2b00      	cmp	r3, #0
 801bdf6:	d004      	beq.n	801be02 <wifi_set_softap_config+0x27a>
 801bdf8:	6af8      	ldr	r0, [r7, #44]	; 0x2c
 801bdfa:	f001 fb45 	bl	801d488 <esp_hosted_free>
 801bdfe:	2300      	movs	r3, #0
 801be00:	62fb      	str	r3, [r7, #44]	; 0x2c
    mem_free(rx_data);
 801be02:	6abb      	ldr	r3, [r7, #40]	; 0x28
 801be04:	2b00      	cmp	r3, #0
 801be06:	d004      	beq.n	801be12 <wifi_set_softap_config+0x28a>
 801be08:	6ab8      	ldr	r0, [r7, #40]	; 0x28
 801be0a:	f001 fb3d 	bl	801d488 <esp_hosted_free>
 801be0e:	2300      	movs	r3, #0
 801be10:	62bb      	str	r3, [r7, #40]	; 0x28
    mem_free(req_payload);
 801be12:	6a3b      	ldr	r3, [r7, #32]
 801be14:	2b00      	cmp	r3, #0
 801be16:	d004      	beq.n	801be22 <wifi_set_softap_config+0x29a>
 801be18:	6a38      	ldr	r0, [r7, #32]
 801be1a:	f001 fb35 	bl	801d488 <esp_hosted_free>
 801be1e:	2300      	movs	r3, #0
 801be20:	623b      	str	r3, [r7, #32]
    esp_hosted_config_payload__free_unpacked(resp, NULL);
 801be22:	2100      	movs	r1, #0
 801be24:	6b78      	ldr	r0, [r7, #52]	; 0x34
 801be26:	f7fb ff8d 	bl	8017d44 <esp_hosted_config_payload__free_unpacked>
    return SUCCESS;
 801be2a:	2300      	movs	r3, #0
 801be2c:	e01f      	b.n	801be6e <wifi_set_softap_config+0x2e6>

err1:
    mem_free(rx_data);
 801be2e:	6abb      	ldr	r3, [r7, #40]	; 0x28
 801be30:	2b00      	cmp	r3, #0
 801be32:	d004      	beq.n	801be3e <wifi_set_softap_config+0x2b6>
 801be34:	6ab8      	ldr	r0, [r7, #40]	; 0x28
 801be36:	f001 fb27 	bl	801d488 <esp_hosted_free>
 801be3a:	2300      	movs	r3, #0
 801be3c:	62bb      	str	r3, [r7, #40]	; 0x28
    esp_hosted_config_payload__free_unpacked(resp, NULL);
 801be3e:	2100      	movs	r1, #0
 801be40:	6b78      	ldr	r0, [r7, #52]	; 0x34
 801be42:	f7fb ff7f 	bl	8017d44 <esp_hosted_config_payload__free_unpacked>
err2:
    mem_free(tx_data);
 801be46:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 801be48:	2b00      	cmp	r3, #0
 801be4a:	d005      	beq.n	801be58 <wifi_set_softap_config+0x2d0>
 801be4c:	6af8      	ldr	r0, [r7, #44]	; 0x2c
 801be4e:	f001 fb1b 	bl	801d488 <esp_hosted_free>
 801be52:	2300      	movs	r3, #0
 801be54:	62fb      	str	r3, [r7, #44]	; 0x2c
 801be56:	e000      	b.n	801be5a <wifi_set_softap_config+0x2d2>
err3:
 801be58:	bf00      	nop
    mem_free(req_payload);
 801be5a:	6a3b      	ldr	r3, [r7, #32]
 801be5c:	2b00      	cmp	r3, #0
 801be5e:	d004      	beq.n	801be6a <wifi_set_softap_config+0x2e2>
 801be60:	6a38      	ldr	r0, [r7, #32]
 801be62:	f001 fb11 	bl	801d488 <esp_hosted_free>
 801be66:	2300      	movs	r3, #0
 801be68:	623b      	str	r3, [r7, #32]
    return FAILURE;
 801be6a:	f04f 33ff 	mov.w	r3, #4294967295
}
 801be6e:	4618      	mov	r0, r3
 801be70:	3738      	adds	r7, #56	; 0x38
 801be72:	46bd      	mov	sp, r7
 801be74:	e8bd 4080 	ldmia.w	sp!, {r7, lr}
 801be78:	b004      	add	sp, #16
 801be7a:	4770      	bx	lr
 801be7c:	080245e4 	.word	0x080245e4
 801be80:	080245f8 	.word	0x080245f8
 801be84:	080246f8 	.word	0x080246f8
 801be88:	08024710 	.word	0x08024710
 801be8c:	08024734 	.word	0x08024734
 801be90:	08024758 	.word	0x08024758
 801be94:	08024498 	.word	0x08024498
 801be98:	080244c4 	.word	0x080244c4
 801be9c:	080244d8 	.word	0x080244d8
 801bea0:	08024500 	.word	0x08024500
 801bea4:	0802451c 	.word	0x0802451c
 801bea8:	0802476c 	.word	0x0802476c

0801beac <wifi_ap_scan_list>:
}

// Function sends scanned list of available APs
// User must free esp_hosted_wifi_scanlist_t handler
esp_hosted_wifi_scanlist_t* wifi_ap_scan_list (int *count)
{
 801beac:	b580      	push	{r7, lr}
 801beae:	b090      	sub	sp, #64	; 0x40
 801beb0:	af00      	add	r7, sp, #0
 801beb2:	6078      	str	r0, [r7, #4]
    EspHostedConfigPayload req, *resp = NULL;
 801beb4:	2300      	movs	r3, #0
 801beb6:	637b      	str	r3, [r7, #52]	; 0x34
    uint32_t tx_len = 0, rx_len = 0;
 801beb8:	2300      	movs	r3, #0
 801beba:	633b      	str	r3, [r7, #48]	; 0x30
 801bebc:	2300      	movs	r3, #0
 801bebe:	60bb      	str	r3, [r7, #8]
    uint8_t *tx_data = NULL, *rx_data = NULL;
 801bec0:	2300      	movs	r3, #0
 801bec2:	62fb      	str	r3, [r7, #44]	; 0x2c
 801bec4:	2300      	movs	r3, #0
 801bec6:	62bb      	str	r3, [r7, #40]	; 0x28
    esp_hosted_wifi_scanlist_t *list = NULL;
 801bec8:	2300      	movs	r3, #0
 801beca:	63fb      	str	r3, [r7, #60]	; 0x3c
    int i = 0;
 801becc:	2300      	movs	r3, #0
 801bece:	63bb      	str	r3, [r7, #56]	; 0x38

    if (!count) {
 801bed0:	687b      	ldr	r3, [r7, #4]
 801bed2:	2b00      	cmp	r3, #0
 801bed4:	d107      	bne.n	801bee6 <wifi_ap_scan_list+0x3a>
        command_log("Invalid parameter\n");
 801bed6:	4896      	ldr	r0, [pc, #600]	; (801c130 <wifi_ap_scan_list+0x284>)
 801bed8:	f004 f9e4 	bl	80202a4 <puts>
 801bedc:	200d      	movs	r0, #13
 801bede:	f004 f95d 	bl	802019c <putchar>
        return NULL;
 801bee2:	2300      	movs	r3, #0
 801bee4:	e11f      	b.n	801c126 <wifi_ap_scan_list+0x27a>
    }

    esp_hosted_config_payload__init (&req);
 801bee6:	f107 030c 	add.w	r3, r7, #12
 801beea:	4618      	mov	r0, r3
 801beec:	f7fb febe 	bl	8017c6c <esp_hosted_config_payload__init>
    req.has_msg = true;
 801bef0:	2301      	movs	r3, #1
 801bef2:	61bb      	str	r3, [r7, #24]
    req.msg = ESP_HOSTED_CONFIG_MSG_TYPE__TypeCmdGetAPScanList;
 801bef4:	2312      	movs	r3, #18
 801bef6:	61fb      	str	r3, [r7, #28]
    tx_len = esp_hosted_config_payload__get_packed_size(&req);
 801bef8:	f107 030c 	add.w	r3, r7, #12
 801befc:	4618      	mov	r0, r3
 801befe:	f7fb fecb 	bl	8017c98 <esp_hosted_config_payload__get_packed_size>
 801bf02:	6338      	str	r0, [r7, #48]	; 0x30
    if (!tx_len) {
 801bf04:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801bf06:	2b00      	cmp	r3, #0
 801bf08:	d107      	bne.n	801bf1a <wifi_ap_scan_list+0x6e>
        command_log("Invalid tx length\n");
 801bf0a:	488a      	ldr	r0, [pc, #552]	; (801c134 <wifi_ap_scan_list+0x288>)
 801bf0c:	f004 f9ca 	bl	80202a4 <puts>
 801bf10:	200d      	movs	r0, #13
 801bf12:	f004 f943 	bl	802019c <putchar>
        return NULL;
 801bf16:	2300      	movs	r3, #0
 801bf18:	e105      	b.n	801c126 <wifi_ap_scan_list+0x27a>
    }

    tx_data = (uint8_t *)esp_hosted_calloc(1, tx_len);
 801bf1a:	6b39      	ldr	r1, [r7, #48]	; 0x30
 801bf1c:	2001      	movs	r0, #1
 801bf1e:	f001 fa9b 	bl	801d458 <esp_hosted_calloc>
 801bf22:	62f8      	str	r0, [r7, #44]	; 0x2c
    if (!tx_data) {
 801bf24:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 801bf26:	2b00      	cmp	r3, #0
 801bf28:	d107      	bne.n	801bf3a <wifi_ap_scan_list+0x8e>
        command_log("Failed to allocate memory for tx data\n");
 801bf2a:	4883      	ldr	r0, [pc, #524]	; (801c138 <wifi_ap_scan_list+0x28c>)
 801bf2c:	f004 f9ba 	bl	80202a4 <puts>
 801bf30:	200d      	movs	r0, #13
 801bf32:	f004 f933 	bl	802019c <putchar>
        return NULL;
 801bf36:	2300      	movs	r3, #0
 801bf38:	e0f5      	b.n	801c126 <wifi_ap_scan_list+0x27a>
    }

    esp_hosted_config_payload__pack(&req, tx_data);
 801bf3a:	f107 030c 	add.w	r3, r7, #12
 801bf3e:	6af9      	ldr	r1, [r7, #44]	; 0x2c
 801bf40:	4618      	mov	r0, r3
 801bf42:	f7fb fec9 	bl	8017cd8 <esp_hosted_config_payload__pack>
    rx_data = transport_pserial_data_handler(tx_data, tx_len,
 801bf46:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801bf48:	b299      	uxth	r1, r3
 801bf4a:	f107 0308 	add.w	r3, r7, #8
 801bf4e:	221e      	movs	r2, #30
 801bf50:	6af8      	ldr	r0, [r7, #44]	; 0x2c
 801bf52:	f000 fa49 	bl	801c3e8 <transport_pserial_data_handler>
 801bf56:	62b8      	str	r0, [r7, #40]	; 0x28
            TIMEOUT_PSERIAL_RESP, &rx_len);
    if (!rx_data || !rx_len) {
 801bf58:	6abb      	ldr	r3, [r7, #40]	; 0x28
 801bf5a:	2b00      	cmp	r3, #0
 801bf5c:	d002      	beq.n	801bf64 <wifi_ap_scan_list+0xb8>
 801bf5e:	68bb      	ldr	r3, [r7, #8]
 801bf60:	2b00      	cmp	r3, #0
 801bf62:	d106      	bne.n	801bf72 <wifi_ap_scan_list+0xc6>
        command_log("Failed to process rx data\n");
 801bf64:	4875      	ldr	r0, [pc, #468]	; (801c13c <wifi_ap_scan_list+0x290>)
 801bf66:	f004 f99d 	bl	80202a4 <puts>
 801bf6a:	200d      	movs	r0, #13
 801bf6c:	f004 f916 	bl	802019c <putchar>
        goto err2;
 801bf70:	e0d0      	b.n	801c114 <wifi_ap_scan_list+0x268>
    }

    resp = esp_hosted_config_payload__unpack(NULL, rx_len, rx_data);
 801bf72:	68bb      	ldr	r3, [r7, #8]
 801bf74:	6aba      	ldr	r2, [r7, #40]	; 0x28
 801bf76:	4619      	mov	r1, r3
 801bf78:	2000      	movs	r0, #0
 801bf7a:	f7fb fecf 	bl	8017d1c <esp_hosted_config_payload__unpack>
 801bf7e:	6378      	str	r0, [r7, #52]	; 0x34
    if (!resp || (!resp->resp_scan_ap_list)) {
 801bf80:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 801bf82:	2b00      	cmp	r3, #0
 801bf84:	d003      	beq.n	801bf8e <wifi_ap_scan_list+0xe2>
 801bf86:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 801bf88:	699b      	ldr	r3, [r3, #24]
 801bf8a:	2b00      	cmp	r3, #0
 801bf8c:	d106      	bne.n	801bf9c <wifi_ap_scan_list+0xf0>
        command_log("Failed to unpack rx_data\n");
 801bf8e:	486c      	ldr	r0, [pc, #432]	; (801c140 <wifi_ap_scan_list+0x294>)
 801bf90:	f004 f988 	bl	80202a4 <puts>
 801bf94:	200d      	movs	r0, #13
 801bf96:	f004 f901 	bl	802019c <putchar>
        goto err1;
 801bf9a:	e0af      	b.n	801c0fc <wifi_ap_scan_list+0x250>
    }

    if (resp->resp_scan_ap_list->resp) {
 801bf9c:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 801bf9e:	699b      	ldr	r3, [r3, #24]
 801bfa0:	6a1b      	ldr	r3, [r3, #32]
 801bfa2:	2b00      	cmp	r3, #0
 801bfa4:	d006      	beq.n	801bfb4 <wifi_ap_scan_list+0x108>
        command_log("Failed to get scan AP List\n");
 801bfa6:	4867      	ldr	r0, [pc, #412]	; (801c144 <wifi_ap_scan_list+0x298>)
 801bfa8:	f004 f97c 	bl	80202a4 <puts>
 801bfac:	200d      	movs	r0, #13
 801bfae:	f004 f8f5 	bl	802019c <putchar>
        goto err1;
 801bfb2:	e0a3      	b.n	801c0fc <wifi_ap_scan_list+0x250>
    }

    if (resp->resp_scan_ap_list->count) {
 801bfb4:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 801bfb6:	699b      	ldr	r3, [r3, #24]
 801bfb8:	691b      	ldr	r3, [r3, #16]
 801bfba:	2b00      	cmp	r3, #0
 801bfbc:	d022      	beq.n	801c004 <wifi_ap_scan_list+0x158>
        *count = resp->resp_scan_ap_list->count;
 801bfbe:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 801bfc0:	699b      	ldr	r3, [r3, #24]
 801bfc2:	691b      	ldr	r3, [r3, #16]
 801bfc4:	461a      	mov	r2, r3
 801bfc6:	687b      	ldr	r3, [r7, #4]
 801bfc8:	601a      	str	r2, [r3, #0]
        if (!*count) {
 801bfca:	687b      	ldr	r3, [r7, #4]
 801bfcc:	681b      	ldr	r3, [r3, #0]
 801bfce:	2b00      	cmp	r3, #0
 801bfd0:	d106      	bne.n	801bfe0 <wifi_ap_scan_list+0x134>
            command_log("No APs available\n");
 801bfd2:	485d      	ldr	r0, [pc, #372]	; (801c148 <wifi_ap_scan_list+0x29c>)
 801bfd4:	f004 f966 	bl	80202a4 <puts>
 801bfd8:	200d      	movs	r0, #13
 801bfda:	f004 f8df 	bl	802019c <putchar>
            goto err1;
 801bfde:	e08d      	b.n	801c0fc <wifi_ap_scan_list+0x250>
        }
        list = (esp_hosted_wifi_scanlist_t *)esp_hosted_calloc \
                (resp->resp_scan_ap_list->count,
 801bfe0:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 801bfe2:	699b      	ldr	r3, [r3, #24]
 801bfe4:	691b      	ldr	r3, [r3, #16]
        list = (esp_hosted_wifi_scanlist_t *)esp_hosted_calloc \
 801bfe6:	2140      	movs	r1, #64	; 0x40
 801bfe8:	4618      	mov	r0, r3
 801bfea:	f001 fa35 	bl	801d458 <esp_hosted_calloc>
 801bfee:	63f8      	str	r0, [r7, #60]	; 0x3c
                 sizeof(esp_hosted_wifi_scanlist_t));

        if (!list) {
 801bff0:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 801bff2:	2b00      	cmp	r3, #0
 801bff4:	d106      	bne.n	801c004 <wifi_ap_scan_list+0x158>
            command_log("Failed to allocate memory for scan list\n");
 801bff6:	4855      	ldr	r0, [pc, #340]	; (801c14c <wifi_ap_scan_list+0x2a0>)
 801bff8:	f004 f954 	bl	80202a4 <puts>
 801bffc:	200d      	movs	r0, #13
 801bffe:	f004 f8cd 	bl	802019c <putchar>
            goto err1;
 801c002:	e07b      	b.n	801c0fc <wifi_ap_scan_list+0x250>
        }
    }

    for (i=0; i<resp->resp_scan_ap_list->count; i++) {
 801c004:	2300      	movs	r3, #0
 801c006:	63bb      	str	r3, [r7, #56]	; 0x38
 801c008:	e05c      	b.n	801c0c4 <wifi_ap_scan_list+0x218>
        memcpy(list[i].ssid,
 801c00a:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 801c00c:	019b      	lsls	r3, r3, #6
 801c00e:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 801c010:	4413      	add	r3, r2
 801c012:	4618      	mov	r0, r3
                (char *)resp->resp_scan_ap_list->entries[i]->ssid.data,
 801c014:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 801c016:	699b      	ldr	r3, [r3, #24]
 801c018:	699a      	ldr	r2, [r3, #24]
 801c01a:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 801c01c:	009b      	lsls	r3, r3, #2
 801c01e:	4413      	add	r3, r2
 801c020:	681b      	ldr	r3, [r3, #0]
 801c022:	6959      	ldr	r1, [r3, #20]
                resp->resp_scan_ap_list->entries[i]->ssid.len);
 801c024:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 801c026:	699b      	ldr	r3, [r3, #24]
 801c028:	699a      	ldr	r2, [r3, #24]
 801c02a:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 801c02c:	009b      	lsls	r3, r3, #2
 801c02e:	4413      	add	r3, r2
 801c030:	681b      	ldr	r3, [r3, #0]
        memcpy(list[i].ssid,
 801c032:	691b      	ldr	r3, [r3, #16]
 801c034:	461a      	mov	r2, r3
 801c036:	f003 fbf9 	bl	801f82c <memcpy>
        memcpy(list[i].bssid,
 801c03a:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 801c03c:	019b      	lsls	r3, r3, #6
 801c03e:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 801c040:	4413      	add	r3, r2
 801c042:	f103 0020 	add.w	r0, r3, #32
                (char *)resp->resp_scan_ap_list->entries[i]->bssid.data,
 801c046:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 801c048:	699b      	ldr	r3, [r3, #24]
 801c04a:	699a      	ldr	r2, [r3, #24]
 801c04c:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 801c04e:	009b      	lsls	r3, r3, #2
 801c050:	4413      	add	r3, r2
 801c052:	681b      	ldr	r3, [r3, #0]
 801c054:	6b19      	ldr	r1, [r3, #48]	; 0x30
                resp->resp_scan_ap_list->entries[i]->bssid.len);
 801c056:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 801c058:	699b      	ldr	r3, [r3, #24]
 801c05a:	699a      	ldr	r2, [r3, #24]
 801c05c:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 801c05e:	009b      	lsls	r3, r3, #2
 801c060:	4413      	add	r3, r2
 801c062:	681b      	ldr	r3, [r3, #0]
        memcpy(list[i].bssid,
 801c064:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 801c066:	461a      	mov	r2, r3
 801c068:	f003 fbe0 	bl	801f82c <memcpy>
        list[i].channel = resp->resp_scan_ap_list->entries[i]->chnl;
 801c06c:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 801c06e:	699b      	ldr	r3, [r3, #24]
 801c070:	699a      	ldr	r2, [r3, #24]
 801c072:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 801c074:	009b      	lsls	r3, r3, #2
 801c076:	4413      	add	r3, r2
 801c078:	681b      	ldr	r3, [r3, #0]
 801c07a:	69d9      	ldr	r1, [r3, #28]
 801c07c:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 801c07e:	019b      	lsls	r3, r3, #6
 801c080:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 801c082:	4413      	add	r3, r2
 801c084:	460a      	mov	r2, r1
 801c086:	639a      	str	r2, [r3, #56]	; 0x38
        list[i].rssi = resp->resp_scan_ap_list->entries[i]->rssi;
 801c088:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 801c08a:	699b      	ldr	r3, [r3, #24]
 801c08c:	699a      	ldr	r2, [r3, #24]
 801c08e:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 801c090:	009b      	lsls	r3, r3, #2
 801c092:	4413      	add	r3, r2
 801c094:	681a      	ldr	r2, [r3, #0]
 801c096:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 801c098:	019b      	lsls	r3, r3, #6
 801c09a:	6bf9      	ldr	r1, [r7, #60]	; 0x3c
 801c09c:	440b      	add	r3, r1
 801c09e:	6a52      	ldr	r2, [r2, #36]	; 0x24
 801c0a0:	635a      	str	r2, [r3, #52]	; 0x34
        list[i].encryption_mode = resp->resp_scan_ap_list->entries[i]->ecn;
 801c0a2:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 801c0a4:	699b      	ldr	r3, [r3, #24]
 801c0a6:	699a      	ldr	r2, [r3, #24]
 801c0a8:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 801c0aa:	009b      	lsls	r3, r3, #2
 801c0ac:	4413      	add	r3, r2
 801c0ae:	681b      	ldr	r3, [r3, #0]
 801c0b0:	6b99      	ldr	r1, [r3, #56]	; 0x38
 801c0b2:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 801c0b4:	019b      	lsls	r3, r3, #6
 801c0b6:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 801c0b8:	4413      	add	r3, r2
 801c0ba:	460a      	mov	r2, r1
 801c0bc:	63da      	str	r2, [r3, #60]	; 0x3c
    for (i=0; i<resp->resp_scan_ap_list->count; i++) {
 801c0be:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 801c0c0:	3301      	adds	r3, #1
 801c0c2:	63bb      	str	r3, [r7, #56]	; 0x38
 801c0c4:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 801c0c6:	699b      	ldr	r3, [r3, #24]
 801c0c8:	691a      	ldr	r2, [r3, #16]
 801c0ca:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 801c0cc:	429a      	cmp	r2, r3
 801c0ce:	d89c      	bhi.n	801c00a <wifi_ap_scan_list+0x15e>
    }

    mem_free(tx_data);
 801c0d0:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 801c0d2:	2b00      	cmp	r3, #0
 801c0d4:	d004      	beq.n	801c0e0 <wifi_ap_scan_list+0x234>
 801c0d6:	6af8      	ldr	r0, [r7, #44]	; 0x2c
 801c0d8:	f001 f9d6 	bl	801d488 <esp_hosted_free>
 801c0dc:	2300      	movs	r3, #0
 801c0de:	62fb      	str	r3, [r7, #44]	; 0x2c
    mem_free(rx_data);
 801c0e0:	6abb      	ldr	r3, [r7, #40]	; 0x28
 801c0e2:	2b00      	cmp	r3, #0
 801c0e4:	d004      	beq.n	801c0f0 <wifi_ap_scan_list+0x244>
 801c0e6:	6ab8      	ldr	r0, [r7, #40]	; 0x28
 801c0e8:	f001 f9ce 	bl	801d488 <esp_hosted_free>
 801c0ec:	2300      	movs	r3, #0
 801c0ee:	62bb      	str	r3, [r7, #40]	; 0x28
    esp_hosted_config_payload__free_unpacked(resp, NULL);
 801c0f0:	2100      	movs	r1, #0
 801c0f2:	6b78      	ldr	r0, [r7, #52]	; 0x34
 801c0f4:	f7fb fe26 	bl	8017d44 <esp_hosted_config_payload__free_unpacked>
    return list;
 801c0f8:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 801c0fa:	e014      	b.n	801c126 <wifi_ap_scan_list+0x27a>

err1:
    mem_free(rx_data);
 801c0fc:	6abb      	ldr	r3, [r7, #40]	; 0x28
 801c0fe:	2b00      	cmp	r3, #0
 801c100:	d004      	beq.n	801c10c <wifi_ap_scan_list+0x260>
 801c102:	6ab8      	ldr	r0, [r7, #40]	; 0x28
 801c104:	f001 f9c0 	bl	801d488 <esp_hosted_free>
 801c108:	2300      	movs	r3, #0
 801c10a:	62bb      	str	r3, [r7, #40]	; 0x28
    esp_hosted_config_payload__free_unpacked(resp, NULL);
 801c10c:	2100      	movs	r1, #0
 801c10e:	6b78      	ldr	r0, [r7, #52]	; 0x34
 801c110:	f7fb fe18 	bl	8017d44 <esp_hosted_config_payload__free_unpacked>
err2:
    mem_free(tx_data);
 801c114:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 801c116:	2b00      	cmp	r3, #0
 801c118:	d004      	beq.n	801c124 <wifi_ap_scan_list+0x278>
 801c11a:	6af8      	ldr	r0, [r7, #44]	; 0x2c
 801c11c:	f001 f9b4 	bl	801d488 <esp_hosted_free>
 801c120:	2300      	movs	r3, #0
 801c122:	62fb      	str	r3, [r7, #44]	; 0x2c
    return NULL;
 801c124:	2300      	movs	r3, #0
}
 801c126:	4618      	mov	r0, r3
 801c128:	3740      	adds	r7, #64	; 0x40
 801c12a:	46bd      	mov	sp, r7
 801c12c:	bd80      	pop	{r7, pc}
 801c12e:	bf00      	nop
 801c130:	08024484 	.word	0x08024484
 801c134:	080244c4 	.word	0x080244c4
 801c138:	080247cc 	.word	0x080247cc
 801c13c:	08024500 	.word	0x08024500
 801c140:	0802451c 	.word	0x0802451c
 801c144:	080247f4 	.word	0x080247f4
 801c148:	08024810 	.word	0x08024810
 801c14c:	08024824 	.word	0x08024824

0801c150 <compose_tlv>:
 * length is respective value field's data length in 16 bits
 * value is actual data to be transferred
 */

uint16_t compose_tlv(uint8_t* buf, uint8_t* data, uint16_t data_length)
{
 801c150:	b580      	push	{r7, lr}
 801c152:	b086      	sub	sp, #24
 801c154:	af00      	add	r7, sp, #0
 801c156:	60f8      	str	r0, [r7, #12]
 801c158:	60b9      	str	r1, [r7, #8]
 801c15a:	4613      	mov	r3, r2
 801c15c:	80fb      	strh	r3, [r7, #6]
	uint16_t count = 0;
 801c15e:	2300      	movs	r3, #0
 801c160:	82fb      	strh	r3, [r7, #22]
	buf[count] = PROTO_PSER_TLV_T_EPNAME;
 801c162:	8afb      	ldrh	r3, [r7, #22]
 801c164:	68fa      	ldr	r2, [r7, #12]
 801c166:	4413      	add	r3, r2
 801c168:	2201      	movs	r2, #1
 801c16a:	701a      	strb	r2, [r3, #0]
	count++;
 801c16c:	8afb      	ldrh	r3, [r7, #22]
 801c16e:	3301      	adds	r3, #1
 801c170:	82fb      	strh	r3, [r7, #22]
	uint16_t ep_length = strlen(ep_name);
 801c172:	4b2a      	ldr	r3, [pc, #168]	; (801c21c <compose_tlv+0xcc>)
 801c174:	681b      	ldr	r3, [r3, #0]
 801c176:	4618      	mov	r0, r3
 801c178:	f7e4 f9d8 	bl	800052c <strlen>
 801c17c:	4603      	mov	r3, r0
 801c17e:	82bb      	strh	r3, [r7, #20]
	buf[count] = (ep_length & 0xFF);
 801c180:	8afb      	ldrh	r3, [r7, #22]
 801c182:	68fa      	ldr	r2, [r7, #12]
 801c184:	4413      	add	r3, r2
 801c186:	8aba      	ldrh	r2, [r7, #20]
 801c188:	b2d2      	uxtb	r2, r2
 801c18a:	701a      	strb	r2, [r3, #0]
	count++;
 801c18c:	8afb      	ldrh	r3, [r7, #22]
 801c18e:	3301      	adds	r3, #1
 801c190:	82fb      	strh	r3, [r7, #22]
	buf[count] = ((ep_length >> 8) & 0xFF);
 801c192:	8abb      	ldrh	r3, [r7, #20]
 801c194:	0a1b      	lsrs	r3, r3, #8
 801c196:	b299      	uxth	r1, r3
 801c198:	8afb      	ldrh	r3, [r7, #22]
 801c19a:	68fa      	ldr	r2, [r7, #12]
 801c19c:	4413      	add	r3, r2
 801c19e:	b2ca      	uxtb	r2, r1
 801c1a0:	701a      	strb	r2, [r3, #0]
	count++;
 801c1a2:	8afb      	ldrh	r3, [r7, #22]
 801c1a4:	3301      	adds	r3, #1
 801c1a6:	82fb      	strh	r3, [r7, #22]
	strncpy((char *)&buf[count], ep_name, ep_length);
 801c1a8:	8afb      	ldrh	r3, [r7, #22]
 801c1aa:	68fa      	ldr	r2, [r7, #12]
 801c1ac:	4413      	add	r3, r2
 801c1ae:	4a1b      	ldr	r2, [pc, #108]	; (801c21c <compose_tlv+0xcc>)
 801c1b0:	6811      	ldr	r1, [r2, #0]
 801c1b2:	8aba      	ldrh	r2, [r7, #20]
 801c1b4:	4618      	mov	r0, r3
 801c1b6:	f004 fb8d 	bl	80208d4 <strncpy>
	count = count + ep_length;
 801c1ba:	8afa      	ldrh	r2, [r7, #22]
 801c1bc:	8abb      	ldrh	r3, [r7, #20]
 801c1be:	4413      	add	r3, r2
 801c1c0:	82fb      	strh	r3, [r7, #22]
	buf[count]= PROTO_PSER_TLV_T_DATA;
 801c1c2:	8afb      	ldrh	r3, [r7, #22]
 801c1c4:	68fa      	ldr	r2, [r7, #12]
 801c1c6:	4413      	add	r3, r2
 801c1c8:	2202      	movs	r2, #2
 801c1ca:	701a      	strb	r2, [r3, #0]
	count++;
 801c1cc:	8afb      	ldrh	r3, [r7, #22]
 801c1ce:	3301      	adds	r3, #1
 801c1d0:	82fb      	strh	r3, [r7, #22]
	buf[count] = (data_length & 0xFF);
 801c1d2:	8afb      	ldrh	r3, [r7, #22]
 801c1d4:	68fa      	ldr	r2, [r7, #12]
 801c1d6:	4413      	add	r3, r2
 801c1d8:	88fa      	ldrh	r2, [r7, #6]
 801c1da:	b2d2      	uxtb	r2, r2
 801c1dc:	701a      	strb	r2, [r3, #0]
	count++;
 801c1de:	8afb      	ldrh	r3, [r7, #22]
 801c1e0:	3301      	adds	r3, #1
 801c1e2:	82fb      	strh	r3, [r7, #22]
	buf[count] = ((data_length >> 8) & 0xFF);
 801c1e4:	88fb      	ldrh	r3, [r7, #6]
 801c1e6:	0a1b      	lsrs	r3, r3, #8
 801c1e8:	b299      	uxth	r1, r3
 801c1ea:	8afb      	ldrh	r3, [r7, #22]
 801c1ec:	68fa      	ldr	r2, [r7, #12]
 801c1ee:	4413      	add	r3, r2
 801c1f0:	b2ca      	uxtb	r2, r1
 801c1f2:	701a      	strb	r2, [r3, #0]
	count++;
 801c1f4:	8afb      	ldrh	r3, [r7, #22]
 801c1f6:	3301      	adds	r3, #1
 801c1f8:	82fb      	strh	r3, [r7, #22]
	memcpy(&buf[count], data, data_length);
 801c1fa:	8afb      	ldrh	r3, [r7, #22]
 801c1fc:	68fa      	ldr	r2, [r7, #12]
 801c1fe:	4413      	add	r3, r2
 801c200:	88fa      	ldrh	r2, [r7, #6]
 801c202:	68b9      	ldr	r1, [r7, #8]
 801c204:	4618      	mov	r0, r3
 801c206:	f003 fb11 	bl	801f82c <memcpy>
	count = count + data_length;
 801c20a:	8afa      	ldrh	r2, [r7, #22]
 801c20c:	88fb      	ldrh	r3, [r7, #6]
 801c20e:	4413      	add	r3, r2
 801c210:	82fb      	strh	r3, [r7, #22]
	return count;
 801c212:	8afb      	ldrh	r3, [r7, #22]
}
 801c214:	4618      	mov	r0, r3
 801c216:	3718      	adds	r7, #24
 801c218:	46bd      	mov	sp, r7
 801c21a:	bd80      	pop	{r7, pc}
 801c21c:	24000478 	.word	0x24000478

0801c220 <parse_tlv>:

uint8_t parse_tlv(uint8_t* data, uint32_t* pro_len)
{
 801c220:	e92d 4fb0 	stmdb	sp!, {r4, r5, r7, r8, r9, sl, fp, lr}
 801c224:	b090      	sub	sp, #64	; 0x40
 801c226:	af00      	add	r7, sp, #0
 801c228:	62f8      	str	r0, [r7, #44]	; 0x2c
 801c22a:	62b9      	str	r1, [r7, #40]	; 0x28
	uint64_t len = 0;
 801c22c:	f04f 0200 	mov.w	r2, #0
 801c230:	f04f 0300 	mov.w	r3, #0
 801c234:	e9c7 230e 	strd	r2, r3, [r7, #56]	; 0x38
	uint16_t val_len = 0;
 801c238:	2300      	movs	r3, #0
 801c23a:	86fb      	strh	r3, [r7, #54]	; 0x36
	if (data[len] == PROTO_PSER_TLV_T_EPNAME) {
 801c23c:	6bba      	ldr	r2, [r7, #56]	; 0x38
 801c23e:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 801c240:	4413      	add	r3, r2
 801c242:	781b      	ldrb	r3, [r3, #0]
 801c244:	2b01      	cmp	r3, #1
 801c246:	f040 80b5 	bne.w	801c3b4 <parse_tlv+0x194>
		len++;
 801c24a:	e9d7 230e 	ldrd	r2, r3, [r7, #56]	; 0x38
 801c24e:	1c54      	adds	r4, r2, #1
 801c250:	f143 0500 	adc.w	r5, r3, #0
 801c254:	e9c7 450e 	strd	r4, r5, [r7, #56]	; 0x38
		val_len = data[len];
 801c258:	6bba      	ldr	r2, [r7, #56]	; 0x38
 801c25a:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 801c25c:	4413      	add	r3, r2
 801c25e:	781b      	ldrb	r3, [r3, #0]
 801c260:	86fb      	strh	r3, [r7, #54]	; 0x36
		len++;
 801c262:	e9d7 230e 	ldrd	r2, r3, [r7, #56]	; 0x38
 801c266:	f112 0801 	adds.w	r8, r2, #1
 801c26a:	f143 0900 	adc.w	r9, r3, #0
 801c26e:	e9c7 890e 	strd	r8, r9, [r7, #56]	; 0x38
		val_len = (data[len] << 8) + val_len;
 801c272:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 801c274:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 801c276:	4413      	add	r3, r2
 801c278:	781b      	ldrb	r3, [r3, #0]
 801c27a:	b29b      	uxth	r3, r3
 801c27c:	021b      	lsls	r3, r3, #8
 801c27e:	b29a      	uxth	r2, r3
 801c280:	8efb      	ldrh	r3, [r7, #54]	; 0x36
 801c282:	4413      	add	r3, r2
 801c284:	86fb      	strh	r3, [r7, #54]	; 0x36
		len++;
 801c286:	e9d7 230e 	ldrd	r2, r3, [r7, #56]	; 0x38
 801c28a:	1c51      	adds	r1, r2, #1
 801c28c:	6239      	str	r1, [r7, #32]
 801c28e:	f143 0300 	adc.w	r3, r3, #0
 801c292:	627b      	str	r3, [r7, #36]	; 0x24
 801c294:	e9d7 3408 	ldrd	r3, r4, [r7, #32]
 801c298:	e9c7 340e 	strd	r3, r4, [r7, #56]	; 0x38
		if (val_len == strlen(ep_name)) {
 801c29c:	8efc      	ldrh	r4, [r7, #54]	; 0x36
 801c29e:	4b4d      	ldr	r3, [pc, #308]	; (801c3d4 <parse_tlv+0x1b4>)
 801c2a0:	681b      	ldr	r3, [r3, #0]
 801c2a2:	4618      	mov	r0, r3
 801c2a4:	f7e4 f942 	bl	800052c <strlen>
 801c2a8:	4603      	mov	r3, r0
 801c2aa:	429c      	cmp	r4, r3
 801c2ac:	d176      	bne.n	801c39c <parse_tlv+0x17c>
			if (strncmp((char* )&data[len],ep_name,strlen(ep_name)) == 0) {
 801c2ae:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 801c2b0:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 801c2b2:	18d4      	adds	r4, r2, r3
 801c2b4:	4b47      	ldr	r3, [pc, #284]	; (801c3d4 <parse_tlv+0x1b4>)
 801c2b6:	681d      	ldr	r5, [r3, #0]
 801c2b8:	4b46      	ldr	r3, [pc, #280]	; (801c3d4 <parse_tlv+0x1b4>)
 801c2ba:	681b      	ldr	r3, [r3, #0]
 801c2bc:	4618      	mov	r0, r3
 801c2be:	f7e4 f935 	bl	800052c <strlen>
 801c2c2:	4603      	mov	r3, r0
 801c2c4:	461a      	mov	r2, r3
 801c2c6:	4629      	mov	r1, r5
 801c2c8:	4620      	mov	r0, r4
 801c2ca:	f004 faef 	bl	80208ac <strncmp>
 801c2ce:	4603      	mov	r3, r0
 801c2d0:	2b00      	cmp	r3, #0
 801c2d2:	d159      	bne.n	801c388 <parse_tlv+0x168>
				len = len + strlen(ep_name);
 801c2d4:	4b3f      	ldr	r3, [pc, #252]	; (801c3d4 <parse_tlv+0x1b4>)
 801c2d6:	681b      	ldr	r3, [r3, #0]
 801c2d8:	4618      	mov	r0, r3
 801c2da:	f7e4 f927 	bl	800052c <strlen>
 801c2de:	4603      	mov	r3, r0
 801c2e0:	2200      	movs	r2, #0
 801c2e2:	469a      	mov	sl, r3
 801c2e4:	4693      	mov	fp, r2
 801c2e6:	e9d7 230e 	ldrd	r2, r3, [r7, #56]	; 0x38
 801c2ea:	eb12 010a 	adds.w	r1, r2, sl
 801c2ee:	61b9      	str	r1, [r7, #24]
 801c2f0:	eb43 030b 	adc.w	r3, r3, fp
 801c2f4:	61fb      	str	r3, [r7, #28]
 801c2f6:	e9d7 3406 	ldrd	r3, r4, [r7, #24]
 801c2fa:	e9c7 340e 	strd	r3, r4, [r7, #56]	; 0x38
				if (data[len] == PROTO_PSER_TLV_T_DATA) {
 801c2fe:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 801c300:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 801c302:	4413      	add	r3, r2
 801c304:	781b      	ldrb	r3, [r3, #0]
 801c306:	2b02      	cmp	r3, #2
 801c308:	d134      	bne.n	801c374 <parse_tlv+0x154>
					len++;
 801c30a:	e9d7 230e 	ldrd	r2, r3, [r7, #56]	; 0x38
 801c30e:	1c51      	adds	r1, r2, #1
 801c310:	6139      	str	r1, [r7, #16]
 801c312:	f143 0300 	adc.w	r3, r3, #0
 801c316:	617b      	str	r3, [r7, #20]
 801c318:	e9d7 3404 	ldrd	r3, r4, [r7, #16]
 801c31c:	e9c7 340e 	strd	r3, r4, [r7, #56]	; 0x38
					val_len = data[len];
 801c320:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 801c322:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 801c324:	4413      	add	r3, r2
 801c326:	781b      	ldrb	r3, [r3, #0]
 801c328:	86fb      	strh	r3, [r7, #54]	; 0x36
					len++;
 801c32a:	e9d7 230e 	ldrd	r2, r3, [r7, #56]	; 0x38
 801c32e:	1c51      	adds	r1, r2, #1
 801c330:	60b9      	str	r1, [r7, #8]
 801c332:	f143 0300 	adc.w	r3, r3, #0
 801c336:	60fb      	str	r3, [r7, #12]
 801c338:	e9d7 3402 	ldrd	r3, r4, [r7, #8]
 801c33c:	e9c7 340e 	strd	r3, r4, [r7, #56]	; 0x38
					val_len = (data[len] << 8) + val_len;
 801c340:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 801c342:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 801c344:	4413      	add	r3, r2
 801c346:	781b      	ldrb	r3, [r3, #0]
 801c348:	b29b      	uxth	r3, r3
 801c34a:	021b      	lsls	r3, r3, #8
 801c34c:	b29a      	uxth	r2, r3
 801c34e:	8efb      	ldrh	r3, [r7, #54]	; 0x36
 801c350:	4413      	add	r3, r2
 801c352:	86fb      	strh	r3, [r7, #54]	; 0x36
					len++;
 801c354:	e9d7 230e 	ldrd	r2, r3, [r7, #56]	; 0x38
 801c358:	1c51      	adds	r1, r2, #1
 801c35a:	6039      	str	r1, [r7, #0]
 801c35c:	f143 0300 	adc.w	r3, r3, #0
 801c360:	607b      	str	r3, [r7, #4]
 801c362:	e9d7 3400 	ldrd	r3, r4, [r7]
 801c366:	e9c7 340e 	strd	r3, r4, [r7, #56]	; 0x38
					*pro_len = val_len;
 801c36a:	8efa      	ldrh	r2, [r7, #54]	; 0x36
 801c36c:	6abb      	ldr	r3, [r7, #40]	; 0x28
 801c36e:	601a      	str	r2, [r3, #0]
					return SUCCESS;
 801c370:	2300      	movs	r3, #0
 801c372:	e029      	b.n	801c3c8 <parse_tlv+0x1a8>
				} else {
					command_log("Data Type not matched, exp %d, recvd %d\n",
 801c374:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 801c376:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 801c378:	4413      	add	r3, r2
 801c37a:	781b      	ldrb	r3, [r3, #0]
 801c37c:	461a      	mov	r2, r3
 801c37e:	2102      	movs	r1, #2
 801c380:	4815      	ldr	r0, [pc, #84]	; (801c3d8 <parse_tlv+0x1b8>)
 801c382:	f003 fef3 	bl	802016c <iprintf>
 801c386:	e01e      	b.n	801c3c6 <parse_tlv+0x1a6>
							PROTO_PSER_TLV_T_DATA, data[len]);
				}
			} else {
				command_log("Endpoint Name not matched, exp %s, recvd %s\n",
 801c388:	4b12      	ldr	r3, [pc, #72]	; (801c3d4 <parse_tlv+0x1b4>)
 801c38a:	6819      	ldr	r1, [r3, #0]
 801c38c:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 801c38e:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 801c390:	4413      	add	r3, r2
 801c392:	461a      	mov	r2, r3
 801c394:	4811      	ldr	r0, [pc, #68]	; (801c3dc <parse_tlv+0x1bc>)
 801c396:	f003 fee9 	bl	802016c <iprintf>
 801c39a:	e014      	b.n	801c3c6 <parse_tlv+0x1a6>
						ep_name, (char* )&data[len]);
			}
		} else {
			command_log("Endpoint length not matched, exp %lu, recvd %d\n",
 801c39c:	4b0d      	ldr	r3, [pc, #52]	; (801c3d4 <parse_tlv+0x1b4>)
 801c39e:	681b      	ldr	r3, [r3, #0]
 801c3a0:	4618      	mov	r0, r3
 801c3a2:	f7e4 f8c3 	bl	800052c <strlen>
 801c3a6:	4601      	mov	r1, r0
 801c3a8:	8efb      	ldrh	r3, [r7, #54]	; 0x36
 801c3aa:	461a      	mov	r2, r3
 801c3ac:	480c      	ldr	r0, [pc, #48]	; (801c3e0 <parse_tlv+0x1c0>)
 801c3ae:	f003 fedd 	bl	802016c <iprintf>
 801c3b2:	e008      	b.n	801c3c6 <parse_tlv+0x1a6>
					(long unsigned int)(strlen(ep_name)), val_len);
		}
	} else {
		command_log("Endpoint type not matched, exp %d, recvd %d\n",
 801c3b4:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 801c3b6:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 801c3b8:	4413      	add	r3, r2
 801c3ba:	781b      	ldrb	r3, [r3, #0]
 801c3bc:	461a      	mov	r2, r3
 801c3be:	2101      	movs	r1, #1
 801c3c0:	4808      	ldr	r0, [pc, #32]	; (801c3e4 <parse_tlv+0x1c4>)
 801c3c2:	f003 fed3 	bl	802016c <iprintf>
				PROTO_PSER_TLV_T_EPNAME, data[len]);
	}
	return FAILURE;
 801c3c6:	23ff      	movs	r3, #255	; 0xff
}
 801c3c8:	4618      	mov	r0, r3
 801c3ca:	3740      	adds	r7, #64	; 0x40
 801c3cc:	46bd      	mov	sp, r7
 801c3ce:	e8bd 8fb0 	ldmia.w	sp!, {r4, r5, r7, r8, r9, sl, fp, pc}
 801c3d2:	bf00      	nop
 801c3d4:	24000478 	.word	0x24000478
 801c3d8:	08024ac0 	.word	0x08024ac0
 801c3dc:	08024aec 	.word	0x08024aec
 801c3e0:	08024b1c 	.word	0x08024b1c
 801c3e4:	08024b50 	.word	0x08024b50

0801c3e8 <transport_pserial_data_handler>:

uint8_t * transport_pserial_data_handler(uint8_t* data, uint16_t data_length,
		uint8_t wait, uint32_t* pro_len)
{
 801c3e8:	b580      	push	{r7, lr}
 801c3ea:	b08a      	sub	sp, #40	; 0x28
 801c3ec:	af00      	add	r7, sp, #0
 801c3ee:	60f8      	str	r0, [r7, #12]
 801c3f0:	607b      	str	r3, [r7, #4]
 801c3f2:	460b      	mov	r3, r1
 801c3f4:	817b      	strh	r3, [r7, #10]
 801c3f6:	4613      	mov	r3, r2
 801c3f8:	727b      	strb	r3, [r7, #9]
	int count = 0, ret = 0;
 801c3fa:	2300      	movs	r3, #0
 801c3fc:	617b      	str	r3, [r7, #20]
 801c3fe:	2300      	movs	r3, #0
 801c400:	627b      	str	r3, [r7, #36]	; 0x24
	uint16_t buf_len = 0, read_len = 0;
 801c402:	2300      	movs	r3, #0
 801c404:	847b      	strh	r3, [r7, #34]	; 0x22
 801c406:	2300      	movs	r3, #0
 801c408:	843b      	strh	r3, [r7, #32]
	uint8_t *write_buf = NULL, *read_buf = NULL;
 801c40a:	2300      	movs	r3, #0
 801c40c:	61fb      	str	r3, [r7, #28]
 801c40e:	2300      	movs	r3, #0
 801c410:	61bb      	str	r3, [r7, #24]
	struct esp_hosted_driver_handle_t* esp_hosted_driver_handle = NULL;
 801c412:	2300      	movs	r3, #0
 801c414:	613b      	str	r3, [r7, #16]
 *  Bytes used per field as follows:
 * --------------------------------------------------------------------------------------------
 *       1        |        2        | Endpoint length |     1     |      2      | Data length |
 * --------------------------------------------------------------------------------------------
 */
	buf_len = SIZE_OF_TYPE + SIZE_OF_LENGTH + strlen(ep_name) +
 801c416:	4b44      	ldr	r3, [pc, #272]	; (801c528 <transport_pserial_data_handler+0x140>)
 801c418:	681b      	ldr	r3, [r3, #0]
 801c41a:	4618      	mov	r0, r3
 801c41c:	f7e4 f886 	bl	800052c <strlen>
 801c420:	4603      	mov	r3, r0
		SIZE_OF_TYPE + SIZE_OF_LENGTH + data_length;
 801c422:	b29a      	uxth	r2, r3
 801c424:	897b      	ldrh	r3, [r7, #10]
 801c426:	4413      	add	r3, r2
 801c428:	b29b      	uxth	r3, r3
	buf_len = SIZE_OF_TYPE + SIZE_OF_LENGTH + strlen(ep_name) +
 801c42a:	3306      	adds	r3, #6
 801c42c:	847b      	strh	r3, [r7, #34]	; 0x22

	read_len = buf_len - data_length;
 801c42e:	8c7a      	ldrh	r2, [r7, #34]	; 0x22
 801c430:	897b      	ldrh	r3, [r7, #10]
 801c432:	1ad3      	subs	r3, r2, r3
 801c434:	843b      	strh	r3, [r7, #32]

	write_buf = (uint8_t* )esp_hosted_calloc(1, buf_len);
 801c436:	8c7b      	ldrh	r3, [r7, #34]	; 0x22
 801c438:	4619      	mov	r1, r3
 801c43a:	2001      	movs	r0, #1
 801c43c:	f001 f80c 	bl	801d458 <esp_hosted_calloc>
 801c440:	61f8      	str	r0, [r7, #28]
	if (!write_buf) {
 801c442:	69fb      	ldr	r3, [r7, #28]
 801c444:	2b00      	cmp	r3, #0
 801c446:	d104      	bne.n	801c452 <transport_pserial_data_handler+0x6a>
		command_log("Failed to allocate memory \n");
 801c448:	4838      	ldr	r0, [pc, #224]	; (801c52c <transport_pserial_data_handler+0x144>)
 801c44a:	f003 fe8f 	bl	802016c <iprintf>
		return NULL;
 801c44e:	2300      	movs	r3, #0
 801c450:	e065      	b.n	801c51e <transport_pserial_data_handler+0x136>
	}

	esp_hosted_driver_handle = esp_hosted_driver_open(transport);
 801c452:	4b37      	ldr	r3, [pc, #220]	; (801c530 <transport_pserial_data_handler+0x148>)
 801c454:	681b      	ldr	r3, [r3, #0]
 801c456:	4618      	mov	r0, r3
 801c458:	f001 f822 	bl	801d4a0 <esp_hosted_driver_open>
 801c45c:	4603      	mov	r3, r0
 801c45e:	613b      	str	r3, [r7, #16]
	if (!esp_hosted_driver_handle) {
 801c460:	693b      	ldr	r3, [r7, #16]
 801c462:	2b00      	cmp	r3, #0
 801c464:	d106      	bne.n	801c474 <transport_pserial_data_handler+0x8c>
		esp_hosted_free(write_buf);
 801c466:	69f8      	ldr	r0, [r7, #28]
 801c468:	f001 f80e 	bl	801d488 <esp_hosted_free>
		write_buf = NULL;
 801c46c:	2300      	movs	r3, #0
 801c46e:	61fb      	str	r3, [r7, #28]
		return NULL;
 801c470:	2300      	movs	r3, #0
 801c472:	e054      	b.n	801c51e <transport_pserial_data_handler+0x136>
	}

	count = compose_tlv(write_buf, data, data_length);
 801c474:	897b      	ldrh	r3, [r7, #10]
 801c476:	461a      	mov	r2, r3
 801c478:	68f9      	ldr	r1, [r7, #12]
 801c47a:	69f8      	ldr	r0, [r7, #28]
 801c47c:	f7ff fe68 	bl	801c150 <compose_tlv>
 801c480:	4603      	mov	r3, r0
 801c482:	617b      	str	r3, [r7, #20]
	if (!count) {
 801c484:	697b      	ldr	r3, [r7, #20]
 801c486:	2b00      	cmp	r3, #0
 801c488:	d103      	bne.n	801c492 <transport_pserial_data_handler+0xaa>
		command_log("Failed to compose TX data\n");
 801c48a:	482a      	ldr	r0, [pc, #168]	; (801c534 <transport_pserial_data_handler+0x14c>)
 801c48c:	f003 fe6e 	bl	802016c <iprintf>
		goto err;
 801c490:	e030      	b.n	801c4f4 <transport_pserial_data_handler+0x10c>
	}

	ret = esp_hosted_driver_write(esp_hosted_driver_handle, write_buf, count, &count);
 801c492:	6938      	ldr	r0, [r7, #16]
 801c494:	697a      	ldr	r2, [r7, #20]
 801c496:	f107 0314 	add.w	r3, r7, #20
 801c49a:	69f9      	ldr	r1, [r7, #28]
 801c49c:	f001 f824 	bl	801d4e8 <esp_hosted_driver_write>
 801c4a0:	6278      	str	r0, [r7, #36]	; 0x24
	if (ret != SUCCESS) {
 801c4a2:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801c4a4:	2b00      	cmp	r3, #0
 801c4a6:	d003      	beq.n	801c4b0 <transport_pserial_data_handler+0xc8>
		command_log("Failed to write TX data\n");
 801c4a8:	4823      	ldr	r0, [pc, #140]	; (801c538 <transport_pserial_data_handler+0x150>)
 801c4aa:	f003 fe5f 	bl	802016c <iprintf>
		goto err;
 801c4ae:	e021      	b.n	801c4f4 <transport_pserial_data_handler+0x10c>
	}

	read_buf = esp_hosted_driver_read(esp_hosted_driver_handle, read_len, wait, pro_len);
 801c4b0:	6938      	ldr	r0, [r7, #16]
 801c4b2:	8c39      	ldrh	r1, [r7, #32]
 801c4b4:	7a7a      	ldrb	r2, [r7, #9]
 801c4b6:	687b      	ldr	r3, [r7, #4]
 801c4b8:	f001 f86e 	bl	801d598 <esp_hosted_driver_read>
 801c4bc:	61b8      	str	r0, [r7, #24]
	if (! read_buf) {
 801c4be:	69bb      	ldr	r3, [r7, #24]
 801c4c0:	2b00      	cmp	r3, #0
 801c4c2:	d103      	bne.n	801c4cc <transport_pserial_data_handler+0xe4>
		command_log("Failed to read RX data\n");
 801c4c4:	481d      	ldr	r0, [pc, #116]	; (801c53c <transport_pserial_data_handler+0x154>)
 801c4c6:	f003 fe51 	bl	802016c <iprintf>
		goto err;
 801c4ca:	e013      	b.n	801c4f4 <transport_pserial_data_handler+0x10c>
	} else if (!pro_len) {
 801c4cc:	687b      	ldr	r3, [r7, #4]
 801c4ce:	2b00      	cmp	r3, #0
 801c4d0:	d102      	bne.n	801c4d8 <transport_pserial_data_handler+0xf0>
		command_log("Zero protobuf data length received \n");
 801c4d2:	481b      	ldr	r0, [pc, #108]	; (801c540 <transport_pserial_data_handler+0x158>)
 801c4d4:	f003 fe4a 	bl	802016c <iprintf>
	}

	ret = esp_hosted_driver_close(&esp_hosted_driver_handle);
 801c4d8:	f107 0310 	add.w	r3, r7, #16
 801c4dc:	4618      	mov	r0, r3
 801c4de:	f001 f927 	bl	801d730 <esp_hosted_driver_close>
 801c4e2:	6278      	str	r0, [r7, #36]	; 0x24
	if (ret != SUCCESS) {
 801c4e4:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801c4e6:	2b00      	cmp	r3, #0
 801c4e8:	d002      	beq.n	801c4f0 <transport_pserial_data_handler+0x108>
		command_log("Failed to close driver interface\n");
 801c4ea:	4816      	ldr	r0, [pc, #88]	; (801c544 <transport_pserial_data_handler+0x15c>)
 801c4ec:	f003 fe3e 	bl	802016c <iprintf>
	}

	return read_buf;
 801c4f0:	69bb      	ldr	r3, [r7, #24]
 801c4f2:	e014      	b.n	801c51e <transport_pserial_data_handler+0x136>
err:
	if (write_buf) {
 801c4f4:	69fb      	ldr	r3, [r7, #28]
 801c4f6:	2b00      	cmp	r3, #0
 801c4f8:	d004      	beq.n	801c504 <transport_pserial_data_handler+0x11c>
		esp_hosted_free(write_buf);
 801c4fa:	69f8      	ldr	r0, [r7, #28]
 801c4fc:	f000 ffc4 	bl	801d488 <esp_hosted_free>
		write_buf = NULL;
 801c500:	2300      	movs	r3, #0
 801c502:	61fb      	str	r3, [r7, #28]
	}

	ret = esp_hosted_driver_close(&esp_hosted_driver_handle);
 801c504:	f107 0310 	add.w	r3, r7, #16
 801c508:	4618      	mov	r0, r3
 801c50a:	f001 f911 	bl	801d730 <esp_hosted_driver_close>
 801c50e:	6278      	str	r0, [r7, #36]	; 0x24
	if (ret != SUCCESS) {
 801c510:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801c512:	2b00      	cmp	r3, #0
 801c514:	d002      	beq.n	801c51c <transport_pserial_data_handler+0x134>
		command_log("Failed to close driver interface\n");
 801c516:	480b      	ldr	r0, [pc, #44]	; (801c544 <transport_pserial_data_handler+0x15c>)
 801c518:	f003 fe28 	bl	802016c <iprintf>
	}
	return NULL;
 801c51c:	2300      	movs	r3, #0
}
 801c51e:	4618      	mov	r0, r3
 801c520:	3728      	adds	r7, #40	; 0x28
 801c522:	46bd      	mov	sp, r7
 801c524:	bd80      	pop	{r7, pc}
 801c526:	bf00      	nop
 801c528:	24000478 	.word	0x24000478
 801c52c:	08024b80 	.word	0x08024b80
 801c530:	24000474 	.word	0x24000474
 801c534:	08024ba0 	.word	0x08024ba0
 801c538:	08024bbc 	.word	0x08024bbc
 801c53c:	08024bd8 	.word	0x08024bd8
 801c540:	08024bf4 	.word	0x08024bf4
 801c544:	08024c1c 	.word	0x08024c1c

0801c548 <reset_slave>:
  * @brief  Reset slave to initialize
  * @param  None
  * @retval None
  */
void reset_slave(void)
{
 801c548:	b580      	push	{r7, lr}
 801c54a:	b086      	sub	sp, #24
 801c54c:	af00      	add	r7, sp, #0

	/* GPIO Ports Clock Enable */
	//__HAL_RCC_GPIOA_CLK_ENABLE();

	/* TODO: make this pin configurable from project config */
	GPIO_InitStruct.Pin = GPIO_RESET_Pin;
 801c54e:	2304      	movs	r3, #4
 801c550:	607b      	str	r3, [r7, #4]
	GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
 801c552:	2301      	movs	r3, #1
 801c554:	60bb      	str	r3, [r7, #8]
	GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
 801c556:	2300      	movs	r3, #0
 801c558:	613b      	str	r3, [r7, #16]
	HAL_GPIO_Init(GPIO_RESET_GPIO_Port, &GPIO_InitStruct);
 801c55a:	1d3b      	adds	r3, r7, #4
 801c55c:	4619      	mov	r1, r3
 801c55e:	480d      	ldr	r0, [pc, #52]	; (801c594 <reset_slave+0x4c>)
 801c560:	f7e5 fa5e 	bl	8001a20 <HAL_GPIO_Init>

	HAL_GPIO_WritePin(GPIO_RESET_GPIO_Port, GPIO_RESET_Pin, GPIO_PIN_RESET);
 801c564:	2200      	movs	r2, #0
 801c566:	2104      	movs	r1, #4
 801c568:	480a      	ldr	r0, [pc, #40]	; (801c594 <reset_slave+0x4c>)
 801c56a:	f7e5 fc21 	bl	8001db0 <HAL_GPIO_WritePin>
	hard_delay(50);
 801c56e:	2032      	movs	r0, #50	; 0x32
 801c570:	f001 fbbf 	bl	801dcf2 <hard_delay>
	//HAL_Delay(50);
	/* revert to initial state */
	GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
 801c574:	2300      	movs	r3, #0
 801c576:	60bb      	str	r3, [r7, #8]
	HAL_GPIO_Init(GPIO_RESET_GPIO_Port, &GPIO_InitStruct);
 801c578:	1d3b      	adds	r3, r7, #4
 801c57a:	4619      	mov	r1, r3
 801c57c:	4805      	ldr	r0, [pc, #20]	; (801c594 <reset_slave+0x4c>)
 801c57e:	f7e5 fa4f 	bl	8001a20 <HAL_GPIO_Init>

	/* stop spi transactions short time to avoid slave sync issues */
	hard_delay(50000);
 801c582:	f24c 3050 	movw	r0, #50000	; 0xc350
 801c586:	f001 fbb4 	bl	801dcf2 <hard_delay>
	//HAL_Delay(50000);
}
 801c58a:	bf00      	nop
 801c58c:	3718      	adds	r7, #24
 801c58e:	46bd      	mov	sp, r7
 801c590:	bd80      	pop	{r7, pc}
 801c592:	bf00      	nop
 801c594:	58022800 	.word	0x58022800

0801c598 <control_path_event_handler>:
  * @brief  Control path event handler callback
  * @param  event - spi_drv_events_e event to be handled
  * @retval None
  */
static void control_path_event_handler(uint8_t event)
{
 801c598:	b580      	push	{r7, lr}
 801c59a:	b082      	sub	sp, #8
 801c59c:	af00      	add	r7, sp, #0
 801c59e:	4603      	mov	r3, r0
 801c5a0:	71fb      	strb	r3, [r7, #7]
	switch(event)
 801c5a2:	79fb      	ldrb	r3, [r7, #7]
 801c5a4:	2b03      	cmp	r3, #3
 801c5a6:	d825      	bhi.n	801c5f4 <control_path_event_handler+0x5c>
 801c5a8:	a201      	add	r2, pc, #4	; (adr r2, 801c5b0 <control_path_event_handler+0x18>)
 801c5aa:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 801c5ae:	bf00      	nop
 801c5b0:	0801c5c1 	.word	0x0801c5c1
 801c5b4:	0801c5cd 	.word	0x0801c5cd
 801c5b8:	0801c5db 	.word	0x0801c5db
 801c5bc:	0801c5e7 	.word	0x0801c5e7
	{
		case STATION_CONNECTED:
		{
			station_connected = true;
 801c5c0:	4b0f      	ldr	r3, [pc, #60]	; (801c600 <control_path_event_handler+0x68>)
 801c5c2:	2201      	movs	r2, #1
 801c5c4:	701a      	strb	r2, [r3, #0]
			 init_sta();
 801c5c6:	f000 f94d 	bl	801c864 <init_sta>
			break;
 801c5ca:	e014      	b.n	801c5f6 <control_path_event_handler+0x5e>
		}
		case STATION_DISCONNECTED:
		{
			station_connected = false;
 801c5cc:	4b0c      	ldr	r3, [pc, #48]	; (801c600 <control_path_event_handler+0x68>)
 801c5ce:	2200      	movs	r2, #0
 801c5d0:	701a      	strb	r2, [r3, #0]
			printf("station disconnected\n\r");
 801c5d2:	480c      	ldr	r0, [pc, #48]	; (801c604 <control_path_event_handler+0x6c>)
 801c5d4:	f003 fdca 	bl	802016c <iprintf>
			break;
 801c5d8:	e00d      	b.n	801c5f6 <control_path_event_handler+0x5e>
		}
		case SOFTAP_STARTED:
		{
			ap_connected = true;
 801c5da:	4b0b      	ldr	r3, [pc, #44]	; (801c608 <control_path_event_handler+0x70>)
 801c5dc:	2201      	movs	r2, #1
 801c5de:	701a      	strb	r2, [r3, #0]
			init_ap();
 801c5e0:	f000 f960 	bl	801c8a4 <init_ap>
			break;
 801c5e4:	e007      	b.n	801c5f6 <control_path_event_handler+0x5e>
		}
		case SOFTAP_STOPPED:
		{
			ap_connected = false;
 801c5e6:	4b08      	ldr	r3, [pc, #32]	; (801c608 <control_path_event_handler+0x70>)
 801c5e8:	2200      	movs	r2, #0
 801c5ea:	701a      	strb	r2, [r3, #0]
			printf("softap stopped\n\r");
 801c5ec:	4807      	ldr	r0, [pc, #28]	; (801c60c <control_path_event_handler+0x74>)
 801c5ee:	f003 fdbd 	bl	802016c <iprintf>
			break;
 801c5f2:	e000      	b.n	801c5f6 <control_path_event_handler+0x5e>
		}
		default:
		break;
 801c5f4:	bf00      	nop
	}
}
 801c5f6:	bf00      	nop
 801c5f8:	3708      	adds	r7, #8
 801c5fa:	46bd      	mov	sp, r7
 801c5fc:	bd80      	pop	{r7, pc}
 801c5fe:	bf00      	nop
 801c600:	24034b14 	.word	0x24034b14
 801c604:	08024c40 	.word	0x08024c40
 801c608:	24034b15 	.word	0x24034b15
 801c60c:	08024c58 	.word	0x08024c58

0801c610 <spi_driver_event_handler>:
  * @brief  SPI driver event handler callback
  * @param  event - spi_drv_events_e event to be handled
  * @retval None
  */
void spi_driver_event_handler(uint8_t event)
{
 801c610:	b580      	push	{r7, lr}
 801c612:	b082      	sub	sp, #8
 801c614:	af00      	add	r7, sp, #0
 801c616:	4603      	mov	r3, r0
 801c618:	71fb      	strb	r3, [r7, #7]
	switch(event)
 801c61a:	79fb      	ldrb	r3, [r7, #7]
 801c61c:	2b00      	cmp	r3, #0
 801c61e:	d103      	bne.n	801c628 <spi_driver_event_handler+0x18>
	{
		case SPI_DRIVER_ACTIVE:
		{
			/* Initiate control path now */
			control_path_init(control_path_event_handler);
 801c620:	4804      	ldr	r0, [pc, #16]	; (801c634 <spi_driver_event_handler+0x24>)
 801c622:	f000 f9f1 	bl	801ca08 <control_path_init>
			break;
 801c626:	e000      	b.n	801c62a <spi_driver_event_handler+0x1a>
		}
		default:
		break;
 801c628:	bf00      	nop
	}
}
 801c62a:	bf00      	nop
 801c62c:	3708      	adds	r7, #8
 801c62e:	46bd      	mov	sp, r7
 801c630:	bd80      	pop	{r7, pc}
 801c632:	bf00      	nop
 801c634:	0801c599 	.word	0x0801c599

0801c638 <__io_putchar>:
  * @brief  Retargets the C library printf function to the USART.
  * @param  None
  * @retval None
  */
PUTCHAR_PROTOTYPE
{
 801c638:	b580      	push	{r7, lr}
 801c63a:	b082      	sub	sp, #8
 801c63c:	af00      	add	r7, sp, #0
 801c63e:	6078      	str	r0, [r7, #4]
	/* Place your implementation of fputc here */
	/* e.g. write a character to the USART6 and
	 * Loop until the end of transmission */
	HAL_UART_Transmit(&huart1, (uint8_t *)&ch, 1, 0xFFFF);
 801c640:	1d39      	adds	r1, r7, #4
 801c642:	f64f 73ff 	movw	r3, #65535	; 0xffff
 801c646:	2201      	movs	r2, #1
 801c648:	4803      	ldr	r0, [pc, #12]	; (801c658 <__io_putchar+0x20>)
 801c64a:	f7e8 fffd 	bl	8005648 <HAL_UART_Transmit>

	return ch;
 801c64e:	687b      	ldr	r3, [r7, #4]
}
 801c650:	4618      	mov	r0, r3
 801c652:	3708      	adds	r7, #8
 801c654:	46bd      	mov	sp, r7
 801c656:	bd80      	pop	{r7, pc}
 801c658:	24000a64 	.word	0x24000a64

0801c65c <sta_rx_callback>:
  * @brief Station mode rx callback
  * @param  net_handle - station network handle
  * @retval None
  */
static void sta_rx_callback(struct network_handle *net_handle)
{
 801c65c:	b590      	push	{r4, r7, lr}
 801c65e:	b08b      	sub	sp, #44	; 0x2c
 801c660:	af02      	add	r7, sp, #8
 801c662:	6078      	str	r0, [r7, #4]
	struct pbuf *rx_buffer = NULL;
 801c664:	2300      	movs	r3, #0
 801c666:	61fb      	str	r3, [r7, #28]
	struct pbuf *snd_buffer = NULL;
 801c668:	2300      	movs	r3, #0
 801c66a:	61bb      	str	r3, [r7, #24]
	uint8_t *arp_resp = NULL;
 801c66c:	2300      	movs	r3, #0
 801c66e:	617b      	str	r3, [r7, #20]
	uint16_t arp_resp_len = 0;
 801c670:	2300      	movs	r3, #0
 801c672:	81fb      	strh	r3, [r7, #14]
	uint32_t sta_ip = 0;
 801c674:	2300      	movs	r3, #0
 801c676:	60bb      	str	r3, [r7, #8]
	int ret;

	rx_buffer = network_read(net_handle, 0);
 801c678:	2100      	movs	r1, #0
 801c67a:	6878      	ldr	r0, [r7, #4]
 801c67c:	f001 fe3e 	bl	801e2fc <network_read>
 801c680:	61f8      	str	r0, [r7, #28]

	if (get_self_ip_station(&sta_ip)) {
 801c682:	f107 0308 	add.w	r3, r7, #8
 801c686:	4618      	mov	r0, r3
 801c688:	f000 f972 	bl	801c970 <get_self_ip_station>
 801c68c:	4603      	mov	r3, r0
 801c68e:	2b00      	cmp	r3, #0
 801c690:	d013      	beq.n	801c6ba <sta_rx_callback+0x5e>
		printf("Problem getting self station ip\n\r");
 801c692:	482e      	ldr	r0, [pc, #184]	; (801c74c <sta_rx_callback+0xf0>)
 801c694:	f003 fd6a 	bl	802016c <iprintf>
		if(rx_buffer) {
 801c698:	69fb      	ldr	r3, [r7, #28]
 801c69a:	2b00      	cmp	r3, #0
 801c69c:	d052      	beq.n	801c744 <sta_rx_callback+0xe8>
			free(rx_buffer->payload);
 801c69e:	69fb      	ldr	r3, [r7, #28]
 801c6a0:	681b      	ldr	r3, [r3, #0]
 801c6a2:	4618      	mov	r0, r3
 801c6a4:	f000 fef0 	bl	801d488 <esp_hosted_free>
			rx_buffer->payload = NULL;
 801c6a8:	69fb      	ldr	r3, [r7, #28]
 801c6aa:	2200      	movs	r2, #0
 801c6ac:	601a      	str	r2, [r3, #0]
			free(rx_buffer);
 801c6ae:	69f8      	ldr	r0, [r7, #28]
 801c6b0:	f000 feea 	bl	801d488 <esp_hosted_free>
			rx_buffer = NULL;
 801c6b4:	2300      	movs	r3, #0
 801c6b6:	61fb      	str	r3, [r7, #28]
 801c6b8:	e045      	b.n	801c746 <sta_rx_callback+0xea>
		}
		return;
	}

	if (rx_buffer) {
 801c6ba:	69fb      	ldr	r3, [r7, #28]
 801c6bc:	2b00      	cmp	r3, #0
 801c6be:	d042      	beq.n	801c746 <sta_rx_callback+0xea>
		arp_resp = arp_req_handler(&sta_ip, get_self_mac_station(), rx_buffer->payload,
 801c6c0:	f000 f98e 	bl	801c9e0 <get_self_mac_station>
 801c6c4:	4604      	mov	r4, r0
 801c6c6:	69fb      	ldr	r3, [r7, #28]
 801c6c8:	681a      	ldr	r2, [r3, #0]
 801c6ca:	69fb      	ldr	r3, [r7, #28]
 801c6cc:	8899      	ldrh	r1, [r3, #4]
 801c6ce:	f107 0008 	add.w	r0, r7, #8
 801c6d2:	f107 030e 	add.w	r3, r7, #14
 801c6d6:	9300      	str	r3, [sp, #0]
 801c6d8:	460b      	mov	r3, r1
 801c6da:	4621      	mov	r1, r4
 801c6dc:	f001 fa4a 	bl	801db74 <arp_req_handler>
 801c6e0:	6178      	str	r0, [r7, #20]
				rx_buffer->len, &arp_resp_len);

		if (arp_resp) {
 801c6e2:	697b      	ldr	r3, [r7, #20]
 801c6e4:	2b00      	cmp	r3, #0
 801c6e6:	d01f      	beq.n	801c728 <sta_rx_callback+0xcc>
			snd_buffer = malloc(sizeof(struct pbuf));
 801c6e8:	2008      	movs	r0, #8
 801c6ea:	f000 fe9d 	bl	801d428 <esp_hosted_malloc>
 801c6ee:	61b8      	str	r0, [r7, #24]
			assert(snd_buffer);
 801c6f0:	69bb      	ldr	r3, [r7, #24]
 801c6f2:	2b00      	cmp	r3, #0
 801c6f4:	d106      	bne.n	801c704 <sta_rx_callback+0xa8>
 801c6f6:	f44f 7285 	mov.w	r2, #266	; 0x10a
 801c6fa:	4915      	ldr	r1, [pc, #84]	; (801c750 <sta_rx_callback+0xf4>)
 801c6fc:	4815      	ldr	r0, [pc, #84]	; (801c754 <sta_rx_callback+0xf8>)
 801c6fe:	f003 fd35 	bl	802016c <iprintf>
 801c702:	e7fe      	b.n	801c702 <sta_rx_callback+0xa6>

			snd_buffer->payload = arp_resp;
 801c704:	69bb      	ldr	r3, [r7, #24]
 801c706:	697a      	ldr	r2, [r7, #20]
 801c708:	601a      	str	r2, [r3, #0]
			snd_buffer->len = arp_resp_len;
 801c70a:	89fa      	ldrh	r2, [r7, #14]
 801c70c:	69bb      	ldr	r3, [r7, #24]
 801c70e:	809a      	strh	r2, [r3, #4]

			ret = network_write(net_handle, snd_buffer);
 801c710:	69b9      	ldr	r1, [r7, #24]
 801c712:	6878      	ldr	r0, [r7, #4]
 801c714:	f001 fe32 	bl	801e37c <network_write>
 801c718:	6138      	str	r0, [r7, #16]

			if (ret)
 801c71a:	693b      	ldr	r3, [r7, #16]
 801c71c:	2b00      	cmp	r3, #0
 801c71e:	d003      	beq.n	801c728 <sta_rx_callback+0xcc>
				printf("%s: Failed to send arp response\n\r", __func__);
 801c720:	490d      	ldr	r1, [pc, #52]	; (801c758 <sta_rx_callback+0xfc>)
 801c722:	480e      	ldr	r0, [pc, #56]	; (801c75c <sta_rx_callback+0x100>)
 801c724:	f003 fd22 	bl	802016c <iprintf>
		}

		free(rx_buffer->payload);
 801c728:	69fb      	ldr	r3, [r7, #28]
 801c72a:	681b      	ldr	r3, [r3, #0]
 801c72c:	4618      	mov	r0, r3
 801c72e:	f000 feab 	bl	801d488 <esp_hosted_free>
		rx_buffer->payload = NULL;
 801c732:	69fb      	ldr	r3, [r7, #28]
 801c734:	2200      	movs	r2, #0
 801c736:	601a      	str	r2, [r3, #0]
		free(rx_buffer);
 801c738:	69f8      	ldr	r0, [r7, #28]
 801c73a:	f000 fea5 	bl	801d488 <esp_hosted_free>
		rx_buffer = NULL;
 801c73e:	2300      	movs	r3, #0
 801c740:	61fb      	str	r3, [r7, #28]
 801c742:	e000      	b.n	801c746 <sta_rx_callback+0xea>
		return;
 801c744:	bf00      	nop
	}
}
 801c746:	3724      	adds	r7, #36	; 0x24
 801c748:	46bd      	mov	sp, r7
 801c74a:	bd90      	pop	{r4, r7, pc}
 801c74c:	08024cd0 	.word	0x08024cd0
 801c750:	08024c78 	.word	0x08024c78
 801c754:	08024cbc 	.word	0x08024cbc
 801c758:	080287b0 	.word	0x080287b0
 801c75c:	08024cf4 	.word	0x08024cf4

0801c760 <ap_rx_callback>:
  * @brief Softap mode rx callback
  * @param  net_handle - Softap network handle
  * @retval None
  */
static void ap_rx_callback(struct network_handle *net_handle)
{
 801c760:	b590      	push	{r4, r7, lr}
 801c762:	b08b      	sub	sp, #44	; 0x2c
 801c764:	af02      	add	r7, sp, #8
 801c766:	6078      	str	r0, [r7, #4]
	struct pbuf *rx_buffer = NULL;
 801c768:	2300      	movs	r3, #0
 801c76a:	61fb      	str	r3, [r7, #28]
	struct pbuf *snd_buffer = NULL;
 801c76c:	2300      	movs	r3, #0
 801c76e:	61bb      	str	r3, [r7, #24]
	uint8_t *arp_resp = NULL;
 801c770:	2300      	movs	r3, #0
 801c772:	617b      	str	r3, [r7, #20]
	uint16_t arp_resp_len = 0;
 801c774:	2300      	movs	r3, #0
 801c776:	81fb      	strh	r3, [r7, #14]
	int ret;
	uint32_t softap_ip = 0;
 801c778:	2300      	movs	r3, #0
 801c77a:	60bb      	str	r3, [r7, #8]

	rx_buffer = network_read(net_handle, 0);
 801c77c:	2100      	movs	r1, #0
 801c77e:	6878      	ldr	r0, [r7, #4]
 801c780:	f001 fdbc 	bl	801e2fc <network_read>
 801c784:	61f8      	str	r0, [r7, #28]

	if (get_self_ip_softap(&softap_ip)) {
 801c786:	f107 0308 	add.w	r3, r7, #8
 801c78a:	4618      	mov	r0, r3
 801c78c:	f000 f90c 	bl	801c9a8 <get_self_ip_softap>
 801c790:	4603      	mov	r3, r0
 801c792:	2b00      	cmp	r3, #0
 801c794:	d013      	beq.n	801c7be <ap_rx_callback+0x5e>
		printf("Problem getting self softap ip\n\r");
 801c796:	482e      	ldr	r0, [pc, #184]	; (801c850 <ap_rx_callback+0xf0>)
 801c798:	f003 fce8 	bl	802016c <iprintf>
		if(rx_buffer) {
 801c79c:	69fb      	ldr	r3, [r7, #28]
 801c79e:	2b00      	cmp	r3, #0
 801c7a0:	d052      	beq.n	801c848 <ap_rx_callback+0xe8>
			free(rx_buffer->payload);
 801c7a2:	69fb      	ldr	r3, [r7, #28]
 801c7a4:	681b      	ldr	r3, [r3, #0]
 801c7a6:	4618      	mov	r0, r3
 801c7a8:	f000 fe6e 	bl	801d488 <esp_hosted_free>
			rx_buffer->payload = NULL;
 801c7ac:	69fb      	ldr	r3, [r7, #28]
 801c7ae:	2200      	movs	r2, #0
 801c7b0:	601a      	str	r2, [r3, #0]
			free(rx_buffer);
 801c7b2:	69f8      	ldr	r0, [r7, #28]
 801c7b4:	f000 fe68 	bl	801d488 <esp_hosted_free>
			rx_buffer = NULL;
 801c7b8:	2300      	movs	r3, #0
 801c7ba:	61fb      	str	r3, [r7, #28]
 801c7bc:	e045      	b.n	801c84a <ap_rx_callback+0xea>
		}
		return;
	}

	if (rx_buffer) {
 801c7be:	69fb      	ldr	r3, [r7, #28]
 801c7c0:	2b00      	cmp	r3, #0
 801c7c2:	d042      	beq.n	801c84a <ap_rx_callback+0xea>
		arp_resp = arp_req_handler(&softap_ip, get_self_mac_softap(),
 801c7c4:	f000 f916 	bl	801c9f4 <get_self_mac_softap>
 801c7c8:	4604      	mov	r4, r0
 801c7ca:	69fb      	ldr	r3, [r7, #28]
 801c7cc:	681a      	ldr	r2, [r3, #0]
 801c7ce:	69fb      	ldr	r3, [r7, #28]
 801c7d0:	8899      	ldrh	r1, [r3, #4]
 801c7d2:	f107 0008 	add.w	r0, r7, #8
 801c7d6:	f107 030e 	add.w	r3, r7, #14
 801c7da:	9300      	str	r3, [sp, #0]
 801c7dc:	460b      	mov	r3, r1
 801c7de:	4621      	mov	r1, r4
 801c7e0:	f001 f9c8 	bl	801db74 <arp_req_handler>
 801c7e4:	6178      	str	r0, [r7, #20]
				rx_buffer->payload, rx_buffer->len, &arp_resp_len);

		if (arp_resp) {
 801c7e6:	697b      	ldr	r3, [r7, #20]
 801c7e8:	2b00      	cmp	r3, #0
 801c7ea:	d01f      	beq.n	801c82c <ap_rx_callback+0xcc>
			snd_buffer = malloc(sizeof(struct pbuf));
 801c7ec:	2008      	movs	r0, #8
 801c7ee:	f000 fe1b 	bl	801d428 <esp_hosted_malloc>
 801c7f2:	61b8      	str	r0, [r7, #24]
			assert(snd_buffer);
 801c7f4:	69bb      	ldr	r3, [r7, #24]
 801c7f6:	2b00      	cmp	r3, #0
 801c7f8:	d106      	bne.n	801c808 <ap_rx_callback+0xa8>
 801c7fa:	f240 123d 	movw	r2, #317	; 0x13d
 801c7fe:	4915      	ldr	r1, [pc, #84]	; (801c854 <ap_rx_callback+0xf4>)
 801c800:	4815      	ldr	r0, [pc, #84]	; (801c858 <ap_rx_callback+0xf8>)
 801c802:	f003 fcb3 	bl	802016c <iprintf>
 801c806:	e7fe      	b.n	801c806 <ap_rx_callback+0xa6>

			snd_buffer->payload = arp_resp;
 801c808:	69bb      	ldr	r3, [r7, #24]
 801c80a:	697a      	ldr	r2, [r7, #20]
 801c80c:	601a      	str	r2, [r3, #0]
			snd_buffer->len = arp_resp_len;
 801c80e:	89fa      	ldrh	r2, [r7, #14]
 801c810:	69bb      	ldr	r3, [r7, #24]
 801c812:	809a      	strh	r2, [r3, #4]

			ret = network_write(net_handle, snd_buffer);
 801c814:	69b9      	ldr	r1, [r7, #24]
 801c816:	6878      	ldr	r0, [r7, #4]
 801c818:	f001 fdb0 	bl	801e37c <network_write>
 801c81c:	6138      	str	r0, [r7, #16]

			if (ret)
 801c81e:	693b      	ldr	r3, [r7, #16]
 801c820:	2b00      	cmp	r3, #0
 801c822:	d003      	beq.n	801c82c <ap_rx_callback+0xcc>
				printf("%s: Failed to send arp response\n\r", __func__);
 801c824:	490d      	ldr	r1, [pc, #52]	; (801c85c <ap_rx_callback+0xfc>)
 801c826:	480e      	ldr	r0, [pc, #56]	; (801c860 <ap_rx_callback+0x100>)
 801c828:	f003 fca0 	bl	802016c <iprintf>
		}

		free(rx_buffer->payload);
 801c82c:	69fb      	ldr	r3, [r7, #28]
 801c82e:	681b      	ldr	r3, [r3, #0]
 801c830:	4618      	mov	r0, r3
 801c832:	f000 fe29 	bl	801d488 <esp_hosted_free>
		rx_buffer->payload = NULL;
 801c836:	69fb      	ldr	r3, [r7, #28]
 801c838:	2200      	movs	r2, #0
 801c83a:	601a      	str	r2, [r3, #0]
		free(rx_buffer);
 801c83c:	69f8      	ldr	r0, [r7, #28]
 801c83e:	f000 fe23 	bl	801d488 <esp_hosted_free>
		rx_buffer = NULL;
 801c842:	2300      	movs	r3, #0
 801c844:	61fb      	str	r3, [r7, #28]
 801c846:	e000      	b.n	801c84a <ap_rx_callback+0xea>
		return;
 801c848:	bf00      	nop
	}
}
 801c84a:	3724      	adds	r7, #36	; 0x24
 801c84c:	46bd      	mov	sp, r7
 801c84e:	bd90      	pop	{r4, r7, pc}
 801c850:	08024d18 	.word	0x08024d18
 801c854:	08024c78 	.word	0x08024c78
 801c858:	08024cbc 	.word	0x08024cbc
 801c85c:	080287c0 	.word	0x080287c0
 801c860:	08024cf4 	.word	0x08024cf4

0801c864 <init_sta>:
  * @brief start station mode network path
  * @param None
  * @retval None
  */
static void init_sta(void)
{
 801c864:	b580      	push	{r7, lr}
 801c866:	af00      	add	r7, sp, #0
	sta_handle = network_open(STA_INTERFACE, sta_rx_callback);
 801c868:	4909      	ldr	r1, [pc, #36]	; (801c890 <init_sta+0x2c>)
 801c86a:	480a      	ldr	r0, [pc, #40]	; (801c894 <init_sta+0x30>)
 801c86c:	f001 fd06 	bl	801e27c <network_open>
 801c870:	4603      	mov	r3, r0
 801c872:	4a09      	ldr	r2, [pc, #36]	; (801c898 <init_sta+0x34>)
 801c874:	6013      	str	r3, [r2, #0]
	assert(sta_handle);
 801c876:	4b08      	ldr	r3, [pc, #32]	; (801c898 <init_sta+0x34>)
 801c878:	681b      	ldr	r3, [r3, #0]
 801c87a:	2b00      	cmp	r3, #0
 801c87c:	d106      	bne.n	801c88c <init_sta+0x28>
 801c87e:	f44f 72ac 	mov.w	r2, #344	; 0x158
 801c882:	4906      	ldr	r1, [pc, #24]	; (801c89c <init_sta+0x38>)
 801c884:	4806      	ldr	r0, [pc, #24]	; (801c8a0 <init_sta+0x3c>)
 801c886:	f003 fc71 	bl	802016c <iprintf>
 801c88a:	e7fe      	b.n	801c88a <init_sta+0x26>
}
 801c88c:	bf00      	nop
 801c88e:	bd80      	pop	{r7, pc}
 801c890:	0801c65d 	.word	0x0801c65d
 801c894:	08024d3c 	.word	0x08024d3c
 801c898:	24034b18 	.word	0x24034b18
 801c89c:	08024c78 	.word	0x08024c78
 801c8a0:	08024cbc 	.word	0x08024cbc

0801c8a4 <init_ap>:
  * @brief start softap mode network path
  * @param None
  * @retval None
  */
static void init_ap(void)
{
 801c8a4:	b580      	push	{r7, lr}
 801c8a6:	af00      	add	r7, sp, #0
	ap_handle = network_open(SOFTAP_INTERFACE, ap_rx_callback);
 801c8a8:	4909      	ldr	r1, [pc, #36]	; (801c8d0 <init_ap+0x2c>)
 801c8aa:	480a      	ldr	r0, [pc, #40]	; (801c8d4 <init_ap+0x30>)
 801c8ac:	f001 fce6 	bl	801e27c <network_open>
 801c8b0:	4603      	mov	r3, r0
 801c8b2:	4a09      	ldr	r2, [pc, #36]	; (801c8d8 <init_ap+0x34>)
 801c8b4:	6013      	str	r3, [r2, #0]
	assert(ap_handle);
 801c8b6:	4b08      	ldr	r3, [pc, #32]	; (801c8d8 <init_ap+0x34>)
 801c8b8:	681b      	ldr	r3, [r3, #0]
 801c8ba:	2b00      	cmp	r3, #0
 801c8bc:	d106      	bne.n	801c8cc <init_ap+0x28>
 801c8be:	f240 1263 	movw	r2, #355	; 0x163
 801c8c2:	4906      	ldr	r1, [pc, #24]	; (801c8dc <init_ap+0x38>)
 801c8c4:	4806      	ldr	r0, [pc, #24]	; (801c8e0 <init_ap+0x3c>)
 801c8c6:	f003 fc51 	bl	802016c <iprintf>
 801c8ca:	e7fe      	b.n	801c8ca <init_ap+0x26>
}
 801c8cc:	bf00      	nop
 801c8ce:	bd80      	pop	{r7, pc}
 801c8d0:	0801c761 	.word	0x0801c761
 801c8d4:	08024d48 	.word	0x08024d48
 801c8d8:	24034b1c 	.word	0x24034b1c
 801c8dc:	08024c78 	.word	0x08024c78
 801c8e0:	08024cbc 	.word	0x08024cbc

0801c8e4 <stream_set>:
  *         offset - offset from stream
  *         len - len of buffer
  * @retval None
  */
void stream_set(uint8_t * stream, const void *val, uint8_t offset, uint16_t len)
{
 801c8e4:	b480      	push	{r7}
 801c8e6:	b087      	sub	sp, #28
 801c8e8:	af00      	add	r7, sp, #0
 801c8ea:	60f8      	str	r0, [r7, #12]
 801c8ec:	60b9      	str	r1, [r7, #8]
 801c8ee:	4611      	mov	r1, r2
 801c8f0:	461a      	mov	r2, r3
 801c8f2:	460b      	mov	r3, r1
 801c8f4:	71fb      	strb	r3, [r7, #7]
 801c8f6:	4613      	mov	r3, r2
 801c8f8:	80bb      	strh	r3, [r7, #4]
	uint8_t * src = (uint8_t *)val;
 801c8fa:	68bb      	ldr	r3, [r7, #8]
 801c8fc:	613b      	str	r3, [r7, #16]
	uint16_t idx;

	for (idx=0;idx<len;idx++) {
 801c8fe:	2300      	movs	r3, #0
 801c900:	82fb      	strh	r3, [r7, #22]
 801c902:	e00d      	b.n	801c920 <stream_set+0x3c>
		stream[offset+idx] = src[idx];
 801c904:	8afb      	ldrh	r3, [r7, #22]
 801c906:	693a      	ldr	r2, [r7, #16]
 801c908:	441a      	add	r2, r3
 801c90a:	79f9      	ldrb	r1, [r7, #7]
 801c90c:	8afb      	ldrh	r3, [r7, #22]
 801c90e:	440b      	add	r3, r1
 801c910:	4619      	mov	r1, r3
 801c912:	68fb      	ldr	r3, [r7, #12]
 801c914:	440b      	add	r3, r1
 801c916:	7812      	ldrb	r2, [r2, #0]
 801c918:	701a      	strb	r2, [r3, #0]
	for (idx=0;idx<len;idx++) {
 801c91a:	8afb      	ldrh	r3, [r7, #22]
 801c91c:	3301      	adds	r3, #1
 801c91e:	82fb      	strh	r3, [r7, #22]
 801c920:	8afa      	ldrh	r2, [r7, #22]
 801c922:	88bb      	ldrh	r3, [r7, #4]
 801c924:	429a      	cmp	r2, r3
 801c926:	d3ed      	bcc.n	801c904 <stream_set+0x20>
	}
}
 801c928:	bf00      	nop
 801c92a:	bf00      	nop
 801c92c:	371c      	adds	r7, #28
 801c92e:	46bd      	mov	sp, r7
 801c930:	f85d 7b04 	ldr.w	r7, [sp], #4
 801c934:	4770      	bx	lr
	...

0801c938 <stream_get>:
  *         offset - offset from stream
  *         len - len of buffer
  * @retval value at offset from stream of len
  */
uint8_t * stream_get(uint8_t * stream, uint8_t offset, uint16_t len)
{
 801c938:	b580      	push	{r7, lr}
 801c93a:	b082      	sub	sp, #8
 801c93c:	af00      	add	r7, sp, #0
 801c93e:	6078      	str	r0, [r7, #4]
 801c940:	460b      	mov	r3, r1
 801c942:	70fb      	strb	r3, [r7, #3]
 801c944:	4613      	mov	r3, r2
 801c946:	803b      	strh	r3, [r7, #0]
	(void)len;
	assert(stream);
 801c948:	687b      	ldr	r3, [r7, #4]
 801c94a:	2b00      	cmp	r3, #0
 801c94c:	d105      	bne.n	801c95a <stream_get+0x22>
 801c94e:	2255      	movs	r2, #85	; 0x55
 801c950:	4905      	ldr	r1, [pc, #20]	; (801c968 <stream_get+0x30>)
 801c952:	4806      	ldr	r0, [pc, #24]	; (801c96c <stream_get+0x34>)
 801c954:	f003 fc0a 	bl	802016c <iprintf>
 801c958:	e7fe      	b.n	801c958 <stream_get+0x20>

	return (stream+offset);
 801c95a:	78fb      	ldrb	r3, [r7, #3]
 801c95c:	687a      	ldr	r2, [r7, #4]
 801c95e:	4413      	add	r3, r2
}
 801c960:	4618      	mov	r0, r3
 801c962:	3708      	adds	r7, #8
 801c964:	46bd      	mov	sp, r7
 801c966:	bd80      	pop	{r7, pc}
 801c968:	08024d5c 	.word	0x08024d5c
 801c96c:	08024da4 	.word	0x08024da4

0801c970 <get_self_ip_station>:
  * @brief  Get self station ip from config param
  * @param  self_ip - output ip address
  * @retval STM_FAIL if fail, else STM_OK
  */
stm_ret_t get_self_ip_station(uint32_t *self_ip)
{
 801c970:	b580      	push	{r7, lr}
 801c972:	b082      	sub	sp, #8
 801c974:	af00      	add	r7, sp, #0
 801c976:	6078      	str	r0, [r7, #4]
	if (STM_OK != get_ipaddr_from_str(INPUT_STATION_SRC_IP, self_ip)) {
 801c978:	6879      	ldr	r1, [r7, #4]
 801c97a:	4809      	ldr	r0, [pc, #36]	; (801c9a0 <get_self_ip_station+0x30>)
 801c97c:	f001 fc57 	bl	801e22e <get_ipaddr_from_str>
 801c980:	4603      	mov	r3, r0
 801c982:	2b00      	cmp	r3, #0
 801c984:	d006      	beq.n	801c994 <get_self_ip_station+0x24>
			printf("invalid src ip addr from INPUT_STATION_SRC_IP %s\n\r",
 801c986:	4906      	ldr	r1, [pc, #24]	; (801c9a0 <get_self_ip_station+0x30>)
 801c988:	4806      	ldr	r0, [pc, #24]	; (801c9a4 <get_self_ip_station+0x34>)
 801c98a:	f003 fbef 	bl	802016c <iprintf>
					INPUT_STATION_SRC_IP);
			return STM_FAIL;
 801c98e:	f04f 33ff 	mov.w	r3, #4294967295
 801c992:	e000      	b.n	801c996 <get_self_ip_station+0x26>
		}
		return STM_OK;
 801c994:	2300      	movs	r3, #0
}
 801c996:	4618      	mov	r0, r3
 801c998:	3708      	adds	r7, #8
 801c99a:	46bd      	mov	sp, r7
 801c99c:	bd80      	pop	{r7, pc}
 801c99e:	bf00      	nop
 801c9a0:	08024db8 	.word	0x08024db8
 801c9a4:	08024dc8 	.word	0x08024dc8

0801c9a8 <get_self_ip_softap>:
  * @brief  Get self softap ip from config param
  * @param  self_ip - output ip address
  * @retval STM_FAIL if fail, else STM_OK
  */
stm_ret_t get_self_ip_softap(uint32_t *self_ip)
{
 801c9a8:	b580      	push	{r7, lr}
 801c9aa:	b082      	sub	sp, #8
 801c9ac:	af00      	add	r7, sp, #0
 801c9ae:	6078      	str	r0, [r7, #4]
	if (STM_OK != get_ipaddr_from_str(INPUT_SOFTAP_SRC_IP, self_ip)) {
 801c9b0:	6879      	ldr	r1, [r7, #4]
 801c9b2:	4809      	ldr	r0, [pc, #36]	; (801c9d8 <get_self_ip_softap+0x30>)
 801c9b4:	f001 fc3b 	bl	801e22e <get_ipaddr_from_str>
 801c9b8:	4603      	mov	r3, r0
 801c9ba:	2b00      	cmp	r3, #0
 801c9bc:	d006      	beq.n	801c9cc <get_self_ip_softap+0x24>
		printf("invalid src ip addr from INPUT_SOFTAP_SRC_IP %s\n\r",
 801c9be:	4906      	ldr	r1, [pc, #24]	; (801c9d8 <get_self_ip_softap+0x30>)
 801c9c0:	4806      	ldr	r0, [pc, #24]	; (801c9dc <get_self_ip_softap+0x34>)
 801c9c2:	f003 fbd3 	bl	802016c <iprintf>
				INPUT_SOFTAP_SRC_IP);
		return STM_FAIL;
 801c9c6:	f04f 33ff 	mov.w	r3, #4294967295
 801c9ca:	e000      	b.n	801c9ce <get_self_ip_softap+0x26>
	}
	return STM_OK;
 801c9cc:	2300      	movs	r3, #0
}
 801c9ce:	4618      	mov	r0, r3
 801c9d0:	3708      	adds	r7, #8
 801c9d2:	46bd      	mov	sp, r7
 801c9d4:	bd80      	pop	{r7, pc}
 801c9d6:	bf00      	nop
 801c9d8:	08024dfc 	.word	0x08024dfc
 801c9dc:	08024e08 	.word	0x08024e08

0801c9e0 <get_self_mac_station>:
  * @brief  Get self mac for station
  * @param None
  * @retval NULL if fail, else mac
  */
uint8_t *get_self_mac_station()
{
 801c9e0:	b480      	push	{r7}
 801c9e2:	af00      	add	r7, sp, #0
	return self_station_mac;
 801c9e4:	4b02      	ldr	r3, [pc, #8]	; (801c9f0 <get_self_mac_station+0x10>)
}
 801c9e6:	4618      	mov	r0, r3
 801c9e8:	46bd      	mov	sp, r7
 801c9ea:	f85d 7b04 	ldr.w	r7, [sp], #4
 801c9ee:	4770      	bx	lr
 801c9f0:	24034b24 	.word	0x24034b24

0801c9f4 <get_self_mac_softap>:
  * @brief  Get self mac for softap
  * @param  None
  * @retval NULL if fail, else mac
  */
uint8_t *get_self_mac_softap()
{
 801c9f4:	b480      	push	{r7}
 801c9f6:	af00      	add	r7, sp, #0
	return self_softap_mac;
 801c9f8:	4b02      	ldr	r3, [pc, #8]	; (801ca04 <get_self_mac_softap+0x10>)
}
 801c9fa:	4618      	mov	r0, r3
 801c9fc:	46bd      	mov	sp, r7
 801c9fe:	f85d 7b04 	ldr.w	r7, [sp], #4
 801ca02:	4770      	bx	lr
 801ca04:	24034b2c 	.word	0x24034b2c

0801ca08 <control_path_init>:
  * @param  control_path_evt_handler - event handler of type
  *         control_path_events_e
  * @retval None
  */
void control_path_init(void(*control_path_evt_handler)(uint8_t))
{
 801ca08:	b580      	push	{r7, lr}
 801ca0a:	b08c      	sub	sp, #48	; 0x30
 801ca0c:	af08      	add	r7, sp, #32
 801ca0e:	6078      	str	r0, [r7, #4]
	UINT status;
	print_configuration_parameters();
 801ca10:	f000 f8a2 	bl	801cb58 <print_configuration_parameters>
	/* do not start control path until all tasks are in place */
	mode = WIFI_MODE_NONE;
 801ca14:	4b15      	ldr	r3, [pc, #84]	; (801ca6c <control_path_init+0x64>)
 801ca16:	2200      	movs	r2, #0
 801ca18:	601a      	str	r2, [r3, #0]

	/* register event handler */
	control_path_evt_handler_fp = control_path_evt_handler;
 801ca1a:	4a15      	ldr	r2, [pc, #84]	; (801ca70 <control_path_init+0x68>)
 801ca1c:	687b      	ldr	r3, [r7, #4]
 801ca1e:	6013      	str	r3, [r2, #0]

	/* Call control path library init */
	control_path_platform_init();
 801ca20:	f000 fc7e 	bl	801d320 <control_path_platform_init>
	/* Task - application task */
	/*osThreadDef(SEM_Thread, control_path_task, osPriorityAboveNormal, 0,
			CONTROL_PATH_TASK_STACK_SIZE);
	control_path_task_id = osThreadCreate(osThread(SEM_Thread), NULL);*/
	//xTaskCreate(control_path_task, "SEM_Thread", CONTROL_PATH_TASK_STACK_SIZE, (void *) 0, 1, &control_path_task_id);
	status = tx_thread_create(&control_path_task_id, "control_path_task",
 801ca24:	23b4      	movs	r3, #180	; 0xb4
 801ca26:	9306      	str	r3, [sp, #24]
 801ca28:	2301      	movs	r3, #1
 801ca2a:	9305      	str	r3, [sp, #20]
 801ca2c:	2300      	movs	r3, #0
 801ca2e:	9304      	str	r3, [sp, #16]
 801ca30:	2300      	movs	r3, #0
 801ca32:	9303      	str	r3, [sp, #12]
 801ca34:	2300      	movs	r3, #0
 801ca36:	9302      	str	r3, [sp, #8]
 801ca38:	f44f 5380 	mov.w	r3, #4096	; 0x1000
 801ca3c:	9301      	str	r3, [sp, #4]
 801ca3e:	4b0d      	ldr	r3, [pc, #52]	; (801ca74 <control_path_init+0x6c>)
 801ca40:	9300      	str	r3, [sp, #0]
 801ca42:	2300      	movs	r3, #0
 801ca44:	4a0c      	ldr	r2, [pc, #48]	; (801ca78 <control_path_init+0x70>)
 801ca46:	490d      	ldr	r1, [pc, #52]	; (801ca7c <control_path_init+0x74>)
 801ca48:	480d      	ldr	r0, [pc, #52]	; (801ca80 <control_path_init+0x78>)
 801ca4a:	f7f9 ff4b 	bl	80168e4 <_txe_thread_create>
 801ca4e:	60f8      	str	r0, [r7, #12]
								  control_path_task, 0, contral_path_task_stack, CONTROL_PATH_TASK_STACK_SIZE,
								  CONTROL_PATH_TASK_PRIO, CONTROL_PATH_TASK_PRIO, TX_NO_TIME_SLICE, TX_AUTO_START);
//	assert(control_path_task_id);
	assert(status == TX_SUCCESS);
 801ca50:	68fb      	ldr	r3, [r7, #12]
 801ca52:	2b00      	cmp	r3, #0
 801ca54:	d005      	beq.n	801ca62 <control_path_init+0x5a>
 801ca56:	22b2      	movs	r2, #178	; 0xb2
 801ca58:	490a      	ldr	r1, [pc, #40]	; (801ca84 <control_path_init+0x7c>)
 801ca5a:	480b      	ldr	r0, [pc, #44]	; (801ca88 <control_path_init+0x80>)
 801ca5c:	f003 fb86 	bl	802016c <iprintf>
 801ca60:	e7fe      	b.n	801ca60 <control_path_init+0x58>
}
 801ca62:	bf00      	nop
 801ca64:	3710      	adds	r7, #16
 801ca66:	46bd      	mov	sp, r7
 801ca68:	bd80      	pop	{r7, pc}
 801ca6a:	bf00      	nop
 801ca6c:	24034b20 	.word	0x24034b20
 801ca70:	24035be8 	.word	0x24035be8
 801ca74:	24034b34 	.word	0x24034b34
 801ca78:	0801d0ed 	.word	0x0801d0ed
 801ca7c:	08024ec8 	.word	0x08024ec8
 801ca80:	24035b34 	.word	0x24035b34
 801ca84:	08024edc 	.word	0x08024edc
 801ca88:	08024f28 	.word	0x08024f28

0801ca8c <get_boolean_param>:
  * @brief  get boolean usr param
  * @param  param - user input string
  * @retval 0 if "yes", else 0
  */
static uint8_t get_boolean_param(char *param)
{
 801ca8c:	b580      	push	{r7, lr}
 801ca8e:	b082      	sub	sp, #8
 801ca90:	af00      	add	r7, sp, #0
 801ca92:	6078      	str	r0, [r7, #4]
	if (strncasecmp(param, PARAM_STR_YES, strlen(PARAM_STR_YES)) == 0) {
 801ca94:	2203      	movs	r2, #3
 801ca96:	4907      	ldr	r1, [pc, #28]	; (801cab4 <get_boolean_param+0x28>)
 801ca98:	6878      	ldr	r0, [r7, #4]
 801ca9a:	f003 fee5 	bl	8020868 <strncasecmp>
 801ca9e:	4603      	mov	r3, r0
 801caa0:	2b00      	cmp	r3, #0
 801caa2:	d101      	bne.n	801caa8 <get_boolean_param+0x1c>
		return 1;
 801caa4:	2301      	movs	r3, #1
 801caa6:	e000      	b.n	801caaa <get_boolean_param+0x1e>
	}
	return 0;
 801caa8:	2300      	movs	r3, #0
}
 801caaa:	4618      	mov	r0, r3
 801caac:	3708      	adds	r7, #8
 801caae:	46bd      	mov	sp, r7
 801cab0:	bd80      	pop	{r7, pc}
 801cab2:	bf00      	nop
 801cab4:	08024f3c 	.word	0x08024f3c

0801cab8 <get_param_softap_bw>:
  * @brief  get usr param softap bw
  * @param  None
  * @retval value from wifi_bandwidth_t
  */
static uint8_t get_param_softap_bw(void)
{
 801cab8:	b580      	push	{r7, lr}
 801caba:	af00      	add	r7, sp, #0
	if (strncasecmp(INPUT_SOFTAP_BANDWIDTH, PARAM_STR_HT20,
 801cabc:	2204      	movs	r2, #4
 801cabe:	4906      	ldr	r1, [pc, #24]	; (801cad8 <get_param_softap_bw+0x20>)
 801cac0:	4806      	ldr	r0, [pc, #24]	; (801cadc <get_param_softap_bw+0x24>)
 801cac2:	f003 fed1 	bl	8020868 <strncasecmp>
 801cac6:	4603      	mov	r3, r0
 801cac8:	2b00      	cmp	r3, #0
 801caca:	d101      	bne.n	801cad0 <get_param_softap_bw+0x18>
				strlen(PARAM_STR_HT20))==0) {
		return WIFI_BW_HT20;
 801cacc:	2301      	movs	r3, #1
 801cace:	e000      	b.n	801cad2 <get_param_softap_bw+0x1a>
	} else if (strncasecmp(INPUT_SOFTAP_BANDWIDTH, PARAM_STR_HT40,
				strlen(PARAM_STR_HT40))==0) {
		return WIFI_BW_HT40;
 801cad0:	2302      	movs	r3, #2
	} else {
		printf("%s not supported for INPUT_SOFTAP_BANDWIDTH, Default to HT40\n\r",
				INPUT_SOFTAP_BANDWIDTH);
		return WIFI_BW_HT40;
	}
}
 801cad2:	4618      	mov	r0, r3
 801cad4:	bd80      	pop	{r7, pc}
 801cad6:	bf00      	nop
 801cad8:	08024f40 	.word	0x08024f40
 801cadc:	08024f48 	.word	0x08024f48

0801cae0 <get_param_softap_encryption>:
  * @brief  get usr param softap encryption
  * @param  None
  * @retval value from wifi_auth_mode_t
  */
static uint8_t get_param_softap_encryption(void)
{
 801cae0:	b480      	push	{r7}
 801cae2:	af00      	add	r7, sp, #0
	if (strncasecmp(INPUT_SOFTAP_ENCRYPTION, PARAM_STR_WPA_WPA2_PSK,
				strlen(PARAM_STR_WPA_WPA2_PSK)) == 0) {
		return WIFI_AUTH_WPA_WPA2_PSK;
 801cae4:	2304      	movs	r3, #4
	}
	printf("%s not supported for INPUT_SOFTAP_ENCRYPTION. Default to OPEN\n\r",
			INPUT_SOFTAP_ENCRYPTION);

	return WIFI_AUTH_OPEN;
}
 801cae6:	4618      	mov	r0, r3
 801cae8:	46bd      	mov	sp, r7
 801caea:	f85d 7b04 	ldr.w	r7, [sp], #4
 801caee:	4770      	bx	lr

0801caf0 <control_path_call_event>:
  * @brief  call up event handler registered
  * @param  event - control path events of type control_path_events_e
  * @retval STM_OK/STM_FAIL
  */
static void control_path_call_event(uint8_t event)
{
 801caf0:	b580      	push	{r7, lr}
 801caf2:	b082      	sub	sp, #8
 801caf4:	af00      	add	r7, sp, #0
 801caf6:	4603      	mov	r3, r0
 801caf8:	71fb      	strb	r3, [r7, #7]
	if(control_path_evt_handler_fp) {
 801cafa:	4b06      	ldr	r3, [pc, #24]	; (801cb14 <control_path_call_event+0x24>)
 801cafc:	681b      	ldr	r3, [r3, #0]
 801cafe:	2b00      	cmp	r3, #0
 801cb00:	d004      	beq.n	801cb0c <control_path_call_event+0x1c>
		control_path_evt_handler_fp(event);
 801cb02:	4b04      	ldr	r3, [pc, #16]	; (801cb14 <control_path_call_event+0x24>)
 801cb04:	681b      	ldr	r3, [r3, #0]
 801cb06:	79fa      	ldrb	r2, [r7, #7]
 801cb08:	4610      	mov	r0, r2
 801cb0a:	4798      	blx	r3
	}
}
 801cb0c:	bf00      	nop
 801cb0e:	3708      	adds	r7, #8
 801cb10:	46bd      	mov	sp, r7
 801cb12:	bd80      	pop	{r7, pc}
 801cb14:	24035be8 	.word	0x24035be8

0801cb18 <save_softap_mac>:
  * @brief  save softap mac in bytes
  * @param  mac - mac in string
  * @retval STM_OK/STM_FAIL
  */
static stm_ret_t save_softap_mac(const char *mac)
{
 801cb18:	b580      	push	{r7, lr}
 801cb1a:	b082      	sub	sp, #8
 801cb1c:	af00      	add	r7, sp, #0
 801cb1e:	6078      	str	r0, [r7, #4]
	return convert_mac_to_bytes(self_softap_mac, mac);
 801cb20:	6879      	ldr	r1, [r7, #4]
 801cb22:	4804      	ldr	r0, [pc, #16]	; (801cb34 <save_softap_mac+0x1c>)
 801cb24:	f001 fad0 	bl	801e0c8 <convert_mac_to_bytes>
 801cb28:	4603      	mov	r3, r0
}
 801cb2a:	4618      	mov	r0, r3
 801cb2c:	3708      	adds	r7, #8
 801cb2e:	46bd      	mov	sp, r7
 801cb30:	bd80      	pop	{r7, pc}
 801cb32:	bf00      	nop
 801cb34:	24034b2c 	.word	0x24034b2c

0801cb38 <save_station_mac>:
  * @brief  save station mac in bytes
  * @param  mac - mac in string
  * @retval STM_OK/STM_FAIL
  */
static stm_ret_t save_station_mac(const char *mac)
{
 801cb38:	b580      	push	{r7, lr}
 801cb3a:	b082      	sub	sp, #8
 801cb3c:	af00      	add	r7, sp, #0
 801cb3e:	6078      	str	r0, [r7, #4]
	return convert_mac_to_bytes(self_station_mac, mac);
 801cb40:	6879      	ldr	r1, [r7, #4]
 801cb42:	4804      	ldr	r0, [pc, #16]	; (801cb54 <save_station_mac+0x1c>)
 801cb44:	f001 fac0 	bl	801e0c8 <convert_mac_to_bytes>
 801cb48:	4603      	mov	r3, r0
}
 801cb4a:	4618      	mov	r0, r3
 801cb4c:	3708      	adds	r7, #8
 801cb4e:	46bd      	mov	sp, r7
 801cb50:	bd80      	pop	{r7, pc}
 801cb52:	bf00      	nop
 801cb54:	24034b24 	.word	0x24034b24

0801cb58 <print_configuration_parameters>:
/** @brief  print user configuration parameters
  * @param  None
  * @retval None
  */
static void print_configuration_parameters(void)
{
 801cb58:	b580      	push	{r7, lr}
 801cb5a:	af00      	add	r7, sp, #0
	hard_delay(100);
 801cb5c:	2064      	movs	r0, #100	; 0x64
 801cb5e:	f001 f8c8 	bl	801dcf2 <hard_delay>
	//HAL_Delay(100);
	printf("\n\r");
 801cb62:	4833      	ldr	r0, [pc, #204]	; (801cc30 <print_configuration_parameters+0xd8>)
 801cb64:	f003 fb02 	bl	802016c <iprintf>
	printf("+-----------------------------------+-------------------------------------------+\n\r");
 801cb68:	4832      	ldr	r0, [pc, #200]	; (801cc34 <print_configuration_parameters+0xdc>)
 801cb6a:	f003 faff 	bl	802016c <iprintf>
	printf("|           Parameters              |             Values                        |\n\r");
 801cb6e:	4832      	ldr	r0, [pc, #200]	; (801cc38 <print_configuration_parameters+0xe0>)
 801cb70:	f003 fafc 	bl	802016c <iprintf>
	printf("+-----------------------------------+-------------------------------------------+\n\r");
 801cb74:	482f      	ldr	r0, [pc, #188]	; (801cc34 <print_configuration_parameters+0xdc>)
 801cb76:	f003 faf9 	bl	802016c <iprintf>
	printf("|      INPUT__OPERATING_MODE        |             %-30s|\n\r",INPUT__OPERATING_MODE);
 801cb7a:	4930      	ldr	r1, [pc, #192]	; (801cc3c <print_configuration_parameters+0xe4>)
 801cb7c:	4830      	ldr	r0, [pc, #192]	; (801cc40 <print_configuration_parameters+0xe8>)
 801cb7e:	f003 faf5 	bl	802016c <iprintf>
	printf("|      INPUT_GET_AP_SCAN_LIST       |             %-30s|\n\r",INPUT_GET_AP_SCAN_LIST);
 801cb82:	4930      	ldr	r1, [pc, #192]	; (801cc44 <print_configuration_parameters+0xec>)
 801cb84:	4830      	ldr	r0, [pc, #192]	; (801cc48 <print_configuration_parameters+0xf0>)
 801cb86:	f003 faf1 	bl	802016c <iprintf>
	printf("+-----------------------------------+-------------------------------------------+\n\r");
 801cb8a:	482a      	ldr	r0, [pc, #168]	; (801cc34 <print_configuration_parameters+0xdc>)
 801cb8c:	f003 faee 	bl	802016c <iprintf>
	printf("|            SOFTAP                 |                                           |\n\r");
 801cb90:	482e      	ldr	r0, [pc, #184]	; (801cc4c <print_configuration_parameters+0xf4>)
 801cb92:	f003 faeb 	bl	802016c <iprintf>
	printf("+-----------------------------------+-------------------------------------------+\n\r");
 801cb96:	4827      	ldr	r0, [pc, #156]	; (801cc34 <print_configuration_parameters+0xdc>)
 801cb98:	f003 fae8 	bl	802016c <iprintf>
	printf("|        INPUT_SOFTAP__SSID         |             %-30s|\n\r",INPUT_SOFTAP__SSID);
 801cb9c:	492c      	ldr	r1, [pc, #176]	; (801cc50 <print_configuration_parameters+0xf8>)
 801cb9e:	482d      	ldr	r0, [pc, #180]	; (801cc54 <print_configuration_parameters+0xfc>)
 801cba0:	f003 fae4 	bl	802016c <iprintf>
	printf("|       INPUT_SOFTAP_PASSWORD       |             %-30s|\n\r", INPUT_SOFTAP_PASSWORD);
 801cba4:	492c      	ldr	r1, [pc, #176]	; (801cc58 <print_configuration_parameters+0x100>)
 801cba6:	482d      	ldr	r0, [pc, #180]	; (801cc5c <print_configuration_parameters+0x104>)
 801cba8:	f003 fae0 	bl	802016c <iprintf>
	printf("|      INPUT_SOFTAP_BANDWIDTH       |             %-30s|\n\r",INPUT_SOFTAP_BANDWIDTH);
 801cbac:	492c      	ldr	r1, [pc, #176]	; (801cc60 <print_configuration_parameters+0x108>)
 801cbae:	482d      	ldr	r0, [pc, #180]	; (801cc64 <print_configuration_parameters+0x10c>)
 801cbb0:	f003 fadc 	bl	802016c <iprintf>
	printf("|       INPUT_SOFTAP_CHANNEL        |             %-30s|\n\r",INPUT_SOFTAP_CHANNEL);
 801cbb4:	492c      	ldr	r1, [pc, #176]	; (801cc68 <print_configuration_parameters+0x110>)
 801cbb6:	482d      	ldr	r0, [pc, #180]	; (801cc6c <print_configuration_parameters+0x114>)
 801cbb8:	f003 fad8 	bl	802016c <iprintf>
	printf("|      INPUT_SOFTAP_ENCRYPTION      |             %-30s|\n\r",INPUT_SOFTAP_ENCRYPTION);
 801cbbc:	492c      	ldr	r1, [pc, #176]	; (801cc70 <print_configuration_parameters+0x118>)
 801cbbe:	482d      	ldr	r0, [pc, #180]	; (801cc74 <print_configuration_parameters+0x11c>)
 801cbc0:	f003 fad4 	bl	802016c <iprintf>
	printf("|      INPUT_SOFTAP_MAX_CONN        |             %-30s|\n\r",INPUT_SOFTAP_MAX_CONN);
 801cbc4:	492c      	ldr	r1, [pc, #176]	; (801cc78 <print_configuration_parameters+0x120>)
 801cbc6:	482d      	ldr	r0, [pc, #180]	; (801cc7c <print_configuration_parameters+0x124>)
 801cbc8:	f003 fad0 	bl	802016c <iprintf>
	printf("|     INPUT_SOFTAP_SSID_HIDDEN      |             %-30s|\n\r",INPUT_SOFTAP_SSID_HIDDEN);
 801cbcc:	492c      	ldr	r1, [pc, #176]	; (801cc80 <print_configuration_parameters+0x128>)
 801cbce:	482d      	ldr	r0, [pc, #180]	; (801cc84 <print_configuration_parameters+0x12c>)
 801cbd0:	f003 facc 	bl	802016c <iprintf>
	printf("|       INPUT_SOFTAP_SRC_IP         |             %-30s|\n\r",INPUT_SOFTAP_SRC_IP);
 801cbd4:	492c      	ldr	r1, [pc, #176]	; (801cc88 <print_configuration_parameters+0x130>)
 801cbd6:	482d      	ldr	r0, [pc, #180]	; (801cc8c <print_configuration_parameters+0x134>)
 801cbd8:	f003 fac8 	bl	802016c <iprintf>
	printf("|      INPUT_SOFTAP_ARP_DEST_IP     |             %-30s|\n\r",INPUT_SOFTAP_ARP_DEST_IP);
 801cbdc:	492c      	ldr	r1, [pc, #176]	; (801cc90 <print_configuration_parameters+0x138>)
 801cbde:	482d      	ldr	r0, [pc, #180]	; (801cc94 <print_configuration_parameters+0x13c>)
 801cbe0:	f003 fac4 	bl	802016c <iprintf>
	printf("+-----------------------------------+-------------------------------------------+\n\r");
 801cbe4:	4813      	ldr	r0, [pc, #76]	; (801cc34 <print_configuration_parameters+0xdc>)
 801cbe6:	f003 fac1 	bl	802016c <iprintf>
	printf("|            STATION                |                                           |\n\r");
 801cbea:	482b      	ldr	r0, [pc, #172]	; (801cc98 <print_configuration_parameters+0x140>)
 801cbec:	f003 fabe 	bl	802016c <iprintf>
	printf("+-----------------------------------+-------------------------------------------+\n\r");
 801cbf0:	4810      	ldr	r0, [pc, #64]	; (801cc34 <print_configuration_parameters+0xdc>)
 801cbf2:	f003 fabb 	bl	802016c <iprintf>
	printf("|        INPUT_STATION__SSID        |             %-30s|\n\r",INPUT_STATION__SSID);
 801cbf6:	4929      	ldr	r1, [pc, #164]	; (801cc9c <print_configuration_parameters+0x144>)
 801cbf8:	4829      	ldr	r0, [pc, #164]	; (801cca0 <print_configuration_parameters+0x148>)
 801cbfa:	f003 fab7 	bl	802016c <iprintf>
	printf("|       INPUT_STATION_BSSID         |             %-30s|\n\r",INPUT_STATION_BSSID);
 801cbfe:	4929      	ldr	r1, [pc, #164]	; (801cca4 <print_configuration_parameters+0x14c>)
 801cc00:	4829      	ldr	r0, [pc, #164]	; (801cca8 <print_configuration_parameters+0x150>)
 801cc02:	f003 fab3 	bl	802016c <iprintf>
	printf("|   INPUT_STATION_IS_WPA3_SUPPORTED |             %-30s|\n\r",INPUT_STATION_IS_WPA3_SUPPORTED);
 801cc06:	490f      	ldr	r1, [pc, #60]	; (801cc44 <print_configuration_parameters+0xec>)
 801cc08:	4828      	ldr	r0, [pc, #160]	; (801ccac <print_configuration_parameters+0x154>)
 801cc0a:	f003 faaf 	bl	802016c <iprintf>
	printf("|      INPUT_STATION_PASSWORD       |             %-30s|\n\r",INPUT_STATION_PASSWORD);
 801cc0e:	4928      	ldr	r1, [pc, #160]	; (801ccb0 <print_configuration_parameters+0x158>)
 801cc10:	4828      	ldr	r0, [pc, #160]	; (801ccb4 <print_configuration_parameters+0x15c>)
 801cc12:	f003 faab 	bl	802016c <iprintf>
	printf("|       INPUT_STATION_SRC_IP        |             %-30s|\n\r",INPUT_STATION_SRC_IP);
 801cc16:	4928      	ldr	r1, [pc, #160]	; (801ccb8 <print_configuration_parameters+0x160>)
 801cc18:	4828      	ldr	r0, [pc, #160]	; (801ccbc <print_configuration_parameters+0x164>)
 801cc1a:	f003 faa7 	bl	802016c <iprintf>
	printf("|     INPUT_STATION_ARP_DEST_IP     |             %-30s|\n\r",INPUT_STATION_ARP_DEST_IP);
 801cc1e:	4928      	ldr	r1, [pc, #160]	; (801ccc0 <print_configuration_parameters+0x168>)
 801cc20:	4828      	ldr	r0, [pc, #160]	; (801ccc4 <print_configuration_parameters+0x16c>)
 801cc22:	f003 faa3 	bl	802016c <iprintf>
	printf("+-----------------------------------+-------------------------------------------+\n\r");
 801cc26:	4803      	ldr	r0, [pc, #12]	; (801cc34 <print_configuration_parameters+0xdc>)
 801cc28:	f003 faa0 	bl	802016c <iprintf>
}
 801cc2c:	bf00      	nop
 801cc2e:	bd80      	pop	{r7, pc}
 801cc30:	08024f50 	.word	0x08024f50
 801cc34:	08024f54 	.word	0x08024f54
 801cc38:	08024fa8 	.word	0x08024fa8
 801cc3c:	08024ffc 	.word	0x08024ffc
 801cc40:	08025004 	.word	0x08025004
 801cc44:	08024f3c 	.word	0x08024f3c
 801cc48:	08025040 	.word	0x08025040
 801cc4c:	0802507c 	.word	0x0802507c
 801cc50:	080250d0 	.word	0x080250d0
 801cc54:	080250d8 	.word	0x080250d8
 801cc58:	08025114 	.word	0x08025114
 801cc5c:	08025120 	.word	0x08025120
 801cc60:	08024f48 	.word	0x08024f48
 801cc64:	0802515c 	.word	0x0802515c
 801cc68:	08025198 	.word	0x08025198
 801cc6c:	0802519c 	.word	0x0802519c
 801cc70:	080251d8 	.word	0x080251d8
 801cc74:	080251e8 	.word	0x080251e8
 801cc78:	08025224 	.word	0x08025224
 801cc7c:	08025228 	.word	0x08025228
 801cc80:	08025264 	.word	0x08025264
 801cc84:	08025268 	.word	0x08025268
 801cc88:	08024dfc 	.word	0x08024dfc
 801cc8c:	080252a4 	.word	0x080252a4
 801cc90:	08024e84 	.word	0x08024e84
 801cc94:	080252e0 	.word	0x080252e0
 801cc98:	0802531c 	.word	0x0802531c
 801cc9c:	08025370 	.word	0x08025370
 801cca0:	08025378 	.word	0x08025378
 801cca4:	080253b4 	.word	0x080253b4
 801cca8:	080253b8 	.word	0x080253b8
 801ccac:	080253f4 	.word	0x080253f4
 801ccb0:	08025430 	.word	0x08025430
 801ccb4:	0802543c 	.word	0x0802543c
 801ccb8:	08024db8 	.word	0x08024db8
 801ccbc:	08025478 	.word	0x08025478
 801ccc0:	08024e3c 	.word	0x08024e3c
 801ccc4:	080254b4 	.word	0x080254b4

0801ccc8 <station_connect>:
  * @brief  connect to wifi(ap) router
  * @param  None
  * @retval STM_OK/STM_FAIL
  */
static int station_connect(void)
{
 801ccc8:	b580      	push	{r7, lr}
 801ccca:	b0cc      	sub	sp, #304	; 0x130
 801cccc:	af20      	add	r7, sp, #128	; 0x80
	/* station mode */
	int wifi_mode = WIFI_MODE_STA;
 801ccce:	2301      	movs	r3, #1
 801ccd0:	f8c7 30ac 	str.w	r3, [r7, #172]	; 0xac
	char mac[WIFI_MAX_STR_LEN];
	int ret;
	esp_hosted_control_config_t ap_config = {0};
 801ccd4:	1d3b      	adds	r3, r7, #4
 801ccd6:	2290      	movs	r2, #144	; 0x90
 801ccd8:	2100      	movs	r1, #0
 801ccda:	4618      	mov	r0, r3
 801ccdc:	f002 fdce 	bl	801f87c <memset>

	printf("Station mode: ssid: %s passwd %s \n\r",
 801cce0:	4a3b      	ldr	r2, [pc, #236]	; (801cdd0 <station_connect+0x108>)
 801cce2:	493c      	ldr	r1, [pc, #240]	; (801cdd4 <station_connect+0x10c>)
 801cce4:	483c      	ldr	r0, [pc, #240]	; (801cdd8 <station_connect+0x110>)
 801cce6:	f003 fa41 	bl	802016c <iprintf>
			INPUT_STATION__SSID, INPUT_STATION_PASSWORD);

	strncpy((char* )&ap_config.station.ssid,    INPUT_STATION__SSID,
			min(SSID_LENGTH,     strlen(INPUT_STATION__SSID)+1));
 801ccea:	2108      	movs	r1, #8
 801ccec:	2020      	movs	r0, #32
 801ccee:	f000 fff0 	bl	801dcd2 <min>
 801ccf2:	4603      	mov	r3, r0
	strncpy((char* )&ap_config.station.ssid,    INPUT_STATION__SSID,
 801ccf4:	461a      	mov	r2, r3
 801ccf6:	1d3b      	adds	r3, r7, #4
 801ccf8:	4936      	ldr	r1, [pc, #216]	; (801cdd4 <station_connect+0x10c>)
 801ccfa:	4618      	mov	r0, r3
 801ccfc:	f003 fdea 	bl	80208d4 <strncpy>
	strncpy((char* )&ap_config.station.pwd,     INPUT_STATION_PASSWORD,
			min(PASSWORD_LENGTH, strlen(INPUT_STATION_PASSWORD)+1));
 801cd00:	2109      	movs	r1, #9
 801cd02:	2040      	movs	r0, #64	; 0x40
 801cd04:	f000 ffe5 	bl	801dcd2 <min>
 801cd08:	4603      	mov	r3, r0
	strncpy((char* )&ap_config.station.pwd,     INPUT_STATION_PASSWORD,
 801cd0a:	461a      	mov	r2, r3
 801cd0c:	1d3b      	adds	r3, r7, #4
 801cd0e:	3320      	adds	r3, #32
 801cd10:	492f      	ldr	r1, [pc, #188]	; (801cdd0 <station_connect+0x108>)
 801cd12:	4618      	mov	r0, r3
 801cd14:	f003 fdde 	bl	80208d4 <strncpy>
	if (strlen(INPUT_STATION_BSSID)) {
		strncpy((char* )&ap_config.station.bssid,   INPUT_STATION_BSSID,
			min(BSSID_LENGTH,    strlen(INPUT_STATION_BSSID)+1));
	}
	ap_config.station.is_wpa3_supported =
		get_boolean_param(INPUT_STATION_IS_WPA3_SUPPORTED);
 801cd18:	4830      	ldr	r0, [pc, #192]	; (801cddc <station_connect+0x114>)
 801cd1a:	f7ff feb7 	bl	801ca8c <get_boolean_param>
 801cd1e:	4603      	mov	r3, r0
 801cd20:	2b00      	cmp	r3, #0
 801cd22:	bf14      	ite	ne
 801cd24:	2301      	movne	r3, #1
 801cd26:	2300      	moveq	r3, #0
 801cd28:	b2db      	uxtb	r3, r3
	ap_config.station.is_wpa3_supported =
 801cd2a:	f887 3075 	strb.w	r3, [r7, #117]	; 0x75

	memset(mac, '\0', WIFI_MAX_STR_LEN);
 801cd2e:	f107 0394 	add.w	r3, r7, #148	; 0x94
 801cd32:	2213      	movs	r2, #19
 801cd34:	2100      	movs	r1, #0
 801cd36:	4618      	mov	r0, r3
 801cd38:	f002 fda0 	bl	801f87c <memset>
	ret = wifi_get_mac(wifi_mode, mac);
 801cd3c:	f107 0394 	add.w	r3, r7, #148	; 0x94
 801cd40:	4619      	mov	r1, r3
 801cd42:	f8d7 00ac 	ldr.w	r0, [r7, #172]	; 0xac
 801cd46:	f7fe fc83 	bl	801b650 <wifi_get_mac>
 801cd4a:	f8c7 00a8 	str.w	r0, [r7, #168]	; 0xa8
	if (ret) {
 801cd4e:	f8d7 30a8 	ldr.w	r3, [r7, #168]	; 0xa8
 801cd52:	2b00      	cmp	r3, #0
 801cd54:	d009      	beq.n	801cd6a <station_connect+0xa2>
		printf("Failed to get MAC address, retrying \n\r");
 801cd56:	4822      	ldr	r0, [pc, #136]	; (801cde0 <station_connect+0x118>)
 801cd58:	f003 fa08 	bl	802016c <iprintf>
		hard_delay(50000);
 801cd5c:	f24c 3050 	movw	r0, #50000	; 0xc350
 801cd60:	f000 ffc7 	bl	801dcf2 <hard_delay>
		//HAL_Delay(50000);
		return STM_FAIL;
 801cd64:	f04f 33ff 	mov.w	r3, #4294967295
 801cd68:	e02e      	b.n	801cdc8 <station_connect+0x100>
	} else {
		printf("Station's MAC address is %s \n\r", mac);
 801cd6a:	f107 0394 	add.w	r3, r7, #148	; 0x94
 801cd6e:	4619      	mov	r1, r3
 801cd70:	481c      	ldr	r0, [pc, #112]	; (801cde4 <station_connect+0x11c>)
 801cd72:	f003 f9fb 	bl	802016c <iprintf>
		save_station_mac(mac);
 801cd76:	f107 0394 	add.w	r3, r7, #148	; 0x94
 801cd7a:	4618      	mov	r0, r3
 801cd7c:	f7ff fedc 	bl	801cb38 <save_station_mac>
	}
	ret = wifi_set_ap_config(ap_config);
 801cd80:	4668      	mov	r0, sp
 801cd82:	f107 0314 	add.w	r3, r7, #20
 801cd86:	2280      	movs	r2, #128	; 0x80
 801cd88:	4619      	mov	r1, r3
 801cd8a:	f002 fd4f 	bl	801f82c <memcpy>
 801cd8e:	1d3b      	adds	r3, r7, #4
 801cd90:	cb0f      	ldmia	r3, {r0, r1, r2, r3}
 801cd92:	f7fe fd63 	bl	801b85c <wifi_set_ap_config>
 801cd96:	f8c7 00a8 	str.w	r0, [r7, #168]	; 0xa8
	if (ret) {
 801cd9a:	f8d7 30a8 	ldr.w	r3, [r7, #168]	; 0xa8
 801cd9e:	2b00      	cmp	r3, #0
 801cda0:	d009      	beq.n	801cdb6 <station_connect+0xee>
		printf("Failed to connect with AP \n\r");
 801cda2:	4811      	ldr	r0, [pc, #68]	; (801cde8 <station_connect+0x120>)
 801cda4:	f003 f9e2 	bl	802016c <iprintf>
		hard_delay(50000);
 801cda8:	f24c 3050 	movw	r0, #50000	; 0xc350
 801cdac:	f000 ffa1 	bl	801dcf2 <hard_delay>
		//HAL_Delay(50000);
		return STM_FAIL;
 801cdb0:	f04f 33ff 	mov.w	r3, #4294967295
 801cdb4:	e008      	b.n	801cdc8 <station_connect+0x100>
	} else {
		printf("Connected to %s \n\r", ap_config.station.ssid);
 801cdb6:	1d3b      	adds	r3, r7, #4
 801cdb8:	4619      	mov	r1, r3
 801cdba:	480c      	ldr	r0, [pc, #48]	; (801cdec <station_connect+0x124>)
 801cdbc:	f003 f9d6 	bl	802016c <iprintf>
		control_path_call_event(STATION_CONNECTED);
 801cdc0:	2000      	movs	r0, #0
 801cdc2:	f7ff fe95 	bl	801caf0 <control_path_call_event>
	}
	return STM_OK;
 801cdc6:	2300      	movs	r3, #0
}
 801cdc8:	4618      	mov	r0, r3
 801cdca:	37b0      	adds	r7, #176	; 0xb0
 801cdcc:	46bd      	mov	sp, r7
 801cdce:	bd80      	pop	{r7, pc}
 801cdd0:	08025430 	.word	0x08025430
 801cdd4:	08025370 	.word	0x08025370
 801cdd8:	080254f0 	.word	0x080254f0
 801cddc:	08024f3c 	.word	0x08024f3c
 801cde0:	08025514 	.word	0x08025514
 801cde4:	0802553c 	.word	0x0802553c
 801cde8:	0802555c 	.word	0x0802555c
 801cdec:	0802557c 	.word	0x0802557c

0801cdf0 <softap_start>:
  * @brief  broadcast ESP as AP(wifi))
  * @param  None
  * @retval STM_OK/STM_FAIL
  */
static int softap_start(void)
{
 801cdf0:	b580      	push	{r7, lr}
 801cdf2:	b0ce      	sub	sp, #312	; 0x138
 801cdf4:	af20      	add	r7, sp, #128	; 0x80
	/* softap mode */

	int wifi_mode = WIFI_MODE_AP, ret = 0, channel = 0, max_connections = 0;
 801cdf6:	2302      	movs	r3, #2
 801cdf8:	f8c7 30b4 	str.w	r3, [r7, #180]	; 0xb4
 801cdfc:	2300      	movs	r3, #0
 801cdfe:	f8c7 30b0 	str.w	r3, [r7, #176]	; 0xb0
 801ce02:	2300      	movs	r3, #0
 801ce04:	f8c7 30ac 	str.w	r3, [r7, #172]	; 0xac
 801ce08:	2300      	movs	r3, #0
 801ce0a:	f8c7 30a8 	str.w	r3, [r7, #168]	; 0xa8
	char mac[WIFI_MAX_STR_LEN];
	esp_hosted_control_config_t softap_config = {0};
 801ce0e:	1d3b      	adds	r3, r7, #4
 801ce10:	2290      	movs	r2, #144	; 0x90
 801ce12:	2100      	movs	r1, #0
 801ce14:	4618      	mov	r0, r3
 801ce16:	f002 fd31 	bl	801f87c <memset>

	printf("SoftAP mode: ssid: %s passwd %s \n\r",
 801ce1a:	4a5c      	ldr	r2, [pc, #368]	; (801cf8c <softap_start+0x19c>)
 801ce1c:	495c      	ldr	r1, [pc, #368]	; (801cf90 <softap_start+0x1a0>)
 801ce1e:	485d      	ldr	r0, [pc, #372]	; (801cf94 <softap_start+0x1a4>)
 801ce20:	f003 f9a4 	bl	802016c <iprintf>
			INPUT_SOFTAP__SSID, INPUT_SOFTAP_PASSWORD);

	strncpy((char* )&softap_config.softap.ssid, INPUT_SOFTAP__SSID,
			min(SSID_LENGTH,      strlen(INPUT_SOFTAP__SSID)+1));
 801ce24:	2108      	movs	r1, #8
 801ce26:	2020      	movs	r0, #32
 801ce28:	f000 ff53 	bl	801dcd2 <min>
 801ce2c:	4603      	mov	r3, r0
	strncpy((char* )&softap_config.softap.ssid, INPUT_SOFTAP__SSID,
 801ce2e:	461a      	mov	r2, r3
 801ce30:	1d3b      	adds	r3, r7, #4
 801ce32:	4957      	ldr	r1, [pc, #348]	; (801cf90 <softap_start+0x1a0>)
 801ce34:	4618      	mov	r0, r3
 801ce36:	f003 fd4d 	bl	80208d4 <strncpy>
	strncpy((char* )&softap_config.softap.pwd,  INPUT_SOFTAP_PASSWORD,
			min(PASSWORD_LENGTH,  strlen(INPUT_SOFTAP_PASSWORD)+1));
 801ce3a:	210c      	movs	r1, #12
 801ce3c:	2040      	movs	r0, #64	; 0x40
 801ce3e:	f000 ff48 	bl	801dcd2 <min>
 801ce42:	4603      	mov	r3, r0
	strncpy((char* )&softap_config.softap.pwd,  INPUT_SOFTAP_PASSWORD,
 801ce44:	461a      	mov	r2, r3
 801ce46:	1d3b      	adds	r3, r7, #4
 801ce48:	3320      	adds	r3, #32
 801ce4a:	4950      	ldr	r1, [pc, #320]	; (801cf8c <softap_start+0x19c>)
 801ce4c:	4618      	mov	r0, r3
 801ce4e:	f003 fd41 	bl	80208d4 <strncpy>

	ret = get_num_from_string(&channel, INPUT_SOFTAP_CHANNEL);
 801ce52:	f107 03ac 	add.w	r3, r7, #172	; 0xac
 801ce56:	4950      	ldr	r1, [pc, #320]	; (801cf98 <softap_start+0x1a8>)
 801ce58:	4618      	mov	r0, r3
 801ce5a:	f000 ff65 	bl	801dd28 <get_num_from_string>
 801ce5e:	f8c7 00b0 	str.w	r0, [r7, #176]	; 0xb0
	if (ret != STM_FAIL) {
 801ce62:	f8d7 30b0 	ldr.w	r3, [r7, #176]	; 0xb0
 801ce66:	f1b3 3fff 	cmp.w	r3, #4294967295
 801ce6a:	d003      	beq.n	801ce74 <softap_start+0x84>
		softap_config.softap.channel = channel;
 801ce6c:	f8d7 30ac 	ldr.w	r3, [r7, #172]	; 0xac
 801ce70:	667b      	str	r3, [r7, #100]	; 0x64
 801ce72:	e007      	b.n	801ce84 <softap_start+0x94>
	} else {
		printf("Wrong input entered for softap channel\n");
 801ce74:	4849      	ldr	r0, [pc, #292]	; (801cf9c <softap_start+0x1ac>)
 801ce76:	f003 fa15 	bl	80202a4 <puts>
		printf("Setting softap channel to default value 1\n");
 801ce7a:	4849      	ldr	r0, [pc, #292]	; (801cfa0 <softap_start+0x1b0>)
 801ce7c:	f003 fa12 	bl	80202a4 <puts>
		softap_config.softap.channel = DEFAULT_SOFTAP_CHANNEL;
 801ce80:	2301      	movs	r3, #1
 801ce82:	667b      	str	r3, [r7, #100]	; 0x64
	}

	ret = get_num_from_string(&max_connections, INPUT_SOFTAP_MAX_CONN);
 801ce84:	f107 03a8 	add.w	r3, r7, #168	; 0xa8
 801ce88:	4946      	ldr	r1, [pc, #280]	; (801cfa4 <softap_start+0x1b4>)
 801ce8a:	4618      	mov	r0, r3
 801ce8c:	f000 ff4c 	bl	801dd28 <get_num_from_string>
 801ce90:	f8c7 00b0 	str.w	r0, [r7, #176]	; 0xb0
	if (ret != STM_FAIL) {
 801ce94:	f8d7 30b0 	ldr.w	r3, [r7, #176]	; 0xb0
 801ce98:	f1b3 3fff 	cmp.w	r3, #4294967295
 801ce9c:	d003      	beq.n	801cea6 <softap_start+0xb6>
		softap_config.softap.max_connections = max_connections;
 801ce9e:	f8d7 30a8 	ldr.w	r3, [r7, #168]	; 0xa8
 801cea2:	66fb      	str	r3, [r7, #108]	; 0x6c
 801cea4:	e007      	b.n	801ceb6 <softap_start+0xc6>
	} else {
		printf("Wrong input entered for softap maximum connections\n");
 801cea6:	4840      	ldr	r0, [pc, #256]	; (801cfa8 <softap_start+0x1b8>)
 801cea8:	f003 f9fc 	bl	80202a4 <puts>
		printf("Setting softap maximum connections to default value 4\n");
 801ceac:	483f      	ldr	r0, [pc, #252]	; (801cfac <softap_start+0x1bc>)
 801ceae:	f003 f9f9 	bl	80202a4 <puts>
		softap_config.softap.max_connections = DEFAULT_SOFTAP_MAX_CONNECTIONS;
 801ceb2:	2304      	movs	r3, #4
 801ceb4:	66fb      	str	r3, [r7, #108]	; 0x6c
	}

	softap_config.softap.encryption_mode   = get_param_softap_encryption();
 801ceb6:	f7ff fe13 	bl	801cae0 <get_param_softap_encryption>
 801ceba:	4603      	mov	r3, r0
 801cebc:	66bb      	str	r3, [r7, #104]	; 0x68
	softap_config.softap.ssid_hidden       = get_boolean_param(INPUT_SOFTAP_SSID_HIDDEN);
 801cebe:	483c      	ldr	r0, [pc, #240]	; (801cfb0 <softap_start+0x1c0>)
 801cec0:	f7ff fde4 	bl	801ca8c <get_boolean_param>
 801cec4:	4603      	mov	r3, r0
 801cec6:	2b00      	cmp	r3, #0
 801cec8:	bf14      	ite	ne
 801ceca:	2301      	movne	r3, #1
 801cecc:	2300      	moveq	r3, #0
 801cece:	b2db      	uxtb	r3, r3
 801ced0:	f887 3070 	strb.w	r3, [r7, #112]	; 0x70
	softap_config.softap.bandwidth         = get_param_softap_bw();
 801ced4:	f7ff fdf0 	bl	801cab8 <get_param_softap_bw>
 801ced8:	4603      	mov	r3, r0
 801ceda:	f887 3071 	strb.w	r3, [r7, #113]	; 0x71

	memset(mac, '\0', WIFI_MAX_STR_LEN);
 801cede:	f107 0394 	add.w	r3, r7, #148	; 0x94
 801cee2:	2213      	movs	r2, #19
 801cee4:	2100      	movs	r1, #0
 801cee6:	4618      	mov	r0, r3
 801cee8:	f002 fcc8 	bl	801f87c <memset>

	ret = wifi_get_mac(wifi_mode, mac);
 801ceec:	f107 0394 	add.w	r3, r7, #148	; 0x94
 801cef0:	4619      	mov	r1, r3
 801cef2:	f8d7 00b4 	ldr.w	r0, [r7, #180]	; 0xb4
 801cef6:	f7fe fbab 	bl	801b650 <wifi_get_mac>
 801cefa:	f8c7 00b0 	str.w	r0, [r7, #176]	; 0xb0
	if (ret) {
 801cefe:	f8d7 30b0 	ldr.w	r3, [r7, #176]	; 0xb0
 801cf02:	2b00      	cmp	r3, #0
 801cf04:	d009      	beq.n	801cf1a <softap_start+0x12a>
		printf("Failed to get MAC address \n\r");
 801cf06:	482b      	ldr	r0, [pc, #172]	; (801cfb4 <softap_start+0x1c4>)
 801cf08:	f003 f930 	bl	802016c <iprintf>
		hard_delay(50000);
 801cf0c:	f24c 3050 	movw	r0, #50000	; 0xc350
 801cf10:	f000 feef 	bl	801dcf2 <hard_delay>
		//HAL_Delay(50000);
		return STM_FAIL;
 801cf14:	f04f 33ff 	mov.w	r3, #4294967295
 801cf18:	e034      	b.n	801cf84 <softap_start+0x194>
	} else {
		printf("SoftAP's MAC address is %s \n\r", mac);
 801cf1a:	f107 0394 	add.w	r3, r7, #148	; 0x94
 801cf1e:	4619      	mov	r1, r3
 801cf20:	4825      	ldr	r0, [pc, #148]	; (801cfb8 <softap_start+0x1c8>)
 801cf22:	f003 f923 	bl	802016c <iprintf>
		save_softap_mac(mac);
 801cf26:	f107 0394 	add.w	r3, r7, #148	; 0x94
 801cf2a:	4618      	mov	r0, r3
 801cf2c:	f7ff fdf4 	bl	801cb18 <save_softap_mac>
	}

	ret = wifi_set_softap_config(softap_config);
 801cf30:	4668      	mov	r0, sp
 801cf32:	f107 0314 	add.w	r3, r7, #20
 801cf36:	2280      	movs	r2, #128	; 0x80
 801cf38:	4619      	mov	r1, r3
 801cf3a:	f002 fc77 	bl	801f82c <memcpy>
 801cf3e:	1d3b      	adds	r3, r7, #4
 801cf40:	cb0f      	ldmia	r3, {r0, r1, r2, r3}
 801cf42:	f7fe fe21 	bl	801bb88 <wifi_set_softap_config>
 801cf46:	f8c7 00b0 	str.w	r0, [r7, #176]	; 0xb0
	if (ret) {
 801cf4a:	f8d7 30b0 	ldr.w	r3, [r7, #176]	; 0xb0
 801cf4e:	2b00      	cmp	r3, #0
 801cf50:	d009      	beq.n	801cf66 <softap_start+0x176>
		printf("Failed to start softAP \n\r");
 801cf52:	481a      	ldr	r0, [pc, #104]	; (801cfbc <softap_start+0x1cc>)
 801cf54:	f003 f90a 	bl	802016c <iprintf>
		hard_delay(50000);
 801cf58:	f24c 3050 	movw	r0, #50000	; 0xc350
 801cf5c:	f000 fec9 	bl	801dcf2 <hard_delay>
		//HAL_Delay(50000);
		return STM_FAIL;
 801cf60:	f04f 33ff 	mov.w	r3, #4294967295
 801cf64:	e00e      	b.n	801cf84 <softap_start+0x194>
	} else {
		printf("started %s softAP\n\r", softap_config.softap.ssid);
 801cf66:	1d3b      	adds	r3, r7, #4
 801cf68:	4619      	mov	r1, r3
 801cf6a:	4815      	ldr	r0, [pc, #84]	; (801cfc0 <softap_start+0x1d0>)
 801cf6c:	f003 f8fe 	bl	802016c <iprintf>
		mode |= MODE_SOFTAP;
 801cf70:	4b14      	ldr	r3, [pc, #80]	; (801cfc4 <softap_start+0x1d4>)
 801cf72:	681b      	ldr	r3, [r3, #0]
 801cf74:	f043 0304 	orr.w	r3, r3, #4
 801cf78:	4a12      	ldr	r2, [pc, #72]	; (801cfc4 <softap_start+0x1d4>)
 801cf7a:	6013      	str	r3, [r2, #0]
		control_path_call_event(SOFTAP_STARTED);
 801cf7c:	2002      	movs	r0, #2
 801cf7e:	f7ff fdb7 	bl	801caf0 <control_path_call_event>
	}
	return STM_OK;
 801cf82:	2300      	movs	r3, #0
}
 801cf84:	4618      	mov	r0, r3
 801cf86:	37b8      	adds	r7, #184	; 0xb8
 801cf88:	46bd      	mov	sp, r7
 801cf8a:	bd80      	pop	{r7, pc}
 801cf8c:	08025114 	.word	0x08025114
 801cf90:	080250d0 	.word	0x080250d0
 801cf94:	08025590 	.word	0x08025590
 801cf98:	08025198 	.word	0x08025198
 801cf9c:	080255b4 	.word	0x080255b4
 801cfa0:	080255dc 	.word	0x080255dc
 801cfa4:	08025224 	.word	0x08025224
 801cfa8:	08025608 	.word	0x08025608
 801cfac:	0802563c 	.word	0x0802563c
 801cfb0:	08025264 	.word	0x08025264
 801cfb4:	08025674 	.word	0x08025674
 801cfb8:	08025694 	.word	0x08025694
 801cfbc:	080256b4 	.word	0x080256b4
 801cfc0:	080256d0 	.word	0x080256d0
 801cfc4:	24034b20 	.word	0x24034b20

0801cfc8 <get_ap_scan_list>:
  * @brief  get available ap list
  * @param  None
  * @retval STM_OK/STM_FAIL
  */
static int get_ap_scan_list(void)
{
 801cfc8:	b5b0      	push	{r4, r5, r7, lr}
 801cfca:	b086      	sub	sp, #24
 801cfcc:	af02      	add	r7, sp, #8
    int count = 0;
 801cfce:	2300      	movs	r3, #0
 801cfd0:	607b      	str	r3, [r7, #4]
    esp_hosted_wifi_scanlist_t* list = NULL;
 801cfd2:	2300      	movs	r3, #0
 801cfd4:	60bb      	str	r3, [r7, #8]
    list = wifi_ap_scan_list(&count);
 801cfd6:	1d3b      	adds	r3, r7, #4
 801cfd8:	4618      	mov	r0, r3
 801cfda:	f7fe ff67 	bl	801beac <wifi_ap_scan_list>
 801cfde:	60b8      	str	r0, [r7, #8]
    if (!count) {
 801cfe0:	687b      	ldr	r3, [r7, #4]
 801cfe2:	2b00      	cmp	r3, #0
 801cfe4:	d103      	bne.n	801cfee <get_ap_scan_list+0x26>
        printf("No AP found \n");
 801cfe6:	482b      	ldr	r0, [pc, #172]	; (801d094 <get_ap_scan_list+0xcc>)
 801cfe8:	f003 f95c 	bl	80202a4 <puts>
 801cfec:	e044      	b.n	801d078 <get_ap_scan_list+0xb0>
    } else if (!list) {
 801cfee:	68bb      	ldr	r3, [r7, #8]
 801cff0:	2b00      	cmp	r3, #0
 801cff2:	d103      	bne.n	801cffc <get_ap_scan_list+0x34>
        printf("Failed to get scanned AP list \n");
 801cff4:	4828      	ldr	r0, [pc, #160]	; (801d098 <get_ap_scan_list+0xd0>)
 801cff6:	f003 f955 	bl	80202a4 <puts>
 801cffa:	e03d      	b.n	801d078 <get_ap_scan_list+0xb0>
    } else {
        printf("Scanned Neighbouring AP list \n\r");
 801cffc:	4827      	ldr	r0, [pc, #156]	; (801d09c <get_ap_scan_list+0xd4>)
 801cffe:	f003 f8b5 	bl	802016c <iprintf>
        printf("+----------------------------------+----------------------+---------+---------+---------------+\n\r");
 801d002:	4827      	ldr	r0, [pc, #156]	; (801d0a0 <get_ap_scan_list+0xd8>)
 801d004:	f003 f8b2 	bl	802016c <iprintf>
        printf("|                 SSID             |         BSSID        |   rssi  | channel | Auth mode     |\n\r");
 801d008:	4826      	ldr	r0, [pc, #152]	; (801d0a4 <get_ap_scan_list+0xdc>)
 801d00a:	f003 f8af 	bl	802016c <iprintf>
        printf("+----------------------------------+----------------------+---------+---------+---------------+\n\r");
 801d00e:	4824      	ldr	r0, [pc, #144]	; (801d0a0 <get_ap_scan_list+0xd8>)
 801d010:	f003 f8ac 	bl	802016c <iprintf>
        for (int i=0; i<count; i++) {
 801d014:	2300      	movs	r3, #0
 801d016:	60fb      	str	r3, [r7, #12]
 801d018:	e027      	b.n	801d06a <get_ap_scan_list+0xa2>
            printf("| %-32s | %-20s | %-7d | %-7d | %-11d   |\n\r"
                    ,list[i].ssid, list[i].bssid,
 801d01a:	68fb      	ldr	r3, [r7, #12]
 801d01c:	019b      	lsls	r3, r3, #6
 801d01e:	68ba      	ldr	r2, [r7, #8]
 801d020:	4413      	add	r3, r2
 801d022:	461d      	mov	r5, r3
 801d024:	68fb      	ldr	r3, [r7, #12]
 801d026:	019b      	lsls	r3, r3, #6
 801d028:	68ba      	ldr	r2, [r7, #8]
 801d02a:	4413      	add	r3, r2
 801d02c:	f103 0020 	add.w	r0, r3, #32
                    list[i].rssi, list[i].channel,
 801d030:	68fb      	ldr	r3, [r7, #12]
 801d032:	019b      	lsls	r3, r3, #6
 801d034:	68ba      	ldr	r2, [r7, #8]
 801d036:	4413      	add	r3, r2
            printf("| %-32s | %-20s | %-7d | %-7d | %-11d   |\n\r"
 801d038:	6b5c      	ldr	r4, [r3, #52]	; 0x34
                    list[i].rssi, list[i].channel,
 801d03a:	68fb      	ldr	r3, [r7, #12]
 801d03c:	019b      	lsls	r3, r3, #6
 801d03e:	68ba      	ldr	r2, [r7, #8]
 801d040:	4413      	add	r3, r2
            printf("| %-32s | %-20s | %-7d | %-7d | %-11d   |\n\r"
 801d042:	6b9b      	ldr	r3, [r3, #56]	; 0x38
                    list[i].encryption_mode);
 801d044:	68fa      	ldr	r2, [r7, #12]
 801d046:	0192      	lsls	r2, r2, #6
 801d048:	68b9      	ldr	r1, [r7, #8]
 801d04a:	440a      	add	r2, r1
            printf("| %-32s | %-20s | %-7d | %-7d | %-11d   |\n\r"
 801d04c:	6bd2      	ldr	r2, [r2, #60]	; 0x3c
 801d04e:	9201      	str	r2, [sp, #4]
 801d050:	9300      	str	r3, [sp, #0]
 801d052:	4623      	mov	r3, r4
 801d054:	4602      	mov	r2, r0
 801d056:	4629      	mov	r1, r5
 801d058:	4813      	ldr	r0, [pc, #76]	; (801d0a8 <get_ap_scan_list+0xe0>)
 801d05a:	f003 f887 	bl	802016c <iprintf>
            hard_delay(50);
 801d05e:	2032      	movs	r0, #50	; 0x32
 801d060:	f000 fe47 	bl	801dcf2 <hard_delay>
        for (int i=0; i<count; i++) {
 801d064:	68fb      	ldr	r3, [r7, #12]
 801d066:	3301      	adds	r3, #1
 801d068:	60fb      	str	r3, [r7, #12]
 801d06a:	687b      	ldr	r3, [r7, #4]
 801d06c:	68fa      	ldr	r2, [r7, #12]
 801d06e:	429a      	cmp	r2, r3
 801d070:	dbd3      	blt.n	801d01a <get_ap_scan_list+0x52>
            //HAL_Delay(50);
        }
        printf("+----------------------------------+----------------------+---------+---------+---------------+\n\r");
 801d072:	480b      	ldr	r0, [pc, #44]	; (801d0a0 <get_ap_scan_list+0xd8>)
 801d074:	f003 f87a 	bl	802016c <iprintf>
    }
    if (list) {
 801d078:	68bb      	ldr	r3, [r7, #8]
 801d07a:	2b00      	cmp	r3, #0
 801d07c:	d004      	beq.n	801d088 <get_ap_scan_list+0xc0>
        free(list);
 801d07e:	68b8      	ldr	r0, [r7, #8]
 801d080:	f000 fa02 	bl	801d488 <esp_hosted_free>
        list = NULL;
 801d084:	2300      	movs	r3, #0
 801d086:	60bb      	str	r3, [r7, #8]
    }
    return STM_OK;
 801d088:	2300      	movs	r3, #0
}
 801d08a:	4618      	mov	r0, r3
 801d08c:	3710      	adds	r7, #16
 801d08e:	46bd      	mov	sp, r7
 801d090:	bdb0      	pop	{r4, r5, r7, pc}
 801d092:	bf00      	nop
 801d094:	080256e4 	.word	0x080256e4
 801d098:	080256f4 	.word	0x080256f4
 801d09c:	08025714 	.word	0x08025714
 801d0a0:	08025734 	.word	0x08025734
 801d0a4:	08025798 	.word	0x08025798
 801d0a8:	080257fc 	.word	0x080257fc

0801d0ac <get_application_mode>:
  * @brief  get mode
  * @param  mode - output mode
  * @retval None
  */
static int get_application_mode(void)
{
 801d0ac:	b580      	push	{r7, lr}
 801d0ae:	af00      	add	r7, sp, #0
	if (strncasecmp(INPUT__OPERATING_MODE, PARAM_STR_SOFTAP_STATION,
 801d0b0:	220e      	movs	r2, #14
 801d0b2:	490b      	ldr	r1, [pc, #44]	; (801d0e0 <get_application_mode+0x34>)
 801d0b4:	480b      	ldr	r0, [pc, #44]	; (801d0e4 <get_application_mode+0x38>)
 801d0b6:	f003 fbd7 	bl	8020868 <strncasecmp>
 801d0ba:	4603      	mov	r3, r0
 801d0bc:	2b00      	cmp	r3, #0
 801d0be:	d101      	bne.n	801d0c4 <get_application_mode+0x18>
				strlen(PARAM_STR_SOFTAP_STATION))==0) {

		return MODE_SOFTAP_STATION;
 801d0c0:	2306      	movs	r3, #6
 801d0c2:	e00a      	b.n	801d0da <get_application_mode+0x2e>

	} else if (strncasecmp(INPUT__OPERATING_MODE, PARAM_STR_STATION_SOFTAP,
 801d0c4:	220e      	movs	r2, #14
 801d0c6:	4908      	ldr	r1, [pc, #32]	; (801d0e8 <get_application_mode+0x3c>)
 801d0c8:	4806      	ldr	r0, [pc, #24]	; (801d0e4 <get_application_mode+0x38>)
 801d0ca:	f003 fbcd 	bl	8020868 <strncasecmp>
 801d0ce:	4603      	mov	r3, r0
 801d0d0:	2b00      	cmp	r3, #0
 801d0d2:	d101      	bne.n	801d0d8 <get_application_mode+0x2c>
				strlen(PARAM_STR_STATION_SOFTAP))==0) {

		return MODE_SOFTAP_STATION;
 801d0d4:	2306      	movs	r3, #6
 801d0d6:	e000      	b.n	801d0da <get_application_mode+0x2e>

	} else if (strncasecmp(INPUT__OPERATING_MODE, PARAM_STR_SOFTAP,
				strlen(PARAM_STR_SOFTAP))==0) {

		return MODE_SOFTAP;
 801d0d8:	2304      	movs	r3, #4

	} else {

		return MODE_NULL;
	}
}
 801d0da:	4618      	mov	r0, r3
 801d0dc:	bd80      	pop	{r7, pc}
 801d0de:	bf00      	nop
 801d0e0:	08025828 	.word	0x08025828
 801d0e4:	08024ffc 	.word	0x08024ffc
 801d0e8:	08025838 	.word	0x08025838

0801d0ec <control_path_task>:
  * @brief  Control path task
  * @param  argument: Not used
  * @retval None
  */
static void control_path_task(ULONG argument)
{
 801d0ec:	b580      	push	{r7, lr}
 801d0ee:	b088      	sub	sp, #32
 801d0f0:	af00      	add	r7, sp, #0
 801d0f2:	6078      	str	r0, [r7, #4]
	int ret = 0, app_mode = 0, station_connect_retry = 0, softap_start_retry = 0;
 801d0f4:	2300      	movs	r3, #0
 801d0f6:	613b      	str	r3, [r7, #16]
 801d0f8:	2300      	movs	r3, #0
 801d0fa:	60fb      	str	r3, [r7, #12]
 801d0fc:	2300      	movs	r3, #0
 801d0fe:	61fb      	str	r3, [r7, #28]
 801d100:	2300      	movs	r3, #0
 801d102:	61bb      	str	r3, [r7, #24]
	bool scap_ap_list = false, stop = false;
 801d104:	2300      	movs	r3, #0
 801d106:	75fb      	strb	r3, [r7, #23]
 801d108:	2300      	movs	r3, #0
 801d10a:	75bb      	strb	r3, [r7, #22]

	app_mode = get_application_mode();
 801d10c:	f7ff ffce 	bl	801d0ac <get_application_mode>
 801d110:	60f8      	str	r0, [r7, #12]
	//printf("Application mode is %d \n\r", mode);
	for (;;) {

		if (!stop) {
 801d112:	7dbb      	ldrb	r3, [r7, #22]
 801d114:	f083 0301 	eor.w	r3, r3, #1
 801d118:	b2db      	uxtb	r3, r3
 801d11a:	2b00      	cmp	r3, #0
 801d11c:	f000 80de 	beq.w	801d2dc <control_path_task+0x1f0>
			if (get_boolean_param(INPUT_GET_AP_SCAN_LIST) && !scap_ap_list) {
 801d120:	4876      	ldr	r0, [pc, #472]	; (801d2fc <control_path_task+0x210>)
 801d122:	f7ff fcb3 	bl	801ca8c <get_boolean_param>
 801d126:	4603      	mov	r3, r0
 801d128:	2b00      	cmp	r3, #0
 801d12a:	d00e      	beq.n	801d14a <control_path_task+0x5e>
 801d12c:	7dfb      	ldrb	r3, [r7, #23]
 801d12e:	f083 0301 	eor.w	r3, r3, #1
 801d132:	b2db      	uxtb	r3, r3
 801d134:	2b00      	cmp	r3, #0
 801d136:	d008      	beq.n	801d14a <control_path_task+0x5e>
				ret = get_ap_scan_list();
 801d138:	f7ff ff46 	bl	801cfc8 <get_ap_scan_list>
 801d13c:	6138      	str	r0, [r7, #16]
				if (ret) {
 801d13e:	693b      	ldr	r3, [r7, #16]
 801d140:	2b00      	cmp	r3, #0
 801d142:	f040 80d0 	bne.w	801d2e6 <control_path_task+0x1fa>
					continue;
				}
				scap_ap_list = true;
 801d146:	2301      	movs	r3, #1
 801d148:	75fb      	strb	r3, [r7, #23]
			}
			switch (app_mode) {
 801d14a:	68fb      	ldr	r3, [r7, #12]
 801d14c:	3b01      	subs	r3, #1
 801d14e:	2b06      	cmp	r3, #6
 801d150:	f200 80b4 	bhi.w	801d2bc <control_path_task+0x1d0>
 801d154:	a201      	add	r2, pc, #4	; (adr r2, 801d15c <control_path_task+0x70>)
 801d156:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 801d15a:	bf00      	nop
 801d15c:	0801d2eb 	.word	0x0801d2eb
 801d160:	0801d179 	.word	0x0801d179
 801d164:	0801d2bd 	.word	0x0801d2bd
 801d168:	0801d1c5 	.word	0x0801d1c5
 801d16c:	0801d2bd 	.word	0x0801d2bd
 801d170:	0801d20f 	.word	0x0801d20f
 801d174:	0801d2eb 	.word	0x0801d2eb
				case MODE_STATION:
				{
					if (station_connect_retry < RETRY_COUNT) {
 801d178:	69fb      	ldr	r3, [r7, #28]
 801d17a:	2b04      	cmp	r3, #4
 801d17c:	dc18      	bgt.n	801d1b0 <control_path_task+0xc4>
						ret = station_connect();
 801d17e:	f7ff fda3 	bl	801ccc8 <station_connect>
 801d182:	6138      	str	r0, [r7, #16]
						if (ret) {
 801d184:	693b      	ldr	r3, [r7, #16]
 801d186:	2b00      	cmp	r3, #0
 801d188:	d009      	beq.n	801d19e <control_path_task+0xb2>
							mode &= ~MODE_STATION;
 801d18a:	4b5d      	ldr	r3, [pc, #372]	; (801d300 <control_path_task+0x214>)
 801d18c:	681b      	ldr	r3, [r3, #0]
 801d18e:	f023 0302 	bic.w	r3, r3, #2
 801d192:	4a5b      	ldr	r2, [pc, #364]	; (801d300 <control_path_task+0x214>)
 801d194:	6013      	str	r3, [r2, #0]
							station_connect_retry++;
 801d196:	69fb      	ldr	r3, [r7, #28]
 801d198:	3301      	adds	r3, #1
 801d19a:	61fb      	str	r3, [r7, #28]
							continue;
 801d19c:	e0ac      	b.n	801d2f8 <control_path_task+0x20c>
						} else {
							mode |= MODE_STATION;
 801d19e:	4b58      	ldr	r3, [pc, #352]	; (801d300 <control_path_task+0x214>)
 801d1a0:	681b      	ldr	r3, [r3, #0]
 801d1a2:	f043 0302 	orr.w	r3, r3, #2
 801d1a6:	4a56      	ldr	r2, [pc, #344]	; (801d300 <control_path_task+0x214>)
 801d1a8:	6013      	str	r3, [r2, #0]
							stop = true;
 801d1aa:	2301      	movs	r3, #1
 801d1ac:	75bb      	strb	r3, [r7, #22]
						}
					} else if (station_connect_retry == RETRY_COUNT) {
						stop = true;
						printf("Maximum retry done to connect with AP\n\r");
					}
					break;
 801d1ae:	e09e      	b.n	801d2ee <control_path_task+0x202>
					} else if (station_connect_retry == RETRY_COUNT) {
 801d1b0:	69fb      	ldr	r3, [r7, #28]
 801d1b2:	2b05      	cmp	r3, #5
 801d1b4:	f040 809b 	bne.w	801d2ee <control_path_task+0x202>
						stop = true;
 801d1b8:	2301      	movs	r3, #1
 801d1ba:	75bb      	strb	r3, [r7, #22]
						printf("Maximum retry done to connect with AP\n\r");
 801d1bc:	4851      	ldr	r0, [pc, #324]	; (801d304 <control_path_task+0x218>)
 801d1be:	f002 ffd5 	bl	802016c <iprintf>
					break;
 801d1c2:	e094      	b.n	801d2ee <control_path_task+0x202>
				}
				case MODE_SOFTAP:
				{
					if (softap_start_retry < RETRY_COUNT) {
 801d1c4:	69bb      	ldr	r3, [r7, #24]
 801d1c6:	2b04      	cmp	r3, #4
 801d1c8:	dc18      	bgt.n	801d1fc <control_path_task+0x110>
						ret = softap_start();
 801d1ca:	f7ff fe11 	bl	801cdf0 <softap_start>
 801d1ce:	6138      	str	r0, [r7, #16]
						if (ret) {
 801d1d0:	693b      	ldr	r3, [r7, #16]
 801d1d2:	2b00      	cmp	r3, #0
 801d1d4:	d009      	beq.n	801d1ea <control_path_task+0xfe>
							mode &= ~MODE_SOFTAP;
 801d1d6:	4b4a      	ldr	r3, [pc, #296]	; (801d300 <control_path_task+0x214>)
 801d1d8:	681b      	ldr	r3, [r3, #0]
 801d1da:	f023 0304 	bic.w	r3, r3, #4
 801d1de:	4a48      	ldr	r2, [pc, #288]	; (801d300 <control_path_task+0x214>)
 801d1e0:	6013      	str	r3, [r2, #0]
							softap_start_retry++;
 801d1e2:	69bb      	ldr	r3, [r7, #24]
 801d1e4:	3301      	adds	r3, #1
 801d1e6:	61bb      	str	r3, [r7, #24]
							continue;
 801d1e8:	e086      	b.n	801d2f8 <control_path_task+0x20c>
						} else {
							mode |= MODE_SOFTAP;
 801d1ea:	4b45      	ldr	r3, [pc, #276]	; (801d300 <control_path_task+0x214>)
 801d1ec:	681b      	ldr	r3, [r3, #0]
 801d1ee:	f043 0304 	orr.w	r3, r3, #4
 801d1f2:	4a43      	ldr	r2, [pc, #268]	; (801d300 <control_path_task+0x214>)
 801d1f4:	6013      	str	r3, [r2, #0]
							stop = true;
 801d1f6:	2301      	movs	r3, #1
 801d1f8:	75bb      	strb	r3, [r7, #22]
						}
					} else if (softap_start_retry == RETRY_COUNT) {
						stop = true;
						printf("Maximum retry done to start SOFTAP \n\r");
					}
					break;
 801d1fa:	e07a      	b.n	801d2f2 <control_path_task+0x206>
					} else if (softap_start_retry == RETRY_COUNT) {
 801d1fc:	69bb      	ldr	r3, [r7, #24]
 801d1fe:	2b05      	cmp	r3, #5
 801d200:	d177      	bne.n	801d2f2 <control_path_task+0x206>
						stop = true;
 801d202:	2301      	movs	r3, #1
 801d204:	75bb      	strb	r3, [r7, #22]
						printf("Maximum retry done to start SOFTAP \n\r");
 801d206:	4840      	ldr	r0, [pc, #256]	; (801d308 <control_path_task+0x21c>)
 801d208:	f002 ffb0 	bl	802016c <iprintf>
					break;
 801d20c:	e071      	b.n	801d2f2 <control_path_task+0x206>
				}
				case MODE_SOFTAP_STATION:
				{
					if (!(mode & MODE_STATION) && station_connect_retry < RETRY_COUNT) {
 801d20e:	4b3c      	ldr	r3, [pc, #240]	; (801d300 <control_path_task+0x214>)
 801d210:	681b      	ldr	r3, [r3, #0]
 801d212:	f003 0302 	and.w	r3, r3, #2
 801d216:	2b00      	cmp	r3, #0
 801d218:	d119      	bne.n	801d24e <control_path_task+0x162>
 801d21a:	69fb      	ldr	r3, [r7, #28]
 801d21c:	2b04      	cmp	r3, #4
 801d21e:	dc16      	bgt.n	801d24e <control_path_task+0x162>
						ret = station_connect();
 801d220:	f7ff fd52 	bl	801ccc8 <station_connect>
 801d224:	6138      	str	r0, [r7, #16]
						if (ret) {
 801d226:	693b      	ldr	r3, [r7, #16]
 801d228:	2b00      	cmp	r3, #0
 801d22a:	d009      	beq.n	801d240 <control_path_task+0x154>
							mode &= ~MODE_STATION;
 801d22c:	4b34      	ldr	r3, [pc, #208]	; (801d300 <control_path_task+0x214>)
 801d22e:	681b      	ldr	r3, [r3, #0]
 801d230:	f023 0302 	bic.w	r3, r3, #2
 801d234:	4a32      	ldr	r2, [pc, #200]	; (801d300 <control_path_task+0x214>)
 801d236:	6013      	str	r3, [r2, #0]
							station_connect_retry++;
 801d238:	69fb      	ldr	r3, [r7, #28]
 801d23a:	3301      	adds	r3, #1
 801d23c:	61fb      	str	r3, [r7, #28]
						if (ret) {
 801d23e:	e00e      	b.n	801d25e <control_path_task+0x172>
						} else {
							mode |= MODE_STATION;
 801d240:	4b2f      	ldr	r3, [pc, #188]	; (801d300 <control_path_task+0x214>)
 801d242:	681b      	ldr	r3, [r3, #0]
 801d244:	f043 0302 	orr.w	r3, r3, #2
 801d248:	4a2d      	ldr	r2, [pc, #180]	; (801d300 <control_path_task+0x214>)
 801d24a:	6013      	str	r3, [r2, #0]
						if (ret) {
 801d24c:	e007      	b.n	801d25e <control_path_task+0x172>
						}
					} else if (station_connect_retry == RETRY_COUNT){
 801d24e:	69fb      	ldr	r3, [r7, #28]
 801d250:	2b05      	cmp	r3, #5
 801d252:	d104      	bne.n	801d25e <control_path_task+0x172>
						stop = true;
 801d254:	2301      	movs	r3, #1
 801d256:	75bb      	strb	r3, [r7, #22]
						printf("Maximum retry done to connect with AP\n\r");
 801d258:	482a      	ldr	r0, [pc, #168]	; (801d304 <control_path_task+0x218>)
 801d25a:	f002 ff87 	bl	802016c <iprintf>
					}
					if (!(mode & MODE_SOFTAP) && softap_start_retry < RETRY_COUNT) {
 801d25e:	4b28      	ldr	r3, [pc, #160]	; (801d300 <control_path_task+0x214>)
 801d260:	681b      	ldr	r3, [r3, #0]
 801d262:	f003 0304 	and.w	r3, r3, #4
 801d266:	2b00      	cmp	r3, #0
 801d268:	d119      	bne.n	801d29e <control_path_task+0x1b2>
 801d26a:	69bb      	ldr	r3, [r7, #24]
 801d26c:	2b04      	cmp	r3, #4
 801d26e:	dc16      	bgt.n	801d29e <control_path_task+0x1b2>
						ret = softap_start();
 801d270:	f7ff fdbe 	bl	801cdf0 <softap_start>
 801d274:	6138      	str	r0, [r7, #16]
						if (ret) {
 801d276:	693b      	ldr	r3, [r7, #16]
 801d278:	2b00      	cmp	r3, #0
 801d27a:	d009      	beq.n	801d290 <control_path_task+0x1a4>
							mode &= ~MODE_SOFTAP;
 801d27c:	4b20      	ldr	r3, [pc, #128]	; (801d300 <control_path_task+0x214>)
 801d27e:	681b      	ldr	r3, [r3, #0]
 801d280:	f023 0304 	bic.w	r3, r3, #4
 801d284:	4a1e      	ldr	r2, [pc, #120]	; (801d300 <control_path_task+0x214>)
 801d286:	6013      	str	r3, [r2, #0]
							softap_start_retry++;
 801d288:	69bb      	ldr	r3, [r7, #24]
 801d28a:	3301      	adds	r3, #1
 801d28c:	61bb      	str	r3, [r7, #24]
						if (ret) {
 801d28e:	e00e      	b.n	801d2ae <control_path_task+0x1c2>
						} else {
							mode |= MODE_SOFTAP;
 801d290:	4b1b      	ldr	r3, [pc, #108]	; (801d300 <control_path_task+0x214>)
 801d292:	681b      	ldr	r3, [r3, #0]
 801d294:	f043 0304 	orr.w	r3, r3, #4
 801d298:	4a19      	ldr	r2, [pc, #100]	; (801d300 <control_path_task+0x214>)
 801d29a:	6013      	str	r3, [r2, #0]
						if (ret) {
 801d29c:	e007      	b.n	801d2ae <control_path_task+0x1c2>
						}
					} else if (softap_start_retry == RETRY_COUNT) {
 801d29e:	69bb      	ldr	r3, [r7, #24]
 801d2a0:	2b05      	cmp	r3, #5
 801d2a2:	d104      	bne.n	801d2ae <control_path_task+0x1c2>
						stop = true;
 801d2a4:	2301      	movs	r3, #1
 801d2a6:	75bb      	strb	r3, [r7, #22]
						printf("Maximum retry done to start SOFTAP \n\r");
 801d2a8:	4817      	ldr	r0, [pc, #92]	; (801d308 <control_path_task+0x21c>)
 801d2aa:	f002 ff5f 	bl	802016c <iprintf>
					}
					if (mode == MODE_SOFTAP_STATION) {
 801d2ae:	4b14      	ldr	r3, [pc, #80]	; (801d300 <control_path_task+0x214>)
 801d2b0:	681b      	ldr	r3, [r3, #0]
 801d2b2:	2b06      	cmp	r3, #6
 801d2b4:	d11f      	bne.n	801d2f6 <control_path_task+0x20a>
						stop = true;
 801d2b6:	2301      	movs	r3, #1
 801d2b8:	75bb      	strb	r3, [r7, #22]
					}
					break;
 801d2ba:	e01c      	b.n	801d2f6 <control_path_task+0x20a>
				case MODE_NULL:
				case MODE_MAX:
					break;
				default:
				{
					printf("Operating mode is not selected.\n\r");
 801d2bc:	4813      	ldr	r0, [pc, #76]	; (801d30c <control_path_task+0x220>)
 801d2be:	f002 ff55 	bl	802016c <iprintf>
					printf("Please revisit Project settings->\n\r");
 801d2c2:	4813      	ldr	r0, [pc, #76]	; (801d310 <control_path_task+0x224>)
 801d2c4:	f002 ff52 	bl	802016c <iprintf>
					printf("   ->C/C++ Build->Build Variables->INPUT_OPERATING_MODE\n\r");
 801d2c8:	4812      	ldr	r0, [pc, #72]	; (801d314 <control_path_task+0x228>)
 801d2ca:	f002 ff4f 	bl	802016c <iprintf>
					printf("=> Either \"STATION\" or \"SOFTAP\" or \"SOFTAP+STATION\"\n\r");
 801d2ce:	4812      	ldr	r0, [pc, #72]	; (801d318 <control_path_task+0x22c>)
 801d2d0:	f002 ff4c 	bl	802016c <iprintf>
					hard_delay(500000);
 801d2d4:	4811      	ldr	r0, [pc, #68]	; (801d31c <control_path_task+0x230>)
 801d2d6:	f000 fd0c 	bl	801dcf2 <hard_delay>
 801d2da:	e71a      	b.n	801d112 <control_path_task+0x26>
					//HAL_Delay(50000);
				}
			}

		} else {
			tx_thread_sleep(MS_TO_TICKS(5000));
 801d2dc:	f44f 70fa 	mov.w	r0, #500	; 0x1f4
 801d2e0:	f7f7 fc68 	bl	8014bb4 <_tx_thread_sleep>
 801d2e4:	e715      	b.n	801d112 <control_path_task+0x26>
					continue;
 801d2e6:	bf00      	nop
 801d2e8:	e713      	b.n	801d112 <control_path_task+0x26>
					break;
 801d2ea:	bf00      	nop
 801d2ec:	e711      	b.n	801d112 <control_path_task+0x26>
					break;
 801d2ee:	bf00      	nop
 801d2f0:	e70f      	b.n	801d112 <control_path_task+0x26>
					break;
 801d2f2:	bf00      	nop
 801d2f4:	e70d      	b.n	801d112 <control_path_task+0x26>
					break;
 801d2f6:	bf00      	nop
		if (!stop) {
 801d2f8:	e70b      	b.n	801d112 <control_path_task+0x26>
 801d2fa:	bf00      	nop
 801d2fc:	08024f3c 	.word	0x08024f3c
 801d300:	24034b20 	.word	0x24034b20
 801d304:	08025848 	.word	0x08025848
 801d308:	08025870 	.word	0x08025870
 801d30c:	08025898 	.word	0x08025898
 801d310:	080258bc 	.word	0x080258bc
 801d314:	080258e0 	.word	0x080258e0
 801d318:	0802591c 	.word	0x0802591c
 801d31c:	0007a120 	.word	0x0007a120

0801d320 <control_path_platform_init>:
struct esp_hosted_driver_handle_t {
    int handle; /* dummy variable */
};

int control_path_platform_init(void)
{
 801d320:	b580      	push	{r7, lr}
 801d322:	b082      	sub	sp, #8
 801d324:	af00      	add	r7, sp, #0
	UINT status;

	/* control path semaphore */
	status = tx_semaphore_create(&readSemaphore, "readSemaphore", 1);
 801d326:	231c      	movs	r3, #28
 801d328:	2201      	movs	r2, #1
 801d32a:	4926      	ldr	r1, [pc, #152]	; (801d3c4 <control_path_platform_init+0xa4>)
 801d32c:	4826      	ldr	r0, [pc, #152]	; (801d3c8 <control_path_platform_init+0xa8>)
 801d32e:	f7f9 f9a5 	bl	801667c <_txe_semaphore_create>
 801d332:	6078      	str	r0, [r7, #4]
	assert(status == TX_SUCCESS);
 801d334:	687b      	ldr	r3, [r7, #4]
 801d336:	2b00      	cmp	r3, #0
 801d338:	d005      	beq.n	801d346 <control_path_platform_init+0x26>
 801d33a:	222e      	movs	r2, #46	; 0x2e
 801d33c:	4923      	ldr	r1, [pc, #140]	; (801d3cc <control_path_platform_init+0xac>)
 801d33e:	4824      	ldr	r0, [pc, #144]	; (801d3d0 <control_path_platform_init+0xb0>)
 801d340:	f002 ff14 	bl	802016c <iprintf>
 801d344:	e7fe      	b.n	801d344 <control_path_platform_init+0x24>

	/* grab the semaphore, so that task will be mandated to wait on semaphore */
	if (tx_semaphore_get(&readSemaphore, TX_WAIT_FOREVER) != TX_SUCCESS) {
 801d346:	f04f 31ff 	mov.w	r1, #4294967295
 801d34a:	481f      	ldr	r0, [pc, #124]	; (801d3c8 <control_path_platform_init+0xa8>)
 801d34c:	f7f9 fa6a 	bl	8016824 <_txe_semaphore_get>
 801d350:	4603      	mov	r3, r0
 801d352:	2b00      	cmp	r3, #0
 801d354:	d005      	beq.n	801d362 <control_path_platform_init+0x42>
	    printf("could not obtain readSemaphore\n\r");
 801d356:	481f      	ldr	r0, [pc, #124]	; (801d3d4 <control_path_platform_init+0xb4>)
 801d358:	f002 ff08 	bl	802016c <iprintf>
	    return STM_FAIL;
 801d35c:	f04f 33ff 	mov.w	r3, #4294967295
 801d360:	e02b      	b.n	801d3ba <control_path_platform_init+0x9a>
	}

	serial_if_g = serial_init(control_path_rx_indication);
 801d362:	481d      	ldr	r0, [pc, #116]	; (801d3d8 <control_path_platform_init+0xb8>)
 801d364:	f001 fb5a 	bl	801ea1c <serial_init>
 801d368:	4603      	mov	r3, r0
 801d36a:	4a1c      	ldr	r2, [pc, #112]	; (801d3dc <control_path_platform_init+0xbc>)
 801d36c:	6013      	str	r3, [r2, #0]
	if (!serial_if_g) {
 801d36e:	4b1b      	ldr	r3, [pc, #108]	; (801d3dc <control_path_platform_init+0xbc>)
 801d370:	681b      	ldr	r3, [r3, #0]
 801d372:	2b00      	cmp	r3, #0
 801d374:	d10f      	bne.n	801d396 <control_path_platform_init+0x76>
	    printf("Serial interface creation failed\n\r");
 801d376:	481a      	ldr	r0, [pc, #104]	; (801d3e0 <control_path_platform_init+0xc0>)
 801d378:	f002 fef8 	bl	802016c <iprintf>
	    assert(serial_if_g);
 801d37c:	4b17      	ldr	r3, [pc, #92]	; (801d3dc <control_path_platform_init+0xbc>)
 801d37e:	681b      	ldr	r3, [r3, #0]
 801d380:	2b00      	cmp	r3, #0
 801d382:	d105      	bne.n	801d390 <control_path_platform_init+0x70>
 801d384:	2239      	movs	r2, #57	; 0x39
 801d386:	4911      	ldr	r1, [pc, #68]	; (801d3cc <control_path_platform_init+0xac>)
 801d388:	4811      	ldr	r0, [pc, #68]	; (801d3d0 <control_path_platform_init+0xb0>)
 801d38a:	f002 feef 	bl	802016c <iprintf>
 801d38e:	e7fe      	b.n	801d38e <control_path_platform_init+0x6e>
	    return STM_FAIL;
 801d390:	f04f 33ff 	mov.w	r3, #4294967295
 801d394:	e011      	b.n	801d3ba <control_path_platform_init+0x9a>
	}
	if (STM_OK != serial_if_g->fops->open(serial_if_g)) {
 801d396:	4b11      	ldr	r3, [pc, #68]	; (801d3dc <control_path_platform_init+0xbc>)
 801d398:	681b      	ldr	r3, [r3, #0]
 801d39a:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 801d39c:	681b      	ldr	r3, [r3, #0]
 801d39e:	4a0f      	ldr	r2, [pc, #60]	; (801d3dc <control_path_platform_init+0xbc>)
 801d3a0:	6812      	ldr	r2, [r2, #0]
 801d3a2:	4610      	mov	r0, r2
 801d3a4:	4798      	blx	r3
 801d3a6:	4603      	mov	r3, r0
 801d3a8:	2b00      	cmp	r3, #0
 801d3aa:	d005      	beq.n	801d3b8 <control_path_platform_init+0x98>
		printf("Serial interface open failed\n\r");
 801d3ac:	480d      	ldr	r0, [pc, #52]	; (801d3e4 <control_path_platform_init+0xc4>)
 801d3ae:	f002 fedd 	bl	802016c <iprintf>
		return STM_FAIL;
 801d3b2:	f04f 33ff 	mov.w	r3, #4294967295
 801d3b6:	e000      	b.n	801d3ba <control_path_platform_init+0x9a>
	}
	return STM_OK;
 801d3b8:	2300      	movs	r3, #0
}
 801d3ba:	4618      	mov	r0, r3
 801d3bc:	3708      	adds	r7, #8
 801d3be:	46bd      	mov	sp, r7
 801d3c0:	bd80      	pop	{r7, pc}
 801d3c2:	bf00      	nop
 801d3c4:	08025954 	.word	0x08025954
 801d3c8:	24035bec 	.word	0x24035bec
 801d3cc:	08025964 	.word	0x08025964
 801d3d0:	080259b8 	.word	0x080259b8
 801d3d4:	080259cc 	.word	0x080259cc
 801d3d8:	0801d3e9 	.word	0x0801d3e9
 801d3dc:	24035c08 	.word	0x24035c08
 801d3e0:	080259f0 	.word	0x080259f0
 801d3e4:	08025a14 	.word	0x08025a14

0801d3e8 <control_path_rx_indication>:
	}
	return STM_OK;
}

static void control_path_rx_indication(void)
{
 801d3e8:	b580      	push	{r7, lr}
 801d3ea:	af00      	add	r7, sp, #0
	(VOID)tx_semaphore_put(&readSemaphore);
 801d3ec:	4802      	ldr	r0, [pc, #8]	; (801d3f8 <control_path_rx_indication+0x10>)
 801d3ee:	f7f9 fa5b 	bl	80168a8 <_txe_semaphore_put>
}
 801d3f2:	bf00      	nop
 801d3f4:	bd80      	pop	{r7, pc}
 801d3f6:	bf00      	nop
 801d3f8:	24035bec 	.word	0x24035bec

0801d3fc <esp_hosted_heap_init>:

void esp_hosted_heap_init(void)
{
 801d3fc:	b580      	push	{r7, lr}
 801d3fe:	b082      	sub	sp, #8
 801d400:	af02      	add	r7, sp, #8
    (VOID)tx_byte_pool_create(&byte_tool, "ESP Hosted Byte Pool", byte_pool_mem, BYTE_POOL_SIZE);
 801d402:	2334      	movs	r3, #52	; 0x34
 801d404:	9300      	str	r3, [sp, #0]
 801d406:	f44f 33a0 	mov.w	r3, #81920	; 0x14000
 801d40a:	4a04      	ldr	r2, [pc, #16]	; (801d41c <esp_hosted_heap_init+0x20>)
 801d40c:	4904      	ldr	r1, [pc, #16]	; (801d420 <esp_hosted_heap_init+0x24>)
 801d40e:	4805      	ldr	r0, [pc, #20]	; (801d424 <esp_hosted_heap_init+0x28>)
 801d410:	f7f8 fc32 	bl	8015c78 <_txe_byte_pool_create>
}
 801d414:	bf00      	nop
 801d416:	46bd      	mov	sp, r7
 801d418:	bd80      	pop	{r7, pc}
 801d41a:	bf00      	nop
 801d41c:	24035c0c 	.word	0x24035c0c
 801d420:	08025a54 	.word	0x08025a54
 801d424:	24049c0c 	.word	0x24049c0c

0801d428 <esp_hosted_malloc>:

void* esp_hosted_malloc(size_t size)
{
 801d428:	b580      	push	{r7, lr}
 801d42a:	b084      	sub	sp, #16
 801d42c:	af00      	add	r7, sp, #0
 801d42e:	6078      	str	r0, [r7, #4]
    void *pointer;
    return tx_byte_allocate(&byte_tool, &pointer, size, TX_NO_WAIT) == TX_SUCCESS ? pointer : NULL;
 801d430:	f107 010c 	add.w	r1, r7, #12
 801d434:	2300      	movs	r3, #0
 801d436:	687a      	ldr	r2, [r7, #4]
 801d438:	4806      	ldr	r0, [pc, #24]	; (801d454 <esp_hosted_malloc+0x2c>)
 801d43a:	f7f8 fba9 	bl	8015b90 <_txe_byte_allocate>
 801d43e:	4603      	mov	r3, r0
 801d440:	2b00      	cmp	r3, #0
 801d442:	d101      	bne.n	801d448 <esp_hosted_malloc+0x20>
 801d444:	68fb      	ldr	r3, [r7, #12]
 801d446:	e000      	b.n	801d44a <esp_hosted_malloc+0x22>
 801d448:	2300      	movs	r3, #0
}
 801d44a:	4618      	mov	r0, r3
 801d44c:	3710      	adds	r7, #16
 801d44e:	46bd      	mov	sp, r7
 801d450:	bd80      	pop	{r7, pc}
 801d452:	bf00      	nop
 801d454:	24049c0c 	.word	0x24049c0c

0801d458 <esp_hosted_calloc>:

void* esp_hosted_calloc(size_t blk_no, size_t size)
{
 801d458:	b580      	push	{r7, lr}
 801d45a:	b084      	sub	sp, #16
 801d45c:	af00      	add	r7, sp, #0
 801d45e:	6078      	str	r0, [r7, #4]
 801d460:	6039      	str	r1, [r7, #0]
    size_t total = blk_no * size;
 801d462:	687b      	ldr	r3, [r7, #4]
 801d464:	683a      	ldr	r2, [r7, #0]
 801d466:	fb02 f303 	mul.w	r3, r2, r3
 801d46a:	60fb      	str	r3, [r7, #12]
    void *pointer = esp_hosted_malloc(total);
 801d46c:	68f8      	ldr	r0, [r7, #12]
 801d46e:	f7ff ffdb 	bl	801d428 <esp_hosted_malloc>
 801d472:	60b8      	str	r0, [r7, #8]
    TX_MEMSET(pointer, 0, total);
 801d474:	68fa      	ldr	r2, [r7, #12]
 801d476:	2100      	movs	r1, #0
 801d478:	68b8      	ldr	r0, [r7, #8]
 801d47a:	f002 f9ff 	bl	801f87c <memset>
    return pointer;
 801d47e:	68bb      	ldr	r3, [r7, #8]
}
 801d480:	4618      	mov	r0, r3
 801d482:	3710      	adds	r7, #16
 801d484:	46bd      	mov	sp, r7
 801d486:	bd80      	pop	{r7, pc}

0801d488 <esp_hosted_free>:

void esp_hosted_free(void* ptr)
{
 801d488:	b580      	push	{r7, lr}
 801d48a:	b082      	sub	sp, #8
 801d48c:	af00      	add	r7, sp, #0
 801d48e:	6078      	str	r0, [r7, #4]
    (VOID)tx_byte_release(ptr);
 801d490:	6878      	ldr	r0, [r7, #4]
 801d492:	f7f8 fc91 	bl	8015db8 <_txe_byte_release>
}
 801d496:	bf00      	nop
 801d498:	3708      	adds	r7, #8
 801d49a:	46bd      	mov	sp, r7
 801d49c:	bd80      	pop	{r7, pc}
	...

0801d4a0 <esp_hosted_driver_open>:

struct esp_hosted_driver_handle_t* esp_hosted_driver_open(const char* transport)
{
 801d4a0:	b580      	push	{r7, lr}
 801d4a2:	b084      	sub	sp, #16
 801d4a4:	af00      	add	r7, sp, #0
 801d4a6:	6078      	str	r0, [r7, #4]
	struct esp_hosted_driver_handle_t* esp_hosted_driver_handle = NULL;
 801d4a8:	2300      	movs	r3, #0
 801d4aa:	60fb      	str	r3, [r7, #12]
	if (!transport) {
 801d4ac:	687b      	ldr	r3, [r7, #4]
 801d4ae:	2b00      	cmp	r3, #0
 801d4b0:	d104      	bne.n	801d4bc <esp_hosted_driver_open+0x1c>
		printf("Invalid parameter in open \n\r");
 801d4b2:	480b      	ldr	r0, [pc, #44]	; (801d4e0 <esp_hosted_driver_open+0x40>)
 801d4b4:	f002 fe5a 	bl	802016c <iprintf>
		return NULL;
 801d4b8:	2300      	movs	r3, #0
 801d4ba:	e00d      	b.n	801d4d8 <esp_hosted_driver_open+0x38>
	}
	esp_hosted_driver_handle = (struct esp_hosted_driver_handle_t*) esp_hosted_calloc
 801d4bc:	2104      	movs	r1, #4
 801d4be:	2001      	movs	r0, #1
 801d4c0:	f7ff ffca 	bl	801d458 <esp_hosted_calloc>
 801d4c4:	60f8      	str	r0, [r7, #12]
		(1,sizeof(struct esp_hosted_driver_handle_t));
	if (!esp_hosted_driver_handle) {
 801d4c6:	68fb      	ldr	r3, [r7, #12]
 801d4c8:	2b00      	cmp	r3, #0
 801d4ca:	d104      	bne.n	801d4d6 <esp_hosted_driver_open+0x36>
		printf("Failed to allocate memory \n");
 801d4cc:	4805      	ldr	r0, [pc, #20]	; (801d4e4 <esp_hosted_driver_open+0x44>)
 801d4ce:	f002 fee9 	bl	80202a4 <puts>
		return NULL;
 801d4d2:	2300      	movs	r3, #0
 801d4d4:	e000      	b.n	801d4d8 <esp_hosted_driver_open+0x38>
	}
	return esp_hosted_driver_handle;
 801d4d6:	68fb      	ldr	r3, [r7, #12]
}
 801d4d8:	4618      	mov	r0, r3
 801d4da:	3710      	adds	r7, #16
 801d4dc:	46bd      	mov	sp, r7
 801d4de:	bd80      	pop	{r7, pc}
 801d4e0:	08025a6c 	.word	0x08025a6c
 801d4e4:	08025a8c 	.word	0x08025a8c

0801d4e8 <esp_hosted_driver_write>:

int esp_hosted_driver_write (struct esp_hosted_driver_handle_t* esp_hosted_driver_handle,
	uint8_t* buf, int in_count, int* out_count)
{
 801d4e8:	b580      	push	{r7, lr}
 801d4ea:	b086      	sub	sp, #24
 801d4ec:	af00      	add	r7, sp, #0
 801d4ee:	60f8      	str	r0, [r7, #12]
 801d4f0:	60b9      	str	r1, [r7, #8]
 801d4f2:	607a      	str	r2, [r7, #4]
 801d4f4:	603b      	str	r3, [r7, #0]
	int ret = 0;
 801d4f6:	2300      	movs	r3, #0
 801d4f8:	617b      	str	r3, [r7, #20]
	if (!esp_hosted_driver_handle || !buf || !in_count || !out_count) {
 801d4fa:	68fb      	ldr	r3, [r7, #12]
 801d4fc:	2b00      	cmp	r3, #0
 801d4fe:	d008      	beq.n	801d512 <esp_hosted_driver_write+0x2a>
 801d500:	68bb      	ldr	r3, [r7, #8]
 801d502:	2b00      	cmp	r3, #0
 801d504:	d005      	beq.n	801d512 <esp_hosted_driver_write+0x2a>
 801d506:	687b      	ldr	r3, [r7, #4]
 801d508:	2b00      	cmp	r3, #0
 801d50a:	d002      	beq.n	801d512 <esp_hosted_driver_write+0x2a>
 801d50c:	683b      	ldr	r3, [r7, #0]
 801d50e:	2b00      	cmp	r3, #0
 801d510:	d105      	bne.n	801d51e <esp_hosted_driver_write+0x36>
		printf("Invalid parameters in write\n\r");
 801d512:	481d      	ldr	r0, [pc, #116]	; (801d588 <esp_hosted_driver_write+0xa0>)
 801d514:	f002 fe2a 	bl	802016c <iprintf>
		return STM_FAIL;
 801d518:	f04f 33ff 	mov.w	r3, #4294967295
 801d51c:	e02f      	b.n	801d57e <esp_hosted_driver_write+0x96>
	}

	if( (!serial_if_g) ||
 801d51e:	4b1b      	ldr	r3, [pc, #108]	; (801d58c <esp_hosted_driver_write+0xa4>)
 801d520:	681b      	ldr	r3, [r3, #0]
 801d522:	2b00      	cmp	r3, #0
 801d524:	d00a      	beq.n	801d53c <esp_hosted_driver_write+0x54>
		(!serial_if_g->fops) ||
 801d526:	4b19      	ldr	r3, [pc, #100]	; (801d58c <esp_hosted_driver_write+0xa4>)
 801d528:	681b      	ldr	r3, [r3, #0]
 801d52a:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
	if( (!serial_if_g) ||
 801d52c:	2b00      	cmp	r3, #0
 801d52e:	d005      	beq.n	801d53c <esp_hosted_driver_write+0x54>
		(!serial_if_g->fops->write)) {
 801d530:	4b16      	ldr	r3, [pc, #88]	; (801d58c <esp_hosted_driver_write+0xa4>)
 801d532:	681b      	ldr	r3, [r3, #0]
 801d534:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 801d536:	689b      	ldr	r3, [r3, #8]
		(!serial_if_g->fops) ||
 801d538:	2b00      	cmp	r3, #0
 801d53a:	d105      	bne.n	801d548 <esp_hosted_driver_write+0x60>
		printf("serial interface not valid\n\r");
 801d53c:	4814      	ldr	r0, [pc, #80]	; (801d590 <esp_hosted_driver_write+0xa8>)
 801d53e:	f002 fe15 	bl	802016c <iprintf>
		return STM_FAIL;
 801d542:	f04f 33ff 	mov.w	r3, #4294967295
 801d546:	e01a      	b.n	801d57e <esp_hosted_driver_write+0x96>
	}

	ret = serial_if_g->fops->write(serial_if_g, buf, in_count);
 801d548:	4b10      	ldr	r3, [pc, #64]	; (801d58c <esp_hosted_driver_write+0xa4>)
 801d54a:	681b      	ldr	r3, [r3, #0]
 801d54c:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 801d54e:	689b      	ldr	r3, [r3, #8]
 801d550:	4a0e      	ldr	r2, [pc, #56]	; (801d58c <esp_hosted_driver_write+0xa4>)
 801d552:	6810      	ldr	r0, [r2, #0]
 801d554:	687a      	ldr	r2, [r7, #4]
 801d556:	b292      	uxth	r2, r2
 801d558:	68b9      	ldr	r1, [r7, #8]
 801d55a:	4798      	blx	r3
 801d55c:	6178      	str	r0, [r7, #20]
	if (ret != STM_OK) {
 801d55e:	697b      	ldr	r3, [r7, #20]
 801d560:	2b00      	cmp	r3, #0
 801d562:	d008      	beq.n	801d576 <esp_hosted_driver_write+0x8e>
		*out_count = 0;
 801d564:	683b      	ldr	r3, [r7, #0]
 801d566:	2200      	movs	r2, #0
 801d568:	601a      	str	r2, [r3, #0]
		printf("Failed to write data\n\r");
 801d56a:	480a      	ldr	r0, [pc, #40]	; (801d594 <esp_hosted_driver_write+0xac>)
 801d56c:	f002 fdfe 	bl	802016c <iprintf>
		return STM_FAIL;
 801d570:	f04f 33ff 	mov.w	r3, #4294967295
 801d574:	e003      	b.n	801d57e <esp_hosted_driver_write+0x96>
	}

	*out_count = in_count;
 801d576:	683b      	ldr	r3, [r7, #0]
 801d578:	687a      	ldr	r2, [r7, #4]
 801d57a:	601a      	str	r2, [r3, #0]
	return STM_OK;
 801d57c:	2300      	movs	r3, #0
}
 801d57e:	4618      	mov	r0, r3
 801d580:	3718      	adds	r7, #24
 801d582:	46bd      	mov	sp, r7
 801d584:	bd80      	pop	{r7, pc}
 801d586:	bf00      	nop
 801d588:	08025aa8 	.word	0x08025aa8
 801d58c:	24035c08 	.word	0x24035c08
 801d590:	08025ac8 	.word	0x08025ac8
 801d594:	08025ae8 	.word	0x08025ae8

0801d598 <esp_hosted_driver_read>:

uint8_t* esp_hosted_driver_read (struct esp_hosted_driver_handle_t* esp_hosted_driver_handle,
	int read_len, uint8_t wait, uint32_t* buf_len)
{
 801d598:	b580      	push	{r7, lr}
 801d59a:	b08a      	sub	sp, #40	; 0x28
 801d59c:	af00      	add	r7, sp, #0
 801d59e:	60f8      	str	r0, [r7, #12]
 801d5a0:	60b9      	str	r1, [r7, #8]
 801d5a2:	603b      	str	r3, [r7, #0]
 801d5a4:	4613      	mov	r3, r2
 801d5a6:	71fb      	strb	r3, [r7, #7]
	uint16_t rx_buf_len = 0;
 801d5a8:	2300      	movs	r3, #0
 801d5aa:	82fb      	strh	r3, [r7, #22]
	uint8_t* read_buf = NULL;
 801d5ac:	2300      	movs	r3, #0
 801d5ae:	627b      	str	r3, [r7, #36]	; 0x24
	uint8_t* buf = NULL;
 801d5b0:	2300      	movs	r3, #0
 801d5b2:	623b      	str	r3, [r7, #32]
	int len = 0, ret = 0;
 801d5b4:	2300      	movs	r3, #0
 801d5b6:	61fb      	str	r3, [r7, #28]
 801d5b8:	2300      	movs	r3, #0
 801d5ba:	61bb      	str	r3, [r7, #24]

	if (!esp_hosted_driver_handle || !read_len || !buf_len || !wait) {
 801d5bc:	68fb      	ldr	r3, [r7, #12]
 801d5be:	2b00      	cmp	r3, #0
 801d5c0:	d008      	beq.n	801d5d4 <esp_hosted_driver_read+0x3c>
 801d5c2:	68bb      	ldr	r3, [r7, #8]
 801d5c4:	2b00      	cmp	r3, #0
 801d5c6:	d005      	beq.n	801d5d4 <esp_hosted_driver_read+0x3c>
 801d5c8:	683b      	ldr	r3, [r7, #0]
 801d5ca:	2b00      	cmp	r3, #0
 801d5cc:	d002      	beq.n	801d5d4 <esp_hosted_driver_read+0x3c>
 801d5ce:	79fb      	ldrb	r3, [r7, #7]
 801d5d0:	2b00      	cmp	r3, #0
 801d5d2:	d104      	bne.n	801d5de <esp_hosted_driver_read+0x46>
		printf("Invalid parameters in read\n\r");
 801d5d4:	484d      	ldr	r0, [pc, #308]	; (801d70c <esp_hosted_driver_read+0x174>)
 801d5d6:	f002 fdc9 	bl	802016c <iprintf>
		return NULL;
 801d5da:	2300      	movs	r3, #0
 801d5dc:	e091      	b.n	801d702 <esp_hosted_driver_read+0x16a>
	}
	if(readSemaphore.tx_semaphore_id == TX_CLEAR_ID) {
 801d5de:	4b4c      	ldr	r3, [pc, #304]	; (801d710 <esp_hosted_driver_read+0x178>)
 801d5e0:	681b      	ldr	r3, [r3, #0]
 801d5e2:	2b00      	cmp	r3, #0
 801d5e4:	d104      	bne.n	801d5f0 <esp_hosted_driver_read+0x58>
		printf("Semaphore not initialized\n\r");
 801d5e6:	484b      	ldr	r0, [pc, #300]	; (801d714 <esp_hosted_driver_read+0x17c>)
 801d5e8:	f002 fdc0 	bl	802016c <iprintf>
		return NULL;
 801d5ec:	2300      	movs	r3, #0
 801d5ee:	e088      	b.n	801d702 <esp_hosted_driver_read+0x16a>
//	if (tx_semaphore_get(&readSemaphore , MS_TO_TICKS(wait * 1000)) != TX_SUCCESS) {
//		printf("Failed to read data \n\r");
//		return NULL;
//	}

	if( (!serial_if_g) ||
 801d5f0:	4b49      	ldr	r3, [pc, #292]	; (801d718 <esp_hosted_driver_read+0x180>)
 801d5f2:	681b      	ldr	r3, [r3, #0]
 801d5f4:	2b00      	cmp	r3, #0
 801d5f6:	d00a      	beq.n	801d60e <esp_hosted_driver_read+0x76>
		(!serial_if_g->fops) ||
 801d5f8:	4b47      	ldr	r3, [pc, #284]	; (801d718 <esp_hosted_driver_read+0x180>)
 801d5fa:	681b      	ldr	r3, [r3, #0]
 801d5fc:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
	if( (!serial_if_g) ||
 801d5fe:	2b00      	cmp	r3, #0
 801d600:	d005      	beq.n	801d60e <esp_hosted_driver_read+0x76>
		(!serial_if_g->fops->read)) {
 801d602:	4b45      	ldr	r3, [pc, #276]	; (801d718 <esp_hosted_driver_read+0x180>)
 801d604:	681b      	ldr	r3, [r3, #0]
 801d606:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 801d608:	685b      	ldr	r3, [r3, #4]
		(!serial_if_g->fops) ||
 801d60a:	2b00      	cmp	r3, #0
 801d60c:	d104      	bne.n	801d618 <esp_hosted_driver_read+0x80>
		printf("serial interface refusing to read\n\r");
 801d60e:	4843      	ldr	r0, [pc, #268]	; (801d71c <esp_hosted_driver_read+0x184>)
 801d610:	f002 fdac 	bl	802016c <iprintf>
		return NULL;
 801d614:	2300      	movs	r3, #0
 801d616:	e074      	b.n	801d702 <esp_hosted_driver_read+0x16a>
	}

	read_buf = serial_if_g->fops->read(serial_if_g, &rx_buf_len);
 801d618:	4b3f      	ldr	r3, [pc, #252]	; (801d718 <esp_hosted_driver_read+0x180>)
 801d61a:	681b      	ldr	r3, [r3, #0]
 801d61c:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 801d61e:	685b      	ldr	r3, [r3, #4]
 801d620:	4a3d      	ldr	r2, [pc, #244]	; (801d718 <esp_hosted_driver_read+0x180>)
 801d622:	6812      	ldr	r2, [r2, #0]
 801d624:	f107 0116 	add.w	r1, r7, #22
 801d628:	4610      	mov	r0, r2
 801d62a:	4798      	blx	r3
 801d62c:	6278      	str	r0, [r7, #36]	; 0x24
	if ((! read_buf) || (!rx_buf_len)) {
 801d62e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801d630:	2b00      	cmp	r3, #0
 801d632:	d002      	beq.n	801d63a <esp_hosted_driver_read+0xa2>
 801d634:	8afb      	ldrh	r3, [r7, #22]
 801d636:	2b00      	cmp	r3, #0
 801d638:	d104      	bne.n	801d644 <esp_hosted_driver_read+0xac>
		printf("serial read failed\n\r");
 801d63a:	4839      	ldr	r0, [pc, #228]	; (801d720 <esp_hosted_driver_read+0x188>)
 801d63c:	f002 fd96 	bl	802016c <iprintf>
		return NULL;
 801d640:	2300      	movs	r3, #0
 801d642:	e05e      	b.n	801d702 <esp_hosted_driver_read+0x16a>
	}
	print_hex_dump(read_buf, rx_buf_len, "Serial read data");
 801d644:	8afb      	ldrh	r3, [r7, #22]
 801d646:	4a37      	ldr	r2, [pc, #220]	; (801d724 <esp_hosted_driver_read+0x18c>)
 801d648:	4619      	mov	r1, r3
 801d64a:	6a78      	ldr	r0, [r7, #36]	; 0x24
 801d64c:	f000 fb34 	bl	801dcb8 <print_hex_dump>
 *  ---------------------------------------------------------------------------
 *
 *  read_len = 1 + 2 + Endpoint length + 1 + 2
 */

	len = min(rx_buf_len,read_len);
 801d650:	8afb      	ldrh	r3, [r7, #22]
 801d652:	68b9      	ldr	r1, [r7, #8]
 801d654:	4618      	mov	r0, r3
 801d656:	f000 fb3c 	bl	801dcd2 <min>
 801d65a:	61f8      	str	r0, [r7, #28]
	buf = (uint8_t* )esp_hosted_calloc(1, len);
 801d65c:	69fb      	ldr	r3, [r7, #28]
 801d65e:	4619      	mov	r1, r3
 801d660:	2001      	movs	r0, #1
 801d662:	f7ff fef9 	bl	801d458 <esp_hosted_calloc>
 801d666:	6238      	str	r0, [r7, #32]
	if (!buf) {
 801d668:	6a3b      	ldr	r3, [r7, #32]
 801d66a:	2b00      	cmp	r3, #0
 801d66c:	d103      	bne.n	801d676 <esp_hosted_driver_read+0xde>
		printf("Failed to allocate memory \n\r");
 801d66e:	482e      	ldr	r0, [pc, #184]	; (801d728 <esp_hosted_driver_read+0x190>)
 801d670:	f002 fd7c 	bl	802016c <iprintf>
		goto err;
 801d674:	e03e      	b.n	801d6f4 <esp_hosted_driver_read+0x15c>
	}

	memset(buf, 0, read_len);
 801d676:	68bb      	ldr	r3, [r7, #8]
 801d678:	461a      	mov	r2, r3
 801d67a:	2100      	movs	r1, #0
 801d67c:	6a38      	ldr	r0, [r7, #32]
 801d67e:	f002 f8fd 	bl	801f87c <memset>
	memcpy(buf, read_buf, len);
 801d682:	69fb      	ldr	r3, [r7, #28]
 801d684:	461a      	mov	r2, r3
 801d686:	6a79      	ldr	r1, [r7, #36]	; 0x24
 801d688:	6a38      	ldr	r0, [r7, #32]
 801d68a:	f002 f8cf 	bl	801f82c <memcpy>

 /* parse_tlv function returns variable payload length of received data in buf_len */
	ret = parse_tlv(buf, buf_len);
 801d68e:	6839      	ldr	r1, [r7, #0]
 801d690:	6a38      	ldr	r0, [r7, #32]
 801d692:	f7fe fdc5 	bl	801c220 <parse_tlv>
 801d696:	4603      	mov	r3, r0
 801d698:	61bb      	str	r3, [r7, #24]
	if (ret != STM_OK) {
 801d69a:	69bb      	ldr	r3, [r7, #24]
 801d69c:	2b00      	cmp	r3, #0
 801d69e:	d006      	beq.n	801d6ae <esp_hosted_driver_read+0x116>
		esp_hosted_free(buf);
 801d6a0:	6a38      	ldr	r0, [r7, #32]
 801d6a2:	f7ff fef1 	bl	801d488 <esp_hosted_free>
		printf("Failed to parse RX data \n\r");
 801d6a6:	4821      	ldr	r0, [pc, #132]	; (801d72c <esp_hosted_driver_read+0x194>)
 801d6a8:	f002 fd60 	bl	802016c <iprintf>
		goto err;
 801d6ac:	e022      	b.n	801d6f4 <esp_hosted_driver_read+0x15c>
	}

	esp_hosted_free(buf);
 801d6ae:	6a38      	ldr	r0, [r7, #32]
 801d6b0:	f7ff feea 	bl	801d488 <esp_hosted_free>

	buf = NULL;
 801d6b4:	2300      	movs	r3, #0
 801d6b6:	623b      	str	r3, [r7, #32]
/*
 * 2) Read variable length of RX data:
 */
	buf = (uint8_t* )esp_hosted_calloc(1, *buf_len);
 801d6b8:	683b      	ldr	r3, [r7, #0]
 801d6ba:	681b      	ldr	r3, [r3, #0]
 801d6bc:	4619      	mov	r1, r3
 801d6be:	2001      	movs	r0, #1
 801d6c0:	f7ff feca 	bl	801d458 <esp_hosted_calloc>
 801d6c4:	6238      	str	r0, [r7, #32]
	if (!buf) {
 801d6c6:	6a3b      	ldr	r3, [r7, #32]
 801d6c8:	2b00      	cmp	r3, #0
 801d6ca:	d103      	bne.n	801d6d4 <esp_hosted_driver_read+0x13c>
		printf("Failed to allocate memory \n\r");
 801d6cc:	4816      	ldr	r0, [pc, #88]	; (801d728 <esp_hosted_driver_read+0x190>)
 801d6ce:	f002 fd4d 	bl	802016c <iprintf>
		goto err;
 801d6d2:	e00f      	b.n	801d6f4 <esp_hosted_driver_read+0x15c>
	}

	memcpy((buf), read_buf+read_len, *buf_len);
 801d6d4:	68bb      	ldr	r3, [r7, #8]
 801d6d6:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 801d6d8:	18d1      	adds	r1, r2, r3
 801d6da:	683b      	ldr	r3, [r7, #0]
 801d6dc:	681b      	ldr	r3, [r3, #0]
 801d6de:	461a      	mov	r2, r3
 801d6e0:	6a38      	ldr	r0, [r7, #32]
 801d6e2:	f002 f8a3 	bl	801f82c <memcpy>

	esp_hosted_free(read_buf);
 801d6e6:	6a78      	ldr	r0, [r7, #36]	; 0x24
 801d6e8:	f7ff fece 	bl	801d488 <esp_hosted_free>
	read_buf = NULL;
 801d6ec:	2300      	movs	r3, #0
 801d6ee:	627b      	str	r3, [r7, #36]	; 0x24
	return buf;
 801d6f0:	6a3b      	ldr	r3, [r7, #32]
 801d6f2:	e006      	b.n	801d702 <esp_hosted_driver_read+0x16a>
err:
	if (read_buf) {
 801d6f4:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801d6f6:	2b00      	cmp	r3, #0
 801d6f8:	d002      	beq.n	801d700 <esp_hosted_driver_read+0x168>
		esp_hosted_free(read_buf);
 801d6fa:	6a78      	ldr	r0, [r7, #36]	; 0x24
 801d6fc:	f7ff fec4 	bl	801d488 <esp_hosted_free>
	}
	return NULL;
 801d700:	2300      	movs	r3, #0
}
 801d702:	4618      	mov	r0, r3
 801d704:	3728      	adds	r7, #40	; 0x28
 801d706:	46bd      	mov	sp, r7
 801d708:	bd80      	pop	{r7, pc}
 801d70a:	bf00      	nop
 801d70c:	08025b00 	.word	0x08025b00
 801d710:	24035bec 	.word	0x24035bec
 801d714:	08025b20 	.word	0x08025b20
 801d718:	24035c08 	.word	0x24035c08
 801d71c:	08025b3c 	.word	0x08025b3c
 801d720:	08025b60 	.word	0x08025b60
 801d724:	08025b78 	.word	0x08025b78
 801d728:	08025b8c 	.word	0x08025b8c
 801d72c:	08025bac 	.word	0x08025bac

0801d730 <esp_hosted_driver_close>:

int esp_hosted_driver_close(struct esp_hosted_driver_handle_t** esp_hosted_driver_handle)
{
 801d730:	b580      	push	{r7, lr}
 801d732:	b082      	sub	sp, #8
 801d734:	af00      	add	r7, sp, #0
 801d736:	6078      	str	r0, [r7, #4]
	if (!esp_hosted_driver_handle || !(*esp_hosted_driver_handle)) {
 801d738:	687b      	ldr	r3, [r7, #4]
 801d73a:	2b00      	cmp	r3, #0
 801d73c:	d003      	beq.n	801d746 <esp_hosted_driver_close+0x16>
 801d73e:	687b      	ldr	r3, [r7, #4]
 801d740:	681b      	ldr	r3, [r3, #0]
 801d742:	2b00      	cmp	r3, #0
 801d744:	d102      	bne.n	801d74c <esp_hosted_driver_close+0x1c>
		printf("Invalid parameter in close \n\r");
 801d746:	4806      	ldr	r0, [pc, #24]	; (801d760 <esp_hosted_driver_close+0x30>)
 801d748:	f002 fd10 	bl	802016c <iprintf>
	}
	esp_hosted_free(*esp_hosted_driver_handle);
 801d74c:	687b      	ldr	r3, [r7, #4]
 801d74e:	681b      	ldr	r3, [r3, #0]
 801d750:	4618      	mov	r0, r3
 801d752:	f7ff fe99 	bl	801d488 <esp_hosted_free>
	return STM_OK;
 801d756:	2300      	movs	r3, #0
}
 801d758:	4618      	mov	r0, r3
 801d75a:	3708      	adds	r7, #8
 801d75c:	46bd      	mov	sp, r7
 801d75e:	bd80      	pop	{r7, pc}
 801d760:	08025bc8 	.word	0x08025bc8

0801d764 <arping_set_ipaddr>:
  *         type - src/dest type of ip addr
  *         ip   - ip addr to set
  * @retval None
  */
static void arping_set_ipaddr(uint8_t *stream, ie_type_e type, uint32_t ip)
{
 801d764:	b580      	push	{r7, lr}
 801d766:	b086      	sub	sp, #24
 801d768:	af00      	add	r7, sp, #0
 801d76a:	60f8      	str	r0, [r7, #12]
 801d76c:	460b      	mov	r3, r1
 801d76e:	607a      	str	r2, [r7, #4]
 801d770:	72fb      	strb	r3, [r7, #11]
	uint32_t ip_nw = hton_long(ip);
 801d772:	6878      	ldr	r0, [r7, #4]
 801d774:	f000 fa7f 	bl	801dc76 <hton_long>
 801d778:	4603      	mov	r3, r0
 801d77a:	617b      	str	r3, [r7, #20]
	if (type == IP_ADDR_TYPE_SRC ) {
 801d77c:	7afb      	ldrb	r3, [r7, #11]
 801d77e:	2bcc      	cmp	r3, #204	; 0xcc
 801d780:	d107      	bne.n	801d792 <arping_set_ipaddr+0x2e>
		stream_set(stream, &ip_nw, ARPING_OFFSET_SRC_IP, IP_ADDR_LEN);
 801d782:	f107 0114 	add.w	r1, r7, #20
 801d786:	2304      	movs	r3, #4
 801d788:	221c      	movs	r2, #28
 801d78a:	68f8      	ldr	r0, [r7, #12]
 801d78c:	f7ff f8aa 	bl	801c8e4 <stream_set>
	} else if (type == IP_ADDR_TYPE_DST ) {
		stream_set(stream, &ip_nw, ARPING_OFFSET_DST_IP, IP_ADDR_LEN);
	} else {
		printf("Address type be either src/dst\n");
	}
}
 801d790:	e00d      	b.n	801d7ae <arping_set_ipaddr+0x4a>
	} else if (type == IP_ADDR_TYPE_DST ) {
 801d792:	7afb      	ldrb	r3, [r7, #11]
 801d794:	2bcd      	cmp	r3, #205	; 0xcd
 801d796:	d107      	bne.n	801d7a8 <arping_set_ipaddr+0x44>
		stream_set(stream, &ip_nw, ARPING_OFFSET_DST_IP, IP_ADDR_LEN);
 801d798:	f107 0114 	add.w	r1, r7, #20
 801d79c:	2304      	movs	r3, #4
 801d79e:	2226      	movs	r2, #38	; 0x26
 801d7a0:	68f8      	ldr	r0, [r7, #12]
 801d7a2:	f7ff f89f 	bl	801c8e4 <stream_set>
}
 801d7a6:	e002      	b.n	801d7ae <arping_set_ipaddr+0x4a>
		printf("Address type be either src/dst\n");
 801d7a8:	4803      	ldr	r0, [pc, #12]	; (801d7b8 <arping_set_ipaddr+0x54>)
 801d7aa:	f002 fd7b 	bl	80202a4 <puts>
}
 801d7ae:	bf00      	nop
 801d7b0:	3718      	adds	r7, #24
 801d7b2:	46bd      	mov	sp, r7
 801d7b4:	bd80      	pop	{r7, pc}
 801d7b6:	bf00      	nop
 801d7b8:	08025be8 	.word	0x08025be8

0801d7bc <arping_get_ipaddr>:
  * @param  stream - input buffer
  *         type - src/dest type of ip addr
  * @retval ip addr in 32 bits
  */
static uint32_t arping_get_ipaddr(uint8_t *stream, ie_type_e type)
{
 801d7bc:	b580      	push	{r7, lr}
 801d7be:	b084      	sub	sp, #16
 801d7c0:	af00      	add	r7, sp, #0
 801d7c2:	6078      	str	r0, [r7, #4]
 801d7c4:	460b      	mov	r3, r1
 801d7c6:	70fb      	strb	r3, [r7, #3]
	uint32_t ip_nw;
	if (type == IP_ADDR_TYPE_SRC ) {
 801d7c8:	78fb      	ldrb	r3, [r7, #3]
 801d7ca:	2bcc      	cmp	r3, #204	; 0xcc
 801d7cc:	d108      	bne.n	801d7e0 <arping_get_ipaddr+0x24>
		ip_nw = *(uint32_t*) stream_get(stream,
 801d7ce:	2204      	movs	r2, #4
 801d7d0:	211c      	movs	r1, #28
 801d7d2:	6878      	ldr	r0, [r7, #4]
 801d7d4:	f7ff f8b0 	bl	801c938 <stream_get>
 801d7d8:	4603      	mov	r3, r0
 801d7da:	681b      	ldr	r3, [r3, #0]
 801d7dc:	60fb      	str	r3, [r7, #12]
 801d7de:	e00e      	b.n	801d7fe <arping_get_ipaddr+0x42>
				ARPING_OFFSET_SRC_IP, IP_ADDR_LEN);
	} else if (type == IP_ADDR_TYPE_DST ) {
 801d7e0:	78fb      	ldrb	r3, [r7, #3]
 801d7e2:	2bcd      	cmp	r3, #205	; 0xcd
 801d7e4:	d108      	bne.n	801d7f8 <arping_get_ipaddr+0x3c>
		ip_nw = *(uint32_t*) stream_get(stream,
 801d7e6:	2204      	movs	r2, #4
 801d7e8:	2126      	movs	r1, #38	; 0x26
 801d7ea:	6878      	ldr	r0, [r7, #4]
 801d7ec:	f7ff f8a4 	bl	801c938 <stream_get>
 801d7f0:	4603      	mov	r3, r0
 801d7f2:	681b      	ldr	r3, [r3, #0]
 801d7f4:	60fb      	str	r3, [r7, #12]
 801d7f6:	e002      	b.n	801d7fe <arping_get_ipaddr+0x42>
				ARPING_OFFSET_DST_IP, IP_ADDR_LEN);
	} else {
		printf("Address type be either src/dst\n");
 801d7f8:	4805      	ldr	r0, [pc, #20]	; (801d810 <arping_get_ipaddr+0x54>)
 801d7fa:	f002 fd53 	bl	80202a4 <puts>
	}
	return ntoh_long(ip_nw);
 801d7fe:	68f8      	ldr	r0, [r7, #12]
 801d800:	f000 fa39 	bl	801dc76 <hton_long>
 801d804:	4603      	mov	r3, r0
}
 801d806:	4618      	mov	r0, r3
 801d808:	3710      	adds	r7, #16
 801d80a:	46bd      	mov	sp, r7
 801d80c:	bd80      	pop	{r7, pc}
 801d80e:	bf00      	nop
 801d810:	08025be8 	.word	0x08025be8

0801d814 <arping_set_mac>:
  *         type - src/dest type of ip addr
  *         mac - input mac addr
  * @retval None
  */
static void arping_set_mac(uint8_t *stream, ie_type_e type, const uint8_t *mac)
{
 801d814:	b580      	push	{r7, lr}
 801d816:	b084      	sub	sp, #16
 801d818:	af00      	add	r7, sp, #0
 801d81a:	60f8      	str	r0, [r7, #12]
 801d81c:	460b      	mov	r3, r1
 801d81e:	607a      	str	r2, [r7, #4]
 801d820:	72fb      	strb	r3, [r7, #11]
	if (type == MAC_ADDR_TYPE_SRC) {
 801d822:	7afb      	ldrb	r3, [r7, #11]
 801d824:	2bc8      	cmp	r3, #200	; 0xc8
 801d826:	d106      	bne.n	801d836 <arping_set_mac+0x22>
		stream_set(stream, mac, ARPING_OFFSET_SRC_MAC, MAC_LEN);
 801d828:	2306      	movs	r3, #6
 801d82a:	2206      	movs	r2, #6
 801d82c:	6879      	ldr	r1, [r7, #4]
 801d82e:	68f8      	ldr	r0, [r7, #12]
 801d830:	f7ff f858 	bl	801c8e4 <stream_set>
	} else if (type == MAC_ADDR_TYPE_DST_REPEAT) {
		stream_set(stream, mac, ARPING_OFFSET_DST_REPEAT_MAC, MAC_LEN);
	} else {
		printf("mac type be either src/dst/repeatSrc\n");
	}
}
 801d834:	e020      	b.n	801d878 <arping_set_mac+0x64>
	} else if (type == MAC_ADDR_TYPE_DST) {
 801d836:	7afb      	ldrb	r3, [r7, #11]
 801d838:	2bca      	cmp	r3, #202	; 0xca
 801d83a:	d106      	bne.n	801d84a <arping_set_mac+0x36>
		stream_set(stream, mac, ARPING_OFFSET_DST_MAC, MAC_LEN);
 801d83c:	2306      	movs	r3, #6
 801d83e:	2200      	movs	r2, #0
 801d840:	6879      	ldr	r1, [r7, #4]
 801d842:	68f8      	ldr	r0, [r7, #12]
 801d844:	f7ff f84e 	bl	801c8e4 <stream_set>
}
 801d848:	e016      	b.n	801d878 <arping_set_mac+0x64>
	} else if (type == MAC_ADDR_TYPE_SRC_REPEAT) {
 801d84a:	7afb      	ldrb	r3, [r7, #11]
 801d84c:	2bc9      	cmp	r3, #201	; 0xc9
 801d84e:	d106      	bne.n	801d85e <arping_set_mac+0x4a>
		stream_set(stream, mac, ARPING_OFFSET_SRC_REPEAT_MAC, MAC_LEN);
 801d850:	2306      	movs	r3, #6
 801d852:	2216      	movs	r2, #22
 801d854:	6879      	ldr	r1, [r7, #4]
 801d856:	68f8      	ldr	r0, [r7, #12]
 801d858:	f7ff f844 	bl	801c8e4 <stream_set>
}
 801d85c:	e00c      	b.n	801d878 <arping_set_mac+0x64>
	} else if (type == MAC_ADDR_TYPE_DST_REPEAT) {
 801d85e:	7afb      	ldrb	r3, [r7, #11]
 801d860:	2bcb      	cmp	r3, #203	; 0xcb
 801d862:	d106      	bne.n	801d872 <arping_set_mac+0x5e>
		stream_set(stream, mac, ARPING_OFFSET_DST_REPEAT_MAC, MAC_LEN);
 801d864:	2306      	movs	r3, #6
 801d866:	2220      	movs	r2, #32
 801d868:	6879      	ldr	r1, [r7, #4]
 801d86a:	68f8      	ldr	r0, [r7, #12]
 801d86c:	f7ff f83a 	bl	801c8e4 <stream_set>
}
 801d870:	e002      	b.n	801d878 <arping_set_mac+0x64>
		printf("mac type be either src/dst/repeatSrc\n");
 801d872:	4803      	ldr	r0, [pc, #12]	; (801d880 <arping_set_mac+0x6c>)
 801d874:	f002 fd16 	bl	80202a4 <puts>
}
 801d878:	bf00      	nop
 801d87a:	3710      	adds	r7, #16
 801d87c:	46bd      	mov	sp, r7
 801d87e:	bd80      	pop	{r7, pc}
 801d880:	08025c08 	.word	0x08025c08

0801d884 <arping_get_mac>:
  * @param  stream - input buffer
  *         type - src/dest type of ip addr
  * @retval output mac addr ptr
  */
static uint8_t * arping_get_mac(uint8_t *stream, ie_type_e type)
{
 801d884:	b580      	push	{r7, lr}
 801d886:	b084      	sub	sp, #16
 801d888:	af00      	add	r7, sp, #0
 801d88a:	6078      	str	r0, [r7, #4]
 801d88c:	460b      	mov	r3, r1
 801d88e:	70fb      	strb	r3, [r7, #3]
	uint8_t * mac= 0;
 801d890:	2300      	movs	r3, #0
 801d892:	60fb      	str	r3, [r7, #12]

	if (type == MAC_ADDR_TYPE_SRC) {
 801d894:	78fb      	ldrb	r3, [r7, #3]
 801d896:	2bc8      	cmp	r3, #200	; 0xc8
 801d898:	d106      	bne.n	801d8a8 <arping_get_mac+0x24>
		mac = stream_get(stream, ARPING_OFFSET_SRC_MAC, MAC_LEN);
 801d89a:	2206      	movs	r2, #6
 801d89c:	2106      	movs	r1, #6
 801d89e:	6878      	ldr	r0, [r7, #4]
 801d8a0:	f7ff f84a 	bl	801c938 <stream_get>
 801d8a4:	60f8      	str	r0, [r7, #12]
 801d8a6:	e020      	b.n	801d8ea <arping_get_mac+0x66>
	} else if (type == MAC_ADDR_TYPE_DST) {
 801d8a8:	78fb      	ldrb	r3, [r7, #3]
 801d8aa:	2bca      	cmp	r3, #202	; 0xca
 801d8ac:	d106      	bne.n	801d8bc <arping_get_mac+0x38>
		mac = stream_get(stream, ARPING_OFFSET_DST_MAC, MAC_LEN);
 801d8ae:	2206      	movs	r2, #6
 801d8b0:	2100      	movs	r1, #0
 801d8b2:	6878      	ldr	r0, [r7, #4]
 801d8b4:	f7ff f840 	bl	801c938 <stream_get>
 801d8b8:	60f8      	str	r0, [r7, #12]
 801d8ba:	e016      	b.n	801d8ea <arping_get_mac+0x66>
	} else if (type == MAC_ADDR_TYPE_SRC_REPEAT) {
 801d8bc:	78fb      	ldrb	r3, [r7, #3]
 801d8be:	2bc9      	cmp	r3, #201	; 0xc9
 801d8c0:	d106      	bne.n	801d8d0 <arping_get_mac+0x4c>
		mac = stream_get(stream, ARPING_OFFSET_SRC_REPEAT_MAC, MAC_LEN);
 801d8c2:	2206      	movs	r2, #6
 801d8c4:	2116      	movs	r1, #22
 801d8c6:	6878      	ldr	r0, [r7, #4]
 801d8c8:	f7ff f836 	bl	801c938 <stream_get>
 801d8cc:	60f8      	str	r0, [r7, #12]
 801d8ce:	e00c      	b.n	801d8ea <arping_get_mac+0x66>
	} else if (type == MAC_ADDR_TYPE_DST_REPEAT) {
 801d8d0:	78fb      	ldrb	r3, [r7, #3]
 801d8d2:	2bcb      	cmp	r3, #203	; 0xcb
 801d8d4:	d106      	bne.n	801d8e4 <arping_get_mac+0x60>
		mac = stream_get(stream, ARPING_OFFSET_DST_REPEAT_MAC, MAC_LEN);
 801d8d6:	2206      	movs	r2, #6
 801d8d8:	2120      	movs	r1, #32
 801d8da:	6878      	ldr	r0, [r7, #4]
 801d8dc:	f7ff f82c 	bl	801c938 <stream_get>
 801d8e0:	60f8      	str	r0, [r7, #12]
 801d8e2:	e002      	b.n	801d8ea <arping_get_mac+0x66>
	} else {
		printf("mac type be either src/dst/srcRepeat\n");
 801d8e4:	4803      	ldr	r0, [pc, #12]	; (801d8f4 <arping_get_mac+0x70>)
 801d8e6:	f002 fcdd 	bl	80202a4 <puts>
	}
	return mac;
 801d8ea:	68fb      	ldr	r3, [r7, #12]
}
 801d8ec:	4618      	mov	r0, r3
 801d8ee:	3710      	adds	r7, #16
 801d8f0:	46bd      	mov	sp, r7
 801d8f2:	bd80      	pop	{r7, pc}
 801d8f4:	08025c30 	.word	0x08025c30

0801d8f8 <arping_set_opcode>:
  * @param  stream - input buffer
  *         opcode - request/reply type
  * @retval None
  */
static void arping_set_opcode(uint8_t *stream, const uint16_t opcode)
{
 801d8f8:	b580      	push	{r7, lr}
 801d8fa:	b084      	sub	sp, #16
 801d8fc:	af00      	add	r7, sp, #0
 801d8fe:	6078      	str	r0, [r7, #4]
 801d900:	460b      	mov	r3, r1
 801d902:	807b      	strh	r3, [r7, #2]
	uint16_t opcode_nw = hton_short(opcode);
 801d904:	887b      	ldrh	r3, [r7, #2]
 801d906:	4618      	mov	r0, r3
 801d908:	f000 f99e 	bl	801dc48 <hton_short>
 801d90c:	4603      	mov	r3, r0
 801d90e:	81fb      	strh	r3, [r7, #14]
	stream_set(stream, &opcode_nw, ARPING_OFFSET_OPCODE, OPCODE_LEN);
 801d910:	f107 010e 	add.w	r1, r7, #14
 801d914:	2302      	movs	r3, #2
 801d916:	2214      	movs	r2, #20
 801d918:	6878      	ldr	r0, [r7, #4]
 801d91a:	f7fe ffe3 	bl	801c8e4 <stream_set>
}
 801d91e:	bf00      	nop
 801d920:	3710      	adds	r7, #16
 801d922:	46bd      	mov	sp, r7
 801d924:	bd80      	pop	{r7, pc}

0801d926 <arping_get_opcode>:
  * @brief  Get opcode
  * @param  stream - input buffer
  * @retval opcode - request/reply type
  */
static uint16_t arping_get_opcode(uint8_t *stream)
{
 801d926:	b580      	push	{r7, lr}
 801d928:	b084      	sub	sp, #16
 801d92a:	af00      	add	r7, sp, #0
 801d92c:	6078      	str	r0, [r7, #4]
	uint16_t opcode_nw = 0;
 801d92e:	2300      	movs	r3, #0
 801d930:	81fb      	strh	r3, [r7, #14]
	opcode_nw = *(uint16_t*)stream_get(stream,
 801d932:	2202      	movs	r2, #2
 801d934:	2114      	movs	r1, #20
 801d936:	6878      	ldr	r0, [r7, #4]
 801d938:	f7fe fffe 	bl	801c938 <stream_get>
 801d93c:	4603      	mov	r3, r0
 801d93e:	881b      	ldrh	r3, [r3, #0]
 801d940:	81fb      	strh	r3, [r7, #14]
			ARPING_OFFSET_OPCODE, OPCODE_LEN);
	return (ntoh_short(opcode_nw));
 801d942:	89fb      	ldrh	r3, [r7, #14]
 801d944:	4618      	mov	r0, r3
 801d946:	f000 f97f 	bl	801dc48 <hton_short>
 801d94a:	4603      	mov	r3, r0
}
 801d94c:	4618      	mov	r0, r3
 801d94e:	3710      	adds	r7, #16
 801d950:	46bd      	mov	sp, r7
 801d952:	bd80      	pop	{r7, pc}

0801d954 <arping_get_protocol>:
  * @brief  Get protocol
  * @param  stream - input buffer
  * @retval protocol field
  */
static uint16_t arping_get_protocol(uint8_t *stream)
{
 801d954:	b580      	push	{r7, lr}
 801d956:	b084      	sub	sp, #16
 801d958:	af00      	add	r7, sp, #0
 801d95a:	6078      	str	r0, [r7, #4]
	uint16_t prot_nw = 0;
 801d95c:	2300      	movs	r3, #0
 801d95e:	81fb      	strh	r3, [r7, #14]
	prot_nw = *(uint16_t*)stream_get(stream,
 801d960:	2202      	movs	r2, #2
 801d962:	210c      	movs	r1, #12
 801d964:	6878      	ldr	r0, [r7, #4]
 801d966:	f7fe ffe7 	bl	801c938 <stream_get>
 801d96a:	4603      	mov	r3, r0
 801d96c:	881b      	ldrh	r3, [r3, #0]
 801d96e:	81fb      	strh	r3, [r7, #14]
			ARPING_OFFSET_PROTOCOL, PROTOCOL_LEN_ARP);
	return (ntoh_short(prot_nw));
 801d970:	89fb      	ldrh	r3, [r7, #14]
 801d972:	4618      	mov	r0, r3
 801d974:	f000 f968 	bl	801dc48 <hton_short>
 801d978:	4603      	mov	r3, r0
}
 801d97a:	4618      	mov	r0, r3
 801d97c:	3710      	adds	r7, #16
 801d97e:	46bd      	mov	sp, r7
 801d980:	bd80      	pop	{r7, pc}
	...

0801d984 <arping_swap_ip_addresses>:
  * @brief  Change ip addresses of src and dest
  * @param  stream - input/output buffer
  * @retval none
  */
static void arping_swap_ip_addresses(uint8_t * stream)
{
 801d984:	b580      	push	{r7, lr}
 801d986:	b084      	sub	sp, #16
 801d988:	af00      	add	r7, sp, #0
 801d98a:	6078      	str	r0, [r7, #4]
	uint32_t in_src_ip = 0;
 801d98c:	2300      	movs	r3, #0
 801d98e:	60fb      	str	r3, [r7, #12]
	uint32_t in_dst_ip = 0;
 801d990:	2300      	movs	r3, #0
 801d992:	60bb      	str	r3, [r7, #8]
	if (! stream)
 801d994:	687b      	ldr	r3, [r7, #4]
 801d996:	2b00      	cmp	r3, #0
 801d998:	d103      	bne.n	801d9a2 <arping_swap_ip_addresses+0x1e>
	{
		printf("stream NULL passed\n\r");
 801d99a:	480d      	ldr	r0, [pc, #52]	; (801d9d0 <arping_swap_ip_addresses+0x4c>)
 801d99c:	f002 fbe6 	bl	802016c <iprintf>
		return;
 801d9a0:	e013      	b.n	801d9ca <arping_swap_ip_addresses+0x46>
	}

	in_src_ip = arping_get_ipaddr(stream, IP_ADDR_TYPE_SRC);
 801d9a2:	21cc      	movs	r1, #204	; 0xcc
 801d9a4:	6878      	ldr	r0, [r7, #4]
 801d9a6:	f7ff ff09 	bl	801d7bc <arping_get_ipaddr>
 801d9aa:	60f8      	str	r0, [r7, #12]
	in_dst_ip = arping_get_ipaddr(stream, IP_ADDR_TYPE_DST);
 801d9ac:	21cd      	movs	r1, #205	; 0xcd
 801d9ae:	6878      	ldr	r0, [r7, #4]
 801d9b0:	f7ff ff04 	bl	801d7bc <arping_get_ipaddr>
 801d9b4:	60b8      	str	r0, [r7, #8]

	arping_set_ipaddr(stream, IP_ADDR_TYPE_DST, in_src_ip);
 801d9b6:	68fa      	ldr	r2, [r7, #12]
 801d9b8:	21cd      	movs	r1, #205	; 0xcd
 801d9ba:	6878      	ldr	r0, [r7, #4]
 801d9bc:	f7ff fed2 	bl	801d764 <arping_set_ipaddr>
	arping_set_ipaddr(stream, IP_ADDR_TYPE_SRC, in_dst_ip);
 801d9c0:	68ba      	ldr	r2, [r7, #8]
 801d9c2:	21cc      	movs	r1, #204	; 0xcc
 801d9c4:	6878      	ldr	r0, [r7, #4]
 801d9c6:	f7ff fecd 	bl	801d764 <arping_set_ipaddr>
}
 801d9ca:	3710      	adds	r7, #16
 801d9cc:	46bd      	mov	sp, r7
 801d9ce:	bd80      	pop	{r7, pc}
 801d9d0:	08025c58 	.word	0x08025c58

0801d9d4 <arping_change_mac_addresses>:
  *         self_mac - source mac
  * @retval none
  */
static void arping_change_mac_addresses(uint8_t * stream,
		const uint8_t *self_mac)
{
 801d9d4:	b580      	push	{r7, lr}
 801d9d6:	b084      	sub	sp, #16
 801d9d8:	af00      	add	r7, sp, #0
 801d9da:	6078      	str	r0, [r7, #4]
 801d9dc:	6039      	str	r1, [r7, #0]
	uint8_t * rsp_mac = NULL;
 801d9de:	2300      	movs	r3, #0
 801d9e0:	60fb      	str	r3, [r7, #12]

	if (! stream)
 801d9e2:	687b      	ldr	r3, [r7, #4]
 801d9e4:	2b00      	cmp	r3, #0
 801d9e6:	d103      	bne.n	801d9f0 <arping_change_mac_addresses+0x1c>
	{
		printf("stream NULL passed\n\r");
 801d9e8:	480f      	ldr	r0, [pc, #60]	; (801da28 <arping_change_mac_addresses+0x54>)
 801d9ea:	f002 fbbf 	bl	802016c <iprintf>
		return;
 801d9ee:	e018      	b.n	801da22 <arping_change_mac_addresses+0x4e>
	}

	rsp_mac = arping_get_mac(stream, MAC_ADDR_TYPE_SRC);
 801d9f0:	21c8      	movs	r1, #200	; 0xc8
 801d9f2:	6878      	ldr	r0, [r7, #4]
 801d9f4:	f7ff ff46 	bl	801d884 <arping_get_mac>
 801d9f8:	60f8      	str	r0, [r7, #12]

	arping_set_mac(stream, MAC_ADDR_TYPE_DST, rsp_mac);
 801d9fa:	68fa      	ldr	r2, [r7, #12]
 801d9fc:	21ca      	movs	r1, #202	; 0xca
 801d9fe:	6878      	ldr	r0, [r7, #4]
 801da00:	f7ff ff08 	bl	801d814 <arping_set_mac>
	arping_set_mac(stream, MAC_ADDR_TYPE_DST_REPEAT, rsp_mac);
 801da04:	68fa      	ldr	r2, [r7, #12]
 801da06:	21cb      	movs	r1, #203	; 0xcb
 801da08:	6878      	ldr	r0, [r7, #4]
 801da0a:	f7ff ff03 	bl	801d814 <arping_set_mac>
	arping_set_mac(stream, MAC_ADDR_TYPE_SRC, self_mac);
 801da0e:	683a      	ldr	r2, [r7, #0]
 801da10:	21c8      	movs	r1, #200	; 0xc8
 801da12:	6878      	ldr	r0, [r7, #4]
 801da14:	f7ff fefe 	bl	801d814 <arping_set_mac>
	arping_set_mac(stream, MAC_ADDR_TYPE_SRC_REPEAT, self_mac);
 801da18:	683a      	ldr	r2, [r7, #0]
 801da1a:	21c9      	movs	r1, #201	; 0xc9
 801da1c:	6878      	ldr	r0, [r7, #4]
 801da1e:	f7ff fef9 	bl	801d814 <arping_set_mac>
}
 801da22:	3710      	adds	r7, #16
 801da24:	46bd      	mov	sp, r7
 801da26:	bd80      	pop	{r7, pc}
 801da28:	08025c58 	.word	0x08025c58

0801da2c <is_arp_packet>:
  * @brief  check if arp type of protocol
  * @param  pkt - input buffer
  * @retval true/false
  */
static uint8_t is_arp_packet(uint8_t *pkt)
{
 801da2c:	b580      	push	{r7, lr}
 801da2e:	b084      	sub	sp, #16
 801da30:	af00      	add	r7, sp, #0
 801da32:	6078      	str	r0, [r7, #4]
	uint16_t prot = arping_get_protocol(pkt);
 801da34:	6878      	ldr	r0, [r7, #4]
 801da36:	f7ff ff8d 	bl	801d954 <arping_get_protocol>
 801da3a:	4603      	mov	r3, r0
 801da3c:	81fb      	strh	r3, [r7, #14]
	uint16_t opcode = arping_get_opcode(pkt);
 801da3e:	6878      	ldr	r0, [r7, #4]
 801da40:	f7ff ff71 	bl	801d926 <arping_get_opcode>
 801da44:	4603      	mov	r3, r0
 801da46:	81bb      	strh	r3, [r7, #12]
	if (PROTOCOL_ARP == prot) {
 801da48:	89fb      	ldrh	r3, [r7, #14]
 801da4a:	f640 0206 	movw	r2, #2054	; 0x806
 801da4e:	4293      	cmp	r3, r2
 801da50:	d105      	bne.n	801da5e <is_arp_packet+0x32>
		if (opcode < MAX_MSG_TYPE_ARPING) {
 801da52:	89bb      	ldrh	r3, [r7, #12]
 801da54:	2b02      	cmp	r3, #2
 801da56:	d802      	bhi.n	801da5e <is_arp_packet+0x32>
			return opcode;
 801da58:	89bb      	ldrh	r3, [r7, #12]
 801da5a:	b2db      	uxtb	r3, r3
 801da5c:	e000      	b.n	801da60 <is_arp_packet+0x34>
		}
	}
	return 0;
 801da5e:	2300      	movs	r3, #0
}
 801da60:	4618      	mov	r0, r3
 801da62:	3710      	adds	r7, #16
 801da64:	46bd      	mov	sp, r7
 801da66:	bd80      	pop	{r7, pc}

0801da68 <display_arp>:
  *         pkt_len - len of pkt
  *         arp_msg - opcode of pkt
  * @retval None
  */
static void display_arp(uint8_t *pkt, uint16_t pkt_len, uint8_t arp_msg)
{
 801da68:	b5f0      	push	{r4, r5, r6, r7, lr}
 801da6a:	b0a1      	sub	sp, #132	; 0x84
 801da6c:	af06      	add	r7, sp, #24
 801da6e:	6078      	str	r0, [r7, #4]
 801da70:	460b      	mov	r3, r1
 801da72:	807b      	strh	r3, [r7, #2]
 801da74:	4613      	mov	r3, r2
 801da76:	707b      	strb	r3, [r7, #1]
	char ip_addr_s[16];
	char mac_s[30];
	uint8_t *mac = NULL;
 801da78:	2300      	movs	r3, #0
 801da7a:	667b      	str	r3, [r7, #100]	; 0x64
	char str_req[2][20] = {"ARP_REQ_RCVD", "ARP_RSP_RCVD"};
 801da7c:	4b2b      	ldr	r3, [pc, #172]	; (801db2c <display_arp+0xc4>)
 801da7e:	f107 040c 	add.w	r4, r7, #12
 801da82:	461d      	mov	r5, r3
 801da84:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 801da86:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 801da88:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 801da8a:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 801da8c:	e895 0003 	ldmia.w	r5, {r0, r1}
 801da90:	e884 0003 	stmia.w	r4, {r0, r1}

	if (arp_msg < MAX_MSG_TYPE_ARPING) {
 801da94:	787b      	ldrb	r3, [r7, #1]
 801da96:	2b02      	cmp	r3, #2
 801da98:	d843      	bhi.n	801db22 <display_arp+0xba>
		ipv4_addr_ntoa(arping_get_ipaddr(pkt, IP_ADDR_TYPE_SRC), ip_addr_s, 20);
 801da9a:	21cc      	movs	r1, #204	; 0xcc
 801da9c:	6878      	ldr	r0, [r7, #4]
 801da9e:	f7ff fe8d 	bl	801d7bc <arping_get_ipaddr>
 801daa2:	f107 0354 	add.w	r3, r7, #84	; 0x54
 801daa6:	2214      	movs	r2, #20
 801daa8:	4619      	mov	r1, r3
 801daaa:	f000 fa97 	bl	801dfdc <ipv4_addr_ntoa>
		mac = arping_get_mac(pkt, MAC_ADDR_TYPE_SRC);
 801daae:	21c8      	movs	r1, #200	; 0xc8
 801dab0:	6878      	ldr	r0, [r7, #4]
 801dab2:	f7ff fee7 	bl	801d884 <arping_get_mac>
 801dab6:	6678      	str	r0, [r7, #100]	; 0x64

		snprintf(mac_s, 30, "%2x:%2x:%2x:%2x:%2x:%2x",
				mac[0], mac[1], mac[2], mac[3], mac[4], mac[5]);
 801dab8:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 801daba:	781b      	ldrb	r3, [r3, #0]
		snprintf(mac_s, 30, "%2x:%2x:%2x:%2x:%2x:%2x",
 801dabc:	461e      	mov	r6, r3
				mac[0], mac[1], mac[2], mac[3], mac[4], mac[5]);
 801dabe:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 801dac0:	3301      	adds	r3, #1
 801dac2:	781b      	ldrb	r3, [r3, #0]
		snprintf(mac_s, 30, "%2x:%2x:%2x:%2x:%2x:%2x",
 801dac4:	461a      	mov	r2, r3
				mac[0], mac[1], mac[2], mac[3], mac[4], mac[5]);
 801dac6:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 801dac8:	3302      	adds	r3, #2
 801daca:	781b      	ldrb	r3, [r3, #0]
		snprintf(mac_s, 30, "%2x:%2x:%2x:%2x:%2x:%2x",
 801dacc:	4619      	mov	r1, r3
				mac[0], mac[1], mac[2], mac[3], mac[4], mac[5]);
 801dace:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 801dad0:	3303      	adds	r3, #3
 801dad2:	781b      	ldrb	r3, [r3, #0]
		snprintf(mac_s, 30, "%2x:%2x:%2x:%2x:%2x:%2x",
 801dad4:	461c      	mov	r4, r3
				mac[0], mac[1], mac[2], mac[3], mac[4], mac[5]);
 801dad6:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 801dad8:	3304      	adds	r3, #4
 801dada:	781b      	ldrb	r3, [r3, #0]
		snprintf(mac_s, 30, "%2x:%2x:%2x:%2x:%2x:%2x",
 801dadc:	461d      	mov	r5, r3
				mac[0], mac[1], mac[2], mac[3], mac[4], mac[5]);
 801dade:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 801dae0:	3305      	adds	r3, #5
 801dae2:	781b      	ldrb	r3, [r3, #0]
		snprintf(mac_s, 30, "%2x:%2x:%2x:%2x:%2x:%2x",
 801dae4:	f107 0034 	add.w	r0, r7, #52	; 0x34
 801dae8:	9304      	str	r3, [sp, #16]
 801daea:	9503      	str	r5, [sp, #12]
 801daec:	9402      	str	r4, [sp, #8]
 801daee:	9101      	str	r1, [sp, #4]
 801daf0:	9200      	str	r2, [sp, #0]
 801daf2:	4633      	mov	r3, r6
 801daf4:	4a0e      	ldr	r2, [pc, #56]	; (801db30 <display_arp+0xc8>)
 801daf6:	211e      	movs	r1, #30
 801daf8:	f002 fc2a 	bl	8020350 <sniprintf>

		printf("%s: %u bytes from %s (%s)\n\r",
				str_req[arp_msg-1], pkt_len,  ip_addr_s, mac_s);
 801dafc:	787b      	ldrb	r3, [r7, #1]
 801dafe:	1e5a      	subs	r2, r3, #1
 801db00:	f107 010c 	add.w	r1, r7, #12
 801db04:	4613      	mov	r3, r2
 801db06:	009b      	lsls	r3, r3, #2
 801db08:	4413      	add	r3, r2
 801db0a:	009b      	lsls	r3, r3, #2
 801db0c:	4419      	add	r1, r3
		printf("%s: %u bytes from %s (%s)\n\r",
 801db0e:	887a      	ldrh	r2, [r7, #2]
 801db10:	f107 0054 	add.w	r0, r7, #84	; 0x54
 801db14:	f107 0334 	add.w	r3, r7, #52	; 0x34
 801db18:	9300      	str	r3, [sp, #0]
 801db1a:	4603      	mov	r3, r0
 801db1c:	4805      	ldr	r0, [pc, #20]	; (801db34 <display_arp+0xcc>)
 801db1e:	f002 fb25 	bl	802016c <iprintf>
	}
}
 801db22:	bf00      	nop
 801db24:	376c      	adds	r7, #108	; 0x6c
 801db26:	46bd      	mov	sp, r7
 801db28:	bdf0      	pop	{r4, r5, r6, r7, pc}
 801db2a:	bf00      	nop
 801db2c:	08025ca4 	.word	0x08025ca4
 801db30:	08025c70 	.word	0x08025c70
 801db34:	08025c88 	.word	0x08025c88

0801db38 <is_arp_pkt_for_me>:
  * @param  src_ip - self ip
  *         pkt - input buffer
  * @retval 1 if pass, else 0
  */
static uint8_t is_arp_pkt_for_me(uint32_t *src_ip, uint8_t *pkt)
{
 801db38:	b580      	push	{r7, lr}
 801db3a:	b084      	sub	sp, #16
 801db3c:	af00      	add	r7, sp, #0
 801db3e:	6078      	str	r0, [r7, #4]
 801db40:	6039      	str	r1, [r7, #0]
	uint32_t in_dst_ip = 0;
 801db42:	2300      	movs	r3, #0
 801db44:	60fb      	str	r3, [r7, #12]

	in_dst_ip = arping_get_ipaddr(pkt, IP_ADDR_TYPE_DST);
 801db46:	21cd      	movs	r1, #205	; 0xcd
 801db48:	6838      	ldr	r0, [r7, #0]
 801db4a:	f7ff fe37 	bl	801d7bc <arping_get_ipaddr>
 801db4e:	4603      	mov	r3, r0
 801db50:	60fb      	str	r3, [r7, #12]
	if (! is_same_buff(&in_dst_ip, src_ip, IP_ADDR_LEN) ){
 801db52:	f107 030c 	add.w	r3, r7, #12
 801db56:	2204      	movs	r2, #4
 801db58:	6879      	ldr	r1, [r7, #4]
 801db5a:	4618      	mov	r0, r3
 801db5c:	f000 fb28 	bl	801e1b0 <is_same_buff>
 801db60:	4603      	mov	r3, r0
 801db62:	2b00      	cmp	r3, #0
 801db64:	d101      	bne.n	801db6a <is_arp_pkt_for_me+0x32>
		return 0;
 801db66:	2300      	movs	r3, #0
 801db68:	e000      	b.n	801db6c <is_arp_pkt_for_me+0x34>
	}

	return 1;
 801db6a:	2301      	movs	r3, #1
}
 801db6c:	4618      	mov	r0, r3
 801db6e:	3710      	adds	r7, #16
 801db70:	46bd      	mov	sp, r7
 801db72:	bd80      	pop	{r7, pc}

0801db74 <arp_req_handler>:
  *         resp_len - rsp pkt size
  * @retval arp response buffer if valid arp request or NULL
  */
uint8_t * arp_req_handler(uint32_t *src_ip, const uint8_t *src_mac,
		uint8_t *pkt, uint16_t pkt_len, uint16_t *resp_len)
{
 801db74:	b580      	push	{r7, lr}
 801db76:	b086      	sub	sp, #24
 801db78:	af00      	add	r7, sp, #0
 801db7a:	60f8      	str	r0, [r7, #12]
 801db7c:	60b9      	str	r1, [r7, #8]
 801db7e:	607a      	str	r2, [r7, #4]
 801db80:	807b      	strh	r3, [r7, #2]
	uint8_t is_arp_req = 0;
 801db82:	2300      	movs	r3, #0
 801db84:	75fb      	strb	r3, [r7, #23]
	uint8_t *arp_resp = NULL;
 801db86:	2300      	movs	r3, #0
 801db88:	613b      	str	r3, [r7, #16]

	if (! pkt_len || ! pkt) {
 801db8a:	887b      	ldrh	r3, [r7, #2]
 801db8c:	2b00      	cmp	r3, #0
 801db8e:	d002      	beq.n	801db96 <arp_req_handler+0x22>
 801db90:	687b      	ldr	r3, [r7, #4]
 801db92:	2b00      	cmp	r3, #0
 801db94:	d107      	bne.n	801dba6 <arp_req_handler+0x32>
		if(resp_len)
 801db96:	6a3b      	ldr	r3, [r7, #32]
 801db98:	2b00      	cmp	r3, #0
 801db9a:	d002      	beq.n	801dba2 <arp_req_handler+0x2e>
			*resp_len = 0;
 801db9c:	6a3b      	ldr	r3, [r7, #32]
 801db9e:	2200      	movs	r2, #0
 801dba0:	801a      	strh	r2, [r3, #0]
		return NULL;
 801dba2:	2300      	movs	r3, #0
 801dba4:	e047      	b.n	801dc36 <arp_req_handler+0xc2>
	}

	/* discard if not arp pkt */
	is_arp_req = is_arp_packet(pkt);
 801dba6:	6878      	ldr	r0, [r7, #4]
 801dba8:	f7ff ff40 	bl	801da2c <is_arp_packet>
 801dbac:	4603      	mov	r3, r0
 801dbae:	75fb      	strb	r3, [r7, #23]
	if(! is_arp_req) {
 801dbb0:	7dfb      	ldrb	r3, [r7, #23]
 801dbb2:	2b00      	cmp	r3, #0
 801dbb4:	d101      	bne.n	801dbba <arp_req_handler+0x46>
		return NULL;
 801dbb6:	2300      	movs	r3, #0
 801dbb8:	e03d      	b.n	801dc36 <arp_req_handler+0xc2>
	}

	if (! is_arp_pkt_for_me(src_ip, pkt)) {
 801dbba:	6879      	ldr	r1, [r7, #4]
 801dbbc:	68f8      	ldr	r0, [r7, #12]
 801dbbe:	f7ff ffbb 	bl	801db38 <is_arp_pkt_for_me>
 801dbc2:	4603      	mov	r3, r0
 801dbc4:	2b00      	cmp	r3, #0
 801dbc6:	d101      	bne.n	801dbcc <arp_req_handler+0x58>
		return NULL;
 801dbc8:	2300      	movs	r3, #0
 801dbca:	e034      	b.n	801dc36 <arp_req_handler+0xc2>
	}

	display_arp(pkt, pkt_len, is_arp_req);
 801dbcc:	7dfa      	ldrb	r2, [r7, #23]
 801dbce:	887b      	ldrh	r3, [r7, #2]
 801dbd0:	4619      	mov	r1, r3
 801dbd2:	6878      	ldr	r0, [r7, #4]
 801dbd4:	f7ff ff48 	bl	801da68 <display_arp>

	if(ARP_REPLY == is_arp_req) {
 801dbd8:	7dfb      	ldrb	r3, [r7, #23]
 801dbda:	2b02      	cmp	r3, #2
 801dbdc:	d101      	bne.n	801dbe2 <arp_req_handler+0x6e>
		return NULL;
 801dbde:	2300      	movs	r3, #0
 801dbe0:	e029      	b.n	801dc36 <arp_req_handler+0xc2>
	}

	arp_resp = malloc(ARPING_MAX_PKT_SIZE);
 801dbe2:	202a      	movs	r0, #42	; 0x2a
 801dbe4:	f7ff fc20 	bl	801d428 <esp_hosted_malloc>
 801dbe8:	6138      	str	r0, [r7, #16]
	assert(arp_resp);
 801dbea:	693b      	ldr	r3, [r7, #16]
 801dbec:	2b00      	cmp	r3, #0
 801dbee:	d106      	bne.n	801dbfe <arp_req_handler+0x8a>
 801dbf0:	f44f 72af 	mov.w	r2, #350	; 0x15e
 801dbf4:	4912      	ldr	r1, [pc, #72]	; (801dc40 <arp_req_handler+0xcc>)
 801dbf6:	4813      	ldr	r0, [pc, #76]	; (801dc44 <arp_req_handler+0xd0>)
 801dbf8:	f002 fab8 	bl	802016c <iprintf>
 801dbfc:	e7fe      	b.n	801dbfc <arp_req_handler+0x88>


	/* replicate packet */
	memset(arp_resp, 0, ARPING_MAX_PKT_SIZE);
 801dbfe:	222a      	movs	r2, #42	; 0x2a
 801dc00:	2100      	movs	r1, #0
 801dc02:	6938      	ldr	r0, [r7, #16]
 801dc04:	f001 fe3a 	bl	801f87c <memset>
	memcpy(arp_resp, pkt, ARPING_MAX_PKT_SIZE);
 801dc08:	222a      	movs	r2, #42	; 0x2a
 801dc0a:	6879      	ldr	r1, [r7, #4]
 801dc0c:	6938      	ldr	r0, [r7, #16]
 801dc0e:	f001 fe0d 	bl	801f82c <memcpy>

	/* set opcode */
	arping_set_opcode(arp_resp, 2);
 801dc12:	2102      	movs	r1, #2
 801dc14:	6938      	ldr	r0, [r7, #16]
 801dc16:	f7ff fe6f 	bl	801d8f8 <arping_set_opcode>

	/* swap source and destination ip addresses */
	arping_swap_ip_addresses(arp_resp);
 801dc1a:	6938      	ldr	r0, [r7, #16]
 801dc1c:	f7ff feb2 	bl	801d984 <arping_swap_ip_addresses>
	arping_change_mac_addresses(arp_resp, src_mac);
 801dc20:	68b9      	ldr	r1, [r7, #8]
 801dc22:	6938      	ldr	r0, [r7, #16]
 801dc24:	f7ff fed6 	bl	801d9d4 <arping_change_mac_addresses>

	if(resp_len)
 801dc28:	6a3b      	ldr	r3, [r7, #32]
 801dc2a:	2b00      	cmp	r3, #0
 801dc2c:	d002      	beq.n	801dc34 <arp_req_handler+0xc0>
		*resp_len = pkt_len;
 801dc2e:	6a3b      	ldr	r3, [r7, #32]
 801dc30:	887a      	ldrh	r2, [r7, #2]
 801dc32:	801a      	strh	r2, [r3, #0]

	return arp_resp;
 801dc34:	693b      	ldr	r3, [r7, #16]
}
 801dc36:	4618      	mov	r0, r3
 801dc38:	3718      	adds	r7, #24
 801dc3a:	46bd      	mov	sp, r7
 801dc3c:	bd80      	pop	{r7, pc}
 801dc3e:	bf00      	nop
 801dc40:	08025ccc 	.word	0x08025ccc
 801dc44:	08025d1c 	.word	0x08025d1c

0801dc48 <hton_short>:
#if DEBUG_HEX_STREAM_PRINT
char print_buff[MAX_SPI_BUFFER_SIZE*3];
#endif

uint16_t hton_short (uint16_t x)
{
 801dc48:	b480      	push	{r7}
 801dc4a:	b085      	sub	sp, #20
 801dc4c:	af00      	add	r7, sp, #0
 801dc4e:	4603      	mov	r3, r0
 801dc50:	80fb      	strh	r3, [r7, #6]
#if BYTE_ORDER == BIG_ENDIAN
  return x;
#elif BYTE_ORDER == LITTLE_ENDIAN
  uint16_t val = 0;
 801dc52:	2300      	movs	r3, #0
 801dc54:	81fb      	strh	r3, [r7, #14]

  val = (x &0x00FF)<<8;
 801dc56:	88fb      	ldrh	r3, [r7, #6]
 801dc58:	021b      	lsls	r3, r3, #8
 801dc5a:	81fb      	strh	r3, [r7, #14]
  val |= (x &0xFF00)>>8;
 801dc5c:	88fb      	ldrh	r3, [r7, #6]
 801dc5e:	0a1b      	lsrs	r3, r3, #8
 801dc60:	b29a      	uxth	r2, r3
 801dc62:	89fb      	ldrh	r3, [r7, #14]
 801dc64:	4313      	orrs	r3, r2
 801dc66:	81fb      	strh	r3, [r7, #14]

  return val;
 801dc68:	89fb      	ldrh	r3, [r7, #14]
#else
# error "not able to identify endianness"
#endif
}
 801dc6a:	4618      	mov	r0, r3
 801dc6c:	3714      	adds	r7, #20
 801dc6e:	46bd      	mov	sp, r7
 801dc70:	f85d 7b04 	ldr.w	r7, [sp], #4
 801dc74:	4770      	bx	lr

0801dc76 <hton_long>:

uint32_t hton_long (uint32_t x)
{
 801dc76:	b480      	push	{r7}
 801dc78:	b085      	sub	sp, #20
 801dc7a:	af00      	add	r7, sp, #0
 801dc7c:	6078      	str	r0, [r7, #4]
#if BYTE_ORDER == BIG_ENDIAN
  return x;
#elif BYTE_ORDER == LITTLE_ENDIAN
    uint32_t val = (x&0xFF000000) >> 24;
 801dc7e:	687b      	ldr	r3, [r7, #4]
 801dc80:	0e1b      	lsrs	r3, r3, #24
 801dc82:	60fb      	str	r3, [r7, #12]

    val |= (x&0x00FF0000) >> 8;
 801dc84:	687b      	ldr	r3, [r7, #4]
 801dc86:	0a1b      	lsrs	r3, r3, #8
 801dc88:	f403 437f 	and.w	r3, r3, #65280	; 0xff00
 801dc8c:	68fa      	ldr	r2, [r7, #12]
 801dc8e:	4313      	orrs	r3, r2
 801dc90:	60fb      	str	r3, [r7, #12]
    val |= (x&0x0000FF00) << 8;
 801dc92:	687b      	ldr	r3, [r7, #4]
 801dc94:	021b      	lsls	r3, r3, #8
 801dc96:	f403 037f 	and.w	r3, r3, #16711680	; 0xff0000
 801dc9a:	68fa      	ldr	r2, [r7, #12]
 801dc9c:	4313      	orrs	r3, r2
 801dc9e:	60fb      	str	r3, [r7, #12]
    val |= (x&0x000000FF) << 24;
 801dca0:	687b      	ldr	r3, [r7, #4]
 801dca2:	061b      	lsls	r3, r3, #24
 801dca4:	68fa      	ldr	r2, [r7, #12]
 801dca6:	4313      	orrs	r3, r2
 801dca8:	60fb      	str	r3, [r7, #12]

    return val;
 801dcaa:	68fb      	ldr	r3, [r7, #12]
#else
# error "not able to identify endianness"
#endif
}
 801dcac:	4618      	mov	r0, r3
 801dcae:	3714      	adds	r7, #20
 801dcb0:	46bd      	mov	sp, r7
 801dcb2:	f85d 7b04 	ldr.w	r7, [sp], #4
 801dcb6:	4770      	bx	lr

0801dcb8 <print_hex_dump>:
  *         rx_len - size of buf
  *         human_str - help string to prepend
  * @retval None
  */
void print_hex_dump(uint8_t *buff, uint16_t rx_len, char *human_str)
{
 801dcb8:	b480      	push	{r7}
 801dcba:	b085      	sub	sp, #20
 801dcbc:	af00      	add	r7, sp, #0
 801dcbe:	60f8      	str	r0, [r7, #12]
 801dcc0:	460b      	mov	r3, r1
 801dcc2:	607a      	str	r2, [r7, #4]
 801dcc4:	817b      	strh	r3, [r7, #10]
#else
    UNUSED_VAR(buff);
    UNUSED_VAR(rx_len);
    UNUSED_VAR(human_str);
#endif /* DEBUG_HEX_STREAM_PRINT */
}
 801dcc6:	bf00      	nop
 801dcc8:	3714      	adds	r7, #20
 801dcca:	46bd      	mov	sp, r7
 801dccc:	f85d 7b04 	ldr.w	r7, [sp], #4
 801dcd0:	4770      	bx	lr

0801dcd2 <min>:
  * @brief  Calculate minimum
  * @param  x - number
  *         y - number
  * @retval minimum
  */
int min(int x, int y) {
 801dcd2:	b480      	push	{r7}
 801dcd4:	b083      	sub	sp, #12
 801dcd6:	af00      	add	r7, sp, #0
 801dcd8:	6078      	str	r0, [r7, #4]
 801dcda:	6039      	str	r1, [r7, #0]
    return (x < y) ? x : y;
 801dcdc:	683a      	ldr	r2, [r7, #0]
 801dcde:	687b      	ldr	r3, [r7, #4]
 801dce0:	4293      	cmp	r3, r2
 801dce2:	bfa8      	it	ge
 801dce4:	4613      	movge	r3, r2
}
 801dce6:	4618      	mov	r0, r3
 801dce8:	370c      	adds	r7, #12
 801dcea:	46bd      	mov	sp, r7
 801dcec:	f85d 7b04 	ldr.w	r7, [sp], #4
 801dcf0:	4770      	bx	lr

0801dcf2 <hard_delay>:
  * @brief Delay without context switch
  * @param  None
  * @retval None
  */
void hard_delay(int x)
{
 801dcf2:	b480      	push	{r7}
 801dcf4:	b085      	sub	sp, #20
 801dcf6:	af00      	add	r7, sp, #0
 801dcf8:	6078      	str	r0, [r7, #4]
    volatile int idx = 0;
 801dcfa:	2300      	movs	r3, #0
 801dcfc:	60fb      	str	r3, [r7, #12]
    for (idx=0; idx<1000*x; idx++) {
 801dcfe:	2300      	movs	r3, #0
 801dd00:	60fb      	str	r3, [r7, #12]
 801dd02:	e002      	b.n	801dd0a <hard_delay+0x18>
 801dd04:	68fb      	ldr	r3, [r7, #12]
 801dd06:	3301      	adds	r3, #1
 801dd08:	60fb      	str	r3, [r7, #12]
 801dd0a:	687b      	ldr	r3, [r7, #4]
 801dd0c:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
 801dd10:	fb03 f202 	mul.w	r2, r3, r2
 801dd14:	68fb      	ldr	r3, [r7, #12]
 801dd16:	429a      	cmp	r2, r3
 801dd18:	dcf4      	bgt.n	801dd04 <hard_delay+0x12>
    }
}
 801dd1a:	bf00      	nop
 801dd1c:	bf00      	nop
 801dd1e:	3714      	adds	r7, #20
 801dd20:	46bd      	mov	sp, r7
 801dd22:	f85d 7b04 	ldr.w	r7, [sp], #4
 801dd26:	4770      	bx	lr

0801dd28 <get_num_from_string>:
  * @param  val - return integer value,
  *         arg - input string
  * @retval STM_OK on success, else STM_FAIL
  */
int get_num_from_string(int *val, char *arg)
{
 801dd28:	b580      	push	{r7, lr}
 801dd2a:	b086      	sub	sp, #24
 801dd2c:	af00      	add	r7, sp, #0
 801dd2e:	6078      	str	r0, [r7, #4]
 801dd30:	6039      	str	r1, [r7, #0]
  int base = 10;
 801dd32:	230a      	movs	r3, #10
 801dd34:	617b      	str	r3, [r7, #20]
  char *endptr = NULL, *str = NULL;
 801dd36:	2300      	movs	r3, #0
 801dd38:	60fb      	str	r3, [r7, #12]
 801dd3a:	2300      	movs	r3, #0
 801dd3c:	613b      	str	r3, [r7, #16]

  if (!arg || (arg[0]=='\0')) {
 801dd3e:	683b      	ldr	r3, [r7, #0]
 801dd40:	2b00      	cmp	r3, #0
 801dd42:	d003      	beq.n	801dd4c <get_num_from_string+0x24>
 801dd44:	683b      	ldr	r3, [r7, #0]
 801dd46:	781b      	ldrb	r3, [r3, #0]
 801dd48:	2b00      	cmp	r3, #0
 801dd4a:	d105      	bne.n	801dd58 <get_num_from_string+0x30>
    printf("No number Identified \n");
 801dd4c:	4825      	ldr	r0, [pc, #148]	; (801dde4 <get_num_from_string+0xbc>)
 801dd4e:	f002 faa9 	bl	80202a4 <puts>
    return STM_FAIL;
 801dd52:	f04f 33ff 	mov.w	r3, #4294967295
 801dd56:	e041      	b.n	801dddc <get_num_from_string+0xb4>
  }

  if (!val) {
 801dd58:	687b      	ldr	r3, [r7, #4]
 801dd5a:	2b00      	cmp	r3, #0
 801dd5c:	d105      	bne.n	801dd6a <get_num_from_string+0x42>
    printf("No memory allocated \n");
 801dd5e:	4822      	ldr	r0, [pc, #136]	; (801dde8 <get_num_from_string+0xc0>)
 801dd60:	f002 faa0 	bl	80202a4 <puts>
    return STM_FAIL;
 801dd64:	f04f 33ff 	mov.w	r3, #4294967295
 801dd68:	e038      	b.n	801dddc <get_num_from_string+0xb4>
  }

  errno = 0;
 801dd6a:	f001 fd13 	bl	801f794 <__errno>
 801dd6e:	4603      	mov	r3, r0
 801dd70:	2200      	movs	r2, #0
 801dd72:	601a      	str	r2, [r3, #0]
  str = arg;
 801dd74:	683b      	ldr	r3, [r7, #0]
 801dd76:	613b      	str	r3, [r7, #16]
  *val = strtol(str, &endptr, base);
 801dd78:	f107 030c 	add.w	r3, r7, #12
 801dd7c:	697a      	ldr	r2, [r7, #20]
 801dd7e:	4619      	mov	r1, r3
 801dd80:	6938      	ldr	r0, [r7, #16]
 801dd82:	f002 fe3f 	bl	8020a04 <strtol>
 801dd86:	4602      	mov	r2, r0
 801dd88:	687b      	ldr	r3, [r7, #4]
 801dd8a:	601a      	str	r2, [r3, #0]

  if (endptr == str) {
 801dd8c:	68fb      	ldr	r3, [r7, #12]
 801dd8e:	693a      	ldr	r2, [r7, #16]
 801dd90:	429a      	cmp	r2, r3
 801dd92:	d108      	bne.n	801dda6 <get_num_from_string+0x7e>
    printf("No digits found \n");
 801dd94:	4815      	ldr	r0, [pc, #84]	; (801ddec <get_num_from_string+0xc4>)
 801dd96:	f002 fa85 	bl	80202a4 <puts>
    *val = 0;
 801dd9a:	687b      	ldr	r3, [r7, #4]
 801dd9c:	2200      	movs	r2, #0
 801dd9e:	601a      	str	r2, [r3, #0]
    return STM_FAIL;
 801dda0:	f04f 33ff 	mov.w	r3, #4294967295
 801dda4:	e01a      	b.n	801dddc <get_num_from_string+0xb4>
  }

  if ((errno == ERANGE) && ((*val == INT32_MAX) || (*val == INT32_MIN))) {
 801dda6:	f001 fcf5 	bl	801f794 <__errno>
 801ddaa:	4603      	mov	r3, r0
 801ddac:	681b      	ldr	r3, [r3, #0]
 801ddae:	2b22      	cmp	r3, #34	; 0x22
 801ddb0:	d113      	bne.n	801ddda <get_num_from_string+0xb2>
 801ddb2:	687b      	ldr	r3, [r7, #4]
 801ddb4:	681b      	ldr	r3, [r3, #0]
 801ddb6:	f06f 4200 	mvn.w	r2, #2147483648	; 0x80000000
 801ddba:	4293      	cmp	r3, r2
 801ddbc:	d004      	beq.n	801ddc8 <get_num_from_string+0xa0>
 801ddbe:	687b      	ldr	r3, [r7, #4]
 801ddc0:	681b      	ldr	r3, [r3, #0]
 801ddc2:	f1b3 4f00 	cmp.w	r3, #2147483648	; 0x80000000
 801ddc6:	d108      	bne.n	801ddda <get_num_from_string+0xb2>
    perror("strtol");
 801ddc8:	4809      	ldr	r0, [pc, #36]	; (801ddf0 <get_num_from_string+0xc8>)
 801ddca:	f002 f9c7 	bl	802015c <perror>
    *val = 0;
 801ddce:	687b      	ldr	r3, [r7, #4]
 801ddd0:	2200      	movs	r2, #0
 801ddd2:	601a      	str	r2, [r3, #0]
    return STM_FAIL;
 801ddd4:	f04f 33ff 	mov.w	r3, #4294967295
 801ddd8:	e000      	b.n	801dddc <get_num_from_string+0xb4>
  }

  return STM_OK;
 801ddda:	2300      	movs	r3, #0
}
 801dddc:	4618      	mov	r0, r3
 801ddde:	3718      	adds	r7, #24
 801dde0:	46bd      	mov	sp, r7
 801dde2:	bd80      	pop	{r7, pc}
 801dde4:	08025d30 	.word	0x08025d30
 801dde8:	08025d48 	.word	0x08025d48
 801ddec:	08025d60 	.word	0x08025d60
 801ddf0:	08025d74 	.word	0x08025d74

0801ddf4 <ipv4_addr_aton>:
 * Returns 1 if the address is valid, 0 if not.
 * This replaces inet_addr, the return value from which
 * cannot distinguish between failure and a local broadcast address.
 */
int ipv4_addr_aton(const char *cp, uint32_t *ip_uint32)
{
 801ddf4:	b580      	push	{r7, lr}
 801ddf6:	b08c      	sub	sp, #48	; 0x30
 801ddf8:	af00      	add	r7, sp, #0
 801ddfa:	6078      	str	r0, [r7, #4]
 801ddfc:	6039      	str	r1, [r7, #0]
	u_long val, base, n;
	char c;
	u_long parts[4], *pp = parts;
 801ddfe:	f107 030c 	add.w	r3, r7, #12
 801de02:	627b      	str	r3, [r7, #36]	; 0x24
		/*
		 * Collect number up to ``.''.
		 * Values are specified as for C:
		 * 0x=hex, 0=octal, other=decimal.
		 */
		val = 0; base = 10;
 801de04:	2300      	movs	r3, #0
 801de06:	62fb      	str	r3, [r7, #44]	; 0x2c
 801de08:	230a      	movs	r3, #10
 801de0a:	62bb      	str	r3, [r7, #40]	; 0x28
		if (*cp == '0') {
 801de0c:	687b      	ldr	r3, [r7, #4]
 801de0e:	781b      	ldrb	r3, [r3, #0]
 801de10:	2b30      	cmp	r3, #48	; 0x30
 801de12:	d159      	bne.n	801dec8 <ipv4_addr_aton+0xd4>
			if (*++cp == 'x' || *cp == 'X')
 801de14:	687b      	ldr	r3, [r7, #4]
 801de16:	3301      	adds	r3, #1
 801de18:	607b      	str	r3, [r7, #4]
 801de1a:	687b      	ldr	r3, [r7, #4]
 801de1c:	781b      	ldrb	r3, [r3, #0]
 801de1e:	2b78      	cmp	r3, #120	; 0x78
 801de20:	d003      	beq.n	801de2a <ipv4_addr_aton+0x36>
 801de22:	687b      	ldr	r3, [r7, #4]
 801de24:	781b      	ldrb	r3, [r3, #0]
 801de26:	2b58      	cmp	r3, #88	; 0x58
 801de28:	d105      	bne.n	801de36 <ipv4_addr_aton+0x42>
				base = 16, cp++;
 801de2a:	2310      	movs	r3, #16
 801de2c:	62bb      	str	r3, [r7, #40]	; 0x28
 801de2e:	687b      	ldr	r3, [r7, #4]
 801de30:	3301      	adds	r3, #1
 801de32:	607b      	str	r3, [r7, #4]
 801de34:	e001      	b.n	801de3a <ipv4_addr_aton+0x46>
			else
				base = 8;
 801de36:	2308      	movs	r3, #8
 801de38:	62bb      	str	r3, [r7, #40]	; 0x28
		}
		while ((c = *cp) != '\0') {
 801de3a:	e045      	b.n	801dec8 <ipv4_addr_aton+0xd4>
			if (isascii(c) && isdigit(c)) {
 801de3c:	f997 3023 	ldrsb.w	r3, [r7, #35]	; 0x23
 801de40:	2b00      	cmp	r3, #0
 801de42:	db16      	blt.n	801de72 <ipv4_addr_aton+0x7e>
 801de44:	f897 3023 	ldrb.w	r3, [r7, #35]	; 0x23
 801de48:	3301      	adds	r3, #1
 801de4a:	4a63      	ldr	r2, [pc, #396]	; (801dfd8 <ipv4_addr_aton+0x1e4>)
 801de4c:	4413      	add	r3, r2
 801de4e:	781b      	ldrb	r3, [r3, #0]
 801de50:	f003 0304 	and.w	r3, r3, #4
 801de54:	2b00      	cmp	r3, #0
 801de56:	d00c      	beq.n	801de72 <ipv4_addr_aton+0x7e>
				val = (val * base) + (c - '0');
 801de58:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 801de5a:	6aba      	ldr	r2, [r7, #40]	; 0x28
 801de5c:	fb03 f202 	mul.w	r2, r3, r2
 801de60:	f897 3023 	ldrb.w	r3, [r7, #35]	; 0x23
 801de64:	4413      	add	r3, r2
 801de66:	3b30      	subs	r3, #48	; 0x30
 801de68:	62fb      	str	r3, [r7, #44]	; 0x2c
				cp++;
 801de6a:	687b      	ldr	r3, [r7, #4]
 801de6c:	3301      	adds	r3, #1
 801de6e:	607b      	str	r3, [r7, #4]
				continue;
 801de70:	e02a      	b.n	801dec8 <ipv4_addr_aton+0xd4>
			}
			if (base == 16 && isascii(c) && isxdigit(c)) {
 801de72:	6abb      	ldr	r3, [r7, #40]	; 0x28
 801de74:	2b10      	cmp	r3, #16
 801de76:	d130      	bne.n	801deda <ipv4_addr_aton+0xe6>
 801de78:	f997 3023 	ldrsb.w	r3, [r7, #35]	; 0x23
 801de7c:	2b00      	cmp	r3, #0
 801de7e:	db2c      	blt.n	801deda <ipv4_addr_aton+0xe6>
 801de80:	f897 3023 	ldrb.w	r3, [r7, #35]	; 0x23
 801de84:	3301      	adds	r3, #1
 801de86:	4a54      	ldr	r2, [pc, #336]	; (801dfd8 <ipv4_addr_aton+0x1e4>)
 801de88:	4413      	add	r3, r2
 801de8a:	781b      	ldrb	r3, [r3, #0]
 801de8c:	f003 0344 	and.w	r3, r3, #68	; 0x44
 801de90:	2b00      	cmp	r3, #0
 801de92:	d022      	beq.n	801deda <ipv4_addr_aton+0xe6>
				val = (val << 4) +
 801de94:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 801de96:	011b      	lsls	r3, r3, #4
					(c + 10 - (islower(c) ? 'a' : 'A'));
 801de98:	f897 2023 	ldrb.w	r2, [r7, #35]	; 0x23
 801de9c:	f102 010a 	add.w	r1, r2, #10
 801dea0:	f897 2023 	ldrb.w	r2, [r7, #35]	; 0x23
 801dea4:	3201      	adds	r2, #1
 801dea6:	484c      	ldr	r0, [pc, #304]	; (801dfd8 <ipv4_addr_aton+0x1e4>)
 801dea8:	4402      	add	r2, r0
 801deaa:	7812      	ldrb	r2, [r2, #0]
 801deac:	f002 0203 	and.w	r2, r2, #3
 801deb0:	2a02      	cmp	r2, #2
 801deb2:	d101      	bne.n	801deb8 <ipv4_addr_aton+0xc4>
 801deb4:	2261      	movs	r2, #97	; 0x61
 801deb6:	e000      	b.n	801deba <ipv4_addr_aton+0xc6>
 801deb8:	2241      	movs	r2, #65	; 0x41
 801deba:	1a8a      	subs	r2, r1, r2
				val = (val << 4) +
 801debc:	4413      	add	r3, r2
 801debe:	62fb      	str	r3, [r7, #44]	; 0x2c
				cp++;
 801dec0:	687b      	ldr	r3, [r7, #4]
 801dec2:	3301      	adds	r3, #1
 801dec4:	607b      	str	r3, [r7, #4]
				continue;
 801dec6:	bf00      	nop
		while ((c = *cp) != '\0') {
 801dec8:	687b      	ldr	r3, [r7, #4]
 801deca:	781b      	ldrb	r3, [r3, #0]
 801decc:	f887 3023 	strb.w	r3, [r7, #35]	; 0x23
 801ded0:	f897 3023 	ldrb.w	r3, [r7, #35]	; 0x23
 801ded4:	2b00      	cmp	r3, #0
 801ded6:	d1b1      	bne.n	801de3c <ipv4_addr_aton+0x48>
 801ded8:	e000      	b.n	801dedc <ipv4_addr_aton+0xe8>
			}
			break;
 801deda:	bf00      	nop
		}
		if (*cp == '.') {
 801dedc:	687b      	ldr	r3, [r7, #4]
 801dede:	781b      	ldrb	r3, [r3, #0]
 801dee0:	2b2e      	cmp	r3, #46	; 0x2e
 801dee2:	d113      	bne.n	801df0c <ipv4_addr_aton+0x118>
			 * Internet format:
			 *	a.b.c.d
			 *	a.b.c	(with c treated as 16-bits)
			 *	a.b	(with b treated as 24 bits)
			 */
			if (pp >= parts + 3 || val > 0xff)
 801dee4:	f107 030c 	add.w	r3, r7, #12
 801dee8:	330c      	adds	r3, #12
 801deea:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 801deec:	429a      	cmp	r2, r3
 801deee:	d202      	bcs.n	801def6 <ipv4_addr_aton+0x102>
 801def0:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 801def2:	2bff      	cmp	r3, #255	; 0xff
 801def4:	d901      	bls.n	801defa <ipv4_addr_aton+0x106>
				return (0);
 801def6:	2300      	movs	r3, #0
 801def8:	e06a      	b.n	801dfd0 <ipv4_addr_aton+0x1dc>
			*pp++ = val, cp++;
 801defa:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801defc:	1d1a      	adds	r2, r3, #4
 801defe:	627a      	str	r2, [r7, #36]	; 0x24
 801df00:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 801df02:	601a      	str	r2, [r3, #0]
 801df04:	687b      	ldr	r3, [r7, #4]
 801df06:	3301      	adds	r3, #1
 801df08:	607b      	str	r3, [r7, #4]
		val = 0; base = 10;
 801df0a:	e77b      	b.n	801de04 <ipv4_addr_aton+0x10>
		} else
			break;
 801df0c:	bf00      	nop
	}
	/*
	 * Check for trailing characters.
	 */
	if (*cp && (!isascii(*cp) || !isspace(*cp)))
 801df0e:	687b      	ldr	r3, [r7, #4]
 801df10:	781b      	ldrb	r3, [r3, #0]
 801df12:	2b00      	cmp	r3, #0
 801df14:	d010      	beq.n	801df38 <ipv4_addr_aton+0x144>
 801df16:	687b      	ldr	r3, [r7, #4]
 801df18:	781b      	ldrb	r3, [r3, #0]
 801df1a:	b25b      	sxtb	r3, r3
 801df1c:	2b00      	cmp	r3, #0
 801df1e:	db09      	blt.n	801df34 <ipv4_addr_aton+0x140>
 801df20:	687b      	ldr	r3, [r7, #4]
 801df22:	781b      	ldrb	r3, [r3, #0]
 801df24:	3301      	adds	r3, #1
 801df26:	4a2c      	ldr	r2, [pc, #176]	; (801dfd8 <ipv4_addr_aton+0x1e4>)
 801df28:	4413      	add	r3, r2
 801df2a:	781b      	ldrb	r3, [r3, #0]
 801df2c:	f003 0308 	and.w	r3, r3, #8
 801df30:	2b00      	cmp	r3, #0
 801df32:	d101      	bne.n	801df38 <ipv4_addr_aton+0x144>
		return (0);
 801df34:	2300      	movs	r3, #0
 801df36:	e04b      	b.n	801dfd0 <ipv4_addr_aton+0x1dc>
	/*
	 * Concoct the address according to
	 * the number of parts specified.
	 */
	n = pp - parts + 1;
 801df38:	f107 030c 	add.w	r3, r7, #12
 801df3c:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 801df3e:	1ad3      	subs	r3, r2, r3
 801df40:	109b      	asrs	r3, r3, #2
 801df42:	3301      	adds	r3, #1
 801df44:	61fb      	str	r3, [r7, #28]
	switch (n) {
 801df46:	69fb      	ldr	r3, [r7, #28]
 801df48:	3b01      	subs	r3, #1
 801df4a:	2b03      	cmp	r3, #3
 801df4c:	d836      	bhi.n	801dfbc <ipv4_addr_aton+0x1c8>
 801df4e:	a201      	add	r2, pc, #4	; (adr r2, 801df54 <ipv4_addr_aton+0x160>)
 801df50:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 801df54:	0801dfbd 	.word	0x0801dfbd
 801df58:	0801df65 	.word	0x0801df65
 801df5c:	0801df7d 	.word	0x0801df7d
 801df60:	0801df9b 	.word	0x0801df9b

	case 1:				/* a -- 32 bits */
		break;

	case 2:				/* a.b -- 8.24 bits */
		if (val > 0xffffff)
 801df64:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 801df66:	f1b3 7f80 	cmp.w	r3, #16777216	; 0x1000000
 801df6a:	d301      	bcc.n	801df70 <ipv4_addr_aton+0x17c>
			return (0);
 801df6c:	2300      	movs	r3, #0
 801df6e:	e02f      	b.n	801dfd0 <ipv4_addr_aton+0x1dc>
		val |= parts[0] << 24;
 801df70:	68fb      	ldr	r3, [r7, #12]
 801df72:	061b      	lsls	r3, r3, #24
 801df74:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 801df76:	4313      	orrs	r3, r2
 801df78:	62fb      	str	r3, [r7, #44]	; 0x2c
		break;
 801df7a:	e01f      	b.n	801dfbc <ipv4_addr_aton+0x1c8>

	case 3:				/* a.b.c -- 8.8.16 bits */
		if (val > 0xffff)
 801df7c:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 801df7e:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
 801df82:	d301      	bcc.n	801df88 <ipv4_addr_aton+0x194>
			return (0);
 801df84:	2300      	movs	r3, #0
 801df86:	e023      	b.n	801dfd0 <ipv4_addr_aton+0x1dc>
		val |= (parts[0] << 24) | (parts[1] << 16);
 801df88:	68fb      	ldr	r3, [r7, #12]
 801df8a:	061a      	lsls	r2, r3, #24
 801df8c:	693b      	ldr	r3, [r7, #16]
 801df8e:	041b      	lsls	r3, r3, #16
 801df90:	4313      	orrs	r3, r2
 801df92:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 801df94:	4313      	orrs	r3, r2
 801df96:	62fb      	str	r3, [r7, #44]	; 0x2c
		break;
 801df98:	e010      	b.n	801dfbc <ipv4_addr_aton+0x1c8>

	case 4:				/* a.b.c.d -- 8.8.8.8 bits */
		if (val > 0xff)
 801df9a:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 801df9c:	2bff      	cmp	r3, #255	; 0xff
 801df9e:	d901      	bls.n	801dfa4 <ipv4_addr_aton+0x1b0>
			return (0);
 801dfa0:	2300      	movs	r3, #0
 801dfa2:	e015      	b.n	801dfd0 <ipv4_addr_aton+0x1dc>
		val |= (parts[0] << 24) | (parts[1] << 16) | (parts[2] << 8);
 801dfa4:	68fb      	ldr	r3, [r7, #12]
 801dfa6:	061a      	lsls	r2, r3, #24
 801dfa8:	693b      	ldr	r3, [r7, #16]
 801dfaa:	041b      	lsls	r3, r3, #16
 801dfac:	431a      	orrs	r2, r3
 801dfae:	697b      	ldr	r3, [r7, #20]
 801dfb0:	021b      	lsls	r3, r3, #8
 801dfb2:	4313      	orrs	r3, r2
 801dfb4:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 801dfb6:	4313      	orrs	r3, r2
 801dfb8:	62fb      	str	r3, [r7, #44]	; 0x2c
		break;
 801dfba:	bf00      	nop
	}
	if(ip_uint32) {
 801dfbc:	683b      	ldr	r3, [r7, #0]
 801dfbe:	2b00      	cmp	r3, #0
 801dfc0:	d005      	beq.n	801dfce <ipv4_addr_aton+0x1da>
		*ip_uint32 = hton_long(val);
 801dfc2:	6af8      	ldr	r0, [r7, #44]	; 0x2c
 801dfc4:	f7ff fe57 	bl	801dc76 <hton_long>
 801dfc8:	4602      	mov	r2, r0
 801dfca:	683b      	ldr	r3, [r7, #0]
 801dfcc:	601a      	str	r2, [r3, #0]
	}
	return (1);
 801dfce:	2301      	movs	r3, #1
}
 801dfd0:	4618      	mov	r0, r3
 801dfd2:	3730      	adds	r7, #48	; 0x30
 801dfd4:	46bd      	mov	sp, r7
 801dfd6:	bd80      	pop	{r7, pc}
 801dfd8:	0802880b 	.word	0x0802880b

0801dfdc <ipv4_addr_ntoa>:
 * @return either pointer to buf which now holds the ASCII
 *         representation of addr or NULL if buf was too small
 */

char * ipv4_addr_ntoa(uint32_t addr, char *buf, int buflen)
{
 801dfdc:	b580      	push	{r7, lr}
 801dfde:	b08a      	sub	sp, #40	; 0x28
 801dfe0:	af00      	add	r7, sp, #0
 801dfe2:	60f8      	str	r0, [r7, #12]
 801dfe4:	60b9      	str	r1, [r7, #8]
 801dfe6:	607a      	str	r2, [r7, #4]
	char *rp;
	uint8_t *ap;
	uint8_t rem;
	uint8_t n;
	uint8_t i;
	int len = 0;
 801dfe8:	2300      	movs	r3, #0
 801dfea:	61bb      	str	r3, [r7, #24]
	uint32_t addr_nw = ntoh_long(addr);
 801dfec:	68f8      	ldr	r0, [r7, #12]
 801dfee:	f7ff fe42 	bl	801dc76 <hton_long>
 801dff2:	4603      	mov	r3, r0
 801dff4:	613b      	str	r3, [r7, #16]

	rp = buf;
 801dff6:	68bb      	ldr	r3, [r7, #8]
 801dff8:	627b      	str	r3, [r7, #36]	; 0x24
	ap = (uint8_t *)&addr_nw;
 801dffa:	f107 0310 	add.w	r3, r7, #16
 801dffe:	623b      	str	r3, [r7, #32]
	for (n = 0; n < 4; n++) {
 801e000:	2300      	movs	r3, #0
 801e002:	77fb      	strb	r3, [r7, #31]
 801e004:	e050      	b.n	801e0a8 <ipv4_addr_ntoa+0xcc>
		i = 0;
 801e006:	2300      	movs	r3, #0
 801e008:	77bb      	strb	r3, [r7, #30]
		do {
			rem = *ap % (uint8_t)10;
 801e00a:	6a3b      	ldr	r3, [r7, #32]
 801e00c:	781a      	ldrb	r2, [r3, #0]
 801e00e:	4b2d      	ldr	r3, [pc, #180]	; (801e0c4 <ipv4_addr_ntoa+0xe8>)
 801e010:	fba3 1302 	umull	r1, r3, r3, r2
 801e014:	08d9      	lsrs	r1, r3, #3
 801e016:	460b      	mov	r3, r1
 801e018:	009b      	lsls	r3, r3, #2
 801e01a:	440b      	add	r3, r1
 801e01c:	005b      	lsls	r3, r3, #1
 801e01e:	1ad3      	subs	r3, r2, r3
 801e020:	75fb      	strb	r3, [r7, #23]
			*ap /= (uint8_t)10;
 801e022:	6a3b      	ldr	r3, [r7, #32]
 801e024:	781b      	ldrb	r3, [r3, #0]
 801e026:	4a27      	ldr	r2, [pc, #156]	; (801e0c4 <ipv4_addr_ntoa+0xe8>)
 801e028:	fba2 2303 	umull	r2, r3, r2, r3
 801e02c:	08db      	lsrs	r3, r3, #3
 801e02e:	b2da      	uxtb	r2, r3
 801e030:	6a3b      	ldr	r3, [r7, #32]
 801e032:	701a      	strb	r2, [r3, #0]
			inv[i++] = (char)('0' + rem);
 801e034:	7fbb      	ldrb	r3, [r7, #30]
 801e036:	1c5a      	adds	r2, r3, #1
 801e038:	77ba      	strb	r2, [r7, #30]
 801e03a:	4619      	mov	r1, r3
 801e03c:	7dfb      	ldrb	r3, [r7, #23]
 801e03e:	3330      	adds	r3, #48	; 0x30
 801e040:	b2da      	uxtb	r2, r3
 801e042:	f101 0328 	add.w	r3, r1, #40	; 0x28
 801e046:	443b      	add	r3, r7
 801e048:	f803 2c14 	strb.w	r2, [r3, #-20]
		} while (*ap);
 801e04c:	6a3b      	ldr	r3, [r7, #32]
 801e04e:	781b      	ldrb	r3, [r3, #0]
 801e050:	2b00      	cmp	r3, #0
 801e052:	d1da      	bne.n	801e00a <ipv4_addr_ntoa+0x2e>
		while (i--) {
 801e054:	e010      	b.n	801e078 <ipv4_addr_ntoa+0x9c>
			if (len++ >= buflen) {
 801e056:	69bb      	ldr	r3, [r7, #24]
 801e058:	1c5a      	adds	r2, r3, #1
 801e05a:	61ba      	str	r2, [r7, #24]
 801e05c:	687a      	ldr	r2, [r7, #4]
 801e05e:	429a      	cmp	r2, r3
 801e060:	dc01      	bgt.n	801e066 <ipv4_addr_ntoa+0x8a>
				return NULL;
 801e062:	2300      	movs	r3, #0
 801e064:	e02a      	b.n	801e0bc <ipv4_addr_ntoa+0xe0>
			}
			*rp++ = inv[i];
 801e066:	7fba      	ldrb	r2, [r7, #30]
 801e068:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801e06a:	1c59      	adds	r1, r3, #1
 801e06c:	6279      	str	r1, [r7, #36]	; 0x24
 801e06e:	3228      	adds	r2, #40	; 0x28
 801e070:	443a      	add	r2, r7
 801e072:	f812 2c14 	ldrb.w	r2, [r2, #-20]
 801e076:	701a      	strb	r2, [r3, #0]
		while (i--) {
 801e078:	7fbb      	ldrb	r3, [r7, #30]
 801e07a:	1e5a      	subs	r2, r3, #1
 801e07c:	77ba      	strb	r2, [r7, #30]
 801e07e:	2b00      	cmp	r3, #0
 801e080:	d1e9      	bne.n	801e056 <ipv4_addr_ntoa+0x7a>
		}
		if (len++ >= buflen) {
 801e082:	69bb      	ldr	r3, [r7, #24]
 801e084:	1c5a      	adds	r2, r3, #1
 801e086:	61ba      	str	r2, [r7, #24]
 801e088:	687a      	ldr	r2, [r7, #4]
 801e08a:	429a      	cmp	r2, r3
 801e08c:	dc01      	bgt.n	801e092 <ipv4_addr_ntoa+0xb6>
			return NULL;
 801e08e:	2300      	movs	r3, #0
 801e090:	e014      	b.n	801e0bc <ipv4_addr_ntoa+0xe0>
		}
		*rp++ = '.';
 801e092:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801e094:	1c5a      	adds	r2, r3, #1
 801e096:	627a      	str	r2, [r7, #36]	; 0x24
 801e098:	222e      	movs	r2, #46	; 0x2e
 801e09a:	701a      	strb	r2, [r3, #0]
		ap++;
 801e09c:	6a3b      	ldr	r3, [r7, #32]
 801e09e:	3301      	adds	r3, #1
 801e0a0:	623b      	str	r3, [r7, #32]
	for (n = 0; n < 4; n++) {
 801e0a2:	7ffb      	ldrb	r3, [r7, #31]
 801e0a4:	3301      	adds	r3, #1
 801e0a6:	77fb      	strb	r3, [r7, #31]
 801e0a8:	7ffb      	ldrb	r3, [r7, #31]
 801e0aa:	2b03      	cmp	r3, #3
 801e0ac:	d9ab      	bls.n	801e006 <ipv4_addr_ntoa+0x2a>
	}
	*--rp = 0;
 801e0ae:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801e0b0:	3b01      	subs	r3, #1
 801e0b2:	627b      	str	r3, [r7, #36]	; 0x24
 801e0b4:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801e0b6:	2200      	movs	r2, #0
 801e0b8:	701a      	strb	r2, [r3, #0]
	return buf;
 801e0ba:	68bb      	ldr	r3, [r7, #8]
}
 801e0bc:	4618      	mov	r0, r3
 801e0be:	3728      	adds	r7, #40	; 0x28
 801e0c0:	46bd      	mov	sp, r7
 801e0c2:	bd80      	pop	{r7, pc}
 801e0c4:	cccccccd 	.word	0xcccccccd

0801e0c8 <convert_mac_to_bytes>:
  * @param  out - output mac in bytes
  *         s - input mac string
  * @retval STM_OK/STM_FAIL
  */
stm_ret_t convert_mac_to_bytes(uint8_t *out, const char *s)
{
 801e0c8:	b580      	push	{r7, lr}
 801e0ca:	b08e      	sub	sp, #56	; 0x38
 801e0cc:	af04      	add	r7, sp, #16
 801e0ce:	6078      	str	r0, [r7, #4]
 801e0d0:	6039      	str	r1, [r7, #0]
	int mac[MAC_LEN] = {0};
 801e0d2:	f107 030c 	add.w	r3, r7, #12
 801e0d6:	2200      	movs	r2, #0
 801e0d8:	601a      	str	r2, [r3, #0]
 801e0da:	605a      	str	r2, [r3, #4]
 801e0dc:	609a      	str	r2, [r3, #8]
 801e0de:	60da      	str	r2, [r3, #12]
 801e0e0:	611a      	str	r2, [r3, #16]
 801e0e2:	615a      	str	r2, [r3, #20]
	int num_bytes = 0;
 801e0e4:	2300      	movs	r3, #0
 801e0e6:	627b      	str	r3, [r7, #36]	; 0x24

	if (!s || (strlen(s) < MIN_MAC_STRING_LEN))  {
 801e0e8:	683b      	ldr	r3, [r7, #0]
 801e0ea:	2b00      	cmp	r3, #0
 801e0ec:	d005      	beq.n	801e0fa <convert_mac_to_bytes+0x32>
 801e0ee:	6838      	ldr	r0, [r7, #0]
 801e0f0:	f7e2 fa1c 	bl	800052c <strlen>
 801e0f4:	4603      	mov	r3, r0
 801e0f6:	2b10      	cmp	r3, #16
 801e0f8:	d802      	bhi.n	801e100 <convert_mac_to_bytes+0x38>
		return STM_FAIL;
 801e0fa:	f04f 33ff 	mov.w	r3, #4294967295
 801e0fe:	e050      	b.n	801e1a2 <convert_mac_to_bytes+0xda>
	}

	num_bytes =  sscanf(s, "%2x:%2x:%2x:%2x:%2x:%2x",
 801e100:	f107 030c 	add.w	r3, r7, #12
 801e104:	1d19      	adds	r1, r3, #4
 801e106:	f107 020c 	add.w	r2, r7, #12
 801e10a:	f107 030c 	add.w	r3, r7, #12
 801e10e:	3314      	adds	r3, #20
 801e110:	9303      	str	r3, [sp, #12]
 801e112:	f107 030c 	add.w	r3, r7, #12
 801e116:	3310      	adds	r3, #16
 801e118:	9302      	str	r3, [sp, #8]
 801e11a:	f107 030c 	add.w	r3, r7, #12
 801e11e:	330c      	adds	r3, #12
 801e120:	9301      	str	r3, [sp, #4]
 801e122:	f107 030c 	add.w	r3, r7, #12
 801e126:	3308      	adds	r3, #8
 801e128:	9300      	str	r3, [sp, #0]
 801e12a:	460b      	mov	r3, r1
 801e12c:	491f      	ldr	r1, [pc, #124]	; (801e1ac <convert_mac_to_bytes+0xe4>)
 801e12e:	6838      	ldr	r0, [r7, #0]
 801e130:	f002 f942 	bl	80203b8 <siscanf>
 801e134:	6278      	str	r0, [r7, #36]	; 0x24
			&mac[0],&mac[1], &mac[2], &mac[3], &mac[4], &mac[5]);

	if ((num_bytes < MAC_LEN)  ||
 801e136:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801e138:	2b05      	cmp	r3, #5
 801e13a:	dd11      	ble.n	801e160 <convert_mac_to_bytes+0x98>
		(mac[0] > 0xFF) ||
 801e13c:	68fb      	ldr	r3, [r7, #12]
	if ((num_bytes < MAC_LEN)  ||
 801e13e:	2bff      	cmp	r3, #255	; 0xff
 801e140:	dc0e      	bgt.n	801e160 <convert_mac_to_bytes+0x98>
		(mac[1] > 0xFF) ||
 801e142:	693b      	ldr	r3, [r7, #16]
		(mac[0] > 0xFF) ||
 801e144:	2bff      	cmp	r3, #255	; 0xff
 801e146:	dc0b      	bgt.n	801e160 <convert_mac_to_bytes+0x98>
		(mac[2] > 0xFF) ||
 801e148:	697b      	ldr	r3, [r7, #20]
		(mac[1] > 0xFF) ||
 801e14a:	2bff      	cmp	r3, #255	; 0xff
 801e14c:	dc08      	bgt.n	801e160 <convert_mac_to_bytes+0x98>
		(mac[3] > 0xFF) ||
 801e14e:	69bb      	ldr	r3, [r7, #24]
		(mac[2] > 0xFF) ||
 801e150:	2bff      	cmp	r3, #255	; 0xff
 801e152:	dc05      	bgt.n	801e160 <convert_mac_to_bytes+0x98>
		(mac[4] > 0xFF) ||
 801e154:	69fb      	ldr	r3, [r7, #28]
		(mac[3] > 0xFF) ||
 801e156:	2bff      	cmp	r3, #255	; 0xff
 801e158:	dc02      	bgt.n	801e160 <convert_mac_to_bytes+0x98>
		(mac[5] > 0xFF)) {
 801e15a:	6a3b      	ldr	r3, [r7, #32]
		(mac[4] > 0xFF) ||
 801e15c:	2bff      	cmp	r3, #255	; 0xff
 801e15e:	dd02      	ble.n	801e166 <convert_mac_to_bytes+0x9e>
		return STM_FAIL;
 801e160:	f04f 33ff 	mov.w	r3, #4294967295
 801e164:	e01d      	b.n	801e1a2 <convert_mac_to_bytes+0xda>
	}

	out[0] = mac[0]&0xff;
 801e166:	68fb      	ldr	r3, [r7, #12]
 801e168:	b2da      	uxtb	r2, r3
 801e16a:	687b      	ldr	r3, [r7, #4]
 801e16c:	701a      	strb	r2, [r3, #0]
	out[1] = mac[1]&0xff;
 801e16e:	693a      	ldr	r2, [r7, #16]
 801e170:	687b      	ldr	r3, [r7, #4]
 801e172:	3301      	adds	r3, #1
 801e174:	b2d2      	uxtb	r2, r2
 801e176:	701a      	strb	r2, [r3, #0]
	out[2] = mac[2]&0xff;
 801e178:	697a      	ldr	r2, [r7, #20]
 801e17a:	687b      	ldr	r3, [r7, #4]
 801e17c:	3302      	adds	r3, #2
 801e17e:	b2d2      	uxtb	r2, r2
 801e180:	701a      	strb	r2, [r3, #0]
	out[3] = mac[3]&0xff;
 801e182:	69ba      	ldr	r2, [r7, #24]
 801e184:	687b      	ldr	r3, [r7, #4]
 801e186:	3303      	adds	r3, #3
 801e188:	b2d2      	uxtb	r2, r2
 801e18a:	701a      	strb	r2, [r3, #0]
	out[4] = mac[4]&0xff;
 801e18c:	69fa      	ldr	r2, [r7, #28]
 801e18e:	687b      	ldr	r3, [r7, #4]
 801e190:	3304      	adds	r3, #4
 801e192:	b2d2      	uxtb	r2, r2
 801e194:	701a      	strb	r2, [r3, #0]
	out[5] = mac[5]&0xff;
 801e196:	6a3a      	ldr	r2, [r7, #32]
 801e198:	687b      	ldr	r3, [r7, #4]
 801e19a:	3305      	adds	r3, #5
 801e19c:	b2d2      	uxtb	r2, r2
 801e19e:	701a      	strb	r2, [r3, #0]

	return STM_OK;
 801e1a0:	2300      	movs	r3, #0
}
 801e1a2:	4618      	mov	r0, r3
 801e1a4:	3728      	adds	r7, #40	; 0x28
 801e1a6:	46bd      	mov	sp, r7
 801e1a8:	bd80      	pop	{r7, pc}
 801e1aa:	bf00      	nop
 801e1ac:	08025d7c 	.word	0x08025d7c

0801e1b0 <is_same_buff>:
  * @param  buff1 - in bytes
  *         buff2 - in bytes
  * @retval 1 if same, else 0
  */
uint8_t is_same_buff(void *buff1, void *buff2, uint16_t len)
{
 801e1b0:	b480      	push	{r7}
 801e1b2:	b089      	sub	sp, #36	; 0x24
 801e1b4:	af00      	add	r7, sp, #0
 801e1b6:	60f8      	str	r0, [r7, #12]
 801e1b8:	60b9      	str	r1, [r7, #8]
 801e1ba:	4613      	mov	r3, r2
 801e1bc:	80fb      	strh	r3, [r7, #6]
	uint16_t idx;
	uint8_t *b1 = (uint8_t*)buff1;
 801e1be:	68fb      	ldr	r3, [r7, #12]
 801e1c0:	61bb      	str	r3, [r7, #24]
	uint8_t *b2 = (uint8_t*)buff2;
 801e1c2:	68bb      	ldr	r3, [r7, #8]
 801e1c4:	617b      	str	r3, [r7, #20]

	if ((b1 == NULL) && (b2==NULL)) {
 801e1c6:	69bb      	ldr	r3, [r7, #24]
 801e1c8:	2b00      	cmp	r3, #0
 801e1ca:	d109      	bne.n	801e1e0 <is_same_buff+0x30>
 801e1cc:	697b      	ldr	r3, [r7, #20]
 801e1ce:	2b00      	cmp	r3, #0
 801e1d0:	d106      	bne.n	801e1e0 <is_same_buff+0x30>
		if(len) {
 801e1d2:	88fb      	ldrh	r3, [r7, #6]
 801e1d4:	2b00      	cmp	r3, #0
 801e1d6:	d001      	beq.n	801e1dc <is_same_buff+0x2c>
			return 0;
 801e1d8:	2300      	movs	r3, #0
 801e1da:	e022      	b.n	801e222 <is_same_buff+0x72>
		}
		return 1;
 801e1dc:	2301      	movs	r3, #1
 801e1de:	e020      	b.n	801e222 <is_same_buff+0x72>
	}

	if(!b1 || !b2) {
 801e1e0:	69bb      	ldr	r3, [r7, #24]
 801e1e2:	2b00      	cmp	r3, #0
 801e1e4:	d002      	beq.n	801e1ec <is_same_buff+0x3c>
 801e1e6:	697b      	ldr	r3, [r7, #20]
 801e1e8:	2b00      	cmp	r3, #0
 801e1ea:	d101      	bne.n	801e1f0 <is_same_buff+0x40>
		return 0;
 801e1ec:	2300      	movs	r3, #0
 801e1ee:	e018      	b.n	801e222 <is_same_buff+0x72>
	}

	/* Function assumes buff1 and buff2 are allocated for len */
	for (idx=0; idx < len; idx++) {
 801e1f0:	2300      	movs	r3, #0
 801e1f2:	83fb      	strh	r3, [r7, #30]
 801e1f4:	e010      	b.n	801e218 <is_same_buff+0x68>
		if (*b1 != *b2) {
 801e1f6:	69bb      	ldr	r3, [r7, #24]
 801e1f8:	781a      	ldrb	r2, [r3, #0]
 801e1fa:	697b      	ldr	r3, [r7, #20]
 801e1fc:	781b      	ldrb	r3, [r3, #0]
 801e1fe:	429a      	cmp	r2, r3
 801e200:	d001      	beq.n	801e206 <is_same_buff+0x56>
			return 0;
 801e202:	2300      	movs	r3, #0
 801e204:	e00d      	b.n	801e222 <is_same_buff+0x72>
		}
		b1++;
 801e206:	69bb      	ldr	r3, [r7, #24]
 801e208:	3301      	adds	r3, #1
 801e20a:	61bb      	str	r3, [r7, #24]
		b2++;
 801e20c:	697b      	ldr	r3, [r7, #20]
 801e20e:	3301      	adds	r3, #1
 801e210:	617b      	str	r3, [r7, #20]
	for (idx=0; idx < len; idx++) {
 801e212:	8bfb      	ldrh	r3, [r7, #30]
 801e214:	3301      	adds	r3, #1
 801e216:	83fb      	strh	r3, [r7, #30]
 801e218:	8bfa      	ldrh	r2, [r7, #30]
 801e21a:	88fb      	ldrh	r3, [r7, #6]
 801e21c:	429a      	cmp	r2, r3
 801e21e:	d3ea      	bcc.n	801e1f6 <is_same_buff+0x46>
	}
	return 1;
 801e220:	2301      	movs	r3, #1
}
 801e222:	4618      	mov	r0, r3
 801e224:	3724      	adds	r7, #36	; 0x24
 801e226:	46bd      	mov	sp, r7
 801e228:	f85d 7b04 	ldr.w	r7, [sp], #4
 801e22c:	4770      	bx	lr

0801e22e <get_ipaddr_from_str>:
  * @param  ip_s - input ip address in string
  *         ip_x - output ip address in 32 bit
  * @retval STM_OK/STM_FAIL
  */
stm_ret_t get_ipaddr_from_str(const char *ip_s, uint32_t *ip_x)
{
 801e22e:	b580      	push	{r7, lr}
 801e230:	b084      	sub	sp, #16
 801e232:	af00      	add	r7, sp, #0
 801e234:	6078      	str	r0, [r7, #4]
 801e236:	6039      	str	r1, [r7, #0]
	uint32_t ip_nw = 0;
 801e238:	2300      	movs	r3, #0
 801e23a:	60fb      	str	r3, [r7, #12]
	if (! ipv4_addr_aton(ip_s, &ip_nw))
 801e23c:	f107 030c 	add.w	r3, r7, #12
 801e240:	4619      	mov	r1, r3
 801e242:	6878      	ldr	r0, [r7, #4]
 801e244:	f7ff fdd6 	bl	801ddf4 <ipv4_addr_aton>
 801e248:	4603      	mov	r3, r0
 801e24a:	2b00      	cmp	r3, #0
 801e24c:	d102      	bne.n	801e254 <get_ipaddr_from_str+0x26>
	{
		return STM_FAIL;
 801e24e:	f04f 33ff 	mov.w	r3, #4294967295
 801e252:	e007      	b.n	801e264 <get_ipaddr_from_str+0x36>
	}
	/* ipv4_addr_aton does conversion in network order. reverse */
	*ip_x = ntoh_long(ip_nw);
 801e254:	68fb      	ldr	r3, [r7, #12]
 801e256:	4618      	mov	r0, r3
 801e258:	f7ff fd0d 	bl	801dc76 <hton_long>
 801e25c:	4602      	mov	r2, r0
 801e25e:	683b      	ldr	r3, [r7, #0]
 801e260:	601a      	str	r2, [r3, #0]
	return STM_OK;
 801e262:	2300      	movs	r3, #0
}
 801e264:	4618      	mov	r0, r3
 801e266:	3710      	adds	r7, #16
 801e268:	46bd      	mov	sp, r7
 801e26a:	bd80      	pop	{r7, pc}

0801e26c <network_init>:
  * @brief  init network interface
  * @param  None
  * @retval STM_OK/STM_FAIL
  */
int network_init(void)
{
 801e26c:	b580      	push	{r7, lr}
 801e26e:	af00      	add	r7, sp, #0
	netdev_init();
 801e270:	f000 f8b8 	bl	801e3e4 <netdev_init>
	return STM_OK;
 801e274:	2300      	movs	r3, #0
}
 801e276:	4618      	mov	r0, r3
 801e278:	bd80      	pop	{r7, pc}
	...

0801e27c <network_open>:
  * @param  if_name - interfae to open
  *         net_rx_callback - callback called on incoming data
  * @retval handle of network interface
  */
struct network_handle * network_open(char *if_name, void (* net_rx_callback)(struct network_handle *))
{
 801e27c:	b580      	push	{r7, lr}
 801e27e:	b084      	sub	sp, #16
 801e280:	af00      	add	r7, sp, #0
 801e282:	6078      	str	r0, [r7, #4]
 801e284:	6039      	str	r1, [r7, #0]
	struct netdev *ndev = NULL;
 801e286:	2300      	movs	r3, #0
 801e288:	60fb      	str	r3, [r7, #12]
	struct network_handle *net_handle = NULL;
 801e28a:	2300      	movs	r3, #0
 801e28c:	60bb      	str	r3, [r7, #8]

	if (!if_name)
 801e28e:	687b      	ldr	r3, [r7, #4]
 801e290:	2b00      	cmp	r3, #0
 801e292:	d101      	bne.n	801e298 <network_open+0x1c>
		return NULL;
 801e294:	2300      	movs	r3, #0
 801e296:	e028      	b.n	801e2ea <network_open+0x6e>

	ndev = netdev_get(if_name);
 801e298:	6878      	ldr	r0, [r7, #4]
 801e29a:	f000 f8fb 	bl	801e494 <netdev_get>
 801e29e:	60f8      	str	r0, [r7, #12]

	if (!ndev) {
 801e2a0:	68fb      	ldr	r3, [r7, #12]
 801e2a2:	2b00      	cmp	r3, #0
 801e2a4:	d104      	bne.n	801e2b0 <network_open+0x34>
		printf ("Invalid interface name\n");
 801e2a6:	4813      	ldr	r0, [pc, #76]	; (801e2f4 <network_open+0x78>)
 801e2a8:	f001 fffc 	bl	80202a4 <puts>
		return NULL;
 801e2ac:	2300      	movs	r3, #0
 801e2ae:	e01c      	b.n	801e2ea <network_open+0x6e>
	}

	/* create network handle */
	net_handle = malloc(sizeof(struct network_handle));
 801e2b0:	2008      	movs	r0, #8
 801e2b2:	f7ff f8b9 	bl	801d428 <esp_hosted_malloc>
 801e2b6:	60b8      	str	r0, [r7, #8]

	net_handle->ndev = ndev;
 801e2b8:	68bb      	ldr	r3, [r7, #8]
 801e2ba:	68fa      	ldr	r2, [r7, #12]
 801e2bc:	601a      	str	r2, [r3, #0]
	net_handle->net_rx_callback = net_rx_callback;
 801e2be:	68bb      	ldr	r3, [r7, #8]
 801e2c0:	683a      	ldr	r2, [r7, #0]
 801e2c2:	605a      	str	r2, [r3, #4]

	if (netdev_open(ndev)) {
 801e2c4:	68f8      	ldr	r0, [r7, #12]
 801e2c6:	f000 f8a7 	bl	801e418 <netdev_open>
 801e2ca:	4603      	mov	r3, r0
 801e2cc:	2b00      	cmp	r3, #0
 801e2ce:	d007      	beq.n	801e2e0 <network_open+0x64>
		printf ("Failed to setup netdev\n");
 801e2d0:	4809      	ldr	r0, [pc, #36]	; (801e2f8 <network_open+0x7c>)
 801e2d2:	f001 ffe7 	bl	80202a4 <puts>
		free(net_handle);
 801e2d6:	68b8      	ldr	r0, [r7, #8]
 801e2d8:	f7ff f8d6 	bl	801d488 <esp_hosted_free>
		return NULL;
 801e2dc:	2300      	movs	r3, #0
 801e2de:	e004      	b.n	801e2ea <network_open+0x6e>
	}

	ndev->net_handle = net_handle;
 801e2e0:	68fb      	ldr	r3, [r7, #12]
 801e2e2:	68ba      	ldr	r2, [r7, #8]
 801e2e4:	f8c3 2108 	str.w	r2, [r3, #264]	; 0x108

	return net_handle;
 801e2e8:	68bb      	ldr	r3, [r7, #8]
}
 801e2ea:	4618      	mov	r0, r3
 801e2ec:	3710      	adds	r7, #16
 801e2ee:	46bd      	mov	sp, r7
 801e2f0:	bd80      	pop	{r7, pc}
 801e2f2:	bf00      	nop
 801e2f4:	08025d94 	.word	0x08025d94
 801e2f8:	08025dac 	.word	0x08025dac

0801e2fc <network_read>:
  *         net_rx_callback - callback called on incoming data
  *         xTicksToWait - wait for ticks
  * @retval buffer read
  */
struct pbuf * network_read(struct network_handle *handle, uint32_t xTicksToWait)
{
 801e2fc:	b580      	push	{r7, lr}
 801e2fe:	b084      	sub	sp, #16
 801e300:	af00      	add	r7, sp, #0
 801e302:	6078      	str	r0, [r7, #4]
 801e304:	6039      	str	r1, [r7, #0]
	UINT status;
	struct pbuf *buffer = NULL;
 801e306:	2300      	movs	r3, #0
 801e308:	60fb      	str	r3, [r7, #12]

	if (!handle || !handle->ndev)
 801e30a:	687b      	ldr	r3, [r7, #4]
 801e30c:	2b00      	cmp	r3, #0
 801e30e:	d003      	beq.n	801e318 <network_read+0x1c>
 801e310:	687b      	ldr	r3, [r7, #4]
 801e312:	681b      	ldr	r3, [r3, #0]
 801e314:	2b00      	cmp	r3, #0
 801e316:	d101      	bne.n	801e31c <network_read+0x20>
		return NULL;
 801e318:	2300      	movs	r3, #0
 801e31a:	e026      	b.n	801e36a <network_read+0x6e>

	buffer = malloc(sizeof(struct pbuf));
 801e31c:	2008      	movs	r0, #8
 801e31e:	f7ff f883 	bl	801d428 <esp_hosted_malloc>
 801e322:	60f8      	str	r0, [r7, #12]

	if (!buffer)
 801e324:	68fb      	ldr	r3, [r7, #12]
 801e326:	2b00      	cmp	r3, #0
 801e328:	d101      	bne.n	801e32e <network_read+0x32>
		return NULL;
 801e32a:	2300      	movs	r3, #0
 801e32c:	e01d      	b.n	801e36a <network_read+0x6e>

	status = tx_queue_receive(&(handle->ndev->rx_q), buffer, xTicksToWait);
 801e32e:	687b      	ldr	r3, [r7, #4]
 801e330:	681b      	ldr	r3, [r3, #0]
 801e332:	f503 7386 	add.w	r3, r3, #268	; 0x10c
 801e336:	683a      	ldr	r2, [r7, #0]
 801e338:	68f9      	ldr	r1, [r7, #12]
 801e33a:	4618      	mov	r0, r3
 801e33c:	f7f8 f90a 	bl	8016554 <_txe_queue_receive>
 801e340:	60b8      	str	r0, [r7, #8]
	if (status == TX_SUCCESS) {
 801e342:	68bb      	ldr	r3, [r7, #8]
 801e344:	2b00      	cmp	r3, #0
 801e346:	d101      	bne.n	801e34c <network_read+0x50>
		return buffer;
 801e348:	68fb      	ldr	r3, [r7, #12]
 801e34a:	e00e      	b.n	801e36a <network_read+0x6e>
	} else if (status == TX_QUEUE_EMPTY) {
 801e34c:	68bb      	ldr	r3, [r7, #8]
 801e34e:	2b0a      	cmp	r3, #10
 801e350:	d103      	bne.n	801e35a <network_read+0x5e>
		printf("WARNING: No data available for network_read\r\n");
 801e352:	4808      	ldr	r0, [pc, #32]	; (801e374 <network_read+0x78>)
 801e354:	f001 ffa6 	bl	80202a4 <puts>
 801e358:	e003      	b.n	801e362 <network_read+0x66>
	} else {
		printf("ERROR: tx_queue_receive return %d\r\n", status);
 801e35a:	68b9      	ldr	r1, [r7, #8]
 801e35c:	4806      	ldr	r0, [pc, #24]	; (801e378 <network_read+0x7c>)
 801e35e:	f001 ff05 	bl	802016c <iprintf>
	}

	free(buffer);
 801e362:	68f8      	ldr	r0, [r7, #12]
 801e364:	f7ff f890 	bl	801d488 <esp_hosted_free>
	return NULL;
 801e368:	2300      	movs	r3, #0
}
 801e36a:	4618      	mov	r0, r3
 801e36c:	3710      	adds	r7, #16
 801e36e:	46bd      	mov	sp, r7
 801e370:	bd80      	pop	{r7, pc}
 801e372:	bf00      	nop
 801e374:	08025dc4 	.word	0x08025dc4
 801e378:	08025df4 	.word	0x08025df4

0801e37c <network_write>:
  * @param  handle - network interface handle
  *         buffer - buffer to transmit
  * @retval 0 on success
  */
int network_write(struct network_handle *net_handle, struct pbuf *buffer)
{
 801e37c:	b580      	push	{r7, lr}
 801e37e:	b084      	sub	sp, #16
 801e380:	af00      	add	r7, sp, #0
 801e382:	6078      	str	r0, [r7, #4]
 801e384:	6039      	str	r1, [r7, #0]
	struct netdev *ndev;
	int ret = STM_FAIL;
 801e386:	f04f 33ff 	mov.w	r3, #4294967295
 801e38a:	60fb      	str	r3, [r7, #12]

	if (!net_handle || !buffer)
 801e38c:	687b      	ldr	r3, [r7, #4]
 801e38e:	2b00      	cmp	r3, #0
 801e390:	d002      	beq.n	801e398 <network_write+0x1c>
 801e392:	683b      	ldr	r3, [r7, #0]
 801e394:	2b00      	cmp	r3, #0
 801e396:	d102      	bne.n	801e39e <network_write+0x22>
		return STM_FAIL;
 801e398:	f04f 33ff 	mov.w	r3, #4294967295
 801e39c:	e01e      	b.n	801e3dc <network_write+0x60>

	ndev = net_handle->ndev;
 801e39e:	687b      	ldr	r3, [r7, #4]
 801e3a0:	681b      	ldr	r3, [r3, #0]
 801e3a2:	60bb      	str	r3, [r7, #8]

	if (ndev && (ndev->state == NETDEV_STATE_UP)) {
 801e3a4:	68bb      	ldr	r3, [r7, #8]
 801e3a6:	2b00      	cmp	r3, #0
 801e3a8:	d017      	beq.n	801e3da <network_write+0x5e>
 801e3aa:	68bb      	ldr	r3, [r7, #8]
 801e3ac:	f893 3104 	ldrb.w	r3, [r3, #260]	; 0x104
 801e3b0:	2b01      	cmp	r3, #1
 801e3b2:	d112      	bne.n	801e3da <network_write+0x5e>
		if (ndev->net_ops && ndev->net_ops->netdev_xmit) {
 801e3b4:	68bb      	ldr	r3, [r7, #8]
 801e3b6:	f8d3 3100 	ldr.w	r3, [r3, #256]	; 0x100
 801e3ba:	2b00      	cmp	r3, #0
 801e3bc:	d00d      	beq.n	801e3da <network_write+0x5e>
 801e3be:	68bb      	ldr	r3, [r7, #8]
 801e3c0:	f8d3 3100 	ldr.w	r3, [r3, #256]	; 0x100
 801e3c4:	689b      	ldr	r3, [r3, #8]
 801e3c6:	2b00      	cmp	r3, #0
 801e3c8:	d007      	beq.n	801e3da <network_write+0x5e>
			ret = ndev->net_ops->netdev_xmit(ndev, buffer);
 801e3ca:	68bb      	ldr	r3, [r7, #8]
 801e3cc:	f8d3 3100 	ldr.w	r3, [r3, #256]	; 0x100
 801e3d0:	689b      	ldr	r3, [r3, #8]
 801e3d2:	6839      	ldr	r1, [r7, #0]
 801e3d4:	68b8      	ldr	r0, [r7, #8]
 801e3d6:	4798      	blx	r3
 801e3d8:	60f8      	str	r0, [r7, #12]
		}
	}

	return ret;
 801e3da:	68fb      	ldr	r3, [r7, #12]
}
 801e3dc:	4618      	mov	r0, r3
 801e3de:	3710      	adds	r7, #16
 801e3e0:	46bd      	mov	sp, r7
 801e3e2:	bd80      	pop	{r7, pc}

0801e3e4 <netdev_init>:
  * @brief  initialize detdev
  * @param  None
  * @retval None
  */
void netdev_init(void)
{
 801e3e4:	b480      	push	{r7}
 801e3e6:	b083      	sub	sp, #12
 801e3e8:	af00      	add	r7, sp, #0
	int i;

	for (i = 0; i < MAX_INTERFACE; i++) {
 801e3ea:	2300      	movs	r3, #0
 801e3ec:	607b      	str	r3, [r7, #4]
 801e3ee:	e007      	b.n	801e400 <netdev_init+0x1c>
		ndev_db[i] = NULL;
 801e3f0:	4a08      	ldr	r2, [pc, #32]	; (801e414 <netdev_init+0x30>)
 801e3f2:	687b      	ldr	r3, [r7, #4]
 801e3f4:	2100      	movs	r1, #0
 801e3f6:	f842 1023 	str.w	r1, [r2, r3, lsl #2]
	for (i = 0; i < MAX_INTERFACE; i++) {
 801e3fa:	687b      	ldr	r3, [r7, #4]
 801e3fc:	3301      	adds	r3, #1
 801e3fe:	607b      	str	r3, [r7, #4]
 801e400:	687b      	ldr	r3, [r7, #4]
 801e402:	2b01      	cmp	r3, #1
 801e404:	ddf4      	ble.n	801e3f0 <netdev_init+0xc>
	}
}
 801e406:	bf00      	nop
 801e408:	bf00      	nop
 801e40a:	370c      	adds	r7, #12
 801e40c:	46bd      	mov	sp, r7
 801e40e:	f85d 7b04 	ldr.w	r7, [sp], #4
 801e412:	4770      	bx	lr
 801e414:	24049c40 	.word	0x24049c40

0801e418 <netdev_open>:
  * @brief  open netdev
  * @param  ndev - netdev
  * @retval 0 on success
  */
int netdev_open(netdev_handle_t ndev)
{
 801e418:	b580      	push	{r7, lr}
 801e41a:	b084      	sub	sp, #16
 801e41c:	af02      	add	r7, sp, #8
 801e41e:	6078      	str	r0, [r7, #4]
	if (!ndev)
 801e420:	687b      	ldr	r3, [r7, #4]
 801e422:	2b00      	cmp	r3, #0
 801e424:	d102      	bne.n	801e42c <netdev_open+0x14>
		return STM_FAIL;
 801e426:	f04f 33ff 	mov.w	r3, #4294967295
 801e42a:	e02e      	b.n	801e48a <netdev_open+0x72>

	if (ndev->rx_q.tx_queue_id != TX_CLEAR_ID) {
 801e42c:	687b      	ldr	r3, [r7, #4]
 801e42e:	f8d3 310c 	ldr.w	r3, [r3, #268]	; 0x10c
 801e432:	2b00      	cmp	r3, #0
 801e434:	d007      	beq.n	801e446 <netdev_open+0x2e>
		(VOID)tx_queue_flush(&(ndev->rx_q));
 801e436:	687b      	ldr	r3, [r7, #4]
 801e438:	f503 7386 	add.w	r3, r3, #268	; 0x10c
 801e43c:	4618      	mov	r0, r3
 801e43e:	f7f8 f86b 	bl	8016518 <_txe_queue_flush>
		return STM_OK;
 801e442:	2300      	movs	r3, #0
 801e444:	e021      	b.n	801e48a <netdev_open+0x72>
	}

	ndev->rx_q_buffer = malloc(RX_QUEUE_SIZE * sizeof(struct pbuf));
 801e446:	f44f 70c8 	mov.w	r0, #400	; 0x190
 801e44a:	f7fe ffed 	bl	801d428 <esp_hosted_malloc>
 801e44e:	4602      	mov	r2, r0
 801e450:	687b      	ldr	r3, [r7, #4]
 801e452:	f8c3 2144 	str.w	r2, [r3, #324]	; 0x144
	if (tx_queue_create(&(ndev->rx_q), ndev->name, sizeof(struct pbuf) / sizeof(ULONG), ndev->rx_q_buffer, RX_QUEUE_SIZE * sizeof(struct pbuf)) != TX_SUCCESS)
 801e456:	687b      	ldr	r3, [r7, #4]
 801e458:	f503 7086 	add.w	r0, r3, #268	; 0x10c
 801e45c:	6879      	ldr	r1, [r7, #4]
 801e45e:	687b      	ldr	r3, [r7, #4]
 801e460:	f8d3 3144 	ldr.w	r3, [r3, #324]	; 0x144
 801e464:	2238      	movs	r2, #56	; 0x38
 801e466:	9201      	str	r2, [sp, #4]
 801e468:	f44f 72c8 	mov.w	r2, #400	; 0x190
 801e46c:	9200      	str	r2, [sp, #0]
 801e46e:	2202      	movs	r2, #2
 801e470:	f7f7 ff64 	bl	801633c <_txe_queue_create>
 801e474:	4603      	mov	r3, r0
 801e476:	2b00      	cmp	r3, #0
 801e478:	d002      	beq.n	801e480 <netdev_open+0x68>
		return STM_FAIL;
 801e47a:	f04f 33ff 	mov.w	r3, #4294967295
 801e47e:	e004      	b.n	801e48a <netdev_open+0x72>

	ndev->state = NETDEV_STATE_UP;
 801e480:	687b      	ldr	r3, [r7, #4]
 801e482:	2201      	movs	r2, #1
 801e484:	f883 2104 	strb.w	r2, [r3, #260]	; 0x104

	return STM_OK;
 801e488:	2300      	movs	r3, #0
}
 801e48a:	4618      	mov	r0, r3
 801e48c:	3708      	adds	r7, #8
 801e48e:	46bd      	mov	sp, r7
 801e490:	bd80      	pop	{r7, pc}
	...

0801e494 <netdev_get>:
  * @brief  get netdev handle from interface name
  * @param  if_name - interface name
  * @retval netdev handle
  */
struct netdev * netdev_get(char *if_name)
{
 801e494:	b580      	push	{r7, lr}
 801e496:	b084      	sub	sp, #16
 801e498:	af00      	add	r7, sp, #0
 801e49a:	6078      	str	r0, [r7, #4]
	int i = 0;
 801e49c:	2300      	movs	r3, #0
 801e49e:	60fb      	str	r3, [r7, #12]
	struct netdev *ndev;

	if (!if_name)
 801e4a0:	687b      	ldr	r3, [r7, #4]
 801e4a2:	2b00      	cmp	r3, #0
 801e4a4:	d118      	bne.n	801e4d8 <netdev_get+0x44>
		return NULL;
 801e4a6:	2300      	movs	r3, #0
 801e4a8:	e01a      	b.n	801e4e0 <netdev_get+0x4c>

	while (i < MAX_INTERFACE) {
		ndev = ndev_db[i];
 801e4aa:	4a0f      	ldr	r2, [pc, #60]	; (801e4e8 <netdev_get+0x54>)
 801e4ac:	68fb      	ldr	r3, [r7, #12]
 801e4ae:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 801e4b2:	60bb      	str	r3, [r7, #8]

		if (ndev) {
 801e4b4:	68bb      	ldr	r3, [r7, #8]
 801e4b6:	2b00      	cmp	r3, #0
 801e4b8:	d00b      	beq.n	801e4d2 <netdev_get+0x3e>
			if (strncmp(if_name, ndev->name, MAX_IF_NAME_SIZE) == 0)
 801e4ba:	68bb      	ldr	r3, [r7, #8]
 801e4bc:	f44f 7280 	mov.w	r2, #256	; 0x100
 801e4c0:	4619      	mov	r1, r3
 801e4c2:	6878      	ldr	r0, [r7, #4]
 801e4c4:	f002 f9f2 	bl	80208ac <strncmp>
 801e4c8:	4603      	mov	r3, r0
 801e4ca:	2b00      	cmp	r3, #0
 801e4cc:	d101      	bne.n	801e4d2 <netdev_get+0x3e>
				return ndev;
 801e4ce:	68bb      	ldr	r3, [r7, #8]
 801e4d0:	e006      	b.n	801e4e0 <netdev_get+0x4c>
		}

		i++;
 801e4d2:	68fb      	ldr	r3, [r7, #12]
 801e4d4:	3301      	adds	r3, #1
 801e4d6:	60fb      	str	r3, [r7, #12]
	while (i < MAX_INTERFACE) {
 801e4d8:	68fb      	ldr	r3, [r7, #12]
 801e4da:	2b01      	cmp	r3, #1
 801e4dc:	dde5      	ble.n	801e4aa <netdev_get+0x16>
	}

	return NULL;
 801e4de:	2300      	movs	r3, #0
}
 801e4e0:	4618      	mov	r0, r3
 801e4e2:	3710      	adds	r7, #16
 801e4e4:	46bd      	mov	sp, r7
 801e4e6:	bd80      	pop	{r7, pc}
 801e4e8:	24049c40 	.word	0x24049c40

0801e4ec <netdev_alloc>:
  * @param  sizeof_priv - size of priv interface
  *         name - interface name
  * @retval allocated netdev
  */
netdev_handle_t netdev_alloc(uint32_t sizeof_priv, char *name)
{
 801e4ec:	b580      	push	{r7, lr}
 801e4ee:	b084      	sub	sp, #16
 801e4f0:	af00      	add	r7, sp, #0
 801e4f2:	6078      	str	r0, [r7, #4]
 801e4f4:	6039      	str	r1, [r7, #0]
	struct netdev *ndev = NULL;
 801e4f6:	2300      	movs	r3, #0
 801e4f8:	60fb      	str	r3, [r7, #12]

	if (!name)
 801e4fa:	683b      	ldr	r3, [r7, #0]
 801e4fc:	2b00      	cmp	r3, #0
 801e4fe:	d101      	bne.n	801e504 <netdev_alloc+0x18>
		return NULL;
 801e500:	2300      	movs	r3, #0
 801e502:	e02e      	b.n	801e562 <netdev_alloc+0x76>

	ndev = (struct netdev *) malloc(sizeof(struct netdev));
 801e504:	f44f 70a6 	mov.w	r0, #332	; 0x14c
 801e508:	f7fe ff8e 	bl	801d428 <esp_hosted_malloc>
 801e50c:	60f8      	str	r0, [r7, #12]

	if (ndev) {
 801e50e:	68fb      	ldr	r3, [r7, #12]
 801e510:	2b00      	cmp	r3, #0
 801e512:	d022      	beq.n	801e55a <netdev_alloc+0x6e>
		memset(ndev, 0, sizeof(struct netdev));
 801e514:	f44f 72a6 	mov.w	r2, #332	; 0x14c
 801e518:	2100      	movs	r1, #0
 801e51a:	68f8      	ldr	r0, [r7, #12]
 801e51c:	f001 f9ae 	bl	801f87c <memset>
		memcpy(ndev->name, name, MAX_IF_NAME_SIZE);
 801e520:	68fb      	ldr	r3, [r7, #12]
 801e522:	f44f 7280 	mov.w	r2, #256	; 0x100
 801e526:	6839      	ldr	r1, [r7, #0]
 801e528:	4618      	mov	r0, r3
 801e52a:	f001 f97f 	bl	801f82c <memcpy>

		ndev->priv = malloc(sizeof_priv);
 801e52e:	6878      	ldr	r0, [r7, #4]
 801e530:	f7fe ff7a 	bl	801d428 <esp_hosted_malloc>
 801e534:	4602      	mov	r2, r0
 801e536:	68fb      	ldr	r3, [r7, #12]
 801e538:	f8c3 2148 	str.w	r2, [r3, #328]	; 0x148

		if (!ndev->priv) {
 801e53c:	68fb      	ldr	r3, [r7, #12]
 801e53e:	f8d3 3148 	ldr.w	r3, [r3, #328]	; 0x148
 801e542:	2b00      	cmp	r3, #0
 801e544:	d10c      	bne.n	801e560 <netdev_alloc+0x74>
			printf("Failed to allocate memory for priv\n");
 801e546:	4809      	ldr	r0, [pc, #36]	; (801e56c <netdev_alloc+0x80>)
 801e548:	f001 feac 	bl	80202a4 <puts>
			free(ndev);
 801e54c:	68f8      	ldr	r0, [r7, #12]
 801e54e:	f7fe ff9b 	bl	801d488 <esp_hosted_free>
			ndev = NULL;
 801e552:	2300      	movs	r3, #0
 801e554:	60fb      	str	r3, [r7, #12]
			return NULL;
 801e556:	2300      	movs	r3, #0
 801e558:	e003      	b.n	801e562 <netdev_alloc+0x76>
		}
	} else {
		printf("Failed to allocate memory for net dev\n");
 801e55a:	4805      	ldr	r0, [pc, #20]	; (801e570 <netdev_alloc+0x84>)
 801e55c:	f001 fea2 	bl	80202a4 <puts>
	}

	return ndev;
 801e560:	68fb      	ldr	r3, [r7, #12]
}
 801e562:	4618      	mov	r0, r3
 801e564:	3710      	adds	r7, #16
 801e566:	46bd      	mov	sp, r7
 801e568:	bd80      	pop	{r7, pc}
 801e56a:	bf00      	nop
 801e56c:	08025e18 	.word	0x08025e18
 801e570:	08025e3c 	.word	0x08025e3c

0801e574 <netdev_free>:
  * @brief  free netdev's private handle
  * @param  dev - netdev handle
  * @retval None
  */
void netdev_free(netdev_handle_t dev)
{
 801e574:	b580      	push	{r7, lr}
 801e576:	b084      	sub	sp, #16
 801e578:	af00      	add	r7, sp, #0
 801e57a:	6078      	str	r0, [r7, #4]
	struct netdev *ndev = (struct netdev *) dev;
 801e57c:	687b      	ldr	r3, [r7, #4]
 801e57e:	60fb      	str	r3, [r7, #12]

	if (ndev) {
 801e580:	68fb      	ldr	r3, [r7, #12]
 801e582:	2b00      	cmp	r3, #0
 801e584:	d022      	beq.n	801e5cc <netdev_free+0x58>
		if (ndev->priv) {
 801e586:	68fb      	ldr	r3, [r7, #12]
 801e588:	f8d3 3148 	ldr.w	r3, [r3, #328]	; 0x148
 801e58c:	2b00      	cmp	r3, #0
 801e58e:	d009      	beq.n	801e5a4 <netdev_free+0x30>
			free(ndev->priv);
 801e590:	68fb      	ldr	r3, [r7, #12]
 801e592:	f8d3 3148 	ldr.w	r3, [r3, #328]	; 0x148
 801e596:	4618      	mov	r0, r3
 801e598:	f7fe ff76 	bl	801d488 <esp_hosted_free>
			ndev->priv = NULL;
 801e59c:	68fb      	ldr	r3, [r7, #12]
 801e59e:	2200      	movs	r2, #0
 801e5a0:	f8c3 2148 	str.w	r2, [r3, #328]	; 0x148
		}

		if (ndev->net_handle) {
 801e5a4:	68fb      	ldr	r3, [r7, #12]
 801e5a6:	f8d3 3108 	ldr.w	r3, [r3, #264]	; 0x108
 801e5aa:	2b00      	cmp	r3, #0
 801e5ac:	d009      	beq.n	801e5c2 <netdev_free+0x4e>
			free(ndev->net_handle);
 801e5ae:	68fb      	ldr	r3, [r7, #12]
 801e5b0:	f8d3 3108 	ldr.w	r3, [r3, #264]	; 0x108
 801e5b4:	4618      	mov	r0, r3
 801e5b6:	f7fe ff67 	bl	801d488 <esp_hosted_free>
			ndev->net_handle = NULL;
 801e5ba:	68fb      	ldr	r3, [r7, #12]
 801e5bc:	2200      	movs	r2, #0
 801e5be:	f8c3 2108 	str.w	r2, [r3, #264]	; 0x108
		}


		free(ndev);
 801e5c2:	68f8      	ldr	r0, [r7, #12]
 801e5c4:	f7fe ff60 	bl	801d488 <esp_hosted_free>
		ndev = NULL;
 801e5c8:	2300      	movs	r3, #0
 801e5ca:	60fb      	str	r3, [r7, #12]
	}
}
 801e5cc:	bf00      	nop
 801e5ce:	3710      	adds	r7, #16
 801e5d0:	46bd      	mov	sp, r7
 801e5d2:	bd80      	pop	{r7, pc}

0801e5d4 <netdev_get_priv>:
  * @brief  get netdev's private interface
  * @param  dev - private interface
  * @retval private interface handle on success else NULL
  */
void * netdev_get_priv(netdev_handle_t dev)
{
 801e5d4:	b480      	push	{r7}
 801e5d6:	b085      	sub	sp, #20
 801e5d8:	af00      	add	r7, sp, #0
 801e5da:	6078      	str	r0, [r7, #4]
	struct netdev *ndev = (struct netdev *) dev;
 801e5dc:	687b      	ldr	r3, [r7, #4]
 801e5de:	60fb      	str	r3, [r7, #12]

	if (ndev) {
 801e5e0:	68fb      	ldr	r3, [r7, #12]
 801e5e2:	2b00      	cmp	r3, #0
 801e5e4:	d003      	beq.n	801e5ee <netdev_get_priv+0x1a>
		return ndev->priv;
 801e5e6:	68fb      	ldr	r3, [r7, #12]
 801e5e8:	f8d3 3148 	ldr.w	r3, [r3, #328]	; 0x148
 801e5ec:	e000      	b.n	801e5f0 <netdev_get_priv+0x1c>
	}

	return NULL;
 801e5ee:	2300      	movs	r3, #0
}
 801e5f0:	4618      	mov	r0, r3
 801e5f2:	3714      	adds	r7, #20
 801e5f4:	46bd      	mov	sp, r7
 801e5f6:	f85d 7b04 	ldr.w	r7, [sp], #4
 801e5fa:	4770      	bx	lr

0801e5fc <netdev_register>:
  * @param  dev - private interface
  *         ops - network options to register
  * @retval 0 on success, else -1
  */
int netdev_register(netdev_handle_t dev, struct netdev_ops *ops)
{
 801e5fc:	b580      	push	{r7, lr}
 801e5fe:	b084      	sub	sp, #16
 801e600:	af00      	add	r7, sp, #0
 801e602:	6078      	str	r0, [r7, #4]
 801e604:	6039      	str	r1, [r7, #0]
	struct netdev *ndev = (struct netdev *) dev;
 801e606:	687b      	ldr	r3, [r7, #4]
 801e608:	60fb      	str	r3, [r7, #12]

	if (!ndev || !ops) {
 801e60a:	68fb      	ldr	r3, [r7, #12]
 801e60c:	2b00      	cmp	r3, #0
 801e60e:	d002      	beq.n	801e616 <netdev_register+0x1a>
 801e610:	683b      	ldr	r3, [r7, #0]
 801e612:	2b00      	cmp	r3, #0
 801e614:	d105      	bne.n	801e622 <netdev_register+0x26>
		printf ("Invalid arguments\n");
 801e616:	480e      	ldr	r0, [pc, #56]	; (801e650 <netdev_register+0x54>)
 801e618:	f001 fe44 	bl	80202a4 <puts>
		return STM_FAIL;
 801e61c:	f04f 33ff 	mov.w	r3, #4294967295
 801e620:	e012      	b.n	801e648 <netdev_register+0x4c>
	}

	ndev->net_ops = ops;
 801e622:	68fb      	ldr	r3, [r7, #12]
 801e624:	683a      	ldr	r2, [r7, #0]
 801e626:	f8c3 2100 	str.w	r2, [r3, #256]	; 0x100
	ndev_db[ndev_index % MAX_INTERFACE] = ndev;
 801e62a:	4b0a      	ldr	r3, [pc, #40]	; (801e654 <netdev_register+0x58>)
 801e62c:	781b      	ldrb	r3, [r3, #0]
 801e62e:	f003 0301 	and.w	r3, r3, #1
 801e632:	4909      	ldr	r1, [pc, #36]	; (801e658 <netdev_register+0x5c>)
 801e634:	68fa      	ldr	r2, [r7, #12]
 801e636:	f841 2023 	str.w	r2, [r1, r3, lsl #2]

	ndev_index++;
 801e63a:	4b06      	ldr	r3, [pc, #24]	; (801e654 <netdev_register+0x58>)
 801e63c:	781b      	ldrb	r3, [r3, #0]
 801e63e:	3301      	adds	r3, #1
 801e640:	b2da      	uxtb	r2, r3
 801e642:	4b04      	ldr	r3, [pc, #16]	; (801e654 <netdev_register+0x58>)
 801e644:	701a      	strb	r2, [r3, #0]

	return STM_OK;
 801e646:	2300      	movs	r3, #0
}
 801e648:	4618      	mov	r0, r3
 801e64a:	3710      	adds	r7, #16
 801e64c:	46bd      	mov	sp, r7
 801e64e:	bd80      	pop	{r7, pc}
 801e650:	08025e64 	.word	0x08025e64
 801e654:	24049c48 	.word	0x24049c48
 801e658:	24049c40 	.word	0x24049c40

0801e65c <netdev_unregister>:
  * @brief  unregister netdev
  * @param  dev - private interface
  * @retval 0 on success, else -1
  */
int netdev_unregister(netdev_handle_t dev)
{
 801e65c:	b580      	push	{r7, lr}
 801e65e:	b084      	sub	sp, #16
 801e660:	af00      	add	r7, sp, #0
 801e662:	6078      	str	r0, [r7, #4]
	struct netdev *ndev = (struct netdev *) dev;
 801e664:	687b      	ldr	r3, [r7, #4]
 801e666:	60fb      	str	r3, [r7, #12]

	if (!ndev) {
 801e668:	68fb      	ldr	r3, [r7, #12]
 801e66a:	2b00      	cmp	r3, #0
 801e66c:	d105      	bne.n	801e67a <netdev_unregister+0x1e>
		printf ("Invalid arguments\n");
 801e66e:	4809      	ldr	r0, [pc, #36]	; (801e694 <netdev_unregister+0x38>)
 801e670:	f001 fe18 	bl	80202a4 <puts>
		return STM_FAIL;
 801e674:	f04f 33ff 	mov.w	r3, #4294967295
 801e678:	e008      	b.n	801e68c <netdev_unregister+0x30>
	}

	ndev->net_ops = NULL;
 801e67a:	68fb      	ldr	r3, [r7, #12]
 801e67c:	2200      	movs	r2, #0
 801e67e:	f8c3 2100 	str.w	r2, [r3, #256]	; 0x100
	ndev->state = NETDEV_STATE_DOWN;
 801e682:	68fb      	ldr	r3, [r7, #12]
 801e684:	2200      	movs	r2, #0
 801e686:	f883 2104 	strb.w	r2, [r3, #260]	; 0x104

	return STM_OK;
 801e68a:	2300      	movs	r3, #0
}
 801e68c:	4618      	mov	r0, r3
 801e68e:	3710      	adds	r7, #16
 801e690:	46bd      	mov	sp, r7
 801e692:	bd80      	pop	{r7, pc}
 801e694:	08025e64 	.word	0x08025e64

0801e698 <netdev_rx>:
  * @param  dev - private interface
  *         net_buf - buffer received
  * @retval 0 on success, else -1
  */
int netdev_rx(netdev_handle_t dev, struct pbuf *net_buf)
{
 801e698:	b580      	push	{r7, lr}
 801e69a:	b084      	sub	sp, #16
 801e69c:	af00      	add	r7, sp, #0
 801e69e:	6078      	str	r0, [r7, #4]
 801e6a0:	6039      	str	r1, [r7, #0]
	struct netdev *ndev = (struct netdev *) dev;
 801e6a2:	687b      	ldr	r3, [r7, #4]
 801e6a4:	60fb      	str	r3, [r7, #12]
	struct network_handle *net_handle;

	if (!ndev || !net_buf) {
 801e6a6:	68fb      	ldr	r3, [r7, #12]
 801e6a8:	2b00      	cmp	r3, #0
 801e6aa:	d002      	beq.n	801e6b2 <netdev_rx+0x1a>
 801e6ac:	683b      	ldr	r3, [r7, #0]
 801e6ae:	2b00      	cmp	r3, #0
 801e6b0:	d108      	bne.n	801e6c4 <netdev_rx+0x2c>
		printf ("Invalid arguments\n");
 801e6b2:	4827      	ldr	r0, [pc, #156]	; (801e750 <netdev_rx+0xb8>)
 801e6b4:	f001 fdf6 	bl	80202a4 <puts>
		tx_thread_sleep(50);
 801e6b8:	2032      	movs	r0, #50	; 0x32
 801e6ba:	f7f6 fa7b 	bl	8014bb4 <_tx_thread_sleep>
		return STM_FAIL;
 801e6be:	f04f 33ff 	mov.w	r3, #4294967295
 801e6c2:	e041      	b.n	801e748 <netdev_rx+0xb0>
	}

	if (ndev->state == NETDEV_STATE_UP) {
 801e6c4:	68fb      	ldr	r3, [r7, #12]
 801e6c6:	f893 3104 	ldrb.w	r3, [r3, #260]	; 0x104
 801e6ca:	2b01      	cmp	r3, #1
 801e6cc:	d122      	bne.n	801e714 <netdev_rx+0x7c>
		if (TX_SUCCESS != tx_queue_send(&(ndev->rx_q), net_buf, TX_WAIT_FOREVER)) {
 801e6ce:	68fb      	ldr	r3, [r7, #12]
 801e6d0:	f503 7386 	add.w	r3, r3, #268	; 0x10c
 801e6d4:	f04f 32ff 	mov.w	r2, #4294967295
 801e6d8:	6839      	ldr	r1, [r7, #0]
 801e6da:	4618      	mov	r0, r3
 801e6dc:	f7f7 ff84 	bl	80165e8 <_txe_queue_send>
 801e6e0:	4603      	mov	r3, r0
 801e6e2:	2b00      	cmp	r3, #0
 801e6e4:	d003      	beq.n	801e6ee <netdev_rx+0x56>
			printf ("Failed to enqueue received packet\n");
 801e6e6:	481b      	ldr	r0, [pc, #108]	; (801e754 <netdev_rx+0xbc>)
 801e6e8:	f001 fddc 	bl	80202a4 <puts>
			goto done;
 801e6ec:	e013      	b.n	801e716 <netdev_rx+0x7e>
		}

		net_handle = (struct network_handle *) ndev->net_handle;
 801e6ee:	68fb      	ldr	r3, [r7, #12]
 801e6f0:	f8d3 3108 	ldr.w	r3, [r3, #264]	; 0x108
 801e6f4:	60bb      	str	r3, [r7, #8]

		if (net_handle->net_rx_callback)
 801e6f6:	68bb      	ldr	r3, [r7, #8]
 801e6f8:	685b      	ldr	r3, [r3, #4]
 801e6fa:	2b00      	cmp	r3, #0
 801e6fc:	d003      	beq.n	801e706 <netdev_rx+0x6e>
			net_handle->net_rx_callback(net_handle);
 801e6fe:	68bb      	ldr	r3, [r7, #8]
 801e700:	685b      	ldr	r3, [r3, #4]
 801e702:	68b8      	ldr	r0, [r7, #8]
 801e704:	4798      	blx	r3

		free(net_buf);
 801e706:	6838      	ldr	r0, [r7, #0]
 801e708:	f7fe febe 	bl	801d488 <esp_hosted_free>
		net_buf = NULL;
 801e70c:	2300      	movs	r3, #0
 801e70e:	603b      	str	r3, [r7, #0]

	} else {
		goto done;
	}

	return STM_OK;
 801e710:	2300      	movs	r3, #0
 801e712:	e019      	b.n	801e748 <netdev_rx+0xb0>
		goto done;
 801e714:	bf00      	nop

done:
	if (net_buf) {
 801e716:	683b      	ldr	r3, [r7, #0]
 801e718:	2b00      	cmp	r3, #0
 801e71a:	d010      	beq.n	801e73e <netdev_rx+0xa6>
		if (net_buf->payload) {
 801e71c:	683b      	ldr	r3, [r7, #0]
 801e71e:	681b      	ldr	r3, [r3, #0]
 801e720:	2b00      	cmp	r3, #0
 801e722:	d007      	beq.n	801e734 <netdev_rx+0x9c>
			free(net_buf->payload);
 801e724:	683b      	ldr	r3, [r7, #0]
 801e726:	681b      	ldr	r3, [r3, #0]
 801e728:	4618      	mov	r0, r3
 801e72a:	f7fe fead 	bl	801d488 <esp_hosted_free>
			net_buf->payload = NULL;
 801e72e:	683b      	ldr	r3, [r7, #0]
 801e730:	2200      	movs	r2, #0
 801e732:	601a      	str	r2, [r3, #0]
		}
		free(net_buf);
 801e734:	6838      	ldr	r0, [r7, #0]
 801e736:	f7fe fea7 	bl	801d488 <esp_hosted_free>
		net_buf = NULL;
 801e73a:	2300      	movs	r3, #0
 801e73c:	603b      	str	r3, [r7, #0]
	}
	tx_thread_sleep(50);
 801e73e:	2032      	movs	r0, #50	; 0x32
 801e740:	f7f6 fa38 	bl	8014bb4 <_tx_thread_sleep>
	return STM_FAIL;
 801e744:	f04f 33ff 	mov.w	r3, #4294967295
}
 801e748:	4618      	mov	r0, r3
 801e74a:	3710      	adds	r7, #16
 801e74c:	46bd      	mov	sp, r7
 801e74e:	bd80      	pop	{r7, pc}
 801e750:	08025e64 	.word	0x08025e64
 801e754:	08025e78 	.word	0x08025e78

0801e758 <serial_open>:
  * @brief Open new Serial interface
  * @param  serial_hdl - handle of serial interface
  * @retval 0 if success, -1 on failure
  */
static int serial_open(serial_handle_t *serial_hdl)
{
 801e758:	b580      	push	{r7, lr}
 801e75a:	b084      	sub	sp, #16
 801e75c:	af02      	add	r7, sp, #8
 801e75e:	6078      	str	r0, [r7, #4]
	if (! serial_hdl) {
 801e760:	687b      	ldr	r3, [r7, #4]
 801e762:	2b00      	cmp	r3, #0
 801e764:	d105      	bne.n	801e772 <serial_open+0x1a>
		printf("serial invalid hdr\n\r");
 801e766:	4819      	ldr	r0, [pc, #100]	; (801e7cc <serial_open+0x74>)
 801e768:	f001 fd00 	bl	802016c <iprintf>
		return STM_FAIL;
 801e76c:	f04f 33ff 	mov.w	r3, #4294967295
 801e770:	e028      	b.n	801e7c4 <serial_open+0x6c>
	}

	if (serial_hdl->queue.tx_queue_id != TX_CLEAR_ID) {
 801e772:	687b      	ldr	r3, [r7, #4]
 801e774:	681b      	ldr	r3, [r3, #0]
 801e776:	2b00      	cmp	r3, #0
 801e778:	d003      	beq.n	801e782 <serial_open+0x2a>
		/* clean up earlier queue */
		(VOID)tx_queue_delete(&(serial_hdl->queue));
 801e77a:	687b      	ldr	r3, [r7, #4]
 801e77c:	4618      	mov	r0, r3
 801e77e:	f7f7 fe8d 	bl	801649c <_txe_queue_delete>
	}

	/* Queue - serial rx */
	if (tx_queue_create(&(serial_hdl->queue), "Serial Rx Queue", sizeof(interface_buffer_handle_t) / sizeof(ULONG), &to_serial_intf_queue_buffer[conn_num], sizeof(to_serial_intf_queue_buffer[0])) != TX_SUCCESS) {
 801e782:	6878      	ldr	r0, [r7, #4]
 801e784:	4b12      	ldr	r3, [pc, #72]	; (801e7d0 <serial_open+0x78>)
 801e786:	781b      	ldrb	r3, [r3, #0]
 801e788:	461a      	mov	r2, r3
 801e78a:	f44f 63fa 	mov.w	r3, #2000	; 0x7d0
 801e78e:	fb02 f303 	mul.w	r3, r2, r3
 801e792:	4a10      	ldr	r2, [pc, #64]	; (801e7d4 <serial_open+0x7c>)
 801e794:	4413      	add	r3, r2
 801e796:	2238      	movs	r2, #56	; 0x38
 801e798:	9201      	str	r2, [sp, #4]
 801e79a:	f44f 62fa 	mov.w	r2, #2000	; 0x7d0
 801e79e:	9200      	str	r2, [sp, #0]
 801e7a0:	2205      	movs	r2, #5
 801e7a2:	490d      	ldr	r1, [pc, #52]	; (801e7d8 <serial_open+0x80>)
 801e7a4:	f7f7 fdca 	bl	801633c <_txe_queue_create>
 801e7a8:	4603      	mov	r3, r0
 801e7aa:	2b00      	cmp	r3, #0
 801e7ac:	d005      	beq.n	801e7ba <serial_open+0x62>
		serial_cleanup(serial_hdl);
 801e7ae:	6878      	ldr	r0, [r7, #4]
 801e7b0:	f000 f924 	bl	801e9fc <serial_cleanup>
		return STM_FAIL;
 801e7b4:	f04f 33ff 	mov.w	r3, #4294967295
 801e7b8:	e004      	b.n	801e7c4 <serial_open+0x6c>
	}

	serial_hdl->state  = ACTIVE;
 801e7ba:	687b      	ldr	r3, [r7, #4]
 801e7bc:	2201      	movs	r2, #1
 801e7be:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
	return STM_OK;
 801e7c2:	2300      	movs	r3, #0
}
 801e7c4:	4618      	mov	r0, r3
 801e7c6:	3708      	adds	r7, #8
 801e7c8:	46bd      	mov	sp, r7
 801e7ca:	bd80      	pop	{r7, pc}
 801e7cc:	08025e9c 	.word	0x08025e9c
 801e7d0:	2404ac64 	.word	0x2404ac64
 801e7d4:	24049cbc 	.word	0x24049cbc
 801e7d8:	08025eb4 	.word	0x08025eb4

0801e7dc <get_serial_handle>:
  * @brief Get serial handle for iface_num
  * @param  iface_num - serial connection number
  * @retval serial_hdl - output handle of serial interface
  */
static serial_handle_t * get_serial_handle(const uint8_t iface_num)
{
 801e7dc:	b480      	push	{r7}
 801e7de:	b083      	sub	sp, #12
 801e7e0:	af00      	add	r7, sp, #0
 801e7e2:	4603      	mov	r3, r0
 801e7e4:	71fb      	strb	r3, [r7, #7]
	if ((iface_num < MAX_SERIAL_INTF) &&
 801e7e6:	79fb      	ldrb	r3, [r7, #7]
 801e7e8:	2b01      	cmp	r3, #1
 801e7ea:	d812      	bhi.n	801e812 <get_serial_handle+0x36>
		(interface_handle_g[iface_num]) &&
 801e7ec:	79fb      	ldrb	r3, [r7, #7]
 801e7ee:	4a0c      	ldr	r2, [pc, #48]	; (801e820 <get_serial_handle+0x44>)
 801e7f0:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
	if ((iface_num < MAX_SERIAL_INTF) &&
 801e7f4:	2b00      	cmp	r3, #0
 801e7f6:	d00c      	beq.n	801e812 <get_serial_handle+0x36>
		(interface_handle_g[iface_num]->state == ACTIVE)) {
 801e7f8:	79fb      	ldrb	r3, [r7, #7]
 801e7fa:	4a09      	ldr	r2, [pc, #36]	; (801e820 <get_serial_handle+0x44>)
 801e7fc:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 801e800:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
		(interface_handle_g[iface_num]) &&
 801e804:	2b01      	cmp	r3, #1
 801e806:	d104      	bne.n	801e812 <get_serial_handle+0x36>

		return interface_handle_g[iface_num];
 801e808:	79fb      	ldrb	r3, [r7, #7]
 801e80a:	4a05      	ldr	r2, [pc, #20]	; (801e820 <get_serial_handle+0x44>)
 801e80c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 801e810:	e000      	b.n	801e814 <get_serial_handle+0x38>
	}
	return NULL;
 801e812:	2300      	movs	r3, #0
}
 801e814:	4618      	mov	r0, r3
 801e816:	370c      	adds	r7, #12
 801e818:	46bd      	mov	sp, r7
 801e81a:	f85d 7b04 	ldr.w	r7, [sp], #4
 801e81e:	4770      	bx	lr
 801e820:	2404ac5c 	.word	0x2404ac5c

0801e824 <serial_close>:
  * @brief Close serial interface
  * @param  serial_hdl - handle
  * @retval rbuffer - ready buffer read on serial inerface
  */
static int serial_close(serial_handle_t * serial_hdl)
{
 801e824:	b580      	push	{r7, lr}
 801e826:	b082      	sub	sp, #8
 801e828:	af00      	add	r7, sp, #0
 801e82a:	6078      	str	r0, [r7, #4]
	if (serial_hdl->queue.tx_queue_id != TX_CLEAR_ID) {
 801e82c:	687b      	ldr	r3, [r7, #4]
 801e82e:	681b      	ldr	r3, [r3, #0]
 801e830:	2b00      	cmp	r3, #0
 801e832:	d003      	beq.n	801e83c <serial_close+0x18>
		(VOID)tx_queue_delete(&(serial_hdl->queue));
 801e834:	687b      	ldr	r3, [r7, #4]
 801e836:	4618      	mov	r0, r3
 801e838:	f7f7 fe30 	bl	801649c <_txe_queue_delete>
	}

	/* reset connection */
	if (conn_num > 0) {
 801e83c:	4b0e      	ldr	r3, [pc, #56]	; (801e878 <serial_close+0x54>)
 801e83e:	781b      	ldrb	r3, [r3, #0]
 801e840:	2b00      	cmp	r3, #0
 801e842:	d00c      	beq.n	801e85e <serial_close+0x3a>
		interface_handle_g[--conn_num] = NULL;
 801e844:	4b0c      	ldr	r3, [pc, #48]	; (801e878 <serial_close+0x54>)
 801e846:	781b      	ldrb	r3, [r3, #0]
 801e848:	3b01      	subs	r3, #1
 801e84a:	b2da      	uxtb	r2, r3
 801e84c:	4b0a      	ldr	r3, [pc, #40]	; (801e878 <serial_close+0x54>)
 801e84e:	701a      	strb	r2, [r3, #0]
 801e850:	4b09      	ldr	r3, [pc, #36]	; (801e878 <serial_close+0x54>)
 801e852:	781b      	ldrb	r3, [r3, #0]
 801e854:	4619      	mov	r1, r3
 801e856:	4b09      	ldr	r3, [pc, #36]	; (801e87c <serial_close+0x58>)
 801e858:	2200      	movs	r2, #0
 801e85a:	f843 2021 	str.w	r2, [r3, r1, lsl #2]
	}

	if (serial_hdl) {
 801e85e:	687b      	ldr	r3, [r7, #4]
 801e860:	2b00      	cmp	r3, #0
 801e862:	d004      	beq.n	801e86e <serial_close+0x4a>
		free(serial_hdl);
 801e864:	6878      	ldr	r0, [r7, #4]
 801e866:	f7fe fe0f 	bl	801d488 <esp_hosted_free>
		serial_hdl = NULL;
 801e86a:	2300      	movs	r3, #0
 801e86c:	607b      	str	r3, [r7, #4]
	}
	return STM_OK;
 801e86e:	2300      	movs	r3, #0
}
 801e870:	4618      	mov	r0, r3
 801e872:	3708      	adds	r7, #8
 801e874:	46bd      	mov	sp, r7
 801e876:	bd80      	pop	{r7, pc}
 801e878:	2404ac64 	.word	0x2404ac64
 801e87c:	2404ac5c 	.word	0x2404ac5c

0801e880 <serial_read>:
  *         rlen - output param, number of bytes read
  * @retval rbuffer - ready buffer read on serial inerface
  */
static uint8_t * serial_read(const serial_handle_t * serial_hdl,
							 uint16_t * rlen)
{
 801e880:	b580      	push	{r7, lr}
 801e882:	b088      	sub	sp, #32
 801e884:	af00      	add	r7, sp, #0
 801e886:	6078      	str	r0, [r7, #4]
 801e888:	6039      	str	r1, [r7, #0]
	/* This is a non-blocking call */
	interface_buffer_handle_t buf_handle = {0};
 801e88a:	f107 030c 	add.w	r3, r7, #12
 801e88e:	2200      	movs	r2, #0
 801e890:	601a      	str	r2, [r3, #0]
 801e892:	605a      	str	r2, [r3, #4]
 801e894:	609a      	str	r2, [r3, #8]
 801e896:	60da      	str	r2, [r3, #12]
 801e898:	611a      	str	r2, [r3, #16]

	/* Initial value */
	*rlen = 0 ;
 801e89a:	683b      	ldr	r3, [r7, #0]
 801e89c:	2200      	movs	r2, #0
 801e89e:	801a      	strh	r2, [r3, #0]

	/* check if serial interface valid */
	if ((! serial_hdl) || (serial_hdl->state != ACTIVE)) {
 801e8a0:	687b      	ldr	r3, [r7, #4]
 801e8a2:	2b00      	cmp	r3, #0
 801e8a4:	d004      	beq.n	801e8b0 <serial_read+0x30>
 801e8a6:	687b      	ldr	r3, [r7, #4]
 801e8a8:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
 801e8ac:	2b01      	cmp	r3, #1
 801e8ae:	d004      	beq.n	801e8ba <serial_read+0x3a>
		printf("serial invalid interface\n\r");
 801e8b0:	4812      	ldr	r0, [pc, #72]	; (801e8fc <serial_read+0x7c>)
 801e8b2:	f001 fc5b 	bl	802016c <iprintf>
		return NULL;
 801e8b6:	2300      	movs	r3, #0
 801e8b8:	e01b      	b.n	801e8f2 <serial_read+0x72>
	 * indication, which can be used by higher layer in seperate
	 * dedicated rx task to receive and process rx data.
	 *
	 * In our example, first approach of blocking read is used.
	 */
	if (TX_SUCCESS != tx_queue_receive((TX_QUEUE *)&(serial_hdl->queue), &buf_handle, TX_NO_WAIT)) {
 801e8ba:	687b      	ldr	r3, [r7, #4]
 801e8bc:	f107 010c 	add.w	r1, r7, #12
 801e8c0:	2200      	movs	r2, #0
 801e8c2:	4618      	mov	r0, r3
 801e8c4:	f7f7 fe46 	bl	8016554 <_txe_queue_receive>
 801e8c8:	4603      	mov	r3, r0
 801e8ca:	2b00      	cmp	r3, #0
 801e8cc:	d004      	beq.n	801e8d8 <serial_read+0x58>
		printf("serial queue recv failed \n\r");
 801e8ce:	480c      	ldr	r0, [pc, #48]	; (801e900 <serial_read+0x80>)
 801e8d0:	f001 fc4c 	bl	802016c <iprintf>
		return NULL;
 801e8d4:	2300      	movs	r3, #0
 801e8d6:	e00c      	b.n	801e8f2 <serial_read+0x72>
	}

	/* proceed only if payload and length are sane */
	if (! buf_handle.payload || ! buf_handle.payload_len) {
 801e8d8:	697b      	ldr	r3, [r7, #20]
 801e8da:	2b00      	cmp	r3, #0
 801e8dc:	d002      	beq.n	801e8e4 <serial_read+0x64>
 801e8de:	69bb      	ldr	r3, [r7, #24]
 801e8e0:	2b00      	cmp	r3, #0
 801e8e2:	d101      	bne.n	801e8e8 <serial_read+0x68>
		return NULL;
 801e8e4:	2300      	movs	r3, #0
 801e8e6:	e004      	b.n	801e8f2 <serial_read+0x72>
	}

	*rlen = buf_handle.payload_len;
 801e8e8:	69bb      	ldr	r3, [r7, #24]
 801e8ea:	b29a      	uxth	r2, r3
 801e8ec:	683b      	ldr	r3, [r7, #0]
 801e8ee:	801a      	strh	r2, [r3, #0]

	return buf_handle.payload;
 801e8f0:	697b      	ldr	r3, [r7, #20]
}
 801e8f2:	4618      	mov	r0, r3
 801e8f4:	3720      	adds	r7, #32
 801e8f6:	46bd      	mov	sp, r7
 801e8f8:	bd80      	pop	{r7, pc}
 801e8fa:	bf00      	nop
 801e8fc:	08025ec4 	.word	0x08025ec4
 801e900:	08025ee0 	.word	0x08025ee0

0801e904 <serial_write>:
  *         wbuffer - buffer to send
  * @retval STM_FAIL/STM_OK
  */
static int serial_write(const serial_handle_t * serial_hdl,
	uint8_t * wbuffer, const uint16_t wlen)
{
 801e904:	b580      	push	{r7, lr}
 801e906:	b084      	sub	sp, #16
 801e908:	af00      	add	r7, sp, #0
 801e90a:	60f8      	str	r0, [r7, #12]
 801e90c:	60b9      	str	r1, [r7, #8]
 801e90e:	4613      	mov	r3, r2
 801e910:	80fb      	strh	r3, [r7, #6]

	if ((! serial_hdl) || (serial_hdl->state != ACTIVE)) {
 801e912:	68fb      	ldr	r3, [r7, #12]
 801e914:	2b00      	cmp	r3, #0
 801e916:	d004      	beq.n	801e922 <serial_write+0x1e>
 801e918:	68fb      	ldr	r3, [r7, #12]
 801e91a:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
 801e91e:	2b01      	cmp	r3, #1
 801e920:	d005      	beq.n	801e92e <serial_write+0x2a>
		printf("serial invalid interface for write\n\r");
 801e922:	480a      	ldr	r0, [pc, #40]	; (801e94c <serial_write+0x48>)
 801e924:	f001 fc22 	bl	802016c <iprintf>
		return STM_FAIL;
 801e928:	f04f 33ff 	mov.w	r3, #4294967295
 801e92c:	e00a      	b.n	801e944 <serial_write+0x40>
	}

	return send_to_slave(serial_hdl->if_type,
 801e92e:	68fb      	ldr	r3, [r7, #12]
 801e930:	f893 0038 	ldrb.w	r0, [r3, #56]	; 0x38
 801e934:	68fb      	ldr	r3, [r7, #12]
 801e936:	f893 1039 	ldrb.w	r1, [r3, #57]	; 0x39
 801e93a:	88fb      	ldrh	r3, [r7, #6]
 801e93c:	68ba      	ldr	r2, [r7, #8]
 801e93e:	f000 fb59 	bl	801eff4 <send_to_slave>
 801e942:	4603      	mov	r3, r0
		serial_hdl->if_num, wbuffer, wlen);
}
 801e944:	4618      	mov	r0, r3
 801e946:	3710      	adds	r7, #16
 801e948:	46bd      	mov	sp, r7
 801e94a:	bd80      	pop	{r7, pc}
 801e94c:	08025efc 	.word	0x08025efc

0801e950 <serial_rx_handler>:
  *         rxbuff - buffer from spi driver
  *         rx_len - size of rxbuff
  * @retval None
  */
stm_ret_t serial_rx_handler(uint8_t if_num, uint8_t *rxbuff, uint16_t rx_len)
{
 801e950:	b580      	push	{r7, lr}
 801e952:	b088      	sub	sp, #32
 801e954:	af00      	add	r7, sp, #0
 801e956:	4603      	mov	r3, r0
 801e958:	6039      	str	r1, [r7, #0]
 801e95a:	71fb      	strb	r3, [r7, #7]
 801e95c:	4613      	mov	r3, r2
 801e95e:	80bb      	strh	r3, [r7, #4]
	interface_buffer_handle_t buf_handle = {0};
 801e960:	f107 0308 	add.w	r3, r7, #8
 801e964:	2200      	movs	r2, #0
 801e966:	601a      	str	r2, [r3, #0]
 801e968:	605a      	str	r2, [r3, #4]
 801e96a:	609a      	str	r2, [r3, #8]
 801e96c:	60da      	str	r2, [r3, #12]
 801e96e:	611a      	str	r2, [r3, #16]
	serial_handle_t * serial_hdl = NULL;
 801e970:	2300      	movs	r3, #0
 801e972:	61fb      	str	r3, [r7, #28]

	serial_hdl = get_serial_handle(if_num);
 801e974:	79fb      	ldrb	r3, [r7, #7]
 801e976:	4618      	mov	r0, r3
 801e978:	f7ff ff30 	bl	801e7dc <get_serial_handle>
 801e97c:	61f8      	str	r0, [r7, #28]

	if ((! serial_hdl) || (serial_hdl->state != ACTIVE)) {
 801e97e:	69fb      	ldr	r3, [r7, #28]
 801e980:	2b00      	cmp	r3, #0
 801e982:	d004      	beq.n	801e98e <serial_rx_handler+0x3e>
 801e984:	69fb      	ldr	r3, [r7, #28]
 801e986:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
 801e98a:	2b01      	cmp	r3, #1
 801e98c:	d005      	beq.n	801e99a <serial_rx_handler+0x4a>
		printf("Serial interface not registered yet\n\r");
 801e98e:	4818      	ldr	r0, [pc, #96]	; (801e9f0 <serial_rx_handler+0xa0>)
 801e990:	f001 fbec 	bl	802016c <iprintf>
		return STM_FAIL ;
 801e994:	f04f 33ff 	mov.w	r3, #4294967295
 801e998:	e026      	b.n	801e9e8 <serial_rx_handler+0x98>
	}
	buf_handle.if_type = ESP_SERIAL_IF;
 801e99a:	2302      	movs	r3, #2
 801e99c:	733b      	strb	r3, [r7, #12]
	buf_handle.if_num = if_num;
 801e99e:	79fb      	ldrb	r3, [r7, #7]
 801e9a0:	737b      	strb	r3, [r7, #13]
	buf_handle.payload_len = rx_len;
 801e9a2:	88bb      	ldrh	r3, [r7, #4]
 801e9a4:	617b      	str	r3, [r7, #20]
	buf_handle.payload = rxbuff;
 801e9a6:	683b      	ldr	r3, [r7, #0]
 801e9a8:	613b      	str	r3, [r7, #16]
	buf_handle.priv_buffer_handle = rxbuff;
 801e9aa:	683b      	ldr	r3, [r7, #0]
 801e9ac:	60bb      	str	r3, [r7, #8]
	buf_handle.free_buf_handle = free;
 801e9ae:	4b11      	ldr	r3, [pc, #68]	; (801e9f4 <serial_rx_handler+0xa4>)
 801e9b0:	61bb      	str	r3, [r7, #24]

	/* send to serial queue */
	if (TX_SUCCESS != tx_queue_send(&(serial_hdl->queue),
 801e9b2:	69fb      	ldr	r3, [r7, #28]
 801e9b4:	f107 0108 	add.w	r1, r7, #8
 801e9b8:	f04f 32ff 	mov.w	r2, #4294967295
 801e9bc:	4618      	mov	r0, r3
 801e9be:	f7f7 fe13 	bl	80165e8 <_txe_queue_send>
 801e9c2:	4603      	mov	r3, r0
 801e9c4:	2b00      	cmp	r3, #0
 801e9c6:	d007      	beq.n	801e9d8 <serial_rx_handler+0x88>
		    &buf_handle, TX_WAIT_FOREVER)) {
		printf("Failed send serialif queue[%u]\n\r", if_num);
 801e9c8:	79fb      	ldrb	r3, [r7, #7]
 801e9ca:	4619      	mov	r1, r3
 801e9cc:	480a      	ldr	r0, [pc, #40]	; (801e9f8 <serial_rx_handler+0xa8>)
 801e9ce:	f001 fbcd 	bl	802016c <iprintf>
		return STM_FAIL;
 801e9d2:	f04f 33ff 	mov.w	r3, #4294967295
 801e9d6:	e007      	b.n	801e9e8 <serial_rx_handler+0x98>
	}

	/* Indicate higher layer about data ready for consumption */
	if (serial_hdl->serial_rx_callback) {
 801e9d8:	69fb      	ldr	r3, [r7, #28]
 801e9da:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 801e9dc:	2b00      	cmp	r3, #0
 801e9de:	d002      	beq.n	801e9e6 <serial_rx_handler+0x96>
		(*serial_hdl->serial_rx_callback) ();
 801e9e0:	69fb      	ldr	r3, [r7, #28]
 801e9e2:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 801e9e4:	4798      	blx	r3
	}

	return STM_OK;
 801e9e6:	2300      	movs	r3, #0
}
 801e9e8:	4618      	mov	r0, r3
 801e9ea:	3720      	adds	r7, #32
 801e9ec:	46bd      	mov	sp, r7
 801e9ee:	bd80      	pop	{r7, pc}
 801e9f0:	08025f24 	.word	0x08025f24
 801e9f4:	0801d489 	.word	0x0801d489
 801e9f8:	08025f4c 	.word	0x08025f4c

0801e9fc <serial_cleanup>:
  * @brief Serial cleanup
  * @param  buf_handle - handle
  * @retval None
  */
static void serial_cleanup(serial_handle_t * serial_hdl)
{
 801e9fc:	b580      	push	{r7, lr}
 801e9fe:	b082      	sub	sp, #8
 801ea00:	af00      	add	r7, sp, #0
 801ea02:	6078      	str	r0, [r7, #4]
	serial_close(serial_hdl);
 801ea04:	6878      	ldr	r0, [r7, #4]
 801ea06:	f7ff ff0d 	bl	801e824 <serial_close>
	serial_hdl->state = DESTROY;
 801ea0a:	687b      	ldr	r3, [r7, #4]
 801ea0c:	2202      	movs	r2, #2
 801ea0e:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
}
 801ea12:	bf00      	nop
 801ea14:	3708      	adds	r7, #8
 801ea16:	46bd      	mov	sp, r7
 801ea18:	bd80      	pop	{r7, pc}
	...

0801ea1c <serial_init>:
  * @brief create and return new serial interface
  * @param  serial_rx_callback - callback to be invoked on rx data
  * @retval serial_hdl - output handle of serial interface
  */
serial_handle_t * serial_init(void(*serial_rx_callback)(void))
{
 801ea1c:	b5b0      	push	{r4, r5, r7, lr}
 801ea1e:	b084      	sub	sp, #16
 801ea20:	af00      	add	r7, sp, #0
 801ea22:	6078      	str	r0, [r7, #4]
	serial_handle_t  * serial_hdl = NULL;
 801ea24:	2300      	movs	r3, #0
 801ea26:	60fb      	str	r3, [r7, #12]

	/* Check if more serial interfaces be created */
	if ((conn_num+1) < MAX_SERIAL_INTF) {
 801ea28:	4b27      	ldr	r3, [pc, #156]	; (801eac8 <serial_init+0xac>)
 801ea2a:	781b      	ldrb	r3, [r3, #0]
 801ea2c:	2b00      	cmp	r3, #0
 801ea2e:	d143      	bne.n	801eab8 <serial_init+0x9c>

		serial_hdl = (serial_handle_t *)malloc(sizeof(serial_handle_t));
 801ea30:	2048      	movs	r0, #72	; 0x48
 801ea32:	f7fe fcf9 	bl	801d428 <esp_hosted_malloc>
 801ea36:	60f8      	str	r0, [r7, #12]
		if (! serial_hdl) {
 801ea38:	68fb      	ldr	r3, [r7, #12]
 801ea3a:	2b00      	cmp	r3, #0
 801ea3c:	d104      	bne.n	801ea48 <serial_init+0x2c>
			printf("Serial interface - malloc failed\n\r");
 801ea3e:	4823      	ldr	r0, [pc, #140]	; (801eacc <serial_init+0xb0>)
 801ea40:	f001 fb94 	bl	802016c <iprintf>
			return NULL;
 801ea44:	2300      	movs	r3, #0
 801ea46:	e03b      	b.n	801eac0 <serial_init+0xa4>
		}

		serial_hdl->if_type = ESP_SERIAL_IF;
 801ea48:	68fb      	ldr	r3, [r7, #12]
 801ea4a:	2202      	movs	r2, #2
 801ea4c:	f883 2038 	strb.w	r2, [r3, #56]	; 0x38
		serial_hdl->if_num  = conn_num;
 801ea50:	4b1d      	ldr	r3, [pc, #116]	; (801eac8 <serial_init+0xac>)
 801ea52:	781a      	ldrb	r2, [r3, #0]
 801ea54:	68fb      	ldr	r3, [r7, #12]
 801ea56:	f883 2039 	strb.w	r2, [r3, #57]	; 0x39
		serial_hdl->queue   = to_serial_intf_queue[conn_num];
 801ea5a:	4b1b      	ldr	r3, [pc, #108]	; (801eac8 <serial_init+0xac>)
 801ea5c:	781b      	ldrb	r3, [r3, #0]
 801ea5e:	4619      	mov	r1, r3
 801ea60:	68f8      	ldr	r0, [r7, #12]
 801ea62:	4a1b      	ldr	r2, [pc, #108]	; (801ead0 <serial_init+0xb4>)
 801ea64:	460b      	mov	r3, r1
 801ea66:	00db      	lsls	r3, r3, #3
 801ea68:	1a5b      	subs	r3, r3, r1
 801ea6a:	00db      	lsls	r3, r3, #3
 801ea6c:	4413      	add	r3, r2
 801ea6e:	4604      	mov	r4, r0
 801ea70:	461d      	mov	r5, r3
 801ea72:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 801ea74:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 801ea76:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 801ea78:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 801ea7a:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 801ea7c:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 801ea7e:	e895 0003 	ldmia.w	r5, {r0, r1}
 801ea82:	e884 0003 	stmia.w	r4, {r0, r1}
		serial_hdl->state   = INIT;
 801ea86:	68fb      	ldr	r3, [r7, #12]
 801ea88:	2200      	movs	r2, #0
 801ea8a:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
		serial_hdl->fops    = &serial_fops;
 801ea8e:	68fb      	ldr	r3, [r7, #12]
 801ea90:	4a10      	ldr	r2, [pc, #64]	; (801ead4 <serial_init+0xb8>)
 801ea92:	63da      	str	r2, [r3, #60]	; 0x3c
		serial_hdl->serial_rx_callback   = serial_rx_callback;
 801ea94:	68fb      	ldr	r3, [r7, #12]
 801ea96:	687a      	ldr	r2, [r7, #4]
 801ea98:	645a      	str	r2, [r3, #68]	; 0x44
		interface_handle_g[conn_num] = serial_hdl;
 801ea9a:	4b0b      	ldr	r3, [pc, #44]	; (801eac8 <serial_init+0xac>)
 801ea9c:	781b      	ldrb	r3, [r3, #0]
 801ea9e:	4619      	mov	r1, r3
 801eaa0:	4a0d      	ldr	r2, [pc, #52]	; (801ead8 <serial_init+0xbc>)
 801eaa2:	68fb      	ldr	r3, [r7, #12]
 801eaa4:	f842 3021 	str.w	r3, [r2, r1, lsl #2]
		conn_num++;
 801eaa8:	4b07      	ldr	r3, [pc, #28]	; (801eac8 <serial_init+0xac>)
 801eaaa:	781b      	ldrb	r3, [r3, #0]
 801eaac:	3301      	adds	r3, #1
 801eaae:	b2da      	uxtb	r2, r3
 801eab0:	4b05      	ldr	r3, [pc, #20]	; (801eac8 <serial_init+0xac>)
 801eab2:	701a      	strb	r2, [r3, #0]
	} else {
		printf("Number of serial interface connections overflow\n\r");
		return NULL;
	}

	return serial_hdl;
 801eab4:	68fb      	ldr	r3, [r7, #12]
 801eab6:	e003      	b.n	801eac0 <serial_init+0xa4>
		printf("Number of serial interface connections overflow\n\r");
 801eab8:	4808      	ldr	r0, [pc, #32]	; (801eadc <serial_init+0xc0>)
 801eaba:	f001 fb57 	bl	802016c <iprintf>
		return NULL;
 801eabe:	2300      	movs	r3, #0
}
 801eac0:	4618      	mov	r0, r3
 801eac2:	3710      	adds	r7, #16
 801eac4:	46bd      	mov	sp, r7
 801eac6:	bdb0      	pop	{r4, r5, r7, pc}
 801eac8:	2404ac64 	.word	0x2404ac64
 801eacc:	08025f70 	.word	0x08025f70
 801ead0:	24049c4c 	.word	0x24049c4c
 801ead4:	2400047c 	.word	0x2400047c
 801ead8:	2404ac5c 	.word	0x2404ac5c
 801eadc:	08025f94 	.word	0x08025f94

0801eae0 <get_priv>:
  * @param  if_type - interface type
  *         if_num - interface number
  * @retval interface handle if found, else NULL
  */
static struct esp_private * get_priv(uint8_t if_type, uint8_t if_num)
{
 801eae0:	b480      	push	{r7}
 801eae2:	b085      	sub	sp, #20
 801eae4:	af00      	add	r7, sp, #0
 801eae6:	4603      	mov	r3, r0
 801eae8:	460a      	mov	r2, r1
 801eaea:	71fb      	strb	r3, [r7, #7]
 801eaec:	4613      	mov	r3, r2
 801eaee:	71bb      	strb	r3, [r7, #6]
	int i = 0;
 801eaf0:	2300      	movs	r3, #0
 801eaf2:	60fb      	str	r3, [r7, #12]

	for (i = 0; i < MAX_NETWORK_INTERFACES; i++) {
 801eaf4:	2300      	movs	r3, #0
 801eaf6:	60fb      	str	r3, [r7, #12]
 801eaf8:	e01d      	b.n	801eb36 <get_priv+0x56>
		if((esp_priv[i]) &&
 801eafa:	4a14      	ldr	r2, [pc, #80]	; (801eb4c <get_priv+0x6c>)
 801eafc:	68fb      	ldr	r3, [r7, #12]
 801eafe:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 801eb02:	2b00      	cmp	r3, #0
 801eb04:	d014      	beq.n	801eb30 <get_priv+0x50>
			(esp_priv[i]->if_type == if_type) &&
 801eb06:	4a11      	ldr	r2, [pc, #68]	; (801eb4c <get_priv+0x6c>)
 801eb08:	68fb      	ldr	r3, [r7, #12]
 801eb0a:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 801eb0e:	781b      	ldrb	r3, [r3, #0]
		if((esp_priv[i]) &&
 801eb10:	79fa      	ldrb	r2, [r7, #7]
 801eb12:	429a      	cmp	r2, r3
 801eb14:	d10c      	bne.n	801eb30 <get_priv+0x50>
			(esp_priv[i]->if_num == if_num))
 801eb16:	4a0d      	ldr	r2, [pc, #52]	; (801eb4c <get_priv+0x6c>)
 801eb18:	68fb      	ldr	r3, [r7, #12]
 801eb1a:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 801eb1e:	785b      	ldrb	r3, [r3, #1]
			(esp_priv[i]->if_type == if_type) &&
 801eb20:	79ba      	ldrb	r2, [r7, #6]
 801eb22:	429a      	cmp	r2, r3
 801eb24:	d104      	bne.n	801eb30 <get_priv+0x50>
			return esp_priv[i];
 801eb26:	4a09      	ldr	r2, [pc, #36]	; (801eb4c <get_priv+0x6c>)
 801eb28:	68fb      	ldr	r3, [r7, #12]
 801eb2a:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 801eb2e:	e006      	b.n	801eb3e <get_priv+0x5e>
	for (i = 0; i < MAX_NETWORK_INTERFACES; i++) {
 801eb30:	68fb      	ldr	r3, [r7, #12]
 801eb32:	3301      	adds	r3, #1
 801eb34:	60fb      	str	r3, [r7, #12]
 801eb36:	68fb      	ldr	r3, [r7, #12]
 801eb38:	2b01      	cmp	r3, #1
 801eb3a:	ddde      	ble.n	801eafa <get_priv+0x1a>
	}

	return NULL;
 801eb3c:	2300      	movs	r3, #0
}
 801eb3e:	4618      	mov	r0, r3
 801eb40:	3714      	adds	r7, #20
 801eb42:	46bd      	mov	sp, r7
 801eb44:	f85d 7b04 	ldr.w	r7, [sp], #4
 801eb48:	4770      	bx	lr
 801eb4a:	bf00      	nop
 801eb4c:	2404ac68 	.word	0x2404ac68

0801eb50 <esp_netdev_open>:
  * @brief  open virtual network device
  * @param  netdev - network device
  * @retval 0 on success
  */
static int esp_netdev_open(netdev_handle_t netdev)
{
 801eb50:	b480      	push	{r7}
 801eb52:	b083      	sub	sp, #12
 801eb54:	af00      	add	r7, sp, #0
 801eb56:	6078      	str	r0, [r7, #4]
	return STM_OK;
 801eb58:	2300      	movs	r3, #0
}
 801eb5a:	4618      	mov	r0, r3
 801eb5c:	370c      	adds	r7, #12
 801eb5e:	46bd      	mov	sp, r7
 801eb60:	f85d 7b04 	ldr.w	r7, [sp], #4
 801eb64:	4770      	bx	lr

0801eb66 <esp_netdev_close>:
  * @brief  close virtual network device
  * @param  netdev - network device
  * @retval 0 on success
  */
static int esp_netdev_close(netdev_handle_t netdev)
{
 801eb66:	b480      	push	{r7}
 801eb68:	b083      	sub	sp, #12
 801eb6a:	af00      	add	r7, sp, #0
 801eb6c:	6078      	str	r0, [r7, #4]
	return STM_OK;
 801eb6e:	2300      	movs	r3, #0
}
 801eb70:	4618      	mov	r0, r3
 801eb72:	370c      	adds	r7, #12
 801eb74:	46bd      	mov	sp, r7
 801eb76:	f85d 7b04 	ldr.w	r7, [sp], #4
 801eb7a:	4770      	bx	lr

0801eb7c <esp_netdev_xmit>:
  * @param  netdev - network device
  *         net_buf - buffer to transmit
  * @retval None
  */
static int esp_netdev_xmit(netdev_handle_t netdev, struct pbuf *net_buf)
{
 801eb7c:	b580      	push	{r7, lr}
 801eb7e:	b084      	sub	sp, #16
 801eb80:	af00      	add	r7, sp, #0
 801eb82:	6078      	str	r0, [r7, #4]
 801eb84:	6039      	str	r1, [r7, #0]
	struct esp_private *priv;
	int ret;

	if (!netdev || !net_buf)
 801eb86:	687b      	ldr	r3, [r7, #4]
 801eb88:	2b00      	cmp	r3, #0
 801eb8a:	d002      	beq.n	801eb92 <esp_netdev_xmit+0x16>
 801eb8c:	683b      	ldr	r3, [r7, #0]
 801eb8e:	2b00      	cmp	r3, #0
 801eb90:	d102      	bne.n	801eb98 <esp_netdev_xmit+0x1c>
		return STM_FAIL;
 801eb92:	f04f 33ff 	mov.w	r3, #4294967295
 801eb96:	e019      	b.n	801ebcc <esp_netdev_xmit+0x50>
	priv = (struct esp_private *) netdev_get_priv(netdev);
 801eb98:	6878      	ldr	r0, [r7, #4]
 801eb9a:	f7ff fd1b 	bl	801e5d4 <netdev_get_priv>
 801eb9e:	60f8      	str	r0, [r7, #12]

	if (!priv)
 801eba0:	68fb      	ldr	r3, [r7, #12]
 801eba2:	2b00      	cmp	r3, #0
 801eba4:	d102      	bne.n	801ebac <esp_netdev_xmit+0x30>
		return STM_FAIL;
 801eba6:	f04f 33ff 	mov.w	r3, #4294967295
 801ebaa:	e00f      	b.n	801ebcc <esp_netdev_xmit+0x50>

	ret = send_to_slave(priv->if_type, priv->if_num,
 801ebac:	68fb      	ldr	r3, [r7, #12]
 801ebae:	7818      	ldrb	r0, [r3, #0]
 801ebb0:	68fb      	ldr	r3, [r7, #12]
 801ebb2:	7859      	ldrb	r1, [r3, #1]
 801ebb4:	683b      	ldr	r3, [r7, #0]
 801ebb6:	681a      	ldr	r2, [r3, #0]
 801ebb8:	683b      	ldr	r3, [r7, #0]
 801ebba:	889b      	ldrh	r3, [r3, #4]
 801ebbc:	f000 fa1a 	bl	801eff4 <send_to_slave>
 801ebc0:	4603      	mov	r3, r0
 801ebc2:	60bb      	str	r3, [r7, #8]
			net_buf->payload, net_buf->len);
	free(net_buf);
 801ebc4:	6838      	ldr	r0, [r7, #0]
 801ebc6:	f7fe fc5f 	bl	801d488 <esp_hosted_free>

	return ret;
 801ebca:	68bb      	ldr	r3, [r7, #8]
}
 801ebcc:	4618      	mov	r0, r3
 801ebce:	3710      	adds	r7, #16
 801ebd0:	46bd      	mov	sp, r7
 801ebd2:	bd80      	pop	{r7, pc}

0801ebd4 <init_netdev>:
  * @brief  create virtual network device
  * @param  None
  * @retval None
  */
static stm_ret_t init_netdev(void)
{
 801ebd4:	b580      	push	{r7, lr}
 801ebd6:	b086      	sub	sp, #24
 801ebd8:	af00      	add	r7, sp, #0
	void *ndev = NULL;
 801ebda:	2300      	movs	r3, #0
 801ebdc:	60bb      	str	r3, [r7, #8]
	int i = 0;
 801ebde:	2300      	movs	r3, #0
 801ebe0:	617b      	str	r3, [r7, #20]
	struct esp_private *priv = NULL;
 801ebe2:	2300      	movs	r3, #0
 801ebe4:	607b      	str	r3, [r7, #4]
	char *if_name = STA_INTERFACE;
 801ebe6:	4b24      	ldr	r3, [pc, #144]	; (801ec78 <init_netdev+0xa4>)
 801ebe8:	613b      	str	r3, [r7, #16]
	uint8_t if_type = ESP_STA_IF;
 801ebea:	2300      	movs	r3, #0
 801ebec:	73fb      	strb	r3, [r7, #15]

	for (i = 0; i < MAX_NETWORK_INTERFACES; i++) {
 801ebee:	2300      	movs	r3, #0
 801ebf0:	617b      	str	r3, [r7, #20]
 801ebf2:	e039      	b.n	801ec68 <init_netdev+0x94>
		/* Alloc and init netdev */
		ndev = netdev_alloc(sizeof(struct esp_private), if_name);
 801ebf4:	6939      	ldr	r1, [r7, #16]
 801ebf6:	2008      	movs	r0, #8
 801ebf8:	f7ff fc78 	bl	801e4ec <netdev_alloc>
 801ebfc:	60b8      	str	r0, [r7, #8]
		if (!ndev) {
 801ebfe:	68bb      	ldr	r3, [r7, #8]
 801ec00:	2b00      	cmp	r3, #0
 801ec02:	d104      	bne.n	801ec0e <init_netdev+0x3a>
			deinit_netdev();
 801ec04:	f000 f840 	bl	801ec88 <deinit_netdev>
			return STM_FAIL;
 801ec08:	f04f 33ff 	mov.w	r3, #4294967295
 801ec0c:	e030      	b.n	801ec70 <init_netdev+0x9c>
		}

		priv = (struct esp_private *) netdev_get_priv(ndev);
 801ec0e:	68b8      	ldr	r0, [r7, #8]
 801ec10:	f7ff fce0 	bl	801e5d4 <netdev_get_priv>
 801ec14:	6078      	str	r0, [r7, #4]
		if (!priv) {
 801ec16:	687b      	ldr	r3, [r7, #4]
 801ec18:	2b00      	cmp	r3, #0
 801ec1a:	d104      	bne.n	801ec26 <init_netdev+0x52>
			deinit_netdev();
 801ec1c:	f000 f834 	bl	801ec88 <deinit_netdev>
			return STM_FAIL;
 801ec20:	f04f 33ff 	mov.w	r3, #4294967295
 801ec24:	e024      	b.n	801ec70 <init_netdev+0x9c>
		}

		priv->netdev = ndev;
 801ec26:	687b      	ldr	r3, [r7, #4]
 801ec28:	68ba      	ldr	r2, [r7, #8]
 801ec2a:	605a      	str	r2, [r3, #4]
		priv->if_type = if_type;
 801ec2c:	687b      	ldr	r3, [r7, #4]
 801ec2e:	7bfa      	ldrb	r2, [r7, #15]
 801ec30:	701a      	strb	r2, [r3, #0]
		priv->if_num = 0;
 801ec32:	687b      	ldr	r3, [r7, #4]
 801ec34:	2200      	movs	r2, #0
 801ec36:	705a      	strb	r2, [r3, #1]

		if (netdev_register(ndev, &esp_net_ops)) {
 801ec38:	4910      	ldr	r1, [pc, #64]	; (801ec7c <init_netdev+0xa8>)
 801ec3a:	68b8      	ldr	r0, [r7, #8]
 801ec3c:	f7ff fcde 	bl	801e5fc <netdev_register>
 801ec40:	4603      	mov	r3, r0
 801ec42:	2b00      	cmp	r3, #0
 801ec44:	d004      	beq.n	801ec50 <init_netdev+0x7c>
			deinit_netdev();
 801ec46:	f000 f81f 	bl	801ec88 <deinit_netdev>
			return STM_FAIL;
 801ec4a:	f04f 33ff 	mov.w	r3, #4294967295
 801ec4e:	e00f      	b.n	801ec70 <init_netdev+0x9c>
		}

		if_name = SOFTAP_INTERFACE;
 801ec50:	4b0b      	ldr	r3, [pc, #44]	; (801ec80 <init_netdev+0xac>)
 801ec52:	613b      	str	r3, [r7, #16]
		if_type = ESP_AP_IF;
 801ec54:	2301      	movs	r3, #1
 801ec56:	73fb      	strb	r3, [r7, #15]

		esp_priv[i] = priv;
 801ec58:	490a      	ldr	r1, [pc, #40]	; (801ec84 <init_netdev+0xb0>)
 801ec5a:	697b      	ldr	r3, [r7, #20]
 801ec5c:	687a      	ldr	r2, [r7, #4]
 801ec5e:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
	for (i = 0; i < MAX_NETWORK_INTERFACES; i++) {
 801ec62:	697b      	ldr	r3, [r7, #20]
 801ec64:	3301      	adds	r3, #1
 801ec66:	617b      	str	r3, [r7, #20]
 801ec68:	697b      	ldr	r3, [r7, #20]
 801ec6a:	2b01      	cmp	r3, #1
 801ec6c:	ddc2      	ble.n	801ebf4 <init_netdev+0x20>
	}

	return STM_OK;
 801ec6e:	2300      	movs	r3, #0
}
 801ec70:	4618      	mov	r0, r3
 801ec72:	3718      	adds	r7, #24
 801ec74:	46bd      	mov	sp, r7
 801ec76:	bd80      	pop	{r7, pc}
 801ec78:	08025fc8 	.word	0x08025fc8
 801ec7c:	24000498 	.word	0x24000498
 801ec80:	08025fd4 	.word	0x08025fd4
 801ec84:	2404ac68 	.word	0x2404ac68

0801ec88 <deinit_netdev>:
  * @brief  destroy virtual network device
  * @param  None
  * @retval None
  */
static void deinit_netdev(void)
{
 801ec88:	b580      	push	{r7, lr}
 801ec8a:	b082      	sub	sp, #8
 801ec8c:	af00      	add	r7, sp, #0
	for (int i = 0; i < MAX_NETWORK_INTERFACES; i++) {
 801ec8e:	2300      	movs	r3, #0
 801ec90:	607b      	str	r3, [r7, #4]
 801ec92:	e024      	b.n	801ecde <deinit_netdev+0x56>
		if (esp_priv[i]) {
 801ec94:	4a16      	ldr	r2, [pc, #88]	; (801ecf0 <deinit_netdev+0x68>)
 801ec96:	687b      	ldr	r3, [r7, #4]
 801ec98:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 801ec9c:	2b00      	cmp	r3, #0
 801ec9e:	d01b      	beq.n	801ecd8 <deinit_netdev+0x50>
			if (esp_priv[i]->netdev) {
 801eca0:	4a13      	ldr	r2, [pc, #76]	; (801ecf0 <deinit_netdev+0x68>)
 801eca2:	687b      	ldr	r3, [r7, #4]
 801eca4:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 801eca8:	685b      	ldr	r3, [r3, #4]
 801ecaa:	2b00      	cmp	r3, #0
 801ecac:	d00f      	beq.n	801ecce <deinit_netdev+0x46>
				netdev_unregister(esp_priv[i]->netdev);
 801ecae:	4a10      	ldr	r2, [pc, #64]	; (801ecf0 <deinit_netdev+0x68>)
 801ecb0:	687b      	ldr	r3, [r7, #4]
 801ecb2:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 801ecb6:	685b      	ldr	r3, [r3, #4]
 801ecb8:	4618      	mov	r0, r3
 801ecba:	f7ff fccf 	bl	801e65c <netdev_unregister>
				netdev_free(esp_priv[i]->netdev);
 801ecbe:	4a0c      	ldr	r2, [pc, #48]	; (801ecf0 <deinit_netdev+0x68>)
 801ecc0:	687b      	ldr	r3, [r7, #4]
 801ecc2:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 801ecc6:	685b      	ldr	r3, [r3, #4]
 801ecc8:	4618      	mov	r0, r3
 801ecca:	f7ff fc53 	bl	801e574 <netdev_free>
			}
			esp_priv[i] = NULL;
 801ecce:	4a08      	ldr	r2, [pc, #32]	; (801ecf0 <deinit_netdev+0x68>)
 801ecd0:	687b      	ldr	r3, [r7, #4]
 801ecd2:	2100      	movs	r1, #0
 801ecd4:	f842 1023 	str.w	r1, [r2, r3, lsl #2]
	for (int i = 0; i < MAX_NETWORK_INTERFACES; i++) {
 801ecd8:	687b      	ldr	r3, [r7, #4]
 801ecda:	3301      	adds	r3, #1
 801ecdc:	607b      	str	r3, [r7, #4]
 801ecde:	687b      	ldr	r3, [r7, #4]
 801ece0:	2b01      	cmp	r3, #1
 801ece2:	ddd7      	ble.n	801ec94 <deinit_netdev+0xc>
		}
	}
}
 801ece4:	bf00      	nop
 801ece6:	bf00      	nop
 801ece8:	3708      	adds	r7, #8
 801ecea:	46bd      	mov	sp, r7
 801ecec:	bd80      	pop	{r7, pc}
 801ecee:	bf00      	nop
 801ecf0:	2404ac68 	.word	0x2404ac68

0801ecf4 <is_gpio_alternate_function_set>:
  * @brief  check if alternate function of a GPIO set or not
  * @param  GPIOx - GPIO Instance like A,B,..
  * @retval 1 if alternate function set else 0
  */
static int is_gpio_alternate_function_set(GPIO_TypeDef  *GPIOx, uint32_t pin)
{
 801ecf4:	b480      	push	{r7}
 801ecf6:	b087      	sub	sp, #28
 801ecf8:	af00      	add	r7, sp, #0
 801ecfa:	6078      	str	r0, [r7, #4]
 801ecfc:	6039      	str	r1, [r7, #0]
#define GPIO_NUMBER 16U
	uint32_t position;
	uint32_t ioposition = 0x00U;
 801ecfe:	2300      	movs	r3, #0
 801ed00:	613b      	str	r3, [r7, #16]
	uint32_t iocurrent = 0x00U;
 801ed02:	2300      	movs	r3, #0
 801ed04:	60fb      	str	r3, [r7, #12]
	/* Check the parameters */
	assert_param(IS_GPIO_ALL_INSTANCE(GPIOx));
	assert_param(IS_GPIO_PIN(pin));

	/* Configure the port pins */
	for(position = 0U; position < GPIO_NUMBER; position++)
 801ed06:	2300      	movs	r3, #0
 801ed08:	617b      	str	r3, [r7, #20]
 801ed0a:	e019      	b.n	801ed40 <is_gpio_alternate_function_set+0x4c>
	{
		/* Get the IO position */
		ioposition = 0x01U << position;
 801ed0c:	2201      	movs	r2, #1
 801ed0e:	697b      	ldr	r3, [r7, #20]
 801ed10:	fa02 f303 	lsl.w	r3, r2, r3
 801ed14:	613b      	str	r3, [r7, #16]
		/* Get the current IO position */
		iocurrent = (uint32_t)(pin) & ioposition;
 801ed16:	683a      	ldr	r2, [r7, #0]
 801ed18:	693b      	ldr	r3, [r7, #16]
 801ed1a:	4013      	ands	r3, r2
 801ed1c:	60fb      	str	r3, [r7, #12]

		if(iocurrent == ioposition)
 801ed1e:	68fa      	ldr	r2, [r7, #12]
 801ed20:	693b      	ldr	r3, [r7, #16]
 801ed22:	429a      	cmp	r2, r3
 801ed24:	d109      	bne.n	801ed3a <is_gpio_alternate_function_set+0x46>
		{
			if (GPIOx->AFR[position >> 3U]) {
 801ed26:	697b      	ldr	r3, [r7, #20]
 801ed28:	08da      	lsrs	r2, r3, #3
 801ed2a:	687b      	ldr	r3, [r7, #4]
 801ed2c:	3208      	adds	r2, #8
 801ed2e:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 801ed32:	2b00      	cmp	r3, #0
 801ed34:	d001      	beq.n	801ed3a <is_gpio_alternate_function_set+0x46>
				return 1;
 801ed36:	2301      	movs	r3, #1
 801ed38:	e006      	b.n	801ed48 <is_gpio_alternate_function_set+0x54>
	for(position = 0U; position < GPIO_NUMBER; position++)
 801ed3a:	697b      	ldr	r3, [r7, #20]
 801ed3c:	3301      	adds	r3, #1
 801ed3e:	617b      	str	r3, [r7, #20]
 801ed40:	697b      	ldr	r3, [r7, #20]
 801ed42:	2b0f      	cmp	r3, #15
 801ed44:	d9e2      	bls.n	801ed0c <is_gpio_alternate_function_set+0x18>
			}
		}
	}
	return 0;
 801ed46:	2300      	movs	r3, #0
}
 801ed48:	4618      	mov	r0, r3
 801ed4a:	371c      	adds	r7, #28
 801ed4c:	46bd      	mov	sp, r7
 801ed4e:	f85d 7b04 	ldr.w	r7, [sp], #4
 801ed52:	4770      	bx	lr

0801ed54 <set_hardware_type>:
  *         NSS (as AF) was not working for ESP32S2, this is workaround for that.
  * @param  None
  * @retval None
  */
static void set_hardware_type(void)
{
 801ed54:	b580      	push	{r7, lr}
 801ed56:	af00      	add	r7, sp, #0
	if (is_gpio_alternate_function_set(USR_SPI_CS_GPIO_Port,USR_SPI_CS_Pin)) {
 801ed58:	2102      	movs	r1, #2
 801ed5a:	4807      	ldr	r0, [pc, #28]	; (801ed78 <set_hardware_type+0x24>)
 801ed5c:	f7ff ffca 	bl	801ecf4 <is_gpio_alternate_function_set>
 801ed60:	4603      	mov	r3, r0
 801ed62:	2b00      	cmp	r3, #0
 801ed64:	d003      	beq.n	801ed6e <set_hardware_type+0x1a>
		hardware_type = HARDWARE_TYPE_ESP32;
 801ed66:	4b05      	ldr	r3, [pc, #20]	; (801ed7c <set_hardware_type+0x28>)
 801ed68:	2200      	movs	r2, #0
 801ed6a:	701a      	strb	r2, [r3, #0]
	} else {
		hardware_type = HARDWARE_TYPE_ESP32S2_ESP32C3;
	}
}
 801ed6c:	e002      	b.n	801ed74 <set_hardware_type+0x20>
		hardware_type = HARDWARE_TYPE_ESP32S2_ESP32C3;
 801ed6e:	4b03      	ldr	r3, [pc, #12]	; (801ed7c <set_hardware_type+0x28>)
 801ed70:	2201      	movs	r2, #1
 801ed72:	701a      	strb	r2, [r3, #0]
}
 801ed74:	bf00      	nop
 801ed76:	bd80      	pop	{r7, pc}
 801ed78:	58022800 	.word	0x58022800
 801ed7c:	24000494 	.word	0x24000494

0801ed80 <stm_spi_init>:
  * @brief  spi driver initialize
  * @param  spi_drv_evt_handler - event handler of type spi_drv_events_e
  * @retval None
  */
void stm_spi_init(void(*spi_drv_evt_handler)(uint8_t))
{
 801ed80:	b580      	push	{r7, lr}
 801ed82:	b08c      	sub	sp, #48	; 0x30
 801ed84:	af08      	add	r7, sp, #32
 801ed86:	6078      	str	r0, [r7, #4]
	UINT status;
	stm_ret_t retval = STM_OK;
 801ed88:	2300      	movs	r3, #0
 801ed8a:	73fb      	strb	r3, [r7, #15]
	/* Check if supported board */
    set_hardware_type();
 801ed8c:	f7ff ffe2 	bl	801ed54 <set_hardware_type>

    esp_hosted_heap_init();
 801ed90:	f7fe fb34 	bl	801d3fc <esp_hosted_heap_init>

	/* register callback */
	spi_drv_evt_handler_fp = spi_drv_evt_handler;
 801ed94:	4a54      	ldr	r2, [pc, #336]	; (801eee8 <stm_spi_init+0x168>)
 801ed96:	687b      	ldr	r3, [r7, #4]
 801ed98:	6013      	str	r3, [r2, #0]

	retval = init_netdev();
 801ed9a:	f7ff ff1b 	bl	801ebd4 <init_netdev>
 801ed9e:	4603      	mov	r3, r0
 801eda0:	73fb      	strb	r3, [r7, #15]
	if (retval) {
 801eda2:	f997 300f 	ldrsb.w	r3, [r7, #15]
 801eda6:	2b00      	cmp	r3, #0
 801eda8:	d00d      	beq.n	801edc6 <stm_spi_init+0x46>
		printf("netdev failed to init\n\r");
 801edaa:	4850      	ldr	r0, [pc, #320]	; (801eeec <stm_spi_init+0x16c>)
 801edac:	f001 f9de 	bl	802016c <iprintf>
		assert(retval==STM_OK);
 801edb0:	f997 300f 	ldrsb.w	r3, [r7, #15]
 801edb4:	2b00      	cmp	r3, #0
 801edb6:	d006      	beq.n	801edc6 <stm_spi_init+0x46>
 801edb8:	f44f 7296 	mov.w	r2, #300	; 0x12c
 801edbc:	494c      	ldr	r1, [pc, #304]	; (801eef0 <stm_spi_init+0x170>)
 801edbe:	484d      	ldr	r0, [pc, #308]	; (801eef4 <stm_spi_init+0x174>)
 801edc0:	f001 f9d4 	bl	802016c <iprintf>
 801edc4:	e7fe      	b.n	801edc4 <stm_spi_init+0x44>
	}

	/* spi handshake semaphore */
	status = tx_semaphore_create(&osSemaphore, "osSemaphore", 1);
 801edc6:	231c      	movs	r3, #28
 801edc8:	2201      	movs	r2, #1
 801edca:	494b      	ldr	r1, [pc, #300]	; (801eef8 <stm_spi_init+0x178>)
 801edcc:	484b      	ldr	r0, [pc, #300]	; (801eefc <stm_spi_init+0x17c>)
 801edce:	f7f7 fc55 	bl	801667c <_txe_semaphore_create>
 801edd2:	60b8      	str	r0, [r7, #8]
	assert(status == TX_SUCCESS);
 801edd4:	68bb      	ldr	r3, [r7, #8]
 801edd6:	2b00      	cmp	r3, #0
 801edd8:	d006      	beq.n	801ede8 <stm_spi_init+0x68>
 801edda:	f240 1231 	movw	r2, #305	; 0x131
 801edde:	4944      	ldr	r1, [pc, #272]	; (801eef0 <stm_spi_init+0x170>)
 801ede0:	4844      	ldr	r0, [pc, #272]	; (801eef4 <stm_spi_init+0x174>)
 801ede2:	f001 f9c3 	bl	802016c <iprintf>
 801ede6:	e7fe      	b.n	801ede6 <stm_spi_init+0x66>

	status = tx_mutex_create(&mutex_spi_trans, "mutex_spi_trans", TX_INHERIT);
 801ede8:	2334      	movs	r3, #52	; 0x34
 801edea:	2201      	movs	r2, #1
 801edec:	4944      	ldr	r1, [pc, #272]	; (801ef00 <stm_spi_init+0x180>)
 801edee:	4845      	ldr	r0, [pc, #276]	; (801ef04 <stm_spi_init+0x184>)
 801edf0:	f7f7 f934 	bl	801605c <_txe_mutex_create>
 801edf4:	60b8      	str	r0, [r7, #8]
	assert(status == TX_SUCCESS);
 801edf6:	68bb      	ldr	r3, [r7, #8]
 801edf8:	2b00      	cmp	r3, #0
 801edfa:	d006      	beq.n	801ee0a <stm_spi_init+0x8a>
 801edfc:	f44f 729a 	mov.w	r2, #308	; 0x134
 801ee00:	493b      	ldr	r1, [pc, #236]	; (801eef0 <stm_spi_init+0x170>)
 801ee02:	483c      	ldr	r0, [pc, #240]	; (801eef4 <stm_spi_init+0x174>)
 801ee04:	f001 f9b2 	bl	802016c <iprintf>
 801ee08:	e7fe      	b.n	801ee08 <stm_spi_init+0x88>

	/* Queue - tx */
	status = tx_queue_create(&to_slave_queue, "to_slave_queue", sizeof(interface_buffer_handle_t) / sizeof(ULONG), to_slave_queue_buffer, sizeof(to_slave_queue_buffer));
 801ee0a:	2338      	movs	r3, #56	; 0x38
 801ee0c:	9301      	str	r3, [sp, #4]
 801ee0e:	23c8      	movs	r3, #200	; 0xc8
 801ee10:	9300      	str	r3, [sp, #0]
 801ee12:	4b3d      	ldr	r3, [pc, #244]	; (801ef08 <stm_spi_init+0x188>)
 801ee14:	2205      	movs	r2, #5
 801ee16:	493d      	ldr	r1, [pc, #244]	; (801ef0c <stm_spi_init+0x18c>)
 801ee18:	483d      	ldr	r0, [pc, #244]	; (801ef10 <stm_spi_init+0x190>)
 801ee1a:	f7f7 fa8f 	bl	801633c <_txe_queue_create>
 801ee1e:	60b8      	str	r0, [r7, #8]
	assert(status == TX_SUCCESS);
 801ee20:	68bb      	ldr	r3, [r7, #8]
 801ee22:	2b00      	cmp	r3, #0
 801ee24:	d006      	beq.n	801ee34 <stm_spi_init+0xb4>
 801ee26:	f44f 729c 	mov.w	r2, #312	; 0x138
 801ee2a:	4931      	ldr	r1, [pc, #196]	; (801eef0 <stm_spi_init+0x170>)
 801ee2c:	4831      	ldr	r0, [pc, #196]	; (801eef4 <stm_spi_init+0x174>)
 801ee2e:	f001 f99d 	bl	802016c <iprintf>
 801ee32:	e7fe      	b.n	801ee32 <stm_spi_init+0xb2>

	/* Queue - rx */
	status = tx_queue_create(&from_slave_queue, "from_slave_queue", sizeof(interface_buffer_handle_t) / sizeof(ULONG), from_slave_queue_buffer, sizeof(from_slave_queue_buffer));
 801ee34:	2338      	movs	r3, #56	; 0x38
 801ee36:	9301      	str	r3, [sp, #4]
 801ee38:	23c8      	movs	r3, #200	; 0xc8
 801ee3a:	9300      	str	r3, [sp, #0]
 801ee3c:	4b35      	ldr	r3, [pc, #212]	; (801ef14 <stm_spi_init+0x194>)
 801ee3e:	2205      	movs	r2, #5
 801ee40:	4935      	ldr	r1, [pc, #212]	; (801ef18 <stm_spi_init+0x198>)
 801ee42:	4836      	ldr	r0, [pc, #216]	; (801ef1c <stm_spi_init+0x19c>)
 801ee44:	f7f7 fa7a 	bl	801633c <_txe_queue_create>
 801ee48:	60b8      	str	r0, [r7, #8]
	assert(status == TX_SUCCESS);
 801ee4a:	68bb      	ldr	r3, [r7, #8]
 801ee4c:	2b00      	cmp	r3, #0
 801ee4e:	d006      	beq.n	801ee5e <stm_spi_init+0xde>
 801ee50:	f44f 729e 	mov.w	r2, #316	; 0x13c
 801ee54:	4926      	ldr	r1, [pc, #152]	; (801eef0 <stm_spi_init+0x170>)
 801ee56:	4827      	ldr	r0, [pc, #156]	; (801eef4 <stm_spi_init+0x174>)
 801ee58:	f001 f988 	bl	802016c <iprintf>
 801ee5c:	e7fe      	b.n	801ee5c <stm_spi_init+0xdc>

	/* Task - SPI transaction (full duplex) */
	status = tx_thread_create(&transaction_task_id, "transaction_task",
 801ee5e:	23b4      	movs	r3, #180	; 0xb4
 801ee60:	9306      	str	r3, [sp, #24]
 801ee62:	2301      	movs	r3, #1
 801ee64:	9305      	str	r3, [sp, #20]
 801ee66:	2300      	movs	r3, #0
 801ee68:	9304      	str	r3, [sp, #16]
 801ee6a:	2300      	movs	r3, #0
 801ee6c:	9303      	str	r3, [sp, #12]
 801ee6e:	2300      	movs	r3, #0
 801ee70:	9302      	str	r3, [sp, #8]
 801ee72:	f44f 5380 	mov.w	r3, #4096	; 0x1000
 801ee76:	9301      	str	r3, [sp, #4]
 801ee78:	4b29      	ldr	r3, [pc, #164]	; (801ef20 <stm_spi_init+0x1a0>)
 801ee7a:	9300      	str	r3, [sp, #0]
 801ee7c:	2300      	movs	r3, #0
 801ee7e:	4a29      	ldr	r2, [pc, #164]	; (801ef24 <stm_spi_init+0x1a4>)
 801ee80:	4929      	ldr	r1, [pc, #164]	; (801ef28 <stm_spi_init+0x1a8>)
 801ee82:	482a      	ldr	r0, [pc, #168]	; (801ef2c <stm_spi_init+0x1ac>)
 801ee84:	f7f7 fd2e 	bl	80168e4 <_txe_thread_create>
 801ee88:	60b8      	str	r0, [r7, #8]
							  transaction_task, 0, transaction_task_stack, TRANSACTION_TASK_STACK_SIZE,
							  TRANSACTION_TASK_PRIO, TRANSACTION_TASK_PRIO, TX_NO_TIME_SLICE, TX_AUTO_START);
	assert(status == TX_SUCCESS);
 801ee8a:	68bb      	ldr	r3, [r7, #8]
 801ee8c:	2b00      	cmp	r3, #0
 801ee8e:	d006      	beq.n	801ee9e <stm_spi_init+0x11e>
 801ee90:	f44f 72a1 	mov.w	r2, #322	; 0x142
 801ee94:	4916      	ldr	r1, [pc, #88]	; (801eef0 <stm_spi_init+0x170>)
 801ee96:	4817      	ldr	r0, [pc, #92]	; (801eef4 <stm_spi_init+0x174>)
 801ee98:	f001 f968 	bl	802016c <iprintf>
 801ee9c:	e7fe      	b.n	801ee9c <stm_spi_init+0x11c>

	/* Task - RX processing */
	status = tx_thread_create(&process_rx_task_id, "process_rx_task",
 801ee9e:	23b4      	movs	r3, #180	; 0xb4
 801eea0:	9306      	str	r3, [sp, #24]
 801eea2:	2301      	movs	r3, #1
 801eea4:	9305      	str	r3, [sp, #20]
 801eea6:	2300      	movs	r3, #0
 801eea8:	9304      	str	r3, [sp, #16]
 801eeaa:	2300      	movs	r3, #0
 801eeac:	9303      	str	r3, [sp, #12]
 801eeae:	2300      	movs	r3, #0
 801eeb0:	9302      	str	r3, [sp, #8]
 801eeb2:	f44f 5380 	mov.w	r3, #4096	; 0x1000
 801eeb6:	9301      	str	r3, [sp, #4]
 801eeb8:	4b1d      	ldr	r3, [pc, #116]	; (801ef30 <stm_spi_init+0x1b0>)
 801eeba:	9300      	str	r3, [sp, #0]
 801eebc:	2300      	movs	r3, #0
 801eebe:	4a1d      	ldr	r2, [pc, #116]	; (801ef34 <stm_spi_init+0x1b4>)
 801eec0:	491d      	ldr	r1, [pc, #116]	; (801ef38 <stm_spi_init+0x1b8>)
 801eec2:	481e      	ldr	r0, [pc, #120]	; (801ef3c <stm_spi_init+0x1bc>)
 801eec4:	f7f7 fd0e 	bl	80168e4 <_txe_thread_create>
 801eec8:	60b8      	str	r0, [r7, #8]
							  process_rx_task, 0, process_rx_task_stack, PROCESS_RX_TASK_STACK_SIZE,
							  PROCESS_RX_TASK_PRIO, PROCESS_RX_TASK_PRIO, TX_NO_TIME_SLICE, TX_AUTO_START);
	assert(status == TX_SUCCESS);
 801eeca:	68bb      	ldr	r3, [r7, #8]
 801eecc:	2b00      	cmp	r3, #0
 801eece:	d006      	beq.n	801eede <stm_spi_init+0x15e>
 801eed0:	f44f 72a4 	mov.w	r2, #328	; 0x148
 801eed4:	4906      	ldr	r1, [pc, #24]	; (801eef0 <stm_spi_init+0x170>)
 801eed6:	4807      	ldr	r0, [pc, #28]	; (801eef4 <stm_spi_init+0x174>)
 801eed8:	f001 f948 	bl	802016c <iprintf>
 801eedc:	e7fe      	b.n	801eedc <stm_spi_init+0x15c>
}
 801eede:	bf00      	nop
 801eee0:	3710      	adds	r7, #16
 801eee2:	46bd      	mov	sp, r7
 801eee4:	bd80      	pop	{r7, pc}
 801eee6:	bf00      	nop
 801eee8:	2404d0b0 	.word	0x2404d0b0
 801eeec:	08025fe0 	.word	0x08025fe0
 801eef0:	08025ff8 	.word	0x08025ff8
 801eef4:	08026040 	.word	0x08026040
 801eef8:	08026054 	.word	0x08026054
 801eefc:	2404ac70 	.word	0x2404ac70
 801ef00:	08026060 	.word	0x08026060
 801ef04:	2404ac8c 	.word	0x2404ac8c
 801ef08:	2404ce28 	.word	0x2404ce28
 801ef0c:	08026070 	.word	0x08026070
 801ef10:	2404cfb8 	.word	0x2404cfb8
 801ef14:	2404cef0 	.word	0x2404cef0
 801ef18:	08026080 	.word	0x08026080
 801ef1c:	2404cff0 	.word	0x2404cff0
 801ef20:	2404be28 	.word	0x2404be28
 801ef24:	0801f48d 	.word	0x0801f48d
 801ef28:	08026094 	.word	0x08026094
 801ef2c:	2404ad74 	.word	0x2404ad74
 801ef30:	2404ae28 	.word	0x2404ae28
 801ef34:	0801f505 	.word	0x0801f505
 801ef38:	080260a8 	.word	0x080260a8
 801ef3c:	2404acc0 	.word	0x2404acc0

0801ef40 <HAL_GPIO_EXTI_Callback>:
  * @brief EXTI line detection callback, used as SPI handshake GPIO
  * @param GPIO_Pin: Specifies the pins connected EXTI line
  * @retval None
  */
void HAL_GPIO_EXTI_Callback(uint16_t GPIO_Pin)
{
 801ef40:	b580      	push	{r7, lr}
 801ef42:	b082      	sub	sp, #8
 801ef44:	af00      	add	r7, sp, #0
 801ef46:	4603      	mov	r3, r0
 801ef48:	80fb      	strh	r3, [r7, #6]
	if ( (GPIO_Pin == GPIO_DATA_READY_Pin) ||
 801ef4a:	88fb      	ldrh	r3, [r7, #6]
 801ef4c:	f5b3 4f80 	cmp.w	r3, #16384	; 0x4000
 801ef50:	d003      	beq.n	801ef5a <HAL_GPIO_EXTI_Callback+0x1a>
 801ef52:	88fb      	ldrh	r3, [r7, #6]
 801ef54:	f5b3 5f00 	cmp.w	r3, #8192	; 0x2000
 801ef58:	d102      	bne.n	801ef60 <HAL_GPIO_EXTI_Callback+0x20>
	     (GPIO_Pin == GPIO_HANDSHAKE_Pin) )
	{
		/* Post semaphore to notify SPI slave is ready for next transaction */
		(VOID)tx_semaphore_put(&osSemaphore);
 801ef5a:	4803      	ldr	r0, [pc, #12]	; (801ef68 <HAL_GPIO_EXTI_Callback+0x28>)
 801ef5c:	f7f7 fca4 	bl	80168a8 <_txe_semaphore_put>
	}
}
 801ef60:	bf00      	nop
 801ef62:	3708      	adds	r7, #8
 801ef64:	46bd      	mov	sp, r7
 801ef66:	bd80      	pop	{r7, pc}
 801ef68:	2404ac70 	.word	0x2404ac70

0801ef6c <check_and_execute_spi_transaction>:
  * @param  argument: Not used
  * @retval None
  */

static void check_and_execute_spi_transaction(void)
{
 801ef6c:	b580      	push	{r7, lr}
 801ef6e:	b082      	sub	sp, #8
 801ef70:	af00      	add	r7, sp, #0
	uint8_t * txbuff = NULL;
 801ef72:	2300      	movs	r3, #0
 801ef74:	607b      	str	r3, [r7, #4]
	uint8_t is_valid_tx_buf = 0;
 801ef76:	2300      	movs	r3, #0
 801ef78:	707b      	strb	r3, [r7, #1]
	GPIO_PinState gpio_handshake = GPIO_PIN_RESET;
 801ef7a:	2300      	movs	r3, #0
 801ef7c:	70fb      	strb	r3, [r7, #3]
	GPIO_PinState gpio_rx_data_ready = GPIO_PIN_RESET;
 801ef7e:	2300      	movs	r3, #0
 801ef80:	70bb      	strb	r3, [r7, #2]


	/* handshake line SET -> slave ready for next transaction */
	gpio_handshake = HAL_GPIO_ReadPin(GPIO_HANDSHAKE_GPIO_Port,
 801ef82:	f44f 5100 	mov.w	r1, #8192	; 0x2000
 801ef86:	4817      	ldr	r0, [pc, #92]	; (801efe4 <check_and_execute_spi_transaction+0x78>)
 801ef88:	f7e2 fefa 	bl	8001d80 <HAL_GPIO_ReadPin>
 801ef8c:	4603      	mov	r3, r0
 801ef8e:	70fb      	strb	r3, [r7, #3]
			GPIO_HANDSHAKE_Pin);

	/* data ready line SET -> slave wants to send something */
	gpio_rx_data_ready = HAL_GPIO_ReadPin(GPIO_DATA_READY_GPIO_Port,
 801ef90:	f44f 4180 	mov.w	r1, #16384	; 0x4000
 801ef94:	4813      	ldr	r0, [pc, #76]	; (801efe4 <check_and_execute_spi_transaction+0x78>)
 801ef96:	f7e2 fef3 	bl	8001d80 <HAL_GPIO_ReadPin>
 801ef9a:	4603      	mov	r3, r0
 801ef9c:	70bb      	strb	r3, [r7, #2]
			GPIO_DATA_READY_Pin);

	if (gpio_handshake == GPIO_PIN_SET) {
 801ef9e:	78fb      	ldrb	r3, [r7, #3]
 801efa0:	2b01      	cmp	r3, #1
 801efa2:	d11a      	bne.n	801efda <check_and_execute_spi_transaction+0x6e>

		/* Get next tx buffer to be sent */
		txbuff = get_tx_buffer(&is_valid_tx_buf);
 801efa4:	1c7b      	adds	r3, r7, #1
 801efa6:	4618      	mov	r0, r3
 801efa8:	f000 fb5a 	bl	801f660 <get_tx_buffer>
 801efac:	6078      	str	r0, [r7, #4]

		if ( (gpio_rx_data_ready == GPIO_PIN_SET) ||
 801efae:	78bb      	ldrb	r3, [r7, #2]
 801efb0:	2b01      	cmp	r3, #1
 801efb2:	d002      	beq.n	801efba <check_and_execute_spi_transaction+0x4e>
 801efb4:	787b      	ldrb	r3, [r7, #1]
 801efb6:	2b00      	cmp	r3, #0
 801efb8:	d00f      	beq.n	801efda <check_and_execute_spi_transaction+0x6e>

			/* Execute transaction only if EITHER holds true-
			 * a. A valid tx buffer to be transmitted towards slave
			 * b. Slave wants to send something (Rx for host)
			 */
			tx_mutex_get(&mutex_spi_trans, TX_WAIT_FOREVER);
 801efba:	f04f 31ff 	mov.w	r1, #4294967295
 801efbe:	480a      	ldr	r0, [pc, #40]	; (801efe8 <check_and_execute_spi_transaction+0x7c>)
 801efc0:	f7f7 f928 	bl	8016214 <_txe_mutex_get>
			spi_trans_func[hardware_type](txbuff);
 801efc4:	4b09      	ldr	r3, [pc, #36]	; (801efec <check_and_execute_spi_transaction+0x80>)
 801efc6:	781b      	ldrb	r3, [r3, #0]
 801efc8:	461a      	mov	r2, r3
 801efca:	4b09      	ldr	r3, [pc, #36]	; (801eff0 <check_and_execute_spi_transaction+0x84>)
 801efcc:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 801efd0:	6878      	ldr	r0, [r7, #4]
 801efd2:	4798      	blx	r3
			tx_mutex_put(&mutex_spi_trans);
 801efd4:	4804      	ldr	r0, [pc, #16]	; (801efe8 <check_and_execute_spi_transaction+0x7c>)
 801efd6:	f7f7 f977 	bl	80162c8 <_txe_mutex_put>
		}
	}
}
 801efda:	bf00      	nop
 801efdc:	3708      	adds	r7, #8
 801efde:	46bd      	mov	sp, r7
 801efe0:	bd80      	pop	{r7, pc}
 801efe2:	bf00      	nop
 801efe4:	58022400 	.word	0x58022400
 801efe8:	2404ac8c 	.word	0x2404ac8c
 801efec:	24000494 	.word	0x24000494
 801eff0:	2400048c 	.word	0x2400048c

0801eff4 <send_to_slave>:
  *         wlen - size of wbuffer
  * @retval sendbuf - Tx buffer
  */
stm_ret_t send_to_slave(uint8_t iface_type, uint8_t iface_num,
		uint8_t * wbuffer, uint16_t wlen)
{
 801eff4:	b580      	push	{r7, lr}
 801eff6:	b088      	sub	sp, #32
 801eff8:	af00      	add	r7, sp, #0
 801effa:	603a      	str	r2, [r7, #0]
 801effc:	461a      	mov	r2, r3
 801effe:	4603      	mov	r3, r0
 801f000:	71fb      	strb	r3, [r7, #7]
 801f002:	460b      	mov	r3, r1
 801f004:	71bb      	strb	r3, [r7, #6]
 801f006:	4613      	mov	r3, r2
 801f008:	80bb      	strh	r3, [r7, #4]
	interface_buffer_handle_t buf_handle = {0};
 801f00a:	f107 030c 	add.w	r3, r7, #12
 801f00e:	2200      	movs	r2, #0
 801f010:	601a      	str	r2, [r3, #0]
 801f012:	605a      	str	r2, [r3, #4]
 801f014:	609a      	str	r2, [r3, #8]
 801f016:	60da      	str	r2, [r3, #12]
 801f018:	611a      	str	r2, [r3, #16]

	if (!wbuffer || !wlen || (wlen > MAX_PAYLOAD_SIZE)) {
 801f01a:	683b      	ldr	r3, [r7, #0]
 801f01c:	2b00      	cmp	r3, #0
 801f01e:	d007      	beq.n	801f030 <send_to_slave+0x3c>
 801f020:	88bb      	ldrh	r3, [r7, #4]
 801f022:	2b00      	cmp	r3, #0
 801f024:	d004      	beq.n	801f030 <send_to_slave+0x3c>
 801f026:	88bb      	ldrh	r3, [r7, #4]
 801f028:	f240 6234 	movw	r2, #1588	; 0x634
 801f02c:	4293      	cmp	r3, r2
 801f02e:	d911      	bls.n	801f054 <send_to_slave+0x60>
		printf("write fail: buff(%p) 0? OR (0<len(%u)<=max_poss_len(%u))?\n\r",
 801f030:	88ba      	ldrh	r2, [r7, #4]
 801f032:	f240 6334 	movw	r3, #1588	; 0x634
 801f036:	6839      	ldr	r1, [r7, #0]
 801f038:	4820      	ldr	r0, [pc, #128]	; (801f0bc <send_to_slave+0xc8>)
 801f03a:	f001 f897 	bl	802016c <iprintf>
				wbuffer, wlen, MAX_PAYLOAD_SIZE);
		if(wbuffer) {
 801f03e:	683b      	ldr	r3, [r7, #0]
 801f040:	2b00      	cmp	r3, #0
 801f042:	d004      	beq.n	801f04e <send_to_slave+0x5a>
			free(wbuffer);
 801f044:	6838      	ldr	r0, [r7, #0]
 801f046:	f7fe fa1f 	bl	801d488 <esp_hosted_free>
			wbuffer = NULL;
 801f04a:	2300      	movs	r3, #0
 801f04c:	603b      	str	r3, [r7, #0]
		}
		return STM_FAIL;
 801f04e:	f04f 33ff 	mov.w	r3, #4294967295
 801f052:	e02e      	b.n	801f0b2 <send_to_slave+0xbe>
	}
	memset(&buf_handle, 0, sizeof(buf_handle));
 801f054:	f107 030c 	add.w	r3, r7, #12
 801f058:	2214      	movs	r2, #20
 801f05a:	2100      	movs	r1, #0
 801f05c:	4618      	mov	r0, r3
 801f05e:	f000 fc0d 	bl	801f87c <memset>

	buf_handle.if_type = iface_type;
 801f062:	79fb      	ldrb	r3, [r7, #7]
 801f064:	743b      	strb	r3, [r7, #16]
	buf_handle.if_num = iface_num;
 801f066:	79bb      	ldrb	r3, [r7, #6]
 801f068:	747b      	strb	r3, [r7, #17]
	buf_handle.payload_len = wlen;
 801f06a:	88bb      	ldrh	r3, [r7, #4]
 801f06c:	61bb      	str	r3, [r7, #24]
	buf_handle.payload = wbuffer;
 801f06e:	683b      	ldr	r3, [r7, #0]
 801f070:	617b      	str	r3, [r7, #20]
	buf_handle.priv_buffer_handle = wbuffer;
 801f072:	683b      	ldr	r3, [r7, #0]
 801f074:	60fb      	str	r3, [r7, #12]
	buf_handle.free_buf_handle = free;
 801f076:	4b12      	ldr	r3, [pc, #72]	; (801f0c0 <send_to_slave+0xcc>)
 801f078:	61fb      	str	r3, [r7, #28]

	if (TX_SUCCESS != tx_queue_send(&to_slave_queue, &buf_handle, TX_WAIT_FOREVER)) {
 801f07a:	f107 030c 	add.w	r3, r7, #12
 801f07e:	f04f 32ff 	mov.w	r2, #4294967295
 801f082:	4619      	mov	r1, r3
 801f084:	480f      	ldr	r0, [pc, #60]	; (801f0c4 <send_to_slave+0xd0>)
 801f086:	f7f7 faaf 	bl	80165e8 <_txe_queue_send>
 801f08a:	4603      	mov	r3, r0
 801f08c:	2b00      	cmp	r3, #0
 801f08e:	d00d      	beq.n	801f0ac <send_to_slave+0xb8>
		printf("Failed to send buffer to_slave_queue\n\r");
 801f090:	480d      	ldr	r0, [pc, #52]	; (801f0c8 <send_to_slave+0xd4>)
 801f092:	f001 f86b 	bl	802016c <iprintf>
		if(wbuffer) {
 801f096:	683b      	ldr	r3, [r7, #0]
 801f098:	2b00      	cmp	r3, #0
 801f09a:	d004      	beq.n	801f0a6 <send_to_slave+0xb2>
			free(wbuffer);
 801f09c:	6838      	ldr	r0, [r7, #0]
 801f09e:	f7fe f9f3 	bl	801d488 <esp_hosted_free>
			wbuffer = NULL;
 801f0a2:	2300      	movs	r3, #0
 801f0a4:	603b      	str	r3, [r7, #0]
		}
		return STM_FAIL;
 801f0a6:	f04f 33ff 	mov.w	r3, #4294967295
 801f0aa:	e002      	b.n	801f0b2 <send_to_slave+0xbe>
	}

	check_and_execute_spi_transaction();
 801f0ac:	f7ff ff5e 	bl	801ef6c <check_and_execute_spi_transaction>

	return STM_OK;
 801f0b0:	2300      	movs	r3, #0
}
 801f0b2:	4618      	mov	r0, r3
 801f0b4:	3720      	adds	r7, #32
 801f0b6:	46bd      	mov	sp, r7
 801f0b8:	bd80      	pop	{r7, pc}
 801f0ba:	bf00      	nop
 801f0bc:	080260b8 	.word	0x080260b8
 801f0c0:	0801d489 	.word	0x0801d489
 801f0c4:	2404cfb8 	.word	0x2404cfb8
 801f0c8:	080260f4 	.word	0x080260f4

0801f0cc <stop_spi_transactions_for_msec>:
  * @brief  Give breathing time for slave on spi
  * @param  x - for loop delay count
  * @retval None
  */
static void stop_spi_transactions_for_msec(int x)
{
 801f0cc:	b580      	push	{r7, lr}
 801f0ce:	b082      	sub	sp, #8
 801f0d0:	af00      	add	r7, sp, #0
 801f0d2:	6078      	str	r0, [r7, #4]
	hard_delay(x);
 801f0d4:	6878      	ldr	r0, [r7, #4]
 801f0d6:	f7fe fe0c 	bl	801dcf2 <hard_delay>
}
 801f0da:	bf00      	nop
 801f0dc:	3708      	adds	r7, #8
 801f0de:	46bd      	mov	sp, r7
 801f0e0:	bd80      	pop	{r7, pc}
	...

0801f0e4 <spi_transaction_esp32>:
  * @brief  Full duplex transaction SPI transaction for ESP32 hardware
  * @param  txbuff: TX SPI buffer
  * @retval STM_OK / STM_FAIL
  */
static stm_ret_t spi_transaction_esp32(uint8_t * txbuff)
{
 801f0e4:	b580      	push	{r7, lr}
 801f0e6:	b08e      	sub	sp, #56	; 0x38
 801f0e8:	af02      	add	r7, sp, #8
 801f0ea:	6078      	str	r0, [r7, #4]
	uint8_t *rxbuff = NULL;
 801f0ec:	2300      	movs	r3, #0
 801f0ee:	62fb      	str	r3, [r7, #44]	; 0x2c
	interface_buffer_handle_t buf_handle = {0};
 801f0f0:	f107 030c 	add.w	r3, r7, #12
 801f0f4:	2200      	movs	r2, #0
 801f0f6:	601a      	str	r2, [r3, #0]
 801f0f8:	605a      	str	r2, [r3, #4]
 801f0fa:	609a      	str	r2, [r3, #8]
 801f0fc:	60da      	str	r2, [r3, #12]
 801f0fe:	611a      	str	r2, [r3, #16]
	struct  esp_payload_header *payload_header;
	uint16_t len, offset;
	HAL_StatusTypeDef retval = HAL_ERROR;
 801f100:	2301      	movs	r3, #1
 801f102:	f887 302b 	strb.w	r3, [r7, #43]	; 0x2b

	/* Allocate rx buffer */
	rxbuff = (uint8_t *)malloc(MAX_SPI_BUFFER_SIZE);
 801f106:	f44f 60c8 	mov.w	r0, #1600	; 0x640
 801f10a:	f7fe f98d 	bl	801d428 <esp_hosted_malloc>
 801f10e:	62f8      	str	r0, [r7, #44]	; 0x2c
	assert(rxbuff);
 801f110:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 801f112:	2b00      	cmp	r3, #0
 801f114:	d106      	bne.n	801f124 <spi_transaction_esp32+0x40>
 801f116:	f44f 72e7 	mov.w	r2, #462	; 0x1ce
 801f11a:	4959      	ldr	r1, [pc, #356]	; (801f280 <spi_transaction_esp32+0x19c>)
 801f11c:	4859      	ldr	r0, [pc, #356]	; (801f284 <spi_transaction_esp32+0x1a0>)
 801f11e:	f001 f825 	bl	802016c <iprintf>
 801f122:	e7fe      	b.n	801f122 <spi_transaction_esp32+0x3e>
	memset(rxbuff, 0, MAX_SPI_BUFFER_SIZE);
 801f124:	f44f 62c8 	mov.w	r2, #1600	; 0x640
 801f128:	2100      	movs	r1, #0
 801f12a:	6af8      	ldr	r0, [r7, #44]	; 0x2c
 801f12c:	f000 fba6 	bl	801f87c <memset>

	if(!txbuff) {
 801f130:	687b      	ldr	r3, [r7, #4]
 801f132:	2b00      	cmp	r3, #0
 801f134:	d114      	bne.n	801f160 <spi_transaction_esp32+0x7c>
		/* Even though, there is nothing to send,
		 * valid resetted txbuff is needed for SPI driver
		 */
		txbuff = (uint8_t *)malloc(MAX_SPI_BUFFER_SIZE);
 801f136:	f44f 60c8 	mov.w	r0, #1600	; 0x640
 801f13a:	f7fe f975 	bl	801d428 <esp_hosted_malloc>
 801f13e:	6078      	str	r0, [r7, #4]
		assert(txbuff);
 801f140:	687b      	ldr	r3, [r7, #4]
 801f142:	2b00      	cmp	r3, #0
 801f144:	d106      	bne.n	801f154 <spi_transaction_esp32+0x70>
 801f146:	f44f 72eb 	mov.w	r2, #470	; 0x1d6
 801f14a:	494d      	ldr	r1, [pc, #308]	; (801f280 <spi_transaction_esp32+0x19c>)
 801f14c:	484d      	ldr	r0, [pc, #308]	; (801f284 <spi_transaction_esp32+0x1a0>)
 801f14e:	f001 f80d 	bl	802016c <iprintf>
 801f152:	e7fe      	b.n	801f152 <spi_transaction_esp32+0x6e>
		memset(txbuff, 0, MAX_SPI_BUFFER_SIZE);
 801f154:	f44f 62c8 	mov.w	r2, #1600	; 0x640
 801f158:	2100      	movs	r1, #0
 801f15a:	6878      	ldr	r0, [r7, #4]
 801f15c:	f000 fb8e 	bl	801f87c <memset>
	}

	/* SPI transaction */
	retval = HAL_SPI_TransmitReceive(&hspi5, (uint8_t*)txbuff,
 801f160:	f04f 33ff 	mov.w	r3, #4294967295
 801f164:	9300      	str	r3, [sp, #0]
 801f166:	f44f 63c8 	mov.w	r3, #1600	; 0x640
 801f16a:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 801f16c:	6879      	ldr	r1, [r7, #4]
 801f16e:	4846      	ldr	r0, [pc, #280]	; (801f288 <spi_transaction_esp32+0x1a4>)
 801f170:	f7e5 fb6c 	bl	800484c <HAL_SPI_TransmitReceive>
 801f174:	4603      	mov	r3, r0
 801f176:	f887 302b 	strb.w	r3, [r7, #43]	; 0x2b
			(uint8_t *)rxbuff, MAX_SPI_BUFFER_SIZE, HAL_MAX_DELAY);
//	retval = HAL_SPI_TransmitReceive_IT(&hspi, (uint8_t*)txbuff,
//				(uint8_t *)rxbuff, MAX_SPI_BUFFER_SIZE);

	switch(retval)
 801f17a:	f897 302b 	ldrb.w	r3, [r7, #43]	; 0x2b
 801f17e:	2b03      	cmp	r3, #3
 801f180:	d059      	beq.n	801f236 <spi_transaction_esp32+0x152>
 801f182:	2b03      	cmp	r3, #3
 801f184:	dc5f      	bgt.n	801f246 <spi_transaction_esp32+0x162>
 801f186:	2b00      	cmp	r3, #0
 801f188:	d002      	beq.n	801f190 <spi_transaction_esp32+0xac>
 801f18a:	2b01      	cmp	r3, #1
 801f18c:	d057      	beq.n	801f23e <spi_transaction_esp32+0x15a>
 801f18e:	e05a      	b.n	801f246 <spi_transaction_esp32+0x162>
		case HAL_OK:

			/* Transaction successful */

			/* create buffer rx handle, used for processing */
			payload_header = (struct esp_payload_header *) rxbuff;
 801f190:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 801f192:	627b      	str	r3, [r7, #36]	; 0x24

			/* Fetch length and offset from payload header */
			len = le16toh(payload_header->len);
 801f194:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801f196:	789a      	ldrb	r2, [r3, #2]
 801f198:	78db      	ldrb	r3, [r3, #3]
 801f19a:	021b      	lsls	r3, r3, #8
 801f19c:	4313      	orrs	r3, r2
 801f19e:	847b      	strh	r3, [r7, #34]	; 0x22
			offset = le16toh(payload_header->offset);
 801f1a0:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801f1a2:	791a      	ldrb	r2, [r3, #4]
 801f1a4:	795b      	ldrb	r3, [r3, #5]
 801f1a6:	021b      	lsls	r3, r3, #8
 801f1a8:	4313      	orrs	r3, r2
 801f1aa:	843b      	strh	r3, [r7, #32]

			if ((!len) ||
 801f1ac:	8c7b      	ldrh	r3, [r7, #34]	; 0x22
 801f1ae:	2b00      	cmp	r3, #0
 801f1b0:	d007      	beq.n	801f1c2 <spi_transaction_esp32+0xde>
 801f1b2:	8c7b      	ldrh	r3, [r7, #34]	; 0x22
 801f1b4:	f240 6234 	movw	r2, #1588	; 0x634
 801f1b8:	4293      	cmp	r3, r2
 801f1ba:	d802      	bhi.n	801f1c2 <spi_transaction_esp32+0xde>
				(len > MAX_PAYLOAD_SIZE) ||
 801f1bc:	8c3b      	ldrh	r3, [r7, #32]
 801f1be:	2b0c      	cmp	r3, #12
 801f1c0:	d00b      	beq.n	801f1da <spi_transaction_esp32+0xf6>
				 * 1. no payload to process
				 * 2. input packet size > driver capacity
				 * 3. payload header size mismatch,
				 * wrong header/bit packing?
				 * */
				if (rxbuff) {
 801f1c2:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 801f1c4:	2b00      	cmp	r3, #0
 801f1c6:	d004      	beq.n	801f1d2 <spi_transaction_esp32+0xee>
					free(rxbuff);
 801f1c8:	6af8      	ldr	r0, [r7, #44]	; 0x2c
 801f1ca:	f7fe f95d 	bl	801d488 <esp_hosted_free>
					rxbuff = NULL;
 801f1ce:	2300      	movs	r3, #0
 801f1d0:	62fb      	str	r3, [r7, #44]	; 0x2c
				}
				/* Give chance to other tasks */
				tx_thread_sleep(1);
 801f1d2:	2001      	movs	r0, #1
 801f1d4:	f7f5 fcee 	bl	8014bb4 <_tx_thread_sleep>
 801f1d8:	e024      	b.n	801f224 <spi_transaction_esp32+0x140>

			} else {

				buf_handle.priv_buffer_handle = rxbuff;
 801f1da:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 801f1dc:	60fb      	str	r3, [r7, #12]
				buf_handle.free_buf_handle = free;
 801f1de:	4b2b      	ldr	r3, [pc, #172]	; (801f28c <spi_transaction_esp32+0x1a8>)
 801f1e0:	61fb      	str	r3, [r7, #28]
				buf_handle.payload_len = len;
 801f1e2:	8c7b      	ldrh	r3, [r7, #34]	; 0x22
 801f1e4:	61bb      	str	r3, [r7, #24]
				buf_handle.if_type     = payload_header->if_type;
 801f1e6:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801f1e8:	781b      	ldrb	r3, [r3, #0]
 801f1ea:	f3c3 0303 	ubfx	r3, r3, #0, #4
 801f1ee:	b2db      	uxtb	r3, r3
 801f1f0:	743b      	strb	r3, [r7, #16]
				buf_handle.if_num      = payload_header->if_num;
 801f1f2:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801f1f4:	781b      	ldrb	r3, [r3, #0]
 801f1f6:	f3c3 1303 	ubfx	r3, r3, #4, #4
 801f1fa:	b2db      	uxtb	r3, r3
 801f1fc:	747b      	strb	r3, [r7, #17]
				buf_handle.payload     = rxbuff + offset;
 801f1fe:	8c3b      	ldrh	r3, [r7, #32]
 801f200:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 801f202:	4413      	add	r3, r2
 801f204:	617b      	str	r3, [r7, #20]

				if (TX_SUCCESS != tx_queue_send(&from_slave_queue,
 801f206:	f107 030c 	add.w	r3, r7, #12
 801f20a:	f04f 32ff 	mov.w	r2, #4294967295
 801f20e:	4619      	mov	r1, r3
 801f210:	481f      	ldr	r0, [pc, #124]	; (801f290 <spi_transaction_esp32+0x1ac>)
 801f212:	f7f7 f9e9 	bl	80165e8 <_txe_queue_send>
 801f216:	4603      	mov	r3, r0
 801f218:	2b00      	cmp	r3, #0
 801f21a:	d003      	beq.n	801f224 <spi_transaction_esp32+0x140>
							&buf_handle, TX_WAIT_FOREVER)) {
					printf("Failed to send buffer\n\r");
 801f21c:	481d      	ldr	r0, [pc, #116]	; (801f294 <spi_transaction_esp32+0x1b0>)
 801f21e:	f000 ffa5 	bl	802016c <iprintf>
					goto done;
 801f222:	e017      	b.n	801f254 <spi_transaction_esp32+0x170>
				}
			}

			/* Free input TX buffer */
			if (txbuff) {
 801f224:	687b      	ldr	r3, [r7, #4]
 801f226:	2b00      	cmp	r3, #0
 801f228:	d011      	beq.n	801f24e <spi_transaction_esp32+0x16a>
				free(txbuff);
 801f22a:	6878      	ldr	r0, [r7, #4]
 801f22c:	f7fe f92c 	bl	801d488 <esp_hosted_free>
				txbuff = NULL;
 801f230:	2300      	movs	r3, #0
 801f232:	607b      	str	r3, [r7, #4]
			}
			break;
 801f234:	e00b      	b.n	801f24e <spi_transaction_esp32+0x16a>

		case HAL_TIMEOUT:
			printf("timeout in SPI transaction\n\r");
 801f236:	4818      	ldr	r0, [pc, #96]	; (801f298 <spi_transaction_esp32+0x1b4>)
 801f238:	f000 ff98 	bl	802016c <iprintf>
			goto done;
 801f23c:	e00a      	b.n	801f254 <spi_transaction_esp32+0x170>
			break;

		case HAL_ERROR:
			printf("Error in SPI transaction\n\r");
 801f23e:	4817      	ldr	r0, [pc, #92]	; (801f29c <spi_transaction_esp32+0x1b8>)
 801f240:	f000 ff94 	bl	802016c <iprintf>
			goto done;
 801f244:	e006      	b.n	801f254 <spi_transaction_esp32+0x170>
			break;
		default:
			printf("default handler: Error in SPI transaction\n\r");
 801f246:	4816      	ldr	r0, [pc, #88]	; (801f2a0 <spi_transaction_esp32+0x1bc>)
 801f248:	f000 ff90 	bl	802016c <iprintf>
			goto done;
 801f24c:	e002      	b.n	801f254 <spi_transaction_esp32+0x170>
			break;
 801f24e:	bf00      	nop
			break;
	}

	return STM_OK;
 801f250:	2300      	movs	r3, #0
 801f252:	e011      	b.n	801f278 <spi_transaction_esp32+0x194>

done:
	/* error cases, abort */
	if (txbuff) {
 801f254:	687b      	ldr	r3, [r7, #4]
 801f256:	2b00      	cmp	r3, #0
 801f258:	d004      	beq.n	801f264 <spi_transaction_esp32+0x180>
		free(txbuff);
 801f25a:	6878      	ldr	r0, [r7, #4]
 801f25c:	f7fe f914 	bl	801d488 <esp_hosted_free>
		txbuff = NULL;
 801f260:	2300      	movs	r3, #0
 801f262:	607b      	str	r3, [r7, #4]
	}

	if (rxbuff) {
 801f264:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 801f266:	2b00      	cmp	r3, #0
 801f268:	d004      	beq.n	801f274 <spi_transaction_esp32+0x190>
		free(rxbuff);
 801f26a:	6af8      	ldr	r0, [r7, #44]	; 0x2c
 801f26c:	f7fe f90c 	bl	801d488 <esp_hosted_free>
		rxbuff = NULL;
 801f270:	2300      	movs	r3, #0
 801f272:	62fb      	str	r3, [r7, #44]	; 0x2c
	}
	return STM_FAIL;
 801f274:	f04f 33ff 	mov.w	r3, #4294967295
}
 801f278:	4618      	mov	r0, r3
 801f27a:	3730      	adds	r7, #48	; 0x30
 801f27c:	46bd      	mov	sp, r7
 801f27e:	bd80      	pop	{r7, pc}
 801f280:	08025ff8 	.word	0x08025ff8
 801f284:	08026040 	.word	0x08026040
 801f288:	2400098c 	.word	0x2400098c
 801f28c:	0801d489 	.word	0x0801d489
 801f290:	2404cff0 	.word	0x2404cff0
 801f294:	0802611c 	.word	0x0802611c
 801f298:	08026134 	.word	0x08026134
 801f29c:	08026154 	.word	0x08026154
 801f2a0:	08026170 	.word	0x08026170

0801f2a4 <spi_transaction_esp32s2>:
  * @brief  Full duplex transaction SPI transaction for ESP32S2 hardware
  * @param  txbuff: TX SPI buffer
  * @retval STM_OK / STM_FAIL
  */
static stm_ret_t spi_transaction_esp32s2(uint8_t * txbuff)
{
 801f2a4:	b580      	push	{r7, lr}
 801f2a6:	b08e      	sub	sp, #56	; 0x38
 801f2a8:	af02      	add	r7, sp, #8
 801f2aa:	6078      	str	r0, [r7, #4]
	uint8_t *rxbuff = NULL;
 801f2ac:	2300      	movs	r3, #0
 801f2ae:	62fb      	str	r3, [r7, #44]	; 0x2c
	interface_buffer_handle_t buf_handle = {0};
 801f2b0:	f107 030c 	add.w	r3, r7, #12
 801f2b4:	2200      	movs	r2, #0
 801f2b6:	601a      	str	r2, [r3, #0]
 801f2b8:	605a      	str	r2, [r3, #4]
 801f2ba:	609a      	str	r2, [r3, #8]
 801f2bc:	60da      	str	r2, [r3, #12]
 801f2be:	611a      	str	r2, [r3, #16]
	struct  esp_payload_header *payload_header;
	uint16_t len, offset;
	HAL_StatusTypeDef retval = HAL_ERROR;
 801f2c0:	2301      	movs	r3, #1
 801f2c2:	f887 302b 	strb.w	r3, [r7, #43]	; 0x2b

	/* Allocate rx buffer */
	rxbuff = (uint8_t *)malloc(MAX_SPI_BUFFER_SIZE);
 801f2c6:	f44f 60c8 	mov.w	r0, #1600	; 0x640
 801f2ca:	f7fe f8ad 	bl	801d428 <esp_hosted_malloc>
 801f2ce:	62f8      	str	r0, [r7, #44]	; 0x2c
	assert(rxbuff);
 801f2d0:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 801f2d2:	2b00      	cmp	r3, #0
 801f2d4:	d106      	bne.n	801f2e4 <spi_transaction_esp32s2+0x40>
 801f2d6:	f240 2243 	movw	r2, #579	; 0x243
 801f2da:	4962      	ldr	r1, [pc, #392]	; (801f464 <spi_transaction_esp32s2+0x1c0>)
 801f2dc:	4862      	ldr	r0, [pc, #392]	; (801f468 <spi_transaction_esp32s2+0x1c4>)
 801f2de:	f000 ff45 	bl	802016c <iprintf>
 801f2e2:	e7fe      	b.n	801f2e2 <spi_transaction_esp32s2+0x3e>
	memset(rxbuff, 0, MAX_SPI_BUFFER_SIZE);
 801f2e4:	f44f 62c8 	mov.w	r2, #1600	; 0x640
 801f2e8:	2100      	movs	r1, #0
 801f2ea:	6af8      	ldr	r0, [r7, #44]	; 0x2c
 801f2ec:	f000 fac6 	bl	801f87c <memset>

	if(!txbuff) {
 801f2f0:	687b      	ldr	r3, [r7, #4]
 801f2f2:	2b00      	cmp	r3, #0
 801f2f4:	d114      	bne.n	801f320 <spi_transaction_esp32s2+0x7c>
		/* Even though, there is nothing to send,
		 * valid resetted txbuff is needed for SPI driver
		 */
		txbuff = (uint8_t *)malloc(MAX_SPI_BUFFER_SIZE);
 801f2f6:	f44f 60c8 	mov.w	r0, #1600	; 0x640
 801f2fa:	f7fe f895 	bl	801d428 <esp_hosted_malloc>
 801f2fe:	6078      	str	r0, [r7, #4]
		assert(txbuff);
 801f300:	687b      	ldr	r3, [r7, #4]
 801f302:	2b00      	cmp	r3, #0
 801f304:	d106      	bne.n	801f314 <spi_transaction_esp32s2+0x70>
 801f306:	f240 224b 	movw	r2, #587	; 0x24b
 801f30a:	4956      	ldr	r1, [pc, #344]	; (801f464 <spi_transaction_esp32s2+0x1c0>)
 801f30c:	4856      	ldr	r0, [pc, #344]	; (801f468 <spi_transaction_esp32s2+0x1c4>)
 801f30e:	f000 ff2d 	bl	802016c <iprintf>
 801f312:	e7fe      	b.n	801f312 <spi_transaction_esp32s2+0x6e>
		memset(txbuff, 0, MAX_SPI_BUFFER_SIZE);
 801f314:	f44f 62c8 	mov.w	r2, #1600	; 0x640
 801f318:	2100      	movs	r1, #0
 801f31a:	6878      	ldr	r0, [r7, #4]
 801f31c:	f000 faae 	bl	801f87c <memset>
	}

	/* SPI transaction */
	HAL_GPIO_WritePin(USR_SPI_CS_GPIO_Port, USR_SPI_CS_Pin, GPIO_PIN_RESET);
 801f320:	2200      	movs	r2, #0
 801f322:	2102      	movs	r1, #2
 801f324:	4851      	ldr	r0, [pc, #324]	; (801f46c <spi_transaction_esp32s2+0x1c8>)
 801f326:	f7e2 fd43 	bl	8001db0 <HAL_GPIO_WritePin>
	retval = HAL_SPI_TransmitReceive(&hspi, (uint8_t*)txbuff,
 801f32a:	f04f 33ff 	mov.w	r3, #4294967295
 801f32e:	9300      	str	r3, [sp, #0]
 801f330:	f44f 63c8 	mov.w	r3, #1600	; 0x640
 801f334:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 801f336:	6879      	ldr	r1, [r7, #4]
 801f338:	484d      	ldr	r0, [pc, #308]	; (801f470 <spi_transaction_esp32s2+0x1cc>)
 801f33a:	f7e5 fa87 	bl	800484c <HAL_SPI_TransmitReceive>
 801f33e:	4603      	mov	r3, r0
 801f340:	f887 302b 	strb.w	r3, [r7, #43]	; 0x2b
			(uint8_t *)rxbuff, MAX_SPI_BUFFER_SIZE, HAL_MAX_DELAY);
	while( hspi.State == HAL_SPI_STATE_BUSY );
 801f344:	bf00      	nop
 801f346:	4b4a      	ldr	r3, [pc, #296]	; (801f470 <spi_transaction_esp32s2+0x1cc>)
 801f348:	f893 3081 	ldrb.w	r3, [r3, #129]	; 0x81
 801f34c:	b2db      	uxtb	r3, r3
 801f34e:	2b02      	cmp	r3, #2
 801f350:	d0f9      	beq.n	801f346 <spi_transaction_esp32s2+0xa2>
	HAL_GPIO_WritePin(USR_SPI_CS_GPIO_Port, USR_SPI_CS_Pin, GPIO_PIN_SET);
 801f352:	2201      	movs	r2, #1
 801f354:	2102      	movs	r1, #2
 801f356:	4845      	ldr	r0, [pc, #276]	; (801f46c <spi_transaction_esp32s2+0x1c8>)
 801f358:	f7e2 fd2a 	bl	8001db0 <HAL_GPIO_WritePin>

	switch(retval)
 801f35c:	f897 302b 	ldrb.w	r3, [r7, #43]	; 0x2b
 801f360:	2b03      	cmp	r3, #3
 801f362:	d059      	beq.n	801f418 <spi_transaction_esp32s2+0x174>
 801f364:	2b03      	cmp	r3, #3
 801f366:	dc5f      	bgt.n	801f428 <spi_transaction_esp32s2+0x184>
 801f368:	2b00      	cmp	r3, #0
 801f36a:	d002      	beq.n	801f372 <spi_transaction_esp32s2+0xce>
 801f36c:	2b01      	cmp	r3, #1
 801f36e:	d057      	beq.n	801f420 <spi_transaction_esp32s2+0x17c>
 801f370:	e05a      	b.n	801f428 <spi_transaction_esp32s2+0x184>
		case HAL_OK:

			/* Transaction successful */

			/* create buffer rx handle, used for processing */
			payload_header = (struct esp_payload_header *) rxbuff;
 801f372:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 801f374:	627b      	str	r3, [r7, #36]	; 0x24

			/* Fetch length and offset from payload header */
			len = le16toh(payload_header->len);
 801f376:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801f378:	789a      	ldrb	r2, [r3, #2]
 801f37a:	78db      	ldrb	r3, [r3, #3]
 801f37c:	021b      	lsls	r3, r3, #8
 801f37e:	4313      	orrs	r3, r2
 801f380:	847b      	strh	r3, [r7, #34]	; 0x22
			offset = le16toh(payload_header->offset);
 801f382:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801f384:	791a      	ldrb	r2, [r3, #4]
 801f386:	795b      	ldrb	r3, [r3, #5]
 801f388:	021b      	lsls	r3, r3, #8
 801f38a:	4313      	orrs	r3, r2
 801f38c:	843b      	strh	r3, [r7, #32]

			if ((!len) ||
 801f38e:	8c7b      	ldrh	r3, [r7, #34]	; 0x22
 801f390:	2b00      	cmp	r3, #0
 801f392:	d007      	beq.n	801f3a4 <spi_transaction_esp32s2+0x100>
 801f394:	8c7b      	ldrh	r3, [r7, #34]	; 0x22
 801f396:	f240 6234 	movw	r2, #1588	; 0x634
 801f39a:	4293      	cmp	r3, r2
 801f39c:	d802      	bhi.n	801f3a4 <spi_transaction_esp32s2+0x100>
				(len > MAX_PAYLOAD_SIZE) ||
 801f39e:	8c3b      	ldrh	r3, [r7, #32]
 801f3a0:	2b0c      	cmp	r3, #12
 801f3a2:	d00b      	beq.n	801f3bc <spi_transaction_esp32s2+0x118>
				 * 1. no payload to process
				 * 2. input packet size > driver capacity
				 * 3. payload header size mismatch,
				 * wrong header/bit packing?
				 * */
				if (rxbuff) {
 801f3a4:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 801f3a6:	2b00      	cmp	r3, #0
 801f3a8:	d004      	beq.n	801f3b4 <spi_transaction_esp32s2+0x110>
					free(rxbuff);
 801f3aa:	6af8      	ldr	r0, [r7, #44]	; 0x2c
 801f3ac:	f7fe f86c 	bl	801d488 <esp_hosted_free>
					rxbuff = NULL;
 801f3b0:	2300      	movs	r3, #0
 801f3b2:	62fb      	str	r3, [r7, #44]	; 0x2c
				}
				/* Give chance to other tasks */
				tx_thread_sleep(1);
 801f3b4:	2001      	movs	r0, #1
 801f3b6:	f7f5 fbfd 	bl	8014bb4 <_tx_thread_sleep>
 801f3ba:	e024      	b.n	801f406 <spi_transaction_esp32s2+0x162>

			} else {

				buf_handle.priv_buffer_handle = rxbuff;
 801f3bc:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 801f3be:	60fb      	str	r3, [r7, #12]
				buf_handle.free_buf_handle = free;
 801f3c0:	4b2c      	ldr	r3, [pc, #176]	; (801f474 <spi_transaction_esp32s2+0x1d0>)
 801f3c2:	61fb      	str	r3, [r7, #28]
				buf_handle.payload_len = len;
 801f3c4:	8c7b      	ldrh	r3, [r7, #34]	; 0x22
 801f3c6:	61bb      	str	r3, [r7, #24]
				buf_handle.if_type     = payload_header->if_type;
 801f3c8:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801f3ca:	781b      	ldrb	r3, [r3, #0]
 801f3cc:	f3c3 0303 	ubfx	r3, r3, #0, #4
 801f3d0:	b2db      	uxtb	r3, r3
 801f3d2:	743b      	strb	r3, [r7, #16]
				buf_handle.if_num      = payload_header->if_num;
 801f3d4:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801f3d6:	781b      	ldrb	r3, [r3, #0]
 801f3d8:	f3c3 1303 	ubfx	r3, r3, #4, #4
 801f3dc:	b2db      	uxtb	r3, r3
 801f3de:	747b      	strb	r3, [r7, #17]
				buf_handle.payload     = rxbuff + offset;
 801f3e0:	8c3b      	ldrh	r3, [r7, #32]
 801f3e2:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 801f3e4:	4413      	add	r3, r2
 801f3e6:	617b      	str	r3, [r7, #20]

				if (TX_SUCCESS != tx_queue_send(&from_slave_queue,
 801f3e8:	f107 030c 	add.w	r3, r7, #12
 801f3ec:	f04f 32ff 	mov.w	r2, #4294967295
 801f3f0:	4619      	mov	r1, r3
 801f3f2:	4821      	ldr	r0, [pc, #132]	; (801f478 <spi_transaction_esp32s2+0x1d4>)
 801f3f4:	f7f7 f8f8 	bl	80165e8 <_txe_queue_send>
 801f3f8:	4603      	mov	r3, r0
 801f3fa:	2b00      	cmp	r3, #0
 801f3fc:	d003      	beq.n	801f406 <spi_transaction_esp32s2+0x162>
							&buf_handle, TX_WAIT_FOREVER)) {
					printf("Failed to send buffer\n\r");
 801f3fe:	481f      	ldr	r0, [pc, #124]	; (801f47c <spi_transaction_esp32s2+0x1d8>)
 801f400:	f000 feb4 	bl	802016c <iprintf>
					goto done;
 801f404:	e017      	b.n	801f436 <spi_transaction_esp32s2+0x192>
				}
			}

			/* Free input TX buffer */
			if (txbuff) {
 801f406:	687b      	ldr	r3, [r7, #4]
 801f408:	2b00      	cmp	r3, #0
 801f40a:	d011      	beq.n	801f430 <spi_transaction_esp32s2+0x18c>
				free(txbuff);
 801f40c:	6878      	ldr	r0, [r7, #4]
 801f40e:	f7fe f83b 	bl	801d488 <esp_hosted_free>
				txbuff = NULL;
 801f412:	2300      	movs	r3, #0
 801f414:	607b      	str	r3, [r7, #4]
			}
			break;
 801f416:	e00b      	b.n	801f430 <spi_transaction_esp32s2+0x18c>

		case HAL_TIMEOUT:
			printf("timeout in SPI transaction\n\r");
 801f418:	4819      	ldr	r0, [pc, #100]	; (801f480 <spi_transaction_esp32s2+0x1dc>)
 801f41a:	f000 fea7 	bl	802016c <iprintf>
			goto done;
 801f41e:	e00a      	b.n	801f436 <spi_transaction_esp32s2+0x192>
			break;

		case HAL_ERROR:
			printf("Error in SPI transaction\n\r");
 801f420:	4818      	ldr	r0, [pc, #96]	; (801f484 <spi_transaction_esp32s2+0x1e0>)
 801f422:	f000 fea3 	bl	802016c <iprintf>
			goto done;
 801f426:	e006      	b.n	801f436 <spi_transaction_esp32s2+0x192>
			break;
		default:
			printf("default handler: Error in SPI transaction\n\r");
 801f428:	4817      	ldr	r0, [pc, #92]	; (801f488 <spi_transaction_esp32s2+0x1e4>)
 801f42a:	f000 fe9f 	bl	802016c <iprintf>
			goto done;
 801f42e:	e002      	b.n	801f436 <spi_transaction_esp32s2+0x192>
			break;
 801f430:	bf00      	nop
			break;
	}

	return STM_OK;
 801f432:	2300      	movs	r3, #0
 801f434:	e011      	b.n	801f45a <spi_transaction_esp32s2+0x1b6>

done:
	/* error cases, abort */
	if (txbuff) {
 801f436:	687b      	ldr	r3, [r7, #4]
 801f438:	2b00      	cmp	r3, #0
 801f43a:	d004      	beq.n	801f446 <spi_transaction_esp32s2+0x1a2>
		free(txbuff);
 801f43c:	6878      	ldr	r0, [r7, #4]
 801f43e:	f7fe f823 	bl	801d488 <esp_hosted_free>
		txbuff = NULL;
 801f442:	2300      	movs	r3, #0
 801f444:	607b      	str	r3, [r7, #4]
	}

	if (rxbuff) {
 801f446:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 801f448:	2b00      	cmp	r3, #0
 801f44a:	d004      	beq.n	801f456 <spi_transaction_esp32s2+0x1b2>
		free(rxbuff);
 801f44c:	6af8      	ldr	r0, [r7, #44]	; 0x2c
 801f44e:	f7fe f81b 	bl	801d488 <esp_hosted_free>
		rxbuff = NULL;
 801f452:	2300      	movs	r3, #0
 801f454:	62fb      	str	r3, [r7, #44]	; 0x2c
	}
	return STM_FAIL;
 801f456:	f04f 33ff 	mov.w	r3, #4294967295
}
 801f45a:	4618      	mov	r0, r3
 801f45c:	3730      	adds	r7, #48	; 0x30
 801f45e:	46bd      	mov	sp, r7
 801f460:	bd80      	pop	{r7, pc}
 801f462:	bf00      	nop
 801f464:	08025ff8 	.word	0x08025ff8
 801f468:	08026040 	.word	0x08026040
 801f46c:	58022800 	.word	0x58022800
 801f470:	2404d028 	.word	0x2404d028
 801f474:	0801d489 	.word	0x0801d489
 801f478:	2404cff0 	.word	0x2404cff0
 801f47c:	0802611c 	.word	0x0802611c
 801f480:	08026134 	.word	0x08026134
 801f484:	08026154 	.word	0x08026154
 801f488:	08026170 	.word	0x08026170

0801f48c <transaction_task>:
  * @brief  Task for SPI transaction
  * @param  argument: Not used
  * @retval None
  */
static void transaction_task(ULONG pvParameters)
{
 801f48c:	b580      	push	{r7, lr}
 801f48e:	b082      	sub	sp, #8
 801f490:	af00      	add	r7, sp, #0
 801f492:	6078      	str	r0, [r7, #4]
	if (hardware_type == HARDWARE_TYPE_ESP32) {
 801f494:	4b14      	ldr	r3, [pc, #80]	; (801f4e8 <transaction_task+0x5c>)
 801f496:	781b      	ldrb	r3, [r3, #0]
 801f498:	2b00      	cmp	r3, #0
 801f49a:	d103      	bne.n	801f4a4 <transaction_task+0x18>
		printf("\n\rESP-Hosted for ESP32\n\r");
 801f49c:	4813      	ldr	r0, [pc, #76]	; (801f4ec <transaction_task+0x60>)
 801f49e:	f000 fe65 	bl	802016c <iprintf>
 801f4a2:	e015      	b.n	801f4d0 <transaction_task+0x44>
	} else if (hardware_type == HARDWARE_TYPE_ESP32S2_ESP32C3) {
 801f4a4:	4b10      	ldr	r3, [pc, #64]	; (801f4e8 <transaction_task+0x5c>)
 801f4a6:	781b      	ldrb	r3, [r3, #0]
 801f4a8:	2b01      	cmp	r3, #1
 801f4aa:	d103      	bne.n	801f4b4 <transaction_task+0x28>
		printf("\n\rESP-Hosted for ESP32S2 or ESP32C3\n\r");
 801f4ac:	4810      	ldr	r0, [pc, #64]	; (801f4f0 <transaction_task+0x64>)
 801f4ae:	f000 fe5d 	bl	802016c <iprintf>
 801f4b2:	e00d      	b.n	801f4d0 <transaction_task+0x44>
	} else {
		printf("Unsupported slave hardware\n\r");
 801f4b4:	480f      	ldr	r0, [pc, #60]	; (801f4f4 <transaction_task+0x68>)
 801f4b6:	f000 fe59 	bl	802016c <iprintf>
		assert(hardware_type != HARDWARE_TYPE_INVALID);
 801f4ba:	4b0b      	ldr	r3, [pc, #44]	; (801f4e8 <transaction_task+0x5c>)
 801f4bc:	781b      	ldrb	r3, [r3, #0]
 801f4be:	2b02      	cmp	r3, #2
 801f4c0:	d106      	bne.n	801f4d0 <transaction_task+0x44>
 801f4c2:	f240 22b7 	movw	r2, #695	; 0x2b7
 801f4c6:	490c      	ldr	r1, [pc, #48]	; (801f4f8 <transaction_task+0x6c>)
 801f4c8:	480c      	ldr	r0, [pc, #48]	; (801f4fc <transaction_task+0x70>)
 801f4ca:	f000 fe4f 	bl	802016c <iprintf>
 801f4ce:	e7fe      	b.n	801f4ce <transaction_task+0x42>
	}

	for (;;) {
		/* Wait till slave is ready for next transaction */
		if (tx_semaphore_get(&osSemaphore, TX_WAIT_FOREVER) == TX_SUCCESS) {
 801f4d0:	f04f 31ff 	mov.w	r1, #4294967295
 801f4d4:	480a      	ldr	r0, [pc, #40]	; (801f500 <transaction_task+0x74>)
 801f4d6:	f7f7 f9a5 	bl	8016824 <_txe_semaphore_get>
 801f4da:	4603      	mov	r3, r0
 801f4dc:	2b00      	cmp	r3, #0
 801f4de:	d1f7      	bne.n	801f4d0 <transaction_task+0x44>
			check_and_execute_spi_transaction();
 801f4e0:	f7ff fd44 	bl	801ef6c <check_and_execute_spi_transaction>
		if (tx_semaphore_get(&osSemaphore, TX_WAIT_FOREVER) == TX_SUCCESS) {
 801f4e4:	e7f4      	b.n	801f4d0 <transaction_task+0x44>
 801f4e6:	bf00      	nop
 801f4e8:	24000494 	.word	0x24000494
 801f4ec:	0802619c 	.word	0x0802619c
 801f4f0:	080261b8 	.word	0x080261b8
 801f4f4:	080261e0 	.word	0x080261e0
 801f4f8:	08025ff8 	.word	0x08025ff8
 801f4fc:	08026040 	.word	0x08026040
 801f500:	2404ac70 	.word	0x2404ac70

0801f504 <process_rx_task>:
  * @brief  RX processing task
  * @param  argument: Not used
  * @retval None
  */
static void process_rx_task(ULONG pvParameters)
{
 801f504:	b580      	push	{r7, lr}
 801f506:	b08c      	sub	sp, #48	; 0x30
 801f508:	af00      	add	r7, sp, #0
 801f50a:	6078      	str	r0, [r7, #4]
	interface_buffer_handle_t buf_handle = {0};
 801f50c:	f107 0308 	add.w	r3, r7, #8
 801f510:	2200      	movs	r2, #0
 801f512:	601a      	str	r2, [r3, #0]
 801f514:	605a      	str	r2, [r3, #4]
 801f516:	609a      	str	r2, [r3, #8]
 801f518:	60da      	str	r2, [r3, #12]
 801f51a:	611a      	str	r2, [r3, #16]
	uint8_t *payload = NULL;
 801f51c:	2300      	movs	r3, #0
 801f51e:	62fb      	str	r3, [r7, #44]	; 0x2c
	struct pbuf *buffer = NULL;
 801f520:	2300      	movs	r3, #0
 801f522:	62bb      	str	r3, [r7, #40]	; 0x28
	struct esp_priv_event *event = NULL;
 801f524:	2300      	movs	r3, #0
 801f526:	627b      	str	r3, [r7, #36]	; 0x24
	struct esp_private *priv = NULL;
 801f528:	2300      	movs	r3, #0
 801f52a:	623b      	str	r3, [r7, #32]
	uint8_t *serial_buf = NULL;
 801f52c:	2300      	movs	r3, #0
 801f52e:	61fb      	str	r3, [r7, #28]

	while (1) {


		if (TX_SUCCESS != tx_queue_receive(&from_slave_queue, &buf_handle, TX_WAIT_FOREVER)) {
 801f530:	f107 0308 	add.w	r3, r7, #8
 801f534:	f04f 32ff 	mov.w	r2, #4294967295
 801f538:	4619      	mov	r1, r3
 801f53a:	4845      	ldr	r0, [pc, #276]	; (801f650 <process_rx_task+0x14c>)
 801f53c:	f7f7 f80a 	bl	8016554 <_txe_queue_receive>
 801f540:	4603      	mov	r3, r0
 801f542:	2b00      	cmp	r3, #0
 801f544:	f040 8082 	bne.w	801f64c <process_rx_task+0x148>
			continue;
		}

		/* point to payload */
		payload = buf_handle.payload;
 801f548:	693b      	ldr	r3, [r7, #16]
 801f54a:	62fb      	str	r3, [r7, #44]	; 0x2c

		/* process received buffer for all possible interface types */
		if (buf_handle.if_type == ESP_SERIAL_IF) {
 801f54c:	7b3b      	ldrb	r3, [r7, #12]
 801f54e:	2b02      	cmp	r3, #2
 801f550:	d11c      	bne.n	801f58c <process_rx_task+0x88>

			serial_buf = (uint8_t *)malloc(buf_handle.payload_len);
 801f552:	697b      	ldr	r3, [r7, #20]
 801f554:	4618      	mov	r0, r3
 801f556:	f7fd ff67 	bl	801d428 <esp_hosted_malloc>
 801f55a:	61f8      	str	r0, [r7, #28]
			assert(serial_buf);
 801f55c:	69fb      	ldr	r3, [r7, #28]
 801f55e:	2b00      	cmp	r3, #0
 801f560:	d106      	bne.n	801f570 <process_rx_task+0x6c>
 801f562:	f240 22de 	movw	r2, #734	; 0x2de
 801f566:	493b      	ldr	r1, [pc, #236]	; (801f654 <process_rx_task+0x150>)
 801f568:	483b      	ldr	r0, [pc, #236]	; (801f658 <process_rx_task+0x154>)
 801f56a:	f000 fdff 	bl	802016c <iprintf>
 801f56e:	e7fe      	b.n	801f56e <process_rx_task+0x6a>

			memcpy(serial_buf, payload, buf_handle.payload_len);
 801f570:	697b      	ldr	r3, [r7, #20]
 801f572:	461a      	mov	r2, r3
 801f574:	6af9      	ldr	r1, [r7, #44]	; 0x2c
 801f576:	69f8      	ldr	r0, [r7, #28]
 801f578:	f000 f958 	bl	801f82c <memcpy>

			/* serial interface path */
			serial_rx_handler(buf_handle.if_num, serial_buf,
 801f57c:	7b7b      	ldrb	r3, [r7, #13]
					buf_handle.payload_len);
 801f57e:	697a      	ldr	r2, [r7, #20]
			serial_rx_handler(buf_handle.if_num, serial_buf,
 801f580:	b292      	uxth	r2, r2
 801f582:	69f9      	ldr	r1, [r7, #28]
 801f584:	4618      	mov	r0, r3
 801f586:	f7ff f9e3 	bl	801e950 <serial_rx_handler>
 801f58a:	e056      	b.n	801f63a <process_rx_task+0x136>

		} else if((buf_handle.if_type == ESP_STA_IF) ||
 801f58c:	7b3b      	ldrb	r3, [r7, #12]
 801f58e:	2b00      	cmp	r3, #0
 801f590:	d002      	beq.n	801f598 <process_rx_task+0x94>
				(buf_handle.if_type == ESP_AP_IF)) {
 801f592:	7b3b      	ldrb	r3, [r7, #12]
		} else if((buf_handle.if_type == ESP_STA_IF) ||
 801f594:	2b01      	cmp	r3, #1
 801f596:	d13b      	bne.n	801f610 <process_rx_task+0x10c>
			priv = get_priv(buf_handle.if_type, buf_handle.if_num);
 801f598:	7b3b      	ldrb	r3, [r7, #12]
 801f59a:	7b7a      	ldrb	r2, [r7, #13]
 801f59c:	4611      	mov	r1, r2
 801f59e:	4618      	mov	r0, r3
 801f5a0:	f7ff fa9e 	bl	801eae0 <get_priv>
 801f5a4:	6238      	str	r0, [r7, #32]

			if (priv) {
 801f5a6:	6a3b      	ldr	r3, [r7, #32]
 801f5a8:	2b00      	cmp	r3, #0
 801f5aa:	d046      	beq.n	801f63a <process_rx_task+0x136>
				buffer = (struct pbuf *)malloc(sizeof(struct pbuf));
 801f5ac:	2008      	movs	r0, #8
 801f5ae:	f7fd ff3b 	bl	801d428 <esp_hosted_malloc>
 801f5b2:	62b8      	str	r0, [r7, #40]	; 0x28
				assert(buffer);
 801f5b4:	6abb      	ldr	r3, [r7, #40]	; 0x28
 801f5b6:	2b00      	cmp	r3, #0
 801f5b8:	d106      	bne.n	801f5c8 <process_rx_task+0xc4>
 801f5ba:	f44f 723b 	mov.w	r2, #748	; 0x2ec
 801f5be:	4925      	ldr	r1, [pc, #148]	; (801f654 <process_rx_task+0x150>)
 801f5c0:	4825      	ldr	r0, [pc, #148]	; (801f658 <process_rx_task+0x154>)
 801f5c2:	f000 fdd3 	bl	802016c <iprintf>
 801f5c6:	e7fe      	b.n	801f5c6 <process_rx_task+0xc2>

				buffer->len = buf_handle.payload_len;
 801f5c8:	697b      	ldr	r3, [r7, #20]
 801f5ca:	b29a      	uxth	r2, r3
 801f5cc:	6abb      	ldr	r3, [r7, #40]	; 0x28
 801f5ce:	809a      	strh	r2, [r3, #4]
				buffer->payload = malloc(buf_handle.payload_len);
 801f5d0:	697b      	ldr	r3, [r7, #20]
 801f5d2:	4618      	mov	r0, r3
 801f5d4:	f7fd ff28 	bl	801d428 <esp_hosted_malloc>
 801f5d8:	4602      	mov	r2, r0
 801f5da:	6abb      	ldr	r3, [r7, #40]	; 0x28
 801f5dc:	601a      	str	r2, [r3, #0]
				assert(buffer->payload);
 801f5de:	6abb      	ldr	r3, [r7, #40]	; 0x28
 801f5e0:	681b      	ldr	r3, [r3, #0]
 801f5e2:	2b00      	cmp	r3, #0
 801f5e4:	d106      	bne.n	801f5f4 <process_rx_task+0xf0>
 801f5e6:	f44f 723c 	mov.w	r2, #752	; 0x2f0
 801f5ea:	491a      	ldr	r1, [pc, #104]	; (801f654 <process_rx_task+0x150>)
 801f5ec:	481a      	ldr	r0, [pc, #104]	; (801f658 <process_rx_task+0x154>)
 801f5ee:	f000 fdbd 	bl	802016c <iprintf>
 801f5f2:	e7fe      	b.n	801f5f2 <process_rx_task+0xee>

				memcpy(buffer->payload, buf_handle.payload,
 801f5f4:	6abb      	ldr	r3, [r7, #40]	; 0x28
 801f5f6:	681b      	ldr	r3, [r3, #0]
 801f5f8:	6939      	ldr	r1, [r7, #16]
 801f5fa:	697a      	ldr	r2, [r7, #20]
 801f5fc:	4618      	mov	r0, r3
 801f5fe:	f000 f915 	bl	801f82c <memcpy>
						buf_handle.payload_len);

				netdev_rx(priv->netdev, buffer);
 801f602:	6a3b      	ldr	r3, [r7, #32]
 801f604:	685b      	ldr	r3, [r3, #4]
 801f606:	6ab9      	ldr	r1, [r7, #40]	; 0x28
 801f608:	4618      	mov	r0, r3
 801f60a:	f7ff f845 	bl	801e698 <netdev_rx>
			if (priv) {
 801f60e:	e014      	b.n	801f63a <process_rx_task+0x136>
			}

		} else if (buf_handle.if_type == ESP_PRIV_IF) {
 801f610:	7b3b      	ldrb	r3, [r7, #12]
 801f612:	2b04      	cmp	r3, #4
 801f614:	d111      	bne.n	801f63a <process_rx_task+0x136>
			/* priv transaction received */

			event = (struct esp_priv_event *) (payload);
 801f616:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 801f618:	627b      	str	r3, [r7, #36]	; 0x24
			if (event->event_type == ESP_PRIV_EVENT_INIT) {
 801f61a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801f61c:	781b      	ldrb	r3, [r3, #0]
 801f61e:	2b00      	cmp	r3, #0
 801f620:	d10b      	bne.n	801f63a <process_rx_task+0x136>
				/* halt spi transactions for some time,
				 * this is one time delay, to give breathing
				 * time to slave before spi trans start */
				stop_spi_transactions_for_msec(50000);
 801f622:	f24c 3050 	movw	r0, #50000	; 0xc350
 801f626:	f7ff fd51 	bl	801f0cc <stop_spi_transactions_for_msec>
				if (spi_drv_evt_handler_fp) {
 801f62a:	4b0c      	ldr	r3, [pc, #48]	; (801f65c <process_rx_task+0x158>)
 801f62c:	681b      	ldr	r3, [r3, #0]
 801f62e:	2b00      	cmp	r3, #0
 801f630:	d003      	beq.n	801f63a <process_rx_task+0x136>
					spi_drv_evt_handler_fp(SPI_DRIVER_ACTIVE);
 801f632:	4b0a      	ldr	r3, [pc, #40]	; (801f65c <process_rx_task+0x158>)
 801f634:	681b      	ldr	r3, [r3, #0]
 801f636:	2000      	movs	r0, #0
 801f638:	4798      	blx	r3
		/* Free buffer handle */
		/* When buffer offloaded to other module, that module is
		 * responsible for freeing buffer. In case not offloaded or
		 * failed to offload, buffer should be freed here.
		 */
		if (buf_handle.free_buf_handle) {
 801f63a:	69bb      	ldr	r3, [r7, #24]
 801f63c:	2b00      	cmp	r3, #0
 801f63e:	f43f af77 	beq.w	801f530 <process_rx_task+0x2c>
			buf_handle.free_buf_handle(buf_handle.priv_buffer_handle);
 801f642:	69bb      	ldr	r3, [r7, #24]
 801f644:	68ba      	ldr	r2, [r7, #8]
 801f646:	4610      	mov	r0, r2
 801f648:	4798      	blx	r3
 801f64a:	e771      	b.n	801f530 <process_rx_task+0x2c>
			continue;
 801f64c:	bf00      	nop
		if (TX_SUCCESS != tx_queue_receive(&from_slave_queue, &buf_handle, TX_WAIT_FOREVER)) {
 801f64e:	e76f      	b.n	801f530 <process_rx_task+0x2c>
 801f650:	2404cff0 	.word	0x2404cff0
 801f654:	08025ff8 	.word	0x08025ff8
 801f658:	08026040 	.word	0x08026040
 801f65c:	2404d0b0 	.word	0x2404d0b0

0801f660 <get_tx_buffer>:
  * @brief  Next TX buffer in SPI transaction
  * @param  argument: Not used
  * @retval sendbuf - Tx buffer
  */
static uint8_t * get_tx_buffer(uint8_t *is_valid_tx_buf)
{
 801f660:	b590      	push	{r4, r7, lr}
 801f662:	b08d      	sub	sp, #52	; 0x34
 801f664:	af00      	add	r7, sp, #0
 801f666:	6078      	str	r0, [r7, #4]
	struct  esp_payload_header *payload_header;
	uint8_t *sendbuf = NULL;
 801f668:	2300      	movs	r3, #0
 801f66a:	62fb      	str	r3, [r7, #44]	; 0x2c
	uint8_t *payload = NULL;
 801f66c:	2300      	movs	r3, #0
 801f66e:	627b      	str	r3, [r7, #36]	; 0x24
	uint16_t len = 0;
 801f670:	2300      	movs	r3, #0
 801f672:	857b      	strh	r3, [r7, #42]	; 0x2a
	interface_buffer_handle_t buf_handle = {0};
 801f674:	f107 030c 	add.w	r3, r7, #12
 801f678:	2200      	movs	r2, #0
 801f67a:	601a      	str	r2, [r3, #0]
 801f67c:	605a      	str	r2, [r3, #4]
 801f67e:	609a      	str	r2, [r3, #8]
 801f680:	60da      	str	r2, [r3, #12]
 801f682:	611a      	str	r2, [r3, #16]

	*is_valid_tx_buf = 0;
 801f684:	687b      	ldr	r3, [r7, #4]
 801f686:	2200      	movs	r2, #0
 801f688:	701a      	strb	r2, [r3, #0]
	/* Check if higher layers have anything to transmit, non blocking.
	 * If nothing is expected to send, queue receive will fail.
	 * In that case only payload header with zero payload
	 * length would be transmitted.
	 */
	if (TX_SUCCESS == tx_queue_receive(&to_slave_queue, &buf_handle, TX_NO_WAIT)) {
 801f68a:	f107 030c 	add.w	r3, r7, #12
 801f68e:	2200      	movs	r2, #0
 801f690:	4619      	mov	r1, r3
 801f692:	482f      	ldr	r0, [pc, #188]	; (801f750 <get_tx_buffer+0xf0>)
 801f694:	f7f6 ff5e 	bl	8016554 <_txe_queue_receive>
 801f698:	4603      	mov	r3, r0
 801f69a:	2b00      	cmp	r3, #0
 801f69c:	d101      	bne.n	801f6a2 <get_tx_buffer+0x42>
		len = buf_handle.payload_len;
 801f69e:	69bb      	ldr	r3, [r7, #24]
 801f6a0:	857b      	strh	r3, [r7, #42]	; 0x2a
	}

	if (len) {
 801f6a2:	8d7b      	ldrh	r3, [r7, #42]	; 0x2a
 801f6a4:	2b00      	cmp	r3, #0
 801f6a6:	d046      	beq.n	801f736 <get_tx_buffer+0xd6>

		sendbuf = (uint8_t *) malloc(MAX_SPI_BUFFER_SIZE);
 801f6a8:	f44f 60c8 	mov.w	r0, #1600	; 0x640
 801f6ac:	f7fd febc 	bl	801d428 <esp_hosted_malloc>
 801f6b0:	62f8      	str	r0, [r7, #44]	; 0x2c
		if (!sendbuf) {
 801f6b2:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 801f6b4:	2b00      	cmp	r3, #0
 801f6b6:	d103      	bne.n	801f6c0 <get_tx_buffer+0x60>
			printf("malloc failed\n\r");
 801f6b8:	4826      	ldr	r0, [pc, #152]	; (801f754 <get_tx_buffer+0xf4>)
 801f6ba:	f000 fd57 	bl	802016c <iprintf>
			goto done;
 801f6be:	e03b      	b.n	801f738 <get_tx_buffer+0xd8>
		}

		memset(sendbuf, 0, MAX_SPI_BUFFER_SIZE);
 801f6c0:	f44f 62c8 	mov.w	r2, #1600	; 0x640
 801f6c4:	2100      	movs	r1, #0
 801f6c6:	6af8      	ldr	r0, [r7, #44]	; 0x2c
 801f6c8:	f000 f8d8 	bl	801f87c <memset>

		*is_valid_tx_buf = 1;
 801f6cc:	687b      	ldr	r3, [r7, #4]
 801f6ce:	2201      	movs	r2, #1
 801f6d0:	701a      	strb	r2, [r3, #0]

		/* Form Tx header */
		payload_header = (struct esp_payload_header *) sendbuf;
 801f6d2:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 801f6d4:	623b      	str	r3, [r7, #32]
		payload = sendbuf + sizeof(struct esp_payload_header);
 801f6d6:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 801f6d8:	330c      	adds	r3, #12
 801f6da:	627b      	str	r3, [r7, #36]	; 0x24
		payload_header->len     = htole16(len);
 801f6dc:	6a3b      	ldr	r3, [r7, #32]
 801f6de:	8d7a      	ldrh	r2, [r7, #42]	; 0x2a
 801f6e0:	805a      	strh	r2, [r3, #2]
		payload_header->offset  = htole16(sizeof(struct esp_payload_header));
 801f6e2:	6a3b      	ldr	r3, [r7, #32]
 801f6e4:	2200      	movs	r2, #0
 801f6e6:	f042 020c 	orr.w	r2, r2, #12
 801f6ea:	711a      	strb	r2, [r3, #4]
 801f6ec:	2200      	movs	r2, #0
 801f6ee:	715a      	strb	r2, [r3, #5]
		payload_header->if_type = buf_handle.if_type;
 801f6f0:	7c3b      	ldrb	r3, [r7, #16]
 801f6f2:	f003 030f 	and.w	r3, r3, #15
 801f6f6:	b2d9      	uxtb	r1, r3
 801f6f8:	6a3a      	ldr	r2, [r7, #32]
 801f6fa:	7813      	ldrb	r3, [r2, #0]
 801f6fc:	f361 0303 	bfi	r3, r1, #0, #4
 801f700:	7013      	strb	r3, [r2, #0]
		payload_header->if_num  = buf_handle.if_num;
 801f702:	7c7b      	ldrb	r3, [r7, #17]
 801f704:	f003 030f 	and.w	r3, r3, #15
 801f708:	b2d9      	uxtb	r1, r3
 801f70a:	6a3a      	ldr	r2, [r7, #32]
 801f70c:	7813      	ldrb	r3, [r2, #0]
 801f70e:	f361 1307 	bfi	r3, r1, #4, #4
 801f712:	7013      	strb	r3, [r2, #0]
		payload_header->reserved1 = 0;
 801f714:	6a3b      	ldr	r3, [r7, #32]
 801f716:	2200      	movs	r2, #0
 801f718:	705a      	strb	r2, [r3, #1]

		memcpy(payload, buf_handle.payload, min(len, MAX_PAYLOAD_SIZE));
 801f71a:	697c      	ldr	r4, [r7, #20]
 801f71c:	8d7b      	ldrh	r3, [r7, #42]	; 0x2a
 801f71e:	f240 6134 	movw	r1, #1588	; 0x634
 801f722:	4618      	mov	r0, r3
 801f724:	f7fe fad5 	bl	801dcd2 <min>
 801f728:	4603      	mov	r3, r0
 801f72a:	461a      	mov	r2, r3
 801f72c:	4621      	mov	r1, r4
 801f72e:	6a78      	ldr	r0, [r7, #36]	; 0x24
 801f730:	f000 f87c 	bl	801f82c <memcpy>
 801f734:	e000      	b.n	801f738 <get_tx_buffer+0xd8>
	}

done:
 801f736:	bf00      	nop
	/* free allocated buffer */
	if (buf_handle.free_buf_handle)
 801f738:	69fb      	ldr	r3, [r7, #28]
 801f73a:	2b00      	cmp	r3, #0
 801f73c:	d003      	beq.n	801f746 <get_tx_buffer+0xe6>
		buf_handle.free_buf_handle(buf_handle.priv_buffer_handle);
 801f73e:	69fb      	ldr	r3, [r7, #28]
 801f740:	68fa      	ldr	r2, [r7, #12]
 801f742:	4610      	mov	r0, r2
 801f744:	4798      	blx	r3

	return sendbuf;
 801f746:	6afb      	ldr	r3, [r7, #44]	; 0x2c
}
 801f748:	4618      	mov	r0, r3
 801f74a:	3734      	adds	r7, #52	; 0x34
 801f74c:	46bd      	mov	sp, r7
 801f74e:	bd90      	pop	{r4, r7, pc}
 801f750:	2404cfb8 	.word	0x2404cfb8
 801f754:	08026200 	.word	0x08026200

0801f758 <__assert_func>:
 801f758:	b51f      	push	{r0, r1, r2, r3, r4, lr}
 801f75a:	4614      	mov	r4, r2
 801f75c:	461a      	mov	r2, r3
 801f75e:	4b09      	ldr	r3, [pc, #36]	; (801f784 <__assert_func+0x2c>)
 801f760:	681b      	ldr	r3, [r3, #0]
 801f762:	4605      	mov	r5, r0
 801f764:	68d8      	ldr	r0, [r3, #12]
 801f766:	b14c      	cbz	r4, 801f77c <__assert_func+0x24>
 801f768:	4b07      	ldr	r3, [pc, #28]	; (801f788 <__assert_func+0x30>)
 801f76a:	9100      	str	r1, [sp, #0]
 801f76c:	e9cd 3401 	strd	r3, r4, [sp, #4]
 801f770:	4906      	ldr	r1, [pc, #24]	; (801f78c <__assert_func+0x34>)
 801f772:	462b      	mov	r3, r5
 801f774:	f000 f814 	bl	801f7a0 <fiprintf>
 801f778:	f001 fa22 	bl	8020bc0 <abort>
 801f77c:	4b04      	ldr	r3, [pc, #16]	; (801f790 <__assert_func+0x38>)
 801f77e:	461c      	mov	r4, r3
 801f780:	e7f3      	b.n	801f76a <__assert_func+0x12>
 801f782:	bf00      	nop
 801f784:	240004a4 	.word	0x240004a4
 801f788:	080287cf 	.word	0x080287cf
 801f78c:	080287dc 	.word	0x080287dc
 801f790:	0802880a 	.word	0x0802880a

0801f794 <__errno>:
 801f794:	4b01      	ldr	r3, [pc, #4]	; (801f79c <__errno+0x8>)
 801f796:	6818      	ldr	r0, [r3, #0]
 801f798:	4770      	bx	lr
 801f79a:	bf00      	nop
 801f79c:	240004a4 	.word	0x240004a4

0801f7a0 <fiprintf>:
 801f7a0:	b40e      	push	{r1, r2, r3}
 801f7a2:	b503      	push	{r0, r1, lr}
 801f7a4:	4601      	mov	r1, r0
 801f7a6:	ab03      	add	r3, sp, #12
 801f7a8:	4805      	ldr	r0, [pc, #20]	; (801f7c0 <fiprintf+0x20>)
 801f7aa:	f853 2b04 	ldr.w	r2, [r3], #4
 801f7ae:	6800      	ldr	r0, [r0, #0]
 801f7b0:	9301      	str	r3, [sp, #4]
 801f7b2:	f000 f975 	bl	801faa0 <_vfiprintf_r>
 801f7b6:	b002      	add	sp, #8
 801f7b8:	f85d eb04 	ldr.w	lr, [sp], #4
 801f7bc:	b003      	add	sp, #12
 801f7be:	4770      	bx	lr
 801f7c0:	240004a4 	.word	0x240004a4

0801f7c4 <__libc_init_array>:
 801f7c4:	b570      	push	{r4, r5, r6, lr}
 801f7c6:	4d0d      	ldr	r5, [pc, #52]	; (801f7fc <__libc_init_array+0x38>)
 801f7c8:	4c0d      	ldr	r4, [pc, #52]	; (801f800 <__libc_init_array+0x3c>)
 801f7ca:	1b64      	subs	r4, r4, r5
 801f7cc:	10a4      	asrs	r4, r4, #2
 801f7ce:	2600      	movs	r6, #0
 801f7d0:	42a6      	cmp	r6, r4
 801f7d2:	d109      	bne.n	801f7e8 <__libc_init_array+0x24>
 801f7d4:	4d0b      	ldr	r5, [pc, #44]	; (801f804 <__libc_init_array+0x40>)
 801f7d6:	4c0c      	ldr	r4, [pc, #48]	; (801f808 <__libc_init_array+0x44>)
 801f7d8:	f002 fae0 	bl	8021d9c <_init>
 801f7dc:	1b64      	subs	r4, r4, r5
 801f7de:	10a4      	asrs	r4, r4, #2
 801f7e0:	2600      	movs	r6, #0
 801f7e2:	42a6      	cmp	r6, r4
 801f7e4:	d105      	bne.n	801f7f2 <__libc_init_array+0x2e>
 801f7e6:	bd70      	pop	{r4, r5, r6, pc}
 801f7e8:	f855 3b04 	ldr.w	r3, [r5], #4
 801f7ec:	4798      	blx	r3
 801f7ee:	3601      	adds	r6, #1
 801f7f0:	e7ee      	b.n	801f7d0 <__libc_init_array+0xc>
 801f7f2:	f855 3b04 	ldr.w	r3, [r5], #4
 801f7f6:	4798      	blx	r3
 801f7f8:	3601      	adds	r6, #1
 801f7fa:	e7f2      	b.n	801f7e2 <__libc_init_array+0x1e>
 801f7fc:	080290d0 	.word	0x080290d0
 801f800:	080290d0 	.word	0x080290d0
 801f804:	080290d0 	.word	0x080290d0
 801f808:	080290d4 	.word	0x080290d4

0801f80c <malloc>:
 801f80c:	4b02      	ldr	r3, [pc, #8]	; (801f818 <malloc+0xc>)
 801f80e:	4601      	mov	r1, r0
 801f810:	6818      	ldr	r0, [r3, #0]
 801f812:	f000 b8a7 	b.w	801f964 <_malloc_r>
 801f816:	bf00      	nop
 801f818:	240004a4 	.word	0x240004a4

0801f81c <free>:
 801f81c:	4b02      	ldr	r3, [pc, #8]	; (801f828 <free+0xc>)
 801f81e:	4601      	mov	r1, r0
 801f820:	6818      	ldr	r0, [r3, #0]
 801f822:	f000 b833 	b.w	801f88c <_free_r>
 801f826:	bf00      	nop
 801f828:	240004a4 	.word	0x240004a4

0801f82c <memcpy>:
 801f82c:	440a      	add	r2, r1
 801f82e:	4291      	cmp	r1, r2
 801f830:	f100 33ff 	add.w	r3, r0, #4294967295
 801f834:	d100      	bne.n	801f838 <memcpy+0xc>
 801f836:	4770      	bx	lr
 801f838:	b510      	push	{r4, lr}
 801f83a:	f811 4b01 	ldrb.w	r4, [r1], #1
 801f83e:	f803 4f01 	strb.w	r4, [r3, #1]!
 801f842:	4291      	cmp	r1, r2
 801f844:	d1f9      	bne.n	801f83a <memcpy+0xe>
 801f846:	bd10      	pop	{r4, pc}

0801f848 <memmove>:
 801f848:	4288      	cmp	r0, r1
 801f84a:	b510      	push	{r4, lr}
 801f84c:	eb01 0402 	add.w	r4, r1, r2
 801f850:	d902      	bls.n	801f858 <memmove+0x10>
 801f852:	4284      	cmp	r4, r0
 801f854:	4623      	mov	r3, r4
 801f856:	d807      	bhi.n	801f868 <memmove+0x20>
 801f858:	1e43      	subs	r3, r0, #1
 801f85a:	42a1      	cmp	r1, r4
 801f85c:	d008      	beq.n	801f870 <memmove+0x28>
 801f85e:	f811 2b01 	ldrb.w	r2, [r1], #1
 801f862:	f803 2f01 	strb.w	r2, [r3, #1]!
 801f866:	e7f8      	b.n	801f85a <memmove+0x12>
 801f868:	4402      	add	r2, r0
 801f86a:	4601      	mov	r1, r0
 801f86c:	428a      	cmp	r2, r1
 801f86e:	d100      	bne.n	801f872 <memmove+0x2a>
 801f870:	bd10      	pop	{r4, pc}
 801f872:	f813 4d01 	ldrb.w	r4, [r3, #-1]!
 801f876:	f802 4d01 	strb.w	r4, [r2, #-1]!
 801f87a:	e7f7      	b.n	801f86c <memmove+0x24>

0801f87c <memset>:
 801f87c:	4402      	add	r2, r0
 801f87e:	4603      	mov	r3, r0
 801f880:	4293      	cmp	r3, r2
 801f882:	d100      	bne.n	801f886 <memset+0xa>
 801f884:	4770      	bx	lr
 801f886:	f803 1b01 	strb.w	r1, [r3], #1
 801f88a:	e7f9      	b.n	801f880 <memset+0x4>

0801f88c <_free_r>:
 801f88c:	b537      	push	{r0, r1, r2, r4, r5, lr}
 801f88e:	2900      	cmp	r1, #0
 801f890:	d044      	beq.n	801f91c <_free_r+0x90>
 801f892:	f851 3c04 	ldr.w	r3, [r1, #-4]
 801f896:	9001      	str	r0, [sp, #4]
 801f898:	2b00      	cmp	r3, #0
 801f89a:	f1a1 0404 	sub.w	r4, r1, #4
 801f89e:	bfb8      	it	lt
 801f8a0:	18e4      	addlt	r4, r4, r3
 801f8a2:	f001 fc13 	bl	80210cc <__malloc_lock>
 801f8a6:	4a1e      	ldr	r2, [pc, #120]	; (801f920 <_free_r+0x94>)
 801f8a8:	9801      	ldr	r0, [sp, #4]
 801f8aa:	6813      	ldr	r3, [r2, #0]
 801f8ac:	b933      	cbnz	r3, 801f8bc <_free_r+0x30>
 801f8ae:	6063      	str	r3, [r4, #4]
 801f8b0:	6014      	str	r4, [r2, #0]
 801f8b2:	b003      	add	sp, #12
 801f8b4:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
 801f8b8:	f001 bc0e 	b.w	80210d8 <__malloc_unlock>
 801f8bc:	42a3      	cmp	r3, r4
 801f8be:	d908      	bls.n	801f8d2 <_free_r+0x46>
 801f8c0:	6825      	ldr	r5, [r4, #0]
 801f8c2:	1961      	adds	r1, r4, r5
 801f8c4:	428b      	cmp	r3, r1
 801f8c6:	bf01      	itttt	eq
 801f8c8:	6819      	ldreq	r1, [r3, #0]
 801f8ca:	685b      	ldreq	r3, [r3, #4]
 801f8cc:	1949      	addeq	r1, r1, r5
 801f8ce:	6021      	streq	r1, [r4, #0]
 801f8d0:	e7ed      	b.n	801f8ae <_free_r+0x22>
 801f8d2:	461a      	mov	r2, r3
 801f8d4:	685b      	ldr	r3, [r3, #4]
 801f8d6:	b10b      	cbz	r3, 801f8dc <_free_r+0x50>
 801f8d8:	42a3      	cmp	r3, r4
 801f8da:	d9fa      	bls.n	801f8d2 <_free_r+0x46>
 801f8dc:	6811      	ldr	r1, [r2, #0]
 801f8de:	1855      	adds	r5, r2, r1
 801f8e0:	42a5      	cmp	r5, r4
 801f8e2:	d10b      	bne.n	801f8fc <_free_r+0x70>
 801f8e4:	6824      	ldr	r4, [r4, #0]
 801f8e6:	4421      	add	r1, r4
 801f8e8:	1854      	adds	r4, r2, r1
 801f8ea:	42a3      	cmp	r3, r4
 801f8ec:	6011      	str	r1, [r2, #0]
 801f8ee:	d1e0      	bne.n	801f8b2 <_free_r+0x26>
 801f8f0:	681c      	ldr	r4, [r3, #0]
 801f8f2:	685b      	ldr	r3, [r3, #4]
 801f8f4:	6053      	str	r3, [r2, #4]
 801f8f6:	4421      	add	r1, r4
 801f8f8:	6011      	str	r1, [r2, #0]
 801f8fa:	e7da      	b.n	801f8b2 <_free_r+0x26>
 801f8fc:	d902      	bls.n	801f904 <_free_r+0x78>
 801f8fe:	230c      	movs	r3, #12
 801f900:	6003      	str	r3, [r0, #0]
 801f902:	e7d6      	b.n	801f8b2 <_free_r+0x26>
 801f904:	6825      	ldr	r5, [r4, #0]
 801f906:	1961      	adds	r1, r4, r5
 801f908:	428b      	cmp	r3, r1
 801f90a:	bf04      	itt	eq
 801f90c:	6819      	ldreq	r1, [r3, #0]
 801f90e:	685b      	ldreq	r3, [r3, #4]
 801f910:	6063      	str	r3, [r4, #4]
 801f912:	bf04      	itt	eq
 801f914:	1949      	addeq	r1, r1, r5
 801f916:	6021      	streq	r1, [r4, #0]
 801f918:	6054      	str	r4, [r2, #4]
 801f91a:	e7ca      	b.n	801f8b2 <_free_r+0x26>
 801f91c:	b003      	add	sp, #12
 801f91e:	bd30      	pop	{r4, r5, pc}
 801f920:	2404d0b4 	.word	0x2404d0b4

0801f924 <sbrk_aligned>:
 801f924:	b570      	push	{r4, r5, r6, lr}
 801f926:	4e0e      	ldr	r6, [pc, #56]	; (801f960 <sbrk_aligned+0x3c>)
 801f928:	460c      	mov	r4, r1
 801f92a:	6831      	ldr	r1, [r6, #0]
 801f92c:	4605      	mov	r5, r0
 801f92e:	b911      	cbnz	r1, 801f936 <sbrk_aligned+0x12>
 801f930:	f000 fcfe 	bl	8020330 <_sbrk_r>
 801f934:	6030      	str	r0, [r6, #0]
 801f936:	4621      	mov	r1, r4
 801f938:	4628      	mov	r0, r5
 801f93a:	f000 fcf9 	bl	8020330 <_sbrk_r>
 801f93e:	1c43      	adds	r3, r0, #1
 801f940:	d00a      	beq.n	801f958 <sbrk_aligned+0x34>
 801f942:	1cc4      	adds	r4, r0, #3
 801f944:	f024 0403 	bic.w	r4, r4, #3
 801f948:	42a0      	cmp	r0, r4
 801f94a:	d007      	beq.n	801f95c <sbrk_aligned+0x38>
 801f94c:	1a21      	subs	r1, r4, r0
 801f94e:	4628      	mov	r0, r5
 801f950:	f000 fcee 	bl	8020330 <_sbrk_r>
 801f954:	3001      	adds	r0, #1
 801f956:	d101      	bne.n	801f95c <sbrk_aligned+0x38>
 801f958:	f04f 34ff 	mov.w	r4, #4294967295
 801f95c:	4620      	mov	r0, r4
 801f95e:	bd70      	pop	{r4, r5, r6, pc}
 801f960:	2404d0b8 	.word	0x2404d0b8

0801f964 <_malloc_r>:
 801f964:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 801f968:	1ccd      	adds	r5, r1, #3
 801f96a:	f025 0503 	bic.w	r5, r5, #3
 801f96e:	3508      	adds	r5, #8
 801f970:	2d0c      	cmp	r5, #12
 801f972:	bf38      	it	cc
 801f974:	250c      	movcc	r5, #12
 801f976:	2d00      	cmp	r5, #0
 801f978:	4607      	mov	r7, r0
 801f97a:	db01      	blt.n	801f980 <_malloc_r+0x1c>
 801f97c:	42a9      	cmp	r1, r5
 801f97e:	d905      	bls.n	801f98c <_malloc_r+0x28>
 801f980:	230c      	movs	r3, #12
 801f982:	603b      	str	r3, [r7, #0]
 801f984:	2600      	movs	r6, #0
 801f986:	4630      	mov	r0, r6
 801f988:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 801f98c:	4e2e      	ldr	r6, [pc, #184]	; (801fa48 <_malloc_r+0xe4>)
 801f98e:	f001 fb9d 	bl	80210cc <__malloc_lock>
 801f992:	6833      	ldr	r3, [r6, #0]
 801f994:	461c      	mov	r4, r3
 801f996:	bb34      	cbnz	r4, 801f9e6 <_malloc_r+0x82>
 801f998:	4629      	mov	r1, r5
 801f99a:	4638      	mov	r0, r7
 801f99c:	f7ff ffc2 	bl	801f924 <sbrk_aligned>
 801f9a0:	1c43      	adds	r3, r0, #1
 801f9a2:	4604      	mov	r4, r0
 801f9a4:	d14d      	bne.n	801fa42 <_malloc_r+0xde>
 801f9a6:	6834      	ldr	r4, [r6, #0]
 801f9a8:	4626      	mov	r6, r4
 801f9aa:	2e00      	cmp	r6, #0
 801f9ac:	d140      	bne.n	801fa30 <_malloc_r+0xcc>
 801f9ae:	6823      	ldr	r3, [r4, #0]
 801f9b0:	4631      	mov	r1, r6
 801f9b2:	4638      	mov	r0, r7
 801f9b4:	eb04 0803 	add.w	r8, r4, r3
 801f9b8:	f000 fcba 	bl	8020330 <_sbrk_r>
 801f9bc:	4580      	cmp	r8, r0
 801f9be:	d13a      	bne.n	801fa36 <_malloc_r+0xd2>
 801f9c0:	6821      	ldr	r1, [r4, #0]
 801f9c2:	3503      	adds	r5, #3
 801f9c4:	1a6d      	subs	r5, r5, r1
 801f9c6:	f025 0503 	bic.w	r5, r5, #3
 801f9ca:	3508      	adds	r5, #8
 801f9cc:	2d0c      	cmp	r5, #12
 801f9ce:	bf38      	it	cc
 801f9d0:	250c      	movcc	r5, #12
 801f9d2:	4629      	mov	r1, r5
 801f9d4:	4638      	mov	r0, r7
 801f9d6:	f7ff ffa5 	bl	801f924 <sbrk_aligned>
 801f9da:	3001      	adds	r0, #1
 801f9dc:	d02b      	beq.n	801fa36 <_malloc_r+0xd2>
 801f9de:	6823      	ldr	r3, [r4, #0]
 801f9e0:	442b      	add	r3, r5
 801f9e2:	6023      	str	r3, [r4, #0]
 801f9e4:	e00e      	b.n	801fa04 <_malloc_r+0xa0>
 801f9e6:	6822      	ldr	r2, [r4, #0]
 801f9e8:	1b52      	subs	r2, r2, r5
 801f9ea:	d41e      	bmi.n	801fa2a <_malloc_r+0xc6>
 801f9ec:	2a0b      	cmp	r2, #11
 801f9ee:	d916      	bls.n	801fa1e <_malloc_r+0xba>
 801f9f0:	1961      	adds	r1, r4, r5
 801f9f2:	42a3      	cmp	r3, r4
 801f9f4:	6025      	str	r5, [r4, #0]
 801f9f6:	bf18      	it	ne
 801f9f8:	6059      	strne	r1, [r3, #4]
 801f9fa:	6863      	ldr	r3, [r4, #4]
 801f9fc:	bf08      	it	eq
 801f9fe:	6031      	streq	r1, [r6, #0]
 801fa00:	5162      	str	r2, [r4, r5]
 801fa02:	604b      	str	r3, [r1, #4]
 801fa04:	4638      	mov	r0, r7
 801fa06:	f104 060b 	add.w	r6, r4, #11
 801fa0a:	f001 fb65 	bl	80210d8 <__malloc_unlock>
 801fa0e:	f026 0607 	bic.w	r6, r6, #7
 801fa12:	1d23      	adds	r3, r4, #4
 801fa14:	1af2      	subs	r2, r6, r3
 801fa16:	d0b6      	beq.n	801f986 <_malloc_r+0x22>
 801fa18:	1b9b      	subs	r3, r3, r6
 801fa1a:	50a3      	str	r3, [r4, r2]
 801fa1c:	e7b3      	b.n	801f986 <_malloc_r+0x22>
 801fa1e:	6862      	ldr	r2, [r4, #4]
 801fa20:	42a3      	cmp	r3, r4
 801fa22:	bf0c      	ite	eq
 801fa24:	6032      	streq	r2, [r6, #0]
 801fa26:	605a      	strne	r2, [r3, #4]
 801fa28:	e7ec      	b.n	801fa04 <_malloc_r+0xa0>
 801fa2a:	4623      	mov	r3, r4
 801fa2c:	6864      	ldr	r4, [r4, #4]
 801fa2e:	e7b2      	b.n	801f996 <_malloc_r+0x32>
 801fa30:	4634      	mov	r4, r6
 801fa32:	6876      	ldr	r6, [r6, #4]
 801fa34:	e7b9      	b.n	801f9aa <_malloc_r+0x46>
 801fa36:	230c      	movs	r3, #12
 801fa38:	603b      	str	r3, [r7, #0]
 801fa3a:	4638      	mov	r0, r7
 801fa3c:	f001 fb4c 	bl	80210d8 <__malloc_unlock>
 801fa40:	e7a1      	b.n	801f986 <_malloc_r+0x22>
 801fa42:	6025      	str	r5, [r4, #0]
 801fa44:	e7de      	b.n	801fa04 <_malloc_r+0xa0>
 801fa46:	bf00      	nop
 801fa48:	2404d0b4 	.word	0x2404d0b4

0801fa4c <__sfputc_r>:
 801fa4c:	6893      	ldr	r3, [r2, #8]
 801fa4e:	3b01      	subs	r3, #1
 801fa50:	2b00      	cmp	r3, #0
 801fa52:	b410      	push	{r4}
 801fa54:	6093      	str	r3, [r2, #8]
 801fa56:	da08      	bge.n	801fa6a <__sfputc_r+0x1e>
 801fa58:	6994      	ldr	r4, [r2, #24]
 801fa5a:	42a3      	cmp	r3, r4
 801fa5c:	db01      	blt.n	801fa62 <__sfputc_r+0x16>
 801fa5e:	290a      	cmp	r1, #10
 801fa60:	d103      	bne.n	801fa6a <__sfputc_r+0x1e>
 801fa62:	f85d 4b04 	ldr.w	r4, [sp], #4
 801fa66:	f000 bfd9 	b.w	8020a1c <__swbuf_r>
 801fa6a:	6813      	ldr	r3, [r2, #0]
 801fa6c:	1c58      	adds	r0, r3, #1
 801fa6e:	6010      	str	r0, [r2, #0]
 801fa70:	7019      	strb	r1, [r3, #0]
 801fa72:	4608      	mov	r0, r1
 801fa74:	f85d 4b04 	ldr.w	r4, [sp], #4
 801fa78:	4770      	bx	lr

0801fa7a <__sfputs_r>:
 801fa7a:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 801fa7c:	4606      	mov	r6, r0
 801fa7e:	460f      	mov	r7, r1
 801fa80:	4614      	mov	r4, r2
 801fa82:	18d5      	adds	r5, r2, r3
 801fa84:	42ac      	cmp	r4, r5
 801fa86:	d101      	bne.n	801fa8c <__sfputs_r+0x12>
 801fa88:	2000      	movs	r0, #0
 801fa8a:	e007      	b.n	801fa9c <__sfputs_r+0x22>
 801fa8c:	f814 1b01 	ldrb.w	r1, [r4], #1
 801fa90:	463a      	mov	r2, r7
 801fa92:	4630      	mov	r0, r6
 801fa94:	f7ff ffda 	bl	801fa4c <__sfputc_r>
 801fa98:	1c43      	adds	r3, r0, #1
 801fa9a:	d1f3      	bne.n	801fa84 <__sfputs_r+0xa>
 801fa9c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	...

0801faa0 <_vfiprintf_r>:
 801faa0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 801faa4:	460d      	mov	r5, r1
 801faa6:	b09d      	sub	sp, #116	; 0x74
 801faa8:	4614      	mov	r4, r2
 801faaa:	4698      	mov	r8, r3
 801faac:	4606      	mov	r6, r0
 801faae:	b118      	cbz	r0, 801fab8 <_vfiprintf_r+0x18>
 801fab0:	6983      	ldr	r3, [r0, #24]
 801fab2:	b90b      	cbnz	r3, 801fab8 <_vfiprintf_r+0x18>
 801fab4:	f001 f9f4 	bl	8020ea0 <__sinit>
 801fab8:	4b89      	ldr	r3, [pc, #548]	; (801fce0 <_vfiprintf_r+0x240>)
 801faba:	429d      	cmp	r5, r3
 801fabc:	d11b      	bne.n	801faf6 <_vfiprintf_r+0x56>
 801fabe:	6875      	ldr	r5, [r6, #4]
 801fac0:	6e6b      	ldr	r3, [r5, #100]	; 0x64
 801fac2:	07d9      	lsls	r1, r3, #31
 801fac4:	d405      	bmi.n	801fad2 <_vfiprintf_r+0x32>
 801fac6:	89ab      	ldrh	r3, [r5, #12]
 801fac8:	059a      	lsls	r2, r3, #22
 801faca:	d402      	bmi.n	801fad2 <_vfiprintf_r+0x32>
 801facc:	6da8      	ldr	r0, [r5, #88]	; 0x58
 801face:	f7e1 fdba 	bl	8001646 <__retarget_lock_acquire_recursive>
 801fad2:	89ab      	ldrh	r3, [r5, #12]
 801fad4:	071b      	lsls	r3, r3, #28
 801fad6:	d501      	bpl.n	801fadc <_vfiprintf_r+0x3c>
 801fad8:	692b      	ldr	r3, [r5, #16]
 801fada:	b9eb      	cbnz	r3, 801fb18 <_vfiprintf_r+0x78>
 801fadc:	4629      	mov	r1, r5
 801fade:	4630      	mov	r0, r6
 801fae0:	f001 f800 	bl	8020ae4 <__swsetup_r>
 801fae4:	b1c0      	cbz	r0, 801fb18 <_vfiprintf_r+0x78>
 801fae6:	6e6b      	ldr	r3, [r5, #100]	; 0x64
 801fae8:	07dc      	lsls	r4, r3, #31
 801faea:	d50e      	bpl.n	801fb0a <_vfiprintf_r+0x6a>
 801faec:	f04f 30ff 	mov.w	r0, #4294967295
 801faf0:	b01d      	add	sp, #116	; 0x74
 801faf2:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 801faf6:	4b7b      	ldr	r3, [pc, #492]	; (801fce4 <_vfiprintf_r+0x244>)
 801faf8:	429d      	cmp	r5, r3
 801fafa:	d101      	bne.n	801fb00 <_vfiprintf_r+0x60>
 801fafc:	68b5      	ldr	r5, [r6, #8]
 801fafe:	e7df      	b.n	801fac0 <_vfiprintf_r+0x20>
 801fb00:	4b79      	ldr	r3, [pc, #484]	; (801fce8 <_vfiprintf_r+0x248>)
 801fb02:	429d      	cmp	r5, r3
 801fb04:	bf08      	it	eq
 801fb06:	68f5      	ldreq	r5, [r6, #12]
 801fb08:	e7da      	b.n	801fac0 <_vfiprintf_r+0x20>
 801fb0a:	89ab      	ldrh	r3, [r5, #12]
 801fb0c:	0598      	lsls	r0, r3, #22
 801fb0e:	d4ed      	bmi.n	801faec <_vfiprintf_r+0x4c>
 801fb10:	6da8      	ldr	r0, [r5, #88]	; 0x58
 801fb12:	f7e1 fdac 	bl	800166e <__retarget_lock_release_recursive>
 801fb16:	e7e9      	b.n	801faec <_vfiprintf_r+0x4c>
 801fb18:	2300      	movs	r3, #0
 801fb1a:	9309      	str	r3, [sp, #36]	; 0x24
 801fb1c:	2320      	movs	r3, #32
 801fb1e:	f88d 3029 	strb.w	r3, [sp, #41]	; 0x29
 801fb22:	f8cd 800c 	str.w	r8, [sp, #12]
 801fb26:	2330      	movs	r3, #48	; 0x30
 801fb28:	f8df 81c0 	ldr.w	r8, [pc, #448]	; 801fcec <_vfiprintf_r+0x24c>
 801fb2c:	f88d 302a 	strb.w	r3, [sp, #42]	; 0x2a
 801fb30:	f04f 0901 	mov.w	r9, #1
 801fb34:	4623      	mov	r3, r4
 801fb36:	469a      	mov	sl, r3
 801fb38:	f813 2b01 	ldrb.w	r2, [r3], #1
 801fb3c:	b10a      	cbz	r2, 801fb42 <_vfiprintf_r+0xa2>
 801fb3e:	2a25      	cmp	r2, #37	; 0x25
 801fb40:	d1f9      	bne.n	801fb36 <_vfiprintf_r+0x96>
 801fb42:	ebba 0b04 	subs.w	fp, sl, r4
 801fb46:	d00b      	beq.n	801fb60 <_vfiprintf_r+0xc0>
 801fb48:	465b      	mov	r3, fp
 801fb4a:	4622      	mov	r2, r4
 801fb4c:	4629      	mov	r1, r5
 801fb4e:	4630      	mov	r0, r6
 801fb50:	f7ff ff93 	bl	801fa7a <__sfputs_r>
 801fb54:	3001      	adds	r0, #1
 801fb56:	f000 80aa 	beq.w	801fcae <_vfiprintf_r+0x20e>
 801fb5a:	9a09      	ldr	r2, [sp, #36]	; 0x24
 801fb5c:	445a      	add	r2, fp
 801fb5e:	9209      	str	r2, [sp, #36]	; 0x24
 801fb60:	f89a 3000 	ldrb.w	r3, [sl]
 801fb64:	2b00      	cmp	r3, #0
 801fb66:	f000 80a2 	beq.w	801fcae <_vfiprintf_r+0x20e>
 801fb6a:	2300      	movs	r3, #0
 801fb6c:	f04f 32ff 	mov.w	r2, #4294967295
 801fb70:	e9cd 2305 	strd	r2, r3, [sp, #20]
 801fb74:	f10a 0a01 	add.w	sl, sl, #1
 801fb78:	9304      	str	r3, [sp, #16]
 801fb7a:	9307      	str	r3, [sp, #28]
 801fb7c:	f88d 3053 	strb.w	r3, [sp, #83]	; 0x53
 801fb80:	931a      	str	r3, [sp, #104]	; 0x68
 801fb82:	4654      	mov	r4, sl
 801fb84:	2205      	movs	r2, #5
 801fb86:	f814 1b01 	ldrb.w	r1, [r4], #1
 801fb8a:	4858      	ldr	r0, [pc, #352]	; (801fcec <_vfiprintf_r+0x24c>)
 801fb8c:	f7e0 fcd8 	bl	8000540 <memchr>
 801fb90:	9a04      	ldr	r2, [sp, #16]
 801fb92:	b9d8      	cbnz	r0, 801fbcc <_vfiprintf_r+0x12c>
 801fb94:	06d1      	lsls	r1, r2, #27
 801fb96:	bf44      	itt	mi
 801fb98:	2320      	movmi	r3, #32
 801fb9a:	f88d 3053 	strbmi.w	r3, [sp, #83]	; 0x53
 801fb9e:	0713      	lsls	r3, r2, #28
 801fba0:	bf44      	itt	mi
 801fba2:	232b      	movmi	r3, #43	; 0x2b
 801fba4:	f88d 3053 	strbmi.w	r3, [sp, #83]	; 0x53
 801fba8:	f89a 3000 	ldrb.w	r3, [sl]
 801fbac:	2b2a      	cmp	r3, #42	; 0x2a
 801fbae:	d015      	beq.n	801fbdc <_vfiprintf_r+0x13c>
 801fbb0:	9a07      	ldr	r2, [sp, #28]
 801fbb2:	4654      	mov	r4, sl
 801fbb4:	2000      	movs	r0, #0
 801fbb6:	f04f 0c0a 	mov.w	ip, #10
 801fbba:	4621      	mov	r1, r4
 801fbbc:	f811 3b01 	ldrb.w	r3, [r1], #1
 801fbc0:	3b30      	subs	r3, #48	; 0x30
 801fbc2:	2b09      	cmp	r3, #9
 801fbc4:	d94e      	bls.n	801fc64 <_vfiprintf_r+0x1c4>
 801fbc6:	b1b0      	cbz	r0, 801fbf6 <_vfiprintf_r+0x156>
 801fbc8:	9207      	str	r2, [sp, #28]
 801fbca:	e014      	b.n	801fbf6 <_vfiprintf_r+0x156>
 801fbcc:	eba0 0308 	sub.w	r3, r0, r8
 801fbd0:	fa09 f303 	lsl.w	r3, r9, r3
 801fbd4:	4313      	orrs	r3, r2
 801fbd6:	9304      	str	r3, [sp, #16]
 801fbd8:	46a2      	mov	sl, r4
 801fbda:	e7d2      	b.n	801fb82 <_vfiprintf_r+0xe2>
 801fbdc:	9b03      	ldr	r3, [sp, #12]
 801fbde:	1d19      	adds	r1, r3, #4
 801fbe0:	681b      	ldr	r3, [r3, #0]
 801fbe2:	9103      	str	r1, [sp, #12]
 801fbe4:	2b00      	cmp	r3, #0
 801fbe6:	bfbb      	ittet	lt
 801fbe8:	425b      	neglt	r3, r3
 801fbea:	f042 0202 	orrlt.w	r2, r2, #2
 801fbee:	9307      	strge	r3, [sp, #28]
 801fbf0:	9307      	strlt	r3, [sp, #28]
 801fbf2:	bfb8      	it	lt
 801fbf4:	9204      	strlt	r2, [sp, #16]
 801fbf6:	7823      	ldrb	r3, [r4, #0]
 801fbf8:	2b2e      	cmp	r3, #46	; 0x2e
 801fbfa:	d10c      	bne.n	801fc16 <_vfiprintf_r+0x176>
 801fbfc:	7863      	ldrb	r3, [r4, #1]
 801fbfe:	2b2a      	cmp	r3, #42	; 0x2a
 801fc00:	d135      	bne.n	801fc6e <_vfiprintf_r+0x1ce>
 801fc02:	9b03      	ldr	r3, [sp, #12]
 801fc04:	1d1a      	adds	r2, r3, #4
 801fc06:	681b      	ldr	r3, [r3, #0]
 801fc08:	9203      	str	r2, [sp, #12]
 801fc0a:	2b00      	cmp	r3, #0
 801fc0c:	bfb8      	it	lt
 801fc0e:	f04f 33ff 	movlt.w	r3, #4294967295
 801fc12:	3402      	adds	r4, #2
 801fc14:	9305      	str	r3, [sp, #20]
 801fc16:	f8df a0e4 	ldr.w	sl, [pc, #228]	; 801fcfc <_vfiprintf_r+0x25c>
 801fc1a:	7821      	ldrb	r1, [r4, #0]
 801fc1c:	2203      	movs	r2, #3
 801fc1e:	4650      	mov	r0, sl
 801fc20:	f7e0 fc8e 	bl	8000540 <memchr>
 801fc24:	b140      	cbz	r0, 801fc38 <_vfiprintf_r+0x198>
 801fc26:	2340      	movs	r3, #64	; 0x40
 801fc28:	eba0 000a 	sub.w	r0, r0, sl
 801fc2c:	fa03 f000 	lsl.w	r0, r3, r0
 801fc30:	9b04      	ldr	r3, [sp, #16]
 801fc32:	4303      	orrs	r3, r0
 801fc34:	3401      	adds	r4, #1
 801fc36:	9304      	str	r3, [sp, #16]
 801fc38:	f814 1b01 	ldrb.w	r1, [r4], #1
 801fc3c:	482c      	ldr	r0, [pc, #176]	; (801fcf0 <_vfiprintf_r+0x250>)
 801fc3e:	f88d 1028 	strb.w	r1, [sp, #40]	; 0x28
 801fc42:	2206      	movs	r2, #6
 801fc44:	f7e0 fc7c 	bl	8000540 <memchr>
 801fc48:	2800      	cmp	r0, #0
 801fc4a:	d03f      	beq.n	801fccc <_vfiprintf_r+0x22c>
 801fc4c:	4b29      	ldr	r3, [pc, #164]	; (801fcf4 <_vfiprintf_r+0x254>)
 801fc4e:	bb1b      	cbnz	r3, 801fc98 <_vfiprintf_r+0x1f8>
 801fc50:	9b03      	ldr	r3, [sp, #12]
 801fc52:	3307      	adds	r3, #7
 801fc54:	f023 0307 	bic.w	r3, r3, #7
 801fc58:	3308      	adds	r3, #8
 801fc5a:	9303      	str	r3, [sp, #12]
 801fc5c:	9b09      	ldr	r3, [sp, #36]	; 0x24
 801fc5e:	443b      	add	r3, r7
 801fc60:	9309      	str	r3, [sp, #36]	; 0x24
 801fc62:	e767      	b.n	801fb34 <_vfiprintf_r+0x94>
 801fc64:	fb0c 3202 	mla	r2, ip, r2, r3
 801fc68:	460c      	mov	r4, r1
 801fc6a:	2001      	movs	r0, #1
 801fc6c:	e7a5      	b.n	801fbba <_vfiprintf_r+0x11a>
 801fc6e:	2300      	movs	r3, #0
 801fc70:	3401      	adds	r4, #1
 801fc72:	9305      	str	r3, [sp, #20]
 801fc74:	4619      	mov	r1, r3
 801fc76:	f04f 0c0a 	mov.w	ip, #10
 801fc7a:	4620      	mov	r0, r4
 801fc7c:	f810 2b01 	ldrb.w	r2, [r0], #1
 801fc80:	3a30      	subs	r2, #48	; 0x30
 801fc82:	2a09      	cmp	r2, #9
 801fc84:	d903      	bls.n	801fc8e <_vfiprintf_r+0x1ee>
 801fc86:	2b00      	cmp	r3, #0
 801fc88:	d0c5      	beq.n	801fc16 <_vfiprintf_r+0x176>
 801fc8a:	9105      	str	r1, [sp, #20]
 801fc8c:	e7c3      	b.n	801fc16 <_vfiprintf_r+0x176>
 801fc8e:	fb0c 2101 	mla	r1, ip, r1, r2
 801fc92:	4604      	mov	r4, r0
 801fc94:	2301      	movs	r3, #1
 801fc96:	e7f0      	b.n	801fc7a <_vfiprintf_r+0x1da>
 801fc98:	ab03      	add	r3, sp, #12
 801fc9a:	9300      	str	r3, [sp, #0]
 801fc9c:	462a      	mov	r2, r5
 801fc9e:	4b16      	ldr	r3, [pc, #88]	; (801fcf8 <_vfiprintf_r+0x258>)
 801fca0:	a904      	add	r1, sp, #16
 801fca2:	4630      	mov	r0, r6
 801fca4:	f3af 8000 	nop.w
 801fca8:	4607      	mov	r7, r0
 801fcaa:	1c78      	adds	r0, r7, #1
 801fcac:	d1d6      	bne.n	801fc5c <_vfiprintf_r+0x1bc>
 801fcae:	6e6b      	ldr	r3, [r5, #100]	; 0x64
 801fcb0:	07d9      	lsls	r1, r3, #31
 801fcb2:	d405      	bmi.n	801fcc0 <_vfiprintf_r+0x220>
 801fcb4:	89ab      	ldrh	r3, [r5, #12]
 801fcb6:	059a      	lsls	r2, r3, #22
 801fcb8:	d402      	bmi.n	801fcc0 <_vfiprintf_r+0x220>
 801fcba:	6da8      	ldr	r0, [r5, #88]	; 0x58
 801fcbc:	f7e1 fcd7 	bl	800166e <__retarget_lock_release_recursive>
 801fcc0:	89ab      	ldrh	r3, [r5, #12]
 801fcc2:	065b      	lsls	r3, r3, #25
 801fcc4:	f53f af12 	bmi.w	801faec <_vfiprintf_r+0x4c>
 801fcc8:	9809      	ldr	r0, [sp, #36]	; 0x24
 801fcca:	e711      	b.n	801faf0 <_vfiprintf_r+0x50>
 801fccc:	ab03      	add	r3, sp, #12
 801fcce:	9300      	str	r3, [sp, #0]
 801fcd0:	462a      	mov	r2, r5
 801fcd2:	4b09      	ldr	r3, [pc, #36]	; (801fcf8 <_vfiprintf_r+0x258>)
 801fcd4:	a904      	add	r1, sp, #16
 801fcd6:	4630      	mov	r0, r6
 801fcd8:	f000 f880 	bl	801fddc <_printf_i>
 801fcdc:	e7e4      	b.n	801fca8 <_vfiprintf_r+0x208>
 801fcde:	bf00      	nop
 801fce0:	0802906c 	.word	0x0802906c
 801fce4:	0802908c 	.word	0x0802908c
 801fce8:	0802904c 	.word	0x0802904c
 801fcec:	08028910 	.word	0x08028910
 801fcf0:	0802891a 	.word	0x0802891a
 801fcf4:	00000000 	.word	0x00000000
 801fcf8:	0801fa7b 	.word	0x0801fa7b
 801fcfc:	08028916 	.word	0x08028916

0801fd00 <_printf_common>:
 801fd00:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 801fd04:	4616      	mov	r6, r2
 801fd06:	4699      	mov	r9, r3
 801fd08:	688a      	ldr	r2, [r1, #8]
 801fd0a:	690b      	ldr	r3, [r1, #16]
 801fd0c:	f8dd 8020 	ldr.w	r8, [sp, #32]
 801fd10:	4293      	cmp	r3, r2
 801fd12:	bfb8      	it	lt
 801fd14:	4613      	movlt	r3, r2
 801fd16:	6033      	str	r3, [r6, #0]
 801fd18:	f891 2043 	ldrb.w	r2, [r1, #67]	; 0x43
 801fd1c:	4607      	mov	r7, r0
 801fd1e:	460c      	mov	r4, r1
 801fd20:	b10a      	cbz	r2, 801fd26 <_printf_common+0x26>
 801fd22:	3301      	adds	r3, #1
 801fd24:	6033      	str	r3, [r6, #0]
 801fd26:	6823      	ldr	r3, [r4, #0]
 801fd28:	0699      	lsls	r1, r3, #26
 801fd2a:	bf42      	ittt	mi
 801fd2c:	6833      	ldrmi	r3, [r6, #0]
 801fd2e:	3302      	addmi	r3, #2
 801fd30:	6033      	strmi	r3, [r6, #0]
 801fd32:	6825      	ldr	r5, [r4, #0]
 801fd34:	f015 0506 	ands.w	r5, r5, #6
 801fd38:	d106      	bne.n	801fd48 <_printf_common+0x48>
 801fd3a:	f104 0a19 	add.w	sl, r4, #25
 801fd3e:	68e3      	ldr	r3, [r4, #12]
 801fd40:	6832      	ldr	r2, [r6, #0]
 801fd42:	1a9b      	subs	r3, r3, r2
 801fd44:	42ab      	cmp	r3, r5
 801fd46:	dc26      	bgt.n	801fd96 <_printf_common+0x96>
 801fd48:	f894 2043 	ldrb.w	r2, [r4, #67]	; 0x43
 801fd4c:	1e13      	subs	r3, r2, #0
 801fd4e:	6822      	ldr	r2, [r4, #0]
 801fd50:	bf18      	it	ne
 801fd52:	2301      	movne	r3, #1
 801fd54:	0692      	lsls	r2, r2, #26
 801fd56:	d42b      	bmi.n	801fdb0 <_printf_common+0xb0>
 801fd58:	f104 0243 	add.w	r2, r4, #67	; 0x43
 801fd5c:	4649      	mov	r1, r9
 801fd5e:	4638      	mov	r0, r7
 801fd60:	47c0      	blx	r8
 801fd62:	3001      	adds	r0, #1
 801fd64:	d01e      	beq.n	801fda4 <_printf_common+0xa4>
 801fd66:	6823      	ldr	r3, [r4, #0]
 801fd68:	68e5      	ldr	r5, [r4, #12]
 801fd6a:	6832      	ldr	r2, [r6, #0]
 801fd6c:	f003 0306 	and.w	r3, r3, #6
 801fd70:	2b04      	cmp	r3, #4
 801fd72:	bf08      	it	eq
 801fd74:	1aad      	subeq	r5, r5, r2
 801fd76:	68a3      	ldr	r3, [r4, #8]
 801fd78:	6922      	ldr	r2, [r4, #16]
 801fd7a:	bf0c      	ite	eq
 801fd7c:	ea25 75e5 	biceq.w	r5, r5, r5, asr #31
 801fd80:	2500      	movne	r5, #0
 801fd82:	4293      	cmp	r3, r2
 801fd84:	bfc4      	itt	gt
 801fd86:	1a9b      	subgt	r3, r3, r2
 801fd88:	18ed      	addgt	r5, r5, r3
 801fd8a:	2600      	movs	r6, #0
 801fd8c:	341a      	adds	r4, #26
 801fd8e:	42b5      	cmp	r5, r6
 801fd90:	d11a      	bne.n	801fdc8 <_printf_common+0xc8>
 801fd92:	2000      	movs	r0, #0
 801fd94:	e008      	b.n	801fda8 <_printf_common+0xa8>
 801fd96:	2301      	movs	r3, #1
 801fd98:	4652      	mov	r2, sl
 801fd9a:	4649      	mov	r1, r9
 801fd9c:	4638      	mov	r0, r7
 801fd9e:	47c0      	blx	r8
 801fda0:	3001      	adds	r0, #1
 801fda2:	d103      	bne.n	801fdac <_printf_common+0xac>
 801fda4:	f04f 30ff 	mov.w	r0, #4294967295
 801fda8:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 801fdac:	3501      	adds	r5, #1
 801fdae:	e7c6      	b.n	801fd3e <_printf_common+0x3e>
 801fdb0:	18e1      	adds	r1, r4, r3
 801fdb2:	1c5a      	adds	r2, r3, #1
 801fdb4:	2030      	movs	r0, #48	; 0x30
 801fdb6:	f881 0043 	strb.w	r0, [r1, #67]	; 0x43
 801fdba:	4422      	add	r2, r4
 801fdbc:	f894 1045 	ldrb.w	r1, [r4, #69]	; 0x45
 801fdc0:	f882 1043 	strb.w	r1, [r2, #67]	; 0x43
 801fdc4:	3302      	adds	r3, #2
 801fdc6:	e7c7      	b.n	801fd58 <_printf_common+0x58>
 801fdc8:	2301      	movs	r3, #1
 801fdca:	4622      	mov	r2, r4
 801fdcc:	4649      	mov	r1, r9
 801fdce:	4638      	mov	r0, r7
 801fdd0:	47c0      	blx	r8
 801fdd2:	3001      	adds	r0, #1
 801fdd4:	d0e6      	beq.n	801fda4 <_printf_common+0xa4>
 801fdd6:	3601      	adds	r6, #1
 801fdd8:	e7d9      	b.n	801fd8e <_printf_common+0x8e>
	...

0801fddc <_printf_i>:
 801fddc:	e92d 47ff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, lr}
 801fde0:	7e0f      	ldrb	r7, [r1, #24]
 801fde2:	9d0c      	ldr	r5, [sp, #48]	; 0x30
 801fde4:	2f78      	cmp	r7, #120	; 0x78
 801fde6:	4691      	mov	r9, r2
 801fde8:	4680      	mov	r8, r0
 801fdea:	460c      	mov	r4, r1
 801fdec:	469a      	mov	sl, r3
 801fdee:	f101 0243 	add.w	r2, r1, #67	; 0x43
 801fdf2:	d807      	bhi.n	801fe04 <_printf_i+0x28>
 801fdf4:	2f62      	cmp	r7, #98	; 0x62
 801fdf6:	d80a      	bhi.n	801fe0e <_printf_i+0x32>
 801fdf8:	2f00      	cmp	r7, #0
 801fdfa:	f000 80d8 	beq.w	801ffae <_printf_i+0x1d2>
 801fdfe:	2f58      	cmp	r7, #88	; 0x58
 801fe00:	f000 80a3 	beq.w	801ff4a <_printf_i+0x16e>
 801fe04:	f104 0542 	add.w	r5, r4, #66	; 0x42
 801fe08:	f884 7042 	strb.w	r7, [r4, #66]	; 0x42
 801fe0c:	e03a      	b.n	801fe84 <_printf_i+0xa8>
 801fe0e:	f1a7 0363 	sub.w	r3, r7, #99	; 0x63
 801fe12:	2b15      	cmp	r3, #21
 801fe14:	d8f6      	bhi.n	801fe04 <_printf_i+0x28>
 801fe16:	a101      	add	r1, pc, #4	; (adr r1, 801fe1c <_printf_i+0x40>)
 801fe18:	f851 f023 	ldr.w	pc, [r1, r3, lsl #2]
 801fe1c:	0801fe75 	.word	0x0801fe75
 801fe20:	0801fe89 	.word	0x0801fe89
 801fe24:	0801fe05 	.word	0x0801fe05
 801fe28:	0801fe05 	.word	0x0801fe05
 801fe2c:	0801fe05 	.word	0x0801fe05
 801fe30:	0801fe05 	.word	0x0801fe05
 801fe34:	0801fe89 	.word	0x0801fe89
 801fe38:	0801fe05 	.word	0x0801fe05
 801fe3c:	0801fe05 	.word	0x0801fe05
 801fe40:	0801fe05 	.word	0x0801fe05
 801fe44:	0801fe05 	.word	0x0801fe05
 801fe48:	0801ff95 	.word	0x0801ff95
 801fe4c:	0801feb9 	.word	0x0801feb9
 801fe50:	0801ff77 	.word	0x0801ff77
 801fe54:	0801fe05 	.word	0x0801fe05
 801fe58:	0801fe05 	.word	0x0801fe05
 801fe5c:	0801ffb7 	.word	0x0801ffb7
 801fe60:	0801fe05 	.word	0x0801fe05
 801fe64:	0801feb9 	.word	0x0801feb9
 801fe68:	0801fe05 	.word	0x0801fe05
 801fe6c:	0801fe05 	.word	0x0801fe05
 801fe70:	0801ff7f 	.word	0x0801ff7f
 801fe74:	682b      	ldr	r3, [r5, #0]
 801fe76:	1d1a      	adds	r2, r3, #4
 801fe78:	681b      	ldr	r3, [r3, #0]
 801fe7a:	602a      	str	r2, [r5, #0]
 801fe7c:	f104 0542 	add.w	r5, r4, #66	; 0x42
 801fe80:	f884 3042 	strb.w	r3, [r4, #66]	; 0x42
 801fe84:	2301      	movs	r3, #1
 801fe86:	e0a3      	b.n	801ffd0 <_printf_i+0x1f4>
 801fe88:	6820      	ldr	r0, [r4, #0]
 801fe8a:	6829      	ldr	r1, [r5, #0]
 801fe8c:	0606      	lsls	r6, r0, #24
 801fe8e:	f101 0304 	add.w	r3, r1, #4
 801fe92:	d50a      	bpl.n	801feaa <_printf_i+0xce>
 801fe94:	680e      	ldr	r6, [r1, #0]
 801fe96:	602b      	str	r3, [r5, #0]
 801fe98:	2e00      	cmp	r6, #0
 801fe9a:	da03      	bge.n	801fea4 <_printf_i+0xc8>
 801fe9c:	232d      	movs	r3, #45	; 0x2d
 801fe9e:	4276      	negs	r6, r6
 801fea0:	f884 3043 	strb.w	r3, [r4, #67]	; 0x43
 801fea4:	485e      	ldr	r0, [pc, #376]	; (8020020 <_printf_i+0x244>)
 801fea6:	230a      	movs	r3, #10
 801fea8:	e019      	b.n	801fede <_printf_i+0x102>
 801feaa:	680e      	ldr	r6, [r1, #0]
 801feac:	602b      	str	r3, [r5, #0]
 801feae:	f010 0f40 	tst.w	r0, #64	; 0x40
 801feb2:	bf18      	it	ne
 801feb4:	b236      	sxthne	r6, r6
 801feb6:	e7ef      	b.n	801fe98 <_printf_i+0xbc>
 801feb8:	682b      	ldr	r3, [r5, #0]
 801feba:	6820      	ldr	r0, [r4, #0]
 801febc:	1d19      	adds	r1, r3, #4
 801febe:	6029      	str	r1, [r5, #0]
 801fec0:	0601      	lsls	r1, r0, #24
 801fec2:	d501      	bpl.n	801fec8 <_printf_i+0xec>
 801fec4:	681e      	ldr	r6, [r3, #0]
 801fec6:	e002      	b.n	801fece <_printf_i+0xf2>
 801fec8:	0646      	lsls	r6, r0, #25
 801feca:	d5fb      	bpl.n	801fec4 <_printf_i+0xe8>
 801fecc:	881e      	ldrh	r6, [r3, #0]
 801fece:	4854      	ldr	r0, [pc, #336]	; (8020020 <_printf_i+0x244>)
 801fed0:	2f6f      	cmp	r7, #111	; 0x6f
 801fed2:	bf0c      	ite	eq
 801fed4:	2308      	moveq	r3, #8
 801fed6:	230a      	movne	r3, #10
 801fed8:	2100      	movs	r1, #0
 801feda:	f884 1043 	strb.w	r1, [r4, #67]	; 0x43
 801fede:	6865      	ldr	r5, [r4, #4]
 801fee0:	60a5      	str	r5, [r4, #8]
 801fee2:	2d00      	cmp	r5, #0
 801fee4:	bfa2      	ittt	ge
 801fee6:	6821      	ldrge	r1, [r4, #0]
 801fee8:	f021 0104 	bicge.w	r1, r1, #4
 801feec:	6021      	strge	r1, [r4, #0]
 801feee:	b90e      	cbnz	r6, 801fef4 <_printf_i+0x118>
 801fef0:	2d00      	cmp	r5, #0
 801fef2:	d04d      	beq.n	801ff90 <_printf_i+0x1b4>
 801fef4:	4615      	mov	r5, r2
 801fef6:	fbb6 f1f3 	udiv	r1, r6, r3
 801fefa:	fb03 6711 	mls	r7, r3, r1, r6
 801fefe:	5dc7      	ldrb	r7, [r0, r7]
 801ff00:	f805 7d01 	strb.w	r7, [r5, #-1]!
 801ff04:	4637      	mov	r7, r6
 801ff06:	42bb      	cmp	r3, r7
 801ff08:	460e      	mov	r6, r1
 801ff0a:	d9f4      	bls.n	801fef6 <_printf_i+0x11a>
 801ff0c:	2b08      	cmp	r3, #8
 801ff0e:	d10b      	bne.n	801ff28 <_printf_i+0x14c>
 801ff10:	6823      	ldr	r3, [r4, #0]
 801ff12:	07de      	lsls	r6, r3, #31
 801ff14:	d508      	bpl.n	801ff28 <_printf_i+0x14c>
 801ff16:	6923      	ldr	r3, [r4, #16]
 801ff18:	6861      	ldr	r1, [r4, #4]
 801ff1a:	4299      	cmp	r1, r3
 801ff1c:	bfde      	ittt	le
 801ff1e:	2330      	movle	r3, #48	; 0x30
 801ff20:	f805 3c01 	strble.w	r3, [r5, #-1]
 801ff24:	f105 35ff 	addle.w	r5, r5, #4294967295
 801ff28:	1b52      	subs	r2, r2, r5
 801ff2a:	6122      	str	r2, [r4, #16]
 801ff2c:	f8cd a000 	str.w	sl, [sp]
 801ff30:	464b      	mov	r3, r9
 801ff32:	aa03      	add	r2, sp, #12
 801ff34:	4621      	mov	r1, r4
 801ff36:	4640      	mov	r0, r8
 801ff38:	f7ff fee2 	bl	801fd00 <_printf_common>
 801ff3c:	3001      	adds	r0, #1
 801ff3e:	d14c      	bne.n	801ffda <_printf_i+0x1fe>
 801ff40:	f04f 30ff 	mov.w	r0, #4294967295
 801ff44:	b004      	add	sp, #16
 801ff46:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 801ff4a:	4835      	ldr	r0, [pc, #212]	; (8020020 <_printf_i+0x244>)
 801ff4c:	f881 7045 	strb.w	r7, [r1, #69]	; 0x45
 801ff50:	6829      	ldr	r1, [r5, #0]
 801ff52:	6823      	ldr	r3, [r4, #0]
 801ff54:	f851 6b04 	ldr.w	r6, [r1], #4
 801ff58:	6029      	str	r1, [r5, #0]
 801ff5a:	061d      	lsls	r5, r3, #24
 801ff5c:	d514      	bpl.n	801ff88 <_printf_i+0x1ac>
 801ff5e:	07df      	lsls	r7, r3, #31
 801ff60:	bf44      	itt	mi
 801ff62:	f043 0320 	orrmi.w	r3, r3, #32
 801ff66:	6023      	strmi	r3, [r4, #0]
 801ff68:	b91e      	cbnz	r6, 801ff72 <_printf_i+0x196>
 801ff6a:	6823      	ldr	r3, [r4, #0]
 801ff6c:	f023 0320 	bic.w	r3, r3, #32
 801ff70:	6023      	str	r3, [r4, #0]
 801ff72:	2310      	movs	r3, #16
 801ff74:	e7b0      	b.n	801fed8 <_printf_i+0xfc>
 801ff76:	6823      	ldr	r3, [r4, #0]
 801ff78:	f043 0320 	orr.w	r3, r3, #32
 801ff7c:	6023      	str	r3, [r4, #0]
 801ff7e:	2378      	movs	r3, #120	; 0x78
 801ff80:	4828      	ldr	r0, [pc, #160]	; (8020024 <_printf_i+0x248>)
 801ff82:	f884 3045 	strb.w	r3, [r4, #69]	; 0x45
 801ff86:	e7e3      	b.n	801ff50 <_printf_i+0x174>
 801ff88:	0659      	lsls	r1, r3, #25
 801ff8a:	bf48      	it	mi
 801ff8c:	b2b6      	uxthmi	r6, r6
 801ff8e:	e7e6      	b.n	801ff5e <_printf_i+0x182>
 801ff90:	4615      	mov	r5, r2
 801ff92:	e7bb      	b.n	801ff0c <_printf_i+0x130>
 801ff94:	682b      	ldr	r3, [r5, #0]
 801ff96:	6826      	ldr	r6, [r4, #0]
 801ff98:	6961      	ldr	r1, [r4, #20]
 801ff9a:	1d18      	adds	r0, r3, #4
 801ff9c:	6028      	str	r0, [r5, #0]
 801ff9e:	0635      	lsls	r5, r6, #24
 801ffa0:	681b      	ldr	r3, [r3, #0]
 801ffa2:	d501      	bpl.n	801ffa8 <_printf_i+0x1cc>
 801ffa4:	6019      	str	r1, [r3, #0]
 801ffa6:	e002      	b.n	801ffae <_printf_i+0x1d2>
 801ffa8:	0670      	lsls	r0, r6, #25
 801ffaa:	d5fb      	bpl.n	801ffa4 <_printf_i+0x1c8>
 801ffac:	8019      	strh	r1, [r3, #0]
 801ffae:	2300      	movs	r3, #0
 801ffb0:	6123      	str	r3, [r4, #16]
 801ffb2:	4615      	mov	r5, r2
 801ffb4:	e7ba      	b.n	801ff2c <_printf_i+0x150>
 801ffb6:	682b      	ldr	r3, [r5, #0]
 801ffb8:	1d1a      	adds	r2, r3, #4
 801ffba:	602a      	str	r2, [r5, #0]
 801ffbc:	681d      	ldr	r5, [r3, #0]
 801ffbe:	6862      	ldr	r2, [r4, #4]
 801ffc0:	2100      	movs	r1, #0
 801ffc2:	4628      	mov	r0, r5
 801ffc4:	f7e0 fabc 	bl	8000540 <memchr>
 801ffc8:	b108      	cbz	r0, 801ffce <_printf_i+0x1f2>
 801ffca:	1b40      	subs	r0, r0, r5
 801ffcc:	6060      	str	r0, [r4, #4]
 801ffce:	6863      	ldr	r3, [r4, #4]
 801ffd0:	6123      	str	r3, [r4, #16]
 801ffd2:	2300      	movs	r3, #0
 801ffd4:	f884 3043 	strb.w	r3, [r4, #67]	; 0x43
 801ffd8:	e7a8      	b.n	801ff2c <_printf_i+0x150>
 801ffda:	6923      	ldr	r3, [r4, #16]
 801ffdc:	462a      	mov	r2, r5
 801ffde:	4649      	mov	r1, r9
 801ffe0:	4640      	mov	r0, r8
 801ffe2:	47d0      	blx	sl
 801ffe4:	3001      	adds	r0, #1
 801ffe6:	d0ab      	beq.n	801ff40 <_printf_i+0x164>
 801ffe8:	6823      	ldr	r3, [r4, #0]
 801ffea:	079b      	lsls	r3, r3, #30
 801ffec:	d413      	bmi.n	8020016 <_printf_i+0x23a>
 801ffee:	68e0      	ldr	r0, [r4, #12]
 801fff0:	9b03      	ldr	r3, [sp, #12]
 801fff2:	4298      	cmp	r0, r3
 801fff4:	bfb8      	it	lt
 801fff6:	4618      	movlt	r0, r3
 801fff8:	e7a4      	b.n	801ff44 <_printf_i+0x168>
 801fffa:	2301      	movs	r3, #1
 801fffc:	4632      	mov	r2, r6
 801fffe:	4649      	mov	r1, r9
 8020000:	4640      	mov	r0, r8
 8020002:	47d0      	blx	sl
 8020004:	3001      	adds	r0, #1
 8020006:	d09b      	beq.n	801ff40 <_printf_i+0x164>
 8020008:	3501      	adds	r5, #1
 802000a:	68e3      	ldr	r3, [r4, #12]
 802000c:	9903      	ldr	r1, [sp, #12]
 802000e:	1a5b      	subs	r3, r3, r1
 8020010:	42ab      	cmp	r3, r5
 8020012:	dcf2      	bgt.n	801fffa <_printf_i+0x21e>
 8020014:	e7eb      	b.n	801ffee <_printf_i+0x212>
 8020016:	2500      	movs	r5, #0
 8020018:	f104 0619 	add.w	r6, r4, #25
 802001c:	e7f5      	b.n	802000a <_printf_i+0x22e>
 802001e:	bf00      	nop
 8020020:	08028921 	.word	0x08028921
 8020024:	08028932 	.word	0x08028932

08020028 <_perror_r>:
 8020028:	6983      	ldr	r3, [r0, #24]
 802002a:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
 802002c:	68c4      	ldr	r4, [r0, #12]
 802002e:	4605      	mov	r5, r0
 8020030:	460e      	mov	r6, r1
 8020032:	b90b      	cbnz	r3, 8020038 <_perror_r+0x10>
 8020034:	f000 ff34 	bl	8020ea0 <__sinit>
 8020038:	4b43      	ldr	r3, [pc, #268]	; (8020148 <_perror_r+0x120>)
 802003a:	429c      	cmp	r4, r3
 802003c:	d132      	bne.n	80200a4 <_perror_r+0x7c>
 802003e:	686c      	ldr	r4, [r5, #4]
 8020040:	6e63      	ldr	r3, [r4, #100]	; 0x64
 8020042:	07d8      	lsls	r0, r3, #31
 8020044:	d405      	bmi.n	8020052 <_perror_r+0x2a>
 8020046:	89a3      	ldrh	r3, [r4, #12]
 8020048:	0599      	lsls	r1, r3, #22
 802004a:	d402      	bmi.n	8020052 <_perror_r+0x2a>
 802004c:	6da0      	ldr	r0, [r4, #88]	; 0x58
 802004e:	f7e1 fafa 	bl	8001646 <__retarget_lock_acquire_recursive>
 8020052:	4621      	mov	r1, r4
 8020054:	4628      	mov	r0, r5
 8020056:	f000 fe51 	bl	8020cfc <_fflush_r>
 802005a:	bb6e      	cbnz	r6, 80200b8 <_perror_r+0x90>
 802005c:	6829      	ldr	r1, [r5, #0]
 802005e:	ab01      	add	r3, sp, #4
 8020060:	2201      	movs	r2, #1
 8020062:	4628      	mov	r0, r5
 8020064:	f000 fa1a 	bl	802049c <_strerror_r>
 8020068:	4607      	mov	r7, r0
 802006a:	2800      	cmp	r0, #0
 802006c:	d14f      	bne.n	802010e <_perror_r+0xe6>
 802006e:	4837      	ldr	r0, [pc, #220]	; (802014c <_perror_r+0x124>)
 8020070:	4f36      	ldr	r7, [pc, #216]	; (802014c <_perror_r+0x124>)
 8020072:	f7e0 fa5b 	bl	800052c <strlen>
 8020076:	4606      	mov	r6, r0
 8020078:	b156      	cbz	r6, 8020090 <_perror_r+0x68>
 802007a:	4620      	mov	r0, r4
 802007c:	f000 fe7a 	bl	8020d74 <fileno>
 8020080:	4633      	mov	r3, r6
 8020082:	4601      	mov	r1, r0
 8020084:	463a      	mov	r2, r7
 8020086:	4628      	mov	r0, r5
 8020088:	f000 fd1a 	bl	8020ac0 <_write_r>
 802008c:	2800      	cmp	r0, #0
 802008e:	da51      	bge.n	8020134 <_perror_r+0x10c>
 8020090:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
 8020094:	6e62      	ldr	r2, [r4, #100]	; 0x64
 8020096:	f423 5380 	bic.w	r3, r3, #4096	; 0x1000
 802009a:	07d2      	lsls	r2, r2, #31
 802009c:	81a3      	strh	r3, [r4, #12]
 802009e:	d54c      	bpl.n	802013a <_perror_r+0x112>
 80200a0:	b003      	add	sp, #12
 80200a2:	bdf0      	pop	{r4, r5, r6, r7, pc}
 80200a4:	4b2a      	ldr	r3, [pc, #168]	; (8020150 <_perror_r+0x128>)
 80200a6:	429c      	cmp	r4, r3
 80200a8:	d101      	bne.n	80200ae <_perror_r+0x86>
 80200aa:	68ac      	ldr	r4, [r5, #8]
 80200ac:	e7c8      	b.n	8020040 <_perror_r+0x18>
 80200ae:	4b29      	ldr	r3, [pc, #164]	; (8020154 <_perror_r+0x12c>)
 80200b0:	429c      	cmp	r4, r3
 80200b2:	bf08      	it	eq
 80200b4:	68ec      	ldreq	r4, [r5, #12]
 80200b6:	e7c3      	b.n	8020040 <_perror_r+0x18>
 80200b8:	7833      	ldrb	r3, [r6, #0]
 80200ba:	2b00      	cmp	r3, #0
 80200bc:	d0ce      	beq.n	802005c <_perror_r+0x34>
 80200be:	4630      	mov	r0, r6
 80200c0:	f7e0 fa34 	bl	800052c <strlen>
 80200c4:	4607      	mov	r7, r0
 80200c6:	b157      	cbz	r7, 80200de <_perror_r+0xb6>
 80200c8:	4620      	mov	r0, r4
 80200ca:	f000 fe53 	bl	8020d74 <fileno>
 80200ce:	463b      	mov	r3, r7
 80200d0:	4601      	mov	r1, r0
 80200d2:	4632      	mov	r2, r6
 80200d4:	4628      	mov	r0, r5
 80200d6:	f000 fcf3 	bl	8020ac0 <_write_r>
 80200da:	2800      	cmp	r0, #0
 80200dc:	da14      	bge.n	8020108 <_perror_r+0xe0>
 80200de:	481e      	ldr	r0, [pc, #120]	; (8020158 <_perror_r+0x130>)
 80200e0:	4f1d      	ldr	r7, [pc, #116]	; (8020158 <_perror_r+0x130>)
 80200e2:	f7e0 fa23 	bl	800052c <strlen>
 80200e6:	4606      	mov	r6, r0
 80200e8:	2e00      	cmp	r6, #0
 80200ea:	d0b7      	beq.n	802005c <_perror_r+0x34>
 80200ec:	4620      	mov	r0, r4
 80200ee:	f000 fe41 	bl	8020d74 <fileno>
 80200f2:	4633      	mov	r3, r6
 80200f4:	4601      	mov	r1, r0
 80200f6:	463a      	mov	r2, r7
 80200f8:	4628      	mov	r0, r5
 80200fa:	f000 fce1 	bl	8020ac0 <_write_r>
 80200fe:	2800      	cmp	r0, #0
 8020100:	dbac      	blt.n	802005c <_perror_r+0x34>
 8020102:	1a36      	subs	r6, r6, r0
 8020104:	4407      	add	r7, r0
 8020106:	e7ef      	b.n	80200e8 <_perror_r+0xc0>
 8020108:	1a3f      	subs	r7, r7, r0
 802010a:	4406      	add	r6, r0
 802010c:	e7db      	b.n	80200c6 <_perror_r+0x9e>
 802010e:	f7e0 fa0d 	bl	800052c <strlen>
 8020112:	4606      	mov	r6, r0
 8020114:	2e00      	cmp	r6, #0
 8020116:	d0aa      	beq.n	802006e <_perror_r+0x46>
 8020118:	4620      	mov	r0, r4
 802011a:	f000 fe2b 	bl	8020d74 <fileno>
 802011e:	4633      	mov	r3, r6
 8020120:	4601      	mov	r1, r0
 8020122:	463a      	mov	r2, r7
 8020124:	4628      	mov	r0, r5
 8020126:	f000 fccb 	bl	8020ac0 <_write_r>
 802012a:	2800      	cmp	r0, #0
 802012c:	db9f      	blt.n	802006e <_perror_r+0x46>
 802012e:	1a36      	subs	r6, r6, r0
 8020130:	4407      	add	r7, r0
 8020132:	e7ef      	b.n	8020114 <_perror_r+0xec>
 8020134:	1a36      	subs	r6, r6, r0
 8020136:	4407      	add	r7, r0
 8020138:	e79e      	b.n	8020078 <_perror_r+0x50>
 802013a:	059b      	lsls	r3, r3, #22
 802013c:	d4b0      	bmi.n	80200a0 <_perror_r+0x78>
 802013e:	6da0      	ldr	r0, [r4, #88]	; 0x58
 8020140:	f7e1 fa95 	bl	800166e <__retarget_lock_release_recursive>
 8020144:	e7ac      	b.n	80200a0 <_perror_r+0x78>
 8020146:	bf00      	nop
 8020148:	0802906c 	.word	0x0802906c
 802014c:	08028809 	.word	0x08028809
 8020150:	0802908c 	.word	0x0802908c
 8020154:	0802904c 	.word	0x0802904c
 8020158:	080287d9 	.word	0x080287d9

0802015c <perror>:
 802015c:	4b02      	ldr	r3, [pc, #8]	; (8020168 <perror+0xc>)
 802015e:	4601      	mov	r1, r0
 8020160:	6818      	ldr	r0, [r3, #0]
 8020162:	f7ff bf61 	b.w	8020028 <_perror_r>
 8020166:	bf00      	nop
 8020168:	240004a4 	.word	0x240004a4

0802016c <iprintf>:
 802016c:	b40f      	push	{r0, r1, r2, r3}
 802016e:	4b0a      	ldr	r3, [pc, #40]	; (8020198 <iprintf+0x2c>)
 8020170:	b513      	push	{r0, r1, r4, lr}
 8020172:	681c      	ldr	r4, [r3, #0]
 8020174:	b124      	cbz	r4, 8020180 <iprintf+0x14>
 8020176:	69a3      	ldr	r3, [r4, #24]
 8020178:	b913      	cbnz	r3, 8020180 <iprintf+0x14>
 802017a:	4620      	mov	r0, r4
 802017c:	f000 fe90 	bl	8020ea0 <__sinit>
 8020180:	ab05      	add	r3, sp, #20
 8020182:	9a04      	ldr	r2, [sp, #16]
 8020184:	68a1      	ldr	r1, [r4, #8]
 8020186:	9301      	str	r3, [sp, #4]
 8020188:	4620      	mov	r0, r4
 802018a:	f7ff fc89 	bl	801faa0 <_vfiprintf_r>
 802018e:	b002      	add	sp, #8
 8020190:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
 8020194:	b004      	add	sp, #16
 8020196:	4770      	bx	lr
 8020198:	240004a4 	.word	0x240004a4

0802019c <putchar>:
 802019c:	4b09      	ldr	r3, [pc, #36]	; (80201c4 <putchar+0x28>)
 802019e:	b513      	push	{r0, r1, r4, lr}
 80201a0:	681c      	ldr	r4, [r3, #0]
 80201a2:	4601      	mov	r1, r0
 80201a4:	b134      	cbz	r4, 80201b4 <putchar+0x18>
 80201a6:	69a3      	ldr	r3, [r4, #24]
 80201a8:	b923      	cbnz	r3, 80201b4 <putchar+0x18>
 80201aa:	9001      	str	r0, [sp, #4]
 80201ac:	4620      	mov	r0, r4
 80201ae:	f000 fe77 	bl	8020ea0 <__sinit>
 80201b2:	9901      	ldr	r1, [sp, #4]
 80201b4:	68a2      	ldr	r2, [r4, #8]
 80201b6:	4620      	mov	r0, r4
 80201b8:	b002      	add	sp, #8
 80201ba:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
 80201be:	f001 bc3f 	b.w	8021a40 <_putc_r>
 80201c2:	bf00      	nop
 80201c4:	240004a4 	.word	0x240004a4

080201c8 <_puts_r>:
 80201c8:	b570      	push	{r4, r5, r6, lr}
 80201ca:	460e      	mov	r6, r1
 80201cc:	4605      	mov	r5, r0
 80201ce:	b118      	cbz	r0, 80201d8 <_puts_r+0x10>
 80201d0:	6983      	ldr	r3, [r0, #24]
 80201d2:	b90b      	cbnz	r3, 80201d8 <_puts_r+0x10>
 80201d4:	f000 fe64 	bl	8020ea0 <__sinit>
 80201d8:	69ab      	ldr	r3, [r5, #24]
 80201da:	68ac      	ldr	r4, [r5, #8]
 80201dc:	b913      	cbnz	r3, 80201e4 <_puts_r+0x1c>
 80201de:	4628      	mov	r0, r5
 80201e0:	f000 fe5e 	bl	8020ea0 <__sinit>
 80201e4:	4b2c      	ldr	r3, [pc, #176]	; (8020298 <_puts_r+0xd0>)
 80201e6:	429c      	cmp	r4, r3
 80201e8:	d120      	bne.n	802022c <_puts_r+0x64>
 80201ea:	686c      	ldr	r4, [r5, #4]
 80201ec:	6e63      	ldr	r3, [r4, #100]	; 0x64
 80201ee:	07db      	lsls	r3, r3, #31
 80201f0:	d405      	bmi.n	80201fe <_puts_r+0x36>
 80201f2:	89a3      	ldrh	r3, [r4, #12]
 80201f4:	0598      	lsls	r0, r3, #22
 80201f6:	d402      	bmi.n	80201fe <_puts_r+0x36>
 80201f8:	6da0      	ldr	r0, [r4, #88]	; 0x58
 80201fa:	f7e1 fa24 	bl	8001646 <__retarget_lock_acquire_recursive>
 80201fe:	89a3      	ldrh	r3, [r4, #12]
 8020200:	0719      	lsls	r1, r3, #28
 8020202:	d51d      	bpl.n	8020240 <_puts_r+0x78>
 8020204:	6923      	ldr	r3, [r4, #16]
 8020206:	b1db      	cbz	r3, 8020240 <_puts_r+0x78>
 8020208:	3e01      	subs	r6, #1
 802020a:	68a3      	ldr	r3, [r4, #8]
 802020c:	f816 1f01 	ldrb.w	r1, [r6, #1]!
 8020210:	3b01      	subs	r3, #1
 8020212:	60a3      	str	r3, [r4, #8]
 8020214:	bb39      	cbnz	r1, 8020266 <_puts_r+0x9e>
 8020216:	2b00      	cmp	r3, #0
 8020218:	da38      	bge.n	802028c <_puts_r+0xc4>
 802021a:	4622      	mov	r2, r4
 802021c:	210a      	movs	r1, #10
 802021e:	4628      	mov	r0, r5
 8020220:	f000 fbfc 	bl	8020a1c <__swbuf_r>
 8020224:	3001      	adds	r0, #1
 8020226:	d011      	beq.n	802024c <_puts_r+0x84>
 8020228:	250a      	movs	r5, #10
 802022a:	e011      	b.n	8020250 <_puts_r+0x88>
 802022c:	4b1b      	ldr	r3, [pc, #108]	; (802029c <_puts_r+0xd4>)
 802022e:	429c      	cmp	r4, r3
 8020230:	d101      	bne.n	8020236 <_puts_r+0x6e>
 8020232:	68ac      	ldr	r4, [r5, #8]
 8020234:	e7da      	b.n	80201ec <_puts_r+0x24>
 8020236:	4b1a      	ldr	r3, [pc, #104]	; (80202a0 <_puts_r+0xd8>)
 8020238:	429c      	cmp	r4, r3
 802023a:	bf08      	it	eq
 802023c:	68ec      	ldreq	r4, [r5, #12]
 802023e:	e7d5      	b.n	80201ec <_puts_r+0x24>
 8020240:	4621      	mov	r1, r4
 8020242:	4628      	mov	r0, r5
 8020244:	f000 fc4e 	bl	8020ae4 <__swsetup_r>
 8020248:	2800      	cmp	r0, #0
 802024a:	d0dd      	beq.n	8020208 <_puts_r+0x40>
 802024c:	f04f 35ff 	mov.w	r5, #4294967295
 8020250:	6e63      	ldr	r3, [r4, #100]	; 0x64
 8020252:	07da      	lsls	r2, r3, #31
 8020254:	d405      	bmi.n	8020262 <_puts_r+0x9a>
 8020256:	89a3      	ldrh	r3, [r4, #12]
 8020258:	059b      	lsls	r3, r3, #22
 802025a:	d402      	bmi.n	8020262 <_puts_r+0x9a>
 802025c:	6da0      	ldr	r0, [r4, #88]	; 0x58
 802025e:	f7e1 fa06 	bl	800166e <__retarget_lock_release_recursive>
 8020262:	4628      	mov	r0, r5
 8020264:	bd70      	pop	{r4, r5, r6, pc}
 8020266:	2b00      	cmp	r3, #0
 8020268:	da04      	bge.n	8020274 <_puts_r+0xac>
 802026a:	69a2      	ldr	r2, [r4, #24]
 802026c:	429a      	cmp	r2, r3
 802026e:	dc06      	bgt.n	802027e <_puts_r+0xb6>
 8020270:	290a      	cmp	r1, #10
 8020272:	d004      	beq.n	802027e <_puts_r+0xb6>
 8020274:	6823      	ldr	r3, [r4, #0]
 8020276:	1c5a      	adds	r2, r3, #1
 8020278:	6022      	str	r2, [r4, #0]
 802027a:	7019      	strb	r1, [r3, #0]
 802027c:	e7c5      	b.n	802020a <_puts_r+0x42>
 802027e:	4622      	mov	r2, r4
 8020280:	4628      	mov	r0, r5
 8020282:	f000 fbcb 	bl	8020a1c <__swbuf_r>
 8020286:	3001      	adds	r0, #1
 8020288:	d1bf      	bne.n	802020a <_puts_r+0x42>
 802028a:	e7df      	b.n	802024c <_puts_r+0x84>
 802028c:	6823      	ldr	r3, [r4, #0]
 802028e:	250a      	movs	r5, #10
 8020290:	1c5a      	adds	r2, r3, #1
 8020292:	6022      	str	r2, [r4, #0]
 8020294:	701d      	strb	r5, [r3, #0]
 8020296:	e7db      	b.n	8020250 <_puts_r+0x88>
 8020298:	0802906c 	.word	0x0802906c
 802029c:	0802908c 	.word	0x0802908c
 80202a0:	0802904c 	.word	0x0802904c

080202a4 <puts>:
 80202a4:	4b02      	ldr	r3, [pc, #8]	; (80202b0 <puts+0xc>)
 80202a6:	4601      	mov	r1, r0
 80202a8:	6818      	ldr	r0, [r3, #0]
 80202aa:	f7ff bf8d 	b.w	80201c8 <_puts_r>
 80202ae:	bf00      	nop
 80202b0:	240004a4 	.word	0x240004a4

080202b4 <rand>:
 80202b4:	4b16      	ldr	r3, [pc, #88]	; (8020310 <rand+0x5c>)
 80202b6:	b510      	push	{r4, lr}
 80202b8:	681c      	ldr	r4, [r3, #0]
 80202ba:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 80202bc:	b9b3      	cbnz	r3, 80202ec <rand+0x38>
 80202be:	2018      	movs	r0, #24
 80202c0:	f7ff faa4 	bl	801f80c <malloc>
 80202c4:	63a0      	str	r0, [r4, #56]	; 0x38
 80202c6:	b928      	cbnz	r0, 80202d4 <rand+0x20>
 80202c8:	4602      	mov	r2, r0
 80202ca:	4b12      	ldr	r3, [pc, #72]	; (8020314 <rand+0x60>)
 80202cc:	4812      	ldr	r0, [pc, #72]	; (8020318 <rand+0x64>)
 80202ce:	214e      	movs	r1, #78	; 0x4e
 80202d0:	f7ff fa42 	bl	801f758 <__assert_func>
 80202d4:	4a11      	ldr	r2, [pc, #68]	; (802031c <rand+0x68>)
 80202d6:	4b12      	ldr	r3, [pc, #72]	; (8020320 <rand+0x6c>)
 80202d8:	e9c0 2300 	strd	r2, r3, [r0]
 80202dc:	4b11      	ldr	r3, [pc, #68]	; (8020324 <rand+0x70>)
 80202de:	6083      	str	r3, [r0, #8]
 80202e0:	230b      	movs	r3, #11
 80202e2:	8183      	strh	r3, [r0, #12]
 80202e4:	2201      	movs	r2, #1
 80202e6:	2300      	movs	r3, #0
 80202e8:	e9c0 2304 	strd	r2, r3, [r0, #16]
 80202ec:	6ba4      	ldr	r4, [r4, #56]	; 0x38
 80202ee:	4a0e      	ldr	r2, [pc, #56]	; (8020328 <rand+0x74>)
 80202f0:	6920      	ldr	r0, [r4, #16]
 80202f2:	6963      	ldr	r3, [r4, #20]
 80202f4:	490d      	ldr	r1, [pc, #52]	; (802032c <rand+0x78>)
 80202f6:	4342      	muls	r2, r0
 80202f8:	fb01 2203 	mla	r2, r1, r3, r2
 80202fc:	fba0 0101 	umull	r0, r1, r0, r1
 8020300:	1c43      	adds	r3, r0, #1
 8020302:	eb42 0001 	adc.w	r0, r2, r1
 8020306:	e9c4 3004 	strd	r3, r0, [r4, #16]
 802030a:	f020 4000 	bic.w	r0, r0, #2147483648	; 0x80000000
 802030e:	bd10      	pop	{r4, pc}
 8020310:	240004a4 	.word	0x240004a4
 8020314:	08028943 	.word	0x08028943
 8020318:	0802895a 	.word	0x0802895a
 802031c:	abcd330e 	.word	0xabcd330e
 8020320:	e66d1234 	.word	0xe66d1234
 8020324:	0005deec 	.word	0x0005deec
 8020328:	5851f42d 	.word	0x5851f42d
 802032c:	4c957f2d 	.word	0x4c957f2d

08020330 <_sbrk_r>:
 8020330:	b538      	push	{r3, r4, r5, lr}
 8020332:	4d06      	ldr	r5, [pc, #24]	; (802034c <_sbrk_r+0x1c>)
 8020334:	2300      	movs	r3, #0
 8020336:	4604      	mov	r4, r0
 8020338:	4608      	mov	r0, r1
 802033a:	602b      	str	r3, [r5, #0]
 802033c:	f7e0 ffd6 	bl	80012ec <_sbrk>
 8020340:	1c43      	adds	r3, r0, #1
 8020342:	d102      	bne.n	802034a <_sbrk_r+0x1a>
 8020344:	682b      	ldr	r3, [r5, #0]
 8020346:	b103      	cbz	r3, 802034a <_sbrk_r+0x1a>
 8020348:	6023      	str	r3, [r4, #0]
 802034a:	bd38      	pop	{r3, r4, r5, pc}
 802034c:	2404d0bc 	.word	0x2404d0bc

08020350 <sniprintf>:
 8020350:	b40c      	push	{r2, r3}
 8020352:	b530      	push	{r4, r5, lr}
 8020354:	4b17      	ldr	r3, [pc, #92]	; (80203b4 <sniprintf+0x64>)
 8020356:	1e0c      	subs	r4, r1, #0
 8020358:	681d      	ldr	r5, [r3, #0]
 802035a:	b09d      	sub	sp, #116	; 0x74
 802035c:	da08      	bge.n	8020370 <sniprintf+0x20>
 802035e:	238b      	movs	r3, #139	; 0x8b
 8020360:	602b      	str	r3, [r5, #0]
 8020362:	f04f 30ff 	mov.w	r0, #4294967295
 8020366:	b01d      	add	sp, #116	; 0x74
 8020368:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
 802036c:	b002      	add	sp, #8
 802036e:	4770      	bx	lr
 8020370:	f44f 7302 	mov.w	r3, #520	; 0x208
 8020374:	f8ad 3014 	strh.w	r3, [sp, #20]
 8020378:	bf14      	ite	ne
 802037a:	f104 33ff 	addne.w	r3, r4, #4294967295
 802037e:	4623      	moveq	r3, r4
 8020380:	9304      	str	r3, [sp, #16]
 8020382:	9307      	str	r3, [sp, #28]
 8020384:	f64f 73ff 	movw	r3, #65535	; 0xffff
 8020388:	9002      	str	r0, [sp, #8]
 802038a:	9006      	str	r0, [sp, #24]
 802038c:	f8ad 3016 	strh.w	r3, [sp, #22]
 8020390:	9a20      	ldr	r2, [sp, #128]	; 0x80
 8020392:	ab21      	add	r3, sp, #132	; 0x84
 8020394:	a902      	add	r1, sp, #8
 8020396:	4628      	mov	r0, r5
 8020398:	9301      	str	r3, [sp, #4]
 802039a:	f000 ff2d 	bl	80211f8 <_svfiprintf_r>
 802039e:	1c43      	adds	r3, r0, #1
 80203a0:	bfbc      	itt	lt
 80203a2:	238b      	movlt	r3, #139	; 0x8b
 80203a4:	602b      	strlt	r3, [r5, #0]
 80203a6:	2c00      	cmp	r4, #0
 80203a8:	d0dd      	beq.n	8020366 <sniprintf+0x16>
 80203aa:	9b02      	ldr	r3, [sp, #8]
 80203ac:	2200      	movs	r2, #0
 80203ae:	701a      	strb	r2, [r3, #0]
 80203b0:	e7d9      	b.n	8020366 <sniprintf+0x16>
 80203b2:	bf00      	nop
 80203b4:	240004a4 	.word	0x240004a4

080203b8 <siscanf>:
 80203b8:	b40e      	push	{r1, r2, r3}
 80203ba:	b510      	push	{r4, lr}
 80203bc:	b09f      	sub	sp, #124	; 0x7c
 80203be:	ac21      	add	r4, sp, #132	; 0x84
 80203c0:	f44f 7101 	mov.w	r1, #516	; 0x204
 80203c4:	f854 2b04 	ldr.w	r2, [r4], #4
 80203c8:	9201      	str	r2, [sp, #4]
 80203ca:	f8ad 101c 	strh.w	r1, [sp, #28]
 80203ce:	9004      	str	r0, [sp, #16]
 80203d0:	9008      	str	r0, [sp, #32]
 80203d2:	f7e0 f8ab 	bl	800052c <strlen>
 80203d6:	4b0c      	ldr	r3, [pc, #48]	; (8020408 <siscanf+0x50>)
 80203d8:	9005      	str	r0, [sp, #20]
 80203da:	9009      	str	r0, [sp, #36]	; 0x24
 80203dc:	930d      	str	r3, [sp, #52]	; 0x34
 80203de:	480b      	ldr	r0, [pc, #44]	; (802040c <siscanf+0x54>)
 80203e0:	9a01      	ldr	r2, [sp, #4]
 80203e2:	6800      	ldr	r0, [r0, #0]
 80203e4:	9403      	str	r4, [sp, #12]
 80203e6:	2300      	movs	r3, #0
 80203e8:	9311      	str	r3, [sp, #68]	; 0x44
 80203ea:	9316      	str	r3, [sp, #88]	; 0x58
 80203ec:	f64f 73ff 	movw	r3, #65535	; 0xffff
 80203f0:	f8ad 301e 	strh.w	r3, [sp, #30]
 80203f4:	a904      	add	r1, sp, #16
 80203f6:	4623      	mov	r3, r4
 80203f8:	f001 f858 	bl	80214ac <__ssvfiscanf_r>
 80203fc:	b01f      	add	sp, #124	; 0x7c
 80203fe:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
 8020402:	b003      	add	sp, #12
 8020404:	4770      	bx	lr
 8020406:	bf00      	nop
 8020408:	08020433 	.word	0x08020433
 802040c:	240004a4 	.word	0x240004a4

08020410 <__sread>:
 8020410:	b510      	push	{r4, lr}
 8020412:	460c      	mov	r4, r1
 8020414:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
 8020418:	f001 fb5a 	bl	8021ad0 <_read_r>
 802041c:	2800      	cmp	r0, #0
 802041e:	bfab      	itete	ge
 8020420:	6d63      	ldrge	r3, [r4, #84]	; 0x54
 8020422:	89a3      	ldrhlt	r3, [r4, #12]
 8020424:	181b      	addge	r3, r3, r0
 8020426:	f423 5380 	biclt.w	r3, r3, #4096	; 0x1000
 802042a:	bfac      	ite	ge
 802042c:	6563      	strge	r3, [r4, #84]	; 0x54
 802042e:	81a3      	strhlt	r3, [r4, #12]
 8020430:	bd10      	pop	{r4, pc}

08020432 <__seofread>:
 8020432:	2000      	movs	r0, #0
 8020434:	4770      	bx	lr

08020436 <__swrite>:
 8020436:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 802043a:	461f      	mov	r7, r3
 802043c:	898b      	ldrh	r3, [r1, #12]
 802043e:	05db      	lsls	r3, r3, #23
 8020440:	4605      	mov	r5, r0
 8020442:	460c      	mov	r4, r1
 8020444:	4616      	mov	r6, r2
 8020446:	d505      	bpl.n	8020454 <__swrite+0x1e>
 8020448:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
 802044c:	2302      	movs	r3, #2
 802044e:	2200      	movs	r2, #0
 8020450:	f000 fdc4 	bl	8020fdc <_lseek_r>
 8020454:	89a3      	ldrh	r3, [r4, #12]
 8020456:	f9b4 100e 	ldrsh.w	r1, [r4, #14]
 802045a:	f423 5380 	bic.w	r3, r3, #4096	; 0x1000
 802045e:	81a3      	strh	r3, [r4, #12]
 8020460:	4632      	mov	r2, r6
 8020462:	463b      	mov	r3, r7
 8020464:	4628      	mov	r0, r5
 8020466:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
 802046a:	f000 bb29 	b.w	8020ac0 <_write_r>

0802046e <__sseek>:
 802046e:	b510      	push	{r4, lr}
 8020470:	460c      	mov	r4, r1
 8020472:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
 8020476:	f000 fdb1 	bl	8020fdc <_lseek_r>
 802047a:	1c43      	adds	r3, r0, #1
 802047c:	89a3      	ldrh	r3, [r4, #12]
 802047e:	bf15      	itete	ne
 8020480:	6560      	strne	r0, [r4, #84]	; 0x54
 8020482:	f423 5380 	biceq.w	r3, r3, #4096	; 0x1000
 8020486:	f443 5380 	orrne.w	r3, r3, #4096	; 0x1000
 802048a:	81a3      	strheq	r3, [r4, #12]
 802048c:	bf18      	it	ne
 802048e:	81a3      	strhne	r3, [r4, #12]
 8020490:	bd10      	pop	{r4, pc}

08020492 <__sclose>:
 8020492:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
 8020496:	f000 bb9b 	b.w	8020bd0 <_close_r>
	...

0802049c <_strerror_r>:
 802049c:	b510      	push	{r4, lr}
 802049e:	4604      	mov	r4, r0
 80204a0:	4608      	mov	r0, r1
 80204a2:	4611      	mov	r1, r2
 80204a4:	288e      	cmp	r0, #142	; 0x8e
 80204a6:	f200 8130 	bhi.w	802070a <_strerror_r+0x26e>
 80204aa:	e8df f010 	tbh	[pc, r0, lsl #1]
 80204ae:	0139      	.short	0x0139
 80204b0:	0092008f 	.word	0x0092008f
 80204b4:	00960094 	.word	0x00960094
 80204b8:	009a0098 	.word	0x009a0098
 80204bc:	009e009c 	.word	0x009e009c
 80204c0:	00a400a2 	.word	0x00a400a2
 80204c4:	00aa00a8 	.word	0x00aa00a8
 80204c8:	00ae00ac 	.word	0x00ae00ac
 80204cc:	00b0012e 	.word	0x00b0012e
 80204d0:	00b400b2 	.word	0x00b400b2
 80204d4:	00b800b6 	.word	0x00b800b6
 80204d8:	00c000be 	.word	0x00c000be
 80204dc:	00c800c6 	.word	0x00c800c6
 80204e0:	00cc00ca 	.word	0x00cc00ca
 80204e4:	00d200ce 	.word	0x00d200ce
 80204e8:	00d800d6 	.word	0x00d800d6
 80204ec:	00dc00da 	.word	0x00dc00da
 80204f0:	00e000de 	.word	0x00e000de
 80204f4:	00e400e2 	.word	0x00e400e2
 80204f8:	012e012e 	.word	0x012e012e
 80204fc:	012e012e 	.word	0x012e012e
 8020500:	012e012e 	.word	0x012e012e
 8020504:	012e012e 	.word	0x012e012e
 8020508:	00ec00e8 	.word	0x00ec00e8
 802050c:	012e012e 	.word	0x012e012e
 8020510:	012e012e 	.word	0x012e012e
 8020514:	012e012e 	.word	0x012e012e
 8020518:	012e012e 	.word	0x012e012e
 802051c:	012e012e 	.word	0x012e012e
 8020520:	012e012e 	.word	0x012e012e
 8020524:	00ee012e 	.word	0x00ee012e
 8020528:	00f00108 	.word	0x00f00108
 802052c:	012e00f2 	.word	0x012e00f2
 8020530:	012e012e 	.word	0x012e012e
 8020534:	012e00f4 	.word	0x012e00f4
 8020538:	012e012e 	.word	0x012e012e
 802053c:	012e00f6 	.word	0x012e00f6
 8020540:	00fa012e 	.word	0x00fa012e
 8020544:	012e012e 	.word	0x012e012e
 8020548:	012e00fc 	.word	0x012e00fc
 802054c:	012e012e 	.word	0x012e012e
 8020550:	012e012e 	.word	0x012e012e
 8020554:	012e012e 	.word	0x012e012e
 8020558:	012e012e 	.word	0x012e012e
 802055c:	00fe012e 	.word	0x00fe012e
 8020560:	0100012e 	.word	0x0100012e
 8020564:	01040102 	.word	0x01040102
 8020568:	012e012e 	.word	0x012e012e
 802056c:	012e0126 	.word	0x012e0126
 8020570:	012e012e 	.word	0x012e012e
 8020574:	012e012e 	.word	0x012e012e
 8020578:	012e012e 	.word	0x012e012e
 802057c:	0114012e 	.word	0x0114012e
 8020580:	010a0106 	.word	0x010a0106
 8020584:	010e010c 	.word	0x010e010c
 8020588:	012e0110 	.word	0x012e0110
 802058c:	01160112 	.word	0x01160112
 8020590:	00ea011a 	.word	0x00ea011a
 8020594:	012c00c2 	.word	0x012c00c2
 8020598:	00d000ba 	.word	0x00d000ba
 802059c:	00a000bc 	.word	0x00a000bc
 80205a0:	012a00a6 	.word	0x012a00a6
 80205a4:	012e00f8 	.word	0x012e00f8
 80205a8:	00c40118 	.word	0x00c40118
 80205ac:	011c011e 	.word	0x011c011e
 80205b0:	012e012e 	.word	0x012e012e
 80205b4:	012e012e 	.word	0x012e012e
 80205b8:	00d4012e 	.word	0x00d4012e
 80205bc:	012e012e 	.word	0x012e012e
 80205c0:	00e6012e 	.word	0x00e6012e
 80205c4:	01200128 	.word	0x01200128
 80205c8:	01240122 	.word	0x01240122
 80205cc:	4b55      	ldr	r3, [pc, #340]	; (8020724 <_strerror_r+0x288>)
 80205ce:	4618      	mov	r0, r3
 80205d0:	bd10      	pop	{r4, pc}
 80205d2:	4b55      	ldr	r3, [pc, #340]	; (8020728 <_strerror_r+0x28c>)
 80205d4:	e7fb      	b.n	80205ce <_strerror_r+0x132>
 80205d6:	4b55      	ldr	r3, [pc, #340]	; (802072c <_strerror_r+0x290>)
 80205d8:	e7f9      	b.n	80205ce <_strerror_r+0x132>
 80205da:	4b55      	ldr	r3, [pc, #340]	; (8020730 <_strerror_r+0x294>)
 80205dc:	e7f7      	b.n	80205ce <_strerror_r+0x132>
 80205de:	4b55      	ldr	r3, [pc, #340]	; (8020734 <_strerror_r+0x298>)
 80205e0:	e7f5      	b.n	80205ce <_strerror_r+0x132>
 80205e2:	4b55      	ldr	r3, [pc, #340]	; (8020738 <_strerror_r+0x29c>)
 80205e4:	e7f3      	b.n	80205ce <_strerror_r+0x132>
 80205e6:	4b55      	ldr	r3, [pc, #340]	; (802073c <_strerror_r+0x2a0>)
 80205e8:	e7f1      	b.n	80205ce <_strerror_r+0x132>
 80205ea:	4b55      	ldr	r3, [pc, #340]	; (8020740 <_strerror_r+0x2a4>)
 80205ec:	e7ef      	b.n	80205ce <_strerror_r+0x132>
 80205ee:	4b55      	ldr	r3, [pc, #340]	; (8020744 <_strerror_r+0x2a8>)
 80205f0:	e7ed      	b.n	80205ce <_strerror_r+0x132>
 80205f2:	4b55      	ldr	r3, [pc, #340]	; (8020748 <_strerror_r+0x2ac>)
 80205f4:	e7eb      	b.n	80205ce <_strerror_r+0x132>
 80205f6:	4b55      	ldr	r3, [pc, #340]	; (802074c <_strerror_r+0x2b0>)
 80205f8:	e7e9      	b.n	80205ce <_strerror_r+0x132>
 80205fa:	4b55      	ldr	r3, [pc, #340]	; (8020750 <_strerror_r+0x2b4>)
 80205fc:	e7e7      	b.n	80205ce <_strerror_r+0x132>
 80205fe:	4b55      	ldr	r3, [pc, #340]	; (8020754 <_strerror_r+0x2b8>)
 8020600:	e7e5      	b.n	80205ce <_strerror_r+0x132>
 8020602:	4b55      	ldr	r3, [pc, #340]	; (8020758 <_strerror_r+0x2bc>)
 8020604:	e7e3      	b.n	80205ce <_strerror_r+0x132>
 8020606:	4b55      	ldr	r3, [pc, #340]	; (802075c <_strerror_r+0x2c0>)
 8020608:	e7e1      	b.n	80205ce <_strerror_r+0x132>
 802060a:	4b55      	ldr	r3, [pc, #340]	; (8020760 <_strerror_r+0x2c4>)
 802060c:	e7df      	b.n	80205ce <_strerror_r+0x132>
 802060e:	4b55      	ldr	r3, [pc, #340]	; (8020764 <_strerror_r+0x2c8>)
 8020610:	e7dd      	b.n	80205ce <_strerror_r+0x132>
 8020612:	4b55      	ldr	r3, [pc, #340]	; (8020768 <_strerror_r+0x2cc>)
 8020614:	e7db      	b.n	80205ce <_strerror_r+0x132>
 8020616:	4b55      	ldr	r3, [pc, #340]	; (802076c <_strerror_r+0x2d0>)
 8020618:	e7d9      	b.n	80205ce <_strerror_r+0x132>
 802061a:	4b55      	ldr	r3, [pc, #340]	; (8020770 <_strerror_r+0x2d4>)
 802061c:	e7d7      	b.n	80205ce <_strerror_r+0x132>
 802061e:	4b55      	ldr	r3, [pc, #340]	; (8020774 <_strerror_r+0x2d8>)
 8020620:	e7d5      	b.n	80205ce <_strerror_r+0x132>
 8020622:	4b55      	ldr	r3, [pc, #340]	; (8020778 <_strerror_r+0x2dc>)
 8020624:	e7d3      	b.n	80205ce <_strerror_r+0x132>
 8020626:	4b55      	ldr	r3, [pc, #340]	; (802077c <_strerror_r+0x2e0>)
 8020628:	e7d1      	b.n	80205ce <_strerror_r+0x132>
 802062a:	4b55      	ldr	r3, [pc, #340]	; (8020780 <_strerror_r+0x2e4>)
 802062c:	e7cf      	b.n	80205ce <_strerror_r+0x132>
 802062e:	4b55      	ldr	r3, [pc, #340]	; (8020784 <_strerror_r+0x2e8>)
 8020630:	e7cd      	b.n	80205ce <_strerror_r+0x132>
 8020632:	4b55      	ldr	r3, [pc, #340]	; (8020788 <_strerror_r+0x2ec>)
 8020634:	e7cb      	b.n	80205ce <_strerror_r+0x132>
 8020636:	4b55      	ldr	r3, [pc, #340]	; (802078c <_strerror_r+0x2f0>)
 8020638:	e7c9      	b.n	80205ce <_strerror_r+0x132>
 802063a:	4b55      	ldr	r3, [pc, #340]	; (8020790 <_strerror_r+0x2f4>)
 802063c:	e7c7      	b.n	80205ce <_strerror_r+0x132>
 802063e:	4b55      	ldr	r3, [pc, #340]	; (8020794 <_strerror_r+0x2f8>)
 8020640:	e7c5      	b.n	80205ce <_strerror_r+0x132>
 8020642:	4b55      	ldr	r3, [pc, #340]	; (8020798 <_strerror_r+0x2fc>)
 8020644:	e7c3      	b.n	80205ce <_strerror_r+0x132>
 8020646:	4b55      	ldr	r3, [pc, #340]	; (802079c <_strerror_r+0x300>)
 8020648:	e7c1      	b.n	80205ce <_strerror_r+0x132>
 802064a:	4b55      	ldr	r3, [pc, #340]	; (80207a0 <_strerror_r+0x304>)
 802064c:	e7bf      	b.n	80205ce <_strerror_r+0x132>
 802064e:	4b55      	ldr	r3, [pc, #340]	; (80207a4 <_strerror_r+0x308>)
 8020650:	e7bd      	b.n	80205ce <_strerror_r+0x132>
 8020652:	4b55      	ldr	r3, [pc, #340]	; (80207a8 <_strerror_r+0x30c>)
 8020654:	e7bb      	b.n	80205ce <_strerror_r+0x132>
 8020656:	4b55      	ldr	r3, [pc, #340]	; (80207ac <_strerror_r+0x310>)
 8020658:	e7b9      	b.n	80205ce <_strerror_r+0x132>
 802065a:	4b55      	ldr	r3, [pc, #340]	; (80207b0 <_strerror_r+0x314>)
 802065c:	e7b7      	b.n	80205ce <_strerror_r+0x132>
 802065e:	4b55      	ldr	r3, [pc, #340]	; (80207b4 <_strerror_r+0x318>)
 8020660:	e7b5      	b.n	80205ce <_strerror_r+0x132>
 8020662:	4b55      	ldr	r3, [pc, #340]	; (80207b8 <_strerror_r+0x31c>)
 8020664:	e7b3      	b.n	80205ce <_strerror_r+0x132>
 8020666:	4b55      	ldr	r3, [pc, #340]	; (80207bc <_strerror_r+0x320>)
 8020668:	e7b1      	b.n	80205ce <_strerror_r+0x132>
 802066a:	4b55      	ldr	r3, [pc, #340]	; (80207c0 <_strerror_r+0x324>)
 802066c:	e7af      	b.n	80205ce <_strerror_r+0x132>
 802066e:	4b55      	ldr	r3, [pc, #340]	; (80207c4 <_strerror_r+0x328>)
 8020670:	e7ad      	b.n	80205ce <_strerror_r+0x132>
 8020672:	4b55      	ldr	r3, [pc, #340]	; (80207c8 <_strerror_r+0x32c>)
 8020674:	e7ab      	b.n	80205ce <_strerror_r+0x132>
 8020676:	4b55      	ldr	r3, [pc, #340]	; (80207cc <_strerror_r+0x330>)
 8020678:	e7a9      	b.n	80205ce <_strerror_r+0x132>
 802067a:	4b55      	ldr	r3, [pc, #340]	; (80207d0 <_strerror_r+0x334>)
 802067c:	e7a7      	b.n	80205ce <_strerror_r+0x132>
 802067e:	4b55      	ldr	r3, [pc, #340]	; (80207d4 <_strerror_r+0x338>)
 8020680:	e7a5      	b.n	80205ce <_strerror_r+0x132>
 8020682:	4b55      	ldr	r3, [pc, #340]	; (80207d8 <_strerror_r+0x33c>)
 8020684:	e7a3      	b.n	80205ce <_strerror_r+0x132>
 8020686:	4b55      	ldr	r3, [pc, #340]	; (80207dc <_strerror_r+0x340>)
 8020688:	e7a1      	b.n	80205ce <_strerror_r+0x132>
 802068a:	4b55      	ldr	r3, [pc, #340]	; (80207e0 <_strerror_r+0x344>)
 802068c:	e79f      	b.n	80205ce <_strerror_r+0x132>
 802068e:	4b55      	ldr	r3, [pc, #340]	; (80207e4 <_strerror_r+0x348>)
 8020690:	e79d      	b.n	80205ce <_strerror_r+0x132>
 8020692:	4b55      	ldr	r3, [pc, #340]	; (80207e8 <_strerror_r+0x34c>)
 8020694:	e79b      	b.n	80205ce <_strerror_r+0x132>
 8020696:	4b55      	ldr	r3, [pc, #340]	; (80207ec <_strerror_r+0x350>)
 8020698:	e799      	b.n	80205ce <_strerror_r+0x132>
 802069a:	4b55      	ldr	r3, [pc, #340]	; (80207f0 <_strerror_r+0x354>)
 802069c:	e797      	b.n	80205ce <_strerror_r+0x132>
 802069e:	4b55      	ldr	r3, [pc, #340]	; (80207f4 <_strerror_r+0x358>)
 80206a0:	e795      	b.n	80205ce <_strerror_r+0x132>
 80206a2:	4b55      	ldr	r3, [pc, #340]	; (80207f8 <_strerror_r+0x35c>)
 80206a4:	e793      	b.n	80205ce <_strerror_r+0x132>
 80206a6:	4b55      	ldr	r3, [pc, #340]	; (80207fc <_strerror_r+0x360>)
 80206a8:	e791      	b.n	80205ce <_strerror_r+0x132>
 80206aa:	4b55      	ldr	r3, [pc, #340]	; (8020800 <_strerror_r+0x364>)
 80206ac:	e78f      	b.n	80205ce <_strerror_r+0x132>
 80206ae:	4b55      	ldr	r3, [pc, #340]	; (8020804 <_strerror_r+0x368>)
 80206b0:	e78d      	b.n	80205ce <_strerror_r+0x132>
 80206b2:	4b55      	ldr	r3, [pc, #340]	; (8020808 <_strerror_r+0x36c>)
 80206b4:	e78b      	b.n	80205ce <_strerror_r+0x132>
 80206b6:	4b55      	ldr	r3, [pc, #340]	; (802080c <_strerror_r+0x370>)
 80206b8:	e789      	b.n	80205ce <_strerror_r+0x132>
 80206ba:	4b55      	ldr	r3, [pc, #340]	; (8020810 <_strerror_r+0x374>)
 80206bc:	e787      	b.n	80205ce <_strerror_r+0x132>
 80206be:	4b55      	ldr	r3, [pc, #340]	; (8020814 <_strerror_r+0x378>)
 80206c0:	e785      	b.n	80205ce <_strerror_r+0x132>
 80206c2:	4b55      	ldr	r3, [pc, #340]	; (8020818 <_strerror_r+0x37c>)
 80206c4:	e783      	b.n	80205ce <_strerror_r+0x132>
 80206c6:	4b55      	ldr	r3, [pc, #340]	; (802081c <_strerror_r+0x380>)
 80206c8:	e781      	b.n	80205ce <_strerror_r+0x132>
 80206ca:	4b55      	ldr	r3, [pc, #340]	; (8020820 <_strerror_r+0x384>)
 80206cc:	e77f      	b.n	80205ce <_strerror_r+0x132>
 80206ce:	4b55      	ldr	r3, [pc, #340]	; (8020824 <_strerror_r+0x388>)
 80206d0:	e77d      	b.n	80205ce <_strerror_r+0x132>
 80206d2:	4b55      	ldr	r3, [pc, #340]	; (8020828 <_strerror_r+0x38c>)
 80206d4:	e77b      	b.n	80205ce <_strerror_r+0x132>
 80206d6:	4b55      	ldr	r3, [pc, #340]	; (802082c <_strerror_r+0x390>)
 80206d8:	e779      	b.n	80205ce <_strerror_r+0x132>
 80206da:	4b55      	ldr	r3, [pc, #340]	; (8020830 <_strerror_r+0x394>)
 80206dc:	e777      	b.n	80205ce <_strerror_r+0x132>
 80206de:	4b55      	ldr	r3, [pc, #340]	; (8020834 <_strerror_r+0x398>)
 80206e0:	e775      	b.n	80205ce <_strerror_r+0x132>
 80206e2:	4b55      	ldr	r3, [pc, #340]	; (8020838 <_strerror_r+0x39c>)
 80206e4:	e773      	b.n	80205ce <_strerror_r+0x132>
 80206e6:	4b55      	ldr	r3, [pc, #340]	; (802083c <_strerror_r+0x3a0>)
 80206e8:	e771      	b.n	80205ce <_strerror_r+0x132>
 80206ea:	4b55      	ldr	r3, [pc, #340]	; (8020840 <_strerror_r+0x3a4>)
 80206ec:	e76f      	b.n	80205ce <_strerror_r+0x132>
 80206ee:	4b55      	ldr	r3, [pc, #340]	; (8020844 <_strerror_r+0x3a8>)
 80206f0:	e76d      	b.n	80205ce <_strerror_r+0x132>
 80206f2:	4b55      	ldr	r3, [pc, #340]	; (8020848 <_strerror_r+0x3ac>)
 80206f4:	e76b      	b.n	80205ce <_strerror_r+0x132>
 80206f6:	4b55      	ldr	r3, [pc, #340]	; (802084c <_strerror_r+0x3b0>)
 80206f8:	e769      	b.n	80205ce <_strerror_r+0x132>
 80206fa:	4b55      	ldr	r3, [pc, #340]	; (8020850 <_strerror_r+0x3b4>)
 80206fc:	e767      	b.n	80205ce <_strerror_r+0x132>
 80206fe:	4b55      	ldr	r3, [pc, #340]	; (8020854 <_strerror_r+0x3b8>)
 8020700:	e765      	b.n	80205ce <_strerror_r+0x132>
 8020702:	4b55      	ldr	r3, [pc, #340]	; (8020858 <_strerror_r+0x3bc>)
 8020704:	e763      	b.n	80205ce <_strerror_r+0x132>
 8020706:	4b55      	ldr	r3, [pc, #340]	; (802085c <_strerror_r+0x3c0>)
 8020708:	e761      	b.n	80205ce <_strerror_r+0x132>
 802070a:	2b00      	cmp	r3, #0
 802070c:	bf14      	ite	ne
 802070e:	461a      	movne	r2, r3
 8020710:	4622      	moveq	r2, r4
 8020712:	f000 f981 	bl	8020a18 <_user_strerror>
 8020716:	4b52      	ldr	r3, [pc, #328]	; (8020860 <_strerror_r+0x3c4>)
 8020718:	2800      	cmp	r0, #0
 802071a:	bf18      	it	ne
 802071c:	4603      	movne	r3, r0
 802071e:	e756      	b.n	80205ce <_strerror_r+0x132>
 8020720:	4b50      	ldr	r3, [pc, #320]	; (8020864 <_strerror_r+0x3c8>)
 8020722:	e754      	b.n	80205ce <_strerror_r+0x132>
 8020724:	080289b5 	.word	0x080289b5
 8020728:	080289bf 	.word	0x080289bf
 802072c:	080289d9 	.word	0x080289d9
 8020730:	080289e9 	.word	0x080289e9
 8020734:	08028a01 	.word	0x08028a01
 8020738:	08028a0b 	.word	0x08028a0b
 802073c:	08028a25 	.word	0x08028a25
 8020740:	08028a37 	.word	0x08028a37
 8020744:	08028a49 	.word	0x08028a49
 8020748:	08028a62 	.word	0x08028a62
 802074c:	08028a72 	.word	0x08028a72
 8020750:	08028a7e 	.word	0x08028a7e
 8020754:	08028a9b 	.word	0x08028a9b
 8020758:	08028aad 	.word	0x08028aad
 802075c:	08028abe 	.word	0x08028abe
 8020760:	08028ad0 	.word	0x08028ad0
 8020764:	08028adc 	.word	0x08028adc
 8020768:	08028af4 	.word	0x08028af4
 802076c:	08028b00 	.word	0x08028b00
 8020770:	08028b12 	.word	0x08028b12
 8020774:	08028b21 	.word	0x08028b21
 8020778:	08028b31 	.word	0x08028b31
 802077c:	08028b3e 	.word	0x08028b3e
 8020780:	08028b5d 	.word	0x08028b5d
 8020784:	08028b6c 	.word	0x08028b6c
 8020788:	08028b7d 	.word	0x08028b7d
 802078c:	08028ba1 	.word	0x08028ba1
 8020790:	08028bbf 	.word	0x08028bbf
 8020794:	08028bdd 	.word	0x08028bdd
 8020798:	08028bfd 	.word	0x08028bfd
 802079c:	08028c14 	.word	0x08028c14
 80207a0:	08028c23 	.word	0x08028c23
 80207a4:	08028c32 	.word	0x08028c32
 80207a8:	08028c46 	.word	0x08028c46
 80207ac:	08028c5e 	.word	0x08028c5e
 80207b0:	08028c6c 	.word	0x08028c6c
 80207b4:	08028c79 	.word	0x08028c79
 80207b8:	08028c8f 	.word	0x08028c8f
 80207bc:	08028c9e 	.word	0x08028c9e
 80207c0:	08028caa 	.word	0x08028caa
 80207c4:	08028cd9 	.word	0x08028cd9
 80207c8:	08028cea 	.word	0x08028cea
 80207cc:	08028d05 	.word	0x08028d05
 80207d0:	08028d18 	.word	0x08028d18
 80207d4:	08028d2e 	.word	0x08028d2e
 80207d8:	08028d37 	.word	0x08028d37
 80207dc:	08028d4e 	.word	0x08028d4e
 80207e0:	08028d56 	.word	0x08028d56
 80207e4:	08028d63 	.word	0x08028d63
 80207e8:	08028d78 	.word	0x08028d78
 80207ec:	08028d8c 	.word	0x08028d8c
 80207f0:	08028da4 	.word	0x08028da4
 80207f4:	08028db3 	.word	0x08028db3
 80207f8:	08028dc4 	.word	0x08028dc4
 80207fc:	08028dd7 	.word	0x08028dd7
 8020800:	08028de3 	.word	0x08028de3
 8020804:	08028dfc 	.word	0x08028dfc
 8020808:	08028e10 	.word	0x08028e10
 802080c:	08028e2b 	.word	0x08028e2b
 8020810:	08028e43 	.word	0x08028e43
 8020814:	08028e5d 	.word	0x08028e5d
 8020818:	08028e65 	.word	0x08028e65
 802081c:	08028e95 	.word	0x08028e95
 8020820:	08028eb4 	.word	0x08028eb4
 8020824:	08028ed3 	.word	0x08028ed3
 8020828:	08028eea 	.word	0x08028eea
 802082c:	08028efd 	.word	0x08028efd
 8020830:	08028f16 	.word	0x08028f16
 8020834:	08028f2d 	.word	0x08028f2d
 8020838:	08028f43 	.word	0x08028f43
 802083c:	08028f64 	.word	0x08028f64
 8020840:	08028f7c 	.word	0x08028f7c
 8020844:	08028f98 	.word	0x08028f98
 8020848:	08028fab 	.word	0x08028fab
 802084c:	08028fc1 	.word	0x08028fc1
 8020850:	08028fd5 	.word	0x08028fd5
 8020854:	08028ff7 	.word	0x08028ff7
 8020858:	0802901d 	.word	0x0802901d
 802085c:	0802902e 	.word	0x0802902e
 8020860:	0802880a 	.word	0x0802880a
 8020864:	08029043 	.word	0x08029043

08020868 <strncasecmp>:
 8020868:	b570      	push	{r4, r5, r6, lr}
 802086a:	4e0f      	ldr	r6, [pc, #60]	; (80208a8 <strncasecmp+0x40>)
 802086c:	4604      	mov	r4, r0
 802086e:	440a      	add	r2, r1
 8020870:	428a      	cmp	r2, r1
 8020872:	d101      	bne.n	8020878 <strncasecmp+0x10>
 8020874:	2000      	movs	r0, #0
 8020876:	e013      	b.n	80208a0 <strncasecmp+0x38>
 8020878:	f814 3b01 	ldrb.w	r3, [r4], #1
 802087c:	5d98      	ldrb	r0, [r3, r6]
 802087e:	f000 0003 	and.w	r0, r0, #3
 8020882:	2801      	cmp	r0, #1
 8020884:	f811 0b01 	ldrb.w	r0, [r1], #1
 8020888:	5c35      	ldrb	r5, [r6, r0]
 802088a:	f005 0503 	and.w	r5, r5, #3
 802088e:	bf08      	it	eq
 8020890:	3320      	addeq	r3, #32
 8020892:	2d01      	cmp	r5, #1
 8020894:	bf08      	it	eq
 8020896:	3020      	addeq	r0, #32
 8020898:	1a1b      	subs	r3, r3, r0
 802089a:	d102      	bne.n	80208a2 <strncasecmp+0x3a>
 802089c:	2800      	cmp	r0, #0
 802089e:	d1e7      	bne.n	8020870 <strncasecmp+0x8>
 80208a0:	bd70      	pop	{r4, r5, r6, pc}
 80208a2:	4618      	mov	r0, r3
 80208a4:	e7fc      	b.n	80208a0 <strncasecmp+0x38>
 80208a6:	bf00      	nop
 80208a8:	0802880c 	.word	0x0802880c

080208ac <strncmp>:
 80208ac:	b510      	push	{r4, lr}
 80208ae:	b17a      	cbz	r2, 80208d0 <strncmp+0x24>
 80208b0:	4603      	mov	r3, r0
 80208b2:	3901      	subs	r1, #1
 80208b4:	1884      	adds	r4, r0, r2
 80208b6:	f813 0b01 	ldrb.w	r0, [r3], #1
 80208ba:	f811 2f01 	ldrb.w	r2, [r1, #1]!
 80208be:	4290      	cmp	r0, r2
 80208c0:	d101      	bne.n	80208c6 <strncmp+0x1a>
 80208c2:	42a3      	cmp	r3, r4
 80208c4:	d101      	bne.n	80208ca <strncmp+0x1e>
 80208c6:	1a80      	subs	r0, r0, r2
 80208c8:	bd10      	pop	{r4, pc}
 80208ca:	2800      	cmp	r0, #0
 80208cc:	d1f3      	bne.n	80208b6 <strncmp+0xa>
 80208ce:	e7fa      	b.n	80208c6 <strncmp+0x1a>
 80208d0:	4610      	mov	r0, r2
 80208d2:	e7f9      	b.n	80208c8 <strncmp+0x1c>

080208d4 <strncpy>:
 80208d4:	b510      	push	{r4, lr}
 80208d6:	3901      	subs	r1, #1
 80208d8:	4603      	mov	r3, r0
 80208da:	b132      	cbz	r2, 80208ea <strncpy+0x16>
 80208dc:	f811 4f01 	ldrb.w	r4, [r1, #1]!
 80208e0:	f803 4b01 	strb.w	r4, [r3], #1
 80208e4:	3a01      	subs	r2, #1
 80208e6:	2c00      	cmp	r4, #0
 80208e8:	d1f7      	bne.n	80208da <strncpy+0x6>
 80208ea:	441a      	add	r2, r3
 80208ec:	2100      	movs	r1, #0
 80208ee:	4293      	cmp	r3, r2
 80208f0:	d100      	bne.n	80208f4 <strncpy+0x20>
 80208f2:	bd10      	pop	{r4, pc}
 80208f4:	f803 1b01 	strb.w	r1, [r3], #1
 80208f8:	e7f9      	b.n	80208ee <strncpy+0x1a>
	...

080208fc <_strtol_l.constprop.0>:
 80208fc:	2b01      	cmp	r3, #1
 80208fe:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 8020902:	d001      	beq.n	8020908 <_strtol_l.constprop.0+0xc>
 8020904:	2b24      	cmp	r3, #36	; 0x24
 8020906:	d906      	bls.n	8020916 <_strtol_l.constprop.0+0x1a>
 8020908:	f7fe ff44 	bl	801f794 <__errno>
 802090c:	2316      	movs	r3, #22
 802090e:	6003      	str	r3, [r0, #0]
 8020910:	2000      	movs	r0, #0
 8020912:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8020916:	f8df c0e4 	ldr.w	ip, [pc, #228]	; 80209fc <_strtol_l.constprop.0+0x100>
 802091a:	460d      	mov	r5, r1
 802091c:	462e      	mov	r6, r5
 802091e:	f815 4b01 	ldrb.w	r4, [r5], #1
 8020922:	f814 700c 	ldrb.w	r7, [r4, ip]
 8020926:	f017 0708 	ands.w	r7, r7, #8
 802092a:	d1f7      	bne.n	802091c <_strtol_l.constprop.0+0x20>
 802092c:	2c2d      	cmp	r4, #45	; 0x2d
 802092e:	d132      	bne.n	8020996 <_strtol_l.constprop.0+0x9a>
 8020930:	782c      	ldrb	r4, [r5, #0]
 8020932:	2701      	movs	r7, #1
 8020934:	1cb5      	adds	r5, r6, #2
 8020936:	2b00      	cmp	r3, #0
 8020938:	d05b      	beq.n	80209f2 <_strtol_l.constprop.0+0xf6>
 802093a:	2b10      	cmp	r3, #16
 802093c:	d109      	bne.n	8020952 <_strtol_l.constprop.0+0x56>
 802093e:	2c30      	cmp	r4, #48	; 0x30
 8020940:	d107      	bne.n	8020952 <_strtol_l.constprop.0+0x56>
 8020942:	782c      	ldrb	r4, [r5, #0]
 8020944:	f004 04df 	and.w	r4, r4, #223	; 0xdf
 8020948:	2c58      	cmp	r4, #88	; 0x58
 802094a:	d14d      	bne.n	80209e8 <_strtol_l.constprop.0+0xec>
 802094c:	786c      	ldrb	r4, [r5, #1]
 802094e:	2310      	movs	r3, #16
 8020950:	3502      	adds	r5, #2
 8020952:	f107 4800 	add.w	r8, r7, #2147483648	; 0x80000000
 8020956:	f108 38ff 	add.w	r8, r8, #4294967295
 802095a:	f04f 0c00 	mov.w	ip, #0
 802095e:	fbb8 f9f3 	udiv	r9, r8, r3
 8020962:	4666      	mov	r6, ip
 8020964:	fb03 8a19 	mls	sl, r3, r9, r8
 8020968:	f1a4 0e30 	sub.w	lr, r4, #48	; 0x30
 802096c:	f1be 0f09 	cmp.w	lr, #9
 8020970:	d816      	bhi.n	80209a0 <_strtol_l.constprop.0+0xa4>
 8020972:	4674      	mov	r4, lr
 8020974:	42a3      	cmp	r3, r4
 8020976:	dd24      	ble.n	80209c2 <_strtol_l.constprop.0+0xc6>
 8020978:	f1bc 0f00 	cmp.w	ip, #0
 802097c:	db1e      	blt.n	80209bc <_strtol_l.constprop.0+0xc0>
 802097e:	45b1      	cmp	r9, r6
 8020980:	d31c      	bcc.n	80209bc <_strtol_l.constprop.0+0xc0>
 8020982:	d101      	bne.n	8020988 <_strtol_l.constprop.0+0x8c>
 8020984:	45a2      	cmp	sl, r4
 8020986:	db19      	blt.n	80209bc <_strtol_l.constprop.0+0xc0>
 8020988:	fb06 4603 	mla	r6, r6, r3, r4
 802098c:	f04f 0c01 	mov.w	ip, #1
 8020990:	f815 4b01 	ldrb.w	r4, [r5], #1
 8020994:	e7e8      	b.n	8020968 <_strtol_l.constprop.0+0x6c>
 8020996:	2c2b      	cmp	r4, #43	; 0x2b
 8020998:	bf04      	itt	eq
 802099a:	782c      	ldrbeq	r4, [r5, #0]
 802099c:	1cb5      	addeq	r5, r6, #2
 802099e:	e7ca      	b.n	8020936 <_strtol_l.constprop.0+0x3a>
 80209a0:	f1a4 0e41 	sub.w	lr, r4, #65	; 0x41
 80209a4:	f1be 0f19 	cmp.w	lr, #25
 80209a8:	d801      	bhi.n	80209ae <_strtol_l.constprop.0+0xb2>
 80209aa:	3c37      	subs	r4, #55	; 0x37
 80209ac:	e7e2      	b.n	8020974 <_strtol_l.constprop.0+0x78>
 80209ae:	f1a4 0e61 	sub.w	lr, r4, #97	; 0x61
 80209b2:	f1be 0f19 	cmp.w	lr, #25
 80209b6:	d804      	bhi.n	80209c2 <_strtol_l.constprop.0+0xc6>
 80209b8:	3c57      	subs	r4, #87	; 0x57
 80209ba:	e7db      	b.n	8020974 <_strtol_l.constprop.0+0x78>
 80209bc:	f04f 3cff 	mov.w	ip, #4294967295
 80209c0:	e7e6      	b.n	8020990 <_strtol_l.constprop.0+0x94>
 80209c2:	f1bc 0f00 	cmp.w	ip, #0
 80209c6:	da05      	bge.n	80209d4 <_strtol_l.constprop.0+0xd8>
 80209c8:	2322      	movs	r3, #34	; 0x22
 80209ca:	6003      	str	r3, [r0, #0]
 80209cc:	4646      	mov	r6, r8
 80209ce:	b942      	cbnz	r2, 80209e2 <_strtol_l.constprop.0+0xe6>
 80209d0:	4630      	mov	r0, r6
 80209d2:	e79e      	b.n	8020912 <_strtol_l.constprop.0+0x16>
 80209d4:	b107      	cbz	r7, 80209d8 <_strtol_l.constprop.0+0xdc>
 80209d6:	4276      	negs	r6, r6
 80209d8:	2a00      	cmp	r2, #0
 80209da:	d0f9      	beq.n	80209d0 <_strtol_l.constprop.0+0xd4>
 80209dc:	f1bc 0f00 	cmp.w	ip, #0
 80209e0:	d000      	beq.n	80209e4 <_strtol_l.constprop.0+0xe8>
 80209e2:	1e69      	subs	r1, r5, #1
 80209e4:	6011      	str	r1, [r2, #0]
 80209e6:	e7f3      	b.n	80209d0 <_strtol_l.constprop.0+0xd4>
 80209e8:	2430      	movs	r4, #48	; 0x30
 80209ea:	2b00      	cmp	r3, #0
 80209ec:	d1b1      	bne.n	8020952 <_strtol_l.constprop.0+0x56>
 80209ee:	2308      	movs	r3, #8
 80209f0:	e7af      	b.n	8020952 <_strtol_l.constprop.0+0x56>
 80209f2:	2c30      	cmp	r4, #48	; 0x30
 80209f4:	d0a5      	beq.n	8020942 <_strtol_l.constprop.0+0x46>
 80209f6:	230a      	movs	r3, #10
 80209f8:	e7ab      	b.n	8020952 <_strtol_l.constprop.0+0x56>
 80209fa:	bf00      	nop
 80209fc:	0802880c 	.word	0x0802880c

08020a00 <_strtol_r>:
 8020a00:	f7ff bf7c 	b.w	80208fc <_strtol_l.constprop.0>

08020a04 <strtol>:
 8020a04:	4613      	mov	r3, r2
 8020a06:	460a      	mov	r2, r1
 8020a08:	4601      	mov	r1, r0
 8020a0a:	4802      	ldr	r0, [pc, #8]	; (8020a14 <strtol+0x10>)
 8020a0c:	6800      	ldr	r0, [r0, #0]
 8020a0e:	f7ff bf75 	b.w	80208fc <_strtol_l.constprop.0>
 8020a12:	bf00      	nop
 8020a14:	240004a4 	.word	0x240004a4

08020a18 <_user_strerror>:
 8020a18:	2000      	movs	r0, #0
 8020a1a:	4770      	bx	lr

08020a1c <__swbuf_r>:
 8020a1c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8020a1e:	460e      	mov	r6, r1
 8020a20:	4614      	mov	r4, r2
 8020a22:	4605      	mov	r5, r0
 8020a24:	b118      	cbz	r0, 8020a2e <__swbuf_r+0x12>
 8020a26:	6983      	ldr	r3, [r0, #24]
 8020a28:	b90b      	cbnz	r3, 8020a2e <__swbuf_r+0x12>
 8020a2a:	f000 fa39 	bl	8020ea0 <__sinit>
 8020a2e:	4b21      	ldr	r3, [pc, #132]	; (8020ab4 <__swbuf_r+0x98>)
 8020a30:	429c      	cmp	r4, r3
 8020a32:	d12b      	bne.n	8020a8c <__swbuf_r+0x70>
 8020a34:	686c      	ldr	r4, [r5, #4]
 8020a36:	69a3      	ldr	r3, [r4, #24]
 8020a38:	60a3      	str	r3, [r4, #8]
 8020a3a:	89a3      	ldrh	r3, [r4, #12]
 8020a3c:	071a      	lsls	r2, r3, #28
 8020a3e:	d52f      	bpl.n	8020aa0 <__swbuf_r+0x84>
 8020a40:	6923      	ldr	r3, [r4, #16]
 8020a42:	b36b      	cbz	r3, 8020aa0 <__swbuf_r+0x84>
 8020a44:	6923      	ldr	r3, [r4, #16]
 8020a46:	6820      	ldr	r0, [r4, #0]
 8020a48:	1ac0      	subs	r0, r0, r3
 8020a4a:	6963      	ldr	r3, [r4, #20]
 8020a4c:	b2f6      	uxtb	r6, r6
 8020a4e:	4283      	cmp	r3, r0
 8020a50:	4637      	mov	r7, r6
 8020a52:	dc04      	bgt.n	8020a5e <__swbuf_r+0x42>
 8020a54:	4621      	mov	r1, r4
 8020a56:	4628      	mov	r0, r5
 8020a58:	f000 f950 	bl	8020cfc <_fflush_r>
 8020a5c:	bb30      	cbnz	r0, 8020aac <__swbuf_r+0x90>
 8020a5e:	68a3      	ldr	r3, [r4, #8]
 8020a60:	3b01      	subs	r3, #1
 8020a62:	60a3      	str	r3, [r4, #8]
 8020a64:	6823      	ldr	r3, [r4, #0]
 8020a66:	1c5a      	adds	r2, r3, #1
 8020a68:	6022      	str	r2, [r4, #0]
 8020a6a:	701e      	strb	r6, [r3, #0]
 8020a6c:	6963      	ldr	r3, [r4, #20]
 8020a6e:	3001      	adds	r0, #1
 8020a70:	4283      	cmp	r3, r0
 8020a72:	d004      	beq.n	8020a7e <__swbuf_r+0x62>
 8020a74:	89a3      	ldrh	r3, [r4, #12]
 8020a76:	07db      	lsls	r3, r3, #31
 8020a78:	d506      	bpl.n	8020a88 <__swbuf_r+0x6c>
 8020a7a:	2e0a      	cmp	r6, #10
 8020a7c:	d104      	bne.n	8020a88 <__swbuf_r+0x6c>
 8020a7e:	4621      	mov	r1, r4
 8020a80:	4628      	mov	r0, r5
 8020a82:	f000 f93b 	bl	8020cfc <_fflush_r>
 8020a86:	b988      	cbnz	r0, 8020aac <__swbuf_r+0x90>
 8020a88:	4638      	mov	r0, r7
 8020a8a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8020a8c:	4b0a      	ldr	r3, [pc, #40]	; (8020ab8 <__swbuf_r+0x9c>)
 8020a8e:	429c      	cmp	r4, r3
 8020a90:	d101      	bne.n	8020a96 <__swbuf_r+0x7a>
 8020a92:	68ac      	ldr	r4, [r5, #8]
 8020a94:	e7cf      	b.n	8020a36 <__swbuf_r+0x1a>
 8020a96:	4b09      	ldr	r3, [pc, #36]	; (8020abc <__swbuf_r+0xa0>)
 8020a98:	429c      	cmp	r4, r3
 8020a9a:	bf08      	it	eq
 8020a9c:	68ec      	ldreq	r4, [r5, #12]
 8020a9e:	e7ca      	b.n	8020a36 <__swbuf_r+0x1a>
 8020aa0:	4621      	mov	r1, r4
 8020aa2:	4628      	mov	r0, r5
 8020aa4:	f000 f81e 	bl	8020ae4 <__swsetup_r>
 8020aa8:	2800      	cmp	r0, #0
 8020aaa:	d0cb      	beq.n	8020a44 <__swbuf_r+0x28>
 8020aac:	f04f 37ff 	mov.w	r7, #4294967295
 8020ab0:	e7ea      	b.n	8020a88 <__swbuf_r+0x6c>
 8020ab2:	bf00      	nop
 8020ab4:	0802906c 	.word	0x0802906c
 8020ab8:	0802908c 	.word	0x0802908c
 8020abc:	0802904c 	.word	0x0802904c

08020ac0 <_write_r>:
 8020ac0:	b538      	push	{r3, r4, r5, lr}
 8020ac2:	4d07      	ldr	r5, [pc, #28]	; (8020ae0 <_write_r+0x20>)
 8020ac4:	4604      	mov	r4, r0
 8020ac6:	4608      	mov	r0, r1
 8020ac8:	4611      	mov	r1, r2
 8020aca:	2200      	movs	r2, #0
 8020acc:	602a      	str	r2, [r5, #0]
 8020ace:	461a      	mov	r2, r3
 8020ad0:	f7e0 fbbb 	bl	800124a <_write>
 8020ad4:	1c43      	adds	r3, r0, #1
 8020ad6:	d102      	bne.n	8020ade <_write_r+0x1e>
 8020ad8:	682b      	ldr	r3, [r5, #0]
 8020ada:	b103      	cbz	r3, 8020ade <_write_r+0x1e>
 8020adc:	6023      	str	r3, [r4, #0]
 8020ade:	bd38      	pop	{r3, r4, r5, pc}
 8020ae0:	2404d0bc 	.word	0x2404d0bc

08020ae4 <__swsetup_r>:
 8020ae4:	4b32      	ldr	r3, [pc, #200]	; (8020bb0 <__swsetup_r+0xcc>)
 8020ae6:	b570      	push	{r4, r5, r6, lr}
 8020ae8:	681d      	ldr	r5, [r3, #0]
 8020aea:	4606      	mov	r6, r0
 8020aec:	460c      	mov	r4, r1
 8020aee:	b125      	cbz	r5, 8020afa <__swsetup_r+0x16>
 8020af0:	69ab      	ldr	r3, [r5, #24]
 8020af2:	b913      	cbnz	r3, 8020afa <__swsetup_r+0x16>
 8020af4:	4628      	mov	r0, r5
 8020af6:	f000 f9d3 	bl	8020ea0 <__sinit>
 8020afa:	4b2e      	ldr	r3, [pc, #184]	; (8020bb4 <__swsetup_r+0xd0>)
 8020afc:	429c      	cmp	r4, r3
 8020afe:	d10f      	bne.n	8020b20 <__swsetup_r+0x3c>
 8020b00:	686c      	ldr	r4, [r5, #4]
 8020b02:	89a3      	ldrh	r3, [r4, #12]
 8020b04:	f9b4 200c 	ldrsh.w	r2, [r4, #12]
 8020b08:	0719      	lsls	r1, r3, #28
 8020b0a:	d42c      	bmi.n	8020b66 <__swsetup_r+0x82>
 8020b0c:	06dd      	lsls	r5, r3, #27
 8020b0e:	d411      	bmi.n	8020b34 <__swsetup_r+0x50>
 8020b10:	2309      	movs	r3, #9
 8020b12:	6033      	str	r3, [r6, #0]
 8020b14:	f042 0340 	orr.w	r3, r2, #64	; 0x40
 8020b18:	81a3      	strh	r3, [r4, #12]
 8020b1a:	f04f 30ff 	mov.w	r0, #4294967295
 8020b1e:	e03e      	b.n	8020b9e <__swsetup_r+0xba>
 8020b20:	4b25      	ldr	r3, [pc, #148]	; (8020bb8 <__swsetup_r+0xd4>)
 8020b22:	429c      	cmp	r4, r3
 8020b24:	d101      	bne.n	8020b2a <__swsetup_r+0x46>
 8020b26:	68ac      	ldr	r4, [r5, #8]
 8020b28:	e7eb      	b.n	8020b02 <__swsetup_r+0x1e>
 8020b2a:	4b24      	ldr	r3, [pc, #144]	; (8020bbc <__swsetup_r+0xd8>)
 8020b2c:	429c      	cmp	r4, r3
 8020b2e:	bf08      	it	eq
 8020b30:	68ec      	ldreq	r4, [r5, #12]
 8020b32:	e7e6      	b.n	8020b02 <__swsetup_r+0x1e>
 8020b34:	0758      	lsls	r0, r3, #29
 8020b36:	d512      	bpl.n	8020b5e <__swsetup_r+0x7a>
 8020b38:	6b61      	ldr	r1, [r4, #52]	; 0x34
 8020b3a:	b141      	cbz	r1, 8020b4e <__swsetup_r+0x6a>
 8020b3c:	f104 0344 	add.w	r3, r4, #68	; 0x44
 8020b40:	4299      	cmp	r1, r3
 8020b42:	d002      	beq.n	8020b4a <__swsetup_r+0x66>
 8020b44:	4630      	mov	r0, r6
 8020b46:	f7fe fea1 	bl	801f88c <_free_r>
 8020b4a:	2300      	movs	r3, #0
 8020b4c:	6363      	str	r3, [r4, #52]	; 0x34
 8020b4e:	89a3      	ldrh	r3, [r4, #12]
 8020b50:	f023 0324 	bic.w	r3, r3, #36	; 0x24
 8020b54:	81a3      	strh	r3, [r4, #12]
 8020b56:	2300      	movs	r3, #0
 8020b58:	6063      	str	r3, [r4, #4]
 8020b5a:	6923      	ldr	r3, [r4, #16]
 8020b5c:	6023      	str	r3, [r4, #0]
 8020b5e:	89a3      	ldrh	r3, [r4, #12]
 8020b60:	f043 0308 	orr.w	r3, r3, #8
 8020b64:	81a3      	strh	r3, [r4, #12]
 8020b66:	6923      	ldr	r3, [r4, #16]
 8020b68:	b94b      	cbnz	r3, 8020b7e <__swsetup_r+0x9a>
 8020b6a:	89a3      	ldrh	r3, [r4, #12]
 8020b6c:	f403 7320 	and.w	r3, r3, #640	; 0x280
 8020b70:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
 8020b74:	d003      	beq.n	8020b7e <__swsetup_r+0x9a>
 8020b76:	4621      	mov	r1, r4
 8020b78:	4630      	mov	r0, r6
 8020b7a:	f000 fa67 	bl	802104c <__smakebuf_r>
 8020b7e:	89a0      	ldrh	r0, [r4, #12]
 8020b80:	f9b4 200c 	ldrsh.w	r2, [r4, #12]
 8020b84:	f010 0301 	ands.w	r3, r0, #1
 8020b88:	d00a      	beq.n	8020ba0 <__swsetup_r+0xbc>
 8020b8a:	2300      	movs	r3, #0
 8020b8c:	60a3      	str	r3, [r4, #8]
 8020b8e:	6963      	ldr	r3, [r4, #20]
 8020b90:	425b      	negs	r3, r3
 8020b92:	61a3      	str	r3, [r4, #24]
 8020b94:	6923      	ldr	r3, [r4, #16]
 8020b96:	b943      	cbnz	r3, 8020baa <__swsetup_r+0xc6>
 8020b98:	f010 0080 	ands.w	r0, r0, #128	; 0x80
 8020b9c:	d1ba      	bne.n	8020b14 <__swsetup_r+0x30>
 8020b9e:	bd70      	pop	{r4, r5, r6, pc}
 8020ba0:	0781      	lsls	r1, r0, #30
 8020ba2:	bf58      	it	pl
 8020ba4:	6963      	ldrpl	r3, [r4, #20]
 8020ba6:	60a3      	str	r3, [r4, #8]
 8020ba8:	e7f4      	b.n	8020b94 <__swsetup_r+0xb0>
 8020baa:	2000      	movs	r0, #0
 8020bac:	e7f7      	b.n	8020b9e <__swsetup_r+0xba>
 8020bae:	bf00      	nop
 8020bb0:	240004a4 	.word	0x240004a4
 8020bb4:	0802906c 	.word	0x0802906c
 8020bb8:	0802908c 	.word	0x0802908c
 8020bbc:	0802904c 	.word	0x0802904c

08020bc0 <abort>:
 8020bc0:	b508      	push	{r3, lr}
 8020bc2:	2006      	movs	r0, #6
 8020bc4:	f000 fff6 	bl	8021bb4 <raise>
 8020bc8:	2001      	movs	r0, #1
 8020bca:	f7e0 fb17 	bl	80011fc <_exit>
	...

08020bd0 <_close_r>:
 8020bd0:	b538      	push	{r3, r4, r5, lr}
 8020bd2:	4d06      	ldr	r5, [pc, #24]	; (8020bec <_close_r+0x1c>)
 8020bd4:	2300      	movs	r3, #0
 8020bd6:	4604      	mov	r4, r0
 8020bd8:	4608      	mov	r0, r1
 8020bda:	602b      	str	r3, [r5, #0]
 8020bdc:	f7e0 fb51 	bl	8001282 <_close>
 8020be0:	1c43      	adds	r3, r0, #1
 8020be2:	d102      	bne.n	8020bea <_close_r+0x1a>
 8020be4:	682b      	ldr	r3, [r5, #0]
 8020be6:	b103      	cbz	r3, 8020bea <_close_r+0x1a>
 8020be8:	6023      	str	r3, [r4, #0]
 8020bea:	bd38      	pop	{r3, r4, r5, pc}
 8020bec:	2404d0bc 	.word	0x2404d0bc

08020bf0 <__sflush_r>:
 8020bf0:	898a      	ldrh	r2, [r1, #12]
 8020bf2:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8020bf6:	4605      	mov	r5, r0
 8020bf8:	0710      	lsls	r0, r2, #28
 8020bfa:	460c      	mov	r4, r1
 8020bfc:	d458      	bmi.n	8020cb0 <__sflush_r+0xc0>
 8020bfe:	684b      	ldr	r3, [r1, #4]
 8020c00:	2b00      	cmp	r3, #0
 8020c02:	dc05      	bgt.n	8020c10 <__sflush_r+0x20>
 8020c04:	6c0b      	ldr	r3, [r1, #64]	; 0x40
 8020c06:	2b00      	cmp	r3, #0
 8020c08:	dc02      	bgt.n	8020c10 <__sflush_r+0x20>
 8020c0a:	2000      	movs	r0, #0
 8020c0c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8020c10:	6ae6      	ldr	r6, [r4, #44]	; 0x2c
 8020c12:	2e00      	cmp	r6, #0
 8020c14:	d0f9      	beq.n	8020c0a <__sflush_r+0x1a>
 8020c16:	2300      	movs	r3, #0
 8020c18:	f412 5280 	ands.w	r2, r2, #4096	; 0x1000
 8020c1c:	682f      	ldr	r7, [r5, #0]
 8020c1e:	602b      	str	r3, [r5, #0]
 8020c20:	d032      	beq.n	8020c88 <__sflush_r+0x98>
 8020c22:	6d60      	ldr	r0, [r4, #84]	; 0x54
 8020c24:	89a3      	ldrh	r3, [r4, #12]
 8020c26:	075a      	lsls	r2, r3, #29
 8020c28:	d505      	bpl.n	8020c36 <__sflush_r+0x46>
 8020c2a:	6863      	ldr	r3, [r4, #4]
 8020c2c:	1ac0      	subs	r0, r0, r3
 8020c2e:	6b63      	ldr	r3, [r4, #52]	; 0x34
 8020c30:	b10b      	cbz	r3, 8020c36 <__sflush_r+0x46>
 8020c32:	6c23      	ldr	r3, [r4, #64]	; 0x40
 8020c34:	1ac0      	subs	r0, r0, r3
 8020c36:	2300      	movs	r3, #0
 8020c38:	4602      	mov	r2, r0
 8020c3a:	6ae6      	ldr	r6, [r4, #44]	; 0x2c
 8020c3c:	6a21      	ldr	r1, [r4, #32]
 8020c3e:	4628      	mov	r0, r5
 8020c40:	47b0      	blx	r6
 8020c42:	1c43      	adds	r3, r0, #1
 8020c44:	89a3      	ldrh	r3, [r4, #12]
 8020c46:	d106      	bne.n	8020c56 <__sflush_r+0x66>
 8020c48:	6829      	ldr	r1, [r5, #0]
 8020c4a:	291d      	cmp	r1, #29
 8020c4c:	d82c      	bhi.n	8020ca8 <__sflush_r+0xb8>
 8020c4e:	4a2a      	ldr	r2, [pc, #168]	; (8020cf8 <__sflush_r+0x108>)
 8020c50:	40ca      	lsrs	r2, r1
 8020c52:	07d6      	lsls	r6, r2, #31
 8020c54:	d528      	bpl.n	8020ca8 <__sflush_r+0xb8>
 8020c56:	2200      	movs	r2, #0
 8020c58:	6062      	str	r2, [r4, #4]
 8020c5a:	04d9      	lsls	r1, r3, #19
 8020c5c:	6922      	ldr	r2, [r4, #16]
 8020c5e:	6022      	str	r2, [r4, #0]
 8020c60:	d504      	bpl.n	8020c6c <__sflush_r+0x7c>
 8020c62:	1c42      	adds	r2, r0, #1
 8020c64:	d101      	bne.n	8020c6a <__sflush_r+0x7a>
 8020c66:	682b      	ldr	r3, [r5, #0]
 8020c68:	b903      	cbnz	r3, 8020c6c <__sflush_r+0x7c>
 8020c6a:	6560      	str	r0, [r4, #84]	; 0x54
 8020c6c:	6b61      	ldr	r1, [r4, #52]	; 0x34
 8020c6e:	602f      	str	r7, [r5, #0]
 8020c70:	2900      	cmp	r1, #0
 8020c72:	d0ca      	beq.n	8020c0a <__sflush_r+0x1a>
 8020c74:	f104 0344 	add.w	r3, r4, #68	; 0x44
 8020c78:	4299      	cmp	r1, r3
 8020c7a:	d002      	beq.n	8020c82 <__sflush_r+0x92>
 8020c7c:	4628      	mov	r0, r5
 8020c7e:	f7fe fe05 	bl	801f88c <_free_r>
 8020c82:	2000      	movs	r0, #0
 8020c84:	6360      	str	r0, [r4, #52]	; 0x34
 8020c86:	e7c1      	b.n	8020c0c <__sflush_r+0x1c>
 8020c88:	6a21      	ldr	r1, [r4, #32]
 8020c8a:	2301      	movs	r3, #1
 8020c8c:	4628      	mov	r0, r5
 8020c8e:	47b0      	blx	r6
 8020c90:	1c41      	adds	r1, r0, #1
 8020c92:	d1c7      	bne.n	8020c24 <__sflush_r+0x34>
 8020c94:	682b      	ldr	r3, [r5, #0]
 8020c96:	2b00      	cmp	r3, #0
 8020c98:	d0c4      	beq.n	8020c24 <__sflush_r+0x34>
 8020c9a:	2b1d      	cmp	r3, #29
 8020c9c:	d001      	beq.n	8020ca2 <__sflush_r+0xb2>
 8020c9e:	2b16      	cmp	r3, #22
 8020ca0:	d101      	bne.n	8020ca6 <__sflush_r+0xb6>
 8020ca2:	602f      	str	r7, [r5, #0]
 8020ca4:	e7b1      	b.n	8020c0a <__sflush_r+0x1a>
 8020ca6:	89a3      	ldrh	r3, [r4, #12]
 8020ca8:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 8020cac:	81a3      	strh	r3, [r4, #12]
 8020cae:	e7ad      	b.n	8020c0c <__sflush_r+0x1c>
 8020cb0:	690f      	ldr	r7, [r1, #16]
 8020cb2:	2f00      	cmp	r7, #0
 8020cb4:	d0a9      	beq.n	8020c0a <__sflush_r+0x1a>
 8020cb6:	0793      	lsls	r3, r2, #30
 8020cb8:	680e      	ldr	r6, [r1, #0]
 8020cba:	bf08      	it	eq
 8020cbc:	694b      	ldreq	r3, [r1, #20]
 8020cbe:	600f      	str	r7, [r1, #0]
 8020cc0:	bf18      	it	ne
 8020cc2:	2300      	movne	r3, #0
 8020cc4:	eba6 0807 	sub.w	r8, r6, r7
 8020cc8:	608b      	str	r3, [r1, #8]
 8020cca:	f1b8 0f00 	cmp.w	r8, #0
 8020cce:	dd9c      	ble.n	8020c0a <__sflush_r+0x1a>
 8020cd0:	6a21      	ldr	r1, [r4, #32]
 8020cd2:	6aa6      	ldr	r6, [r4, #40]	; 0x28
 8020cd4:	4643      	mov	r3, r8
 8020cd6:	463a      	mov	r2, r7
 8020cd8:	4628      	mov	r0, r5
 8020cda:	47b0      	blx	r6
 8020cdc:	2800      	cmp	r0, #0
 8020cde:	dc06      	bgt.n	8020cee <__sflush_r+0xfe>
 8020ce0:	89a3      	ldrh	r3, [r4, #12]
 8020ce2:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 8020ce6:	81a3      	strh	r3, [r4, #12]
 8020ce8:	f04f 30ff 	mov.w	r0, #4294967295
 8020cec:	e78e      	b.n	8020c0c <__sflush_r+0x1c>
 8020cee:	4407      	add	r7, r0
 8020cf0:	eba8 0800 	sub.w	r8, r8, r0
 8020cf4:	e7e9      	b.n	8020cca <__sflush_r+0xda>
 8020cf6:	bf00      	nop
 8020cf8:	20400001 	.word	0x20400001

08020cfc <_fflush_r>:
 8020cfc:	b538      	push	{r3, r4, r5, lr}
 8020cfe:	690b      	ldr	r3, [r1, #16]
 8020d00:	4605      	mov	r5, r0
 8020d02:	460c      	mov	r4, r1
 8020d04:	b913      	cbnz	r3, 8020d0c <_fflush_r+0x10>
 8020d06:	2500      	movs	r5, #0
 8020d08:	4628      	mov	r0, r5
 8020d0a:	bd38      	pop	{r3, r4, r5, pc}
 8020d0c:	b118      	cbz	r0, 8020d16 <_fflush_r+0x1a>
 8020d0e:	6983      	ldr	r3, [r0, #24]
 8020d10:	b90b      	cbnz	r3, 8020d16 <_fflush_r+0x1a>
 8020d12:	f000 f8c5 	bl	8020ea0 <__sinit>
 8020d16:	4b14      	ldr	r3, [pc, #80]	; (8020d68 <_fflush_r+0x6c>)
 8020d18:	429c      	cmp	r4, r3
 8020d1a:	d11b      	bne.n	8020d54 <_fflush_r+0x58>
 8020d1c:	686c      	ldr	r4, [r5, #4]
 8020d1e:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
 8020d22:	2b00      	cmp	r3, #0
 8020d24:	d0ef      	beq.n	8020d06 <_fflush_r+0xa>
 8020d26:	6e62      	ldr	r2, [r4, #100]	; 0x64
 8020d28:	07d0      	lsls	r0, r2, #31
 8020d2a:	d404      	bmi.n	8020d36 <_fflush_r+0x3a>
 8020d2c:	0599      	lsls	r1, r3, #22
 8020d2e:	d402      	bmi.n	8020d36 <_fflush_r+0x3a>
 8020d30:	6da0      	ldr	r0, [r4, #88]	; 0x58
 8020d32:	f7e0 fc88 	bl	8001646 <__retarget_lock_acquire_recursive>
 8020d36:	4628      	mov	r0, r5
 8020d38:	4621      	mov	r1, r4
 8020d3a:	f7ff ff59 	bl	8020bf0 <__sflush_r>
 8020d3e:	6e63      	ldr	r3, [r4, #100]	; 0x64
 8020d40:	07da      	lsls	r2, r3, #31
 8020d42:	4605      	mov	r5, r0
 8020d44:	d4e0      	bmi.n	8020d08 <_fflush_r+0xc>
 8020d46:	89a3      	ldrh	r3, [r4, #12]
 8020d48:	059b      	lsls	r3, r3, #22
 8020d4a:	d4dd      	bmi.n	8020d08 <_fflush_r+0xc>
 8020d4c:	6da0      	ldr	r0, [r4, #88]	; 0x58
 8020d4e:	f7e0 fc8e 	bl	800166e <__retarget_lock_release_recursive>
 8020d52:	e7d9      	b.n	8020d08 <_fflush_r+0xc>
 8020d54:	4b05      	ldr	r3, [pc, #20]	; (8020d6c <_fflush_r+0x70>)
 8020d56:	429c      	cmp	r4, r3
 8020d58:	d101      	bne.n	8020d5e <_fflush_r+0x62>
 8020d5a:	68ac      	ldr	r4, [r5, #8]
 8020d5c:	e7df      	b.n	8020d1e <_fflush_r+0x22>
 8020d5e:	4b04      	ldr	r3, [pc, #16]	; (8020d70 <_fflush_r+0x74>)
 8020d60:	429c      	cmp	r4, r3
 8020d62:	bf08      	it	eq
 8020d64:	68ec      	ldreq	r4, [r5, #12]
 8020d66:	e7da      	b.n	8020d1e <_fflush_r+0x22>
 8020d68:	0802906c 	.word	0x0802906c
 8020d6c:	0802908c 	.word	0x0802908c
 8020d70:	0802904c 	.word	0x0802904c

08020d74 <fileno>:
 8020d74:	b570      	push	{r4, r5, r6, lr}
 8020d76:	4e1a      	ldr	r6, [pc, #104]	; (8020de0 <fileno+0x6c>)
 8020d78:	6835      	ldr	r5, [r6, #0]
 8020d7a:	4604      	mov	r4, r0
 8020d7c:	b125      	cbz	r5, 8020d88 <fileno+0x14>
 8020d7e:	69ab      	ldr	r3, [r5, #24]
 8020d80:	b913      	cbnz	r3, 8020d88 <fileno+0x14>
 8020d82:	4628      	mov	r0, r5
 8020d84:	f000 f88c 	bl	8020ea0 <__sinit>
 8020d88:	4b16      	ldr	r3, [pc, #88]	; (8020de4 <fileno+0x70>)
 8020d8a:	429c      	cmp	r4, r3
 8020d8c:	d118      	bne.n	8020dc0 <fileno+0x4c>
 8020d8e:	686c      	ldr	r4, [r5, #4]
 8020d90:	6e63      	ldr	r3, [r4, #100]	; 0x64
 8020d92:	07d8      	lsls	r0, r3, #31
 8020d94:	d405      	bmi.n	8020da2 <fileno+0x2e>
 8020d96:	89a3      	ldrh	r3, [r4, #12]
 8020d98:	0599      	lsls	r1, r3, #22
 8020d9a:	d402      	bmi.n	8020da2 <fileno+0x2e>
 8020d9c:	6da0      	ldr	r0, [r4, #88]	; 0x58
 8020d9e:	f7e0 fc52 	bl	8001646 <__retarget_lock_acquire_recursive>
 8020da2:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
 8020da6:	b1ab      	cbz	r3, 8020dd4 <fileno+0x60>
 8020da8:	f9b4 500e 	ldrsh.w	r5, [r4, #14]
 8020dac:	6e62      	ldr	r2, [r4, #100]	; 0x64
 8020dae:	07d2      	lsls	r2, r2, #31
 8020db0:	d404      	bmi.n	8020dbc <fileno+0x48>
 8020db2:	059b      	lsls	r3, r3, #22
 8020db4:	d402      	bmi.n	8020dbc <fileno+0x48>
 8020db6:	6da0      	ldr	r0, [r4, #88]	; 0x58
 8020db8:	f7e0 fc59 	bl	800166e <__retarget_lock_release_recursive>
 8020dbc:	4628      	mov	r0, r5
 8020dbe:	bd70      	pop	{r4, r5, r6, pc}
 8020dc0:	4b09      	ldr	r3, [pc, #36]	; (8020de8 <fileno+0x74>)
 8020dc2:	429c      	cmp	r4, r3
 8020dc4:	d101      	bne.n	8020dca <fileno+0x56>
 8020dc6:	68ac      	ldr	r4, [r5, #8]
 8020dc8:	e7e2      	b.n	8020d90 <fileno+0x1c>
 8020dca:	4b08      	ldr	r3, [pc, #32]	; (8020dec <fileno+0x78>)
 8020dcc:	429c      	cmp	r4, r3
 8020dce:	bf08      	it	eq
 8020dd0:	68ec      	ldreq	r4, [r5, #12]
 8020dd2:	e7dd      	b.n	8020d90 <fileno+0x1c>
 8020dd4:	6832      	ldr	r2, [r6, #0]
 8020dd6:	2109      	movs	r1, #9
 8020dd8:	6011      	str	r1, [r2, #0]
 8020dda:	f04f 35ff 	mov.w	r5, #4294967295
 8020dde:	e7e5      	b.n	8020dac <fileno+0x38>
 8020de0:	240004a4 	.word	0x240004a4
 8020de4:	0802906c 	.word	0x0802906c
 8020de8:	0802908c 	.word	0x0802908c
 8020dec:	0802904c 	.word	0x0802904c

08020df0 <std>:
 8020df0:	2300      	movs	r3, #0
 8020df2:	b510      	push	{r4, lr}
 8020df4:	4604      	mov	r4, r0
 8020df6:	e9c0 3300 	strd	r3, r3, [r0]
 8020dfa:	e9c0 3304 	strd	r3, r3, [r0, #16]
 8020dfe:	6083      	str	r3, [r0, #8]
 8020e00:	8181      	strh	r1, [r0, #12]
 8020e02:	6643      	str	r3, [r0, #100]	; 0x64
 8020e04:	81c2      	strh	r2, [r0, #14]
 8020e06:	6183      	str	r3, [r0, #24]
 8020e08:	4619      	mov	r1, r3
 8020e0a:	2208      	movs	r2, #8
 8020e0c:	305c      	adds	r0, #92	; 0x5c
 8020e0e:	f7fe fd35 	bl	801f87c <memset>
 8020e12:	4b05      	ldr	r3, [pc, #20]	; (8020e28 <std+0x38>)
 8020e14:	6263      	str	r3, [r4, #36]	; 0x24
 8020e16:	4b05      	ldr	r3, [pc, #20]	; (8020e2c <std+0x3c>)
 8020e18:	62a3      	str	r3, [r4, #40]	; 0x28
 8020e1a:	4b05      	ldr	r3, [pc, #20]	; (8020e30 <std+0x40>)
 8020e1c:	62e3      	str	r3, [r4, #44]	; 0x2c
 8020e1e:	4b05      	ldr	r3, [pc, #20]	; (8020e34 <std+0x44>)
 8020e20:	6224      	str	r4, [r4, #32]
 8020e22:	6323      	str	r3, [r4, #48]	; 0x30
 8020e24:	bd10      	pop	{r4, pc}
 8020e26:	bf00      	nop
 8020e28:	08020411 	.word	0x08020411
 8020e2c:	08020437 	.word	0x08020437
 8020e30:	0802046f 	.word	0x0802046f
 8020e34:	08020493 	.word	0x08020493

08020e38 <_cleanup_r>:
 8020e38:	4901      	ldr	r1, [pc, #4]	; (8020e40 <_cleanup_r+0x8>)
 8020e3a:	f000 b8af 	b.w	8020f9c <_fwalk_reent>
 8020e3e:	bf00      	nop
 8020e40:	08020cfd 	.word	0x08020cfd

08020e44 <__sfmoreglue>:
 8020e44:	b570      	push	{r4, r5, r6, lr}
 8020e46:	2268      	movs	r2, #104	; 0x68
 8020e48:	1e4d      	subs	r5, r1, #1
 8020e4a:	4355      	muls	r5, r2
 8020e4c:	460e      	mov	r6, r1
 8020e4e:	f105 0174 	add.w	r1, r5, #116	; 0x74
 8020e52:	f7fe fd87 	bl	801f964 <_malloc_r>
 8020e56:	4604      	mov	r4, r0
 8020e58:	b140      	cbz	r0, 8020e6c <__sfmoreglue+0x28>
 8020e5a:	2100      	movs	r1, #0
 8020e5c:	e9c0 1600 	strd	r1, r6, [r0]
 8020e60:	300c      	adds	r0, #12
 8020e62:	60a0      	str	r0, [r4, #8]
 8020e64:	f105 0268 	add.w	r2, r5, #104	; 0x68
 8020e68:	f7fe fd08 	bl	801f87c <memset>
 8020e6c:	4620      	mov	r0, r4
 8020e6e:	bd70      	pop	{r4, r5, r6, pc}

08020e70 <__sfp_lock_acquire>:
 8020e70:	4801      	ldr	r0, [pc, #4]	; (8020e78 <__sfp_lock_acquire+0x8>)
 8020e72:	f7e0 bbe8 	b.w	8001646 <__retarget_lock_acquire_recursive>
 8020e76:	bf00      	nop
 8020e78:	24000af8 	.word	0x24000af8

08020e7c <__sfp_lock_release>:
 8020e7c:	4801      	ldr	r0, [pc, #4]	; (8020e84 <__sfp_lock_release+0x8>)
 8020e7e:	f7e0 bbf6 	b.w	800166e <__retarget_lock_release_recursive>
 8020e82:	bf00      	nop
 8020e84:	24000af8 	.word	0x24000af8

08020e88 <__sinit_lock_acquire>:
 8020e88:	4801      	ldr	r0, [pc, #4]	; (8020e90 <__sinit_lock_acquire+0x8>)
 8020e8a:	f7e0 bbdc 	b.w	8001646 <__retarget_lock_acquire_recursive>
 8020e8e:	bf00      	nop
 8020e90:	24000af4 	.word	0x24000af4

08020e94 <__sinit_lock_release>:
 8020e94:	4801      	ldr	r0, [pc, #4]	; (8020e9c <__sinit_lock_release+0x8>)
 8020e96:	f7e0 bbea 	b.w	800166e <__retarget_lock_release_recursive>
 8020e9a:	bf00      	nop
 8020e9c:	24000af4 	.word	0x24000af4

08020ea0 <__sinit>:
 8020ea0:	b510      	push	{r4, lr}
 8020ea2:	4604      	mov	r4, r0
 8020ea4:	f7ff fff0 	bl	8020e88 <__sinit_lock_acquire>
 8020ea8:	69a3      	ldr	r3, [r4, #24]
 8020eaa:	b11b      	cbz	r3, 8020eb4 <__sinit+0x14>
 8020eac:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
 8020eb0:	f7ff bff0 	b.w	8020e94 <__sinit_lock_release>
 8020eb4:	e9c4 3312 	strd	r3, r3, [r4, #72]	; 0x48
 8020eb8:	6523      	str	r3, [r4, #80]	; 0x50
 8020eba:	4b13      	ldr	r3, [pc, #76]	; (8020f08 <__sinit+0x68>)
 8020ebc:	4a13      	ldr	r2, [pc, #76]	; (8020f0c <__sinit+0x6c>)
 8020ebe:	681b      	ldr	r3, [r3, #0]
 8020ec0:	62a2      	str	r2, [r4, #40]	; 0x28
 8020ec2:	42a3      	cmp	r3, r4
 8020ec4:	bf04      	itt	eq
 8020ec6:	2301      	moveq	r3, #1
 8020ec8:	61a3      	streq	r3, [r4, #24]
 8020eca:	4620      	mov	r0, r4
 8020ecc:	f000 f820 	bl	8020f10 <__sfp>
 8020ed0:	6060      	str	r0, [r4, #4]
 8020ed2:	4620      	mov	r0, r4
 8020ed4:	f000 f81c 	bl	8020f10 <__sfp>
 8020ed8:	60a0      	str	r0, [r4, #8]
 8020eda:	4620      	mov	r0, r4
 8020edc:	f000 f818 	bl	8020f10 <__sfp>
 8020ee0:	2200      	movs	r2, #0
 8020ee2:	60e0      	str	r0, [r4, #12]
 8020ee4:	2104      	movs	r1, #4
 8020ee6:	6860      	ldr	r0, [r4, #4]
 8020ee8:	f7ff ff82 	bl	8020df0 <std>
 8020eec:	68a0      	ldr	r0, [r4, #8]
 8020eee:	2201      	movs	r2, #1
 8020ef0:	2109      	movs	r1, #9
 8020ef2:	f7ff ff7d 	bl	8020df0 <std>
 8020ef6:	68e0      	ldr	r0, [r4, #12]
 8020ef8:	2202      	movs	r2, #2
 8020efa:	2112      	movs	r1, #18
 8020efc:	f7ff ff78 	bl	8020df0 <std>
 8020f00:	2301      	movs	r3, #1
 8020f02:	61a3      	str	r3, [r4, #24]
 8020f04:	e7d2      	b.n	8020eac <__sinit+0xc>
 8020f06:	bf00      	nop
 8020f08:	0802890c 	.word	0x0802890c
 8020f0c:	08020e39 	.word	0x08020e39

08020f10 <__sfp>:
 8020f10:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8020f12:	4607      	mov	r7, r0
 8020f14:	f7ff ffac 	bl	8020e70 <__sfp_lock_acquire>
 8020f18:	4b1e      	ldr	r3, [pc, #120]	; (8020f94 <__sfp+0x84>)
 8020f1a:	681e      	ldr	r6, [r3, #0]
 8020f1c:	69b3      	ldr	r3, [r6, #24]
 8020f1e:	b913      	cbnz	r3, 8020f26 <__sfp+0x16>
 8020f20:	4630      	mov	r0, r6
 8020f22:	f7ff ffbd 	bl	8020ea0 <__sinit>
 8020f26:	3648      	adds	r6, #72	; 0x48
 8020f28:	e9d6 3401 	ldrd	r3, r4, [r6, #4]
 8020f2c:	3b01      	subs	r3, #1
 8020f2e:	d503      	bpl.n	8020f38 <__sfp+0x28>
 8020f30:	6833      	ldr	r3, [r6, #0]
 8020f32:	b30b      	cbz	r3, 8020f78 <__sfp+0x68>
 8020f34:	6836      	ldr	r6, [r6, #0]
 8020f36:	e7f7      	b.n	8020f28 <__sfp+0x18>
 8020f38:	f9b4 500c 	ldrsh.w	r5, [r4, #12]
 8020f3c:	b9d5      	cbnz	r5, 8020f74 <__sfp+0x64>
 8020f3e:	4b16      	ldr	r3, [pc, #88]	; (8020f98 <__sfp+0x88>)
 8020f40:	60e3      	str	r3, [r4, #12]
 8020f42:	f104 0058 	add.w	r0, r4, #88	; 0x58
 8020f46:	6665      	str	r5, [r4, #100]	; 0x64
 8020f48:	f7e0 fb57 	bl	80015fa <__retarget_lock_init_recursive>
 8020f4c:	f7ff ff96 	bl	8020e7c <__sfp_lock_release>
 8020f50:	e9c4 5501 	strd	r5, r5, [r4, #4]
 8020f54:	e9c4 5504 	strd	r5, r5, [r4, #16]
 8020f58:	6025      	str	r5, [r4, #0]
 8020f5a:	61a5      	str	r5, [r4, #24]
 8020f5c:	2208      	movs	r2, #8
 8020f5e:	4629      	mov	r1, r5
 8020f60:	f104 005c 	add.w	r0, r4, #92	; 0x5c
 8020f64:	f7fe fc8a 	bl	801f87c <memset>
 8020f68:	e9c4 550d 	strd	r5, r5, [r4, #52]	; 0x34
 8020f6c:	e9c4 5512 	strd	r5, r5, [r4, #72]	; 0x48
 8020f70:	4620      	mov	r0, r4
 8020f72:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8020f74:	3468      	adds	r4, #104	; 0x68
 8020f76:	e7d9      	b.n	8020f2c <__sfp+0x1c>
 8020f78:	2104      	movs	r1, #4
 8020f7a:	4638      	mov	r0, r7
 8020f7c:	f7ff ff62 	bl	8020e44 <__sfmoreglue>
 8020f80:	4604      	mov	r4, r0
 8020f82:	6030      	str	r0, [r6, #0]
 8020f84:	2800      	cmp	r0, #0
 8020f86:	d1d5      	bne.n	8020f34 <__sfp+0x24>
 8020f88:	f7ff ff78 	bl	8020e7c <__sfp_lock_release>
 8020f8c:	230c      	movs	r3, #12
 8020f8e:	603b      	str	r3, [r7, #0]
 8020f90:	e7ee      	b.n	8020f70 <__sfp+0x60>
 8020f92:	bf00      	nop
 8020f94:	0802890c 	.word	0x0802890c
 8020f98:	ffff0001 	.word	0xffff0001

08020f9c <_fwalk_reent>:
 8020f9c:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 8020fa0:	4606      	mov	r6, r0
 8020fa2:	4688      	mov	r8, r1
 8020fa4:	f100 0448 	add.w	r4, r0, #72	; 0x48
 8020fa8:	2700      	movs	r7, #0
 8020faa:	e9d4 9501 	ldrd	r9, r5, [r4, #4]
 8020fae:	f1b9 0901 	subs.w	r9, r9, #1
 8020fb2:	d505      	bpl.n	8020fc0 <_fwalk_reent+0x24>
 8020fb4:	6824      	ldr	r4, [r4, #0]
 8020fb6:	2c00      	cmp	r4, #0
 8020fb8:	d1f7      	bne.n	8020faa <_fwalk_reent+0xe>
 8020fba:	4638      	mov	r0, r7
 8020fbc:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 8020fc0:	89ab      	ldrh	r3, [r5, #12]
 8020fc2:	2b01      	cmp	r3, #1
 8020fc4:	d907      	bls.n	8020fd6 <_fwalk_reent+0x3a>
 8020fc6:	f9b5 300e 	ldrsh.w	r3, [r5, #14]
 8020fca:	3301      	adds	r3, #1
 8020fcc:	d003      	beq.n	8020fd6 <_fwalk_reent+0x3a>
 8020fce:	4629      	mov	r1, r5
 8020fd0:	4630      	mov	r0, r6
 8020fd2:	47c0      	blx	r8
 8020fd4:	4307      	orrs	r7, r0
 8020fd6:	3568      	adds	r5, #104	; 0x68
 8020fd8:	e7e9      	b.n	8020fae <_fwalk_reent+0x12>
	...

08020fdc <_lseek_r>:
 8020fdc:	b538      	push	{r3, r4, r5, lr}
 8020fde:	4d07      	ldr	r5, [pc, #28]	; (8020ffc <_lseek_r+0x20>)
 8020fe0:	4604      	mov	r4, r0
 8020fe2:	4608      	mov	r0, r1
 8020fe4:	4611      	mov	r1, r2
 8020fe6:	2200      	movs	r2, #0
 8020fe8:	602a      	str	r2, [r5, #0]
 8020fea:	461a      	mov	r2, r3
 8020fec:	f7e0 f970 	bl	80012d0 <_lseek>
 8020ff0:	1c43      	adds	r3, r0, #1
 8020ff2:	d102      	bne.n	8020ffa <_lseek_r+0x1e>
 8020ff4:	682b      	ldr	r3, [r5, #0]
 8020ff6:	b103      	cbz	r3, 8020ffa <_lseek_r+0x1e>
 8020ff8:	6023      	str	r3, [r4, #0]
 8020ffa:	bd38      	pop	{r3, r4, r5, pc}
 8020ffc:	2404d0bc 	.word	0x2404d0bc

08021000 <__swhatbuf_r>:
 8021000:	b570      	push	{r4, r5, r6, lr}
 8021002:	460e      	mov	r6, r1
 8021004:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
 8021008:	2900      	cmp	r1, #0
 802100a:	b096      	sub	sp, #88	; 0x58
 802100c:	4614      	mov	r4, r2
 802100e:	461d      	mov	r5, r3
 8021010:	da08      	bge.n	8021024 <__swhatbuf_r+0x24>
 8021012:	f9b6 300c 	ldrsh.w	r3, [r6, #12]
 8021016:	2200      	movs	r2, #0
 8021018:	602a      	str	r2, [r5, #0]
 802101a:	061a      	lsls	r2, r3, #24
 802101c:	d410      	bmi.n	8021040 <__swhatbuf_r+0x40>
 802101e:	f44f 6380 	mov.w	r3, #1024	; 0x400
 8021022:	e00e      	b.n	8021042 <__swhatbuf_r+0x42>
 8021024:	466a      	mov	r2, sp
 8021026:	f000 fe8f 	bl	8021d48 <_fstat_r>
 802102a:	2800      	cmp	r0, #0
 802102c:	dbf1      	blt.n	8021012 <__swhatbuf_r+0x12>
 802102e:	9a01      	ldr	r2, [sp, #4]
 8021030:	f402 4270 	and.w	r2, r2, #61440	; 0xf000
 8021034:	f5a2 5300 	sub.w	r3, r2, #8192	; 0x2000
 8021038:	425a      	negs	r2, r3
 802103a:	415a      	adcs	r2, r3
 802103c:	602a      	str	r2, [r5, #0]
 802103e:	e7ee      	b.n	802101e <__swhatbuf_r+0x1e>
 8021040:	2340      	movs	r3, #64	; 0x40
 8021042:	2000      	movs	r0, #0
 8021044:	6023      	str	r3, [r4, #0]
 8021046:	b016      	add	sp, #88	; 0x58
 8021048:	bd70      	pop	{r4, r5, r6, pc}
	...

0802104c <__smakebuf_r>:
 802104c:	898b      	ldrh	r3, [r1, #12]
 802104e:	b573      	push	{r0, r1, r4, r5, r6, lr}
 8021050:	079d      	lsls	r5, r3, #30
 8021052:	4606      	mov	r6, r0
 8021054:	460c      	mov	r4, r1
 8021056:	d507      	bpl.n	8021068 <__smakebuf_r+0x1c>
 8021058:	f104 0347 	add.w	r3, r4, #71	; 0x47
 802105c:	6023      	str	r3, [r4, #0]
 802105e:	6123      	str	r3, [r4, #16]
 8021060:	2301      	movs	r3, #1
 8021062:	6163      	str	r3, [r4, #20]
 8021064:	b002      	add	sp, #8
 8021066:	bd70      	pop	{r4, r5, r6, pc}
 8021068:	ab01      	add	r3, sp, #4
 802106a:	466a      	mov	r2, sp
 802106c:	f7ff ffc8 	bl	8021000 <__swhatbuf_r>
 8021070:	9900      	ldr	r1, [sp, #0]
 8021072:	4605      	mov	r5, r0
 8021074:	4630      	mov	r0, r6
 8021076:	f7fe fc75 	bl	801f964 <_malloc_r>
 802107a:	b948      	cbnz	r0, 8021090 <__smakebuf_r+0x44>
 802107c:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
 8021080:	059a      	lsls	r2, r3, #22
 8021082:	d4ef      	bmi.n	8021064 <__smakebuf_r+0x18>
 8021084:	f023 0303 	bic.w	r3, r3, #3
 8021088:	f043 0302 	orr.w	r3, r3, #2
 802108c:	81a3      	strh	r3, [r4, #12]
 802108e:	e7e3      	b.n	8021058 <__smakebuf_r+0xc>
 8021090:	4b0d      	ldr	r3, [pc, #52]	; (80210c8 <__smakebuf_r+0x7c>)
 8021092:	62b3      	str	r3, [r6, #40]	; 0x28
 8021094:	89a3      	ldrh	r3, [r4, #12]
 8021096:	6020      	str	r0, [r4, #0]
 8021098:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 802109c:	81a3      	strh	r3, [r4, #12]
 802109e:	9b00      	ldr	r3, [sp, #0]
 80210a0:	6163      	str	r3, [r4, #20]
 80210a2:	9b01      	ldr	r3, [sp, #4]
 80210a4:	6120      	str	r0, [r4, #16]
 80210a6:	b15b      	cbz	r3, 80210c0 <__smakebuf_r+0x74>
 80210a8:	f9b4 100e 	ldrsh.w	r1, [r4, #14]
 80210ac:	4630      	mov	r0, r6
 80210ae:	f000 fe5d 	bl	8021d6c <_isatty_r>
 80210b2:	b128      	cbz	r0, 80210c0 <__smakebuf_r+0x74>
 80210b4:	89a3      	ldrh	r3, [r4, #12]
 80210b6:	f023 0303 	bic.w	r3, r3, #3
 80210ba:	f043 0301 	orr.w	r3, r3, #1
 80210be:	81a3      	strh	r3, [r4, #12]
 80210c0:	89a0      	ldrh	r0, [r4, #12]
 80210c2:	4305      	orrs	r5, r0
 80210c4:	81a5      	strh	r5, [r4, #12]
 80210c6:	e7cd      	b.n	8021064 <__smakebuf_r+0x18>
 80210c8:	08020e39 	.word	0x08020e39

080210cc <__malloc_lock>:
 80210cc:	4801      	ldr	r0, [pc, #4]	; (80210d4 <__malloc_lock+0x8>)
 80210ce:	f7e0 baba 	b.w	8001646 <__retarget_lock_acquire_recursive>
 80210d2:	bf00      	nop
 80210d4:	24000afc 	.word	0x24000afc

080210d8 <__malloc_unlock>:
 80210d8:	4801      	ldr	r0, [pc, #4]	; (80210e0 <__malloc_unlock+0x8>)
 80210da:	f7e0 bac8 	b.w	800166e <__retarget_lock_release_recursive>
 80210de:	bf00      	nop
 80210e0:	24000afc 	.word	0x24000afc

080210e4 <_realloc_r>:
 80210e4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 80210e8:	4680      	mov	r8, r0
 80210ea:	4614      	mov	r4, r2
 80210ec:	460e      	mov	r6, r1
 80210ee:	b921      	cbnz	r1, 80210fa <_realloc_r+0x16>
 80210f0:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
 80210f4:	4611      	mov	r1, r2
 80210f6:	f7fe bc35 	b.w	801f964 <_malloc_r>
 80210fa:	b92a      	cbnz	r2, 8021108 <_realloc_r+0x24>
 80210fc:	f7fe fbc6 	bl	801f88c <_free_r>
 8021100:	4625      	mov	r5, r4
 8021102:	4628      	mov	r0, r5
 8021104:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8021108:	f000 fe40 	bl	8021d8c <_malloc_usable_size_r>
 802110c:	4284      	cmp	r4, r0
 802110e:	4607      	mov	r7, r0
 8021110:	d802      	bhi.n	8021118 <_realloc_r+0x34>
 8021112:	ebb4 0f50 	cmp.w	r4, r0, lsr #1
 8021116:	d812      	bhi.n	802113e <_realloc_r+0x5a>
 8021118:	4621      	mov	r1, r4
 802111a:	4640      	mov	r0, r8
 802111c:	f7fe fc22 	bl	801f964 <_malloc_r>
 8021120:	4605      	mov	r5, r0
 8021122:	2800      	cmp	r0, #0
 8021124:	d0ed      	beq.n	8021102 <_realloc_r+0x1e>
 8021126:	42bc      	cmp	r4, r7
 8021128:	4622      	mov	r2, r4
 802112a:	4631      	mov	r1, r6
 802112c:	bf28      	it	cs
 802112e:	463a      	movcs	r2, r7
 8021130:	f7fe fb7c 	bl	801f82c <memcpy>
 8021134:	4631      	mov	r1, r6
 8021136:	4640      	mov	r0, r8
 8021138:	f7fe fba8 	bl	801f88c <_free_r>
 802113c:	e7e1      	b.n	8021102 <_realloc_r+0x1e>
 802113e:	4635      	mov	r5, r6
 8021140:	e7df      	b.n	8021102 <_realloc_r+0x1e>

08021142 <__ssputs_r>:
 8021142:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 8021146:	688e      	ldr	r6, [r1, #8]
 8021148:	429e      	cmp	r6, r3
 802114a:	4682      	mov	sl, r0
 802114c:	460c      	mov	r4, r1
 802114e:	4690      	mov	r8, r2
 8021150:	461f      	mov	r7, r3
 8021152:	d838      	bhi.n	80211c6 <__ssputs_r+0x84>
 8021154:	898a      	ldrh	r2, [r1, #12]
 8021156:	f412 6f90 	tst.w	r2, #1152	; 0x480
 802115a:	d032      	beq.n	80211c2 <__ssputs_r+0x80>
 802115c:	6825      	ldr	r5, [r4, #0]
 802115e:	6909      	ldr	r1, [r1, #16]
 8021160:	eba5 0901 	sub.w	r9, r5, r1
 8021164:	6965      	ldr	r5, [r4, #20]
 8021166:	eb05 0545 	add.w	r5, r5, r5, lsl #1
 802116a:	eb05 75d5 	add.w	r5, r5, r5, lsr #31
 802116e:	3301      	adds	r3, #1
 8021170:	444b      	add	r3, r9
 8021172:	106d      	asrs	r5, r5, #1
 8021174:	429d      	cmp	r5, r3
 8021176:	bf38      	it	cc
 8021178:	461d      	movcc	r5, r3
 802117a:	0553      	lsls	r3, r2, #21
 802117c:	d531      	bpl.n	80211e2 <__ssputs_r+0xa0>
 802117e:	4629      	mov	r1, r5
 8021180:	f7fe fbf0 	bl	801f964 <_malloc_r>
 8021184:	4606      	mov	r6, r0
 8021186:	b950      	cbnz	r0, 802119e <__ssputs_r+0x5c>
 8021188:	230c      	movs	r3, #12
 802118a:	f8ca 3000 	str.w	r3, [sl]
 802118e:	89a3      	ldrh	r3, [r4, #12]
 8021190:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 8021194:	81a3      	strh	r3, [r4, #12]
 8021196:	f04f 30ff 	mov.w	r0, #4294967295
 802119a:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 802119e:	6921      	ldr	r1, [r4, #16]
 80211a0:	464a      	mov	r2, r9
 80211a2:	f7fe fb43 	bl	801f82c <memcpy>
 80211a6:	89a3      	ldrh	r3, [r4, #12]
 80211a8:	f423 6390 	bic.w	r3, r3, #1152	; 0x480
 80211ac:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 80211b0:	81a3      	strh	r3, [r4, #12]
 80211b2:	6126      	str	r6, [r4, #16]
 80211b4:	6165      	str	r5, [r4, #20]
 80211b6:	444e      	add	r6, r9
 80211b8:	eba5 0509 	sub.w	r5, r5, r9
 80211bc:	6026      	str	r6, [r4, #0]
 80211be:	60a5      	str	r5, [r4, #8]
 80211c0:	463e      	mov	r6, r7
 80211c2:	42be      	cmp	r6, r7
 80211c4:	d900      	bls.n	80211c8 <__ssputs_r+0x86>
 80211c6:	463e      	mov	r6, r7
 80211c8:	6820      	ldr	r0, [r4, #0]
 80211ca:	4632      	mov	r2, r6
 80211cc:	4641      	mov	r1, r8
 80211ce:	f7fe fb3b 	bl	801f848 <memmove>
 80211d2:	68a3      	ldr	r3, [r4, #8]
 80211d4:	1b9b      	subs	r3, r3, r6
 80211d6:	60a3      	str	r3, [r4, #8]
 80211d8:	6823      	ldr	r3, [r4, #0]
 80211da:	4433      	add	r3, r6
 80211dc:	6023      	str	r3, [r4, #0]
 80211de:	2000      	movs	r0, #0
 80211e0:	e7db      	b.n	802119a <__ssputs_r+0x58>
 80211e2:	462a      	mov	r2, r5
 80211e4:	f7ff ff7e 	bl	80210e4 <_realloc_r>
 80211e8:	4606      	mov	r6, r0
 80211ea:	2800      	cmp	r0, #0
 80211ec:	d1e1      	bne.n	80211b2 <__ssputs_r+0x70>
 80211ee:	6921      	ldr	r1, [r4, #16]
 80211f0:	4650      	mov	r0, sl
 80211f2:	f7fe fb4b 	bl	801f88c <_free_r>
 80211f6:	e7c7      	b.n	8021188 <__ssputs_r+0x46>

080211f8 <_svfiprintf_r>:
 80211f8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80211fc:	4698      	mov	r8, r3
 80211fe:	898b      	ldrh	r3, [r1, #12]
 8021200:	061b      	lsls	r3, r3, #24
 8021202:	b09d      	sub	sp, #116	; 0x74
 8021204:	4607      	mov	r7, r0
 8021206:	460d      	mov	r5, r1
 8021208:	4614      	mov	r4, r2
 802120a:	d50e      	bpl.n	802122a <_svfiprintf_r+0x32>
 802120c:	690b      	ldr	r3, [r1, #16]
 802120e:	b963      	cbnz	r3, 802122a <_svfiprintf_r+0x32>
 8021210:	2140      	movs	r1, #64	; 0x40
 8021212:	f7fe fba7 	bl	801f964 <_malloc_r>
 8021216:	6028      	str	r0, [r5, #0]
 8021218:	6128      	str	r0, [r5, #16]
 802121a:	b920      	cbnz	r0, 8021226 <_svfiprintf_r+0x2e>
 802121c:	230c      	movs	r3, #12
 802121e:	603b      	str	r3, [r7, #0]
 8021220:	f04f 30ff 	mov.w	r0, #4294967295
 8021224:	e0d1      	b.n	80213ca <_svfiprintf_r+0x1d2>
 8021226:	2340      	movs	r3, #64	; 0x40
 8021228:	616b      	str	r3, [r5, #20]
 802122a:	2300      	movs	r3, #0
 802122c:	9309      	str	r3, [sp, #36]	; 0x24
 802122e:	2320      	movs	r3, #32
 8021230:	f88d 3029 	strb.w	r3, [sp, #41]	; 0x29
 8021234:	f8cd 800c 	str.w	r8, [sp, #12]
 8021238:	2330      	movs	r3, #48	; 0x30
 802123a:	f8df 81a8 	ldr.w	r8, [pc, #424]	; 80213e4 <_svfiprintf_r+0x1ec>
 802123e:	f88d 302a 	strb.w	r3, [sp, #42]	; 0x2a
 8021242:	f04f 0901 	mov.w	r9, #1
 8021246:	4623      	mov	r3, r4
 8021248:	469a      	mov	sl, r3
 802124a:	f813 2b01 	ldrb.w	r2, [r3], #1
 802124e:	b10a      	cbz	r2, 8021254 <_svfiprintf_r+0x5c>
 8021250:	2a25      	cmp	r2, #37	; 0x25
 8021252:	d1f9      	bne.n	8021248 <_svfiprintf_r+0x50>
 8021254:	ebba 0b04 	subs.w	fp, sl, r4
 8021258:	d00b      	beq.n	8021272 <_svfiprintf_r+0x7a>
 802125a:	465b      	mov	r3, fp
 802125c:	4622      	mov	r2, r4
 802125e:	4629      	mov	r1, r5
 8021260:	4638      	mov	r0, r7
 8021262:	f7ff ff6e 	bl	8021142 <__ssputs_r>
 8021266:	3001      	adds	r0, #1
 8021268:	f000 80aa 	beq.w	80213c0 <_svfiprintf_r+0x1c8>
 802126c:	9a09      	ldr	r2, [sp, #36]	; 0x24
 802126e:	445a      	add	r2, fp
 8021270:	9209      	str	r2, [sp, #36]	; 0x24
 8021272:	f89a 3000 	ldrb.w	r3, [sl]
 8021276:	2b00      	cmp	r3, #0
 8021278:	f000 80a2 	beq.w	80213c0 <_svfiprintf_r+0x1c8>
 802127c:	2300      	movs	r3, #0
 802127e:	f04f 32ff 	mov.w	r2, #4294967295
 8021282:	e9cd 2305 	strd	r2, r3, [sp, #20]
 8021286:	f10a 0a01 	add.w	sl, sl, #1
 802128a:	9304      	str	r3, [sp, #16]
 802128c:	9307      	str	r3, [sp, #28]
 802128e:	f88d 3053 	strb.w	r3, [sp, #83]	; 0x53
 8021292:	931a      	str	r3, [sp, #104]	; 0x68
 8021294:	4654      	mov	r4, sl
 8021296:	2205      	movs	r2, #5
 8021298:	f814 1b01 	ldrb.w	r1, [r4], #1
 802129c:	4851      	ldr	r0, [pc, #324]	; (80213e4 <_svfiprintf_r+0x1ec>)
 802129e:	f7df f94f 	bl	8000540 <memchr>
 80212a2:	9a04      	ldr	r2, [sp, #16]
 80212a4:	b9d8      	cbnz	r0, 80212de <_svfiprintf_r+0xe6>
 80212a6:	06d0      	lsls	r0, r2, #27
 80212a8:	bf44      	itt	mi
 80212aa:	2320      	movmi	r3, #32
 80212ac:	f88d 3053 	strbmi.w	r3, [sp, #83]	; 0x53
 80212b0:	0711      	lsls	r1, r2, #28
 80212b2:	bf44      	itt	mi
 80212b4:	232b      	movmi	r3, #43	; 0x2b
 80212b6:	f88d 3053 	strbmi.w	r3, [sp, #83]	; 0x53
 80212ba:	f89a 3000 	ldrb.w	r3, [sl]
 80212be:	2b2a      	cmp	r3, #42	; 0x2a
 80212c0:	d015      	beq.n	80212ee <_svfiprintf_r+0xf6>
 80212c2:	9a07      	ldr	r2, [sp, #28]
 80212c4:	4654      	mov	r4, sl
 80212c6:	2000      	movs	r0, #0
 80212c8:	f04f 0c0a 	mov.w	ip, #10
 80212cc:	4621      	mov	r1, r4
 80212ce:	f811 3b01 	ldrb.w	r3, [r1], #1
 80212d2:	3b30      	subs	r3, #48	; 0x30
 80212d4:	2b09      	cmp	r3, #9
 80212d6:	d94e      	bls.n	8021376 <_svfiprintf_r+0x17e>
 80212d8:	b1b0      	cbz	r0, 8021308 <_svfiprintf_r+0x110>
 80212da:	9207      	str	r2, [sp, #28]
 80212dc:	e014      	b.n	8021308 <_svfiprintf_r+0x110>
 80212de:	eba0 0308 	sub.w	r3, r0, r8
 80212e2:	fa09 f303 	lsl.w	r3, r9, r3
 80212e6:	4313      	orrs	r3, r2
 80212e8:	9304      	str	r3, [sp, #16]
 80212ea:	46a2      	mov	sl, r4
 80212ec:	e7d2      	b.n	8021294 <_svfiprintf_r+0x9c>
 80212ee:	9b03      	ldr	r3, [sp, #12]
 80212f0:	1d19      	adds	r1, r3, #4
 80212f2:	681b      	ldr	r3, [r3, #0]
 80212f4:	9103      	str	r1, [sp, #12]
 80212f6:	2b00      	cmp	r3, #0
 80212f8:	bfbb      	ittet	lt
 80212fa:	425b      	neglt	r3, r3
 80212fc:	f042 0202 	orrlt.w	r2, r2, #2
 8021300:	9307      	strge	r3, [sp, #28]
 8021302:	9307      	strlt	r3, [sp, #28]
 8021304:	bfb8      	it	lt
 8021306:	9204      	strlt	r2, [sp, #16]
 8021308:	7823      	ldrb	r3, [r4, #0]
 802130a:	2b2e      	cmp	r3, #46	; 0x2e
 802130c:	d10c      	bne.n	8021328 <_svfiprintf_r+0x130>
 802130e:	7863      	ldrb	r3, [r4, #1]
 8021310:	2b2a      	cmp	r3, #42	; 0x2a
 8021312:	d135      	bne.n	8021380 <_svfiprintf_r+0x188>
 8021314:	9b03      	ldr	r3, [sp, #12]
 8021316:	1d1a      	adds	r2, r3, #4
 8021318:	681b      	ldr	r3, [r3, #0]
 802131a:	9203      	str	r2, [sp, #12]
 802131c:	2b00      	cmp	r3, #0
 802131e:	bfb8      	it	lt
 8021320:	f04f 33ff 	movlt.w	r3, #4294967295
 8021324:	3402      	adds	r4, #2
 8021326:	9305      	str	r3, [sp, #20]
 8021328:	f8df a0c8 	ldr.w	sl, [pc, #200]	; 80213f4 <_svfiprintf_r+0x1fc>
 802132c:	7821      	ldrb	r1, [r4, #0]
 802132e:	2203      	movs	r2, #3
 8021330:	4650      	mov	r0, sl
 8021332:	f7df f905 	bl	8000540 <memchr>
 8021336:	b140      	cbz	r0, 802134a <_svfiprintf_r+0x152>
 8021338:	2340      	movs	r3, #64	; 0x40
 802133a:	eba0 000a 	sub.w	r0, r0, sl
 802133e:	fa03 f000 	lsl.w	r0, r3, r0
 8021342:	9b04      	ldr	r3, [sp, #16]
 8021344:	4303      	orrs	r3, r0
 8021346:	3401      	adds	r4, #1
 8021348:	9304      	str	r3, [sp, #16]
 802134a:	f814 1b01 	ldrb.w	r1, [r4], #1
 802134e:	4826      	ldr	r0, [pc, #152]	; (80213e8 <_svfiprintf_r+0x1f0>)
 8021350:	f88d 1028 	strb.w	r1, [sp, #40]	; 0x28
 8021354:	2206      	movs	r2, #6
 8021356:	f7df f8f3 	bl	8000540 <memchr>
 802135a:	2800      	cmp	r0, #0
 802135c:	d038      	beq.n	80213d0 <_svfiprintf_r+0x1d8>
 802135e:	4b23      	ldr	r3, [pc, #140]	; (80213ec <_svfiprintf_r+0x1f4>)
 8021360:	bb1b      	cbnz	r3, 80213aa <_svfiprintf_r+0x1b2>
 8021362:	9b03      	ldr	r3, [sp, #12]
 8021364:	3307      	adds	r3, #7
 8021366:	f023 0307 	bic.w	r3, r3, #7
 802136a:	3308      	adds	r3, #8
 802136c:	9303      	str	r3, [sp, #12]
 802136e:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8021370:	4433      	add	r3, r6
 8021372:	9309      	str	r3, [sp, #36]	; 0x24
 8021374:	e767      	b.n	8021246 <_svfiprintf_r+0x4e>
 8021376:	fb0c 3202 	mla	r2, ip, r2, r3
 802137a:	460c      	mov	r4, r1
 802137c:	2001      	movs	r0, #1
 802137e:	e7a5      	b.n	80212cc <_svfiprintf_r+0xd4>
 8021380:	2300      	movs	r3, #0
 8021382:	3401      	adds	r4, #1
 8021384:	9305      	str	r3, [sp, #20]
 8021386:	4619      	mov	r1, r3
 8021388:	f04f 0c0a 	mov.w	ip, #10
 802138c:	4620      	mov	r0, r4
 802138e:	f810 2b01 	ldrb.w	r2, [r0], #1
 8021392:	3a30      	subs	r2, #48	; 0x30
 8021394:	2a09      	cmp	r2, #9
 8021396:	d903      	bls.n	80213a0 <_svfiprintf_r+0x1a8>
 8021398:	2b00      	cmp	r3, #0
 802139a:	d0c5      	beq.n	8021328 <_svfiprintf_r+0x130>
 802139c:	9105      	str	r1, [sp, #20]
 802139e:	e7c3      	b.n	8021328 <_svfiprintf_r+0x130>
 80213a0:	fb0c 2101 	mla	r1, ip, r1, r2
 80213a4:	4604      	mov	r4, r0
 80213a6:	2301      	movs	r3, #1
 80213a8:	e7f0      	b.n	802138c <_svfiprintf_r+0x194>
 80213aa:	ab03      	add	r3, sp, #12
 80213ac:	9300      	str	r3, [sp, #0]
 80213ae:	462a      	mov	r2, r5
 80213b0:	4b0f      	ldr	r3, [pc, #60]	; (80213f0 <_svfiprintf_r+0x1f8>)
 80213b2:	a904      	add	r1, sp, #16
 80213b4:	4638      	mov	r0, r7
 80213b6:	f3af 8000 	nop.w
 80213ba:	1c42      	adds	r2, r0, #1
 80213bc:	4606      	mov	r6, r0
 80213be:	d1d6      	bne.n	802136e <_svfiprintf_r+0x176>
 80213c0:	89ab      	ldrh	r3, [r5, #12]
 80213c2:	065b      	lsls	r3, r3, #25
 80213c4:	f53f af2c 	bmi.w	8021220 <_svfiprintf_r+0x28>
 80213c8:	9809      	ldr	r0, [sp, #36]	; 0x24
 80213ca:	b01d      	add	sp, #116	; 0x74
 80213cc:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 80213d0:	ab03      	add	r3, sp, #12
 80213d2:	9300      	str	r3, [sp, #0]
 80213d4:	462a      	mov	r2, r5
 80213d6:	4b06      	ldr	r3, [pc, #24]	; (80213f0 <_svfiprintf_r+0x1f8>)
 80213d8:	a904      	add	r1, sp, #16
 80213da:	4638      	mov	r0, r7
 80213dc:	f7fe fcfe 	bl	801fddc <_printf_i>
 80213e0:	e7eb      	b.n	80213ba <_svfiprintf_r+0x1c2>
 80213e2:	bf00      	nop
 80213e4:	08028910 	.word	0x08028910
 80213e8:	0802891a 	.word	0x0802891a
 80213ec:	00000000 	.word	0x00000000
 80213f0:	08021143 	.word	0x08021143
 80213f4:	08028916 	.word	0x08028916

080213f8 <_sungetc_r>:
 80213f8:	b538      	push	{r3, r4, r5, lr}
 80213fa:	1c4b      	adds	r3, r1, #1
 80213fc:	4614      	mov	r4, r2
 80213fe:	d103      	bne.n	8021408 <_sungetc_r+0x10>
 8021400:	f04f 35ff 	mov.w	r5, #4294967295
 8021404:	4628      	mov	r0, r5
 8021406:	bd38      	pop	{r3, r4, r5, pc}
 8021408:	8993      	ldrh	r3, [r2, #12]
 802140a:	f023 0320 	bic.w	r3, r3, #32
 802140e:	8193      	strh	r3, [r2, #12]
 8021410:	6b63      	ldr	r3, [r4, #52]	; 0x34
 8021412:	6852      	ldr	r2, [r2, #4]
 8021414:	b2cd      	uxtb	r5, r1
 8021416:	b18b      	cbz	r3, 802143c <_sungetc_r+0x44>
 8021418:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 802141a:	4293      	cmp	r3, r2
 802141c:	dd08      	ble.n	8021430 <_sungetc_r+0x38>
 802141e:	6823      	ldr	r3, [r4, #0]
 8021420:	1e5a      	subs	r2, r3, #1
 8021422:	6022      	str	r2, [r4, #0]
 8021424:	f803 5c01 	strb.w	r5, [r3, #-1]
 8021428:	6863      	ldr	r3, [r4, #4]
 802142a:	3301      	adds	r3, #1
 802142c:	6063      	str	r3, [r4, #4]
 802142e:	e7e9      	b.n	8021404 <_sungetc_r+0xc>
 8021430:	4621      	mov	r1, r4
 8021432:	f000 fc4f 	bl	8021cd4 <__submore>
 8021436:	2800      	cmp	r0, #0
 8021438:	d0f1      	beq.n	802141e <_sungetc_r+0x26>
 802143a:	e7e1      	b.n	8021400 <_sungetc_r+0x8>
 802143c:	6921      	ldr	r1, [r4, #16]
 802143e:	6823      	ldr	r3, [r4, #0]
 8021440:	b151      	cbz	r1, 8021458 <_sungetc_r+0x60>
 8021442:	4299      	cmp	r1, r3
 8021444:	d208      	bcs.n	8021458 <_sungetc_r+0x60>
 8021446:	f813 1c01 	ldrb.w	r1, [r3, #-1]
 802144a:	42a9      	cmp	r1, r5
 802144c:	d104      	bne.n	8021458 <_sungetc_r+0x60>
 802144e:	3b01      	subs	r3, #1
 8021450:	3201      	adds	r2, #1
 8021452:	6023      	str	r3, [r4, #0]
 8021454:	6062      	str	r2, [r4, #4]
 8021456:	e7d5      	b.n	8021404 <_sungetc_r+0xc>
 8021458:	e9c4 320f 	strd	r3, r2, [r4, #60]	; 0x3c
 802145c:	f104 0344 	add.w	r3, r4, #68	; 0x44
 8021460:	6363      	str	r3, [r4, #52]	; 0x34
 8021462:	2303      	movs	r3, #3
 8021464:	63a3      	str	r3, [r4, #56]	; 0x38
 8021466:	4623      	mov	r3, r4
 8021468:	f803 5f46 	strb.w	r5, [r3, #70]!
 802146c:	6023      	str	r3, [r4, #0]
 802146e:	2301      	movs	r3, #1
 8021470:	e7dc      	b.n	802142c <_sungetc_r+0x34>

08021472 <__ssrefill_r>:
 8021472:	b510      	push	{r4, lr}
 8021474:	460c      	mov	r4, r1
 8021476:	6b49      	ldr	r1, [r1, #52]	; 0x34
 8021478:	b169      	cbz	r1, 8021496 <__ssrefill_r+0x24>
 802147a:	f104 0344 	add.w	r3, r4, #68	; 0x44
 802147e:	4299      	cmp	r1, r3
 8021480:	d001      	beq.n	8021486 <__ssrefill_r+0x14>
 8021482:	f7fe fa03 	bl	801f88c <_free_r>
 8021486:	6c23      	ldr	r3, [r4, #64]	; 0x40
 8021488:	6063      	str	r3, [r4, #4]
 802148a:	2000      	movs	r0, #0
 802148c:	6360      	str	r0, [r4, #52]	; 0x34
 802148e:	b113      	cbz	r3, 8021496 <__ssrefill_r+0x24>
 8021490:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 8021492:	6023      	str	r3, [r4, #0]
 8021494:	bd10      	pop	{r4, pc}
 8021496:	6923      	ldr	r3, [r4, #16]
 8021498:	6023      	str	r3, [r4, #0]
 802149a:	2300      	movs	r3, #0
 802149c:	6063      	str	r3, [r4, #4]
 802149e:	89a3      	ldrh	r3, [r4, #12]
 80214a0:	f043 0320 	orr.w	r3, r3, #32
 80214a4:	81a3      	strh	r3, [r4, #12]
 80214a6:	f04f 30ff 	mov.w	r0, #4294967295
 80214aa:	e7f3      	b.n	8021494 <__ssrefill_r+0x22>

080214ac <__ssvfiscanf_r>:
 80214ac:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 80214b0:	460c      	mov	r4, r1
 80214b2:	f5ad 7d22 	sub.w	sp, sp, #648	; 0x288
 80214b6:	2100      	movs	r1, #0
 80214b8:	e9cd 1144 	strd	r1, r1, [sp, #272]	; 0x110
 80214bc:	49a6      	ldr	r1, [pc, #664]	; (8021758 <__ssvfiscanf_r+0x2ac>)
 80214be:	91a0      	str	r1, [sp, #640]	; 0x280
 80214c0:	f10d 0804 	add.w	r8, sp, #4
 80214c4:	49a5      	ldr	r1, [pc, #660]	; (802175c <__ssvfiscanf_r+0x2b0>)
 80214c6:	4fa6      	ldr	r7, [pc, #664]	; (8021760 <__ssvfiscanf_r+0x2b4>)
 80214c8:	f8df 9298 	ldr.w	r9, [pc, #664]	; 8021764 <__ssvfiscanf_r+0x2b8>
 80214cc:	f8cd 8118 	str.w	r8, [sp, #280]	; 0x118
 80214d0:	4606      	mov	r6, r0
 80214d2:	91a1      	str	r1, [sp, #644]	; 0x284
 80214d4:	9300      	str	r3, [sp, #0]
 80214d6:	7813      	ldrb	r3, [r2, #0]
 80214d8:	2b00      	cmp	r3, #0
 80214da:	f000 815a 	beq.w	8021792 <__ssvfiscanf_r+0x2e6>
 80214de:	5dd9      	ldrb	r1, [r3, r7]
 80214e0:	f011 0108 	ands.w	r1, r1, #8
 80214e4:	f102 0501 	add.w	r5, r2, #1
 80214e8:	d019      	beq.n	802151e <__ssvfiscanf_r+0x72>
 80214ea:	6863      	ldr	r3, [r4, #4]
 80214ec:	2b00      	cmp	r3, #0
 80214ee:	dd0f      	ble.n	8021510 <__ssvfiscanf_r+0x64>
 80214f0:	6823      	ldr	r3, [r4, #0]
 80214f2:	781a      	ldrb	r2, [r3, #0]
 80214f4:	5cba      	ldrb	r2, [r7, r2]
 80214f6:	0712      	lsls	r2, r2, #28
 80214f8:	d401      	bmi.n	80214fe <__ssvfiscanf_r+0x52>
 80214fa:	462a      	mov	r2, r5
 80214fc:	e7eb      	b.n	80214d6 <__ssvfiscanf_r+0x2a>
 80214fe:	9a45      	ldr	r2, [sp, #276]	; 0x114
 8021500:	3201      	adds	r2, #1
 8021502:	9245      	str	r2, [sp, #276]	; 0x114
 8021504:	6862      	ldr	r2, [r4, #4]
 8021506:	3301      	adds	r3, #1
 8021508:	3a01      	subs	r2, #1
 802150a:	6062      	str	r2, [r4, #4]
 802150c:	6023      	str	r3, [r4, #0]
 802150e:	e7ec      	b.n	80214ea <__ssvfiscanf_r+0x3e>
 8021510:	9ba1      	ldr	r3, [sp, #644]	; 0x284
 8021512:	4621      	mov	r1, r4
 8021514:	4630      	mov	r0, r6
 8021516:	4798      	blx	r3
 8021518:	2800      	cmp	r0, #0
 802151a:	d0e9      	beq.n	80214f0 <__ssvfiscanf_r+0x44>
 802151c:	e7ed      	b.n	80214fa <__ssvfiscanf_r+0x4e>
 802151e:	2b25      	cmp	r3, #37	; 0x25
 8021520:	d012      	beq.n	8021548 <__ssvfiscanf_r+0x9c>
 8021522:	469a      	mov	sl, r3
 8021524:	6863      	ldr	r3, [r4, #4]
 8021526:	2b00      	cmp	r3, #0
 8021528:	f340 8091 	ble.w	802164e <__ssvfiscanf_r+0x1a2>
 802152c:	6822      	ldr	r2, [r4, #0]
 802152e:	7813      	ldrb	r3, [r2, #0]
 8021530:	4553      	cmp	r3, sl
 8021532:	f040 812e 	bne.w	8021792 <__ssvfiscanf_r+0x2e6>
 8021536:	6863      	ldr	r3, [r4, #4]
 8021538:	3b01      	subs	r3, #1
 802153a:	6063      	str	r3, [r4, #4]
 802153c:	9b45      	ldr	r3, [sp, #276]	; 0x114
 802153e:	3201      	adds	r2, #1
 8021540:	3301      	adds	r3, #1
 8021542:	6022      	str	r2, [r4, #0]
 8021544:	9345      	str	r3, [sp, #276]	; 0x114
 8021546:	e7d8      	b.n	80214fa <__ssvfiscanf_r+0x4e>
 8021548:	9141      	str	r1, [sp, #260]	; 0x104
 802154a:	9143      	str	r1, [sp, #268]	; 0x10c
 802154c:	7853      	ldrb	r3, [r2, #1]
 802154e:	2b2a      	cmp	r3, #42	; 0x2a
 8021550:	bf02      	ittt	eq
 8021552:	2310      	moveq	r3, #16
 8021554:	1c95      	addeq	r5, r2, #2
 8021556:	9341      	streq	r3, [sp, #260]	; 0x104
 8021558:	220a      	movs	r2, #10
 802155a:	46aa      	mov	sl, r5
 802155c:	f81a 1b01 	ldrb.w	r1, [sl], #1
 8021560:	f1a1 0330 	sub.w	r3, r1, #48	; 0x30
 8021564:	2b09      	cmp	r3, #9
 8021566:	d91d      	bls.n	80215a4 <__ssvfiscanf_r+0xf8>
 8021568:	487e      	ldr	r0, [pc, #504]	; (8021764 <__ssvfiscanf_r+0x2b8>)
 802156a:	2203      	movs	r2, #3
 802156c:	f7de ffe8 	bl	8000540 <memchr>
 8021570:	b140      	cbz	r0, 8021584 <__ssvfiscanf_r+0xd8>
 8021572:	2301      	movs	r3, #1
 8021574:	eba0 0009 	sub.w	r0, r0, r9
 8021578:	fa03 f000 	lsl.w	r0, r3, r0
 802157c:	9b41      	ldr	r3, [sp, #260]	; 0x104
 802157e:	4318      	orrs	r0, r3
 8021580:	9041      	str	r0, [sp, #260]	; 0x104
 8021582:	4655      	mov	r5, sl
 8021584:	f815 3b01 	ldrb.w	r3, [r5], #1
 8021588:	2b78      	cmp	r3, #120	; 0x78
 802158a:	d806      	bhi.n	802159a <__ssvfiscanf_r+0xee>
 802158c:	2b57      	cmp	r3, #87	; 0x57
 802158e:	d810      	bhi.n	80215b2 <__ssvfiscanf_r+0x106>
 8021590:	2b25      	cmp	r3, #37	; 0x25
 8021592:	d0c6      	beq.n	8021522 <__ssvfiscanf_r+0x76>
 8021594:	d856      	bhi.n	8021644 <__ssvfiscanf_r+0x198>
 8021596:	2b00      	cmp	r3, #0
 8021598:	d064      	beq.n	8021664 <__ssvfiscanf_r+0x1b8>
 802159a:	2303      	movs	r3, #3
 802159c:	9347      	str	r3, [sp, #284]	; 0x11c
 802159e:	230a      	movs	r3, #10
 80215a0:	9342      	str	r3, [sp, #264]	; 0x108
 80215a2:	e071      	b.n	8021688 <__ssvfiscanf_r+0x1dc>
 80215a4:	9b43      	ldr	r3, [sp, #268]	; 0x10c
 80215a6:	fb02 1103 	mla	r1, r2, r3, r1
 80215aa:	3930      	subs	r1, #48	; 0x30
 80215ac:	9143      	str	r1, [sp, #268]	; 0x10c
 80215ae:	4655      	mov	r5, sl
 80215b0:	e7d3      	b.n	802155a <__ssvfiscanf_r+0xae>
 80215b2:	f1a3 0258 	sub.w	r2, r3, #88	; 0x58
 80215b6:	2a20      	cmp	r2, #32
 80215b8:	d8ef      	bhi.n	802159a <__ssvfiscanf_r+0xee>
 80215ba:	a101      	add	r1, pc, #4	; (adr r1, 80215c0 <__ssvfiscanf_r+0x114>)
 80215bc:	f851 f022 	ldr.w	pc, [r1, r2, lsl #2]
 80215c0:	08021673 	.word	0x08021673
 80215c4:	0802159b 	.word	0x0802159b
 80215c8:	0802159b 	.word	0x0802159b
 80215cc:	080216d1 	.word	0x080216d1
 80215d0:	0802159b 	.word	0x0802159b
 80215d4:	0802159b 	.word	0x0802159b
 80215d8:	0802159b 	.word	0x0802159b
 80215dc:	0802159b 	.word	0x0802159b
 80215e0:	0802159b 	.word	0x0802159b
 80215e4:	0802159b 	.word	0x0802159b
 80215e8:	0802159b 	.word	0x0802159b
 80215ec:	080216e7 	.word	0x080216e7
 80215f0:	080216bd 	.word	0x080216bd
 80215f4:	0802164b 	.word	0x0802164b
 80215f8:	0802164b 	.word	0x0802164b
 80215fc:	0802164b 	.word	0x0802164b
 8021600:	0802159b 	.word	0x0802159b
 8021604:	080216c1 	.word	0x080216c1
 8021608:	0802159b 	.word	0x0802159b
 802160c:	0802159b 	.word	0x0802159b
 8021610:	0802159b 	.word	0x0802159b
 8021614:	0802159b 	.word	0x0802159b
 8021618:	080216f7 	.word	0x080216f7
 802161c:	080216c9 	.word	0x080216c9
 8021620:	0802166b 	.word	0x0802166b
 8021624:	0802159b 	.word	0x0802159b
 8021628:	0802159b 	.word	0x0802159b
 802162c:	080216f3 	.word	0x080216f3
 8021630:	0802159b 	.word	0x0802159b
 8021634:	080216bd 	.word	0x080216bd
 8021638:	0802159b 	.word	0x0802159b
 802163c:	0802159b 	.word	0x0802159b
 8021640:	08021673 	.word	0x08021673
 8021644:	3b45      	subs	r3, #69	; 0x45
 8021646:	2b02      	cmp	r3, #2
 8021648:	d8a7      	bhi.n	802159a <__ssvfiscanf_r+0xee>
 802164a:	2305      	movs	r3, #5
 802164c:	e01b      	b.n	8021686 <__ssvfiscanf_r+0x1da>
 802164e:	9ba1      	ldr	r3, [sp, #644]	; 0x284
 8021650:	4621      	mov	r1, r4
 8021652:	4630      	mov	r0, r6
 8021654:	4798      	blx	r3
 8021656:	2800      	cmp	r0, #0
 8021658:	f43f af68 	beq.w	802152c <__ssvfiscanf_r+0x80>
 802165c:	9844      	ldr	r0, [sp, #272]	; 0x110
 802165e:	2800      	cmp	r0, #0
 8021660:	f040 808d 	bne.w	802177e <__ssvfiscanf_r+0x2d2>
 8021664:	f04f 30ff 	mov.w	r0, #4294967295
 8021668:	e08f      	b.n	802178a <__ssvfiscanf_r+0x2de>
 802166a:	9a41      	ldr	r2, [sp, #260]	; 0x104
 802166c:	f042 0220 	orr.w	r2, r2, #32
 8021670:	9241      	str	r2, [sp, #260]	; 0x104
 8021672:	9a41      	ldr	r2, [sp, #260]	; 0x104
 8021674:	f442 7200 	orr.w	r2, r2, #512	; 0x200
 8021678:	9241      	str	r2, [sp, #260]	; 0x104
 802167a:	2210      	movs	r2, #16
 802167c:	2b6f      	cmp	r3, #111	; 0x6f
 802167e:	9242      	str	r2, [sp, #264]	; 0x108
 8021680:	bf34      	ite	cc
 8021682:	2303      	movcc	r3, #3
 8021684:	2304      	movcs	r3, #4
 8021686:	9347      	str	r3, [sp, #284]	; 0x11c
 8021688:	6863      	ldr	r3, [r4, #4]
 802168a:	2b00      	cmp	r3, #0
 802168c:	dd42      	ble.n	8021714 <__ssvfiscanf_r+0x268>
 802168e:	9b41      	ldr	r3, [sp, #260]	; 0x104
 8021690:	0659      	lsls	r1, r3, #25
 8021692:	d404      	bmi.n	802169e <__ssvfiscanf_r+0x1f2>
 8021694:	6823      	ldr	r3, [r4, #0]
 8021696:	781a      	ldrb	r2, [r3, #0]
 8021698:	5cba      	ldrb	r2, [r7, r2]
 802169a:	0712      	lsls	r2, r2, #28
 802169c:	d441      	bmi.n	8021722 <__ssvfiscanf_r+0x276>
 802169e:	9b47      	ldr	r3, [sp, #284]	; 0x11c
 80216a0:	2b02      	cmp	r3, #2
 80216a2:	dc50      	bgt.n	8021746 <__ssvfiscanf_r+0x29a>
 80216a4:	466b      	mov	r3, sp
 80216a6:	4622      	mov	r2, r4
 80216a8:	a941      	add	r1, sp, #260	; 0x104
 80216aa:	4630      	mov	r0, r6
 80216ac:	f000 f876 	bl	802179c <_scanf_chars>
 80216b0:	2801      	cmp	r0, #1
 80216b2:	d06e      	beq.n	8021792 <__ssvfiscanf_r+0x2e6>
 80216b4:	2802      	cmp	r0, #2
 80216b6:	f47f af20 	bne.w	80214fa <__ssvfiscanf_r+0x4e>
 80216ba:	e7cf      	b.n	802165c <__ssvfiscanf_r+0x1b0>
 80216bc:	220a      	movs	r2, #10
 80216be:	e7dd      	b.n	802167c <__ssvfiscanf_r+0x1d0>
 80216c0:	2300      	movs	r3, #0
 80216c2:	9342      	str	r3, [sp, #264]	; 0x108
 80216c4:	2303      	movs	r3, #3
 80216c6:	e7de      	b.n	8021686 <__ssvfiscanf_r+0x1da>
 80216c8:	2308      	movs	r3, #8
 80216ca:	9342      	str	r3, [sp, #264]	; 0x108
 80216cc:	2304      	movs	r3, #4
 80216ce:	e7da      	b.n	8021686 <__ssvfiscanf_r+0x1da>
 80216d0:	4629      	mov	r1, r5
 80216d2:	4640      	mov	r0, r8
 80216d4:	f000 fa0e 	bl	8021af4 <__sccl>
 80216d8:	9b41      	ldr	r3, [sp, #260]	; 0x104
 80216da:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 80216de:	9341      	str	r3, [sp, #260]	; 0x104
 80216e0:	4605      	mov	r5, r0
 80216e2:	2301      	movs	r3, #1
 80216e4:	e7cf      	b.n	8021686 <__ssvfiscanf_r+0x1da>
 80216e6:	9b41      	ldr	r3, [sp, #260]	; 0x104
 80216e8:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 80216ec:	9341      	str	r3, [sp, #260]	; 0x104
 80216ee:	2300      	movs	r3, #0
 80216f0:	e7c9      	b.n	8021686 <__ssvfiscanf_r+0x1da>
 80216f2:	2302      	movs	r3, #2
 80216f4:	e7c7      	b.n	8021686 <__ssvfiscanf_r+0x1da>
 80216f6:	9841      	ldr	r0, [sp, #260]	; 0x104
 80216f8:	06c3      	lsls	r3, r0, #27
 80216fa:	f53f aefe 	bmi.w	80214fa <__ssvfiscanf_r+0x4e>
 80216fe:	9b00      	ldr	r3, [sp, #0]
 8021700:	9a45      	ldr	r2, [sp, #276]	; 0x114
 8021702:	1d19      	adds	r1, r3, #4
 8021704:	9100      	str	r1, [sp, #0]
 8021706:	681b      	ldr	r3, [r3, #0]
 8021708:	f010 0f01 	tst.w	r0, #1
 802170c:	bf14      	ite	ne
 802170e:	801a      	strhne	r2, [r3, #0]
 8021710:	601a      	streq	r2, [r3, #0]
 8021712:	e6f2      	b.n	80214fa <__ssvfiscanf_r+0x4e>
 8021714:	9ba1      	ldr	r3, [sp, #644]	; 0x284
 8021716:	4621      	mov	r1, r4
 8021718:	4630      	mov	r0, r6
 802171a:	4798      	blx	r3
 802171c:	2800      	cmp	r0, #0
 802171e:	d0b6      	beq.n	802168e <__ssvfiscanf_r+0x1e2>
 8021720:	e79c      	b.n	802165c <__ssvfiscanf_r+0x1b0>
 8021722:	9a45      	ldr	r2, [sp, #276]	; 0x114
 8021724:	3201      	adds	r2, #1
 8021726:	9245      	str	r2, [sp, #276]	; 0x114
 8021728:	6862      	ldr	r2, [r4, #4]
 802172a:	3a01      	subs	r2, #1
 802172c:	2a00      	cmp	r2, #0
 802172e:	6062      	str	r2, [r4, #4]
 8021730:	dd02      	ble.n	8021738 <__ssvfiscanf_r+0x28c>
 8021732:	3301      	adds	r3, #1
 8021734:	6023      	str	r3, [r4, #0]
 8021736:	e7ad      	b.n	8021694 <__ssvfiscanf_r+0x1e8>
 8021738:	9ba1      	ldr	r3, [sp, #644]	; 0x284
 802173a:	4621      	mov	r1, r4
 802173c:	4630      	mov	r0, r6
 802173e:	4798      	blx	r3
 8021740:	2800      	cmp	r0, #0
 8021742:	d0a7      	beq.n	8021694 <__ssvfiscanf_r+0x1e8>
 8021744:	e78a      	b.n	802165c <__ssvfiscanf_r+0x1b0>
 8021746:	2b04      	cmp	r3, #4
 8021748:	dc0e      	bgt.n	8021768 <__ssvfiscanf_r+0x2bc>
 802174a:	466b      	mov	r3, sp
 802174c:	4622      	mov	r2, r4
 802174e:	a941      	add	r1, sp, #260	; 0x104
 8021750:	4630      	mov	r0, r6
 8021752:	f000 f87d 	bl	8021850 <_scanf_i>
 8021756:	e7ab      	b.n	80216b0 <__ssvfiscanf_r+0x204>
 8021758:	080213f9 	.word	0x080213f9
 802175c:	08021473 	.word	0x08021473
 8021760:	0802880c 	.word	0x0802880c
 8021764:	08028916 	.word	0x08028916
 8021768:	4b0b      	ldr	r3, [pc, #44]	; (8021798 <__ssvfiscanf_r+0x2ec>)
 802176a:	2b00      	cmp	r3, #0
 802176c:	f43f aec5 	beq.w	80214fa <__ssvfiscanf_r+0x4e>
 8021770:	466b      	mov	r3, sp
 8021772:	4622      	mov	r2, r4
 8021774:	a941      	add	r1, sp, #260	; 0x104
 8021776:	4630      	mov	r0, r6
 8021778:	f3af 8000 	nop.w
 802177c:	e798      	b.n	80216b0 <__ssvfiscanf_r+0x204>
 802177e:	89a3      	ldrh	r3, [r4, #12]
 8021780:	f013 0f40 	tst.w	r3, #64	; 0x40
 8021784:	bf18      	it	ne
 8021786:	f04f 30ff 	movne.w	r0, #4294967295
 802178a:	f50d 7d22 	add.w	sp, sp, #648	; 0x288
 802178e:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8021792:	9844      	ldr	r0, [sp, #272]	; 0x110
 8021794:	e7f9      	b.n	802178a <__ssvfiscanf_r+0x2de>
 8021796:	bf00      	nop
 8021798:	00000000 	.word	0x00000000

0802179c <_scanf_chars>:
 802179c:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 80217a0:	4615      	mov	r5, r2
 80217a2:	688a      	ldr	r2, [r1, #8]
 80217a4:	4680      	mov	r8, r0
 80217a6:	460c      	mov	r4, r1
 80217a8:	b932      	cbnz	r2, 80217b8 <_scanf_chars+0x1c>
 80217aa:	698a      	ldr	r2, [r1, #24]
 80217ac:	2a00      	cmp	r2, #0
 80217ae:	bf0c      	ite	eq
 80217b0:	2201      	moveq	r2, #1
 80217b2:	f04f 32ff 	movne.w	r2, #4294967295
 80217b6:	608a      	str	r2, [r1, #8]
 80217b8:	6822      	ldr	r2, [r4, #0]
 80217ba:	f8df 9090 	ldr.w	r9, [pc, #144]	; 802184c <_scanf_chars+0xb0>
 80217be:	06d1      	lsls	r1, r2, #27
 80217c0:	bf5f      	itttt	pl
 80217c2:	681a      	ldrpl	r2, [r3, #0]
 80217c4:	1d11      	addpl	r1, r2, #4
 80217c6:	6019      	strpl	r1, [r3, #0]
 80217c8:	6816      	ldrpl	r6, [r2, #0]
 80217ca:	2700      	movs	r7, #0
 80217cc:	69a0      	ldr	r0, [r4, #24]
 80217ce:	b188      	cbz	r0, 80217f4 <_scanf_chars+0x58>
 80217d0:	2801      	cmp	r0, #1
 80217d2:	d107      	bne.n	80217e4 <_scanf_chars+0x48>
 80217d4:	682a      	ldr	r2, [r5, #0]
 80217d6:	7811      	ldrb	r1, [r2, #0]
 80217d8:	6962      	ldr	r2, [r4, #20]
 80217da:	5c52      	ldrb	r2, [r2, r1]
 80217dc:	b952      	cbnz	r2, 80217f4 <_scanf_chars+0x58>
 80217de:	2f00      	cmp	r7, #0
 80217e0:	d031      	beq.n	8021846 <_scanf_chars+0xaa>
 80217e2:	e022      	b.n	802182a <_scanf_chars+0x8e>
 80217e4:	2802      	cmp	r0, #2
 80217e6:	d120      	bne.n	802182a <_scanf_chars+0x8e>
 80217e8:	682b      	ldr	r3, [r5, #0]
 80217ea:	781b      	ldrb	r3, [r3, #0]
 80217ec:	f813 3009 	ldrb.w	r3, [r3, r9]
 80217f0:	071b      	lsls	r3, r3, #28
 80217f2:	d41a      	bmi.n	802182a <_scanf_chars+0x8e>
 80217f4:	6823      	ldr	r3, [r4, #0]
 80217f6:	06da      	lsls	r2, r3, #27
 80217f8:	bf5e      	ittt	pl
 80217fa:	682b      	ldrpl	r3, [r5, #0]
 80217fc:	781b      	ldrbpl	r3, [r3, #0]
 80217fe:	f806 3b01 	strbpl.w	r3, [r6], #1
 8021802:	682a      	ldr	r2, [r5, #0]
 8021804:	686b      	ldr	r3, [r5, #4]
 8021806:	3201      	adds	r2, #1
 8021808:	602a      	str	r2, [r5, #0]
 802180a:	68a2      	ldr	r2, [r4, #8]
 802180c:	3b01      	subs	r3, #1
 802180e:	3a01      	subs	r2, #1
 8021810:	606b      	str	r3, [r5, #4]
 8021812:	3701      	adds	r7, #1
 8021814:	60a2      	str	r2, [r4, #8]
 8021816:	b142      	cbz	r2, 802182a <_scanf_chars+0x8e>
 8021818:	2b00      	cmp	r3, #0
 802181a:	dcd7      	bgt.n	80217cc <_scanf_chars+0x30>
 802181c:	f8d4 3180 	ldr.w	r3, [r4, #384]	; 0x180
 8021820:	4629      	mov	r1, r5
 8021822:	4640      	mov	r0, r8
 8021824:	4798      	blx	r3
 8021826:	2800      	cmp	r0, #0
 8021828:	d0d0      	beq.n	80217cc <_scanf_chars+0x30>
 802182a:	6823      	ldr	r3, [r4, #0]
 802182c:	f013 0310 	ands.w	r3, r3, #16
 8021830:	d105      	bne.n	802183e <_scanf_chars+0xa2>
 8021832:	68e2      	ldr	r2, [r4, #12]
 8021834:	3201      	adds	r2, #1
 8021836:	60e2      	str	r2, [r4, #12]
 8021838:	69a2      	ldr	r2, [r4, #24]
 802183a:	b102      	cbz	r2, 802183e <_scanf_chars+0xa2>
 802183c:	7033      	strb	r3, [r6, #0]
 802183e:	6923      	ldr	r3, [r4, #16]
 8021840:	443b      	add	r3, r7
 8021842:	6123      	str	r3, [r4, #16]
 8021844:	2000      	movs	r0, #0
 8021846:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 802184a:	bf00      	nop
 802184c:	0802880c 	.word	0x0802880c

08021850 <_scanf_i>:
 8021850:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8021854:	4698      	mov	r8, r3
 8021856:	4b76      	ldr	r3, [pc, #472]	; (8021a30 <_scanf_i+0x1e0>)
 8021858:	460c      	mov	r4, r1
 802185a:	4682      	mov	sl, r0
 802185c:	4616      	mov	r6, r2
 802185e:	e893 0007 	ldmia.w	r3, {r0, r1, r2}
 8021862:	b087      	sub	sp, #28
 8021864:	ab03      	add	r3, sp, #12
 8021866:	e883 0007 	stmia.w	r3, {r0, r1, r2}
 802186a:	4b72      	ldr	r3, [pc, #456]	; (8021a34 <_scanf_i+0x1e4>)
 802186c:	69a1      	ldr	r1, [r4, #24]
 802186e:	4a72      	ldr	r2, [pc, #456]	; (8021a38 <_scanf_i+0x1e8>)
 8021870:	2903      	cmp	r1, #3
 8021872:	bf18      	it	ne
 8021874:	461a      	movne	r2, r3
 8021876:	68a3      	ldr	r3, [r4, #8]
 8021878:	9201      	str	r2, [sp, #4]
 802187a:	1e5a      	subs	r2, r3, #1
 802187c:	f5b2 7fae 	cmp.w	r2, #348	; 0x15c
 8021880:	bf88      	it	hi
 8021882:	f46f 75ae 	mvnhi.w	r5, #348	; 0x15c
 8021886:	4627      	mov	r7, r4
 8021888:	bf82      	ittt	hi
 802188a:	eb03 0905 	addhi.w	r9, r3, r5
 802188e:	f240 135d 	movwhi	r3, #349	; 0x15d
 8021892:	60a3      	strhi	r3, [r4, #8]
 8021894:	f857 3b1c 	ldr.w	r3, [r7], #28
 8021898:	f443 6350 	orr.w	r3, r3, #3328	; 0xd00
 802189c:	bf98      	it	ls
 802189e:	f04f 0900 	movls.w	r9, #0
 80218a2:	6023      	str	r3, [r4, #0]
 80218a4:	463d      	mov	r5, r7
 80218a6:	f04f 0b00 	mov.w	fp, #0
 80218aa:	6831      	ldr	r1, [r6, #0]
 80218ac:	ab03      	add	r3, sp, #12
 80218ae:	7809      	ldrb	r1, [r1, #0]
 80218b0:	f853 002b 	ldr.w	r0, [r3, fp, lsl #2]
 80218b4:	2202      	movs	r2, #2
 80218b6:	f7de fe43 	bl	8000540 <memchr>
 80218ba:	b328      	cbz	r0, 8021908 <_scanf_i+0xb8>
 80218bc:	f1bb 0f01 	cmp.w	fp, #1
 80218c0:	d159      	bne.n	8021976 <_scanf_i+0x126>
 80218c2:	6862      	ldr	r2, [r4, #4]
 80218c4:	b92a      	cbnz	r2, 80218d2 <_scanf_i+0x82>
 80218c6:	6822      	ldr	r2, [r4, #0]
 80218c8:	2308      	movs	r3, #8
 80218ca:	f442 7200 	orr.w	r2, r2, #512	; 0x200
 80218ce:	6063      	str	r3, [r4, #4]
 80218d0:	6022      	str	r2, [r4, #0]
 80218d2:	6822      	ldr	r2, [r4, #0]
 80218d4:	f422 62a0 	bic.w	r2, r2, #1280	; 0x500
 80218d8:	6022      	str	r2, [r4, #0]
 80218da:	68a2      	ldr	r2, [r4, #8]
 80218dc:	1e51      	subs	r1, r2, #1
 80218de:	60a1      	str	r1, [r4, #8]
 80218e0:	b192      	cbz	r2, 8021908 <_scanf_i+0xb8>
 80218e2:	6832      	ldr	r2, [r6, #0]
 80218e4:	1c51      	adds	r1, r2, #1
 80218e6:	6031      	str	r1, [r6, #0]
 80218e8:	7812      	ldrb	r2, [r2, #0]
 80218ea:	f805 2b01 	strb.w	r2, [r5], #1
 80218ee:	6872      	ldr	r2, [r6, #4]
 80218f0:	3a01      	subs	r2, #1
 80218f2:	2a00      	cmp	r2, #0
 80218f4:	6072      	str	r2, [r6, #4]
 80218f6:	dc07      	bgt.n	8021908 <_scanf_i+0xb8>
 80218f8:	f8d4 2180 	ldr.w	r2, [r4, #384]	; 0x180
 80218fc:	4631      	mov	r1, r6
 80218fe:	4650      	mov	r0, sl
 8021900:	4790      	blx	r2
 8021902:	2800      	cmp	r0, #0
 8021904:	f040 8085 	bne.w	8021a12 <_scanf_i+0x1c2>
 8021908:	f10b 0b01 	add.w	fp, fp, #1
 802190c:	f1bb 0f03 	cmp.w	fp, #3
 8021910:	d1cb      	bne.n	80218aa <_scanf_i+0x5a>
 8021912:	6863      	ldr	r3, [r4, #4]
 8021914:	b90b      	cbnz	r3, 802191a <_scanf_i+0xca>
 8021916:	230a      	movs	r3, #10
 8021918:	6063      	str	r3, [r4, #4]
 802191a:	6863      	ldr	r3, [r4, #4]
 802191c:	4947      	ldr	r1, [pc, #284]	; (8021a3c <_scanf_i+0x1ec>)
 802191e:	6960      	ldr	r0, [r4, #20]
 8021920:	1ac9      	subs	r1, r1, r3
 8021922:	f000 f8e7 	bl	8021af4 <__sccl>
 8021926:	f04f 0b00 	mov.w	fp, #0
 802192a:	68a3      	ldr	r3, [r4, #8]
 802192c:	6822      	ldr	r2, [r4, #0]
 802192e:	2b00      	cmp	r3, #0
 8021930:	d03d      	beq.n	80219ae <_scanf_i+0x15e>
 8021932:	6831      	ldr	r1, [r6, #0]
 8021934:	6960      	ldr	r0, [r4, #20]
 8021936:	f891 c000 	ldrb.w	ip, [r1]
 802193a:	f810 000c 	ldrb.w	r0, [r0, ip]
 802193e:	2800      	cmp	r0, #0
 8021940:	d035      	beq.n	80219ae <_scanf_i+0x15e>
 8021942:	f1bc 0f30 	cmp.w	ip, #48	; 0x30
 8021946:	d124      	bne.n	8021992 <_scanf_i+0x142>
 8021948:	0510      	lsls	r0, r2, #20
 802194a:	d522      	bpl.n	8021992 <_scanf_i+0x142>
 802194c:	f10b 0b01 	add.w	fp, fp, #1
 8021950:	f1b9 0f00 	cmp.w	r9, #0
 8021954:	d003      	beq.n	802195e <_scanf_i+0x10e>
 8021956:	3301      	adds	r3, #1
 8021958:	f109 39ff 	add.w	r9, r9, #4294967295
 802195c:	60a3      	str	r3, [r4, #8]
 802195e:	6873      	ldr	r3, [r6, #4]
 8021960:	3b01      	subs	r3, #1
 8021962:	2b00      	cmp	r3, #0
 8021964:	6073      	str	r3, [r6, #4]
 8021966:	dd1b      	ble.n	80219a0 <_scanf_i+0x150>
 8021968:	6833      	ldr	r3, [r6, #0]
 802196a:	3301      	adds	r3, #1
 802196c:	6033      	str	r3, [r6, #0]
 802196e:	68a3      	ldr	r3, [r4, #8]
 8021970:	3b01      	subs	r3, #1
 8021972:	60a3      	str	r3, [r4, #8]
 8021974:	e7d9      	b.n	802192a <_scanf_i+0xda>
 8021976:	f1bb 0f02 	cmp.w	fp, #2
 802197a:	d1ae      	bne.n	80218da <_scanf_i+0x8a>
 802197c:	6822      	ldr	r2, [r4, #0]
 802197e:	f402 61c0 	and.w	r1, r2, #1536	; 0x600
 8021982:	f5b1 7f00 	cmp.w	r1, #512	; 0x200
 8021986:	d1bf      	bne.n	8021908 <_scanf_i+0xb8>
 8021988:	2310      	movs	r3, #16
 802198a:	6063      	str	r3, [r4, #4]
 802198c:	f442 7280 	orr.w	r2, r2, #256	; 0x100
 8021990:	e7a2      	b.n	80218d8 <_scanf_i+0x88>
 8021992:	f422 6210 	bic.w	r2, r2, #2304	; 0x900
 8021996:	6022      	str	r2, [r4, #0]
 8021998:	780b      	ldrb	r3, [r1, #0]
 802199a:	f805 3b01 	strb.w	r3, [r5], #1
 802199e:	e7de      	b.n	802195e <_scanf_i+0x10e>
 80219a0:	f8d4 3180 	ldr.w	r3, [r4, #384]	; 0x180
 80219a4:	4631      	mov	r1, r6
 80219a6:	4650      	mov	r0, sl
 80219a8:	4798      	blx	r3
 80219aa:	2800      	cmp	r0, #0
 80219ac:	d0df      	beq.n	802196e <_scanf_i+0x11e>
 80219ae:	6823      	ldr	r3, [r4, #0]
 80219b0:	05db      	lsls	r3, r3, #23
 80219b2:	d50d      	bpl.n	80219d0 <_scanf_i+0x180>
 80219b4:	42bd      	cmp	r5, r7
 80219b6:	d909      	bls.n	80219cc <_scanf_i+0x17c>
 80219b8:	f815 1c01 	ldrb.w	r1, [r5, #-1]
 80219bc:	f8d4 317c 	ldr.w	r3, [r4, #380]	; 0x17c
 80219c0:	4632      	mov	r2, r6
 80219c2:	4650      	mov	r0, sl
 80219c4:	4798      	blx	r3
 80219c6:	f105 39ff 	add.w	r9, r5, #4294967295
 80219ca:	464d      	mov	r5, r9
 80219cc:	42bd      	cmp	r5, r7
 80219ce:	d02d      	beq.n	8021a2c <_scanf_i+0x1dc>
 80219d0:	6822      	ldr	r2, [r4, #0]
 80219d2:	f012 0210 	ands.w	r2, r2, #16
 80219d6:	d113      	bne.n	8021a00 <_scanf_i+0x1b0>
 80219d8:	702a      	strb	r2, [r5, #0]
 80219da:	6863      	ldr	r3, [r4, #4]
 80219dc:	9e01      	ldr	r6, [sp, #4]
 80219de:	4639      	mov	r1, r7
 80219e0:	4650      	mov	r0, sl
 80219e2:	47b0      	blx	r6
 80219e4:	6821      	ldr	r1, [r4, #0]
 80219e6:	f8d8 3000 	ldr.w	r3, [r8]
 80219ea:	f011 0f20 	tst.w	r1, #32
 80219ee:	d013      	beq.n	8021a18 <_scanf_i+0x1c8>
 80219f0:	1d1a      	adds	r2, r3, #4
 80219f2:	f8c8 2000 	str.w	r2, [r8]
 80219f6:	681b      	ldr	r3, [r3, #0]
 80219f8:	6018      	str	r0, [r3, #0]
 80219fa:	68e3      	ldr	r3, [r4, #12]
 80219fc:	3301      	adds	r3, #1
 80219fe:	60e3      	str	r3, [r4, #12]
 8021a00:	1bed      	subs	r5, r5, r7
 8021a02:	44ab      	add	fp, r5
 8021a04:	6925      	ldr	r5, [r4, #16]
 8021a06:	445d      	add	r5, fp
 8021a08:	6125      	str	r5, [r4, #16]
 8021a0a:	2000      	movs	r0, #0
 8021a0c:	b007      	add	sp, #28
 8021a0e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8021a12:	f04f 0b00 	mov.w	fp, #0
 8021a16:	e7ca      	b.n	80219ae <_scanf_i+0x15e>
 8021a18:	1d1a      	adds	r2, r3, #4
 8021a1a:	f8c8 2000 	str.w	r2, [r8]
 8021a1e:	681b      	ldr	r3, [r3, #0]
 8021a20:	f011 0f01 	tst.w	r1, #1
 8021a24:	bf14      	ite	ne
 8021a26:	8018      	strhne	r0, [r3, #0]
 8021a28:	6018      	streq	r0, [r3, #0]
 8021a2a:	e7e6      	b.n	80219fa <_scanf_i+0x1aa>
 8021a2c:	2001      	movs	r0, #1
 8021a2e:	e7ed      	b.n	8021a0c <_scanf_i+0x1bc>
 8021a30:	08026210 	.word	0x08026210
 8021a34:	08021cd1 	.word	0x08021cd1
 8021a38:	08020a01 	.word	0x08020a01
 8021a3c:	080290c5 	.word	0x080290c5

08021a40 <_putc_r>:
 8021a40:	b570      	push	{r4, r5, r6, lr}
 8021a42:	460d      	mov	r5, r1
 8021a44:	4614      	mov	r4, r2
 8021a46:	4606      	mov	r6, r0
 8021a48:	b118      	cbz	r0, 8021a52 <_putc_r+0x12>
 8021a4a:	6983      	ldr	r3, [r0, #24]
 8021a4c:	b90b      	cbnz	r3, 8021a52 <_putc_r+0x12>
 8021a4e:	f7ff fa27 	bl	8020ea0 <__sinit>
 8021a52:	4b1c      	ldr	r3, [pc, #112]	; (8021ac4 <_putc_r+0x84>)
 8021a54:	429c      	cmp	r4, r3
 8021a56:	d124      	bne.n	8021aa2 <_putc_r+0x62>
 8021a58:	6874      	ldr	r4, [r6, #4]
 8021a5a:	6e63      	ldr	r3, [r4, #100]	; 0x64
 8021a5c:	07d8      	lsls	r0, r3, #31
 8021a5e:	d405      	bmi.n	8021a6c <_putc_r+0x2c>
 8021a60:	89a3      	ldrh	r3, [r4, #12]
 8021a62:	0599      	lsls	r1, r3, #22
 8021a64:	d402      	bmi.n	8021a6c <_putc_r+0x2c>
 8021a66:	6da0      	ldr	r0, [r4, #88]	; 0x58
 8021a68:	f7df fded 	bl	8001646 <__retarget_lock_acquire_recursive>
 8021a6c:	68a3      	ldr	r3, [r4, #8]
 8021a6e:	3b01      	subs	r3, #1
 8021a70:	2b00      	cmp	r3, #0
 8021a72:	60a3      	str	r3, [r4, #8]
 8021a74:	da05      	bge.n	8021a82 <_putc_r+0x42>
 8021a76:	69a2      	ldr	r2, [r4, #24]
 8021a78:	4293      	cmp	r3, r2
 8021a7a:	db1c      	blt.n	8021ab6 <_putc_r+0x76>
 8021a7c:	b2eb      	uxtb	r3, r5
 8021a7e:	2b0a      	cmp	r3, #10
 8021a80:	d019      	beq.n	8021ab6 <_putc_r+0x76>
 8021a82:	6823      	ldr	r3, [r4, #0]
 8021a84:	1c5a      	adds	r2, r3, #1
 8021a86:	6022      	str	r2, [r4, #0]
 8021a88:	701d      	strb	r5, [r3, #0]
 8021a8a:	b2ed      	uxtb	r5, r5
 8021a8c:	6e63      	ldr	r3, [r4, #100]	; 0x64
 8021a8e:	07da      	lsls	r2, r3, #31
 8021a90:	d405      	bmi.n	8021a9e <_putc_r+0x5e>
 8021a92:	89a3      	ldrh	r3, [r4, #12]
 8021a94:	059b      	lsls	r3, r3, #22
 8021a96:	d402      	bmi.n	8021a9e <_putc_r+0x5e>
 8021a98:	6da0      	ldr	r0, [r4, #88]	; 0x58
 8021a9a:	f7df fde8 	bl	800166e <__retarget_lock_release_recursive>
 8021a9e:	4628      	mov	r0, r5
 8021aa0:	bd70      	pop	{r4, r5, r6, pc}
 8021aa2:	4b09      	ldr	r3, [pc, #36]	; (8021ac8 <_putc_r+0x88>)
 8021aa4:	429c      	cmp	r4, r3
 8021aa6:	d101      	bne.n	8021aac <_putc_r+0x6c>
 8021aa8:	68b4      	ldr	r4, [r6, #8]
 8021aaa:	e7d6      	b.n	8021a5a <_putc_r+0x1a>
 8021aac:	4b07      	ldr	r3, [pc, #28]	; (8021acc <_putc_r+0x8c>)
 8021aae:	429c      	cmp	r4, r3
 8021ab0:	bf08      	it	eq
 8021ab2:	68f4      	ldreq	r4, [r6, #12]
 8021ab4:	e7d1      	b.n	8021a5a <_putc_r+0x1a>
 8021ab6:	4629      	mov	r1, r5
 8021ab8:	4622      	mov	r2, r4
 8021aba:	4630      	mov	r0, r6
 8021abc:	f7fe ffae 	bl	8020a1c <__swbuf_r>
 8021ac0:	4605      	mov	r5, r0
 8021ac2:	e7e3      	b.n	8021a8c <_putc_r+0x4c>
 8021ac4:	0802906c 	.word	0x0802906c
 8021ac8:	0802908c 	.word	0x0802908c
 8021acc:	0802904c 	.word	0x0802904c

08021ad0 <_read_r>:
 8021ad0:	b538      	push	{r3, r4, r5, lr}
 8021ad2:	4d07      	ldr	r5, [pc, #28]	; (8021af0 <_read_r+0x20>)
 8021ad4:	4604      	mov	r4, r0
 8021ad6:	4608      	mov	r0, r1
 8021ad8:	4611      	mov	r1, r2
 8021ada:	2200      	movs	r2, #0
 8021adc:	602a      	str	r2, [r5, #0]
 8021ade:	461a      	mov	r2, r3
 8021ae0:	f7df fb96 	bl	8001210 <_read>
 8021ae4:	1c43      	adds	r3, r0, #1
 8021ae6:	d102      	bne.n	8021aee <_read_r+0x1e>
 8021ae8:	682b      	ldr	r3, [r5, #0]
 8021aea:	b103      	cbz	r3, 8021aee <_read_r+0x1e>
 8021aec:	6023      	str	r3, [r4, #0]
 8021aee:	bd38      	pop	{r3, r4, r5, pc}
 8021af0:	2404d0bc 	.word	0x2404d0bc

08021af4 <__sccl>:
 8021af4:	b570      	push	{r4, r5, r6, lr}
 8021af6:	780b      	ldrb	r3, [r1, #0]
 8021af8:	4604      	mov	r4, r0
 8021afa:	2b5e      	cmp	r3, #94	; 0x5e
 8021afc:	bf0b      	itete	eq
 8021afe:	784b      	ldrbeq	r3, [r1, #1]
 8021b00:	1c48      	addne	r0, r1, #1
 8021b02:	1c88      	addeq	r0, r1, #2
 8021b04:	2200      	movne	r2, #0
 8021b06:	bf08      	it	eq
 8021b08:	2201      	moveq	r2, #1
 8021b0a:	1e61      	subs	r1, r4, #1
 8021b0c:	f104 05ff 	add.w	r5, r4, #255	; 0xff
 8021b10:	f801 2f01 	strb.w	r2, [r1, #1]!
 8021b14:	42a9      	cmp	r1, r5
 8021b16:	d1fb      	bne.n	8021b10 <__sccl+0x1c>
 8021b18:	b90b      	cbnz	r3, 8021b1e <__sccl+0x2a>
 8021b1a:	3801      	subs	r0, #1
 8021b1c:	bd70      	pop	{r4, r5, r6, pc}
 8021b1e:	f082 0201 	eor.w	r2, r2, #1
 8021b22:	54e2      	strb	r2, [r4, r3]
 8021b24:	4605      	mov	r5, r0
 8021b26:	4628      	mov	r0, r5
 8021b28:	f810 1b01 	ldrb.w	r1, [r0], #1
 8021b2c:	292d      	cmp	r1, #45	; 0x2d
 8021b2e:	d006      	beq.n	8021b3e <__sccl+0x4a>
 8021b30:	295d      	cmp	r1, #93	; 0x5d
 8021b32:	d0f3      	beq.n	8021b1c <__sccl+0x28>
 8021b34:	b909      	cbnz	r1, 8021b3a <__sccl+0x46>
 8021b36:	4628      	mov	r0, r5
 8021b38:	e7f0      	b.n	8021b1c <__sccl+0x28>
 8021b3a:	460b      	mov	r3, r1
 8021b3c:	e7f1      	b.n	8021b22 <__sccl+0x2e>
 8021b3e:	786e      	ldrb	r6, [r5, #1]
 8021b40:	2e5d      	cmp	r6, #93	; 0x5d
 8021b42:	d0fa      	beq.n	8021b3a <__sccl+0x46>
 8021b44:	42b3      	cmp	r3, r6
 8021b46:	dcf8      	bgt.n	8021b3a <__sccl+0x46>
 8021b48:	3502      	adds	r5, #2
 8021b4a:	4619      	mov	r1, r3
 8021b4c:	3101      	adds	r1, #1
 8021b4e:	428e      	cmp	r6, r1
 8021b50:	5462      	strb	r2, [r4, r1]
 8021b52:	dcfb      	bgt.n	8021b4c <__sccl+0x58>
 8021b54:	1af1      	subs	r1, r6, r3
 8021b56:	3901      	subs	r1, #1
 8021b58:	1c58      	adds	r0, r3, #1
 8021b5a:	42b3      	cmp	r3, r6
 8021b5c:	bfa8      	it	ge
 8021b5e:	2100      	movge	r1, #0
 8021b60:	1843      	adds	r3, r0, r1
 8021b62:	e7e0      	b.n	8021b26 <__sccl+0x32>

08021b64 <_raise_r>:
 8021b64:	291f      	cmp	r1, #31
 8021b66:	b538      	push	{r3, r4, r5, lr}
 8021b68:	4604      	mov	r4, r0
 8021b6a:	460d      	mov	r5, r1
 8021b6c:	d904      	bls.n	8021b78 <_raise_r+0x14>
 8021b6e:	2316      	movs	r3, #22
 8021b70:	6003      	str	r3, [r0, #0]
 8021b72:	f04f 30ff 	mov.w	r0, #4294967295
 8021b76:	bd38      	pop	{r3, r4, r5, pc}
 8021b78:	6c42      	ldr	r2, [r0, #68]	; 0x44
 8021b7a:	b112      	cbz	r2, 8021b82 <_raise_r+0x1e>
 8021b7c:	f852 3021 	ldr.w	r3, [r2, r1, lsl #2]
 8021b80:	b94b      	cbnz	r3, 8021b96 <_raise_r+0x32>
 8021b82:	4620      	mov	r0, r4
 8021b84:	f000 f830 	bl	8021be8 <_getpid_r>
 8021b88:	462a      	mov	r2, r5
 8021b8a:	4601      	mov	r1, r0
 8021b8c:	4620      	mov	r0, r4
 8021b8e:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
 8021b92:	f000 b817 	b.w	8021bc4 <_kill_r>
 8021b96:	2b01      	cmp	r3, #1
 8021b98:	d00a      	beq.n	8021bb0 <_raise_r+0x4c>
 8021b9a:	1c59      	adds	r1, r3, #1
 8021b9c:	d103      	bne.n	8021ba6 <_raise_r+0x42>
 8021b9e:	2316      	movs	r3, #22
 8021ba0:	6003      	str	r3, [r0, #0]
 8021ba2:	2001      	movs	r0, #1
 8021ba4:	e7e7      	b.n	8021b76 <_raise_r+0x12>
 8021ba6:	2400      	movs	r4, #0
 8021ba8:	f842 4025 	str.w	r4, [r2, r5, lsl #2]
 8021bac:	4628      	mov	r0, r5
 8021bae:	4798      	blx	r3
 8021bb0:	2000      	movs	r0, #0
 8021bb2:	e7e0      	b.n	8021b76 <_raise_r+0x12>

08021bb4 <raise>:
 8021bb4:	4b02      	ldr	r3, [pc, #8]	; (8021bc0 <raise+0xc>)
 8021bb6:	4601      	mov	r1, r0
 8021bb8:	6818      	ldr	r0, [r3, #0]
 8021bba:	f7ff bfd3 	b.w	8021b64 <_raise_r>
 8021bbe:	bf00      	nop
 8021bc0:	240004a4 	.word	0x240004a4

08021bc4 <_kill_r>:
 8021bc4:	b538      	push	{r3, r4, r5, lr}
 8021bc6:	4d07      	ldr	r5, [pc, #28]	; (8021be4 <_kill_r+0x20>)
 8021bc8:	2300      	movs	r3, #0
 8021bca:	4604      	mov	r4, r0
 8021bcc:	4608      	mov	r0, r1
 8021bce:	4611      	mov	r1, r2
 8021bd0:	602b      	str	r3, [r5, #0]
 8021bd2:	f7df fb03 	bl	80011dc <_kill>
 8021bd6:	1c43      	adds	r3, r0, #1
 8021bd8:	d102      	bne.n	8021be0 <_kill_r+0x1c>
 8021bda:	682b      	ldr	r3, [r5, #0]
 8021bdc:	b103      	cbz	r3, 8021be0 <_kill_r+0x1c>
 8021bde:	6023      	str	r3, [r4, #0]
 8021be0:	bd38      	pop	{r3, r4, r5, pc}
 8021be2:	bf00      	nop
 8021be4:	2404d0bc 	.word	0x2404d0bc

08021be8 <_getpid_r>:
 8021be8:	f7df baf0 	b.w	80011cc <_getpid>

08021bec <_strtoul_l.constprop.0>:
 8021bec:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 8021bf0:	4f36      	ldr	r7, [pc, #216]	; (8021ccc <_strtoul_l.constprop.0+0xe0>)
 8021bf2:	4686      	mov	lr, r0
 8021bf4:	460d      	mov	r5, r1
 8021bf6:	4628      	mov	r0, r5
 8021bf8:	f815 4b01 	ldrb.w	r4, [r5], #1
 8021bfc:	5de6      	ldrb	r6, [r4, r7]
 8021bfe:	f016 0608 	ands.w	r6, r6, #8
 8021c02:	d1f8      	bne.n	8021bf6 <_strtoul_l.constprop.0+0xa>
 8021c04:	2c2d      	cmp	r4, #45	; 0x2d
 8021c06:	d12f      	bne.n	8021c68 <_strtoul_l.constprop.0+0x7c>
 8021c08:	782c      	ldrb	r4, [r5, #0]
 8021c0a:	2601      	movs	r6, #1
 8021c0c:	1c85      	adds	r5, r0, #2
 8021c0e:	2b00      	cmp	r3, #0
 8021c10:	d057      	beq.n	8021cc2 <_strtoul_l.constprop.0+0xd6>
 8021c12:	2b10      	cmp	r3, #16
 8021c14:	d109      	bne.n	8021c2a <_strtoul_l.constprop.0+0x3e>
 8021c16:	2c30      	cmp	r4, #48	; 0x30
 8021c18:	d107      	bne.n	8021c2a <_strtoul_l.constprop.0+0x3e>
 8021c1a:	7828      	ldrb	r0, [r5, #0]
 8021c1c:	f000 00df 	and.w	r0, r0, #223	; 0xdf
 8021c20:	2858      	cmp	r0, #88	; 0x58
 8021c22:	d149      	bne.n	8021cb8 <_strtoul_l.constprop.0+0xcc>
 8021c24:	786c      	ldrb	r4, [r5, #1]
 8021c26:	2310      	movs	r3, #16
 8021c28:	3502      	adds	r5, #2
 8021c2a:	f04f 38ff 	mov.w	r8, #4294967295
 8021c2e:	2700      	movs	r7, #0
 8021c30:	fbb8 f8f3 	udiv	r8, r8, r3
 8021c34:	fb03 f908 	mul.w	r9, r3, r8
 8021c38:	ea6f 0909 	mvn.w	r9, r9
 8021c3c:	4638      	mov	r0, r7
 8021c3e:	f1a4 0c30 	sub.w	ip, r4, #48	; 0x30
 8021c42:	f1bc 0f09 	cmp.w	ip, #9
 8021c46:	d814      	bhi.n	8021c72 <_strtoul_l.constprop.0+0x86>
 8021c48:	4664      	mov	r4, ip
 8021c4a:	42a3      	cmp	r3, r4
 8021c4c:	dd22      	ble.n	8021c94 <_strtoul_l.constprop.0+0xa8>
 8021c4e:	2f00      	cmp	r7, #0
 8021c50:	db1d      	blt.n	8021c8e <_strtoul_l.constprop.0+0xa2>
 8021c52:	4580      	cmp	r8, r0
 8021c54:	d31b      	bcc.n	8021c8e <_strtoul_l.constprop.0+0xa2>
 8021c56:	d101      	bne.n	8021c5c <_strtoul_l.constprop.0+0x70>
 8021c58:	45a1      	cmp	r9, r4
 8021c5a:	db18      	blt.n	8021c8e <_strtoul_l.constprop.0+0xa2>
 8021c5c:	fb00 4003 	mla	r0, r0, r3, r4
 8021c60:	2701      	movs	r7, #1
 8021c62:	f815 4b01 	ldrb.w	r4, [r5], #1
 8021c66:	e7ea      	b.n	8021c3e <_strtoul_l.constprop.0+0x52>
 8021c68:	2c2b      	cmp	r4, #43	; 0x2b
 8021c6a:	bf04      	itt	eq
 8021c6c:	782c      	ldrbeq	r4, [r5, #0]
 8021c6e:	1c85      	addeq	r5, r0, #2
 8021c70:	e7cd      	b.n	8021c0e <_strtoul_l.constprop.0+0x22>
 8021c72:	f1a4 0c41 	sub.w	ip, r4, #65	; 0x41
 8021c76:	f1bc 0f19 	cmp.w	ip, #25
 8021c7a:	d801      	bhi.n	8021c80 <_strtoul_l.constprop.0+0x94>
 8021c7c:	3c37      	subs	r4, #55	; 0x37
 8021c7e:	e7e4      	b.n	8021c4a <_strtoul_l.constprop.0+0x5e>
 8021c80:	f1a4 0c61 	sub.w	ip, r4, #97	; 0x61
 8021c84:	f1bc 0f19 	cmp.w	ip, #25
 8021c88:	d804      	bhi.n	8021c94 <_strtoul_l.constprop.0+0xa8>
 8021c8a:	3c57      	subs	r4, #87	; 0x57
 8021c8c:	e7dd      	b.n	8021c4a <_strtoul_l.constprop.0+0x5e>
 8021c8e:	f04f 37ff 	mov.w	r7, #4294967295
 8021c92:	e7e6      	b.n	8021c62 <_strtoul_l.constprop.0+0x76>
 8021c94:	2f00      	cmp	r7, #0
 8021c96:	da07      	bge.n	8021ca8 <_strtoul_l.constprop.0+0xbc>
 8021c98:	2322      	movs	r3, #34	; 0x22
 8021c9a:	f8ce 3000 	str.w	r3, [lr]
 8021c9e:	f04f 30ff 	mov.w	r0, #4294967295
 8021ca2:	b932      	cbnz	r2, 8021cb2 <_strtoul_l.constprop.0+0xc6>
 8021ca4:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 8021ca8:	b106      	cbz	r6, 8021cac <_strtoul_l.constprop.0+0xc0>
 8021caa:	4240      	negs	r0, r0
 8021cac:	2a00      	cmp	r2, #0
 8021cae:	d0f9      	beq.n	8021ca4 <_strtoul_l.constprop.0+0xb8>
 8021cb0:	b107      	cbz	r7, 8021cb4 <_strtoul_l.constprop.0+0xc8>
 8021cb2:	1e69      	subs	r1, r5, #1
 8021cb4:	6011      	str	r1, [r2, #0]
 8021cb6:	e7f5      	b.n	8021ca4 <_strtoul_l.constprop.0+0xb8>
 8021cb8:	2430      	movs	r4, #48	; 0x30
 8021cba:	2b00      	cmp	r3, #0
 8021cbc:	d1b5      	bne.n	8021c2a <_strtoul_l.constprop.0+0x3e>
 8021cbe:	2308      	movs	r3, #8
 8021cc0:	e7b3      	b.n	8021c2a <_strtoul_l.constprop.0+0x3e>
 8021cc2:	2c30      	cmp	r4, #48	; 0x30
 8021cc4:	d0a9      	beq.n	8021c1a <_strtoul_l.constprop.0+0x2e>
 8021cc6:	230a      	movs	r3, #10
 8021cc8:	e7af      	b.n	8021c2a <_strtoul_l.constprop.0+0x3e>
 8021cca:	bf00      	nop
 8021ccc:	0802880c 	.word	0x0802880c

08021cd0 <_strtoul_r>:
 8021cd0:	f7ff bf8c 	b.w	8021bec <_strtoul_l.constprop.0>

08021cd4 <__submore>:
 8021cd4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8021cd8:	460c      	mov	r4, r1
 8021cda:	6b49      	ldr	r1, [r1, #52]	; 0x34
 8021cdc:	f104 0344 	add.w	r3, r4, #68	; 0x44
 8021ce0:	4299      	cmp	r1, r3
 8021ce2:	d11d      	bne.n	8021d20 <__submore+0x4c>
 8021ce4:	f44f 6180 	mov.w	r1, #1024	; 0x400
 8021ce8:	f7fd fe3c 	bl	801f964 <_malloc_r>
 8021cec:	b918      	cbnz	r0, 8021cf6 <__submore+0x22>
 8021cee:	f04f 30ff 	mov.w	r0, #4294967295
 8021cf2:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8021cf6:	f44f 6380 	mov.w	r3, #1024	; 0x400
 8021cfa:	63a3      	str	r3, [r4, #56]	; 0x38
 8021cfc:	f894 3046 	ldrb.w	r3, [r4, #70]	; 0x46
 8021d00:	6360      	str	r0, [r4, #52]	; 0x34
 8021d02:	f880 33ff 	strb.w	r3, [r0, #1023]	; 0x3ff
 8021d06:	f894 3045 	ldrb.w	r3, [r4, #69]	; 0x45
 8021d0a:	f880 33fe 	strb.w	r3, [r0, #1022]	; 0x3fe
 8021d0e:	f894 3044 	ldrb.w	r3, [r4, #68]	; 0x44
 8021d12:	f880 33fd 	strb.w	r3, [r0, #1021]	; 0x3fd
 8021d16:	f200 30fd 	addw	r0, r0, #1021	; 0x3fd
 8021d1a:	6020      	str	r0, [r4, #0]
 8021d1c:	2000      	movs	r0, #0
 8021d1e:	e7e8      	b.n	8021cf2 <__submore+0x1e>
 8021d20:	6ba6      	ldr	r6, [r4, #56]	; 0x38
 8021d22:	0077      	lsls	r7, r6, #1
 8021d24:	463a      	mov	r2, r7
 8021d26:	f7ff f9dd 	bl	80210e4 <_realloc_r>
 8021d2a:	4605      	mov	r5, r0
 8021d2c:	2800      	cmp	r0, #0
 8021d2e:	d0de      	beq.n	8021cee <__submore+0x1a>
 8021d30:	eb00 0806 	add.w	r8, r0, r6
 8021d34:	4601      	mov	r1, r0
 8021d36:	4632      	mov	r2, r6
 8021d38:	4640      	mov	r0, r8
 8021d3a:	f7fd fd77 	bl	801f82c <memcpy>
 8021d3e:	e9c4 570d 	strd	r5, r7, [r4, #52]	; 0x34
 8021d42:	f8c4 8000 	str.w	r8, [r4]
 8021d46:	e7e9      	b.n	8021d1c <__submore+0x48>

08021d48 <_fstat_r>:
 8021d48:	b538      	push	{r3, r4, r5, lr}
 8021d4a:	4d07      	ldr	r5, [pc, #28]	; (8021d68 <_fstat_r+0x20>)
 8021d4c:	2300      	movs	r3, #0
 8021d4e:	4604      	mov	r4, r0
 8021d50:	4608      	mov	r0, r1
 8021d52:	4611      	mov	r1, r2
 8021d54:	602b      	str	r3, [r5, #0]
 8021d56:	f7df faa0 	bl	800129a <_fstat>
 8021d5a:	1c43      	adds	r3, r0, #1
 8021d5c:	d102      	bne.n	8021d64 <_fstat_r+0x1c>
 8021d5e:	682b      	ldr	r3, [r5, #0]
 8021d60:	b103      	cbz	r3, 8021d64 <_fstat_r+0x1c>
 8021d62:	6023      	str	r3, [r4, #0]
 8021d64:	bd38      	pop	{r3, r4, r5, pc}
 8021d66:	bf00      	nop
 8021d68:	2404d0bc 	.word	0x2404d0bc

08021d6c <_isatty_r>:
 8021d6c:	b538      	push	{r3, r4, r5, lr}
 8021d6e:	4d06      	ldr	r5, [pc, #24]	; (8021d88 <_isatty_r+0x1c>)
 8021d70:	2300      	movs	r3, #0
 8021d72:	4604      	mov	r4, r0
 8021d74:	4608      	mov	r0, r1
 8021d76:	602b      	str	r3, [r5, #0]
 8021d78:	f7df fa9f 	bl	80012ba <_isatty>
 8021d7c:	1c43      	adds	r3, r0, #1
 8021d7e:	d102      	bne.n	8021d86 <_isatty_r+0x1a>
 8021d80:	682b      	ldr	r3, [r5, #0]
 8021d82:	b103      	cbz	r3, 8021d86 <_isatty_r+0x1a>
 8021d84:	6023      	str	r3, [r4, #0]
 8021d86:	bd38      	pop	{r3, r4, r5, pc}
 8021d88:	2404d0bc 	.word	0x2404d0bc

08021d8c <_malloc_usable_size_r>:
 8021d8c:	f851 3c04 	ldr.w	r3, [r1, #-4]
 8021d90:	1f18      	subs	r0, r3, #4
 8021d92:	2b00      	cmp	r3, #0
 8021d94:	bfbc      	itt	lt
 8021d96:	580b      	ldrlt	r3, [r1, r0]
 8021d98:	18c0      	addlt	r0, r0, r3
 8021d9a:	4770      	bx	lr

08021d9c <_init>:
 8021d9c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8021d9e:	bf00      	nop
 8021da0:	bcf8      	pop	{r3, r4, r5, r6, r7}
 8021da2:	bc08      	pop	{r3}
 8021da4:	469e      	mov	lr, r3
 8021da6:	4770      	bx	lr

08021da8 <_fini>:
 8021da8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8021daa:	bf00      	nop
 8021dac:	bcf8      	pop	{r3, r4, r5, r6, r7}
 8021dae:	bc08      	pop	{r3}
 8021db0:	469e      	mov	lr, r3
 8021db2:	4770      	bx	lr
